<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/networking/websocket.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-websocket"></target>
    <section ids="using-websockets doc-websocket" names="using\ websockets doc_websocket">
        <title>Using WebSockets</title>
        <section ids="html5-and-websocket" names="html5\ and\ websocket">
            <title>HTML5 and WebSocket</title>
            <paragraph>The WebSocket protocol was standardized in 2011 with the original goal of allowing browsers to create stable and bidirectional connections with a server.
                Before that, browsers used to only support HTTP requests, which aren't well-suited for bidirectional communication.</paragraph>
            <paragraph>The protocol is message-based and a very powerful tool to send push notifications to browsers. It has been used to implement chats, turn-based games, and more. It still uses a TCP connection, which is good for reliability but not for latency, so it's not good for real-time applications like VoIP and fast-paced games (see <reference internal="True" refuri="webrtc#doc-webrtc"><inline classes="std std-ref">WebRTC</inline></reference> for those use cases).</paragraph>
            <paragraph>Due to its simplicity, its wide compatibility, and being easier to use than a raw TCP connection, WebSocket started to spread outside the browsers, in native applications as a mean to communicate with network servers.</paragraph>
            <paragraph>Godot supports WebSocket in both native and web exports.</paragraph>
        </section>
        <section ids="using-websocket-in-godot" names="using\ websocket\ in\ godot">
            <title>Using WebSocket in Godot</title>
            <paragraph>WebSocket is implemented in Godot via <reference internal="True" refuri="../../classes/class_websocketpeer#class-websocketpeer"><inline classes="std std-ref">WebSocketPeer</inline></reference>.
                The WebSocket implementation is compatible with the High-Level Multiplayer. See
                section on <reference internal="True" refuri="high_level_multiplayer#doc-high-level-multiplayer"><inline classes="std std-ref">high-level multiplayer</inline></reference> for more
                details.</paragraph>
            <warning>
                <paragraph>When exporting to Android, make sure to enable the <literal>INTERNET</literal>
                    permission in the Android export preset before exporting the project or
                    using one-click deploy. Otherwise, network communication of any kind will be
                    blocked by Android.</paragraph>
            </warning>
            <section ids="minimal-client-example" names="minimal\ client\ example">
                <title>Minimal client example</title>
                <paragraph>This example will show you how to create a WebSocket connection to a remote server, and how to send and receive data.</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node

# The URL we will connect to.
# Use "ws://localhost:9080" if testing with the minimal server example below.
# `wss://` is used for secure connections,
# while `ws://` is used for plain text (insecure) connections.
@export var websocket_url = "wss://echo.websocket.org"

# Our WebSocketClient instance.
var socket = WebSocketPeer.new()


func _ready():
    # Initiate connection to the given URL.
    var err = socket.connect_to_url(websocket_url)
    if err == OK:
        print("Connecting to %s..." % websocket_url)
        # Wait for the socket to connect.
        await get_tree().create_timer(2).timeout

        # Send data.
        print("&gt; Sending test packet.")
        socket.send_text("Test packet")
    else:
        push_error("Unable to connect.")
        set_process(false)


func _process(_delta):
    # Call this in `_process()` or `_physics_process()`.
    # Data transfer and state updates will only happen when calling this function.
    socket.poll()

    # get_ready_state() tells you what state the socket is in.
    var state = socket.get_ready_state()

    # `WebSocketPeer.STATE_OPEN` means the socket is connected and ready
    # to send and receive data.
    if state == WebSocketPeer.STATE_OPEN:
        while socket.get_available_packet_count():
            var packet = socket.get_packet()
            if socket.was_string_packet():
                var packet_text = packet.get_string_from_utf8()
                print("&lt; Got text data from server: %s" % packet_text)
            else:
                print("&lt; Got binary data from server: %d bytes" % packet.size())

    # `WebSocketPeer.STATE_CLOSING` means the socket is closing.
    # It is important to keep polling for a clean close.
    elif state == WebSocketPeer.STATE_CLOSING:
        pass

    # `WebSocketPeer.STATE_CLOSED` means the connection has fully closed.
    # It is now safe to stop polling.
    elif state == WebSocketPeer.STATE_CLOSED:
        # The code will be `-1` if the disconnection was not properly notified by the remote peer.
        var code = socket.get_close_code()
        print("WebSocket closed with code: %d. Clean: %s" % [code, code != -1])
        set_process(false) # Stop processing.</literal_block>
                <paragraph>This will print something similar to:</paragraph>
                <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Connecting to wss://echo.websocket.org...
&lt; Got text data from server: Request served by 7811941c69e658
&gt; Sending test packet.
&lt; Got text data from server: Test packet</literal_block>
            </section>
            <section ids="minimal-server-example" names="minimal\ server\ example">
                <title>Minimal server example</title>
                <paragraph>This example will show you how to create a WebSocket server that listens for remote connections, and how to send and receive data.</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node

# The port we will listen to.
const PORT = 9080

# Our TCP Server instance.
var _tcp_server = TCPServer.new()

# Our connected peers list.
var _peers: Dictionary[int, WebSocketPeer] = {}

var last_peer_id := 1


func _ready():
    # Start listening on the given port.
    var err = _tcp_server.listen(PORT)
    if err == OK:
        print("Server started.")
    else:
        push_error("Unable to start server.")
        set_process(false)


func _process(_delta):
    while _tcp_server.is_connection_available():
        last_peer_id += 1
        print("+ Peer %d connected." % last_peer_id)
        var ws = WebSocketPeer.new()
        ws.accept_stream(_tcp_server.take_connection())
        _peers[last_peer_id] = ws

    # Iterate over all connected peers using "keys()" so we can erase in the loop
    for peer_id in _peers.keys():
        var peer = _peers[peer_id]

        peer.poll()

        var peer_state = peer.get_ready_state()
        if peer_state == WebSocketPeer.STATE_OPEN:
            while peer.get_available_packet_count():
                var packet = peer.get_packet()
                if peer.was_string_packet():
                    var packet_text = packet.get_string_from_utf8()
                    print("&lt; Got text data from peer %d: %s ... echoing" % [peer_id, packet_text])
                    # Echo the packet back.
                    peer.send_text(packet_text)
                else:
                    print("&lt; Got binary data from peer %d: %d ... echoing" % [peer_id, packet.size()])
                    # Echo the packet back.
                    peer.send(packet)
        elif peer_state == WebSocketPeer.STATE_CLOSED:
            # Remove the disconnected peer.
            _peers.erase(peer_id)
            var code = peer.get_close_code()
            var reason = peer.get_close_reason()
            print("- Peer %s closed with code: %d, reason %s. Clean: %s" % [peer_id, code, reason, code != -1])</literal_block>
                <paragraph>When a client connects, this will print something similar to this:</paragraph>
                <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Server started.
+ Peer 2 connected.
&lt; Got text data from peer 2: Test packet ... echoing</literal_block>
            </section>
            <section ids="advanced-chat-demo" names="advanced\ chat\ demo">
                <title>Advanced chat demo</title>
                <paragraph>A more advanced chat demo which optionally uses the multiplayer mid-level
                    abstraction and a high-level multiplayer demo are available in the
                    <reference name="godot demo projects" refuri="https://github.com/godotengine/godot-demo-projects">godot demo projects</reference><target ids="godot-demo-projects" names="godot\ demo\ projects" refuri="https://github.com/godotengine/godot-demo-projects"></target>
                    under <title_reference>networking/websocket_chat</title_reference> and <title_reference>networking/websocket_multiplayer</title_reference>.</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
