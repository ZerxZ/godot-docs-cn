<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/networking/websocket.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-websocket"></target>
    <section ids="websocket doc-websocket" names="websocket doc_websocket">
        <title>WebSocket</title>
        <section ids="html5-and-websocket" names="html5\ and\ websocket html5\ 与\ websocket">
            <title>HTML5 与 WebSocket</title>
            <paragraph>WebSocket协议在2011年被标准化, 最初的目标是让浏览器与服务器建立稳定的双向连接. 在此之前, 浏览器曾只支持HTTPRequests, 并不适合双向通信.</paragraph>
            <paragraph>The protocol is message based and a very powerful tool to send push notifications to browsers, and has been used to implement chats, turn-based games, etc. It still uses a TCP connection, which is good for reliability but not for latency, so not good for real-time applications like VoIP and fast-paced games (see <reference internal="True" refuri="webrtc#doc-webrtc"><inline classes="std std-ref">WebRTC</inline></reference> for those use cases).</paragraph>
            <paragraph>由于它的简单性, 广泛的兼容性以及比原始TCP连接更容易使用,WebSocket很快就开始在浏览器以外的地方应用, 在本地应用程序中作为与网络服务器通信的一种手段.</paragraph>
            <paragraph>Godot在本机和HTML5导出中都支持WebSocket.</paragraph>
        </section>
        <section ids="using-websocket-in-godot" names="using\ websocket\ in\ godot 在\ godot\ 中使用\ websocket">
            <title>在 Godot 中使用 WebSocket</title>
            <paragraph>WebSocket is implemented in Godot via <reference internal="True" refuri="../../classes/class_websocketpeer#class-websocketpeer"><inline classes="std std-ref">WebSocketPeer</inline></reference>. The WebSocket implementation is compatible with the High Level Multiplayer. See section on <reference internal="True" refuri="high_level_multiplayer#doc-high-level-multiplayer"><inline classes="std std-ref">high-level multiplayer</inline></reference> for more details.</paragraph>
            <warning>
                <paragraph>当导出到 Android 时，在导出项目或使用一键部署之前，确保在 Android 导出预设中启用 <literal>INTERNET</literal> 权限。否则，任何形式的网络通信都会被 Android 系统阻止。</paragraph>
            </warning>
            <section ids="minimal-client-example" names="minimal\ client\ example 最小客户端示例">
                <title>最小客户端示例</title>
                <paragraph>本示例将向你展示如何创建与远程服务器的 WebSocket 连接, 以及如何发送和接收数据.</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node

# The URL we will connect to
export var websocket_url = "wss://libwebsockets.org"

# Our WebSocketClient instance
var _client = WebSocketClient.new()

func _ready():
    # Connect base signals to get notified of connection open, close, and errors.
    _client.connection_closed.connect(_closed)
    _client.connection_error.connect(_closed)
    _client.connection_established.connect(_connected)
    # This signal is emitted when not using the Multiplayer API every time
    # a full packet is received.
    # Alternatively, you could check get_peer(1).get_available_packets() in a loop.
    _client.data_received.connect(_on_data)

    # Initiate connection to the given URL.
    var err = _client.connect_to_url(websocket_url, ["lws-mirror-protocol"])
    if err != OK:
        print("Unable to connect")
        set_process(false)

func _closed(was_clean = false):
    # was_clean will tell you if the disconnection was correctly notified
    # by the remote peer before closing the socket.
    print("Closed, clean: ", was_clean)
    set_process(false)

func _connected(proto = ""):
    # This is called on connection, "proto" will be the selected WebSocket
    # sub-protocol (which is optional)
    print("Connected with protocol: ", proto)
    # You MUST always use get_peer(1).put_packet to send data to server,
    # and not put_packet directly when not using the MultiplayerAPI.
    _client.get_peer(1).put_packet("Test packet".to_utf8())

func _on_data():
    # Print the received packet, you MUST always use get_peer(1).get_packet
    # to receive data from server, and not get_packet directly when not
    # using the MultiplayerAPI.
    print("Got data from server: ", _client.get_peer(1).get_packet().get_string_from_utf8())

func _process(delta):
    # Call this in _process or _physics_process. Data transfer, and signals
    # emission will only happen when calling this function.
    _client.poll()</literal_block>
                <paragraph>这将打印:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">Connected with protocol:
Got data from server: Test packet</literal_block>
            </section>
            <section ids="minimal-server-example" names="minimal\ server\ example 最小服务器示例">
                <title>最小服务器示例</title>
                <paragraph>这个例子将告诉你如何创建一个监听远程连接的WebSocket服务器，以及如何发送和接收数据。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node

# The port we will listen to
const PORT = 9080
# Our WebSocketServer instance
var _server = WebSocketServer.new()

func _ready():
    # Connect base signals to get notified of new client connections,
    # disconnections, and disconnect requests.
    _server.client_connected.connect(_connected)
    _server.client_disconnected.connect(_disconnected)
    _server.client_close_request.connect(_close_request)
    # This signal is emitted when not using the Multiplayer API every time a
    # full packet is received.
    # Alternatively, you could check get_peer(PEER_ID).get_available_packets()
    # in a loop for each connected peer.
    _server.data_received.connect(_on_data)
    # Start listening on the given port.
    var err = _server.listen(PORT)
    if err != OK:
        print("Unable to start server")
        set_process(false)

func _connected(id, proto):
    # This is called when a new peer connects, "id" will be the assigned peer id,
    # "proto" will be the selected WebSocket sub-protocol (which is optional)
    print("Client %d connected with protocol: %s" % [id, proto])

func _close_request(id, code, reason):
    # This is called when a client notifies that it wishes to close the connection,
    # providing a reason string and close code.
    print("Client %d disconnecting with code: %d, reason: %s" % [id, code, reason])

func _disconnected(id, was_clean = false):
    # This is called when a client disconnects, "id" will be the one of the
    # disconnecting client, "was_clean" will tell you if the disconnection
    # was correctly notified by the remote peer before closing the socket.
    print("Client %d disconnected, clean: %s" % [id, str(was_clean)])

func _on_data(id):
    # Print the received packet, you MUST always use get_peer(id).get_packet to receive data,
    # and not get_packet directly when not using the MultiplayerAPI.
    var pkt = _server.get_peer(id).get_packet()
    print("Got data from client %d: %s ... echoing" % [id, pkt.get_string_from_utf8()])
    _server.get_peer(id).put_packet(pkt)

func _process(delta):
    # Call this in _process or _physics_process.
    # Data transfer, and signals emission will only happen when calling this function.
    _server.poll()</literal_block>
                <paragraph>这将打印(当客户端连接时)与此类似的东西:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">Client 1348090059 connected with protocol: selected-protocol
Got data from client 1348090059: Test packet ... echoing</literal_block>
            </section>
            <section ids="advanced-chat-demo" names="advanced\ chat\ demo 高级聊天演示">
                <title>高级聊天演示</title>
                <paragraph>在 <reference name="godot demo projects" refuri="https://github.com/godotengine/godot-demo-projects">godot demo projects</reference><target ids="godot-demo-projects" names="godot\ demo\ projects" refuri="https://github.com/godotengine/godot-demo-projects"></target> 下 <title_reference>networking/websocket_chat</title_reference> 和 <title_reference>networking/websocket_multiplayer</title_reference> 有一个更高级的聊天演示demo, 可以选择使用多人中级抽象和高级多人演示demo.</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
