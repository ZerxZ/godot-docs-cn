<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/networking/high_level_multiplayer.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-high-level-multiplayer"></target>
    <section ids="high-level-multiplayer doc-high-level-multiplayer" names="high-level\ multiplayer doc_high_level_multiplayer">
        <title>High-level multiplayer</title>
        <section ids="high-level-vs-low-level-api" names="high-level\ vs\ low-level\ api">
            <title>High-level vs low-level API</title>
            <paragraph>The following explains the differences of high- and low-level networking in Godot as well as some fundamentals. If you want to jump in head-first and add networking to your first nodes, skip to <reference name="Initializing the network" refid="initializing-the-network">Initializing the network</reference> below. But make sure to read the rest later on!</paragraph>
            <paragraph>Godot always supported standard low-level networking via <abbreviation explanation="User Datagram Protocol">UDP</abbreviation>, <abbreviation explanation="Transmission Control Protocol">TCP</abbreviation> and some higher-level protocols such as <abbreviation explanation="Hypertext Transfer Protocol">HTTP</abbreviation> and <abbreviation explanation="Secure Sockets Layer">SSL</abbreviation>.
                These protocols are flexible and can be used for almost anything. However, using them to synchronize game state manually can be a large amount of work. Sometimes that work can't be avoided or is worth it, for example when working with a custom server implementation on the backend. But in most cases, it's worthwhile to consider Godot's high-level networking API, which sacrifices some of the fine-grained control of low-level networking for greater ease of use.</paragraph>
            <paragraph>This is due to the inherent limitations of the low-level protocols:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>TCP ensures packets will always arrive reliably and in order, but latency is generally higher due to error correction.
                        It's also quite a complex protocol because it understands what a "connection" is, and optimizes for goals that often don't suit applications like multiplayer games. Packets are buffered to be sent in larger batches, trading less per-packet overhead for higher latency. This can be useful for things like HTTP, but generally not for games. Some of this can be configured and disabled (e.g. by disabling "Nagle's algorithm" for the TCP connection).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>UDP is a simpler protocol, which only sends packets (and has no concept of a "connection"). No error correction
                        makes it pretty quick (low latency), but packets may be lost along the way or received in the wrong order.
                        Added to that, the MTU (maximum packet size) for UDP is generally low (only a few hundred bytes), so transmitting
                        larger packets means splitting them, reorganizing them and retrying if a part fails.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>In general, TCP can be thought of as reliable, ordered, and slow; UDP as unreliable, unordered and fast.
                Because of the large difference in performance, it often makes sense to re-build the parts of TCP wanted for games (optional reliability and packet order), while avoiding the unwanted parts (congestion/traffic control features, Nagle's algorithm, etc). Due to this, most game engines come with such an implementation, and Godot is no exception.</paragraph>
            <paragraph>In summary, you can use the low-level networking API for maximum control and implement everything on top of bare network protocols or use the high-level API based on <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> that does most of the heavy lifting behind the scenes in a generally optimized way.</paragraph>
            <note>
                <paragraph>Most of Godot's supported platforms offer all or most of the mentioned high- and low-level networking
                    features. As networking is always largely hardware and operating system dependent, however,
                    some features may change or not be available on some target platforms. Most notably,
                    the HTML5 platform currently offers WebSockets and WebRTC support but lacks some of the higher-level features, as
                    well as raw access to low-level protocols like TCP and UDP.</paragraph>
            </note>
            <note>
                <paragraph>More about TCP/IP, UDP, and networking:
                    <reference refuri="https://gafferongames.com/post/udp_vs_tcp/">https://gafferongames.com/post/udp_vs_tcp/</reference></paragraph>
                <paragraph>Gaffer On Games has a lot of useful articles about networking in Games
                    (<reference name="here" refuri="https://gafferongames.com/categories/game-networking/">here</reference>), including the comprehensive
                    <reference name="introduction to networking models in games" refuri="https://gafferongames.com/post/what_every_programmer_needs_to_know_about_game_networking/">introduction to networking models in games</reference>.</paragraph>
            </note>
            <warning>
                <paragraph>Adding networking to your game comes with some responsibility.
                    It can make your application vulnerable if done wrong and may lead to cheats or exploits.
                    It may even allow an attacker to compromise the machines your application runs on
                    and use your servers to send spam, attack others or steal your users' data if they play your game.</paragraph>
                <paragraph>This is always the case when networking is involved and has nothing to do with Godot.
                    You can of course experiment, but when you release a networked application,
                    always take care of any possible security concerns.</paragraph>
            </warning>
        </section>
        <section ids="mid-level-abstraction" names="mid-level\ abstraction">
            <title>Mid-level abstraction</title>
            <paragraph>Before going into how we would like to synchronize a game across the network, it can be helpful to understand how the base network API for synchronization works.</paragraph>
            <paragraph>Godot uses a mid-level object <reference internal="True" refuri="../../classes/class_multiplayerpeer#class-multiplayerpeer"><inline classes="std std-ref">MultiplayerPeer</inline></reference>.
                This object is not meant to be created directly, but is designed so that several C++ implementations can provide it.</paragraph>
            <paragraph>This object extends from <reference internal="True" refuri="../../classes/class_packetpeer#class-packetpeer"><inline classes="std std-ref">PacketPeer</inline></reference>, so it inherits all the useful methods for serializing, sending and receiving data. On top of that, it adds methods to set a peer, transfer mode, etc. It also includes signals that will let you know when peers connect or disconnect.</paragraph>
            <paragraph>This class interface can abstract most types of network layers, topologies and libraries. By default, Godot
                provides an implementation based on ENet (<reference internal="True" refuri="../../classes/class_enetmultiplayerpeer#class-enetmultiplayerpeer"><inline classes="std std-ref">ENetMultiplayerPeer</inline></reference>),
                one based on WebRTC (<reference internal="True" refuri="../../classes/class_webrtcmultiplayerpeer#class-webrtcmultiplayerpeer"><inline classes="std std-ref">WebRTCMultiplayerPeer</inline></reference>), and one based on WebSocket
                (<reference internal="True" refuri="../../classes/class_websocketmultiplayerpeer#class-websocketmultiplayerpeer"><inline classes="std std-ref">WebSocketMultiplayerPeer</inline></reference>), but this could be used to implement
                mobile APIs (for ad hoc WiFi, Bluetooth) or custom device/console-specific networking APIs.</paragraph>
            <paragraph>For most common cases, using this object directly is discouraged, as Godot provides even higher level networking facilities.
                This object is still made available in case a game has specific needs for a lower-level API.</paragraph>
        </section>
        <section ids="hosting-considerations" names="hosting\ considerations">
            <title>Hosting considerations</title>
            <paragraph>When hosting a server, clients on your <abbreviation explanation="Local Area Network">LAN</abbreviation> can
                connect using the internal IP address which is usually of the form
                <literal>192.168.*.*</literal>. This internal IP address is <strong>not</strong> reachable by
                non-LAN/Internet clients.</paragraph>
            <paragraph>On Windows, you can find your internal IP address by opening a command prompt
                and entering <literal>ipconfig</literal>. On macOS, open a Terminal and enter <literal>ifconfig</literal>. On
                Linux, open a terminal and enter <literal>ip addr</literal>.</paragraph>
            <paragraph>If you're hosting a server on your own machine and want non-LAN clients to
                connect to it, you'll probably have to <emphasis>forward</emphasis> the server port on your router.
                This is required to make your server reachable from the Internet since most
                residential connections use a <reference name="NAT" refuri="https://en.wikipedia.org/wiki/Network_address_translation">NAT</reference>. Godot's
                high-level multiplayer API only uses UDP, so you must forward the port in UDP,
                not just TCP.</paragraph>
            <paragraph>After forwarding a UDP port and making sure your server uses that port, you can
                use <reference name="this website" refuri="https://icanhazip.com/">this website</reference> to find your public IP address.
                Then give this public IP address to any Internet clients that wish to connect to
                your server.</paragraph>
            <paragraph>Godot's high-level multiplayer API uses a modified version of ENet which allows
                for full IPv6 support.</paragraph>
        </section>
        <section ids="initializing-the-network" names="initializing\ the\ network">
            <title>Initializing the network</title>
            <paragraph>High-level networking in Godot is managed by the <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.</paragraph>
            <paragraph>Each node has a <literal>multiplayer</literal> property, which is a reference to the <literal>MultiplayerAPI</literal> instance configured for it
                by the scene tree. Initially, every node is configured with the same default <literal>MultiplayerAPI</literal> object.</paragraph>
            <paragraph>It is possible to create a new <literal>MultiplayerAPI</literal> object and assign it to a <literal>NodePath</literal> in the scene tree,
                which will override <literal>multiplayer</literal> for the node at that path and all of its descendants.
                This allows sibling nodes to be configured with different peers, which makes it possible to run a server
                and a client simultaneously in one instance of Godot.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># By default, these expressions are interchangeable.
multiplayer # Get the MultiplayerAPI object configured for this node.
get_tree().get_multiplayer() # Get the default MultiplayerAPI object.</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// By default, these expressions are interchangeable.
Multiplayer; // Get the MultiplayerAPI object configured for this node.
GetTree().GetMultiplayer(); // Get the default MultiplayerAPI object.</literal_block>
                </div>
            </container>
            <paragraph>To initialize networking, a <literal>MultiplayerPeer</literal> object must be created, initialized as a server or client,
                and passed to the <literal>MultiplayerAPI</literal>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Create client.
var peer = ENetMultiplayerPeer.new()
peer.create_client(IP_ADDRESS, PORT)
multiplayer.multiplayer_peer = peer

# Create server.
var peer = ENetMultiplayerPeer.new()
peer.create_server(PORT, MAX_CLIENTS)
multiplayer.multiplayer_peer = peer</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Create client.
var peer = new ENetMultiplayerPeer();
peer.CreateClient(IPAddress, Port);
Multiplayer.MultiplayerPeer = peer;

// Create server.
var peer = new ENetMultiplayerPeer();
peer.CreateServer(Port, MaxClients);
Multiplayer.MultiplayerPeer = peer;</literal_block>
                </div>
            </container>
            <paragraph>To terminate networking:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">multiplayer.multiplayer_peer = OfflineMultiplayerPeer.new()</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Multiplayer.MultiplayerPeer = null;</literal_block>
                </div>
            </container>
            <warning>
                <paragraph>When exporting to Android, make sure to enable the <literal>INTERNET</literal>
                    permission in the Android export preset before exporting the project or
                    using one-click deploy. Otherwise, network communication of any kind will be
                    blocked by Android.</paragraph>
            </warning>
        </section>
        <section ids="managing-connections" names="managing\ connections">
            <title>Managing connections</title>
            <paragraph>Every peer is assigned a unique ID. The server's ID is always 1, and clients are assigned a random positive integer.</paragraph>
            <paragraph>Responding to connections or disconnections is possible by connecting to <literal>MultiplayerAPI</literal>'s signals:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>peer_connected(id: int)</literal> This signal is emitted with the newly connected peer's ID on each other peer, and on the new peer multiple times, once with each other peer's ID.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>peer_disconnected(id: int)</literal> This signal is emitted on every remaining peer when one disconnects.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The rest are only emitted on clients:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>connected_to_server()</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>connection_failed()</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>server_disconnected()</literal></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>To get the unique ID of the associated peer:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">multiplayer.get_unique_id()</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Multiplayer.GetUniqueId();</literal_block>
                </div>
            </container>
            <paragraph>To check whether the peer is server or client:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">multiplayer.is_server()</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Multiplayer.IsServer();</literal_block>
                </div>
            </container>
            <target refid="doc-high-level-multiplayer-rpcs"></target>
        </section>
        <section ids="remote-procedure-calls doc-high-level-multiplayer-rpcs" names="remote\ procedure\ calls doc_high_level_multiplayer_rpcs">
            <title>Remote procedure calls</title>
            <paragraph>Remote procedure calls, or RPCs, are functions that can be called on other peers. To create one, use the <literal>@rpc</literal> annotation
                before a function definition. To call an RPC, use <literal>Callable</literal>'s method <literal>rpc()</literal> to call in every peer, or <literal>rpc_id()</literal> to
                call in a specific peer.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    if multiplayer.is_server():
        print_once_per_client.rpc()

@rpc
func print_once_per_client():
    print("I will be printed to the console once per each connected client.")</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    if (Multiplayer.IsServer())
    {
        Rpc(MethodName.PrintOncePerClient);
    }
}

[Rpc]
private void PrintOncePerClient()
{
    GD.Print("I will be printed to the console once per each connected client.");
}</literal_block>
                </div>
            </container>
            <paragraph>RPCs will not serialize objects or callables.</paragraph>
            <paragraph>For a remote call to be successful, the sending and receiving node need to have the same <literal>NodePath</literal>, which means they
                must have the same name. When using <literal>add_child()</literal> for nodes which are expected to use RPCs, set the argument
                <literal>force_readable_name</literal> to <literal>true</literal>.</paragraph>
            <warning>
                <paragraph>If a function is annotated with <literal>@rpc</literal> on the client script (resp. server script),
                    then this function must also be declared on the server script (resp. client script).
                    Both RPCs must have the same signature which is evaluated with a checksum of <strong>all RPCs</strong>.
                    All RPCs in a script are checked at once, and all RPCs must be declared on both the client
                    scripts and the server scripts, <strong>even functions that are currently not in use</strong>.</paragraph>
                <paragraph>The signature of the RPC includes the <literal>@rpc()</literal> declaration, the function, return type,
                    <strong>and</strong> the NodePath. If an RPC resides in a script attached to <literal>/root/Main/Node1</literal>, then it
                    must reside in precisely the same path and node on both the client script and the server
                    script. Function arguments are not checked for matching between the server and client code
                    (example: <literal>func sendstuff():</literal> and <literal>func sendstuff(arg1, arg2):</literal> <strong>will pass</strong> signature
                    matching).</paragraph>
                <paragraph>If these conditions are not met (if all RPCs do not pass signature matching), the script may print an
                    error or cause unwanted behavior. The error message may be unrelated to the RPC function you are
                    currently building and testing.</paragraph>
                <paragraph>See further explanation and troubleshooting on <reference name="this post" refuri="https://github.com/godotengine/godot/issues/57869#issuecomment-1034215138">this post</reference>.</paragraph>
            </warning>
            <paragraph>The annotation can take a number of arguments, which have default values. <literal>@rpc</literal> is equivalent to:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@rpc("authority", "call_remote", "unreliable", 0)</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Rpc(MultiplayerApi.RpcMode.Authority, CallLocal = false, TransferMode = MultiplayerPeer.TransferModeEnum.Unreliable, TransferChannel = 0)]</literal_block>
                </div>
            </container>
            <paragraph>The parameters and their functions are as follows:</paragraph>
            <paragraph><literal>mode</literal>:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>"authority"</literal>: Only the multiplayer authority can call remotely.
                        The authority is the server by default, but can be changed per-node using
                        <reference internal="True" refuri="../../classes/class_node#class-node-method-set-multiplayer-authority"><inline classes="std std-ref">Node.set_multiplayer_authority</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>"any_peer"</literal>: Clients are allowed to call remotely. Useful for transferring user input.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><literal>sync</literal>:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>"call_remote"</literal>: The function will not be called on the local peer.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>"call_local"</literal>: The function can be called on the local peer. Useful when the server is also a player.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><literal>transfer_mode</literal>:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>"unreliable"</literal> Packets are not acknowledged, can be lost, and can arrive at any order.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>"unreliable_ordered"</literal> Packets are received in the order they were sent in. This is achieved by ignoring packets that arrive later if another that was sent after them has already been received. Can cause packet loss if used incorrectly.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>"reliable"</literal> Resend attempts are sent until packets are acknowledged, and their order is preserved. Has a significant performance penalty.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><literal>transfer_channel</literal> is the channel index.</paragraph>
            <paragraph>The first 3 can be passed in any order, but <literal>transfer_channel</literal> must always be last.</paragraph>
            <paragraph>The function <literal>multiplayer.get_remote_sender_id()</literal> can be used to get the unique id of an rpc sender, when used within the function called by rpc.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_some_input(): # Connected to some input.
    transfer_some_input.rpc_id(1) # Send the input only to the server.


# Call local is required if the server is also a player.
@rpc("any_peer", "call_local", "reliable")
func transfer_some_input():
    # The server knows who sent the input.
    var sender_id = multiplayer.get_remote_sender_id()
    # Process the input and affect game logic.</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private void OnSomeInput() // Connected to some input.
{
    RpcId(1, MethodName.TransferSomeInput); // Send the input only to the server.
}

// Call local is required if the server is also a player.
[Rpc(MultiplayerApi.RpcMode.AnyPeer, CallLocal = true, TransferMode = MultiplayerPeer.TransferModeEnum.Reliable)]
private void TransferSomeInput()
{
    // The server knows who sent the input.
    int senderId = Multiplayer.GetRemoteSenderId();
    // Process the input and affect game logic.
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="channels" names="channels">
            <title>Channels</title>
            <paragraph>Modern networking protocols support channels, which are separate connections within the connection. This allows for multiple
                streams of packets that do not interfere with each other.</paragraph>
            <paragraph>For example, game chat related messages and some of the core gameplay messages should all be sent reliably, but a gameplay
                message should not wait for a chat message to be acknowledged. This can be achieved by using different channels.</paragraph>
            <paragraph>Channels are also useful when used with the unreliable ordered transfer mode. Sending packets of variable size with this transfer mode can
                cause packet loss, since packets which are slower to arrive are ignored. Separating them into multiple streams of homogeneous packets
                by using channels allows ordered transfer with little packet loss, and without the latency penalty caused by reliable mode.</paragraph>
            <paragraph>The default channel with index 0 is actually three different channels - one for each transfer mode.</paragraph>
        </section>
        <section ids="example-lobby-implementation" names="example\ lobby\ implementation">
            <title>Example lobby implementation</title>
            <paragraph>This is an example lobby that can handle peers joining and leaving, notify UI scenes through signals, and start the game after all clients
                have loaded the game scene.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

# Autoload named Lobby

# These signals can be connected to by a UI lobby scene or the game scene.
signal player_connected(peer_id, player_info)
signal player_disconnected(peer_id)
signal server_disconnected

const PORT = 7000
const DEFAULT_SERVER_IP = "127.0.0.1" # IPv4 localhost
const MAX_CONNECTIONS = 20

# This will contain player info for every player,
# with the keys being each player's unique IDs.
var players = {}

# This is the local player info. This should be modified locally
# before the connection is made. It will be passed to every other peer.
# For example, the value of "name" can be set to something the player
# entered in a UI scene.
var player_info = {"name": "Name"}

var players_loaded = 0



func _ready():
    multiplayer.peer_connected.connect(_on_player_connected)
    multiplayer.peer_disconnected.connect(_on_player_disconnected)
    multiplayer.connected_to_server.connect(_on_connected_ok)
    multiplayer.connection_failed.connect(_on_connected_fail)
    multiplayer.server_disconnected.connect(_on_server_disconnected)


func join_game(address = ""):
    if address.is_empty():
        address = DEFAULT_SERVER_IP
    var peer = ENetMultiplayerPeer.new()
    var error = peer.create_client(address, PORT)
    if error:
        return error
    multiplayer.multiplayer_peer = peer


func create_game():
    var peer = ENetMultiplayerPeer.new()
    var error = peer.create_server(PORT, MAX_CONNECTIONS)
    if error:
        return error
    multiplayer.multiplayer_peer = peer

    players[1] = player_info
    player_connected.emit(1, player_info)


func remove_multiplayer_peer():
    multiplayer.multiplayer_peer = OfflineMultiplayerPeer.new()
    players.clear()


# When the server decides to start the game from a UI scene,
# do Lobby.load_game.rpc(filepath)
@rpc("call_local", "reliable")
func load_game(game_scene_path):
    get_tree().change_scene_to_file(game_scene_path)


# Every peer will call this when they have loaded the game scene.
@rpc("any_peer", "call_local", "reliable")
func player_loaded():
    if multiplayer.is_server():
        players_loaded += 1
        if players_loaded == players.size():
            $/root/Game.start_game()
            players_loaded = 0


# When a peer connects, send them my player info.
# This allows transfer of all desired data for each player, not only the unique ID.
func _on_player_connected(id):
    _register_player.rpc_id(id, player_info)


@rpc("any_peer", "reliable")
func _register_player(new_player_info):
    var new_player_id = multiplayer.get_remote_sender_id()
    players[new_player_id] = new_player_info
    player_connected.emit(new_player_id, new_player_info)


func _on_player_disconnected(id):
    players.erase(id)
    player_disconnected.emit(id)


func _on_connected_ok():
    var peer_id = multiplayer.get_unique_id()
    players[peer_id] = player_info
    player_connected.emit(peer_id, player_info)


func _on_connected_fail():
    remove_multiplayer_peer()


func _on_server_disconnected():
    remove_multiplayer_peer()
    players.clear()
    server_disconnected.emit()</literal_block>
                </div>
                <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Lobby : Node
{
    public static Lobby Instance { get; private set; }

    // These signals can be connected to by a UI lobby scene or the game scene.
    [Signal]
    public delegate void PlayerConnectedEventHandler(int peerId, Godot.Collections.Dictionary&lt;string, string&gt; playerInfo);
    [Signal]
    public delegate void PlayerDisconnectedEventHandler(int peerId);
    [Signal]
    public delegate void ServerDisconnectedEventHandler();

    private const int Port = 7000;
    private const string DefaultServerIP = "127.0.0.1"; // IPv4 localhost
    private const int MaxConnections = 20;

    // This will contain player info for every player,
    // with the keys being each player's unique IDs.
    private Godot.Collections.Dictionary&lt;long, Godot.Collections.Dictionary&lt;string, string&gt;&gt; _players = new Godot.Collections.Dictionary&lt;long, Godot.Collections.Dictionary&lt;string, string&gt;&gt;();

    // This is the local player info. This should be modified locally
    // before the connection is made. It will be passed to every other peer.
    // For example, the value of "name" can be set to something the player
    // entered in a UI scene.
    private Godot.Collections.Dictionary&lt;string, string&gt; _playerInfo = new Godot.Collections.Dictionary&lt;string, string&gt;()
    {
        { "Name", "PlayerName" },
    };

    private int _playersLoaded = 0;

    public override void _Ready()
    {
        Instance = this;
        Multiplayer.PeerConnected += OnPlayerConnected;
        Multiplayer.PeerDisconnected += OnPlayerDisconnected;
        Multiplayer.ConnectedToServer += OnConnectOk;
        Multiplayer.ConnectionFailed += OnConnectionFail;
        Multiplayer.ServerDisconnected += OnServerDisconnected;
    }

    private Error JoinGame(string address = "")
    {
        if (string.IsNullOrEmpty(address))
        {
            address = DefaultServerIP;
        }

        var peer = new ENetMultiplayerPeer();
        Error error = peer.CreateClient(address, Port);

        if (error != Error.Ok)
        {
            return error;
        }

        Multiplayer.MultiplayerPeer = peer;
        return Error.Ok;
    }

    private Error CreateGame()
    {
        var peer = new ENetMultiplayerPeer();
        Error error = peer.CreateServer(Port, MaxConnections);

        if (error != Error.Ok)
        {
            return error;
        }

        Multiplayer.MultiplayerPeer = peer;
        _players[1] = _playerInfo;
        EmitSignal(SignalName.PlayerConnected, 1, _playerInfo);
        return Error.Ok;
    }

    private void RemoveMultiplayerPeer()
    {
        Multiplayer.MultiplayerPeer = null;
        _players.Clear();
    }

    // When the server decides to start the game from a UI scene,
    // do Rpc(Lobby.MethodName.LoadGame, filePath);
    [Rpc(CallLocal = true,TransferMode = MultiplayerPeer.TransferModeEnum.Reliable)]
    private void LoadGame(string gameScenePath)
    {
        GetTree().ChangeSceneToFile(gameScenePath);
    }

    // Every peer will call this when they have loaded the game scene.
    [Rpc(MultiplayerApi.RpcMode.AnyPeer,CallLocal = true,TransferMode = MultiplayerPeer.TransferModeEnum.Reliable)]
    private void PlayerLoaded()
    {
        if (Multiplayer.IsServer())
        {
            _playersLoaded += 1;
            if (_playersLoaded == _players.Count)
            {
                GetNode&lt;Game&gt;("/root/Game").StartGame();
                _playersLoaded = 0;
            }
        }
    }

    // When a peer connects, send them my player info.
    // This allows transfer of all desired data for each player, not only the unique ID.
    private void OnPlayerConnected(long id)
    {
        RpcId(id, MethodName.RegisterPlayer, _playerInfo);
    }

    [Rpc(MultiplayerApi.RpcMode.AnyPeer,TransferMode = MultiplayerPeer.TransferModeEnum.Reliable)]
    private void RegisterPlayer(Godot.Collections.Dictionary&lt;string, string&gt; newPlayerInfo)
    {
        int newPlayerId = Multiplayer.GetRemoteSenderId();
        _players[newPlayerId] = newPlayerInfo;
        EmitSignal(SignalName.PlayerConnected, newPlayerId, newPlayerInfo);
    }

    private void OnPlayerDisconnected(long id)
    {
        _players.Remove(id);
        EmitSignal(SignalName.PlayerDisconnected, id);
    }

    private void OnConnectOk()
    {
        int peerId = Multiplayer.GetUniqueId();
        _players[peerId] = _playerInfo;
        EmitSignal(SignalName.PlayerConnected, peerId, _playerInfo);
    }

    private void OnConnectionFail()
    {
        Multiplayer.MultiplayerPeer = null;
    }

    private void OnServerDisconnected()
    {
        Multiplayer.MultiplayerPeer = null;
        _players.Clear();
        EmitSignal(SignalName.ServerDisconnected);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>The game scene's root node should be named Game. In the script attached to it:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node3D # Or Node2D.



func _ready():
    # Preconfigure game.

    Lobby.player_loaded.rpc_id(1) # Tell the server that this peer has loaded.


# Called only on the server.
func start_game():
    # All peers are ready to receive RPCs in this scene.</literal_block>
                </div>
                <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Game : Node3D // Or Node2D.
{
    public override void _Ready()
    {
        // Preconfigure game.

        Lobby.Instance.RpcId(1, Lobby.MethodName.PlayerLoaded); // Tell the server that this peer has loaded.
    }

    // Called only on the server.
    public void StartGame()
    {
        // All peers are ready to receive RPCs in this scene.
    }
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="exporting-for-dedicated-servers" names="exporting\ for\ dedicated\ servers">
            <title>Exporting for dedicated servers</title>
            <paragraph>Once you've made a multiplayer game, you may want to export it to run it on
                a dedicated server with no GPU available. See
                <reference internal="True" refuri="../export/exporting_for_dedicated_servers#doc-exporting-for-dedicated-servers"><inline classes="std std-ref">Exporting for dedicated servers</inline></reference> for more information.</paragraph>
            <note>
                <paragraph>The code samples on this page aren't designed to run on a dedicated
                    server. You'll have to modify them so the server isn't considered to be a
                    player. You'll also have to modify the game starting mechanism so that the
                    first player who joins can start the game.</paragraph>
            </note>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
