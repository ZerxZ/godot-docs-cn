<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/networking/high_level_multiplayer.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-high-level-multiplayer"></target>
    <section ids="high-level-multiplayer doc-high-level-multiplayer" names="high-level\ multiplayer 高级多人游戏 doc_high_level_multiplayer">
        <title>高级多人游戏</title>
        <section ids="high-level-vs-low-level-api" names="high-level\ vs\ low-level\ api 高层与底层\ api">
            <title>高层与底层 API</title>
            <paragraph>下面解释了 Godot 高阶、低阶网络的区别以及一些基本原理。如果你想一头扎进去，直接为你的最初的节点添加网络功能，请跳到下面的<reference name="初始化网络" refid="initializing-the-network">初始化网络</reference>。但是请确保稍后阅读其余部分！</paragraph>
            <paragraph>Godot 始终支持通过 <abbreviation explanation="用户数据报协议">UDP</abbreviation>、 <abbreviation explanation="传输控制协议">TCP</abbreviation> 和一些更高级别的协议【如 <abbreviation explanation="安全套接层">SSL</abbreviation> 和 <abbreviation explanation="超文本传输协议">HTTP</abbreviation> 】进行标准的低级网络连接。这些协议非常灵活，几乎可以用于任何用途。然而，使用这些协议来手动同步游戏状态可能需要做大量的工作。这项工作有时是无法避免的，有时候是值得去做的，比如在后台使用自定义服务器实现这种情况下。而在大多数情况下，考虑使用 Godot 的高级网络 API 是值得的，它牺牲了对低级网络的一些细度控制，换来了更强的易用性。</paragraph>
            <paragraph>这是底层协议的固有限制所造成的：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>TCP 能够确保数据包总是可靠、有序地到达，但是由于错误纠正，延迟通常更高。它也是一个相当复杂的协议，因为它理解什么是“连接”，它优化的目标也经常不是多人游戏这种应用程序。数据包会被缓冲成更大的批次发送，用更高的延迟来交换更小的单数据包开销。这对于 HTTP 之类的东西可能很有用，但对于游戏通常不太有用。其中一些可以配置和禁用（例如禁用 TCP 连接的“Nagle 算法”）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>UDP 是一个更简单的协议，它只发送数据包（没有“连接”的概念）。因为没有错误纠正，所以非常快（低延迟），但数据包就可能在发生丢失或以错误的顺序接收的情况。此外，UDP 的 MTU（Maximum Packet Size，最大数据包大小）通常很低（只有几百字节），因此传输更大的数据包意味着需要对它们进行分割、重新组织、某一部分失败时还要进行重试。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>一般来说,TCP 可以被认为是可靠的, 有序的和缓慢的; UDP则是不可靠, 无序, 但是速度快. 由于性能上的巨大差异, 在避免不需要的部分(拥塞/流量控制特性, Nagle算法等)的同时, 重新构建游戏所需的TCP部分(可选的可靠性和包顺序)通常是合理的. 正因为如此, 大多数游戏引擎都带有这样的实现,Godot也不例外.</paragraph>
            <paragraph>综上所述, 你可以使用低级网络API来实现最大限度的控制, 并在完全裸露的网络协议之上实现所有功能, 或者使用基于 <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 的高级API, 后者以通常以一种比较优化的方式在后台完成大部分繁重的工作.</paragraph>
            <note>
                <paragraph>Godot 支持的大多数平台都提供所有或大部分上述的高、低网络功能。但是，由于网络在很大程度上依赖于硬件和操作系统，在某些目标平台上一些特性可能会改变或者不可用。最值得注意的是 HTML5 平台目前只提供 WebSocket 和 WebRTC 支持，缺乏一些高级功能，以及对 TCP 和 UDP 等低级协议的原始访问。</paragraph>
            </note>
            <note>
                <paragraph>更多关于TCP/IP, UDP和网络的信息: <reference refuri="https://gafferongames.com/post/udp_vs_tcp/">https://gafferongames.com/post/udp_vs_tcp/</reference></paragraph>
                <paragraph>Gaffer On Games有很多关于游戏中网络的有用文章( <reference name="这里" refuri="https://gafferongames.com/categories/game-networking/">这里</reference> ), 包括全面的 <reference name="游戏中的网络模型介绍" refuri="https://gafferongames.com/post/what_every_programmer_needs_to_know_about_game_networking/">游戏中的网络模型介绍</reference> .</paragraph>
            </note>
            <warning>
                <paragraph>在你的游戏中加入社交网络需要承担一定的责任. 如果做错了, 它会使你的应用程序很容易受到攻击, 并可能导致欺骗或利用. 它甚至可能允许攻击者破坏你的应用程序运行在的机器, 并使用你的服务器发送垃圾邮件, 攻击其他人或窃取你的用户数据, 如果他们玩你的游戏.</paragraph>
                <paragraph>当涉及到网络而与Godot无关时, 情况总是如此. 当然, 你可以进行试验, 但是在发布网络应用程序时, 请始终注意任何可能的安全问题.</paragraph>
            </warning>
        </section>
        <section ids="mid-level-abstraction" names="mid-level\ abstraction 中级抽象">
            <title>中级抽象</title>
            <paragraph>在讨论我们希望如何跨网络同步游戏之前, 了解用于同步的基本网络API是如何工作的可能会有所帮助.</paragraph>
            <paragraph>Godot uses a mid-level object <reference internal="True" refuri="../../classes/class_multiplayerpeer#class-multiplayerpeer"><inline classes="std std-ref">MultiplayerPeer</inline></reference>.
                This object is not meant to be created directly, but is designed so that several C++ implementations can provide it.</paragraph>
            <paragraph>这个对象扩展自 <reference internal="True" refuri="../../classes/class_packetpeer#class-packetpeer"><inline classes="std std-ref">PacketPeer</inline></reference>, 因此它继承了所有用于序列化, 发送和接收数据的方法. 除此之外, 它还添加了设置节点, 传输模式等的方法. 它同时还包括当节点连接或断开时将通知你的信号.</paragraph>
            <paragraph>This class interface can abstract most types of network layers, topologies and libraries. By default, Godot
                provides an implementation based on ENet (<reference internal="True" refuri="../../classes/class_enetmultiplayerpeer#class-enetmultiplayerpeer"><inline classes="std std-ref">ENetMultiplayerPeer</inline></reference>),
                one based on WebRTC (<reference internal="True" refuri="../../classes/class_webrtcmultiplayerpeer#class-webrtcmultiplayerpeer"><inline classes="std std-ref">WebRTCMultiplayerPeer</inline></reference>), and one based on WebSocket
                (<reference internal="True" refuri="../../classes/class_websocketpeer#class-websocketpeer"><inline classes="std std-ref">WebSocketPeer</inline></reference>), but this could be used to implement
                mobile APIs (for ad hoc WiFi, Bluetooth) or custom device/console-specific networking APIs.</paragraph>
            <paragraph>For most common cases, using this object directly is discouraged, as Godot provides even higher level networking facilities.
                This object is still made available in case a game has specific needs for a lower-level API.</paragraph>
        </section>
        <section ids="hosting-considerations" names="hosting\ considerations 托管注意事项">
            <title>托管注意事项</title>
            <paragraph>托管服务器时， <abbreviation>LAN（局域网）</abbreviation> 上的客户端可以使用内部 IP 地址进行连接，该地址通常是 <literal>192.168.*.*</literal> 格式的。 非 LAN/Internet 客户端 <strong>无法</strong> 访问此内部 IP 地址。</paragraph>
            <paragraph>在 Windows 中， 你可以在命令提示符中输入 <literal>ipconfig</literal> ， 在 macOS 中，你可以在终端中输入 <literal>ifconfig</literal> ，在 Linux 中，你可以在终端中输入 <literal>ip addr</literal> ，从而找到你的内部 IP 地址。</paragraph>
            <paragraph>如果你在自己的机器上托管了服务器，并且想让非内网客户端连接，你可能需要 <emphasis>转发</emphasis> 服务器端口到你的路由。这是使你的服务器能通过互联网访问所必须的，因为大多数家用网络都使用 <title_reference>NAT &lt;https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2&gt;</title_reference> 技术。Godot 的高等级多人 API 只能使用 UDP ，所以你的端口转发必须是 UDP， 不能只转发 TCP。</paragraph>
            <paragraph>After forwarding a UDP port and making sure your server uses that port, you can
                use <reference name="this website" refuri="https://icanhazip.com/">this website</reference> to find your public IP address.
                Then give this public IP address to any Internet clients that wish to connect to
                your server.</paragraph>
            <paragraph>Godot 的高等级多人联机 API 使用一个修改过的 ENet 版本，包含全 IPv6 支持。</paragraph>
        </section>
        <section ids="initializing-the-network" names="initializing\ the\ network 初始化网络">
            <title>初始化网络</title>
            <paragraph>High level networking in Godot is managed by the <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.</paragraph>
            <paragraph>每个节点都有一个 <literal>multiplayer</literal> 属性，它是对场景树为其配置的 <literal>MultiplayerAPI</literal> 实例的参考。最初，每个节点都配置相同的预设 <literal>MultiplayerAPI</literal> 物件。</paragraph>
            <paragraph>可以建立一个新的 <literal>MultiplayerAPI</literal> 物件并将其分配给场景树中的 <literal>NodePath</literal> ，这将覆盖该路径及其所有后代节点的 <literal>multiplayer</literal> 。这允许兄弟节点配置不同的对等点，从而可以在一个Godot实例中同时执行服务器和客户端。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># By default, these expressions are interchangeable.
multiplayer # Get the MultiplayerAPI object configured for this node.
get_tree().get_multiplayer() # Get the default MultiplayerAPI object.</literal_block>
            <paragraph>为了初始化网络， 你必须初始化一个 <literal>MultiplayerPeer</literal> 对象，初始化为服务端或客户端，然后传给 <literal>MultiplayerAPI</literal> 。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Create client.
var peer = ENetMultiplayerPeer.new()
peer.create_client(IP_ADDRESS, PORT)
multiplayer.multiplayer_peer = peer

# Create server.
var peer = ENetMultiplayerPeer.new()
peer.create_server(PORT, MAX_CLIENTS)
multiplayer.multiplayer_peer = peer</literal_block>
            <paragraph>To terminate networking:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">multiplayer.multiplayer_peer = null</literal_block>
            <warning>
                <paragraph>当导出到 Android 时，在导出项目或使用一键部署之前，确保在 Android 导出预设中启用 <literal>INTERNET</literal> 权限。否则，任何形式的网络通信都会被 Android 系统阻止。</paragraph>
            </warning>
        </section>
        <section ids="managing-connections" names="managing\ connections 管理连接">
            <title>管理连接</title>
            <paragraph>每个 peer 都会被分配一个唯一 ID。服务器的 ID 永远是 1，客户端会被分配一个随机的正整数。</paragraph>
            <paragraph>可以通过连接到 <literal>MultiplayerAPI</literal> 的信号来响应连接或断开连接：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>peer_connected(id: int)</literal> 此信号在每个其他对等点上与新连接的对等点ID一起发出，并在新对等点上多次发出，其中一次与每个其他对等点ID一起发出。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>peer_disconnected（id:int）</literal> 当一个对等体断开连接时，剩余的每个对等体都会发出此信号。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The rest are only emitted on clients:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>connected_to_server()</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>connection_failed()</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>server_disconnected()</literal></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>若要取得关联对等点的唯一ID：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">multiplayer.get_unique_id()</literal_block>
            <paragraph>To check whether the peer is server or client:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">multiplayer.is_server()</literal_block>
        </section>
        <section ids="remote-procedure-calls" names="remote\ procedure\ calls 远程过程调用">
            <title>远程过程调用</title>
            <paragraph>远程过程调用（RPC）是可以在其他对等方上调用的函数。要创建一个，请在函数定义之前使用 <literal>@rpc</literal> 注释。若要调用RPC，请使用 <literal>Callable</literal> 的方法 <literal>rpc()</literal> 在每个对等方中调用，或使用 <literal>rpc_id()</literal> 在特定对等方中进行调用。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    if multiplayer.is_server():
        print_once_per_client.rpc()

@rpc
func print_once_per_client():
    print("I will be printed to the console once per each connected client.")</literal_block>
            <paragraph>RPC不会序列化对象或可调用程序。</paragraph>
            <paragraph>要使远程调用成功，发送节点和接收节点需要具有相同的 <literal>NodePath</literal> ，这意味着它们必须具有相同的名称。对预期使用RPC的节点使用 <literal>add_child()</literal> 时，请将参数 <literal>force_readable_name</literal> 设置为 <literal>true</literal> 。</paragraph>
            <warning>
                <paragraph>如果一个函数在客户端脚本（resp.server脚本）上用 <literal>@rpc</literal> 注释，那么这个函数也必须在服务器脚本（resp.client脚本）上声明。两个RPC必须具有相同的签名，该签名使用 <strong>all RPCs</strong> 的校验和进行评估。同时检查脚本中的所有RPC，并且必须在客户端脚本和服务器脚本上声明所有RPC，<strong>even functions that are currently not in use</strong>。</paragraph>
                <paragraph>RPC 的签名包括 <literal>@rpc()</literal> 声明、函数、返回类型和节点路径。如果 RPC 驻留在附加到 <literal>/root/Main/Node1</literal> 的脚本中，则它必须驻留在客户端脚本和服务器脚本上完全相同的路径和节点中。函数参数（例如 <literal>func sendstuff():</literal> 和 <literal>func sendstuff(arg1, arg2):</literal> <strong>能够成功匹配</strong>签名）。</paragraph>
                <paragraph>如果不满足这些条件（如果所有RPC都没有通过签名匹配），脚本可能会打印错误或导致不必要的行为。错误消息可能与你当前正在构建和测试的RPC函数无关。</paragraph>
                <paragraph>请参阅本帖的进一步解释和故障排除&lt;<reference refuri="https://github.com/godotengine/godot/issues/57869#issuecomment-1034215138">https://github.com/godotengine/godot/issues/57869#issuecomment-1034215138</reference>&gt;`__.</paragraph>
            </warning>
            <paragraph>注释可以采用多个参数，这些参数具有预设值。 <literal>@rpc</literal> 相当于：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@rpc("authority", "call_remote", "unreliable", 0)</literal_block>
            <paragraph>The parameters and their functions are as follows:</paragraph>
            <paragraph><literal>mode</literal>：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>"authority"</literal> ：只有多人权限（服务器）才能远程调用。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>“any_peer”</literal> ：允许客户端进行远程呼叫。用于传输用户输入。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><literal>remotesync</literal> ：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>"call_remote"</literal>: The function will not be called on the local peer.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>“call_local”</literal> ：该函数可以在本地对等机上调用。当服务器也是玩家时很有用。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><literal>transform</literal> ：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>"unreliable"</literal> 数据包不被确认，可能丢失，并且可以按任何顺序到达。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>"unreliable_ordered"</literal> 封包按照发送的顺序接收。这是透过忽略稍后到达的封包（如果已经收到在它们之后发送的另一个封包）来实作的。如果使用不当可能会导致丢包。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>"reliable"</literal> 发送重新传送尝试，直到封包被确认为止，并且它们的顺序被保留。具有显著的性能损失。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><literal>transfer_channel</literal> 是频道索引。</paragraph>
            <paragraph>前3个可以按任何顺序传递，但 <literal>transfer_channel</literal> 必须始终是最后一个。</paragraph>
            <paragraph>当在rpc呼叫的函式中使用时，函式 <literal>multiplayer.get_remote_sender_id()</literal> 可用于取得rpc发送者的唯一ID。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_some_input(): # Connected to some input.
    transfer_some_input.rpc_id(1) # Send the input only to the server.


# Call local is required if the server is also a player.
@rpc("any_peer", "call_local", "reliable")
func transfer_some_input():
    # The server knows who sent the input.
    var sender_id = multiplayer.get_remote_sender_id()
    # Process the input and affect game logic.</literal_block>
        </section>
        <section ids="channels" names="channels 通道">
            <title>通道</title>
            <paragraph>现代网络协定支持信道，信道是连接内的单独连接。这允许多个封包流互不干扰。</paragraph>
            <paragraph>例如，游戏聊天相关讯息和一些核心游戏信息都应该可靠地发送，但游戏信息不应等待聊天信息被确认。这可以透过使用不同的管道来实作。</paragraph>
            <paragraph>当与不可靠的有序传输模式一起使用时，信道也很有用。使用此传输模式发送可变大小的封包可能会导致封包遗失，因为到达较慢的封包将被忽略。透过使用信道将它们分成多个同质封包流，可以实作有序传输，且封包遗失很少，并且不会因可靠模式而导致延迟损失。</paragraph>
            <paragraph>索引为0的默认通道实际上是三个不同的通道——每个传输模式一个。</paragraph>
        </section>
        <section ids="example-lobby-implementation" names="example\ lobby\ implementation 大厅的示例实现">
            <title>大厅的示例实现</title>
            <paragraph>这是一个示例大厅，可以处理同伴的加入和离开，透过信号通知UI场景，并在所有客户端加载游戏场景后启动游戏。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node

# Autoload named Lobby

# These signals can be connected to by a UI lobby scene or the game scene.
signal player_connected(peer_id, player_info)
signal player_disconnected(peer_id)
signal server_disconnected

const PORT = 7000
const DEFAULT_SERVER_IP = "127.0.0.1" # IPv4 localhost
const MAX_CONNECTIONS = 20

# This will contain player info for every player,
# with the keys being each player's unique IDs.
var players = {}

# This is the local player info. This should be modified locally
# before the connection is made. It will be passed to every other peer.
# For example, the value of "name" can be set to something the player
# entered in a UI scene.
var player_info = {"name": "Name"}

var players_loaded = 0



func _ready():
    multiplayer.peer_connected.connect(_on_player_connected)
    multiplayer.peer_disconnected.connect(_on_player_disconnected)
    multiplayer.connected_to_server.connect(_on_connected_ok)
    multiplayer.connection_failed.connect(_on_connected_fail)
    multiplayer.server_disconnected.connect(_on_server_disconnected)


func join_game(address = ""):
    if address.is_empty():
        address = DEFAULT_SERVER_IP
    var peer = ENetMultiplayerPeer.new()
    var error = peer.create_client(address, PORT)
    if error:
        return error
    multiplayer.multiplayer_peer = peer


func create_game():
    var peer = ENetMultiplayerPeer.new()
    var error = peer.create_server(PORT, MAX_CONNECTIONS)
    if error:
        return error
    multiplayer.multiplayer_peer = peer

    players[1] = player_info
    player_connected.emit(1, player_info)


func remove_multiplayer_peer():
    multiplayer.multiplayer_peer = null


# When the server decides to start the game from a UI scene,
# do Lobby.load_game.rpc(filepath)
@rpc("call_local", "reliable")
func load_game(game_scene_path):
    get_tree().change_scene_to_file(game_scene_path)


# Every peer will call this when they have loaded the game scene.
@rpc("any_peer", "call_local", "reliable")
func player_loaded():
    if multiplayer.is_server():
        players_loaded += 1
        if players_loaded == players.size():
            $/root/Game.start_game()
            players_loaded = 0


# When a peer connects, send them my player info.
# This allows transfer of all desired data for each player, not only the unique ID.
func _on_player_connected(id):
    _register_player.rpc_id(id, player_info)


@rpc("any_peer", "reliable")
func _register_player(new_player_info):
    var new_player_id = multiplayer.get_remote_sender_id()
    players[new_player_id] = new_player_info
    player_connected.emit(new_player_id, new_player_info)


func _on_player_disconnected(id):
    players.erase(id)
    player_disconnected.emit(id)


func _on_connected_ok():
    var peer_id = multiplayer.get_unique_id()
    players[peer_id] = player_info
    player_connected.emit(peer_id, player_info)


func _on_connected_fail():
    multiplayer.multiplayer_peer = null


func _on_server_disconnected():
    multiplayer.multiplayer_peer = null
    players.clear()
    server_disconnected.emit()</literal_block>
            <paragraph>游戏场景的根节点应命名为Game。在附加的脚本中：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node3D # Or Node2D.



func _ready():
    # Preconfigure game.

    Lobby.player_loaded.rpc_id(1) # Tell the server that this peer has loaded.


# Called only on the server.
func start_game():
    # All peers are ready to receive RPCs in this scene.</literal_block>
        </section>
        <section ids="exporting-for-dedicated-servers" names="exporting\ for\ dedicated\ servers 为专用服务器导出">
            <title>为专用服务器导出</title>
            <paragraph>一旦你制作了一个多人游戏, 你可能会想导出它到一个没有GPU的专用服务器上运行. 参见 <reference internal="True" refuri="../export/exporting_for_dedicated_servers#doc-exporting-for-dedicated-servers"><inline classes="std std-ref">为专用服务器导出</inline></reference> 获取更多信息.</paragraph>
            <note>
                <paragraph>这个页面上的代码样本并不是为了在专用服务器上运行而设计的. 必须修改它们, 使服务器不被认为是一个玩家, 还必须修改游戏启动机制, 使第一个加入的玩家可以启动游戏.</paragraph>
            </note>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
