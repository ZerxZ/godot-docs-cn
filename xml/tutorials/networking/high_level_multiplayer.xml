<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/networking/high_level_multiplayer.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-high-level-multiplayer"></target>
    <section ids="high-level-multiplayer doc-high-level-multiplayer" names="high-level\ multiplayer 高级多人游戏 doc_high_level_multiplayer">
        <title>高级多人游戏</title>
        <section ids="high-level-vs-low-level-api" names="high-level\ vs\ low-level\ api 高层与底层\ api">
            <title>高层与底层 API</title>
            <paragraph>下面解释了 Godot 高阶、低阶网络的区别以及一些基本原理。如果你想一头扎进去，直接为你的最初的节点添加网络功能，请跳到下面的<reference name="初始化网络" refid="initializing-the-network">初始化网络</reference>。但是请确保稍后阅读其余部分！</paragraph>
            <paragraph>Godot always supported standard low-level networking via <abbreviation explanation="User Datagram Protocol">UDP</abbreviation>, <abbreviation explanation="Transmission Control Protocol">TCP</abbreviation> and some higher-level protocols such as <abbreviation explanation="Hypertext Transfer Protocol">HTTP</abbreviation> and <abbreviation explanation="Secure Sockets Layer">SSL</abbreviation>.
                These protocols are flexible and can be used for almost anything. However, using them to synchronize game state manually can be a large amount of work. Sometimes that work can't be avoided or is worth it, for example when working with a custom server implementation on the backend. But in most cases, it's worthwhile to consider Godot's high-level networking API, which sacrifices some of the fine-grained control of low-level networking for greater ease of use.</paragraph>
            <paragraph>这是底层协议的固有限制所造成的：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>TCP 能够确保数据包总是可靠、有序地到达，但是由于错误纠正，延迟通常更高。它也是一个相当复杂的协议，因为它理解什么是“连接”，它优化的目标也经常不是多人游戏这种应用程序。数据包会被缓冲成更大的批次发送，用更高的延迟来交换更小的单数据包开销。这对于 HTTP 之类的东西可能很有用，但对于游戏通常不太有用。其中一些可以配置和禁用（例如禁用 TCP 连接的“Nagle 算法”）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>UDP 是一个更简单的协议，它只发送数据包（没有“连接”的概念）。因为没有错误纠正，所以非常快（低延迟），但数据包就可能在发生丢失或以错误的顺序接收的情况。此外，UDP 的 MTU（Maximum Packet Size，最大数据包大小）通常很低（只有几百字节），因此传输更大的数据包意味着需要对它们进行分割、重新组织、某一部分失败时还要进行重试。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>一般来说,TCP 可以被认为是可靠的, 有序的和缓慢的; UDP则是不可靠, 无序, 但是速度快. 由于性能上的巨大差异, 在避免不需要的部分(拥塞/流量控制特性, Nagle算法等)的同时, 重新构建游戏所需的TCP部分(可选的可靠性和包顺序)通常是合理的. 正因为如此, 大多数游戏引擎都带有这样的实现,Godot也不例外.</paragraph>
            <paragraph>综上所述, 你可以使用低级网络API来实现最大限度的控制, 并在完全裸露的网络协议之上实现所有功能, 或者使用基于 <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 的高级API, 后者以通常以一种比较优化的方式在后台完成大部分繁重的工作.</paragraph>
            <note>
                <paragraph>Godot 支持的大多数平台都提供所有或大部分上述的高、低网络功能。但是，由于网络在很大程度上依赖于硬件和操作系统，在某些目标平台上一些特性可能会改变或者不可用。最值得注意的是 HTML5 平台目前只提供 WebSocket 和 WebRTC 支持，缺乏一些高级功能，以及对 TCP 和 UDP 等低级协议的原始访问。</paragraph>
            </note>
            <note>
                <paragraph>更多关于TCP/IP, UDP和网络的信息: <reference refuri="https://gafferongames.com/post/udp_vs_tcp/">https://gafferongames.com/post/udp_vs_tcp/</reference></paragraph>
                <paragraph>Gaffer On Games有很多关于游戏中网络的有用文章( <reference name="这里" refuri="https://gafferongames.com/categories/game-networking/">这里</reference> ), 包括全面的 <reference name="游戏中的网络模型介绍" refuri="https://gafferongames.com/post/what_every_programmer_needs_to_know_about_game_networking/">游戏中的网络模型介绍</reference> .</paragraph>
            </note>
            <warning>
                <paragraph>Adding networking to your game comes with some responsibility.
                    It can make your application vulnerable if done wrong and may lead to cheats or exploits.
                    It may even allow an attacker to compromise the machines your application runs on
                    and use your servers to send spam, attack others or steal your users' data if they play your game.</paragraph>
                <paragraph>当涉及到网络而与Godot无关时, 情况总是如此. 当然, 你可以进行试验, 但是在发布网络应用程序时, 请始终注意任何可能的安全问题.</paragraph>
            </warning>
        </section>
        <section ids="mid-level-abstraction" names="mid-level\ abstraction 中级抽象">
            <title>中级抽象</title>
            <paragraph>在讨论我们希望如何跨网络同步游戏之前, 了解用于同步的基本网络API是如何工作的可能会有所帮助.</paragraph>
            <paragraph>Godot uses a mid-level object <reference internal="True" refuri="../../classes/class_multiplayerpeer#class-multiplayerpeer"><inline classes="std std-ref">MultiplayerPeer</inline></reference>.
                This object is not meant to be created directly, but is designed so that several C++ implementations can provide it.</paragraph>
            <paragraph>这个对象扩展自 <reference internal="True" refuri="../../classes/class_packetpeer#class-packetpeer"><inline classes="std std-ref">PacketPeer</inline></reference>, 因此它继承了所有用于序列化, 发送和接收数据的方法. 除此之外, 它还添加了设置节点, 传输模式等的方法. 它同时还包括当节点连接或断开时将通知你的信号.</paragraph>
            <paragraph>This class interface can abstract most types of network layers, topologies and libraries. By default, Godot
                provides an implementation based on ENet (<reference internal="True" refuri="../../classes/class_enetmultiplayerpeer#class-enetmultiplayerpeer"><inline classes="std std-ref">ENetMultiplayerPeer</inline></reference>),
                one based on WebRTC (<reference internal="True" refuri="../../classes/class_webrtcmultiplayerpeer#class-webrtcmultiplayerpeer"><inline classes="std std-ref">WebRTCMultiplayerPeer</inline></reference>), and one based on WebSocket
                (<reference internal="True" refuri="../../classes/class_websocketpeer#class-websocketpeer"><inline classes="std std-ref">WebSocketPeer</inline></reference>), but this could be used to implement
                mobile APIs (for ad hoc WiFi, Bluetooth) or custom device/console-specific networking APIs.</paragraph>
            <paragraph>For most common cases, using this object directly is discouraged, as Godot provides even higher level networking facilities.
                This object is still made available in case a game has specific needs for a lower-level API.</paragraph>
        </section>
        <section ids="hosting-considerations" names="hosting\ considerations 托管注意事项">
            <title>托管注意事项</title>
            <paragraph>托管服务器时， <abbreviation>LAN（局域网）</abbreviation> 上的客户端可以使用内部 IP 地址进行连接，该地址通常是 <literal>192.168.*.*</literal> 格式的。 非 LAN/Internet 客户端 <strong>无法</strong> 访问此内部 IP 地址。</paragraph>
            <paragraph>在 Windows 中， 你可以在命令提示符中输入 <literal>ipconfig</literal> ， 在 macOS 中，你可以在终端中输入 <literal>ifconfig</literal> ，在 Linux 中，你可以在终端中输入 <literal>ip addr</literal> ，从而找到你的内部 IP 地址。</paragraph>
            <paragraph>如果你在自己的机器上托管了服务器，并且想让非内网客户端连接，你可能需要 <emphasis>转发</emphasis> 服务器端口到你的路由。这是使你的服务器能通过互联网访问所必须的，因为大多数家用网络都使用 <title_reference>NAT &lt;https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2&gt;</title_reference> 技术。Godot 的高等级多人 API 只能使用 UDP ，所以你的端口转发必须是 UDP， 不能只转发 TCP。</paragraph>
            <paragraph>在转发了一个 UDP 端口后，确保你的服务器使用这个端口，你可以在 <title_reference>这里 &lt;https://icanhazip.com/&gt;</title_reference> 找到你的公网 IP 地址。然后把这个公网 IP 地址发送给想联机到你服务器的互联网客户端即可。</paragraph>
            <paragraph>Godot 的高等级多人联机 API 使用一个修改过的 ENet 版本，包含全 IPv6 支持。</paragraph>
        </section>
        <section ids="initializing-the-network" names="initializing\ the\ network 初始化网络">
            <title>初始化网络</title>
            <paragraph>High level networking in Godot is managed by the <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.</paragraph>
            <paragraph>Each node has a <literal>multiplayer</literal> property, which is a reference to the <literal>MultiplayerAPI</literal> instance configured for it
                by the scene tree. Initially, every node is configured with the same default <literal>MultiplayerAPI</literal> object.</paragraph>
            <paragraph>It is possible to create a new <literal>MultiplayerAPI</literal> object and assign it to a <literal>NodePath</literal> in the the scene tree,
                which will override <literal>multiplayer</literal> for the node at that path and all of its descendants.
                This allows sibling nodes to be configured with different peers, which makes it possible to run a server
                and a client simultaneously in one instance of Godot.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># By default, these expressions are interchangeable.
multiplayer # Get the MultiplayerAPI object configured for this node.
get_tree().get_multiplayer() # Get the default MultiplayerAPI object.</literal_block>
            <paragraph>为了初始化网络， 你必须初始化一个 <literal>MultiplayerPeer</literal> 对象，初始化为服务端或客户端，然后传给 <literal>MultiplayerAPI</literal> 。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Create client.
var peer = ENetMultiplayerPeer.new()
peer.create_client(IP_ADDRESS, PORT)
multiplayer.multiplayer_peer = peer

# Create server.
var peer = ENetMultiplayerPeer.new()
peer.create_server(PORT, MAX_CLIENTS)
multiplayer.multiplayer_peer = peer</literal_block>
            <paragraph>To terminate networking:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">multiplayer.multiplayer_peer = null</literal_block>
            <warning>
                <paragraph>当导出到 Android 时，在导出项目或使用一键部署之前，确保在 Android 导出预设中启用 <literal>INTERNET</literal> 权限。否则，任何形式的网络通信都会被 Android 系统阻止。</paragraph>
            </warning>
        </section>
        <section ids="managing-connections" names="managing\ connections 管理连接">
            <title>管理连接</title>
            <paragraph>每个 peer 都会被分配一个唯一 ID。服务器的 ID 永远是 1，客户端会被分配一个随机的正整数。</paragraph>
            <paragraph>Responding to connections or disconnections is possible by connecting to <literal>MultiplayerAPI</literal>'s signals:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>peer_connected(id: int)</literal> This signal is emitted with the newly connected peer's ID on each other peer, and on the new peer multiple times, once with each other peer's ID.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>peer_disconnected(id: int)</literal> This signal is emitted on every remaining peer when one disconnects.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The rest are only emitted on clients:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>connected_to_server()</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>connection_failed()</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>server_disconnected()</literal></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>To get the unique ID of the associated peer:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">multiplayer.get_unique_id()</literal_block>
            <paragraph>To check whether the peer is server or client:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">multiplayer.is_server()</literal_block>
        </section>
        <section ids="remote-procedure-calls" names="remote\ procedure\ calls 远程过程调用">
            <title>远程过程调用</title>
            <paragraph>Remote procedure calls, or RPCs, are functions that can be called on other peers. To create one, use the <literal>@rpc</literal> annotation
                before a function definition. To call an RPC, use <literal>Callable</literal>'s method <literal>rpc()</literal> to call in every peer, or <literal>rpc_id()</literal> to
                call in a specific peer.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    if multiplayer.is_server():
        print_once_per_client.rpc()

@rpc
func print_once_per_client():
    print("I will be printed to the console once per each connected client.")</literal_block>
            <paragraph>RPCs will not serialize objects or callables.</paragraph>
            <paragraph>For a remote call to be successful, the sending and receiving node need to have the same <literal>NodePath</literal>, which means they
                must have the same name. When using <literal>add_child()</literal> for nodes which are expected to use RPCs, set the argument
                <literal>force_readable_name</literal> to <literal>true</literal>.</paragraph>
            <warning>
                <paragraph>If a function is annotated with <literal>@rpc</literal> on the client script (resp. server script),
                    then this function must also be declared on the server script (resp. client script).
                    Both RPCs must have the same signature which is evaluated with a checksum of <strong>all RPCs</strong>.
                    All RPCs in a script are checked at once, and all RPCs must be declared on both the client
                    scripts and the server scripts, <strong>even functions that are currently not in use</strong>.</paragraph>
                <paragraph>The signature of the RPC includes the <literal>@rpc()</literal> declaration, the function, return type,
                    AND the nodepath. If an RPC resides in a script attached to <literal>/root/Main/Node1</literal>, then it
                    must reside in precisely the same path and node on both the client script and the server
                    script. Function arguments (example: <literal>func sendstuff():</literal> and <literal>func sendstuff(arg1, arg2):</literal>
                    <strong>will pass</strong> signature matching).</paragraph>
                <paragraph>If these conditions are not met (if all RPCs do not pass signature matching), the script may print an
                    error or cause unwanted behavior. The error message may be unrelated to the RPC function you are
                    currently building and testing.</paragraph>
                <paragraph>See further explanation and troubleshooting on <reference name="this post" refuri="https://github.com/godotengine/godot/issues/57869#issuecomment-1034215138">this post</reference>.</paragraph>
            </warning>
            <paragraph>The annotation can take a number of arguments, which have default values. <literal>@rpc</literal> is equivalent to:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@rpc("authority", "call_remote", "unreliable", 0)</literal_block>
            <paragraph>The parameters and their functions are as follows:</paragraph>
            <paragraph><literal>mode</literal>：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>"authority"</literal>: Only the multiplayer authority (the server) can call remotely.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>"any_peer"</literal>: Clients are allowed to call remotely. Useful for transferring user input.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><literal>remotesync</literal> ：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>"call_remote"</literal>: The function will not be called on the local peer.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>"call_local"</literal>: The function can be called on the local peer. Useful when the server is also a player.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><literal>transform</literal> ：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>"unreliable"</literal> Packets are not acknowledged, can be lost, and can arrive at any order.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>"unreliable_ordered"</literal> Packets are received in the order they were sent in. This is achieved by ignoring packets that arrive later if another that was sent after them has already been received. Can cause packet loss if used incorrectly.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>"reliable"</literal> Resend attempts are sent until packets are acknowledged, and their order is preserved. Has a significant performance penalty.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><literal>transfer_channel</literal> is the channel index.</paragraph>
            <paragraph>The first 3 can be passed in any order, but <literal>transfer_channel</literal> must always be last.</paragraph>
            <paragraph>The function <literal>multiplayer.get_remote_sender_id()</literal> can be used to get the unique id of an rpc sender, when used within the function called by rpc.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_some_input(): # Connected to some input.
    transfer_some_input.rpc_id(1) # Send the input only to the server.


# Call local is required if the server is also a player.
@rpc("any_peer", "call_local", "reliable")
func transfer_some_input():
    # The server knows who sent the input.
    var sender_id = multiplayer.get_remote_sender_id()
    # Process the input and affect game logic.</literal_block>
        </section>
        <section ids="channels" names="channels 通道">
            <title>通道</title>
            <paragraph>Modern networking protocols support channels, which are separate connections within the connection. This allows for multiple
                streams of packets that do not interfere with each other.</paragraph>
            <paragraph>For example, game chat related messages and some of the core gameplay messages should all be sent reliably, but a gameplay
                message should not wait for a chat message to be acknowledged. This can be achieved by using different channels.</paragraph>
            <paragraph>Channels are also useful when used with the unreliable ordered transfer mode. Sending packets of variable size with this transfer mode can
                cause packet loss, since packets which are slower to arrive are ignored. Separating them into multiple streams of homogeneous packets
                by using channels allows ordered transfer with little packet loss, and without the latency penalty caused by reliable mode.</paragraph>
            <paragraph>The default channel with index 0 is actually three different channels - one for each transfer mode.</paragraph>
        </section>
        <section ids="example-lobby-implementation" names="example\ lobby\ implementation 大厅的示例实现">
            <title>大厅的示例实现</title>
            <paragraph>This is an example lobby that can handle peers joining and leaving, notify UI scenes through signals, and start the game after all clients
                have loaded the game scene.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node

# Autoload named Lobby

# These signals can be connected to by a UI lobby scene or the game scene.
signal player_connected(peer_id, player_info)
signal player_disconnected(peer_id)
signal server_disconnected

const PORT = 7000
const DEFAULT_SERVER_IP = "127.0.0.1" # IPv4 localhost
const MAX_CONNECTIONS = 20

# This will contain player info for every player,
# with the keys being each player's unique IDs.
var players = {}

# This is the local player info. This should be modified locally
# before the connection is made. It will be passed to every other peer.
# For example, the value of "name" can be set to something the player
# entered in a UI scene.
var player_info = {"name": "Name"}

var players_loaded = 0



func _ready():
    multiplayer.peer_connected.connect(_on_player_connected)
    multiplayer.peer_disconnected.connect(_on_player_disconnected)
    multiplayer.connected_to_server.connect(_on_connected_ok)
    multiplayer.connection_failed.connect(_on_connected_fail)
    multiplayer.server_disconnected.connect(_on_server_disconnected)


func join_game(address = ""):
    if address.is_empty():
        address = DEFAULT_SERVER_IP
    var peer = ENetMultiplayerPeer.new()
    var error = peer.create_client(address, PORT)
    if error:
        return error
    multiplayer.multiplayer_peer = peer


func create_game():
    var peer = ENetMultiplayerPeer.new()
    var error = peer.create_server(PORT, MAX_CONNECTIONS)
    if error:
        return error
    multiplayer.multiplayer_peer = peer

    players[1] = player_info
    player_connected.emit(1, player_info)


func remove_multiplayer_peer():
    multiplayer.multiplayer_peer = null


# When the server decides to start the game from a UI scene,
# do Lobby.load_game.rpc(filepath)
@rpc("call_local", "reliable")
func load_game(game_scene_path):
    get_tree().change_scene_to_file(game_scene_path)


# Every peer will call this when they have loaded the game scene.
@rpc("any_peer", "call_local", "reliable")
func player_loaded():
    if multiplayer.is_server():
        players_loaded += 1
        if players_loaded == players.size():
            $/root/Game.start_game()
            players_loaded = 0


# When a peer connects, send them my player info.
# This allows transfer of all desired data for each player, not only the unique ID.
func _on_player_connected(id):
    _register_player.rpc_id(id, player_info)


@rpc("any_peer", "reliable")
func _register_player(new_player_info):
    var new_player_id = multiplayer.get_remote_sender_id()
    players[new_player_id] = new_player_info
    player_connected.emit(new_player_id, new_player_info)


func _on_player_disconnected(id):
    players.erase(id)
    player_disconnected.emit(id)


func _on_connected_ok():
    var peer_id = multiplayer.get_unique_id()
    players[peer_id] = player_info
    player_connected.emit(peer_id, player_info)


func _on_connected_fail():
    multiplayer.multiplayer_peer = null


func _on_server_disconnected():
    multiplayer.multiplayer_peer = null
    players.clear()
    server_disconnected.emit()</literal_block>
            <paragraph>The game scene's root node should be named Game. In the script attached to it:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node3D # Or Node2D.



func _ready():
    # Preconfigure game.

    Lobby.player_loaded.rpc_id(1) # Tell the server that this peer has loaded.


# Called only on the server.
func start_game():
    # All peers are ready to receive RPCs in this scene.</literal_block>
        </section>
        <section ids="exporting-for-dedicated-servers" names="exporting\ for\ dedicated\ servers 为专用服务器导出">
            <title>为专用服务器导出</title>
            <paragraph>一旦你制作了一个多人游戏, 你可能会想导出它到一个没有GPU的专用服务器上运行. 参见 <reference internal="True" refuri="../export/exporting_for_dedicated_servers#doc-exporting-for-dedicated-servers"><inline classes="std std-ref">为专用服务器导出</inline></reference> 获取更多信息.</paragraph>
            <note>
                <paragraph>这个页面上的代码样本并不是为了在专用服务器上运行而设计的. 必须修改它们, 使服务器不被认为是一个玩家, 还必须修改游戏启动机制, 使第一个加入的玩家可以启动游戏.</paragraph>
            </note>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
