<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/networking/http_request_class.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-http-request-class"></target>
    <section ids="making-http-requests doc-http-request-class" names="making\ http\ requests 进行\ http\ 请求 doc_http_request_class">
        <title>进行 HTTP 请求</title>
        <section ids="why-use-http" names="why\ use\ http? 为什么使用\ http？">
            <title>为什么使用 HTTP？</title>
            <paragraph><reference name="HTTP 请求" refuri="https://developer.mozilla.org/en-US/docs/Web/HTTP">HTTP 请求</reference><target ids="http" names="http\ 请求" refuri="https://developer.mozilla.org/en-US/docs/Web/HTTP"></target>可以用来与 Web 服务器以及其他非 Godot 程序通信。</paragraph>
            <paragraph>与 Godot 的其他网络功能（例如<reference internal="True" refuri="high_level_multiplayer#doc-high-level-multiplayer"><inline classes="std std-ref">高阶多人游戏</inline></reference>）相比，HTTP 请求的额外开销更大，起步也更慢，所以并不适合实时通信，也不善于进行多人游戏中常见的大量较小更新的发送。</paragraph>
            <paragraph>HTTP, however, offers interoperability with external
                web resources and is great at sending and receiving large amounts
                of data, for example to transfer files like game assets. These assets can then
                be loaded using
                <reference internal="True" refuri="../io/runtime_file_loading_and_saving#doc-runtime-loading-and-saving"><inline classes="std std-ref">runtime file loading and saving</inline></reference>.</paragraph>
            <paragraph>所以 HTTP 可以用在游戏的登录系统、大厅浏览器，可以从 Web 获取信息，也可以下载游戏资产。</paragraph>
            <paragraph>本教学假设你对Godot和Godot编辑器有一定的了解。请参阅 <reference internal="True" refuri="../../getting_started/introduction/index#toc-learn-introduction"><inline classes="std std-ref">Introduction</inline></reference> 和 <reference internal="True" refuri="../../getting_started/step_by_step/index#toc-learn-step-by-step"><inline classes="std std-ref">Step by step</inline></reference> 教学课程，特别是其 <reference internal="True" refuri="../../getting_started/step_by_step/nodes_and_scenes#doc-nodes-and-scenes"><inline classes="std std-ref">Nodes and Scenes</inline></reference> 和 <reference internal="True" refuri="../../getting_started/step_by_step/scripting_first_script#doc-scripting-first-script"><inline classes="std std-ref">Creating your first script</inline></reference> 页面。</paragraph>
        </section>
        <section ids="http-requests-in-godot" names="http\ requests\ in\ godot godot\ 中的\ http\ 请求">
            <title>Godot 中的 HTTP 请求</title>
            <paragraph>在Godot中, 用 <reference internal="True" refuri="../../classes/class_httprequest#class-httprequest"><inline classes="std std-ref">HTTPRequest</inline></reference> 节点发出HTTP请求是最简单的方法. 它继承自更低级别的 <reference internal="True" refuri="../../classes/class_httpclient#class-httpclient"><inline classes="std std-ref">HTTPClient</inline></reference> , 相关的教程见 <reference internal="True" refuri="http_client_class#doc-http-client-class"><inline classes="std std-ref">here</inline></reference>.</paragraph>
            <paragraph>对于此示例，我们将向GitHub发出HTTP请求以检索最新Godot版本的名称。</paragraph>
            <warning>
                <paragraph>When exporting to <strong>Android</strong>, make sure to enable the <strong>Internet</strong>
                    permission in the Android export preset before exporting the project or
                    using one-click deploy. Otherwise, network communication of any kind will be
                    blocked by the Android OS.</paragraph>
            </warning>
        </section>
        <section ids="preparing-the-scene" names="preparing\ the\ scene 准备场景">
            <title>准备场景</title>
            <paragraph>Create a new empty scene, add a root <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> and add a script to it.
                Then add an <reference internal="True" refuri="../../classes/class_httprequest#class-httprequest"><inline classes="std std-ref">HTTPRequest</inline></reference> node as a child.</paragraph>
            <image candidates="{'*': 'tutorials/networking/img/rest_api_scene.webp'}" uri="tutorials/networking/img/rest_api_scene.webp"></image>
        </section>
        <section ids="scripting-the-request" names="scripting\ the\ request 编写请求脚本">
            <title>编写请求脚本</title>
            <paragraph>当项目启动时（所以在 <literal>_ready()</literal> 中），我们将使用 <reference internal="True" refuri="../../classes/class_httprequest#class-httprequest"><inline classes="std std-ref">HTTPRequest</inline></reference> 节点向Github发送HTTP请求，一旦请求完成，我们就将解析传回的JSON数据，搜寻 <literal>name</literal> 字段并将其打印到控制台。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

func _ready():
    $HTTPRequest.request_completed.connect(_on_request_completed)
    $HTTPRequest.request("https://api.github.com/repos/godotengine/godot/releases/latest")

func _on_request_completed(result, response_code, headers, body):
    var json = JSON.parse_string(body.get_string_from_utf8())
    print(json["name"])</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;
using System.Text;

public partial class MyNode : Node
{
    public override void _Ready()
    {
        HttpRequest httpRequest = GetNode&lt;HttpRequest&gt;("HTTPRequest");
        httpRequest.RequestCompleted += OnRequestCompleted;
        httpRequest.Request("https://api.github.com/repos/godotengine/godot/releases/latest");
    }

    private void OnRequestCompleted(long result, long responseCode, string[] headers, byte[] body)
    {
        Godot.Collections.Dictionary json = Json.ParseString(Encoding.UTF8.GetString(body)).AsGodotDictionary();
        GD.Print(json["name"]);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>保存脚本和场景，然后运行项目。Github上最新的Godot版本的名称应该打印到输出日志中。有关解析JSON的更多信息，请参阅类引用 <reference internal="True" refuri="../../classes/class_json#class-json"><inline classes="std std-ref">JSON</inline></reference>。</paragraph>
            <paragraph>请注意, 你可能需要检查 <literal>result</literal> 是否等于 <literal>RESULT_SUCCESS</literal> 以及JSON解析错误是否发生, 要了解更多信息, 请参阅JSON类型参考和 <reference internal="True" refuri="../../classes/class_httprequest#class-httprequest"><inline classes="std std-ref">HTTPRequest</inline></reference> .</paragraph>
            <paragraph>You have to wait for a request to finish before sending another one.
                Making multiple request at once requires you to have one node per request.
                A common strategy is to create and delete HTTPRequest nodes at runtime as necessary.</paragraph>
        </section>
        <section ids="sending-data-to-the-server" names="sending\ data\ to\ the\ server 向服务器发送数据">
            <title>向服务器发送数据</title>
            <paragraph>到目前为止, 我们仅限于从服务器上请求数据. 但如果你需要向服务器发送数据呢？这里有一个常见的方法:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var json = JSON.stringify(data_to_send)
var headers = ["Content-Type: application/json"]
$HTTPRequest.request(url, headers, HTTPClient.METHOD_POST, json)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">string json = Json.Stringify(dataToSend);
string[] headers = new string[] { "Content-Type: application/json" };
HttpRequest httpRequest = GetNode&lt;HttpRequest&gt;("HTTPRequest");
httpRequest.Request(url, headers, HttpClient.Method.Post, json);</literal_block>
                </div>
            </container>
        </section>
        <section ids="setting-custom-http-headers" names="setting\ custom\ http\ headers 设置自定义\ http\ 报头">
            <title>设置自定义 HTTP 报头</title>
            <paragraph>Of course, you can also set custom HTTP headers. These are given as a string array,
                with each string containing a header in the format <literal>"header: value"</literal>.
                For example, to set a custom user agent (the HTTP <literal>User-Agent</literal> header) you could use the following:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">$HTTPRequest.request("https://api.github.com/repos/godotengine/godot/releases/latest", ["User-Agent: YourCustomUserAgent"])</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">HttpRequest httpRequest = GetNode&lt;HttpRequest&gt;("HTTPRequest");
httpRequest.Request("https://api.github.com/repos/godotengine/godot/releases/latest", new string[] { "User-Agent: YourCustomUserAgent" });</literal_block>
                </div>
            </container>
            <warning>
                <paragraph>Be aware that someone might analyse and decompile your released application and
                    thus may gain access to any embedded authorization information like tokens, usernames or passwords.
                    That means it is usually not a good idea to embed things such as database
                    access credentials inside your game. Avoid providing information useful to an attacker whenever possible.</paragraph>
            </warning>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
