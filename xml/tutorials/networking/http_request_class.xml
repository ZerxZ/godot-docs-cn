<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/networking/http_request_class.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-http-request-class"></target>
    <section ids="making-http-requests doc-http-request-class" names="making\ http\ requests 进行\ http\ 请求 doc_http_request_class">
        <title>进行 HTTP 请求</title>
        <section ids="why-use-http" names="why\ use\ http? 为什么使用\ http？">
            <title>为什么使用 HTTP？</title>
            <paragraph><reference name="HTTP 请求" refuri="https://developer.mozilla.org/en-US/docs/Web/HTTP">HTTP 请求</reference><target ids="http" names="http\ 请求" refuri="https://developer.mozilla.org/en-US/docs/Web/HTTP"></target>可以用来与 Web 服务器以及其他非 Godot 程序通信。</paragraph>
            <paragraph>与 Godot 的其他网络功能（例如<reference internal="True" refuri="high_level_multiplayer#doc-high-level-multiplayer"><inline classes="std std-ref">高阶多人游戏</inline></reference>）相比，HTTP 请求的额外开销更大，起步也更慢，所以并不适合实时通信，也不善于进行多人游戏中常见的大量较小更新的发送。</paragraph>
            <paragraph>HTTP, however, offers interoperability with external
                web resources and is great at sending and receiving large amounts
                of data, for example to transfer files like game assets. These assets can then
                be loaded using
                <reference internal="True" refuri="../io/runtime_file_loading_and_saving#doc-runtime-loading-and-saving"><inline classes="std std-ref">runtime file loading and saving</inline></reference>.</paragraph>
            <paragraph>所以 HTTP 可以用在游戏的登录系统、大厅浏览器，可以从 Web 获取信息，也可以下载游戏资产。</paragraph>
            <paragraph>This tutorial assumes some familiarity with Godot and the Godot Editor.
                Refer to the <reference internal="True" refuri="../../getting_started/introduction/index#toc-learn-introduction"><inline classes="std std-ref">Introduction</inline></reference> and the
                <reference internal="True" refuri="../../getting_started/step_by_step/index#toc-learn-step-by-step"><inline classes="std std-ref">Step by step</inline></reference> tutorial, especially its
                <reference internal="True" refuri="../../getting_started/step_by_step/nodes_and_scenes#doc-nodes-and-scenes"><inline classes="std std-ref">Nodes and Scenes</inline></reference> and
                <reference internal="True" refuri="../../getting_started/step_by_step/scripting_first_script#doc-scripting-first-script"><inline classes="std std-ref">Creating your first script</inline></reference> pages if needed.</paragraph>
        </section>
        <section ids="http-requests-in-godot" names="http\ requests\ in\ godot godot\ 中的\ http\ 请求">
            <title>Godot 中的 HTTP 请求</title>
            <paragraph>在Godot中, 用 <reference internal="True" refuri="../../classes/class_httprequest#class-httprequest"><inline classes="std std-ref">HTTPRequest</inline></reference> 节点发出HTTP请求是最简单的方法. 它继承自更低级别的 <reference internal="True" refuri="../../classes/class_httpclient#class-httpclient"><inline classes="std std-ref">HTTPClient</inline></reference> , 相关的教程见 <reference internal="True" refuri="http_client_class#doc-http-client-class"><inline classes="std std-ref">here</inline></reference>.</paragraph>
            <paragraph>For this example, we will make an HTTP request to GitHub to retrieve the name
                of the latest Godot release.</paragraph>
            <warning>
                <paragraph>When exporting to <strong>Android</strong>, make sure to enable the <strong>Internet</strong>
                    permission in the Android export preset before exporting the project or
                    using one-click deploy. Otherwise, network communication of any kind will be
                    blocked by the Android OS.</paragraph>
            </warning>
        </section>
        <section ids="preparing-the-scene" names="preparing\ the\ scene 准备场景">
            <title>准备场景</title>
            <paragraph>Create a new empty scene, add a root <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> and add a script to it.
                Then add a <reference internal="True" refuri="../../classes/class_httprequest#class-httprequest"><inline classes="std std-ref">HTTPRequest</inline></reference> node as a child.</paragraph>
            <image candidates="{'*': 'tutorials/networking/img/rest_api_scene.webp'}" uri="tutorials/networking/img/rest_api_scene.webp"></image>
        </section>
        <section ids="scripting-the-request" names="scripting\ the\ request 编写请求脚本">
            <title>编写请求脚本</title>
            <paragraph>When the project is started (so in <literal>_ready()</literal>), we're going to send an HTTP request
                to Github using our <reference internal="True" refuri="../../classes/class_httprequest#class-httprequest"><inline classes="std std-ref">HTTPRequest</inline></reference> node,
                and once the request completes, we're going to parse the returned JSON data,
                look for the <literal>name</literal> field and print that to console.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

func _ready():
    $HTTPRequest.request_completed.connect(_on_request_completed)
    $HTTPRequest.request("https://api.github.com/repos/godotengine/godot/releases/latest")

func _on_request_completed(result, response_code, headers, body):
    var json = JSON.parse_string(body.get_string_from_utf8())
    print(json["name"])</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;
using System.Text;

public partial class MyNode : Node
{
    public override void _Ready()
    {
        HttpRequest httpRequest = GetNode&lt;HttpRequest&gt;("HTTPRequest");
        httpRequest.RequestCompleted += OnRequestCompleted;
        httpRequest.Request("https://api.github.com/repos/godotengine/godot/releases/latest");
    }

    private void OnRequestCompleted(long result, long responseCode, string[] headers, byte[] body)
    {
        Godot.Collections.Dictionary json = Json.ParseString(Encoding.UTF8.GetString(body)).AsGodotDictionary();
        GD.Print(json["name"]);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>Save the script and the scene, and run the project.
                The name of the most recent Godot release on Github should be printed to the output log.
                For more information on parsing JSON, see the class references for <reference internal="True" refuri="../../classes/class_json#class-json"><inline classes="std std-ref">JSON</inline></reference>.</paragraph>
            <paragraph>请注意, 你可能需要检查 <literal>result</literal> 是否等于 <literal>RESULT_SUCCESS</literal> 以及JSON解析错误是否发生, 要了解更多信息, 请参阅JSON类型参考和 <reference internal="True" refuri="../../classes/class_httprequest#class-httprequest"><inline classes="std std-ref">HTTPRequest</inline></reference> .</paragraph>
            <paragraph>You have to wait for a request to finish before sending another one.
                Making multiple request at once requires you to have one node per request.
                A common strategy is to create and delete HTTPRequest nodes at runtime as necessary.</paragraph>
        </section>
        <section ids="sending-data-to-the-server" names="sending\ data\ to\ the\ server 向服务器发送数据">
            <title>向服务器发送数据</title>
            <paragraph>到目前为止, 我们仅限于从服务器上请求数据. 但如果你需要向服务器发送数据呢？这里有一个常见的方法:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var json = JSON.stringify(data_to_send)
var headers = ["Content-Type: application/json"]
$HTTPRequest.request(url, headers, HTTPClient.METHOD_POST, json)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">string json = Json.Stringify(dataToSend);
string[] headers = new string[] { "Content-Type: application/json" };
HttpRequest httpRequest = GetNode&lt;HttpRequest&gt;("HTTPRequest");
httpRequest.Request(url, headers, HttpClient.Method.Post, json);</literal_block>
                </div>
            </container>
        </section>
        <section ids="setting-custom-http-headers" names="setting\ custom\ http\ headers 设置自定义\ http\ 报头">
            <title>设置自定义 HTTP 报头</title>
            <paragraph>Of course, you can also set custom HTTP headers. These are given as a string array,
                with each string containing a header in the format <literal>"header: value"</literal>.
                For example, to set a custom user agent (the HTTP <literal>User-Agent</literal> header) you could use the following:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">$HTTPRequest.request("https://api.github.com/repos/godotengine/godot/releases/latest", ["User-Agent: YourCustomUserAgent"])</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">HttpRequest httpRequest = GetNode&lt;HttpRequest&gt;("HTTPRequest");
httpRequest.Request("https://api.github.com/repos/godotengine/godot/releases/latest", new string[] { "User-Agent: YourCustomUserAgent" });</literal_block>
                </div>
            </container>
            <warning>
                <paragraph>Be aware that someone might analyse and decompile your released application and
                    thus may gain access to any embedded authorization information like tokens, usernames or passwords.
                    That means it is usually not a good idea to embed things such as database
                    access credentials inside your game. Avoid providing information useful to an attacker whenever possible.</paragraph>
            </warning>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
