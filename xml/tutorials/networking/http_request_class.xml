<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/networking/http_request_class.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-http-request-class"></target>
    <section ids="making-http-requests doc-http-request-class" names="making\ http\ requests doc_http_request_class">
        <title>Making HTTP requests</title>
        <section ids="why-use-http" names="why\ use\ http?">
            <title>Why use HTTP?</title>
            <paragraph><reference name="HTTP requests" refuri="https://developer.mozilla.org/en-US/docs/Web/HTTP">HTTP requests</reference><target ids="http-requests" names="http\ requests" refuri="https://developer.mozilla.org/en-US/docs/Web/HTTP"></target> are useful
                to communicate with web servers and other non-Godot programs.</paragraph>
            <paragraph>Compared to Godot's other networking features (like
                <reference internal="True" refuri="high_level_multiplayer#doc-high-level-multiplayer"><inline classes="std std-ref">High-level multiplayer</inline></reference>),
                HTTP requests have more overhead and take more time to get going,
                so they aren't suited for real-time communication, and aren't great to send
                lots of small updates as is common for multiplayer gameplay.</paragraph>
            <paragraph>HTTP, however, offers interoperability with external
                web resources and is great at sending and receiving large amounts
                of data, for example to transfer files like game assets. These assets can then
                be loaded using
                <reference internal="True" refuri="../io/runtime_file_loading_and_saving#doc-runtime-loading-and-saving"><inline classes="std std-ref">runtime file loading and saving</inline></reference>.</paragraph>
            <paragraph>So HTTP may be useful for your game's login system, lobby browser,
                to retrieve some information from the web or to download game assets.</paragraph>
        </section>
        <section ids="http-requests-in-godot" names="http\ requests\ in\ godot">
            <title>HTTP requests in Godot</title>
            <paragraph>The <reference internal="True" refuri="../../classes/class_httprequest#class-httprequest"><inline classes="std std-ref">HTTPRequest</inline></reference> node is the easiest way to make HTTP requests in Godot.
                It is backed by the more low-level <reference internal="True" refuri="../../classes/class_httpclient#class-httpclient"><inline classes="std std-ref">HTTPClient</inline></reference>,
                for which a tutorial is available <reference internal="True" refuri="http_client_class#doc-http-client-class"><inline classes="std std-ref">here</inline></reference>.</paragraph>
            <paragraph>For this example, we will make an HTTP request to GitHub to retrieve the name
                of the latest Godot release.</paragraph>
            <warning>
                <paragraph>When exporting to <strong>Android</strong>, make sure to enable the <strong>Internet</strong>
                    permission in the Android export preset before exporting the project or
                    using one-click deploy. Otherwise, network communication of any kind will be
                    blocked by the Android OS.</paragraph>
            </warning>
        </section>
        <section ids="preparing-the-scene" names="preparing\ the\ scene">
            <title>Preparing the scene</title>
            <paragraph>Create a new empty scene, add a root <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> and add a script to it.
                Then add an <reference internal="True" refuri="../../classes/class_httprequest#class-httprequest"><inline classes="std std-ref">HTTPRequest</inline></reference> node as a child.</paragraph>
            <image candidates="{'*': 'tutorials/networking/img/rest_api_scene.webp'}" original_uri="img/rest_api_scene.webp" uri="tutorials/networking/img/rest_api_scene.webp"></image>
        </section>
        <section ids="scripting-the-request" names="scripting\ the\ request">
            <title>Scripting the request</title>
            <paragraph>When the project is started (so in <literal>_ready()</literal>), we're going to send an HTTP request
                to Github using our <reference internal="True" refuri="../../classes/class_httprequest#class-httprequest"><inline classes="std std-ref">HTTPRequest</inline></reference> node,
                and once the request completes, we're going to parse the returned JSON data,
                look for the <literal>name</literal> field and print that to console.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

func _ready():
    $HTTPRequest.request_completed.connect(_on_request_completed)
    $HTTPRequest.request("https://api.github.com/repos/godotengine/godot/releases/latest")

func _on_request_completed(result, response_code, headers, body):
    var json = JSON.parse_string(body.get_string_from_utf8())
    print(json["name"])</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;
using System.Text;

public partial class MyNode : Node
{
    public override void _Ready()
    {
        HttpRequest httpRequest = GetNode&lt;HttpRequest&gt;("HTTPRequest");
        httpRequest.RequestCompleted += OnRequestCompleted;
        httpRequest.Request("https://api.github.com/repos/godotengine/godot/releases/latest");
    }

    private void OnRequestCompleted(long result, long responseCode, string[] headers, byte[] body)
    {
        Godot.Collections.Dictionary json = Json.ParseString(Encoding.UTF8.GetString(body)).AsGodotDictionary();
        GD.Print(json["name"]);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>Save the script and the scene, and run the project.
                The name of the most recent Godot release on Github should be printed to the output log.
                For more information on parsing JSON, see the class references for <reference internal="True" refuri="../../classes/class_json#class-json"><inline classes="std std-ref">JSON</inline></reference>.</paragraph>
            <paragraph>Note that you may want to check whether the <literal>result</literal> equals <literal>RESULT_SUCCESS</literal>
                and whether a JSON parsing error occurred, see the JSON class reference and
                <reference internal="True" refuri="../../classes/class_httprequest#class-httprequest"><inline classes="std std-ref">HTTPRequest</inline></reference> for more.</paragraph>
            <paragraph>You have to wait for a request to finish before sending another one.
                Making multiple request at once requires you to have one node per request.
                A common strategy is to create and delete HTTPRequest nodes at runtime as necessary.</paragraph>
        </section>
        <section ids="sending-data-to-the-server" names="sending\ data\ to\ the\ server">
            <title>Sending data to the server</title>
            <paragraph>Until now, we have limited ourselves to requesting data from a server.
                But what if you need to send data to the server? Here is a common way of doing it:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var json = JSON.stringify(data_to_send)
var headers = ["Content-Type: application/json"]
$HTTPRequest.request(url, headers, HTTPClient.METHOD_POST, json)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">string json = Json.Stringify(dataToSend);
string[] headers = ["Content-Type: application/json"];
HttpRequest httpRequest = GetNode&lt;HttpRequest&gt;("HTTPRequest");
httpRequest.Request(url, headers, HttpClient.Method.Post, json);</literal_block>
                </div>
            </container>
        </section>
        <section ids="setting-custom-http-headers" names="setting\ custom\ http\ headers">
            <title>Setting custom HTTP headers</title>
            <paragraph>Of course, you can also set custom HTTP headers. These are given as a string array,
                with each string containing a header in the format <literal>"header: value"</literal>.
                For example, to set a custom user agent (the HTTP <literal>User-Agent</literal> header) you could use the following:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">$HTTPRequest.request("https://api.github.com/repos/godotengine/godot/releases/latest", ["User-Agent: YourCustomUserAgent"])</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">HttpRequest httpRequest = GetNode&lt;HttpRequest&gt;("HTTPRequest");
httpRequest.Request("https://api.github.com/repos/godotengine/godot/releases/latest", ["User-Agent: YourCustomUserAgent"]);</literal_block>
                </div>
            </container>
            <danger>
                <paragraph>Be aware that someone might analyse and decompile your released application and
                    thus may gain access to any embedded authorization information like tokens, usernames or passwords.
                    That means it is usually not a good idea to embed things such as database
                    access credentials inside your game. Avoid providing information useful to an attacker whenever possible.</paragraph>
            </danger>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
