<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/networking/webrtc.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-webrtc"></target>
    <section dupnames="webrtc" ids="webrtc doc-webrtc" names="doc_webrtc">
        <title>WebRTC</title>
        <section ids="html5-websocket-webrtc" names="html5,\ websocket,\ webrtc">
            <title>HTML5, WebSocket, WebRTC</title>
            <paragraph>One of Godot's great features is its ability to export to the HTML5/WebAssembly platform, allowing your game to run directly in the browser when a user visit your webpage.</paragraph>
            <paragraph>This is a great opportunity for both demos and full games, but used to come with some limitations. In the area of networking, browsers used to support only HTTPRequests until recently, when first WebSocket and then WebRTC were proposed as standards.</paragraph>
            <section ids="websocket" names="websocket">
                <title>WebSocket</title>
                <paragraph>When the WebSocket protocol was standardized in December 2011, it allowed browsers to create stable and bidirectional connections to a WebSocket server. The protocol is a very powerful tool to send push notifications to browsers, and has been used to implement chats, turn-based games, etc.</paragraph>
                <paragraph>WebSockets, though, still use a TCP connection, which is good for reliability but not for latency, so not good for real-time applications like VoIP and fast-paced games.</paragraph>
            </section>
            <section dupnames="webrtc" ids="id1">
                <title>WebRTC</title>
                <paragraph>For this reason, since 2010, Google started working on a new technology called WebRTC, which later on, in 2017, became a W3C candidate recommendation. WebRTC is a much more complex set of specifications, and relies on many other technologies behind the scenes (ICE, DTLS, SDP) to provide fast, real-time, and secure communication between two peers.</paragraph>
                <paragraph>The idea is to find the fastest route between the two peers and establish whenever possible a direct communication (i.e. try to avoid a relaying server).</paragraph>
                <paragraph>However, this comes at a price, which is that some media information must be exchanged between the two peers before the communication can start (in the form of Session Description Protocol - SDP strings). This usually takes the form of a so-called WebRTC Signaling Server.</paragraph>
                <image candidates="{'*': 'tutorials/networking/img/webrtc_signaling.png'}" original_uri="img/webrtc_signaling.png" uri="tutorials/networking/img/webrtc_signaling.png"></image>
                <paragraph>Peers connect to a signaling server (for example a WebSocket server) and send their media information. The server then relays this information to other peers, allowing them to establish the desired direct communication. Once this step is done, peers can disconnect from the signaling server and keep the direct Peer-to-Peer (P2P) connection open.</paragraph>
            </section>
        </section>
        <section ids="using-webrtc-in-godot" names="using\ webrtc\ in\ godot">
            <title>Using WebRTC in Godot</title>
            <paragraph>WebRTC is implemented in Godot via two main classes <reference internal="True" refuri="../../classes/class_webrtcpeerconnection#class-webrtcpeerconnection"><inline classes="std std-ref">WebRTCPeerConnection</inline></reference> and <reference internal="True" refuri="../../classes/class_webrtcdatachannel#class-webrtcdatachannel"><inline classes="std std-ref">WebRTCDataChannel</inline></reference>, plus the multiplayer API implementation <reference internal="True" refuri="../../classes/class_webrtcmultiplayerpeer#class-webrtcmultiplayerpeer"><inline classes="std std-ref">WebRTCMultiplayerPeer</inline></reference>. See section on <reference internal="True" refuri="high_level_multiplayer#doc-high-level-multiplayer"><inline classes="std std-ref">high-level multiplayer</inline></reference> for more details.</paragraph>
            <note>
                <paragraph>These classes are available automatically in HTML5, but <strong>require an external GDExtension plugin on native (non-HTML5) platforms</strong>. Check out the <reference name="webrtc-native plugin repository" refuri="https://github.com/godotengine/webrtc-native">webrtc-native plugin repository</reference> for instructions and to get the latest <reference name="release" refuri="https://github.com/godotengine/webrtc-native/releases">release</reference>.</paragraph>
            </note>
            <warning>
                <paragraph>When exporting to Android, make sure to enable the <literal>INTERNET</literal>
                    permission in the Android export preset before exporting the project or
                    using one-click deploy. Otherwise, network communication of any kind will be
                    blocked by Android.</paragraph>
            </warning>
            <section ids="minimal-connection-example" names="minimal\ connection\ example">
                <title>Minimal connection example</title>
                <paragraph>This example will show you how to create a WebRTC connection between two peers in the same application.
                    This is not very useful in real life, but will give you a good overview of how a WebRTC connection is set up.</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node

# Create the two peers
var p1 = WebRTCPeerConnection.new()
var p2 = WebRTCPeerConnection.new()
# And a negotiated channel for each each peer
var ch1 = p1.create_data_channel("chat", {"id": 1, "negotiated": true})
var ch2 = p2.create_data_channel("chat", {"id": 1, "negotiated": true})

func _ready():
    # Connect P1 session created to itself to set local description.
    p1.session_description_created.connect(p1.set_local_description)
    # Connect P1 session and ICE created to p2 set remote description and candidates.
    p1.session_description_created.connect(p2.set_remote_description)
    p1.ice_candidate_created.connect(p2.add_ice_candidate)

    # Same for P2
    p2.session_description_created.connect(p2.set_local_description)
    p2.session_description_created.connect(p1.set_remote_description)
    p2.ice_candidate_created.connect(p1.add_ice_candidate)

    # Let P1 create the offer
    p1.create_offer()

    # Wait a second and send message from P1.
    await get_tree().create_timer(1).timeout
    ch1.put_packet("Hi from P1".to_utf8_buffer())

    # Wait a second and send message from P2.
    await get_tree().create_timer(1).timeout
    ch2.put_packet("Hi from P2".to_utf8_buffer())

func _process(_delta):
    # Poll connections
    p1.poll()
    p2.poll()

    # Check for messages
    if ch1.get_ready_state() == ch1.STATE_OPEN and ch1.get_available_packet_count() &gt; 0:
        print("P1 received: ", ch1.get_packet().get_string_from_utf8())
    if ch2.get_ready_state() == ch2.STATE_OPEN and ch2.get_available_packet_count() &gt; 0:
        print("P2 received: ", ch2.get_packet().get_string_from_utf8())</literal_block>
                <paragraph>This will print:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">P1 received: Hi from P1
P2 received: Hi from P2</literal_block>
            </section>
            <section ids="local-signaling-example" names="local\ signaling\ example">
                <title>Local signaling example</title>
                <paragraph>This example expands on the previous one, separating the peers in two different scenes, and using a <reference internal="True" refuri="../scripting/singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">singleton</inline></reference> as a signaling server.</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node
# An example p2p chat client.

var peer = WebRTCPeerConnection.new()

# Create negotiated data channel.
var channel = peer.create_data_channel("chat", {"negotiated": true, "id": 1})

func _ready():
    # Connect all functions.
    peer.ice_candidate_created.connect(self._on_ice_candidate)
    peer.session_description_created.connect(self._on_session)

    # Register to the local signaling server (see below for the implementation).
    Signaling.register(String(get_path()))


func _on_ice_candidate(mid, index, sdp):
    # Send the ICE candidate to the other peer via signaling server.
    Signaling.send_candidate(String(get_path()), mid, index, sdp)


func _on_session(type, sdp):
    # Send the session to other peer via signaling server.
    Signaling.send_session(String(get_path()), type, sdp)
    # Set generated description as local.
    peer.set_local_description(type, sdp)


func _process(delta):
    # Always poll the connection frequently.
    peer.poll()
    if channel.get_ready_state() == WebRTCDataChannel.STATE_OPEN:
        while channel.get_available_packet_count() &gt; 0:
            print(String(get_path()), " received: ", channel.get_packet().get_string_from_utf8())


func send_message(message):
    channel.put_packet(message.to_utf8_buffer())</literal_block>
                <paragraph>And now for the local signaling server:</paragraph>
                <note>
                    <paragraph>This local signaling server is supposed to be used as a <reference internal="True" refuri="../scripting/singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">singleton</inline></reference> to connect two peers in the same scene.</paragraph>
                </note>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># A local signaling server. Add this to autoloads with name "Signaling" (/root/Signaling)
extends Node

# We will store the two peers here
var peers = []

func register(path):
    assert(peers.size() &lt; 2)
    peers.append(path)
    if peers.size() == 2:
        get_node(peers[0]).peer.create_offer()


func _find_other(path):
    # Find the other registered peer.
    for p in peers:
        if p != path:
            return p
    return ""


func send_session(path, type, sdp):
    var other = _find_other(path)
    assert(other != "")
    get_node(other).peer.set_remote_description(type, sdp)


func send_candidate(path, mid, index, sdp):
    var other = _find_other(path)
    assert(other != "")
    get_node(other).peer.add_ice_candidate(mid, index, sdp)</literal_block>
                <paragraph>Then you can use it like this:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Main scene (main.gd)
extends Node

const Chat = preload("res://chat.gd")

func _ready():
    var p1 = Chat.new()
    var p2 = Chat.new()
    add_child(p1)
    add_child(p2)

    # Wait a second and send message from P1
    await get_tree().create_timer(1).timeout
    p1.send_message("Hi from %s" % String(p1.get_path()))

    # Wait a second and send message from P2
    await get_tree().create_timer(1).timeout
    p2.send_message("Hi from %s" % String(p2.get_path()))</literal_block>
                <paragraph>This will print something similar to this:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">/root/main/@@3 received: Hi from /root/main/@@2
/root/main/@@2 received: Hi from /root/main/@@3</literal_block>
            </section>
            <section ids="remote-signaling-with-websocket" names="remote\ signaling\ with\ websocket">
                <title>Remote signaling with WebSocket</title>
                <paragraph>A more advanced demo using WebSocket for signaling peers and <reference internal="True" refuri="../../classes/class_webrtcmultiplayerpeer#class-webrtcmultiplayerpeer"><inline classes="std std-ref">WebRTCMultiplayerPeer</inline></reference> is available in the <reference name="godot demo projects" refuri="https://github.com/godotengine/godot-demo-projects">godot demo projects</reference><target ids="godot-demo-projects" names="godot\ demo\ projects" refuri="https://github.com/godotengine/godot-demo-projects"></target> under <title_reference>networking/webrtc_signaling</title_reference>.</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
