<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/best_practices/scenes_versus_scripts.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-scenes-versus-scripts"></target>
    <section ids="when-to-use-scenes-versus-scripts doc-scenes-versus-scripts" names="when\ to\ use\ scenes\ versus\ scripts doc_scenes_versus_scripts">
        <title>When to use scenes versus scripts</title>
        <paragraph>We've already covered how scenes and scripts are different. Scripts
            define an engine class extension with imperative code, scenes with
            declarative code.</paragraph>
        <paragraph>Each system's capabilities are different as a result.
            Scenes can define how an extended class initializes, but not what its
            behavior actually is. Scenes are often used in conjunction with a script,
            the scene declaring a composition of nodes, and the script adding behavior with imperative code.</paragraph>
        <section ids="anonymous-types" names="anonymous\ types">
            <title>Anonymous types</title>
            <paragraph>It <emphasis>is</emphasis> possible to completely define a scenes' contents using a script alone.
                This is, in essence, what the Godot Editor does, only in the C++ constructor
                of its objects.</paragraph>
            <paragraph>But, choosing which one to use can be a dilemma. Creating script instances
                is identical to creating in-engine classes whereas handling scenes requires
                a change in API:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">const MyNode = preload("my_node.gd")
const MyScene = preload("my_scene.tscn")
var node = Node.new()
var my_node = MyNode.new() # Same method call.
var my_scene = MyScene.instantiate() # Different method call.
var my_inherited_scene = MyScene.instantiate(PackedScene.GEN_EDIT_STATE_MAIN) # Create scene inheriting from MyScene.</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Game : Node
{
    public static CSharpScript MyNode { get; } =
        GD.Load&lt;CSharpScript&gt;("res://Path/To/MyNode.cs");
    public static PackedScene MyScene { get; } =
        GD.Load&lt;PackedScene&gt;("res://Path/To/MyScene.tscn");
    private Node _node;
    private Node _myNode;
    private Node _myScene;
    private Node _myInheritedScene;

    public Game()
    {
        _node = new Node();
        _myNode = MyNode.New().As&lt;Node&gt;();
        // Different than calling new() or MyNode.New(). Instantiated from a PackedScene.
        _myScene = MyScene.Instantiate();
        // Create scene inheriting from MyScene.
        _myInheritedScene = MyScene.Instantiate(PackedScene.GenEditState.Main);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>Also, scripts will operate a little slower than scenes due to the
                speed differences between engine and script code. The larger and more complex
                the node, the more reason there is to build it as a scene.</paragraph>
        </section>
        <section ids="named-types" names="named\ types">
            <title>Named types</title>
            <paragraph>Scripts can be registered as a new type within the editor
                itself. This displays it as a new type in the node or resource creation dialog
                with an optional icon. This way, the user's ability to use the script
                is much more streamlined. Rather than having to...</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Know the base type of the script they would like to use.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Create an instance of that base type.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Add the script to the node.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>With a registered script, the scripted type instead becomes a creation option
                like the other nodes and resources in the system.
                The creation dialog even has a search bar to look up the type by
                name.</paragraph>
            <paragraph>There are two systems for registering types:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../plugins/editor/making_plugins#doc-making-plugins"><inline classes="std std-ref">Custom Types</inline></reference></paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Editor-only. Typenames are not accessible at runtime.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Does not support inherited custom types.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>An initializer tool. Creates the node with the script. Nothing more.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Editor has no type-awareness of the script or its relationship
                                    to other engine types or scripts.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Allows users to define an icon.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Works for all scripting languages because it deals with Script resources in abstract.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Set up using <reference internal="True" refuri="../../classes/class_editorplugin#class-editorplugin-method-add-custom-type"><inline classes="std std-ref">EditorPlugin.add_custom_type</inline></reference>.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../scripting/gdscript/gdscript_basics#doc-gdscript-basics-class-name"><inline classes="std std-ref">Script Classes</inline></reference></paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Editor and runtime accessible.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Displays inheritance relationships in full.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Creates the node with the script, but can also change types
                                    or extend the type from the editor.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Editor is aware of inheritance relationships between scripts,
                                    script classes, and engine C++ classes.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Allows users to define an icon.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Engine developers must add support for languages manually (both name exposure and
                                    runtime accessibility).</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>The Editor scans project folders and registers any exposed names for all
                                    scripting languages. Each scripting language must implement its own
                                    support for exposing this information.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
            </bullet_list>
            <paragraph>Both methodologies add names to the creation dialog, but script classes, in
                particular, also allow for users to access the typename without loading the
                script resource. Creating instances and accessing constants or static methods
                is viable from anywhere.</paragraph>
            <paragraph>With features like these, one may wish their type to be a script without a
                scene due to the ease of use it grants users. Those developing plugins or
                creating in-house tools for designers to use will find an easier time of things
                this way.</paragraph>
            <paragraph>On the downside, it also means having to use largely imperative programming.</paragraph>
        </section>
        <section ids="performance-of-script-vs-packedscene" names="performance\ of\ script\ vs\ packedscene">
            <title>Performance of Script vs PackedScene</title>
            <paragraph>One last aspect to consider when choosing scenes and scripts is execution speed.</paragraph>
            <paragraph>As the size of objects increases, the scripts' necessary size to create and
                initialize them grows much larger. Creating node hierarchies demonstrates this.
                Each Node's logic could be several hundred lines of code in length.</paragraph>
            <paragraph>The code example below creates a new <literal>Node</literal>, changes its name, assigns a
                script to it, sets its future parent as its owner so it gets saved to disk along
                with it, and finally adds it as a child of the <literal>Main</literal> node:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># main.gd
extends Node

func _init():
    var child = Node.new()
    child.name = "Child"
    child.script = preload("child.gd")
    add_child(child)
    child.owner = self</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Main : Node
{
    public Node Child { get; set; }

    public Main()
    {
        Child = new Node();
        Child.Name = "Child";
        var childID = Child.GetInstanceId();
        Child.SetScript(GD.Load&lt;Script&gt;("res://Path/To/Child.cs"));
        // SetScript() causes the C# wrapper object to be disposed, so obtain a new
        // wrapper for the Child node using its instance ID before proceeding.
        Child = (Node)GodotObject.InstanceFromId(childID);
        AddChild(Child);
        Child.Owner = this;
    }
}</literal_block>
                </div>
            </container>
            <paragraph>Script code like this is much slower than engine-side C++ code. Each instruction
                makes a call to the scripting API which leads to many "lookups" on the back-end
                to find the logic to execute.</paragraph>
            <paragraph>Scenes help to avoid this performance issue. <reference internal="True" refuri="../../classes/class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference>, the base type that scenes inherit from, defines resources
                that use serialized data to create objects. The engine can process scenes in
                batches on the back-end and provide much better performance than scripts.</paragraph>
        </section>
        <section ids="conclusion" names="conclusion">
            <title>Conclusion</title>
            <paragraph>In the end, the best approach is to consider the following:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>If one wishes to create a basic tool that is going to be re-used in several
                        different projects and which people of all skill levels will likely use
                        (including those who don't label themselves as "programmers"), then chances
                        are that it should probably be a script, likely one with a custom name/icon.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If one wishes to create a concept that is particular to their game, then it
                        should always be a scene. Scenes are easier to track/edit and provide more
                        security than scripts.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If one would like to give a name to a scene, then they can still sort of do
                        this by declaring a script class and giving it a scene as a constant.
                        The script becomes, in effect, a namespace:</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                        </div>
                        <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># game.gd
class_name Game # extends RefCounted, so it won't show up in the node creation dialog.
extends RefCounted

const MyScene = preload("my_scene.tscn")

# main.gd
extends Node
func _ready():
    add_child(Game.MyScene.instantiate())</literal_block>
                        </div>
                        <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Game.cs
public partial class Game : RefCounted
{
    public static PackedScene MyScene { get; } =
        GD.Load&lt;PackedScene&gt;("res://Path/To/MyScene.tscn");
}

// Main.cs
public partial class Main : Node
{
    public override void _Ready()
    {
        AddChild(Game.MyScene.Instantiate());
    }
}</literal_block>
                        </div>
                    </container>
                </list_item>
            </bullet_list>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
