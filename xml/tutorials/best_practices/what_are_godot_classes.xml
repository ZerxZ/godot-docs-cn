<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/best_practices/what_are_godot_classes.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-what-are-godot-classes"></target>
    <section ids="applying-object-oriented-principles-in-godot doc-what-are-godot-classes" names="applying\ object-oriented\ principles\ in\ godot doc_what_are_godot_classes">
        <title>Applying object-oriented principles in Godot</title>
        <paragraph>The engine offers two main ways to create reusable objects: scripts and scenes. Neither of these
            technically define classes under the hood.</paragraph>
        <paragraph>Still, many best practices using Godot involve applying object-oriented programming principles to
            the scripts and scenes that compose your game. That is why it's useful to understand how we can
            think of them as classes.</paragraph>
        <paragraph>This guide briefly explains how scripts and scenes work in the engine's core to help you understand
            how they work under the hood.</paragraph>
        <section ids="how-scripts-work-in-the-engine" names="how\ scripts\ work\ in\ the\ engine">
            <title>How scripts work in the engine</title>
            <paragraph>The engine provides built-in classes like <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference>. You can extend those to create
                derived types using a script.</paragraph>
            <paragraph>These scripts are not technically classes. Instead, they are resources that tell the engine a
                sequence of initializations to perform on one of the engine's built-in classes.</paragraph>
            <paragraph>Godot's internal classes have methods that register a class's data with a <reference internal="True" refuri="../../classes/class_classdb#class-classdb"><inline classes="std std-ref">ClassDB</inline></reference>. This database provides runtime access to class information. <literal>ClassDB</literal> contains
                information about classes like:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Properties.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Methods.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Constants.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Signals.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>This <literal>ClassDB</literal> is what objects check against when performing an operation like accessing a
                property or calling a method. It checks the database's records and the object's base types' records
                to see if the object supports the operation.</paragraph>
            <paragraph>Attaching a <reference internal="True" refuri="../../classes/class_script#class-script"><inline classes="std std-ref">Script</inline></reference> to your object extends the methods, properties, and signals
                available from the <literal>ClassDB</literal>.</paragraph>
            <note>
                <paragraph>Even scripts that don't use the <literal>extends</literal> keyword implicitly inherit from the engine's base
                    <reference internal="True" refuri="../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> class. As a result, you can instantiate scripts without the
                    <literal>extends</literal> keyword from code. Since they extend <literal>RefCounted</literal> though, you cannot attach them to
                    a <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference>.</paragraph>
            </note>
        </section>
        <section ids="scenes" names="scenes">
            <title>Scenes</title>
            <paragraph>The behavior of scenes has many similarities to classes, so it can make sense to think of a scene as
                a class. Scenes are reusable, instantiable, and inheritable groups of nodes. Creating a scene is
                similar to having a script that creates nodes and adds them as children using <literal>add_child()</literal>.</paragraph>
            <paragraph>We often pair a scene with a scripted root node that makes use of the scene's nodes. As such,
                the script extends the scene by adding behavior through imperative code.</paragraph>
            <paragraph>The content of a scene helps to define:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>What nodes are available to the script.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>How they are organized.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>How they are initialized.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>What signal connections they have with each other.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Why is any of this important to scene organization? Because instances of scenes <emphasis>are</emphasis> objects. As a
                result, many object-oriented principles that apply to written code also apply to scenes: single
                responsibility, encapsulation, and others.</paragraph>
            <paragraph>The scene is <emphasis>always an extension of the script attached to its root node</emphasis>, so you can interpret it
                as part of a class.</paragraph>
            <paragraph>Most of the techniques explained in this best practices series build on this point.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
