<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/best_practices/what_are_godot_classes.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-what-are-godot-classes"></target>
    <section ids="applying-object-oriented-principles-in-godot doc-what-are-godot-classes" names="applying\ object-oriented\ principles\ in\ godot 在\ godot\ 中应用面向对象原则 doc_what_are_godot_classes">
        <title>在 Godot 中应用面向对象原则</title>
        <paragraph>Godot 引擎主要提供了两种创建可复用对象的方式：脚本和场景。严格来说，这两种方式都没有真的在底层定义类。</paragraph>
        <paragraph>尽管如此，在许多使用 Godot 的最佳方法中，依然涉及将面向对象的编程原则应用到游戏的脚本和场景中。这就是为什么我们需要了解如何将它们视为类。</paragraph>
        <paragraph>本指南简要介绍了脚本和场景在引擎核心中的工作方式,，以帮助你了解它们在底层是如何工作的。</paragraph>
        <section ids="how-scripts-work-in-the-engine" names="how\ scripts\ work\ in\ the\ engine 脚本在引擎中的工作原理">
            <title>脚本在引擎中的工作原理</title>
            <paragraph>引擎提供了内置的类，如 <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> 。你可以使用脚本扩展这些类来创建派生类型。</paragraph>
            <paragraph>这些脚本严格来说并不是类，而是一种资源，用来告知引擎在某一内置类的基础上执行一系列初始化。</paragraph>
            <paragraph>Godot 的内部类可以将一个类的数据注册进一个名为 <reference internal="True" refuri="../../classes/class_classdb#class-classdb"><inline classes="std std-ref">ClassDB</inline></reference> 的数据库，该数据库让我们可以在运行时访问类的信息。 <literal>ClassDB</literal> 包含有关类的信息，例如：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>属性。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>方法。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>常量。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>信号。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>当对象在执行访问属性或调用方法等操作时，它就会检查 <literal>ClassDB</literal> 中对象和对象基类的记录，以确定对象是否支持该操作。</paragraph>
            <paragraph>将 <reference internal="True" refuri="../../classes/class_script#class-script"><inline classes="std std-ref">Script</inline></reference> 附加到你的对象上，可以扩展 <literal>ClassDB</literal> 中该对象的方法、属性和信号。</paragraph>
            <note>
                <paragraph>脚本即使没有使用 <literal>extends</literal> 关键字，也会隐式地继承引擎的基础 <reference internal="True" refuri="../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> 类。因此，你可以从代码中实例化不使用 <literal>extends</literal> 关键字的脚本。不过由于扩展的是 <literal>RefCounted</literal>，你是无法把它们附加到 <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> 上的。</paragraph>
            </note>
        </section>
        <section ids="scenes" names="scenes 场景">
            <title>场景</title>
            <paragraph>场景的行为与类有很多相似之处，所以把场景看成一个类也是合理的。场景是可复用、可实例化、可继承的节点组。创建场景就类似于，有一个脚本去创建一些节点，并使用 <literal>add_child()</literal> 将它们添加为子节点。</paragraph>
            <paragraph>我们经常为场景搭配一个带有脚本的根节点，并在脚本中使用这个场景下的节点。在这种情况下，脚本是通过使用命令式代码为场景添加行为来扩展场景的。</paragraph>
            <paragraph>场景的内容有助于定义：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>脚本可使用哪些节点。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>它们是如何组织的。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>它们是如何初始化的。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>它们彼此之间有什么信号连接。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>为什么这些对组织场景很重要？因为场景的实例<emphasis>都是</emphasis>对象。因此，许多适用于书面代码的面向对象原则也适用于场景：单一职责、封装等。</paragraph>
            <paragraph>场景<emphasis>就是对附着在根节点上的脚本的扩展</emphasis>，所以你可以将其解释为类的一部分。</paragraph>
            <paragraph>此系列最佳实践中所解释的大部分技术都建立在这一点上。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
