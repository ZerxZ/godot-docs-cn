<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/best_practices/logic_preferences.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-logic-preferences"></target>
    <section ids="logic-preferences doc-logic-preferences" names="logic\ preferences doc_logic_preferences">
        <title>Logic preferences</title>
        <paragraph>Ever wondered whether one should approach problem X with strategy Y or Z?
            This article covers a variety of topics related to these dilemmas.</paragraph>
        <section ids="adding-nodes-and-changing-properties-which-first" names="adding\ nodes\ and\ changing\ properties:\ which\ first?">
            <title>Adding nodes and changing properties: which first?</title>
            <paragraph>When initializing nodes from a script at runtime, you may need to change
                properties such as the node's name or position. A common dilemma is, when
                should you change those values?</paragraph>
            <paragraph>It is the best practice to change values on a node before adding it to the
                scene tree. Some property's setters have code to update other
                corresponding values, and that code can be slow! For most cases, this code
                has no impact on your game's performance, but in heavy use cases such as
                procedural generation, it can bring your game to a crawl.</paragraph>
            <paragraph>For these reasons, it is usually best practice to set the initial values
                of a node before adding it to the scene tree. There are some exceptions where
                values <emphasis>can't</emphasis> be set before being added to the scene tree, like setting global
                position.</paragraph>
        </section>
        <section ids="loading-vs-preloading" names="loading\ vs.\ preloading">
            <title>Loading vs. preloading</title>
            <paragraph>In GDScript, there exists the global
                <reference internal="True" refuri="../../classes/class_@gdscript#class-gdscript-method-preload"><inline classes="std std-ref">preload</inline></reference> method. It loads resources as
                early as possible to front-load the "loading" operations and avoid loading
                resources while in the middle of performance-sensitive code.</paragraph>
            <paragraph>Its counterpart, the <reference internal="True" refuri="../../classes/class_@gdscript#class-gdscript-method-load"><inline classes="std std-ref">load</inline></reference> method, loads a
                resource only when it reaches the load statement. That is, it will load a
                resource in-place which can cause slowdowns when it occurs in the middle of
                sensitive processes. The <literal>load()</literal> function is also an alias for
                <reference internal="True" refuri="../../classes/class_resourceloader#class-resourceloader-method-load"><inline classes="std std-ref">ResourceLoader.load(path)</inline></reference> which is
                accessible to <emphasis>all</emphasis> scripting languages.</paragraph>
            <paragraph>So, when exactly does preloading occur versus loading, and when should one use
                either? Let's see an example:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    <button aria-controls="panel-0-Qysr" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># my_buildings.gd
extends Node

# Note how constant scripts/scenes have a different naming scheme than
# their property variants.

# This value is a constant, so it spawns when the Script object loads.
# The script is preloading the value. The advantage here is that the editor
# can offer autocompletion since it must be a static path.
const BuildingScn = preload("res://building.tscn")

# 1. The script preloads the value, so it will load as a dependency
#    of the 'my_buildings.gd' script file. But, because this is a
#    property rather than a constant, the object won't copy the preloaded
#    PackedScene resource into the property until the script instantiates
#    with .new().
#
# 2. The preloaded value is inaccessible from the Script object alone. As
#    such, preloading the value here actually does not provide any benefit.
#
# 3. Because the user exports the value, if this script stored on
#    a node in a scene file, the scene instantiation code will overwrite the
#    preloaded initial value anyway (wasting it). It's usually better to
#    provide `null`, empty, or otherwise invalid default values for exports.
#
# 4. Instantiating the script on its own with .new() triggers
#    `load("office.tscn")`, ignoring any value set through the export.
@export var a_building : PackedScene = preload("office.tscn")

# Uh oh! This results in an error!
# One must assign constant values to constants. Because `load` performs a
# runtime lookup by its very nature, one cannot use it to initialize a
# constant.
const OfficeScn = load("res://office.tscn")

# Successfully loads and only when one instantiates the script! Yay!
var office_scn = load("res://office.tscn")</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

// C# and other languages have no concept of "preloading".
public partial class MyBuildings : Node
{
    //This is a read-only field, it can only be assigned when it's declared or during a constructor.
    public readonly PackedScene Building = ResourceLoader.Load&lt;PackedScene&gt;("res://building.tscn");

    public PackedScene ABuilding;

    public override void _Ready()
    {
        // Can assign the value during initialization.
        ABuilding = GD.Load&lt;PackedScene&gt;("res://Office.tscn");
    }
}</literal_block>
                </div>
                <div aria-labelledby="tab-0-Qysr" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">using namespace godot;

class MyBuildings : public Node {
    GDCLASS(MyBuildings, Node)

public:
    const Ref&lt;PackedScene&gt; building = ResourceLoader::get_singleton()-&gt;load("res://building.tscn");
    Ref&lt;PackedScene&gt; a_building;

    virtual void _ready() override {
        // Can assign the value during initialization.
        a_building = ResourceLoader::get_singleton()-&gt;load("res://office.tscn");
    }
};</literal_block>
                </div>
            </container>
            <paragraph>Preloading allows the script to handle all the loading the moment one loads the
                script. Preloading is useful, but there are also times when one doesn't wish
                to use it. Here are a few considerations when determining which to use:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>If one cannot determine when the script might load, then preloading a
                        resource (especially a scene or script) could result in additional loads
                        one does not expect. This could lead to unintentional, variable-length
                        load times on top of the original script's load operations.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If something else could replace the value (like a scene's exported
                        initialization), then preloading the value has no meaning. This point isn't
                        a significant factor if one intends to always create the script on its own.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If one wishes only to 'import' another class resource (script or scene),
                        then using a preloaded constant is often the best course of action. However,
                        in exceptional cases, one may wish not to do this:</paragraph>
                    <enumerated_list enumtype="arabic" prefix="" suffix=".">
                        <list_item>
                            <paragraph>If the 'imported' class is liable to change, then it should be a property
                                instead, initialized either using an <literal>@export</literal> or a <literal>load()</literal> (and
                                perhaps not even initialized until later).</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>If the script requires a great many dependencies, and one does not wish
                                to consume so much memory, then one may wish to load and unload various
                                dependencies at runtime as circumstances change. If one preloads
                                resources into constants, then the only way to unload these resources
                                would be to unload the entire script. If they are instead loaded
                                as properties, then one can set these properties to <literal>null</literal> and remove
                                all references to the resource (which, as a
                                <reference internal="True" refuri="../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference>-extending type, will cause the
                                resources to delete themselves from memory).</paragraph>
                        </list_item>
                    </enumerated_list>
                </list_item>
            </enumerated_list>
        </section>
        <section ids="large-levels-static-vs-dynamic" names="large\ levels:\ static\ vs.\ dynamic">
            <title>Large levels: static vs. dynamic</title>
            <paragraph>If one is creating a large level, which circumstances are most appropriate?
                Is it better to create the level as one static space? Or is it better to load
                the level in pieces and shift the world's content as needed?</paragraph>
            <paragraph>Well, the simple answer is, "when the performance requires it." The
                dilemma associated with the two options is one of the age-old programming
                choices: does one optimize memory over speed, or vice versa?</paragraph>
            <paragraph>The naive answer is to use a static level that loads everything at once.
                But, depending on the project, this could consume a large amount of
                memory. Wasting users' RAM leads to programs running slow or outright
                crashing from everything else the computer tries to do at the same time.</paragraph>
            <paragraph>No matter what, one should break larger scenes into smaller ones (to aid
                in reusability of assets). Developers can then design a node that manages the
                creation/loading and deletion/unloading of resources and nodes in real-time.
                Games with large and varied environments or procedurally generated
                elements often implement these strategies to avoid wasting memory.</paragraph>
            <paragraph>On the flip side, coding a dynamic system is more complex; it uses more
                programmed logic which results in opportunities for errors and bugs. If one
                isn't careful, they can develop a system that bloats the technical debt of
                the application.</paragraph>
            <paragraph>As such, the best options would be...</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Use static levels for smaller games.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If one has the time/resources on a medium/large game, create a library or
                        plugin that can manage nodes and resources with code. If refined
                        over time so as to improve usability and stability, then it could evolve
                        into a reliable tool across projects.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Use dynamic logic for a medium/large game because one has the coding
                        skills, but not the time or resources to refine the code (game's
                        gotta get done). Could potentially refactor later to outsource the code
                        into a plugin.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>For an example of the various ways one can swap scenes around at runtime,
                please see the <reference internal="True" refuri="../scripting/change_scenes_manually#doc-change-scenes-manually"><inline classes="std std-ref">"Change scenes manually"</inline></reference>
                documentation.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
