<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/best_practices/godot_notifications.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-godot-notifications"></target>
    <section ids="godot-notifications doc-godot-notifications" names="godot\ notifications doc_godot_notifications">
        <title>Godot notifications</title>
        <paragraph>Every Object in Godot implements a
            <reference internal="True" refuri="../../classes/class_object#class-object-private-method-notification"><inline classes="std std-ref">_notification</inline></reference> method. Its purpose is to
            allow the Object to respond to a variety of engine-level callbacks that may
            relate to it. For example, if the engine tells a
            <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference> to "draw", it will call
            <literal>_notification(NOTIFICATION_DRAW)</literal>.</paragraph>
        <paragraph>Some of these notifications, like draw, are useful to override in scripts. So
            much so that Godot exposes many of them with dedicated functions:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><literal>_ready()</literal>: <literal>NOTIFICATION_READY</literal></paragraph>
            </list_item>
            <list_item>
                <paragraph><literal>_enter_tree()</literal>: <literal>NOTIFICATION_ENTER_TREE</literal></paragraph>
            </list_item>
            <list_item>
                <paragraph><literal>_exit_tree()</literal>: <literal>NOTIFICATION_EXIT_TREE</literal></paragraph>
            </list_item>
            <list_item>
                <paragraph><literal>_process(delta)</literal>: <literal>NOTIFICATION_PROCESS</literal></paragraph>
            </list_item>
            <list_item>
                <paragraph><literal>_physics_process(delta)</literal>: <literal>NOTIFICATION_PHYSICS_PROCESS</literal></paragraph>
            </list_item>
            <list_item>
                <paragraph><literal>_draw()</literal>: <literal>NOTIFICATION_DRAW</literal></paragraph>
            </list_item>
        </bullet_list>
        <paragraph>What users might <emphasis>not</emphasis> realize is that notifications exist for types other
            than Node alone, for example:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><reference internal="True" refuri="../../classes/class_object#class-object-constant-notification-postinitialize"><inline classes="std std-ref">Object::NOTIFICATION_POSTINITIALIZE</inline></reference>:
                    a callback that triggers during object initialization. Not accessible to scripts.</paragraph>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="../../classes/class_object#class-object-constant-notification-predelete"><inline classes="std std-ref">Object::NOTIFICATION_PREDELETE</inline></reference>:
                    a callback that triggers before the engine deletes an Object, i.e. a
                    "destructor".</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>And many of the callbacks that <emphasis>do</emphasis> exist in Nodes don't have any dedicated
            methods, but are still quite useful.</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><reference internal="True" refuri="../../classes/class_node#class-node-constant-notification-parented"><inline classes="std std-ref">Node::NOTIFICATION_PARENTED</inline></reference>:
                    a callback that triggers anytime one adds a child node to another node.</paragraph>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="../../classes/class_node#class-node-constant-notification-unparented"><inline classes="std std-ref">Node::NOTIFICATION_UNPARENTED</inline></reference>:
                    a callback that triggers anytime one removes a child node from another
                    node.</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>One can access all these custom notifications from the universal
            <literal>_notification()</literal> method.</paragraph>
        <note>
            <paragraph>Methods in the documentation labeled as "virtual" are also intended to be
                overridden by scripts.</paragraph>
            <paragraph>A classic example is the
                <reference internal="True" refuri="../../classes/class_object#class-object-private-method-init"><inline classes="std std-ref">_init</inline></reference> method in Object. While it has no
                <literal>NOTIFICATION_*</literal> equivalent, the engine still calls the method. Most languages
                (except C#) rely on it as a constructor.</paragraph>
        </note>
        <paragraph>So, in which situation should one use each of these notifications or
            virtual functions?</paragraph>
        <section ids="process-vs-physics-process-vs-input" names="_process\ vs.\ _physics_process\ vs.\ *_input">
            <title>_process vs. _physics_process vs. *_input</title>
            <paragraph>Use <literal>_process()</literal> when one needs a framerate-dependent delta time between
                frames. If code that updates object data needs to update as often as
                possible, this is the right place. Recurring logic checks and data caching
                often execute here, but it comes down to the frequency at which one needs
                the evaluations to update. If they don't need to execute every frame, then
                implementing a Timer-timeout loop is another option.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    <button aria-controls="panel-0-Qysr" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Allows for recurring operations that don't trigger script logic
# every frame (or even every fixed frame).
func _ready():
    var timer = Timer.new()
    timer.autostart = true
    timer.wait_time = 0.5
    add_child(timer)
    timer.timeout.connect(func():
        print("This block runs every 0.5 seconds")
    )</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode : Node
{
    // Allows for recurring operations that don't trigger script logic
    // every frame (or even every fixed frame).
    public override void _Ready()
    {
        var timer = new Timer();
        timer.Autostart = true;
        timer.WaitTime = 0.5;
        AddChild(timer);
        timer.Timeout += () =&gt; GD.Print("This block runs every 0.5 seconds");
    }
}</literal_block>
                </div>
                <div aria-labelledby="tab-0-Qysr" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">using namespace godot;

class MyNode : public Node {
    GDCLASS(MyNode, Node)

public:
    // Allows for recurring operations that don't trigger script logic
    // every frame (or even every fixed frame).
    virtual void _ready() override {
        Timer *timer = memnew(Timer);
        timer-&gt;set_autostart(true);
        timer-&gt;set_wait_time(0.5);
        add_child(timer);
        timer-&gt;connect("timeout", callable_mp(this, &amp;MyNode::run));
    }

    void run() {
        UtilityFunctions::print("This block runs every 0.5 seconds.");
    }
};</literal_block>
                </div>
            </container>
            <paragraph>Use <literal>_physics_process()</literal> when one needs a framerate-independent delta time
                between frames. If code needs consistent updates over time, regardless
                of how fast or slow time advances, this is the right place.
                Recurring kinematic and object transform operations should execute here.</paragraph>
            <paragraph>While it is possible, to achieve the best performance, one should avoid
                making input checks during these callbacks. <literal>_process()</literal> and
                <literal>_physics_process()</literal> will trigger at every opportunity (they do not "rest" by
                default). In contrast, <literal>*_input()</literal> callbacks will trigger only on frames in
                which the engine has actually detected the input.</paragraph>
            <paragraph>One can check for input actions within the input callbacks just the same.
                If one wants to use delta time, one can fetch it from the related
                delta time methods as needed.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    <button aria-controls="panel-1-Qysr" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Called every frame, even when the engine detects no input.
func _process(delta):
    if Input.is_action_just_pressed("ui_select"):
        print(delta)

# Called during every input event.
func _unhandled_input(event):
    match event.get_class():
        "InputEventKey":
            if Input.is_action_just_pressed("ui_accept"):
                print(get_process_delta_time())</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode : Node
{

    // Called every frame, even when the engine detects no input.
    public void _Process(double delta)
    {
        if (Input.IsActionJustPressed("ui_select"))
        {
            GD.Print(delta);
        }
    }

    // Called during every input event. Equally true for _input().
    public void _UnhandledInput(InputEvent @event)
    {
        switch (@event)
        {
            case InputEventKey:
                if (Input.IsActionJustPressed("ui_accept"))
                {
                    GD.Print(GetProcessDeltaTime());
                }
                break;
        }
    }

}</literal_block>
                </div>
                <div aria-labelledby="tab-1-Qysr" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">using namespace godot;

class MyNode : public Node {
    GDCLASS(MyNode, Node)

public:
    // Called every frame, even when the engine detects no input.
    virtual void _process(double p_delta) override {
        if (Input::get_singleton-&gt;is_action_just_pressed("ui_select")) {
            UtilityFunctions::print(p_delta);
        }
    }

    // Called during every input event. Equally true for _input().
    virtual void _unhandled_input(const Ref&lt;InputEvent&gt; &amp;p_event) override {
        Ref&lt;InputEventKey&gt; key_event = event;
        if (key_event.is_valid() &amp;&amp; Input::get_singleton-&gt;is_action_just_pressed("ui_accept")) {
            UtilityFunctions::print(get_process_delta_time());
        }
    }
};</literal_block>
                </div>
            </container>
        </section>
        <section ids="init-vs-initialization-vs-export" names="_init\ vs.\ initialization\ vs.\ export">
            <title>_init vs. initialization vs. export</title>
            <paragraph>If the script initializes its own node subtree, without a scene,
                that code should execute in <literal>_init()</literal>. Other property or SceneTree-independent
                initializations should also run here.</paragraph>
            <note>
                <paragraph>The C# equivalent to GDScript's <literal>_init()</literal> method is the constructor.</paragraph>
            </note>
            <paragraph><literal>_init()</literal> triggers before <literal>_enter_tree()</literal> or <literal>_ready()</literal>, but after a script
                creates and initializes its properties. When instantiating a scene, property
                values will set up according to the following sequence:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>Initial value assignment:</strong> the property is assigned its initialization value,
                        or its default value if one is not specified. If a setter exists, it is not used.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>_init()</literal> <strong>assignment:</strong> the property's value is replaced by any assignments
                        made in <literal>_init()</literal>, triggering the setter.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Exported value assignment:</strong> an exported property's value is again replaced by
                        any value set in the Inspector, triggering the setter.</paragraph>
                </list_item>
            </enumerated_list>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    <button aria-controls="panel-2-Qysr" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># test is initialized to "one", without triggering the setter.
@export var test: String = "one":
    set(value):
        test = value + "!"

func _init():
    # Triggers the setter, changing test's value from "one" to "two!".
    test = "two"

# If someone sets test to "three" from the Inspector, it would trigger
# the setter, changing test's value from "two!" to "three!".</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode : Node
{
    private string _test = "one";

    [Export]
    public string Test
    {
        get { return _test; }
        set { _test = $"{value}!"; }
    }

    public MyNode()
    {
        // Triggers the setter, changing _test's value from "one" to "two!".
        Test = "two";
    }

    // If someone sets Test to "three" in the Inspector, it would trigger
    // the setter, changing _test's value from "two!" to "three!".
}</literal_block>
                </div>
                <div aria-labelledby="tab-2-Qysr" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">using namespace godot;

class MyNode : public Node {
    GDCLASS(MyNode, Node)

    String test = "one";

protected:
    static void _bind_methods() {
        ClassDB::bind_method(D_METHOD("get_test"), &amp;MyNode::get_test);
        ClassDB::bind_method(D_METHOD("set_test", "test"), &amp;MyNode::set_test);
        ADD_PROPERTY(PropertyInfo(Variant::STRING, "test"), "set_test", "get_test");
    }

public:
    String get_test() { return test; }
    void set_test(String p_test) { test = p_test + "!"; }

    MyNode() {
        // Triggers the setter, changing _test's value from "one" to "two!".
        set_test("two");
    }

    // If someone sets test to "three" in the Inspector, it would trigger
    // the setter, changing test's value from "two!" to "three!".
};</literal_block>
                </div>
            </container>
            <paragraph>As a result, instantiating a script versus a scene may affect both the
                initialization <emphasis>and</emphasis> the number of times the engine calls the setter.</paragraph>
        </section>
        <section ids="ready-vs-enter-tree-vs-notification-parented" names="_ready\ vs.\ _enter_tree\ vs.\ notification_parented">
            <title>_ready vs. _enter_tree vs. NOTIFICATION_PARENTED</title>
            <paragraph>When instantiating a scene connected to the first executed scene, Godot will
                instantiate nodes down the tree (making <literal>_init()</literal> calls) and build the tree
                going downwards from the root. This causes <literal>_enter_tree()</literal> calls to cascade
                down the tree. Once the tree is complete, leaf nodes call <literal>_ready</literal>. A node
                will call this method once all child nodes have finished calling theirs. This
                then causes a reverse cascade going up back to the tree's root.</paragraph>
            <paragraph>When instantiating a script or a standalone scene, nodes are not
                added to the SceneTree upon creation, so no <literal>_enter_tree()</literal> callbacks
                trigger. Instead, only the <literal>_init()</literal> call occurs. When the scene is added
                to the SceneTree, the <literal>_enter_tree()</literal> and <literal>_ready()</literal> calls occur.</paragraph>
            <paragraph>If one needs to trigger behavior that occurs as nodes parent to another,
                regardless of whether it occurs as part of the main/active scene or not, one
                can use the <reference internal="True" refuri="../../classes/class_node#class-node-constant-notification-parented"><inline classes="std std-ref">PARENTED</inline></reference> notification.
                For example, here is a snippet that connects a node's method to
                a custom signal on the parent node without failing. Useful on data-centric
                nodes that one might create at runtime.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    <button aria-controls="panel-3-Qysr" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

var parent_cache

func connection_check():
    return parent_cache.has_user_signal("interacted_with")

func _notification(what):
    match what:
        NOTIFICATION_PARENTED:
            parent_cache = get_parent()
            if connection_check():
                parent_cache.interacted_with.connect(_on_parent_interacted_with)
        NOTIFICATION_UNPARENTED:
            if connection_check():
                parent_cache.interacted_with.disconnect(_on_parent_interacted_with)

func _on_parent_interacted_with():
    print("I'm reacting to my parent's interaction!")</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode : Node
{
    private Node _parentCache;

    public bool ConnectionCheck()
    {
        return _parentCache.HasUserSignal("InteractedWith");
    }

    public override void _Notification(int what)
    {
        switch ((long)what)
        {
            case NotificationParented:
                _parentCache = GetParent();
                if (ConnectionCheck())
                {
                    _parentCache.Connect("InteractedWith", Callable.From(OnParentInteractedWith));
                }
                break;
            case NotificationUnparented:
                if (ConnectionCheck())
                {
                    _parentCache.Disconnect("InteractedWith", Callable.From(OnParentInteractedWith));
                }
                break;
        }
    }

    private void OnParentInteractedWith()
    {
        GD.Print("I'm reacting to my parent's interaction!");
    }
}</literal_block>
                </div>
                <div aria-labelledby="tab-3-Qysr" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">using namespace godot;

class MyNode : public Node {
    GDCLASS(MyNode, Node)

    Node *parent_cache = nullptr;

    void on_parent_interacted_with() {
        UtilityFunctions::print("I'm reacting to my parent's interaction!");
    }

public:
    void connection_check() {
        return parent_cache-&gt;has_user_signal("interacted_with");
    }

    void _notification(int p_what) {
        switch (p_what) {
            case NOTIFICATION_PARENTED:
                parent_cache = get_parent();
                if (connection_check()) {
                    parent_cache-&gt;connect("interacted_with", callable_mp(this, &amp;MyNode::on_parent_interacted_with));
                }
                break;
            case NOTIFICATION_UNPARENTED:
                if (connection_check()) {
                    parent_cache-&gt;disconnect("interacted_with", callable_mp(this, &amp;MyNode::on_parent_interacted_with));
                }
                break;
        }
    }
};</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
