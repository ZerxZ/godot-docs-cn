<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/best_practices/node_alternatives.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-node-alternatives"></target>
    <section ids="when-and-how-to-avoid-using-nodes-for-everything doc-node-alternatives" names="when\ and\ how\ to\ avoid\ using\ nodes\ for\ everything 何时以及如何避免为任何事情使用节点 doc_node_alternatives">
        <title>何时以及如何避免为任何事情使用节点</title>
        <paragraph>虽然节点的创建成本很低，但是它们也有一定的局限性。一个项目可能有成千上万个节点，都各自在做事情。每个节点的行为越复杂，对项目性能增加的压力就越大。</paragraph>
        <paragraph>Godot 为创建节点使用的 API 提供了更轻量级的对象。在设计如何构建项目的特性时，请务必将这些作为选项牢记在心。</paragraph>
        <enumerated_list enumtype="arabic" prefix="" suffix=".">
            <list_item>
                <paragraph><reference internal="True" refuri="../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference>：终极轻量级对象，原始的 Object 必须使用手动内存管理。尽管如此，创建自己的自定义数据结构——甚至是节点结构——也并不难，并且比 <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> 类更轻量。</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>示例：</strong>参见 <reference internal="True" refuri="../../classes/class_tree#class-tree"><inline classes="std std-ref">Tree</inline></reference> 节点。它支持对具有任意行数和列数的内容表，进行高级定制。用来生成可视化的数据实际上是 <reference internal="True" refuri="../../classes/class_treeitem#class-treeitem"><inline classes="std std-ref">TreeItem</inline></reference> 对象的树。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>优势：</strong> 将 API 简化为较小范围的对象，有助于提高其可访问性、改善迭代时间。与其使用整个 Node 库，不如创建一组简略的 Object，节点可以从这些 Object 中生成和管理相应的子节点。</paragraph>
                    </list_item>
                </bullet_list>
                <note>
                    <paragraph>处理它们时要小心. 可以将 <literal>Object</literal> 存储到变量中, 但是这些引用可能在没有警告的情况下失效. 例如, 如果对象的创建者决定删除它, 这将在下一次访问时, 触发错误状态.</paragraph>
                </note>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference>：只比 Object 稍微复杂一点。它们会记录对自己的引用，只有当对自己没有另外的引用存在时，才会删除加载的内存。在大多数需要在自定义类中存取数据的情况下，很有用。</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>示例：</strong>见 <reference internal="True" refuri="../../classes/class_fileaccess#class-fileaccess"><inline classes="std std-ref">FileAccess</inline></reference> 对象。它的功能就像普通 Object 一样，只是不需要人为删除。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>优势:</strong> 与 <literal>Object</literal> 相同.</paragraph>
                    </list_item>
                </bullet_list>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> ：只比 RefCounted 稍微复杂一点。它们天然具有将其对象属性序列化（即保存）到 Godot 资源文件，或从 Godot 资源文件中反序列化（即加载）的能力。</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Example:</strong> Scripts, PackedScene (for scene files), and other types like
                            each of the <reference internal="True" refuri="../../classes/class_audioeffect#class-audioeffect"><inline classes="std std-ref">AudioEffect</inline></reference> classes. Each of these
                            can be saved and loaded, therefore they extend from Resource.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>优势</strong>：关于 <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> 与传统数据存储方法相比的优势<reference internal="True" refuri="../scripting/resources#doc-resources"><inline classes="std std-ref">已经说了</inline></reference> 很多。然而，在使用 Resource 替代 Node 的情境下，Resource 的主要优点是与检查器的兼容性。虽然几乎和 Object/Reference 一样轻量，它们仍然可以在检查器中显示并导出属性。这使它们在易用性上，可以媲美使用子节点的方式，而且如果有人计划在其场景中包含许多这类 Resource/Node，它们还可以提高性能。</paragraph>
                    </list_item>
                </bullet_list>
            </list_item>
        </enumerated_list>
        <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
    </section>
</document>
