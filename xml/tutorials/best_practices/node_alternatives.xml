<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/best_practices/node_alternatives.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-node-alternatives"></target>
    <section ids="when-and-how-to-avoid-using-nodes-for-everything doc-node-alternatives" names="when\ and\ how\ to\ avoid\ using\ nodes\ for\ everything doc_node_alternatives">
        <title>When and how to avoid using nodes for everything</title>
        <paragraph>Nodes are cheap to produce, but even they have their limits. A project may
            have tens of thousands of nodes all doing things. The more complex their
            behavior though, the larger the strain each one adds to a project's
            performance.</paragraph>
        <paragraph>Godot provides more lightweight objects for creating APIs which nodes use.
            Be sure to keep these in mind as options when designing how you wish to build
            your project's features.</paragraph>
        <enumerated_list enumtype="arabic" prefix="" suffix=".">
            <list_item>
                <paragraph><reference internal="True" refuri="../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference>: The ultimate lightweight object, the original
                    Object must use manual memory management. With that said, it isn't too
                    difficult to create one's own custom data structures, even node structures,
                    that are also lighter than the <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> class.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Example:</strong> See the <reference internal="True" refuri="../../classes/class_tree#class-tree"><inline classes="std std-ref">Tree</inline></reference> node. It supports a high level
                            of customization for a table of content with an arbitrary number of
                            rows and columns. The data that it uses to generate its visualization
                            though is actually a tree of <reference internal="True" refuri="../../classes/class_treeitem#class-treeitem"><inline classes="std std-ref">TreeItem</inline></reference> Objects.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Advantages:</strong> Simplifying one's API to smaller scoped objects helps improve
                            its accessibility and improve iteration time. Rather than working with the
                            entire Node library, one creates an abbreviated set of Objects from which
                            a node can generate and manage the appropriate sub-nodes.</paragraph>
                    </list_item>
                </bullet_list>
                <note>
                    <paragraph>One should be careful when handling them. One can store an Object
                        into a variable, but these references can become invalid without warning.
                        For example, if the object's creator decides to delete it out of nowhere,
                        this would trigger an error state when one next accesses it.</paragraph>
                </note>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference>: Only a little more complex than Object.
                    They track references to themselves, only deleting loaded memory when no
                    further references to themselves exist. These are useful in the majority of
                    cases where one needs data in a custom class.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Example:</strong> See the <reference internal="True" refuri="../../classes/class_fileaccess#class-fileaccess"><inline classes="std std-ref">FileAccess</inline></reference> object. It functions
                            just like a regular Object except that one need not delete it themselves.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Advantages:</strong> same as the Object.</paragraph>
                    </list_item>
                </bullet_list>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>: Only slightly more complex than RefCounted.
                    They have the innate ability to serialize/deserialize (i.e. save and load)
                    their object properties to/from Godot resource files.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Example:</strong> Scripts, PackedScene (for scene files), and other types like
                            each of the <reference internal="True" refuri="../../classes/class_audioeffect#class-audioeffect"><inline classes="std std-ref">AudioEffect</inline></reference> classes. Each of these
                            can be saved and loaded, therefore they extend from Resource.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Advantages:</strong> Much has
                            <reference internal="True" refuri="../scripting/resources#doc-resources"><inline classes="std std-ref">already been said</inline></reference>
                            on <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>'s advantages over traditional data
                            storage methods. In the context of using Resources over Nodes though,
                            their main advantage is in Inspector-compatibility. While nearly as
                            lightweight as Object/RefCounted, they can still display and export
                            properties in the Inspector. This allows them to fulfill a purpose much
                            like sub-Nodes on the usability front, but also improve performance if
                            one plans to have many such Resources/Nodes in their scenes.</paragraph>
                    </list_item>
                </bullet_list>
            </list_item>
        </enumerated_list>
        <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
    </section>
</document>
