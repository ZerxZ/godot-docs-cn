<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/best_practices/scene_organization.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-scene-organization"></target>
    <section ids="scene-organization doc-scene-organization" names="scene\ organization doc_scene_organization">
        <title>Scene organization</title>
        <paragraph>This article covers topics related to the effective organization of
            scene content. Which nodes should you use? Where should you place them?
            How should they interact?</paragraph>
        <section ids="how-to-build-relationships-effectively" names="how\ to\ build\ relationships\ effectively">
            <title>How to build relationships effectively</title>
            <paragraph>When Godot users begin crafting their own scenes, they often run into the
                following problem:</paragraph>
            <paragraph>They create their first scene and fill it with content only to eventually end
                up saving branches of their scene into separate scenes as the nagging feeling
                that they should split things up starts to accumulate. However, they then
                notice that the hard references they were able to rely on before are no longer
                possible. Re-using the scene in multiple places creates issues because the
                node paths do not find their targets and signal connections established in the
                editor break.</paragraph>
            <paragraph>To fix these problems, you must instantiate the sub-scenes without them
                requiring details about their environment. You need to be able to trust
                that the sub-scene will create itself without being picky about how it's used.</paragraph>
            <paragraph>One of the biggest things to consider in OOP is maintaining
                focused, singular-purpose classes with
                <reference name="loose coupling" refuri="https://en.wikipedia.org/wiki/Loose_coupling">loose coupling</reference><target ids="loose-coupling" names="loose\ coupling" refuri="https://en.wikipedia.org/wiki/Loose_coupling"></target>
                to other parts of the codebase. This keeps the size of objects small (for
                maintainability) and improves their reusability.</paragraph>
            <paragraph>These OOP best practices have <emphasis>several</emphasis> implications for best practices
                in scene structure and script usage.</paragraph>
            <paragraph><strong>If at all possible, you should design scenes to have no dependencies.</strong>
                That is, you should create scenes that keep everything they need within
                themselves.</paragraph>
            <paragraph>If a scene must interact with an external context, experienced developers
                recommend the use of
                <reference name="Dependency Injection" refuri="https://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</reference><target ids="dependency-injection" names="dependency\ injection" refuri="https://en.wikipedia.org/wiki/Dependency_injection"></target>.
                This technique involves having a high-level API provide the dependencies of the
                low-level API. Why do this? Because classes which rely on their external
                environment can inadvertently trigger bugs and unexpected behavior.</paragraph>
            <paragraph>To do this, you must expose data and then rely on a parent context to
                initialize it:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Connect to a signal. Extremely safe, but should be used only to "respond" to
                        behavior, not start it. By convention, signal names are usually past-tense verbs
                        like "entered", "skill_activated", or "item_collected".</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                            <button aria-controls="panel-0-Qysr" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
                        </div>
                        <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Parent
$Child.signal_name.connect(method_on_the_object)

# Child
signal_name.emit() # Triggers parent-specified behavior.</literal_block>
                        </div>
                        <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Parent
GetNode("Child").Connect("SignalName", Callable.From(ObjectWithMethod.MethodOnTheObject));

// Child
EmitSignal("SignalName"); // Triggers parent-specified behavior.</literal_block>
                        </div>
                        <div aria-labelledby="tab-0-Qysr" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Parent
Node *node = get_node&lt;Node&gt;("Child");
if (node != nullptr) {
    // Note that get_node may return a nullptr, which would make calling the connect method crash the engine if "Child" does not exist!
    // So unless you are 1000% sure get_node will never return a nullptr, it's a good idea to always do a nullptr check.
    node-&gt;connect("signal_name", callable_mp(this, &amp;ObjectWithMethod::method_on_the_object));
}

// Child
emit_signal("signal_name"); // Triggers parent-specified behavior.</literal_block>
                        </div>
                    </container>
                </list_item>
                <list_item>
                    <paragraph>Call a method. Used to start behavior.</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                            <button aria-controls="panel-1-Qysr" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
                        </div>
                        <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Parent
$Child.method_name = "do"

# Child, assuming it has String property 'method_name' and method 'do'.
call(method_name) # Call parent-specified method (which child must own).</literal_block>
                        </div>
                        <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Parent
GetNode("Child").Set("MethodName", "Do");

// Child
Call(MethodName); // Call parent-specified method (which child must own).</literal_block>
                        </div>
                        <div aria-labelledby="tab-1-Qysr" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Parent
Node *node = get_node&lt;Node&gt;("Child");
if (node != nullptr) {
    node-&gt;set("method_name", "do");
}

// Child
call(method_name); // Call parent-specified method (which child must own).</literal_block>
                        </div>
                    </container>
                </list_item>
                <list_item>
                    <paragraph>Initialize a <reference internal="True" refuri="../../classes/class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> property. Safer than a method
                        as ownership of the method is unnecessary. Used to start behavior.</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                            <button aria-controls="panel-2-Qysr" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
                        </div>
                        <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Parent
$Child.func_property = object_with_method.method_on_the_object

# Child
func_property.call() # Call parent-specified method (can come from anywhere).</literal_block>
                        </div>
                        <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Parent
GetNode("Child").Set("FuncProperty", Callable.From(ObjectWithMethod.MethodOnTheObject));

// Child
FuncProperty.Call(); // Call parent-specified method (can come from anywhere).</literal_block>
                        </div>
                        <div aria-labelledby="tab-2-Qysr" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Parent
Node *node = get_node&lt;Node&gt;("Child");
if (node != nullptr) {
    node-&gt;set("func_property", Callable(&amp;ObjectWithMethod::method_on_the_object));
}

// Child
func_property.call(); // Call parent-specified method (can come from anywhere).</literal_block>
                        </div>
                    </container>
                </list_item>
                <list_item>
                    <paragraph>Initialize a Node or other Object reference.</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                            <button aria-controls="panel-3-Qysr" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
                        </div>
                        <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Parent
$Child.target = self

# Child
print(target) # Use parent-specified node.</literal_block>
                        </div>
                        <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Parent
GetNode("Child").Set("Target", this);

// Child
GD.Print(Target); // Use parent-specified node.</literal_block>
                        </div>
                        <div aria-labelledby="tab-3-Qysr" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Parent
Node *node = get_node&lt;Node&gt;("Child");
if (node != nullptr) {
    node-&gt;set("target", this);
}

// Child
UtilityFunctions::print(target);</literal_block>
                        </div>
                    </container>
                </list_item>
                <list_item>
                    <paragraph>Initialize a NodePath.</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                            <button aria-controls="panel-4-Qysr" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
                        </div>
                        <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Parent
$Child.target_path = ".."

# Child
get_node(target_path) # Use parent-specified NodePath.</literal_block>
                        </div>
                        <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Parent
GetNode("Child").Set("TargetPath", NodePath(".."));

// Child
GetNode(TargetPath); // Use parent-specified NodePath.</literal_block>
                        </div>
                        <div aria-labelledby="tab-4-Qysr" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Parent
Node *node = get_node&lt;Node&gt;("Child");
if (node != nullptr) {
    node-&gt;set("target_path", NodePath(".."));
}

// Child
get_node&lt;Node&gt;(target_path); // Use parent-specified NodePath.</literal_block>
                        </div>
                    </container>
                </list_item>
            </enumerated_list>
            <paragraph>These options hide the points of access from the child node. This in turn
                keeps the child <strong>loosely coupled</strong> to its environment. You can reuse it
                in another context without any extra changes to its API.</paragraph>
            <note>
                <paragraph>Although the examples above illustrate parent-child relationships,
                    the same principles apply towards all object relations. Nodes which
                    are siblings should only be aware of their own hierarchies while an ancestor
                    mediates their communications and references.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                        <button aria-controls="panel-5-Qysr" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Parent
$Left.target = $Right.get_node("Receiver")

# Left
var target: Node
func execute():
    # Do something with 'target'.

# Right
func _init():
    var receiver = Receiver.new()
    add_child(receiver)</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Parent
GetNode&lt;Left&gt;("Left").Target = GetNode("Right/Receiver");

public partial class Left : Node
{
    public Node Target = null;

    public void Execute()
    {
        // Do something with 'Target'.
    }
}

public partial class Right : Node
{
    public Node Receiver = null;

    public Right()
    {
        Receiver = ResourceLoader.Load&lt;Script&gt;("Receiver.cs").New();
        AddChild(Receiver);
    }
}</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-Qysr" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-Qysr" name="Qysr" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Parent
get_node&lt;Left&gt;("Left")-&gt;target = get_node&lt;Node&gt;("Right/Receiver");

class Left : public Node {
    GDCLASS(Left, Node)

    protected:
        static void _bind_methods() {}

    public:
        Node *target = nullptr;

        Left() {}

        void execute() {
            // Do something with 'target'.
        }
};

class Right : public Node {
    GDCLASS(Right, Node)

    protected:
        static void _bind_methods() {}

    public:
        Node *receiver = nullptr;

        Right() {
            receiver = memnew(Node);
            add_child(receiver);
        }
};</literal_block>
                    </div>
                </container>
                <paragraph>The same principles also apply to non-Node objects that maintain dependencies
                    on other objects. Whichever object owns the other objects should manage
                    the relationships between them.</paragraph>
            </note>
            <warning>
                <paragraph>You should favor keeping data in-house (internal to a scene), though, as
                    placing a dependency on an external context, even a loosely coupled one,
                    still means that the node will expect something in its environment to be
                    true. The project's design philosophies should prevent this from happening.
                    If not, the code's inherent liabilities will force developers to use
                    documentation to keep track of object relations on a microscopic scale; this
                    is otherwise known as development hell. Writing code that relies on external
                    documentation to use it safely is error-prone by default.</paragraph>
                <paragraph>To avoid creating and maintaining such documentation, you convert the
                    dependent node ("child" above) into a tool script that implements
                    <literal>_get_configuration_warnings()</literal>.
                    Returning a non-empty PackedStringArray from it will make the Scene dock generate a
                    warning icon with the string(s) as a tooltip by the node. This is the same icon
                    that appears for nodes such as the
                    <reference internal="True" refuri="../../classes/class_area2d#class-area2d"><inline classes="std std-ref">Area2D</inline></reference> node when it has no child
                    <reference internal="True" refuri="../../classes/class_collisionshape2d#class-collisionshape2d"><inline classes="std std-ref">CollisionShape2D</inline></reference> nodes defined. The editor
                    then self-documents the scene through the script code. No content duplication
                    via documentation is necessary.</paragraph>
                <paragraph>A GUI like this can better inform project users of critical information about
                    a Node. Does it have external dependencies? Have those dependencies been
                    satisfied? Other programmers, and especially designers and writers, will need
                    clear instructions in the messages telling them what to do to configure it.</paragraph>
            </warning>
            <paragraph>So, why does all this complex switcheroo work? Well, because scenes operate
                best when they operate alone. If unable to work alone, then working with
                others anonymously (with minimal hard dependencies, i.e. loose coupling)
                is the next best thing. Inevitably, changes may need to be made to a class, and
                if these changes cause it to interact with other scenes in unforeseen ways,
                then things will start to break down. The whole point of all this indirection
                is to avoid ending up in a situation where changing one class results in
                adversely affecting other classes dependent on it.</paragraph>
            <paragraph>Scripts and scenes, as extensions of engine classes, should abide
                by <emphasis>all</emphasis> OOP principles. Examples include...</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="SOLID" refuri="https://en.wikipedia.org/wiki/SOLID">SOLID</reference><target ids="solid" names="solid" refuri="https://en.wikipedia.org/wiki/SOLID"></target></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="DRY" refuri="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</reference><target ids="dry" names="dry" refuri="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"></target></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="KISS" refuri="https://en.wikipedia.org/wiki/KISS_principle">KISS</reference><target ids="kiss" names="kiss" refuri="https://en.wikipedia.org/wiki/KISS_principle"></target></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="YAGNI" refuri="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</reference><target ids="yagni" names="yagni" refuri="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it"></target></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="choosing-a-node-tree-structure" names="choosing\ a\ node\ tree\ structure">
            <title>Choosing a node tree structure</title>
            <paragraph>You might start to work on a game but get overwhelmed by the vast possibilities
                before you. You might know what you want to do, what systems you want to
                have, but <emphasis>where</emphasis> do you put them all? How you go about making your game
                is always up to you. You can construct node trees in countless ways.
                If you are unsure, this guide can give you a sample of a decent structure to
                start with.</paragraph>
            <paragraph>A game should always have an "entry point"; somewhere you can definitively
                track where things begin so that you can follow the logic as it continues
                elsewhere. It also serves as a bird's eye view of all other data and logic
                in the program. For traditional applications, this is normally a "main"
                function. In Godot, it's a Main node.</paragraph>
            <block_quote>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Node "Main" (main.gd)</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <paragraph>The <literal>main.gd</literal> script will serve as the primary controller of your game.</paragraph>
            <paragraph>Then you have an in-game "World" (a 2D or 3D one). This can be a child
                of Main. In addition, you will need a primary GUI for your game that manages
                the various menus and widgets the project needs.</paragraph>
            <block_quote>
                <bullet_list bullet="-">
                    <list_item>
                        <definition_list>
                            <definition_list_item>
                                <term>Node "Main" (main.gd)</term>
                                <definition>
                                    <bullet_list bullet="-">
                                        <list_item>
                                            <paragraph>Node2D/Node3D "World" (game_world.gd)</paragraph>
                                        </list_item>
                                        <list_item>
                                            <paragraph>Control "GUI" (gui.gd)</paragraph>
                                        </list_item>
                                    </bullet_list>
                                </definition>
                            </definition_list_item>
                        </definition_list>
                    </list_item>
                </bullet_list>
            </block_quote>
            <paragraph>When changing levels, you can then swap out the children of the "World" node.
                <reference internal="True" refuri="../scripting/change_scenes_manually#doc-change-scenes-manually"><inline classes="std std-ref">Changing scenes manually</inline></reference> gives you full
                control over how your game world transitions.</paragraph>
            <paragraph>The next step is to consider what gameplay systems your project requires.
                If you have a system that...</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>tracks all of its data internally</paragraph>
                </list_item>
                <list_item>
                    <paragraph>should be globally accessible</paragraph>
                </list_item>
                <list_item>
                    <paragraph>should exist in isolation</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>... then you should create an <reference internal="True" refuri="../scripting/singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">autoload 'singleton' node</inline></reference>.</paragraph>
            <note>
                <paragraph>For smaller games, a simpler alternative with less control would be to have
                    a "Game" singleton that simply calls the
                    <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree-method-change-scene-to-file"><inline classes="std std-ref">SceneTree.change_scene_to_file()</inline></reference> method
                    to swap out the main scene's content. This structure more or less keeps
                    the "World" as the main game node.</paragraph>
                <paragraph>Any GUI would also need to be either a singleton, a transitory part of the
                    "World", or manually added as a direct child of the root. Otherwise, the
                    GUI nodes would also delete themselves during scene transitions.</paragraph>
            </note>
            <paragraph>If you have systems that modify other systems' data, you should define those as
                their own scripts or scenes, rather than autoloads. For more information, see
                <reference internal="True" refuri="autoloads_versus_internal_nodes#doc-autoloads-versus-internal-nodes"><inline classes="std std-ref">Autoloads versus regular nodes</inline></reference>.</paragraph>
            <paragraph>Each subsystem within your game should have its own section within the
                SceneTree. You should use parent-child relationships only in cases where nodes
                are effectively elements of their parents. Does removing the parent reasonably
                mean that the children should also be removed? If not, then it should have its
                own place in the hierarchy as a sibling or some other relation.</paragraph>
            <note>
                <paragraph>In some cases, you need these separated nodes to <emphasis>also</emphasis> position themselves
                    relative to each other. You can use the
                    <reference internal="True" refuri="../../classes/class_remotetransform3d#class-remotetransform3d"><inline classes="std std-ref">RemoteTransform</inline></reference> /
                    <reference internal="True" refuri="../../classes/class_remotetransform2d#class-remotetransform2d"><inline classes="std std-ref">RemoteTransform2D</inline></reference> nodes for this purpose.
                    They will allow a target node to conditionally inherit selected transform
                    elements from the Remote* node. To assign the <literal>target</literal>
                    <reference internal="True" refuri="../../classes/class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>, use one of the following:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>A reliable third party, likely a parent node, to mediate the assignment.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>A group, to pull a reference to the desired node (assuming there
                            will only ever be one of the targets).</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>When you should do this is subjective. The dilemma arises when you must
                    micro-manage when a node must move around the SceneTree to preserve
                    itself. For example...</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Add a "player" node to a "room".</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Need to change rooms, so you must delete the current room.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Before the room can be deleted, you must preserve and/or move the player.</paragraph>
                        <paragraph>If memory is not a concern, you can...</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Create the new room.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Move the player to the new room.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Delete the old room.</paragraph>
                            </list_item>
                        </bullet_list>
                        <paragraph>If memory is a concern, instead you will need to...</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Move the player somewhere else in the tree.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Delete the room.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Instantiate and add the new room.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Re-add the player to the new room.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                </bullet_list>
                <paragraph>The issue is that the player here is a "special case" where the
                    developers must <emphasis>know</emphasis> that they need to handle the player this way for the
                    project. The only way to reliably share this information as a team
                    is to <emphasis>document</emphasis> it. Keeping implementation details in documentation is
                    dangerous. It's a maintenance burden, strains code readability, and
                    unnecessarily bloats the intellectual content of a project.</paragraph>
                <paragraph>In a more complex game with larger assets, it can be a better idea to keep
                    the player somewhere else in the SceneTree entirely. This results in:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>More consistency.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>No "special cases" that must be documented and maintained somewhere.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>No opportunity for errors to occur because these details are not accounted
                            for.</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>In contrast, if you ever need a child node that does <emphasis>not</emphasis> inherit
                    the transform of its parent, you have the following options:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>The <strong>declarative</strong> solution: place a <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> in between
                            them. Since it doesn't have a transform, they won't pass this information
                            to its children.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The <strong>imperative</strong> solution: Use the <literal>top_level</literal> property for the
                            <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-property-top-level"><inline classes="std std-ref">CanvasItem</inline></reference> or
                            <reference internal="True" refuri="../../classes/class_node3d#class-node3d-property-top-level"><inline classes="std std-ref">Node3D</inline></reference> node. This will make
                            the node ignore its inherited transform.</paragraph>
                    </list_item>
                </enumerated_list>
            </note>
            <note>
                <paragraph>If building a networked game, keep in mind which nodes and gameplay systems
                    are relevant to all players versus those just pertinent to the authoritative
                    server. For example, users do not all need to have a copy of every players'
                    "PlayerController" logic - they only need their own. Keeping them in a
                    separate branch from the "world" can help simplify the management of game
                    connections and the like.</paragraph>
            </note>
            <paragraph>The key to scene organization is to consider the SceneTree in relational terms
                rather than spatial terms. Are the nodes dependent on their parent's existence?
                If not, then they can thrive all by themselves somewhere else.
                If they are dependent, then it stands to reason that they should be children of
                that parent (and likely part of that parent's scene if they aren't already).</paragraph>
            <paragraph>Does this mean nodes themselves are components? Not at all.
                Godot's node trees form an aggregation relationship, not one of composition.
                But while you still have the flexibility to move nodes around, it is still best
                when such moves are unnecessary by default.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
