<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/best_practices/scene_organization.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-scene-organization"></target>
    <section ids="scene-organization doc-scene-organization" names="scene\ organization 场景组织 doc_scene_organization">
        <title>场景组织</title>
        <paragraph>本文讨论与场景内容的有效组织相关的主题。应该使用哪些节点？应该把它们放在哪里？它们应该如何互动？</paragraph>
        <section ids="how-to-build-relationships-effectively" names="how\ to\ build\ relationships\ effectively 如何有效地建立关系">
            <title>如何有效地建立关系</title>
            <paragraph>当 Godot 用户开始制作自己的场景时，他们经常遇到以下问题：</paragraph>
            <paragraph>他们创建了自己的第一个场景并填满内容，但随着应该把事情分解的烦人感觉开始积累，他们最终把场景的分支保存为单独的场景。可他们接着就注意到之前能够依赖的硬引用不能用了。在多个地方重用场景会出现问题，因为节点路径找不到目标，在编辑器中建立的信号连接也失效了。</paragraph>
            <paragraph>要解决这些问题，必须实例化子场景，而子场景不能依赖所处环境中的详细信息。子场景应该能够保证自身创建的时候对别人如何用它没有过分的要求。</paragraph>
            <paragraph>在 OOP 中需要考虑的最大的事情之一是维护目标明确、单一的类，与代码库的其他部分进行<reference name="松散的耦合" refuri="https://en.wikipedia.org/wiki/Loose_coupling">松散的耦合</reference><target ids="id1" names="松散的耦合" refuri="https://en.wikipedia.org/wiki/Loose_coupling"></target>。这样可以使对象的大小保持在较小的范围内（便于维护），提高可重用性。</paragraph>
            <paragraph>这些 OOP 最佳实践对场景结构和脚本使用的有<emphasis>很多</emphasis>意义。</paragraph>
            <paragraph><strong>应该尽可能设计没有依赖项的场景。</strong>也就是说，创建的场景应该将所需的一切保留在其内部。</paragraph>
            <paragraph>如果场景必须与外部环境交互，经验丰富的开发人员会建议使用<reference name="依赖注入" refuri="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5">依赖注入</reference><target ids="id1" names="依赖注入" refuri="https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"></target>。该技术涉及使高级 API 提供低级 API 的依赖关系。为什么要这样呢？因为依赖于其外部环境的类可能会无意中触发 Bug 和意外行为。</paragraph>
            <paragraph>要做到这一点，就必须暴露数据，依靠父级上下文对其进行初始化：</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>连接信号。这样做极其安全，但只能用于“响应”行为，而不是启动行为。按照惯例，信号名称通常是过去式动词，如“entered”“skill_activated”“item_collected”（已进入、已激活技能、已收集道具）。</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                        </div>
                        <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Parent
$Child.signal_name.connect(method_on_the_object)

# Child
signal_name.emit() # Triggers parent-defined behavior.</literal_block>
                        </div>
                        <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Parent
GetNode("Child").Connect("SignalName", Callable.From(ObjectWithMethod.MethodOnTheObject));

// Child
EmitSignal("SignalName"); // Triggers parent-defined behavior.</literal_block>
                        </div>
                    </container>
                </list_item>
                <list_item>
                    <paragraph>调用方法。用于启动行为。</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                        </div>
                        <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Parent
$Child.method_name = "do"

# Child, assuming it has String property 'method_name' and method 'do'.
call(method_name) # Call parent-defined method (which child must own).</literal_block>
                        </div>
                        <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Parent
GetNode("Child").Set("MethodName", "Do");

// Child
Call(MethodName); // Call parent-defined method (which child must own).</literal_block>
                        </div>
                    </container>
                </list_item>
                <list_item>
                    <paragraph>初始化 <reference internal="True" refuri="../../classes/class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> 属性。比调用方法更安全，因为不需要拥有这个方法的所有权。用于启动行为。</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                        </div>
                        <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Parent
$Child.func_property = object_with_method.method_on_the_object

# Child
func_property.call() # Call parent-defined method (can come from anywhere).</literal_block>
                        </div>
                        <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Parent
GetNode("Child").Set("FuncProperty", Callable.From(ObjectWithMethod.MethodOnTheObject));

// Child
FuncProperty.Call(); // Call parent-defined method (can come from anywhere).</literal_block>
                        </div>
                    </container>
                </list_item>
                <list_item>
                    <paragraph>初始化 Node 或其他 Object 的引用。</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                        </div>
                        <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Parent
$Child.target = self

# Child
print(target) # Use parent-defined node.</literal_block>
                        </div>
                        <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Parent
GetNode("Child").Set("Target", this);

// Child
GD.Print(Target); // Use parent-defined node.</literal_block>
                        </div>
                    </container>
                </list_item>
                <list_item>
                    <paragraph>初始化 NodePath。</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                        </div>
                        <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Parent
$Child.target_path = ".."

# Child
get_node(target_path) # Use parent-defined NodePath.</literal_block>
                        </div>
                        <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Parent
GetNode("Child").Set("TargetPath", NodePath(".."));

// Child
GetNode(TargetPath); // Use parent-defined NodePath.</literal_block>
                        </div>
                    </container>
                </list_item>
            </enumerated_list>
            <paragraph>这些选项隐藏了子节点的访问点。这反过来又使子节点与环境保持 <strong>松耦合</strong> （loosely coupled）。人们可以在另外一个上下文中重新使用它，而不需要对API做任何额外的改变。</paragraph>
            <note>
                <paragraph>虽然上面的例子说明了父子关系, 但是同样的原则也适用于所有对象之间的关系. 兄弟节点应该只知道它们的层次结构, 而先祖节点则负责协调它们的通信和引用.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Parent
$Left.target = $Right.get_node("Receiver")

# Left
var target: Node
func execute():
    # Do something with 'target'.

# Right
func _init():
    var receiver = Receiver.new()
    add_child(receiver)</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Parent
GetNode&lt;Left&gt;("Left").Target = GetNode("Right/Receiver");

public partial class Left : Node
{
    public Node Target = null;

    public void Execute()
    {
        // Do something with 'Target'.
    }
}

public partial class Right : Node
{
    public Node Receiver = null;

    public Right()
    {
        Receiver = ResourceLoader.Load&lt;Script&gt;("Receiver.cs").New();
        AddChild(Receiver);
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>同样的原则也适用于, 维护对其他对象依赖关系的非节点对象. 无论哪个对象实际拥有这些对象, 都应该管理它们之间的关系.</paragraph>
            </note>
            <warning>
                <paragraph>人们应该倾向于将数据保存在内部(场景内部), 尽管它对外部上下文有一个依赖, 即使是一个松散耦合的依赖, 仍然意味着节点, 将期望其环境中的某些内容为真. 项目的设计理念应防止这种情况的发生. 如果不是这样, 代码的继承的责任将迫使开发人员使用文档, 以在微观尺度上跟踪对象关系；这就是所谓的开发地狱. 默认情况下, 编写依赖于外部文档的代码, 让人们安全地使用它, 是很容易出错的.</paragraph>
                <paragraph>为了避免创建和维护此类文档，可以将依赖节点（上面的子级）转换为工具脚本，该脚本实现 <literal>_get_configuration_warnings()</literal> 。从中返回的一个非空字符串紧缩数组（PackedStringArray）将使场景停靠面板生成警告图标，其中包含上述字符串作为节点的工具提示。这个警告图标和没有定义 <reference internal="True" refuri="../../classes/class_collisionshape2d#class-collisionshape2d"><inline classes="std std-ref">CollisionShape2D</inline></reference> 子节点时 <reference internal="True" refuri="../../classes/class_area2d#class-area2d"><inline classes="std std-ref">Area2D</inline></reference> 节点旁出现的图标是一样的。这样，编辑器通过脚本代码自记录（self-document）场景，也就不需要在文档里记录一些与之重复的内容了。</paragraph>
                <paragraph>这样的GUI可以更好地通知项目用户有关节点的关键信息. 它具有外部依赖性吗？这些依赖性是否得到满足？其他程序员, 尤其是设计师和作家, 将需要消息中的明确指示, 告诉他们如何进行配置.</paragraph>
            </warning>
            <paragraph>So, why does all this complex switcheroo work? Well, because scenes operate
                best when they operate alone. If unable to work alone, then working with
                others anonymously (with minimal hard dependencies, i.e. loose coupling)
                is the next best thing. Inevitably, changes may need to be made to a class and
                if these changes cause it to interact with other scenes in unforeseen ways,
                then things will start to break down. The whole point of all this indirection
                is to avoid ending up in a situation where changing one class results in
                adversely affecting other classes dependent on it.</paragraph>
            <paragraph>脚本和场景作为引擎类的扩展, 应该遵守 <emphasis>所有</emphasis> 的OOP原则. 例如...</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="SOLID" refuri="https://en.wikipedia.org/wiki/SOLID">SOLID</reference><target ids="solid" names="solid" refuri="https://en.wikipedia.org/wiki/SOLID"></target></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="DRY" refuri="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</reference><target ids="dry" names="dry" refuri="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself"></target></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="KISS" refuri="https://en.wikipedia.org/wiki/KISS_principle">KISS</reference><target ids="kiss" names="kiss" refuri="https://en.wikipedia.org/wiki/KISS_principle"></target></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="YAGNI" refuri="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</reference><target ids="yagni" names="yagni" refuri="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it"></target></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="choosing-a-node-tree-structure" names="choosing\ a\ node\ tree\ structure 选择节点树结构">
            <title>选择节点树结构</title>
            <paragraph>于是，一个开发者开始着手做游戏，却在广阔的可能性面前停了下来。他可能知道自己想做什么，想要什么样的系统，但是该把这些东西安置在 <emphasis>哪里</emphasis> 呢？好吧，自己做的游戏当然自己说了算。构造节点树的方法有无数种。但对于没把握的人而言，这份有用的指南可以给他们一个不错的结构样本作为开始。</paragraph>
            <paragraph>一个游戏总是应该具有某种“入口点”，即某个地方，开发者能明确地追踪各种东西从哪里开始，进而能随着逻辑延伸至其他地方。该处也充当着程序中所有其他数据和逻辑的鸟瞰点。对于传统的应用程序而言，这即是“main”函数。而在这个案例中，它是一个 Main 节点。</paragraph>
            <block_quote>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>“Main”节点（main.gd）</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <paragraph><literal>main.gd</literal> 脚本将作为游戏的主要控制器。</paragraph>
            <paragraph>然后你便拥有了真正的游戏“世界”（二维或三维）。这可以是 Main 的子节点。另外，他们的游戏将需要一个主要的 GUI，来管理项目所需的各种菜单和小部件。</paragraph>
            <block_quote>
                <bullet_list bullet="-">
                    <list_item>
                        <definition_list>
                            <definition_list_item>
                                <term>“Main”节点（main.gd）</term>
                                <definition>
                                    <bullet_list bullet="-">
                                        <list_item>
                                            <paragraph>Node2D/Node3D “世界”（game_world.gd）</paragraph>
                                        </list_item>
                                        <list_item>
                                            <paragraph>Control“GUI”（gui.gd）</paragraph>
                                        </list_item>
                                    </bullet_list>
                                </definition>
                            </definition_list_item>
                        </definition_list>
                    </list_item>
                </bullet_list>
            </block_quote>
            <paragraph>当变更关卡时，可以稍后换出“World”节点的子级。<reference internal="True" refuri="../scripting/change_scenes_manually#doc-change-scenes-manually"><inline classes="std std-ref">手动更换场景</inline></reference>让用户完全控制他们的游戏世界如何过渡。</paragraph>
            <paragraph>下一步是考虑项目需要什么样的游戏系统。如果有这么一个系统……</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>跟踪所有的内部数据</paragraph>
                </list_item>
                <list_item>
                    <paragraph>应该是全局可访问的</paragraph>
                </list_item>
                <list_item>
                    <paragraph>应该是独立存在的</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>…接下来他该创建一个 <reference internal="True" refuri="../scripting/singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">自动加载“单例”节点</inline></reference> 了。</paragraph>
            <note>
                <paragraph>对于较小的游戏，一个更简单且更少控制的做法是使用一个“Game”单例，简单地调用 <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree-method-change-scene-to-file"><inline classes="std std-ref">SceneTree.change_scene_to_file()</inline></reference> 方法，用于置换出主场景的内容。这种结构多少保留了“World”作为主要游戏节点。</paragraph>
                <paragraph>任一GUI也需要是一个单例，或作为 "World" 的过渡部分，或被手动添加到根节点作为其直接子节点。否则GUI节点也会在场景转换时自行删除。</paragraph>
            </note>
            <paragraph>如果一个系统需要修改另一个系统的数据，那么就应该把它们分别定义成单独的脚本或者场景，不应该使用自动加载。其原因请参考文档<reference internal="True" refuri="autoloads_versus_internal_nodes#doc-autoloads-versus-internal-nodes"><inline classes="std std-ref">自动加载与普通节点</inline></reference>。</paragraph>
            <paragraph>游戏中的每个子系统在 <literal>SceneTree</literal> 中应有其自己的部分. 仅在节点是其父级的有效元素的情况下, 才应使用父子关系. 合理地移除父级是否意味着也应删除子级？如果没有, 那么它应在层次结构中有自己的位置, 作为同级关系或其他关系.</paragraph>
            <note>
                <paragraph>在某些情况下，我们会需要让这些分离的节点<emphasis>仍然</emphasis>进行相对定位。为此，可以使用 <reference internal="True" refuri="../../classes/class_remotetransform3d#class-remotetransform3d"><inline classes="std std-ref">RemoteTransform</inline></reference> / <reference internal="True" refuri="../../classes/class_remotetransform2d#class-remotetransform2d"><inline classes="std std-ref">RemoteTransform2D</inline></reference> 节点。它们允许目标节点有条件地从 Remote* 节点继承选定的变换元素。要分配 <literal>target</literal> 的 <reference internal="True" refuri="../../classes/class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>，请使用以下方法之一：</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>一个可靠的第三方, 可能是一个父节点, 来协调分配任务.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>一个编组, 轻松提取对所需节点的引用(假设只有一个目标).</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>什么时候他该这样做呢？嗯，这就比较主观了。当他必须精细管理，且一个节点必须在场景树上来回移动以保留自己时，就会出现两难的局面。例如……</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>添加一个“玩家”节点到一个“房间”节点。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>需要改变房间了，所以他必须删除当前房间节点。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>在房间能被删除前，他必须保留玩家并/或将其移走。</paragraph>
                        <paragraph>需要关心内存吗？</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>如果不需要，就可以直接创建两个房间，移动玩家到新房间，并且删掉旧房间。没有任何问题。</paragraph>
                            </list_item>
                        </bullet_list>
                        <paragraph>如果比较关注内存情况，那么就需要这样……</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>将玩家节点移动到节点树的其他地方。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>删除房间节点。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>实例化并添加新的房间节点。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>重新添加玩家节点。</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                </bullet_list>
                <paragraph>问题在于这里的角色是一种“特殊情况”；开发者必须<emphasis>知道</emphasis>需要以这种方式处理项目中的角色。因此，在团队中可靠地分享这些信息的唯一方法就是<emphasis>写文档</emphasis>。然而，在文档中记录实现细节是很危险的，会成为一种维护负担，使代码可读性下降，不必要地膨胀项目的知识内容。</paragraph>
                <paragraph>在拥有更多的资产的，更复杂的游戏，简单地将玩家完全保留在 SceneTree 中的其他地方会更好。这样的好处是：</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>一致性更高。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>没有“特殊情况”，不必写入文档也不必进行维护。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>因为不需要考虑这些细节，所以也没有出错的机会。</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>相比之下，如果需要子节点<emphasis>不</emphasis>继承父节点的变换，那么就有以下选项：</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph><strong>声明式</strong>解决方案：在它们之间放置一个 <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference>。作为没有变换的节点，Node 不会将这些信息传递给其子节点。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>命令式</strong>解决方案：对 <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-property-top-level"><inline classes="std std-ref">CanvasItem</inline></reference> 或者 <reference internal="True" refuri="../../classes/class_node3d#class-node3d-property-top-level"><inline classes="std std-ref">Node3D</inline></reference> 节点使用 <literal>top_level</literal> 属性。这样就会让该节点忽略其继承的变换（transform）。</paragraph>
                    </list_item>
                </enumerated_list>
            </note>
            <note>
                <paragraph>如果构建的是网络游戏，请记住哪些节点和游戏系统与所有玩家相关，而哪些只与权威服务器相关。例如，用户并不需要所有人都拥有每个玩家的“PlayerController”逻辑的副本。相反，他们只需要自己的。这样，将它们保持在从“世界”分离的独立的分支中，可以帮助简化游戏连接等的管理。</paragraph>
            </note>
            <paragraph>场景组织的关键是用关系树而不是空间树来考虑 SceneTree。节点是否依赖于其父节点的存在？如果不是，那么它们可以自己在别的地方茁壮成长。如果它们是依赖性的，那么理所当然它们应该是父节点的子节点（如果它们还不是父节点场景的一部分，那么很可能是父节点场景的一部分）。</paragraph>
            <paragraph>这是否意味着节点本身就是组件？并不是这样。Godot 的节点树形成的是聚合关系，不是组合关系。虽然依旧可以灵活地移动节点，但在默认情况下是没有进行移动的必要的。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
