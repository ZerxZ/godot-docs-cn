<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/best_practices/data_preferences.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-data-preferences"></target>
    <section ids="data-preferences doc-data-preferences" names="data\ preferences doc_data_preferences">
        <title>Data preferences</title>
        <paragraph>Ever wondered whether one should approach problem X with data structure
            Y or Z? This article covers a variety of topics related to these dilemmas.</paragraph>
        <note>
            <paragraph>This article makes references to "[something]-time" operations. This
                terminology comes from algorithm analysis'
                <reference name="Big O Notation" refuri="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/">Big O Notation</reference><target ids="big-o-notation" names="big\ o\ notation" refuri="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/"></target>.</paragraph>
            <paragraph>Long-story short, it describes the worst-case scenario of runtime length.
                In laymen's terms:</paragraph>
            <paragraph>"As the size of a problem domain increases, the runtime length of the
                algorithm..."</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Constant-time, <literal>O(1)</literal>: "...does not increase."</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Logarithmic-time, <literal>O(log n)</literal>: "...increases at a slow rate."</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Linear-time, <literal>O(n)</literal>: "...increases at the same rate."</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Etc.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Imagine if one had to process 3 million data points within a single frame. It
                would be impossible to craft the feature with a linear-time algorithm since
                the sheer size of the data would increase the runtime far beyond the time allotted.
                In comparison, using a constant-time algorithm could handle the operation without
                issue.</paragraph>
            <paragraph>By and large, developers want to avoid engaging in linear-time operations as
                much as possible. But, if one keeps the scale of a linear-time operation
                small, and if one does not need to perform the operation often, then it may
                be acceptable. Balancing these requirements and choosing the right
                algorithm / data structure for the job is part of what makes programmers'
                skills valuable.</paragraph>
        </note>
        <section ids="array-vs-dictionary-vs-object" names="array\ vs.\ dictionary\ vs.\ object">
            <title>Array vs. Dictionary vs. Object</title>
            <paragraph>Godot stores all variables in the scripting API in the
                <reference internal="True" refuri="../../engine_details/architecture/variant_class#doc-variant-class"><inline classes="std std-ref">Variant</inline></reference> class.
                Variants can store Variant-compatible data structures such as
                <reference internal="True" refuri="../../classes/class_array#class-array"><inline classes="std std-ref">Array</inline></reference> and <reference internal="True" refuri="../../classes/class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> as well
                as <reference internal="True" refuri="../../classes/class_object#class-object"><inline classes="std std-ref">Objects</inline></reference>.</paragraph>
            <paragraph>Godot implements Array as a <literal>Vector&lt;Variant&gt;</literal>. The engine stores the Array
                contents in a contiguous section of memory, i.e. they are in a row adjacent
                to each other.</paragraph>
            <note>
                <paragraph>For those unfamiliar with C++, a Vector is the name of the
                    array object in traditional C++ libraries. It is a "templated"
                    type, meaning that its records can only contain a particular type (denoted
                    by angled brackets). So, for example, a
                    <reference internal="True" refuri="../../classes/class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> would be something like
                    a <literal>Vector&lt;String&gt;</literal>.</paragraph>
            </note>
            <paragraph>Contiguous memory stores imply the following operation performance:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Iterate:</strong> Fastest. Great for loops.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Op: All it does is increment a counter to get to the next record.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>Insert, Erase, Move:</strong> Position-dependent. Generally slow.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Op: Adding/removing/moving content involves moving the adjacent records
                                    over (to make room / fill space).</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Fast add/remove <emphasis>from the end</emphasis>.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Slow add/remove <emphasis>from an arbitrary position</emphasis>.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Slowest add/remove <emphasis>from the front</emphasis>.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>If doing many inserts/removals <emphasis>from the front</emphasis>, then...</paragraph>
                                <block_quote>
                                    <enumerated_list enumtype="arabic" prefix="" suffix=".">
                                        <list_item>
                                            <paragraph>invert the array.</paragraph>
                                        </list_item>
                                        <list_item>
                                            <paragraph>do a loop which executes the Array changes <emphasis>at the end</emphasis>.</paragraph>
                                        </list_item>
                                        <list_item>
                                            <paragraph>re-invert the array.</paragraph>
                                        </list_item>
                                    </enumerated_list>
                                </block_quote>
                                <paragraph>This makes only 2 copies of the array (still constant time, but slow)
                                    versus copying roughly 1/2 of the array, on average, N times (linear time).</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>Get, Set:</strong> Fastest <emphasis>by position</emphasis>. E.g. can request 0th, 2nd, 10th record, etc.
                        but cannot specify which record you want.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Op: 1 addition operation from array start position up to desired index.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>Find:</strong> Slowest. Identifies the index/position of a value.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Op: Must iterate through array and compare values until one finds a match.</paragraph>
                                <block_quote>
                                    <bullet_list bullet="-">
                                        <list_item>
                                            <paragraph>Performance is also dependent on whether one needs an exhaustive
                                                search.</paragraph>
                                        </list_item>
                                    </bullet_list>
                                </block_quote>
                            </list_item>
                            <list_item>
                                <paragraph>If kept ordered, custom search operations can bring it to logarithmic
                                    time (relatively fast). Laymen users won't be comfortable with this
                                    though. Done by re-sorting the Array after every edit and writing an
                                    ordered-aware search algorithm.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
            </bullet_list>
            <paragraph>Godot implements Dictionary as a <literal>HashMap&lt;Variant, Variant, VariantHasher, StringLikeVariantComparator&gt;</literal>. The engine
                stores a small array (initialized to 2^3 or 8 records) of key-value pairs. When
                one attempts to access a value, they provide it a key. It then <emphasis>hashes</emphasis> the
                key, i.e. converts it into a number. The "hash" is used to calculate the index
                into the array. As an array, the HM then has a quick lookup within the "table"
                of keys mapped to values. When the HashMap becomes too full, it increases to
                the next power of 2 (so, 16 records, then 32, etc.) and rebuilds the structure.</paragraph>
            <paragraph>Hashes are to reduce the chance of a key collision. If one occurs, the table
                must recalculate another index for the value that takes the previous position
                into account. In all, this results in constant-time access to all records at
                the expense of memory and some minor operational efficiency.</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Hashing every key an arbitrary number of times.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Hash operations are constant-time, so even if an algorithm must do more
                                    than one, as long as the number of hash calculations doesn't become
                                    too dependent on the density of the table, things will stay fast.
                                    Which leads to...</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph>Maintaining an ever-growing size for the table.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>HashMaps maintain gaps of unused memory interspersed in the table
                                    on purpose to reduce hash collisions and maintain the speed of
                                    accesses. This is why it constantly increases in size exponentially by
                                    powers of 2.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
            </enumerated_list>
            <paragraph>As one might be able to tell, Dictionaries specialize in tasks that Arrays
                do not. An overview of their operational details is as follows:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Iterate:</strong> Fast.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Op: Iterate over the map's internal vector of hashes. Return each key.
                                    Afterwards, users then use the key to jump to and return the desired
                                    value.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>Insert, Erase, Move:</strong> Fastest.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Op: Hash the given key. Do 1 addition operation to look up the
                                    appropriate value (array start + offset). Move is two of these
                                    (one insert, one erase). The map must do some maintenance to preserve
                                    its capabilities:</paragraph>
                                <block_quote>
                                    <bullet_list bullet="-">
                                        <list_item>
                                            <paragraph>update ordered List of records.</paragraph>
                                        </list_item>
                                        <list_item>
                                            <paragraph>determine if table density mandates a need to expand table capacity.</paragraph>
                                        </list_item>
                                    </bullet_list>
                                </block_quote>
                            </list_item>
                            <list_item>
                                <paragraph>The Dictionary remembers in what
                                    order users inserted its keys. This enables it to execute reliable iterations.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>Get, Set:</strong> Fastest. Same as a lookup <emphasis>by key</emphasis>.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Op: Same as insert/erase/move.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>Find:</strong> Slowest. Identifies the key of a value.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Op: Must iterate through records and compare the value until a match is
                                    found.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Note that Godot does not provide this feature out-of-the-box (because
                                    they aren't meant for this task).</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
            </bullet_list>
            <paragraph>Godot implements Objects as stupid, but dynamic containers of data content.
                Objects query data sources when posed questions. For example, to answer
                the question, "do you have a property called, 'position'?", it might ask
                its <reference internal="True" refuri="../../classes/class_script#class-script"><inline classes="std std-ref">script</inline></reference> or the <reference internal="True" refuri="../../classes/class_classdb#class-classdb"><inline classes="std std-ref">ClassDB</inline></reference>.
                One can find more information about what objects are and how they work in
                the <reference internal="True" refuri="what_are_godot_classes#doc-what-are-godot-classes"><inline classes="std std-ref">Applying object-oriented principles in Godot</inline></reference> article.</paragraph>
            <paragraph>The important detail here is the complexity of the Object's task. Every time
                it performs one of these multi-source queries, it runs through <emphasis>several</emphasis>
                iteration loops and HashMap lookups. What's more, the queries are linear-time
                operations dependent on the Object's inheritance hierarchy size. If the class
                the Object queries (its current class) doesn't find anything, the request
                defers to the next base class, all the way up until the original Object class.
                While these are each fast operations in isolation, the fact that it must make
                so many checks is what makes them slower than both of the alternatives for
                looking up data.</paragraph>
            <note>
                <paragraph>When developers mention how slow the scripting API is, it is this chain
                    of queries they refer to. Compared to compiled C++ code where the
                    application knows exactly where to go to find anything, it is inevitable
                    that scripting API operations will take much longer. They must locate the
                    source of any relevant data before they can attempt to access it.</paragraph>
                <paragraph>The reason GDScript is slow is because every operation it performs passes
                    through this system.</paragraph>
                <paragraph>C# can process some content at higher speeds via more optimized bytecode.
                    But, if the C# script calls into an engine class'
                    content or if the script tries to access something external to it, it will
                    go through this pipeline.</paragraph>
                <paragraph>NativeScript C++ goes even further and keeps everything internal by default.
                    Calls into external structures will go through the scripting API. In
                    NativeScript C++, registering methods to expose them to the scripting API is
                    a manual task. It is at this point that external, non-C++ classes will use
                    the API to locate them.</paragraph>
            </note>
            <paragraph>So, assuming one extends from Reference to create a data structure, like
                an Array or Dictionary, why choose an Object over the other two options?</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>Control:</strong> With objects comes the ability to create more sophisticated
                        structures. One can layer abstractions over the data to ensure the external
                        API doesn't change in response to internal data structure changes. What's
                        more, Objects can have signals, allowing for reactive behavior.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Clarity:</strong> Objects are a reliable data source when it comes to the data
                        that scripts and engine classes define for them. Properties may not hold the
                        values one expects, but one doesn't need to worry about whether the property
                        exists in the first place.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Convenience:</strong> If one already has a similar data structure in mind, then
                        extending from an existing class makes the task of building the data
                        structure much easier. In comparison, Arrays and Dictionaries don't
                        fulfill all use cases one might have.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>Objects also give users the opportunity to create even more specialized data
                structures. With it, one can design their own List, Binary Search Tree, Heap,
                Splay Tree, Graph, Disjoint Set, and any host of other options.</paragraph>
            <paragraph>"Why not use Node for tree structures?" one might ask. Well, the Node
                class contains things that won't be relevant to one's custom data structure.
                As such, it can be helpful to construct one's own node type when building
                tree structures.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Object
class_name TreeNode

var _parent: TreeNode = null
var _children := []

func _notification(p_what):
    match p_what:
        NOTIFICATION_PREDELETE:
            # Destructor.
            for a_child in _children:
                a_child.free()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;
using System.Collections.Generic;

// Can decide whether to expose getters/setters for properties later
public partial class TreeNode : GodotObject
{
    private TreeNode _parent = null;

    private List&lt;TreeNode&gt; _children = [];

    public override void _Notification(int what)
    {
        switch (what)
        {
            case NotificationPredelete:
                foreach (TreeNode child in _children)
                {
                    node.Free();
                }
                break;
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>From here, one can then create their own structures with specific features,
                limited only by their imagination.</paragraph>
        </section>
        <section ids="enumerations-int-vs-string" names="enumerations:\ int\ vs.\ string">
            <title>Enumerations: int vs. string</title>
            <paragraph>Most languages offer an enumeration type option. GDScript is no different, but
                unlike most other languages, it allows one to use either integers or strings for
                the enum values (the latter only when using the <literal>@export_enum</literal> annotation in GDScript).
                The question then arises, "which should one use?"</paragraph>
            <paragraph>The short answer is, "whichever you are more comfortable with." This
                is a feature specific to GDScript and not Godot scripting in general;
                The languages prioritizes usability over performance.</paragraph>
            <paragraph>On a technical level, integer comparisons (constant-time) will happen
                faster than string comparisons (linear-time). If one wants to keep
                up other languages' conventions though, then one should use integers.</paragraph>
            <paragraph>The primary issue with using integers comes up when one wants to <emphasis>print</emphasis>
                an enum value. As integers, attempting to print <literal>MY_ENUM</literal> will print
                <literal>5</literal> or what-have-you, rather than something like <literal>"MyEnum"</literal>. To
                print an integer enum, one would have to write a Dictionary that maps the
                corresponding string value for each enum.</paragraph>
            <paragraph>If the primary purpose of using an enum is for printing values and one wishes
                to group them together as related concepts, then it makes sense to use them as
                strings. That way, a separate data structure to execute on the printing is
                unnecessary.</paragraph>
        </section>
        <section ids="animatedtexture-vs-animatedsprite2d-vs-animationplayer-vs-animationtree" names="animatedtexture\ vs.\ animatedsprite2d\ vs.\ animationplayer\ vs.\ animationtree">
            <title>AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree</title>
            <paragraph>Under what circumstances should one use each of Godot's animation classes?
                The answer may not be immediately clear to new Godot users.</paragraph>
            <paragraph><reference internal="True" refuri="../../classes/class_animatedtexture#class-animatedtexture"><inline classes="std std-ref">AnimatedTexture</inline></reference> is a texture that
                the engine draws as an animated loop rather than a static image.
                Users can manipulate...</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>the rate at which it moves across each section of the texture (FPS).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>the number of regions contained within the texture (frames).</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>Godot's <reference internal="True" refuri="../../classes/class_renderingserver#class-renderingserver"><inline classes="std std-ref">RenderingServer</inline></reference> then draws
                the regions in sequence at the prescribed rate. The good news is that this
                involves no extra logic on the part of the engine. The bad news is
                that users have very little control.</paragraph>
            <paragraph>Also note that AnimatedTexture is a <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> unlike
                the other <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> objects discussed here. One might create
                a <reference internal="True" refuri="../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite2D</inline></reference> node that uses AnimatedTexture as its texture.
                Or (something the others can't do) one could add AnimatedTextures as tiles
                in a <reference internal="True" refuri="../../classes/class_tileset#class-tileset"><inline classes="std std-ref">TileSet</inline></reference> and integrate it with a
                <reference internal="True" refuri="../../classes/class_tilemaplayer#class-tilemaplayer"><inline classes="std std-ref">TileMapLayer</inline></reference> for many auto-animating backgrounds that
                all render in a single batched draw call.</paragraph>
            <paragraph>The <reference internal="True" refuri="../../classes/class_animatedsprite2d#class-animatedsprite2d"><inline classes="std std-ref">AnimatedSprite2D</inline></reference> node, in combination with the
                <reference internal="True" refuri="../../classes/class_spriteframes#class-spriteframes"><inline classes="std std-ref">SpriteFrames</inline></reference> resource, allows one to create a
                variety of animation sequences through spritesheets, flip between animations,
                and control their speed, regional offset, and orientation. This makes them
                well-suited to controlling 2D frame-based animations.</paragraph>
            <paragraph>If one needs to trigger other effects in relation to animation changes (for
                example, create particle effects, call functions, or manipulate other
                peripheral elements besides the frame-based animation), then one will need to use
                an <reference internal="True" refuri="../../classes/class_animationplayer#class-animationplayer"><inline classes="std std-ref">AnimationPlayer</inline></reference> node in conjunction with
                the AnimatedSprite2D.</paragraph>
            <paragraph>AnimationPlayers are also the tool one will need to use if they wish to design
                more complex 2D animation systems, such as...</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>Cut-out animations:</strong> editing sprites' transforms at runtime.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>2D Mesh animations:</strong> defining a region for the sprite's texture and
                        rigging a skeleton to it. Then one animates the bones which
                        stretch and bend the texture in proportion to the bones' relationships to
                        each other.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>A mix of the above.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>While one needs an AnimationPlayer to design each of the individual
                animation sequences for a game, it can also be useful to combine animations
                for blending, i.e. enabling smooth transitions between these animations. There
                may also be a hierarchical structure between animations that one plans out for
                their object. These are the cases where the <reference internal="True" refuri="../../classes/class_animationtree#class-animationtree"><inline classes="std std-ref">AnimationTree</inline></reference>
                shines. One can find an in-depth guide on using the AnimationTree
                <reference internal="True" refuri="../animation/animation_tree#doc-animation-tree"><inline classes="std std-ref">here</inline></reference>.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
