<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/best_practices/data_preferences.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-data-preferences"></target>
    <section ids="data-preferences doc-data-preferences" names="data\ preferences 数据偏好 doc_data_preferences">
        <title>数据偏好</title>
        <paragraph>在面对问题 X 的时候，你有没有对应该使用数据结构 Y 还是 Z 产生过困惑？本文会涉及到与这些困境有关的各种主题。</paragraph>
        <note>
            <paragraph>本文会提及“[某某]时间”的操作。这个术语来自于算法分析中的<reference name="大 O 表示法" refuri="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/">大 O 表示法</reference><target ids="o" names="大\ o\ 表示法" refuri="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/"></target>。</paragraph>
            <paragraph>简而言之，它描述了最坏情况下的运行时长。用外行的话来说：</paragraph>
            <paragraph>“随着问题域的大小增加，算法的运行时长……”</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>常量时间，<literal>O(1)</literal>：“……不会增加。”</paragraph>
                </list_item>
                <list_item>
                    <paragraph>对数时间，<literal>O(log n)</literal>：“……会以较慢的速度增长。”</paragraph>
                </list_item>
                <list_item>
                    <paragraph>线性时间，<literal>O(n)</literal>：“……会以相同的速度增长。”</paragraph>
                </list_item>
                <list_item>
                    <paragraph>等等。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>想象一下, 如果必须在一帧内处理300万个数据点. 不可能使用线性时间算法来设计这个特性, 因为数据的绝对大小, 将使运行时间大大超出分配的时间. 相比之下, 使用常量时间算法可以毫无问题地处理该操作.</paragraph>
            <paragraph>总的来说, 开发人员希望尽可能避免进行线性时间操作. 但是, 如果保持线性时间运算的规模很小, 并且如果不需要经常执行操作, 则这是能够接受的. 平衡这些需求, 并为工作选择正确的算法/数据结构, 是使程序员的技能有价值的一部分.</paragraph>
        </note>
        <section ids="array-vs-dictionary-vs-object" names="array\ vs.\ dictionary\ vs.\ object 数组、字典、对象">
            <title>数组、字典、对象</title>
            <paragraph>Godot 把脚本 API 中的所有变量都存储在 <reference internal="True" refuri="../../contributing/development/core_and_modules/variant_class#doc-variant-class"><inline classes="std std-ref">Variant</inline></reference> 中。Variant 可以存储兼容数据结构，例如 <reference internal="True" refuri="../../classes/class_array#class-array"><inline classes="std std-ref">Array</inline></reference> （数组）、 <reference internal="True" refuri="../../classes/class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> （字典）、 <reference internal="True" refuri="../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference> （对象）。</paragraph>
            <paragraph>Godot 使用 <literal>Vector&lt;Variant&gt;</literal> 实现数组。引擎会将数组内容存储在一段连续的内存之中，也就是说，元素与元素之间是相邻的。</paragraph>
            <note>
                <paragraph>这里的 Vector 是传统 C++ STL 库中数组对象的名称，是个“模板”类型，即它只能存储特定类型的数据（用尖括号表示）。例如，<reference internal="True" refuri="../../classes/class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> 其实就类似于 <literal>Vector&lt;String&gt;</literal>。</paragraph>
            </note>
            <paragraph>因为是在内存中连续存储，所以执行各种操作的性能如下：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>迭代：</strong>最快，非常适合循环。</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作：把计数器加一即可获取下一个元素。</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>插入、删除、移动：</strong>与位置相关，一般较慢。</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作：元素的添加、删除、移动需要移动与之相邻的元素（腾出地方或者填充空缺）。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>在<emphasis>末尾</emphasis>添加、删除很快。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>在<emphasis>任意位置</emphasis>添加、删除较慢。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>在<emphasis>开头</emphasis>添加、删除最慢。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>如果需要在<emphasis>开头</emphasis>执行多次插入、删除操作，那么……</paragraph>
                                <block_quote>
                                    <enumerated_list enumtype="arabic" prefix="" suffix=".">
                                        <list_item>
                                            <paragraph>反转数组。</paragraph>
                                        </list_item>
                                        <list_item>
                                            <paragraph>通过循环在<emphasis>末尾</emphasis>执行数组更改。</paragraph>
                                        </list_item>
                                        <list_item>
                                            <paragraph>再把数组反转回来。</paragraph>
                                        </list_item>
                                    </enumerated_list>
                                </block_quote>
                                <paragraph>这样就只复制了两次数组（虽然比较慢，但还是常数时间），否则就得把平均大概一半的数组复制 N 遍（线性时间）。</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>取值、设值：</strong>因为是<emphasis>按位置</emphasis>存取的，所以最快。例如你可以请求第 0 个、第 2 个、第 10 个等等的元素，但不能按照元素的值来请求。</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作：把起始位置做一次加法，得到所需的索引。</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>查找：</strong>最慢。根据值获取索引，也就是位置。</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作：必须遍历数组，一个个元素做比较，直到找到匹配的为止。</paragraph>
                                <block_quote>
                                    <bullet_list bullet="-">
                                        <list_item>
                                            <paragraph>性能同时也取决于是否需要查遍整个数组才能找到目标。</paragraph>
                                        </list_item>
                                    </bullet_list>
                                </block_quote>
                            </list_item>
                            <list_item>
                                <paragraph>如果保持有序, 自定义搜索操作, 可以使其达到对数时间(相对较快). 不过, 外行用户对此会感到不舒服. 通过在每次编辑之后, 重新排序数组, 并编写一个感知顺序的搜索算法来完成.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
            </bullet_list>
            <paragraph>Godot 使用 <literal>OrderedHashMap&lt;Variant, Variant&gt;</literal> 实现 Dictionary。引擎存储一个键值对的小数组（初始化为 2^3 即 8 条记录）。当试图访问一个值时，它提供一个键。然后，对键进行<emphasis>哈希</emphasis>处理，即转换成一个数字。“哈希”值用来计算进入数组的索引。作为一个数组，OHM 就可以在键映射到值的“表”中快速查找。当 HashMap 变得过满时，它会增加到2的下一个幂值（即 16 条记录，然后是 32 条，以此类推），并重新构建结构。</paragraph>
            <paragraph>散列是为了减少键碰撞的机会. 如果发生了, 列表必须为考虑前一个位置的值, 重新计算另一个索引. 总之, 这导致以牺牲内存和一些较小的操作效率为代价, 对所有记录的常量时间访问.</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>散列每个键任意次数.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>散列操作是常量时间的, 因此即使一个算法必须执行多于一个, 只要散列计算的数量不太依赖于列表的密度, 一切都会保持快速. 这导致了……</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph>保持不断增长的表规模.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>HashMaps maintain gaps of unused memory interspersed in the table
                                    on purpose to reduce hash collisions and maintain the speed of
                                    accesses. This is why it constantly increases in size exponentially by
                                    powers of 2.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
            </enumerated_list>
            <paragraph>如大家所知，字典擅长的任务是数组所不擅长的。其操作细节概述如下：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>迭代</strong> : 快速.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作: 遍历映射的内部散列向量. 返回每个键. 之后, 用户使用该键跳转到并返回所需的值.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>插入, 删除, 移动</strong> : 最快.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作: 散列给定的键. 执行1个加法操作来查找适当的值(数组开始+偏移量). 移动其中的两个(一个插入, 一个擦除). 映射必须进行一些维护, 以保留其功能:</paragraph>
                                <block_quote>
                                    <bullet_list bullet="-">
                                        <list_item>
                                            <paragraph>更新记录的有序列表.</paragraph>
                                        </list_item>
                                        <list_item>
                                            <paragraph>确定列表密度, 是否需要扩展列表容量.</paragraph>
                                        </list_item>
                                    </bullet_list>
                                </block_quote>
                            </list_item>
                            <list_item>
                                <paragraph>字典会记住用户插入键的顺序. 这使它能够执行可靠的迭代.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>取值, 设值</strong> : 最快. 和 <emphasis>根据键</emphasis> 查找相同.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作: 和插入/删除/移动类似.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>查找</strong> : 最慢. 标识值的键.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作: 必须遍历记录并比较该值, 直到找到匹配的为止.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>请注意,Godot并未开箱即用地提供此功能(因为它们并非用于此任务).</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
            </bullet_list>
            <paragraph>Godot用愚蠢, 但动态的方式容纳数据容器实现对象. 提出问题时, 对象将查询数据源. 例如, 要回答"你是否有一个名为 <literal>position</literal> 的属性？"的问题, 它可能会询问其 <reference internal="True" refuri="../../classes/class_script#class-script"><inline classes="std std-ref">script</inline></reference> 或 <reference internal="True" refuri="../../classes/class_classdb#class-classdb"><inline classes="std std-ref">ClassDB</inline></reference>. 你可以在 <reference internal="True" refuri="what_are_godot_classes#doc-what-are-godot-classes"><inline classes="std std-ref">在 Godot 中应用面向对象原则</inline></reference> 文章中, 找到有关什么是对象以及它们如何工作的更多信息.</paragraph>
            <paragraph>这里重要的细节是对象任务的复杂性. 每次执行这些多源查询时, 它运行 <emphasis>几个</emphasis> 迭代循环和哈希表查找. 此外, 查询是线性时间操作, 依赖于对象的继承层次结构大小. 如果 <literal>Object</literal> 查询的类(当前类)什么都没有找到, 则该请求将一直推迟到下一个基类, 一直到原始 <literal>Object</literal> 类为止. 虽然这些都是单独的快速操作, 但它必须进行如此多的检查, 于是这一事实使得它们比查找数据的两种方法都要慢.</paragraph>
            <note>
                <paragraph>当开发人员提到脚本API有多慢时, 所引用的正是这一系列查询. 与编译后的, 应用程序知道在哪里可以找到任何东西的,C++代码相比, 不可避免的是, 脚本API操作将花费更长的时间. 他们必须定位任何相关数据的来源, 然后才能尝试访问它.</paragraph>
                <paragraph>GDScript 很慢的原因是, 它执行的每个操作都要经过这个系统.</paragraph>
                <paragraph>C#可以通过更优化的字节码, 以更快的速度处理一些内容. 但是, 如果C#脚本调用引擎类的内容, 或者脚本试图访问它的外部内容, 它会通过这个管道.</paragraph>
                <paragraph>NativeScript C++甚至更进一步, 默认将所有内容都保持在内部. 对外部结构的调用将通过脚本API进行. 在NativeScript C++中, 注册方法以将其公开给脚本API是一项手动任务. 至此, 外部非C++类将使用API来查找它们.</paragraph>
            </note>
            <paragraph>因此, 假设从引用扩展到创建数据结构, 比如一个 <literal>Array</literal> 或 <literal>Dictionary</literal>, 为什么选择一个 <literal>Object</literal> 而不是其他两个选项？</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>控件</strong> : 对象能够创建更复杂的结构. 可以在数据上分层抽象, 以确保外部API不会响应内部数据结构的更改. 更重要的是, 对象可以有信号, 允许响应式行为. 对象带来了创建更复杂结构的能力.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>清晰</strong> : 当涉及到脚本和引擎类为对象定义的数据时, 对象是一个可靠的数据源. 属性可能不包含期望的值, 但是无需担心这个属性是否首先存在.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>便利</strong> : 如果已经有了类似的数据结构, 之后从现有类扩展, 可以使构建数据结构的任务变得容易得多. 相比之下, 数组和字典不能满足所有的用例.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>对象还让用户有机会创建更专门化的数据结构。有了它，一个人可以设计自己的列表、二叉搜索树、堆、散列树、图、不相交集，以及其他选择。</paragraph>
            <paragraph>"为什么不在树结构中使用节点？" 有人可能会问. 节点类包含与自定义数据结构无关的内容. 因此在构建树结构时, 构造自己的节点类型是很有帮助的.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Object
class_name TreeNode

var _parent: TreeNode = null
var _children: = [] setget

func _notification(p_what):
    match p_what:
        NOTIFICATION_PREDELETE:
            # Destructor.
            for a_child in _children:
                a_child.free()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;
using System.Collections.Generic;

// Can decide whether to expose getters/setters for properties later
public partial class TreeNode : GodotObject
{
    private TreeNode _parent = null;

    private List&lt;TreeNode&gt; _children = new();

    public override void _Notification(int what)
    {
        switch (what)
        {
            case NotificationPredelete:
                foreach (TreeNode child in _children)
                {
                    node.Free();
                }
                break;
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>从这里开始, 然后就可以创建具有特定功能的结构, 只会受到他们想象力的限制.</paragraph>
        </section>
        <section ids="enumerations-int-vs-string" names="enumerations:\ int\ vs.\ string 枚举：整数\ vs\ 字符串">
            <title>枚举：整数 VS 字符串</title>
            <paragraph>大多数语言都提供了一个枚举类型选项，GDScript也不例外。但与其他大多数语言不同的是，GDScript的枚举允许开发者使用整数或字符串作为枚举值（只有在GDScript中使用 <literal>@export</literal> 注解时才可使用后者）。 那么问题来了：“该用哪一种枚举？”</paragraph>
            <paragraph>简单回答一下就是：“你觉得哪个更舒服就选哪个。” 这是 GDScript 特有的特性，并非（C++、C#等）一般的 Godot 脚本所特有的特性；该语言将可用性置于性能之上。</paragraph>
            <paragraph>在技术层面上，整数比较（常量时间）比字符串比较（线性时间）更快，若想保持其他语言中使用枚举的习惯，则应使用整数来表示枚举值。</paragraph>
            <paragraph>当你想要 <emphasis>打印</emphasis> 枚举值时，使用整数的主要问题就出现了：尝试直接打印以 <title_reference>int</title_reference> 型保存的枚举 <literal>MY_ENUM</literal> 会打印 <literal>5</literal> 之类的东西，而不是像 <literal>MyEnum</literal> 这样的字符。若要打印以 <title_reference>int</title_reference> 型保存的枚举。必须编写一个字典来映射每个枚举所对应的字符串值。</paragraph>
            <paragraph>如果开发者使用枚举的主要目的是打印值，并希望将它们作为相关概念组合在一起，那么将枚举作为字符串使用是有意义的。这样一来，也就不需要在打印上执行单独的数据结构了。</paragraph>
        </section>
        <section ids="animatedtexture-vs-animatedsprite2d-vs-animationplayer-vs-animationtree" names="animatedtexture\ vs.\ animatedsprite2d\ vs.\ animationplayer\ vs.\ animationtree">
            <title>AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree</title>
            <paragraph>在什么情况下应该使用Godot的各种动画类？对于Godot的新用户来说, 可能不是马上清楚答案.</paragraph>
            <paragraph><reference internal="True" refuri="../../classes/class_animatedtexture#class-animatedtexture"><inline classes="std std-ref">AnimatedTexture</inline></reference> 是引擎绘制一个动画循环, 而不是一个静态图像的纹理. 用户可以进行如下操作…</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>它在纹理的每个部分移动的速率（FPS）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>纹理中包含的区域数(帧).</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>Godot 的 <reference internal="True" refuri="../../classes/class_renderingserver#class-renderingserver"><inline classes="std std-ref">RenderingServer</inline></reference> 会按照规定的速度依次绘制区块。好处是不涉及引擎部分额外的逻辑。坏处是用户几乎没有控制权。</paragraph>
            <paragraph>另外请注意，AnimatedTexture 是一种 <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>，与此处讨论的其他 <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> 对象不同。可以创建 <reference internal="True" refuri="../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite2D</inline></reference> 节点，使用 AnimatedTexture 作为其纹理。或者（仅在其他方法无法满足要求时）可以将 AnimatedTexture 作为图块添加到 <reference internal="True" refuri="../../classes/class_tileset#class-tileset"><inline classes="std std-ref">TileSet</inline></reference> 中并将其与 <reference internal="True" refuri="../../classes/class_tilemap#class-tilemap"><inline classes="std std-ref">TileMap</inline></reference> 集成到一起，从而获得自动动画化的背景。使用此方法时所有的渲染将在单个批处理内绘制调用。</paragraph>
            <paragraph><literal>AnimatedSprite</literal> 节点可以与 <reference internal="True" refuri="../../classes/class_spriteframes#class-spriteframes"><inline classes="std std-ref">SpriteFrames</inline></reference> 资源结合使用，使用户可以通过精灵表创建各种动画序列、在动画之间切换并控制它们的速度、区域偏移量和方向。这使得它们非常适合控制基于二维的帧动画。</paragraph>
            <paragraph>触发与动画更改相关的其他效果，例如创建粒子效果、调用函数或操作除基于帧的动画外的其他外围元素需要将一个 <reference internal="True" refuri="../../classes/class_animationplayer#class-animationplayer"><inline classes="std std-ref">AnimationPlayer</inline></reference> 节点与 <literal>AnimatedSprite</literal> 关联。</paragraph>
            <paragraph>如果你想设计更复杂的二维动画系统，AnimationPlayer 也是你的必备工具，例如……</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>剪纸动画：</strong>在运行时编辑精灵的变换。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>二维网格动画</strong>：为精灵的纹理划分一个区域，并将骨架绑定在上面。然后动画化其中的骨骼，使骨骼按照彼此之间的关系，成比例地拉伸和弯曲纹理。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>综上所述.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>虽然我们需要一个 AnimationPlayer, 来为游戏设计每个独立的动画序列, 它也可以用来混合复合动画, 也就是说, 在这些动画之间实现平滑的转换. 在为对象规划的动画之间, 也可能存在一个层次结构. 在这些情况下使用 <reference internal="True" refuri="../../classes/class_animationtree#class-animationtree"><inline classes="std std-ref">AnimationTree</inline></reference> 效果很出色. 可以在 <reference internal="True" refuri="../animation/animation_tree#doc-animation-tree"><inline classes="std std-ref">这里</inline></reference> 找到关于使用 AnimationTree 的深入指南.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
