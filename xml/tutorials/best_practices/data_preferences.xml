<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/best_practices/data_preferences.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-data-preferences"></target>
    <section ids="data-preferences doc-data-preferences" names="data\ preferences 数据偏好 doc_data_preferences">
        <title>数据偏好</title>
        <paragraph>在面对问题 X 的时候，你有没有对应该使用数据结构 Y 还是 Z 产生过困惑？本文会涉及到与这些困境有关的各种主题。</paragraph>
        <note>
            <paragraph>本文会提及“[某某]时间”的操作。这个术语来自于算法分析中的<reference name="大 O 表示法" refuri="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/">大 O 表示法</reference><target ids="o" names="大\ o\ 表示法" refuri="https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation/"></target>。</paragraph>
            <paragraph>简而言之，它描述了最坏情况下的运行时长。用外行的话来说：</paragraph>
            <paragraph>“随着问题域的大小增加，算法的运行时长……”</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>常量时间，<literal>O(1)</literal>：“……不会增加。”</paragraph>
                </list_item>
                <list_item>
                    <paragraph>对数时间，<literal>O(log n)</literal>：“……会以较慢的速度增长。”</paragraph>
                </list_item>
                <list_item>
                    <paragraph>线性时间，<literal>O(n)</literal>：“……会以相同的速度增长。”</paragraph>
                </list_item>
                <list_item>
                    <paragraph>等等。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>想象一下, 如果必须在一帧内处理300万个数据点. 不可能使用线性时间算法来设计这个特性, 因为数据的绝对大小, 将使运行时间大大超出分配的时间. 相比之下, 使用常量时间算法可以毫无问题地处理该操作.</paragraph>
            <paragraph>总的来说, 开发人员希望尽可能避免进行线性时间操作. 但是, 如果保持线性时间运算的规模很小, 并且如果不需要经常执行操作, 则这是能够接受的. 平衡这些需求, 并为工作选择正确的算法/数据结构, 是使程序员的技能有价值的一部分.</paragraph>
        </note>
        <section ids="array-vs-dictionary-vs-object" names="array\ vs.\ dictionary\ vs.\ object 数组、字典、对象">
            <title>数组、字典、对象</title>
            <paragraph>Godot 把脚本 API 中的所有变量都存储在 <reference internal="True" refuri="../../contributing/development/core_and_modules/variant_class#doc-variant-class"><inline classes="std std-ref">Variant</inline></reference> 中。Variant 可以存储兼容数据结构，例如 <reference internal="True" refuri="../../classes/class_array#class-array"><inline classes="std std-ref">Array</inline></reference> （数组）、 <reference internal="True" refuri="../../classes/class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> （字典）、 <reference internal="True" refuri="../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference> （对象）。</paragraph>
            <paragraph>Godot 使用 <literal>Vector&lt;Variant&gt;</literal> 实现数组。引擎会将数组内容存储在一段连续的内存之中，也就是说，元素与元素之间是相邻的。</paragraph>
            <note>
                <paragraph>这里的 Vector 是传统 C++ STL 库中数组对象的名称，是个“模板”类型，即它只能存储特定类型的数据（用尖括号表示）。例如，<reference internal="True" refuri="../../classes/class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> 其实就类似于 <literal>Vector&lt;String&gt;</literal>。</paragraph>
            </note>
            <paragraph>因为是在内存中连续存储，所以执行各种操作的性能如下：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>迭代：</strong>最快，非常适合循环。</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作：把计数器加一即可获取下一个元素。</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>插入、删除、移动：</strong>与位置相关，一般较慢。</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作：元素的添加、删除、移动需要移动与之相邻的元素（腾出地方或者填充空缺）。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>在<emphasis>末尾</emphasis>添加、删除很快。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>在<emphasis>任意位置</emphasis>添加、删除较慢。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>在<emphasis>开头</emphasis>添加、删除最慢。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>如果需要在<emphasis>开头</emphasis>执行多次插入、删除操作，那么……</paragraph>
                                <block_quote>
                                    <enumerated_list enumtype="arabic" prefix="" suffix=".">
                                        <list_item>
                                            <paragraph>反转数组。</paragraph>
                                        </list_item>
                                        <list_item>
                                            <paragraph>通过循环在<emphasis>末尾</emphasis>执行数组更改。</paragraph>
                                        </list_item>
                                        <list_item>
                                            <paragraph>再把数组反转回来。</paragraph>
                                        </list_item>
                                    </enumerated_list>
                                </block_quote>
                                <paragraph>这样就只复制了两次数组（虽然比较慢，但还是常数时间），否则就得把平均大概一半的数组复制 N 遍（线性时间）。</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>取值、设值：</strong>因为是<emphasis>按位置</emphasis>存取的，所以最快。例如你可以请求第 0 个、第 2 个、第 10 个等等的元素，但不能按照元素的值来请求。</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作：把起始位置做一次加法，得到所需的索引。</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>查找：</strong>最慢。根据值获取索引，也就是位置。</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作：必须遍历数组，一个个元素做比较，直到找到匹配的为止。</paragraph>
                                <block_quote>
                                    <bullet_list bullet="-">
                                        <list_item>
                                            <paragraph>性能同时也取决于是否需要查遍整个数组才能找到目标。</paragraph>
                                        </list_item>
                                    </bullet_list>
                                </block_quote>
                            </list_item>
                            <list_item>
                                <paragraph>如果保持有序, 自定义搜索操作, 可以使其达到对数时间(相对较快). 不过, 外行用户对此会感到不舒服. 通过在每次编辑之后, 重新排序数组, 并编写一个感知顺序的搜索算法来完成.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
            </bullet_list>
            <paragraph>Godot 使用 <literal>OrderedHashMap&lt;Variant, Variant&gt;</literal> 实现 Dictionary。引擎存储一个键值对的小数组（初始化为 2^3 即 8 条记录）。当试图访问一个值时，它提供一个键。然后，对键进行<emphasis>哈希</emphasis>处理，即转换成一个数字。“哈希”值用来计算进入数组的索引。作为一个数组，OHM 就可以在键映射到值的“表”中快速查找。当 HashMap 变得过满时，它会增加到2的下一个幂值（即 16 条记录，然后是 32 条，以此类推），并重新构建结构。</paragraph>
            <paragraph>散列是为了减少键碰撞的机会. 如果发生了, 列表必须为考虑前一个位置的值, 重新计算另一个索引. 总之, 这导致以牺牲内存和一些较小的操作效率为代价, 对所有记录的常量时间访问.</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>散列每个键任意次数.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>散列操作是常量时间的, 因此即使一个算法必须执行多于一个, 只要散列计算的数量不太依赖于列表的密度, 一切都会保持快速. 这导致了……</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph>保持不断增长的表规模.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>HashMaps为了减少哈希冲突, 并保持访问速度, 在表中保留了未使用的内存的间隙. 这也是为什么它的大小不断地以2的幂次增加的原因.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
            </enumerated_list>
            <paragraph>如大家所知，字典擅长的任务是数组所不擅长的。其操作细节概述如下：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>迭代</strong> : 快速.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作: 遍历映射的内部散列向量. 返回每个键. 之后, 用户使用该键跳转到并返回所需的值.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>插入, 删除, 移动</strong> : 最快.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作: 散列给定的键. 执行1个加法操作来查找适当的值(数组开始+偏移量). 移动其中的两个(一个插入, 一个擦除). 映射必须进行一些维护, 以保留其功能:</paragraph>
                                <block_quote>
                                    <bullet_list bullet="-">
                                        <list_item>
                                            <paragraph>更新记录的有序列表.</paragraph>
                                        </list_item>
                                        <list_item>
                                            <paragraph>确定列表密度, 是否需要扩展列表容量.</paragraph>
                                        </list_item>
                                    </bullet_list>
                                </block_quote>
                            </list_item>
                            <list_item>
                                <paragraph>字典会记住用户插入键的顺序. 这使它能够执行可靠的迭代.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>取值, 设值</strong> : 最快. 和 <emphasis>根据键</emphasis> 查找相同.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作: 和插入/删除/移动类似.</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
                <list_item>
                    <paragraph><strong>查找</strong> : 最慢. 标识值的键.</paragraph>
                    <block_quote>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>操作: 必须遍历记录并比较该值, 直到找到匹配的为止.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>请注意,Godot并未开箱即用地提供此功能(因为它们并非用于此任务).</paragraph>
                            </list_item>
                        </bullet_list>
                    </block_quote>
                </list_item>
            </bullet_list>
            <paragraph>Godot用愚蠢, 但动态的方式容纳数据容器实现对象. 提出问题时, 对象将查询数据源. 例如, 要回答"你是否有一个名为 <literal>position</literal> 的属性？"的问题, 它可能会询问其 <reference internal="True" refuri="../../classes/class_script#class-script"><inline classes="std std-ref">script</inline></reference> 或 <reference internal="True" refuri="../../classes/class_classdb#class-classdb"><inline classes="std std-ref">ClassDB</inline></reference>. 你可以在 <reference internal="True" refuri="what_are_godot_classes#doc-what-are-godot-classes"><inline classes="std std-ref">在 Godot 中应用面向对象原则</inline></reference> 文章中, 找到有关什么是对象以及它们如何工作的更多信息.</paragraph>
            <paragraph>这里重要的细节是对象任务的复杂性. 每次执行这些多源查询时, 它运行 <emphasis>几个</emphasis> 迭代循环和哈希表查找. 此外, 查询是线性时间操作, 依赖于对象的继承层次结构大小. 如果 <literal>Object</literal> 查询的类(当前类)什么都没有找到, 则该请求将一直推迟到下一个基类, 一直到原始 <literal>Object</literal> 类为止. 虽然这些都是单独的快速操作, 但它必须进行如此多的检查, 于是这一事实使得它们比查找数据的两种方法都要慢.</paragraph>
            <note>
                <paragraph>当开发人员提到脚本API有多慢时, 所引用的正是这一系列查询. 与编译后的, 应用程序知道在哪里可以找到任何东西的,C++代码相比, 不可避免的是, 脚本API操作将花费更长的时间. 他们必须定位任何相关数据的来源, 然后才能尝试访问它.</paragraph>
                <paragraph>GDScript很慢的原因是, 它执行的每个操作都要经过这个系统.</paragraph>
                <paragraph>C#可以通过更优化的字节码, 以更快的速度处理一些内容. 但是, 如果C#脚本调用引擎类的内容, 或者脚本试图访问它的外部内容, 它会通过这个管道.</paragraph>
                <paragraph>NativeScript C++甚至更进一步, 默认将所有内容都保持在内部. 对外部结构的调用将通过脚本API进行. 在NativeScript C++中, 注册方法以将其公开给脚本API是一项手动任务. 至此, 外部非C++类将使用API来查找它们.</paragraph>
            </note>
            <paragraph>因此, 假设从引用扩展到创建数据结构, 比如一个 <literal>Array</literal> 或 <literal>Dictionary</literal>, 为什么选择一个 <literal>Object</literal> 而不是其他两个选项？</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>控件</strong> : 对象能够创建更复杂的结构. 可以在数据上分层抽象, 以确保外部API不会响应内部数据结构的更改. 更重要的是, 对象可以有信号, 允许响应式行为. 对象带来了创建更复杂结构的能力.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>清晰</strong> : 当涉及到脚本和引擎类为对象定义的数据时, 对象是一个可靠的数据源. 属性可能不包含期望的值, 但是无需担心这个属性是否首先存在.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>便利</strong> : 如果已经有了类似的数据结构, 之后从现有类扩展, 可以使构建数据结构的任务变得容易得多. 相比之下, 数组和字典不能满足所有的用例.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>对象还让用户有机会创建更专门化的数据结构。有了它，一个人可以设计自己的列表、二叉搜索树、堆、散列树、图、不相交集，以及其他选择。</paragraph>
            <paragraph>"为什么不在树结构中使用节点？" 有人可能会问. 节点类包含与自定义数据结构无关的内容. 因此在构建树结构时, 构造自己的节点类型是很有帮助的.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Object
class_name TreeNode

var _parent: TreeNode = null
var _children: = [] setget

func _notification(p_what):
    match p_what:
        NOTIFICATION_PREDELETE:
            # Destructor.
            for a_child in _children:
                a_child.free()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;
using System.Collections.Generic;

// Can decide whether to expose getters/setters for properties later
public partial class TreeNode : GodotObject
{
    private TreeNode _parent = null;

    private List&lt;TreeNode&gt; _children = new();

    public override void _Notification(int what)
    {
        switch (what)
        {
            case NotificationPredelete:
                foreach (TreeNode child in _children)
                {
                    node.Free();
                }
                break;
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>从这里开始, 然后就可以创建具有特定功能的结构, 只会受到他们想象力的限制.</paragraph>
        </section>
        <section ids="enumerations-int-vs-string" names="enumerations:\ int\ vs.\ string 枚举：整数\ vs\ 字符串">
            <title>枚举：整数 VS 字符串</title>
            <paragraph>大多数语言都提供了一个枚举类型选项.GDScript也不例外, 但与大多数其他语言不同的是, 它允许人们使用整数或字符串作为枚举值(只有在GDScript中使用 <literal>export</literal> 关键字时才可使用后者). 那么问题就来了,"应该使用哪一种？"</paragraph>
            <paragraph>简而言之,"你觉得哪个更舒服就选哪个." 这是GDScript特有的特性, 而并非一般的Godot脚本；该语言将可用性置于性能之上.</paragraph>
            <paragraph>在技术层面上, 整数比较(常量时间)比字符串比较(线性时间)更快. 如果你想保持其他语言的习惯, 那么应该使用整数.</paragraph>
            <paragraph>当你想要 <emphasis>打印</emphasis> 枚举值时，使用整数的主要问题就出现了。尝试直接打印以 <title_reference>int</title_reference> 型保存的枚举 <literal>MY_ENUM</literal> ，将会打印 <literal>5</literal> 之类的东西，而不是像 <literal>MyEnum</literal> 这样的词。要打印以 <title_reference>int</title_reference> 型保存的枚举。必须编写一个字典来映射每个枚举对应的字符串值。</paragraph>
            <paragraph>如果使用枚举的主要目的是打印值, 并且希望将它们作为相关概念组合在一起, 那么使用它们作为字符串是有意义的. 这样, 就不需要在打印上执行单独的数据结构.</paragraph>
        </section>
        <section ids="animatedtexture-vs-animatedsprite2d-vs-animationplayer-vs-animationtree" names="animatedtexture\ vs.\ animatedsprite2d\ vs.\ animationplayer\ vs.\ animationtree">
            <title>AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree</title>
            <paragraph>在什么情况下应该使用Godot的各种动画类？对于Godot的新用户来说, 可能不是马上清楚答案.</paragraph>
            <paragraph><reference internal="True" refuri="../../classes/class_animatedtexture#class-animatedtexture"><inline classes="std std-ref">AnimatedTexture</inline></reference> 是引擎绘制一个动画循环, 而不是一个静态图像的纹理. 用户可以进行如下操作…</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>它在纹理的每个部分移动的速率（FPS）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>纹理中包含的区域数(帧).</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>Godot 的 <reference internal="True" refuri="../../classes/class_renderingserver#class-renderingserver"><inline classes="std std-ref">RenderingServer</inline></reference> 会按照规定的速度依次绘制区块。好处是不涉及引擎部分额外的逻辑。坏处是用户几乎没有控制权。</paragraph>
            <paragraph>另外请注意，AnimatedTexture 是一种 <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>，与此处讨论的其他 <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> 对象不同。可以创建 <reference internal="True" refuri="../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite2D</inline></reference> 节点，使用 AnimatedTexture 作为其纹理。或者（仅在其他方法无法满足要求时）可以将 AnimatedTexture 作为图块添加到 <reference internal="True" refuri="../../classes/class_tileset#class-tileset"><inline classes="std std-ref">TileSet</inline></reference> 中并将其与 <reference internal="True" refuri="../../classes/class_tilemap#class-tilemap"><inline classes="std std-ref">TileMap</inline></reference> 集成到一起，从而获得自动动画化的背景。使用此方法时所有的渲染将在单个批处理内绘制调用。</paragraph>
            <paragraph><literal>AnimatedSprite</literal> 节点可以与 <reference internal="True" refuri="../../classes/class_spriteframes#class-spriteframes"><inline classes="std std-ref">SpriteFrames</inline></reference> 资源结合使用，使用户可以通过精灵表创建各种动画序列、在动画之间切换并控制它们的速度、区域偏移量和方向。这使得它们非常适合控制基于二维的帧动画。</paragraph>
            <paragraph>触发与动画更改相关的其他效果，例如创建粒子效果、调用函数或操作除基于帧的动画外的其他外围元素需要将一个 <reference internal="True" refuri="../../classes/class_animationplayer#class-animationplayer"><inline classes="std std-ref">AnimationPlayer</inline></reference> 节点与 <literal>AnimatedSprite</literal> 关联。</paragraph>
            <paragraph>如果你想设计更复杂的二维动画系统，AnimationPlayer 也是你的必备工具，例如……</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>剪纸动画：</strong>在运行时编辑精灵的变换。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>二维网格动画</strong>：为精灵的纹理划分一个区域，并将骨架绑定在上面。然后动画化其中的骨骼，使骨骼按照彼此之间的关系，成比例地拉伸和弯曲纹理。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>综上所述.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>虽然我们需要一个 AnimationPlayer, 来为游戏设计每个独立的动画序列, 它也可以用来混合复合动画, 也就是说, 在这些动画之间实现平滑的转换. 在为对象规划的动画之间, 也可能存在一个层次结构. 在这些情况下使用 <reference internal="True" refuri="../../classes/class_animationtree#class-animationtree"><inline classes="std std-ref">AnimationTree</inline></reference> 效果很出色. 可以在 <reference internal="True" refuri="../animation/animation_tree#doc-animation-tree"><inline classes="std std-ref">这里</inline></reference> 找到关于使用 AnimationTree 的深入指南.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
