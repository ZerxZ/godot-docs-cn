<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/best_practices/autoloads_versus_internal_nodes.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-autoloads-versus-internal-nodes"></target>
    <section ids="autoloads-versus-regular-nodes doc-autoloads-versus-internal-nodes" names="autoloads\ versus\ regular\ nodes 自动加载与常规节点 doc_autoloads_versus_internal_nodes">
        <title>自动加载与常规节点</title>
        <paragraph>Godot 提供了一个在项目根节点自动加载节点的功能，允许你在全局范围内访问它们，从而完成单例作用 <reference internal="True" refuri="../scripting/singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">单例（自动加载）</inline></reference> 。当你在代码中使用 <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree-method-change-scene-to-file"><inline classes="std std-ref">SceneTree.change_scene_to_file</inline></reference> 更改场景时，这些自动加载的节点不会被释放。</paragraph>
        <paragraph>在本指南中, 你将学习到何时使用自动加载功能, 以及避免使用该功能的方法.</paragraph>
        <section ids="the-cutting-audio-issue" names="the\ cutting\ audio\ issue 切割音频问题">
            <title>切割音频问题</title>
            <paragraph>其他引擎可能鼓励使用创建管理类, 单例将很多功能组织到一个全局可访问的对象中. 由于节点树和信号,Godot提供了许多避免全局状态的方法.</paragraph>
            <paragraph>例如, 假设我们正在构建一个平台游戏, 并希望收集能够播放声音效果的硬币, 那么就有一个节点 <reference internal="True" refuri="../../classes/class_audiostreamplayer#class-audiostreamplayer"><inline classes="std std-ref">AudioStreamPlayer</inline></reference>. 如果在 <literal>AudioStreamPlayer</literal> 已经在播放声音时调用它, 新的声音就会打断第一个声音.</paragraph>
            <paragraph>一种解决方案是写一个全局的、自动加载的音效管理器类。它会生成一个 <literal>AudioStreamPlayer</literal> 的节点池，每当一个新的音效请求出现时，它就会在这个节点池中找到可用的节点来播放。我们不妨就把该类命名为 <literal>Sound</literal> ，你可以通过 <literal>Sound.play("coin_pickup.ogg")</literal> 从你项目中的任何位置使用它。这在短期内解决了问题但是却造成了更多的麻烦：</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>全局状态</strong> : 一个对象现在负责所有对象的数据. 如果音效有错误, 或没有一个可用的 <literal>AudioStreamPlayer</literal> , 一切都会崩溃.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>全局访问</strong> : 意味着任何对象都可以从任何地方调用 <literal>Sound.play(sound_path)</literal> , 便不容易找到错误的来源了.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>全局资源分配</strong> : 由于从一开始就存储了一个 <literal>AudioStreamPlayer</literal> 节点池, 如果数量太少会遇到bug, 而数量太多则会占用更多的内存.</paragraph>
                </list_item>
            </enumerated_list>
            <note>
                <paragraph>全局访问的问题在于，任何地方的代码都可能将错误的数据传递给我们例子中的 <literal>Sound</literal> 自动加载。因此，为了修复这个 bug，你需要检索的区域涵盖了整个项目。</paragraph>
                <paragraph>当你将代码保存在场景中时, 音频可能仅涉及一个或两个脚本.</paragraph>
            </note>
            <paragraph>与之形成对比的是, 每个场景在其内部, 保留尽可能多的 <literal>AudioStreamPlayer</literal> 节点, 所有这些问题都会消失:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>每个场景管理自己的状态信息. 如果数据有问题, 则只会在该场景中引起问题.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>每个场景只访问自己的节点. 那么如果有一个bug, 很容易找到哪个节点有问题.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>每个场景只分配所需数量的资源.</paragraph>
                </list_item>
            </enumerated_list>
        </section>
        <section ids="managing-shared-functionality-or-data" names="managing\ shared\ functionality\ or\ data 管理共享功能或数据">
            <title>管理共享功能或数据</title>
            <paragraph>使用自动加载的另一个原因可能是你希望在许多场景中重复使用相同的方法或数据.</paragraph>
            <paragraph>对于函数，可以使用 GDScript 中的 <reference internal="True" refuri="../scripting/gdscript/gdscript_basics#doc-gdscript-basics-class-name"><inline classes="std std-ref">class_name</inline></reference> 关键字创建一种新的 <literal>Node</literal> 类型，为单个场景提供该功能。</paragraph>
            <paragraph>当涉及到数据时, 你可以:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>创建一个新类型的 <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> 来共享数据.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>将数据存储在每个节点可以访问的对象中, 例如使用 <literal>owner</literal> 属性来访问场景的根节点.</paragraph>
                </list_item>
            </enumerated_list>
        </section>
        <section ids="when-you-should-use-an-autoload" names="when\ you\ should\ use\ an\ autoload 何时应使用自动加载">
            <title>何时应使用自动加载</title>
            <paragraph>GDScript 支持使用 <literal>static func</literal> 创建 <literal>static</literal> （静态） 函数。 当与 <literal>class_name</literal> 结合使用时，（静态函数）可以创建辅助函数库，而无需创建实例来调用它们。 静态函数也具有限制，它们不能引用成员变量、非静态（non-static）函数或 <literal>self</literal> 。</paragraph>
            <paragraph>从 Godot 4.1 开始，GDScript 还支持使用 <literal>static var</literal> 的 <literal>static</literal> （静态）变量。 这意味着你现在可以在类的实例之间共享变量，而无需创建单独的自动加载。</paragraph>
            <paragraph>尽管如此，对于那些涵盖范围广泛的系统来说，使用自动加载的节点仍然可以简化你的代码。如果自动加载的节点管理自己的信息并且不侵入其他对象的数据，那么这就是一个创建处理广泛任务的系统（例如，任务或对话系统）的好方法。</paragraph>
            <note>
                <paragraph>自动加载 <emphasis>不</emphasis> 完全是一个单例。没有什么可以阻止你实例化自动加载的节点的副本。它只是一个使节点作为场景树的根的子节点自动加载的工具，而与游戏的节点结构或运行哪个场景（比如通过按 <literal classes="kbd">F6</literal> 键运行当前场景）无关。</paragraph>
                <paragraph>因此，你可以像这样，通过调用 <literal>get_node("/root/Sound")</literal> 来获取名为 <literal>Sound</literal> 的自动加载节点。</paragraph>
            </note>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
