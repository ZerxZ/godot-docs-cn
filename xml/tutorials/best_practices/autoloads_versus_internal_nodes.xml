<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/best_practices/autoloads_versus_internal_nodes.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-autoloads-versus-internal-nodes"></target>
    <section ids="autoloads-versus-regular-nodes doc-autoloads-versus-internal-nodes" names="autoloads\ versus\ regular\ nodes doc_autoloads_versus_internal_nodes">
        <title>Autoloads versus regular nodes</title>
        <paragraph>Godot offers a feature to automatically load nodes at the root of your project,
            allowing you to access them globally, that can fulfill the role of a Singleton:
            <reference internal="True" refuri="../scripting/singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">Singletons (Autoload)</inline></reference>. These autoloaded nodes are not freed when you
            change the scene from code with <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree-method-change-scene-to-file"><inline classes="std std-ref">SceneTree.change_scene_to_file</inline></reference>.</paragraph>
        <paragraph>In this guide, you will learn when to use the Autoload feature, and techniques
            you can use to avoid it.</paragraph>
        <section ids="the-cutting-audio-issue" names="the\ cutting\ audio\ issue">
            <title>The cutting audio issue</title>
            <paragraph>Other engines can encourage the use of creating manager classes, singletons that
                organize a lot of functionality into a globally accessible object. Godot offers
                many ways to avoid global state thanks to the node tree and signals.</paragraph>
            <paragraph>For example, let's say we are building a platformer and want to collect coins
                that play a sound effect. There's a node for that: the <reference internal="True" refuri="../../classes/class_audiostreamplayer#class-audiostreamplayer"><inline classes="std std-ref">AudioStreamPlayer</inline></reference>. But if we call the <literal>AudioStreamPlayer</literal> while it is
                already playing a sound, the new sound interrupts the first.</paragraph>
            <paragraph>A solution is to code a global, autoloaded sound manager class. It generates a
                pool of <literal>AudioStreamPlayer</literal> nodes that cycle through as each new request for
                sound effects comes in. Say we call that class <literal>Sound</literal>, you can use it from
                anywhere in your project by calling <literal>Sound.play("coin_pickup.ogg")</literal>. This
                solves the problem in the short term but causes more problems:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>Global state</strong>: one object is now responsible for all objects' data. If the
                        <literal>Sound</literal> class has errors or doesn't have an AudioStreamPlayer available,
                        all the nodes calling it can break.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Global access</strong>: now that any object can call <literal>Sound.play(sound_path)</literal>
                        from anywhere, there's no longer an easy way to find the source of a bug.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Global resource allocation</strong>: with a pool of <literal>AudioStreamPlayer</literal> nodes
                        stored from the start, you can either have too few and face bugs, or too many
                        and use more memory than you need.</paragraph>
                </list_item>
            </enumerated_list>
            <note>
                <paragraph>About global access, the problem is that any code anywhere could pass wrong
                    data to the <literal>Sound</literal> autoload in our example. As a result, the domain to
                    explore to fix the bug spans the entire project.</paragraph>
                <paragraph>When you keep code inside a scene, only one or two scripts may be
                    involved in audio.</paragraph>
            </note>
            <paragraph>Contrast this with each scene keeping as many <literal>AudioStreamPlayer</literal> nodes as it
                needs within itself and all these problems go away:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Each scene manages its own state information. If there is a problem with the
                        data, it will only cause issues in that one scene.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Each scene accesses only its own nodes. Now, if there is
                        a bug, it's easy to find which node is at fault.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Each scene allocates exactly the amount of resources it needs.</paragraph>
                </list_item>
            </enumerated_list>
        </section>
        <section ids="managing-shared-functionality-or-data" names="managing\ shared\ functionality\ or\ data">
            <title>Managing shared functionality or data</title>
            <paragraph>Another reason to use an Autoload can be that you want to reuse the same method
                or data across many scenes.</paragraph>
            <paragraph>In the case of functions, you can create a new type of <literal>Node</literal> that provides
                that feature for an individual scene using the <reference internal="True" refuri="../scripting/gdscript/gdscript_basics#doc-gdscript-basics-class-name"><inline classes="std std-ref">class_name</inline></reference> keyword in GDScript.</paragraph>
            <paragraph>When it comes to data, you can either:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Create a new type of <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> to share the data.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Store the data in an object to which each node has access, for example using
                        the <literal>owner</literal> property to access the scene's root node.</paragraph>
                </list_item>
            </enumerated_list>
        </section>
        <section ids="when-you-should-use-an-autoload" names="when\ you\ should\ use\ an\ autoload">
            <title>When you should use an Autoload</title>
            <paragraph>GDScript supports the creation of <literal>static</literal> functions using <literal>static func</literal>.
                When combined with <literal>class_name</literal>, this makes it possible to create libraries of
                helper functions without having to create an instance to call them. The
                limitation of static functions is that they can't reference member variables,
                non-static functions or <literal>self</literal>.</paragraph>
            <paragraph>Since Godot 4.1, GDScript also supports <literal>static</literal> variables using <literal>static var</literal>.
                This means you can now share variables across instances of a class without
                having to create a separate autoload.</paragraph>
            <paragraph>Still, autoloaded nodes can simplify your code for systems with a wide scope. If
                the autoload is managing its own information and not invading the data of other
                objects, then it's a great way to create systems that handle broad-scoped tasks.
                For example, a quest or a dialogue system.</paragraph>
            <note>
                <paragraph>An autoload is <emphasis>not</emphasis> necessarily a singleton. Nothing prevents you from
                    instantiating copies of an autoloaded node. An autoload is only a tool that
                    makes a node load automatically as a child of the root of your scene tree,
                    regardless of your game's node structure or which scene you run, e.g. by
                    pressing the <literal classes="kbd">F6</literal> key.</paragraph>
                <paragraph>As a result, you can get the autoloaded node, for example an autoload called
                    <literal>Sound</literal>, by calling <literal>get_node("/root/Sound")</literal>.</paragraph>
            </note>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
