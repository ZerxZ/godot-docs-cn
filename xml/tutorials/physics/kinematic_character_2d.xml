<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/physics/kinematic_character_2d.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-kinematic-character-2d"></target>
    <section ids="kinematic-character-2d doc-kinematic-character-2d" names="kinematic\ character\ (2d) doc_kinematic_character_2d">
        <title>Kinematic character (2D)</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>Yes, the name sounds strange. "Kinematic Character". What is that?
                The reason for the name is that, when physics engines came out, they were called
                "Dynamics" engines (because they dealt mainly with collision
                responses). Many attempts were made to create a character controller
                using the dynamics engines, but it wasn't as easy as it seemed. Godot
                has one of the best implementations of dynamic character controller
                you can find (as it can be seen in the 2d/platformer demo), but using
                it requires a considerable level of skill and understanding of
                physics engines (or a lot of patience with trial and error).</paragraph>
            <paragraph>Some physics engines, such as Havok seem to swear by dynamic character
                controllers as the best option, while others (PhysX) would rather
                promote the kinematic one.</paragraph>
            <paragraph>So, what is the difference?:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>A <strong>dynamic character controller</strong> uses a rigid body with an infinite
                        inertia tensor. It's a rigid body that can't rotate.
                        Physics engines always let objects move and collide, then solve their
                        collisions all together. This makes dynamic character controllers
                        able to interact with other physics objects seamlessly, as seen in
                        the platformer demo. However, these interactions are not always
                        predictable. Collisions can take more than one frame to be
                        solved, so a few collisions may seem to displace a tiny bit. Those
                        problems can be fixed, but require a certain amount of skill.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>A <strong>kinematic character controller</strong> is assumed to always begin in a
                        non-colliding state, and will always move to a non-colliding state.
                        If it starts in a colliding state, it will try to free itself like
                        rigid bodies do, but this is the exception, not the rule. This makes
                        their control and motion a lot more predictable and easier to
                        program. However, as a downside, they can't directly interact with
                        other physics objects, unless done by hand in code.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>This short tutorial focuses on the kinematic character controller.
                It uses the old-school way of handling collisions, which is not
                necessarily simpler under the hood, but well hidden and presented as an API.</paragraph>
        </section>
        <section ids="physics-process" names="physics\ process">
            <title>Physics process</title>
            <paragraph>To manage the logic of a kinematic body or character, it is always
                advised to use physics process, because it's called before physics step and its execution is
                in sync with physics server, also it is called the same amount of times
                per second, always. This makes physics and motion calculation work in a
                more predictable way than using regular process, which might have spikes
                or lose precision if the frame rate is too high or too low.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

func _physics_process(delta):
    pass</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody2D : CharacterBody2D
{
    public override void _PhysicsProcess(double delta)
    {
    }
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="scene-setup" names="scene\ setup">
            <title>Scene setup</title>
            <paragraph>To have something to test, here's the scene (from the tilemap tutorial):
                <reference name="kinematic_character_2d_starter.zip" refuri="https://github.com/godotengine/godot-docs-project-starters/releases/download/latest-4.x/kinematic_character_2d_starter.zip">kinematic_character_2d_starter.zip</reference><target ids="kinematic-character-2d-starter-zip" names="kinematic_character_2d_starter.zip" refuri="https://github.com/godotengine/godot-docs-project-starters/releases/download/latest-4.x/kinematic_character_2d_starter.zip"></target>.
                We'll be creating a new scene for the character. Use the robot sprite and
                create a scene like this:</paragraph>
            <image candidates="{'*': 'tutorials/physics/img/kbscene.webp'}" original_uri="img/kbscene.webp" uri="tutorials/physics/img/kbscene.webp"></image>
            <paragraph>You'll notice that there's a warning icon next to our CollisionShape2D node;
                that's because we haven't defined a shape for it. Create a new CircleShape2D
                in the shape property of CollisionShape2D. Click on &lt;CircleShape2D&gt; to go to the
                options for it, and set the radius to 30:</paragraph>
            <image candidates="{'*': 'tutorials/physics/img/kbradius.webp'}" original_uri="img/kbradius.webp" uri="tutorials/physics/img/kbradius.webp"></image>
            <paragraph><strong>Note: As mentioned before in the physics tutorial, the physics engine
                    can't handle scale on most types of shapes (only collision polygons,
                    planes and segments work), so always change the parameters (such as
                    radius) of the shape instead of scaling it. The same is also true for
                    the kinematic/rigid/static bodies themselves, as their scale affects the
                    shape scale.</strong></paragraph>
            <paragraph>Now, create a script for the character, the one used as an example
                above should work as a base.</paragraph>
            <paragraph>Finally, instance that character scene in the tilemap, and make the
                map scene the main one, so it runs when pressing play.</paragraph>
            <image candidates="{'*': 'tutorials/physics/img/kbinstance.webp'}" original_uri="img/kbinstance.webp" uri="tutorials/physics/img/kbinstance.webp"></image>
        </section>
        <section ids="moving-the-kinematic-character" names="moving\ the\ kinematic\ character">
            <title>Moving the kinematic character</title>
            <paragraph>Go back to the character scene, and open the script, the magic begins
                now! Kinematic body will do nothing by default, but it has a
                useful function called <literal>CharacterBody2D.move_and_collide()</literal>.
                This function takes a <reference internal="True" refuri="../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> as
                an argument, and tries to apply that motion to the kinematic body. If a
                collision happens, it stops right at the moment of the collision.</paragraph>
            <paragraph>So, let's move our sprite downwards until it hits the floor:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

func _physics_process(delta):
    move_and_collide(Vector2(0, 1)) # Move down 1 pixel per physics frame</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody2D : CharacterBody2D
{
    public override void _PhysicsProcess(double delta)
    {
        // Move down 1 pixel per physics frame
        MoveAndCollide(new Vector2(0, 1));
    }
}</literal_block>
                </div>
            </container>
            <paragraph>The result is that the character will move, but stop right when
                hitting the floor. Pretty cool, huh?</paragraph>
            <paragraph>The next step will be adding gravity to the mix, this way it behaves a
                little more like a regular game character:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

const GRAVITY = 200.0

func _physics_process(delta):
    velocity.y += delta * GRAVITY

    var motion = velocity * delta
    move_and_collide(motion)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody2D : CharacterBody2D
{
    private const float Gravity = 200.0f;

    public override void _PhysicsProcess(double delta)
    {
        var velocity = Velocity;
        velocity.Y += (float)delta * Gravity;
        Velocity = velocity;

        var motion = velocity * (float)delta;
        MoveAndCollide(motion);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>Now the character falls smoothly. Let's make it walk to the sides, left
                and right when touching the directional keys. Remember that the values
                being used (for speed at least) are pixels/second.</paragraph>
            <paragraph>This adds basic support for walking when pressing left and right:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

const GRAVITY = 200.0
const WALK_SPEED = 200

func _physics_process(delta):
    velocity.y += delta * GRAVITY

    if Input.is_action_pressed("ui_left"):
        velocity.x = -WALK_SPEED
    elif Input.is_action_pressed("ui_right"):
        velocity.x =  WALK_SPEED
    else:
        velocity.x = 0

    # "move_and_slide" already takes delta time into account.
    move_and_slide()</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody2D : CharacterBody2D
{
    private const float Gravity = 200.0f;
    private const int WalkSpeed = 200;

    public override void _PhysicsProcess(double delta)
    {
        var velocity = Velocity;

        velocity.Y += (float)delta * Gravity;

        if (Input.IsActionPressed("ui_left"))
        {
            velocity.X = -WalkSpeed;
        }
        else if (Input.IsActionPressed("ui_right"))
        {
            velocity.X = WalkSpeed;
        }
        else
        {
            velocity.X = 0;
        }

        Velocity = velocity;

        // "MoveAndSlide" already takes delta time into account.
        MoveAndSlide();
    }
}</literal_block>
                </div>
            </container>
            <paragraph>And give it a try.</paragraph>
            <paragraph>This is a good starting point for a platformer. A more complete demo can be found in the demo zip distributed with the
                engine, or in the
                <reference refuri="https://github.com/godotengine/godot-demo-projects/tree/master/2d/kinematic_character">https://github.com/godotengine/godot-demo-projects/tree/master/2d/kinematic_character</reference>.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
