<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/physics/physics_introduction.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-physics-introduction"></target>
    <section ids="physics-introduction doc-physics-introduction" names="physics\ introduction doc_physics_introduction">
        <title>Physics introduction</title>
        <paragraph>In game development, you often need to know when two objects in the game
            intersect or come into contact. This is known as <strong>collision detection</strong>.
            When a collision is detected, you typically want something to happen. This
            is known as <strong>collision response</strong>.</paragraph>
        <paragraph>Godot offers a number of collision objects in 2D and 3D to provide both collision detection
            and response. Trying to decide which one to use for your project can be confusing.
            You can avoid problems and simplify development if you understand how each works
            and what their pros and cons are.</paragraph>
        <paragraph>In this guide, you will learn:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>Godot's four collision object types</paragraph>
            </list_item>
            <list_item>
                <paragraph>How each collision object works</paragraph>
            </list_item>
            <list_item>
                <paragraph>When and why to choose one type over another</paragraph>
            </list_item>
        </bullet_list>
        <note>
            <paragraph>This document's examples will use 2D objects. Every 2D physics object
                and collision shape has a direct equivalent in 3D and in most cases
                they work in much the same way.</paragraph>
        </note>
        <section ids="collision-objects" names="collision\ objects">
            <title>Collision objects</title>
            <paragraph>Godot offers four kinds of collision objects which all extend <reference internal="True" refuri="../../classes/class_collisionobject2d#class-collisionobject2d"><inline classes="std std-ref">CollisionObject2D</inline></reference>.
                The last three listed below are physics bodies and additionally extend <reference internal="True" refuri="../../classes/class_physicsbody2d#class-physicsbody2d"><inline classes="std std-ref">PhysicsBody2D</inline></reference>.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term><reference internal="True" refuri="../../classes/class_area2d#class-area2d"><inline classes="std std-ref">Area2D</inline></reference></term>
                            <definition>
                                <paragraph><literal>Area2D</literal> nodes provide <strong>detection</strong> and <strong>influence</strong>. They can detect when
                                    objects overlap and can emit signals when bodies enter or exit. An <literal>Area2D</literal>
                                    can also be used to override physics properties, such as gravity or damping,
                                    in a defined area.</paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term><reference internal="True" refuri="../../classes/class_staticbody2d#class-staticbody2d"><inline classes="std std-ref">StaticBody2D</inline></reference></term>
                            <definition>
                                <paragraph>A static body is one that is not moved by the physics engine. It participates
                                    in collision detection, but does not move in response to the collision. They
                                    are most often used for objects that are part of the environment or that do
                                    not need to have any dynamic behavior.</paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term><reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d"><inline classes="std std-ref">RigidBody2D</inline></reference></term>
                            <definition>
                                <paragraph>This is the node that implements simulated 2D physics. You do not control a
                                    <literal>RigidBody2D</literal> directly, but instead you apply forces to it (gravity, impulses,
                                    etc.) and the physics engine calculates the resulting movement.
                                    <reference internal="True" refuri="rigid_body#doc-rigid-body"><inline classes="std std-ref">Read more about using rigid bodies.</inline></reference></paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term><reference internal="True" refuri="../../classes/class_characterbody2d#class-characterbody2d"><inline classes="std std-ref">CharacterBody2D</inline></reference></term>
                            <definition>
                                <paragraph>A body that provides collision detection, but no physics. All movement and
                                    collision response must be implemented in code.</paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
            </bullet_list>
            <section ids="physics-material" names="physics\ material">
                <title>Physics material</title>
                <paragraph>Static bodies and rigid bodies can be configured to use a <reference internal="True" refuri="../../classes/class_physicsmaterial#class-physicsmaterial"><inline classes="std std-ref">PhysicsMaterial</inline></reference>. This allows adjusting the friction and bounce of an object,
                    and set if it's absorbent and/or rough.</paragraph>
            </section>
            <section ids="collision-shapes" names="collision\ shapes">
                <title>Collision shapes</title>
                <paragraph>A physics body can hold any number of <reference internal="True" refuri="../../classes/class_shape2d#class-shape2d"><inline classes="std std-ref">Shape2D</inline></reference> objects
                    as children. These shapes are used to define the object's collision bounds
                    and to detect contact with other objects.</paragraph>
                <note>
                    <paragraph>In order to detect collisions, at least one <literal>Shape2D</literal> must be
                        assigned to the object.</paragraph>
                </note>
                <paragraph>The most common way to assign a shape is by adding a <reference internal="True" refuri="../../classes/class_collisionshape2d#class-collisionshape2d"><inline classes="std std-ref">CollisionShape2D</inline></reference>
                    or <reference internal="True" refuri="../../classes/class_collisionpolygon2d#class-collisionpolygon2d"><inline classes="std std-ref">CollisionPolygon2D</inline></reference> as a child of the object.
                    These nodes allow you to draw the shape directly in the editor workspace.</paragraph>
                <important>
                    <paragraph>Be careful to never scale your collision shapes in the editor.
                        The "Scale" property in the Inspector should remain <literal>(1, 1)</literal>. When changing
                        the size of the collision shape, you should always use the size handles, <strong>not</strong>
                        the <literal>Node2D</literal> scale handles. Scaling a shape can result in unexpected
                        collision behavior.</paragraph>
                </important>
                <image candidates="{'*': 'tutorials/physics/img/player_coll_shape.webp'}" original_uri="img/player_coll_shape.webp" uri="tutorials/physics/img/player_coll_shape.webp"></image>
            </section>
            <section ids="physics-process-callback" names="physics\ process\ callback">
                <title>Physics process callback</title>
                <paragraph>The physics engine runs at a fixed rate (a default of 60 iterations per second). This rate
                    is typically different from the frame rate which fluctuates based on what is rendered and
                    available resources.</paragraph>
                <paragraph>It is important that all physics related code runs at this fixed rate. Therefore Godot
                    differentiates <reference internal="True" refuri="../scripting/idle_and_physics_processing#doc-idle-and-physics-processing"><inline classes="std std-ref">between physics and idle processing</inline></reference>.
                    Code that runs each frame is called idle processing and code that runs on each physics
                    tick is called physics processing. Godot provides two different callbacks, one for each
                    of those processing rates.</paragraph>
                <paragraph>The physics callback, <reference internal="True" refuri="../../classes/class_node#class-node-private-method-physics-process"><inline classes="std std-ref">Node._physics_process()</inline></reference>,
                    is called before each physics step. Any code that needs to access a body's properties should
                    be run in here. This method will be passed a <literal>delta</literal>
                    parameter, which is a floating-point number equal to the time passed in
                    <emphasis>seconds</emphasis> since the last step. When using the default 60 Hz physics update rate,
                    it will typically be equal to <literal>0.01666...</literal> (but not always, see below).</paragraph>
                <note>
                    <paragraph>It's recommended to always use the <literal>delta</literal> parameter when relevant in your
                        physics calculations, so that the game behaves correctly if you change the
                        physics update rate or if the player's device can't keep up.</paragraph>
                </note>
                <target refid="doc-physics-introduction-collision-layers-and-masks"></target>
            </section>
            <section ids="collision-layers-and-masks doc-physics-introduction-collision-layers-and-masks" names="collision\ layers\ and\ masks doc_physics_introduction_collision_layers_and_masks">
                <title>Collision layers and masks</title>
                <paragraph>One of the most powerful, but frequently misunderstood, collision features
                    is the collision layer system. This system allows you to build up complex
                    interactions between a variety of objects. The key concepts are <strong>layers</strong>
                    and <strong>masks</strong>. Each <literal>CollisionObject2D</literal> has 32 different physics layers
                    it can interact with.</paragraph>
                <paragraph>Let's look at each of the properties in turn:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <definition_list>
                            <definition_list_item>
                                <term>collision_layer</term>
                                <definition>
                                    <paragraph>This describes the layers that the object appears <strong>in</strong>. By default, all
                                        bodies are on layer <literal>1</literal>.</paragraph>
                                </definition>
                            </definition_list_item>
                        </definition_list>
                    </list_item>
                    <list_item>
                        <definition_list>
                            <definition_list_item>
                                <term>collision_mask</term>
                                <definition>
                                    <paragraph>This describes what layers the body will <strong>scan</strong> for collisions. If an
                                        object isn't in one of the mask layers, the body will ignore it. By default,
                                        all bodies scan layer <literal>1</literal>.</paragraph>
                                </definition>
                            </definition_list_item>
                        </definition_list>
                    </list_item>
                </bullet_list>
                <paragraph>These properties can be configured via code, or by editing them in the Inspector.</paragraph>
                <paragraph>Keeping track of what you're using each layer for can be difficult, so you
                    may find it useful to assign names to the layers you're using. Names can
                    be assigned in <strong>Project Settings &gt; Layer Names &gt; 2D Physics</strong>.</paragraph>
                <image candidates="{'*': 'tutorials/physics/img/physics_layer_names.webp'}" original_uri="img/physics_layer_names.webp" uri="tutorials/physics/img/physics_layer_names.webp"></image>
                <section ids="gui-example" names="gui\ example">
                    <title>GUI example</title>
                    <paragraph>You have four node types in your game: Walls, Player, Enemy, and Coin. Both
                        Player and Enemy should collide with Walls. The Player node should detect
                        collisions with both Enemy and Coin, but Enemy and Coin should ignore each
                        other.</paragraph>
                    <paragraph>Start by naming layers 1-4 "walls", "player", "enemies", and "coins" and
                        place each node type in its respective layer using the "Layer" property.
                        Then set each node's "Mask" property by selecting the layers it should
                        interact with. For example, the Player's settings would look like this:</paragraph>
                    <image candidates="{'*': 'tutorials/physics/img/player_collision_layers.webp'}" original_uri="img/player_collision_layers.webp" uri="tutorials/physics/img/player_collision_layers.webp"></image>
                    <image candidates="{'*': 'tutorials/physics/img/player_collision_mask.webp'}" original_uri="img/player_collision_mask.webp" uri="tutorials/physics/img/player_collision_mask.webp"></image>
                    <target refid="doc-physics-introduction-collision-layer-code-example"></target>
                </section>
                <section ids="code-example doc-physics-introduction-collision-layer-code-example" names="code\ example doc_physics_introduction_collision_layer_code_example">
                    <title>Code example</title>
                    <paragraph>In function calls, layers are specified as a bitmask. Where a function enables
                        all layers by default, the layer mask will be given as <literal>0xffffffff</literal>. Your code
                        can use binary, hexadecimal, or decimal notation for layer masks, depending
                        on your preference.</paragraph>
                    <paragraph>The code equivalent of the above example where layers 1, 3 and 4 were enabled
                        would be as follows:</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Example: Setting mask value for enabling layers 1, 3 and 4

# Binary - set the bit corresponding to the layers you want to enable (1, 3, and 4) to 1, set all other bits to 0.
# Note: Layer 32 is the first bit, layer 1 is the last. The mask for layers 4, 3 and 1 is therefore:
0b00000000_00000000_00000000_00001101
# (This can be shortened to 0b1101)

# Hexadecimal equivalent (1101 binary converted to hexadecimal).
0x000d
# (This value can be shortened to 0xd.)

# Decimal - Add the results of 2 to the power of (layer to be enabled - 1).
# (2^(1-1)) + (2^(3-1)) + (2^(4-1)) = 1 + 4 + 8 = 13
#
# We can use the `&lt;&lt;` operator to shift the bit to the left by the layer number we want to enable.
# This is a faster way to multiply by powers of 2 than `pow()`.
# Additionally, we use the `|` (binary OR) operator to combine the results of each layer.
# This ensures we don't add the same layer multiple times, which would behave incorrectly.
(1 &lt;&lt; 1 - 1) | (1 &lt;&lt; 3 - 1) | (1 &lt;&lt; 4 - 1)

# The above can alternatively be written as:
# pow(2, 1 - 1) + pow(2, 3 - 1) + pow(2, 4 - 1)</literal_block>
                    <paragraph>You can also set bits independently by calling <literal>set_collision_layer_value(layer_number, value)</literal>
                        or <literal>set_collision_mask_value(layer_number, value)</literal> on any given <reference internal="True" refuri="../../classes/class_collisionobject2d#class-collisionobject2d"><inline classes="std std-ref">CollisionObject2D</inline></reference> as follows:</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Example: Setting mask value to enable layers 1, 3, and 4.

var collider: CollisionObject2D = $CollisionObject2D  # Any given collider.
collider.set_collision_mask_value(1, true)
collider.set_collision_mask_value(3, true)
collider.set_collision_mask_value(4, true)</literal_block>
                    <paragraph>Export annotations can be used to export bitmasks in the editor with a user-friendly GUI:</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@export_flags_2d_physics var layers_2d_physics</literal_block>
                    <paragraph>Additional export annotations are available for render and navigation layers, in both 2D and 3D. See <reference internal="True" refuri="../scripting/gdscript/gdscript_exports#doc-gdscript-exports-exporting-bit-flags"><inline classes="std std-ref">Exporting bit flags</inline></reference>.</paragraph>
                </section>
            </section>
        </section>
        <section ids="area2d" names="area2d">
            <title>Area2D</title>
            <paragraph>Area nodes provide <strong>detection</strong> and <strong>influence</strong>. They can detect when
                objects overlap and emit signals when bodies enter or exit. Areas can also
                be used to override physics properties, such as gravity or damping, in a
                defined area.</paragraph>
            <paragraph>There are three main uses for <reference internal="True" refuri="../../classes/class_area2d#class-area2d"><inline classes="std std-ref">Area2D</inline></reference>:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Overriding physics parameters (such as gravity) in a given region.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Detecting when other bodies enter or exit a region or what bodies are currently in a region.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Checking other areas for overlap.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>By default, areas also receive mouse and touchscreen input.</paragraph>
        </section>
        <section ids="staticbody2d" names="staticbody2d">
            <title>StaticBody2D</title>
            <paragraph>A static body is one that is not moved by the physics engine. It participates
                in collision detection, but does not move in response to the collision. However,
                it can impart motion or rotation to a colliding body <strong>as if</strong> it were moving,
                using its <literal>constant_linear_velocity</literal> and <literal>constant_angular_velocity</literal> properties.</paragraph>
            <paragraph><literal>StaticBody2D</literal> nodes are most often used for objects that are part of the environment
                or that do not need to have any dynamic behavior.</paragraph>
            <paragraph>Example uses for <literal>StaticBody2D</literal>:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Platforms (including moving platforms)</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Conveyor belts</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Walls and other obstacles</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="rigidbody2d" names="rigidbody2d">
            <title>RigidBody2D</title>
            <paragraph>This is the node that implements simulated 2D physics. You do not control a
                <reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d"><inline classes="std std-ref">RigidBody2D</inline></reference> directly. Instead, you apply forces
                to it and the physics engine calculates the resulting movement, including
                collisions with other bodies, and collision responses, such as bouncing,
                rotating, etc.</paragraph>
            <paragraph>You can modify a rigid body's behavior via properties such as "Mass",
                "Friction", or "Bounce", which can be set in the Inspector.</paragraph>
            <paragraph>The body's behavior is also affected by the world's properties, as set in
                <strong>Project Settings &gt; Physics</strong>, or by entering an <reference internal="True" refuri="../../classes/class_area2d#class-area2d"><inline classes="std std-ref">Area2D</inline></reference>
                that is overriding the global physics properties.</paragraph>
            <paragraph>When a rigid body is at rest and hasn't moved for a while, it goes to sleep.
                A sleeping body acts like a static body, and its forces are not calculated by
                the physics engine. The body will wake up when forces are applied, either by
                a collision or via code.</paragraph>
            <section ids="using-rigidbody2d" names="using\ rigidbody2d">
                <title>Using RigidBody2D</title>
                <paragraph>One of the benefits of using a rigid body is that a lot of behavior can be had
                    "for free" without writing any code. For example, if you were making an
                    "Angry Birds"-style game with falling blocks, you would only need to create
                    RigidBody2Ds and adjust their properties. Stacking, falling, and bouncing would
                    automatically be calculated by the physics engine.</paragraph>
                <paragraph>However, if you do wish to have some control over the body, you should take
                    care - altering the <literal>position</literal>, <literal>linear_velocity</literal>, or other physics properties
                    of a rigid body can result in unexpected behavior. If you need to alter any
                    of the physics-related properties, you should use the <reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d-private-method-integrate-forces"><inline classes="std std-ref">_integrate_forces()</inline></reference>
                    callback instead of <literal>_physics_process()</literal>. In this callback, you have access
                    to the body's <reference internal="True" refuri="../../classes/class_physicsdirectbodystate2d#class-physicsdirectbodystate2d"><inline classes="std std-ref">PhysicsDirectBodyState2D</inline></reference>,
                    which allows for safely changing properties and synchronizing them with
                    the physics engine.</paragraph>
                <paragraph>For example, here is the code for an "Asteroids" style spaceship:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends RigidBody2D

var thrust = Vector2(0, -250)
var torque = 20000

func _integrate_forces(state):
    if Input.is_action_pressed("ui_up"):
        state.apply_force(thrust.rotated(rotation))
    else:
        state.apply_force(Vector2())
    var rotation_direction = 0
    if Input.is_action_pressed("ui_right"):
        rotation_direction += 1
    if Input.is_action_pressed("ui_left"):
        rotation_direction -= 1
    state.apply_torque(rotation_direction * torque)</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Spaceship : RigidBody2D
{
    private Vector2 _thrust = new Vector2(0, -250);
    private float _torque = 20000;

    public override void _IntegrateForces(PhysicsDirectBodyState2D state)
    {
        if (Input.IsActionPressed("ui_up"))
        {
            state.ApplyForce(_thrust.Rotated(Rotation));
        }
        else
        {
            state.ApplyForce(new Vector2());
        }

        var rotationDir = 0;
        if (Input.IsActionPressed("ui_right"))
        {
            rotationDir += 1;
        }
        if (Input.IsActionPressed("ui_left"))
        {
            rotationDir -= 1;
        }
        state.ApplyTorque(rotationDir * _torque);
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>Note that we are not setting the <literal>linear_velocity</literal> or <literal>angular_velocity</literal>
                    properties directly, but rather applying forces (<literal>thrust</literal> and <literal>torque</literal>) to
                    the body and letting the physics engine calculate the resulting movement.</paragraph>
                <note>
                    <paragraph>When a rigid body goes to sleep, the <literal>_integrate_forces()</literal>
                        function will not be called. To override this behavior, you will
                        need to keep the body awake by creating a collision, applying a
                        force to it, or by disabling the <reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d-property-can-sleep"><inline classes="std std-ref">can_sleep</inline></reference>
                        property. Be aware that this can have a negative effect on performance.</paragraph>
                </note>
            </section>
            <section ids="contact-reporting" names="contact\ reporting">
                <title>Contact reporting</title>
                <paragraph>By default, rigid bodies do not keep track of contacts, because this can
                    require a huge amount of memory if many bodies are in the scene. To enable
                    contact reporting, set the <reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d-property-max-contacts-reported"><inline classes="std std-ref">max_contacts_reported</inline></reference>
                    property to a non-zero value. The contacts can then be obtained via
                    <reference internal="True" refuri="../../classes/class_physicsdirectbodystate2d#class-physicsdirectbodystate2d-method-get-contact-count"><inline classes="std std-ref">PhysicsDirectBodyState2D.get_contact_count()</inline></reference>
                    and related functions.</paragraph>
                <paragraph>Contact monitoring via signals can be enabled via the <reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d-property-contact-monitor"><inline classes="std std-ref">contact_monitor</inline></reference>
                    property. See <reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d"><inline classes="std std-ref">RigidBody2D</inline></reference> for the list of available
                    signals.</paragraph>
            </section>
        </section>
        <section ids="characterbody2d" names="characterbody2d">
            <title>CharacterBody2D</title>
            <paragraph><reference internal="True" refuri="../../classes/class_characterbody2d#class-characterbody2d"><inline classes="std std-ref">CharacterBody2D</inline></reference> bodies detect collisions with
                other bodies, but are not affected by physics properties like gravity or friction.
                Instead, they must be controlled by the user via code. The physics engine will
                not move a character body.</paragraph>
            <paragraph>When moving a character body, you should not set its <literal>position</literal> directly.
                Instead, you use the <literal>move_and_collide()</literal> or <literal>move_and_slide()</literal> methods.
                These methods move the body along a given vector, and it will instantly stop
                if a collision is detected with another body. After the body has collided,
                any collision response must be coded manually.</paragraph>
            <section ids="character-collision-response" names="character\ collision\ response">
                <title>Character collision response</title>
                <paragraph>After a collision, you may want the body to bounce, to slide along a wall,
                    or to alter the properties of the object it hit. The way you handle collision
                    response depends on which method you used to move the CharacterBody2D.</paragraph>
                <section ids="move-and-collide" names="move_and_collide">
                    <title><reference internal="True" refuri="../../classes/class_physicsbody2d#class-physicsbody2d-method-move-and-collide"><inline classes="std std-ref">move_and_collide</inline></reference></title>
                    <paragraph>When using <literal>move_and_collide()</literal>, the function returns a
                        <reference internal="True" refuri="../../classes/class_kinematiccollision2d#class-kinematiccollision2d"><inline classes="std std-ref">KinematicCollision2D</inline></reference> object, which contains
                        information about the collision and the colliding body. You can use this
                        information to determine the response.</paragraph>
                    <paragraph>For example, if you want to find the point in space where the collision
                        occurred:</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                        </div>
                        <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends PhysicsBody2D

var velocity = Vector2(250, 250)

func _physics_process(delta):
    var collision_info = move_and_collide(velocity * delta)
    if collision_info:
        var collision_point = collision_info.get_position()</literal_block>
                        </div>
                        <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Body : PhysicsBody2D
{
    private Vector2 _velocity = new Vector2(250, 250);

    public override void _PhysicsProcess(double delta)
    {
        var collisionInfo = MoveAndCollide(_velocity * (float)delta);
        if (collisionInfo != null)
        {
            var collisionPoint = collisionInfo.GetPosition();
        }
    }
}</literal_block>
                        </div>
                    </container>
                    <paragraph>Or to bounce off of the colliding object:</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                        </div>
                        <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends PhysicsBody2D

var velocity = Vector2(250, 250)

func _physics_process(delta):
    var collision_info = move_and_collide(velocity * delta)
    if collision_info:
        velocity = velocity.bounce(collision_info.get_normal())</literal_block>
                        </div>
                        <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Body : PhysicsBody2D
{
    private Vector2 _velocity = new Vector2(250, 250);

    public override void _PhysicsProcess(double delta)
    {
        var collisionInfo = MoveAndCollide(_velocity * (float)delta);
        if (collisionInfo != null)
        {
            _velocity = _velocity.Bounce(collisionInfo.GetNormal());
        }
    }
}</literal_block>
                        </div>
                    </container>
                </section>
                <section ids="move-and-slide" names="move_and_slide">
                    <title><reference internal="True" refuri="../../classes/class_characterbody2d#class-characterbody2d-method-move-and-slide"><inline classes="std std-ref">move_and_slide</inline></reference></title>
                    <paragraph>Sliding is a common collision response; imagine a player moving along walls
                        in a top-down game or running up and down slopes in a platformer. While it's
                        possible to code this response yourself after using <literal>move_and_collide()</literal>,
                        <literal>move_and_slide()</literal> provides a convenient way to implement sliding movement
                        without writing much code.</paragraph>
                    <warning>
                        <paragraph><literal>move_and_slide()</literal> automatically includes the timestep in its
                            calculation, so you should <strong>not</strong> multiply the velocity vector
                            by <literal>delta</literal>. This does <strong>not</strong> apply to <literal>gravity</literal> as it is an
                            acceleration and is time dependent, and needs to be scaled by
                            <literal>delta</literal>.</paragraph>
                    </warning>
                    <paragraph>For example, use the following code to make a character that can walk along
                        the ground (including slopes) and jump when standing on the ground:</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                        </div>
                        <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var run_speed = 350
var jump_speed = -1000
var gravity = 2500

func get_input():
    velocity.x = 0
    var right = Input.is_action_pressed('ui_right')
    var left = Input.is_action_pressed('ui_left')
    var jump = Input.is_action_just_pressed('ui_select')

    if is_on_floor() and jump:
        velocity.y = jump_speed
    if right:
        velocity.x += run_speed
    if left:
        velocity.x -= run_speed

func _physics_process(delta):
    velocity.y += gravity * delta
    get_input()
    move_and_slide()</literal_block>
                        </div>
                        <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Body : CharacterBody2D
{
    private float _runSpeed = 350;
    private float _jumpSpeed = -1000;
    private float _gravity = 2500;

    private void GetInput()
    {
        var velocity = Velocity;
        velocity.X = 0;

        var right = Input.IsActionPressed("ui_right");
        var left = Input.IsActionPressed("ui_left");
        var jump = Input.IsActionPressed("ui_select");

        if (IsOnFloor() &amp;&amp; jump)
        {
            velocity.Y = _jumpSpeed;
        }
        if (right)
        {
            velocity.X += _runSpeed;
        }
        if (left)
        {
            velocity.X -= _runSpeed;
        }

        Velocity = velocity;
    }

    public override void _PhysicsProcess(double delta)
    {
        var velocity = Velocity;
        velocity.Y += _gravity * (float)delta;
        Velocity = velocity;
        GetInput();
        MoveAndSlide();
    }
}</literal_block>
                        </div>
                    </container>
                    <paragraph>See <reference internal="True" refuri="kinematic_character_2d#doc-kinematic-character-2d"><inline classes="std std-ref">Kinematic character (2D)</inline></reference> for more details on using <literal>move_and_slide()</literal>,
                        including a demo project with detailed code.</paragraph>
                    <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
                </section>
            </section>
        </section>
    </section>
</document>
