<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/physics/physics_introduction.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-physics-introduction"></target>
    <section ids="physics-introduction doc-physics-introduction" names="physics\ introduction 物理介绍 doc_physics_introduction">
        <title>物理介绍</title>
        <paragraph>在游戏开发中, 你经常需要知道游戏中的两个对象在何时相交或接触. 这被称为 <strong>碰撞检测</strong> . 检测到碰撞时, 你通常希望某些事情发生. 这被称为 <strong>碰撞响应</strong> .</paragraph>
        <paragraph>Godot在2D和3D中提供了许多碰撞对象, 以提供碰撞检测和响应. 你可能很难决定哪个适合你的项目. 一旦了解了每种方法的工作原理以及它们的优缺点, 你就可以避免出现问题并简化开发过程.</paragraph>
        <paragraph>在本指南中，你将学会：</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>Godot的四种碰撞对象类型</paragraph>
            </list_item>
            <list_item>
                <paragraph>每个碰撞对象的工作原理</paragraph>
            </list_item>
            <list_item>
                <paragraph>何时以及为何选择这种类型而不是另一种类型</paragraph>
            </list_item>
        </bullet_list>
        <note>
            <paragraph>本文档的示例将使用2D对象. 每个2D物理对象和碰撞形状在3D中具有直接等价物, 并且在大多数情况下它们以相同的方式工作.</paragraph>
        </note>
        <section ids="collision-objects" names="collision\ objects 碰撞物体">
            <title>碰撞物体</title>
            <paragraph>Godot 提供了四种碰撞对象，它们都继承自 <reference internal="True" refuri="../../classes/class_collisionobject2d#class-collisionobject2d"><inline classes="std std-ref">CollisionObject2D</inline></reference>。 下面列出的最后三种是物理物体，此外还继承了 <reference internal="True" refuri="../../classes/class_physicsbody2d#class-physicsbody2d"><inline classes="std std-ref">PhysicsBody2D</inline></reference>。</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term><reference internal="True" refuri="../../classes/class_area2d#class-area2d"><inline classes="std std-ref">Area2D</inline></reference></term>
                            <definition>
                                <paragraph><literal>Area2D</literal> 节点提供 <strong>检测</strong> 和 <strong>影响</strong> . 它们可以检测物体何时重叠, 并在物体进入或离开时发出信号. <literal>Area2D</literal> 也可用于覆盖物理属性, 例如一定区域内的重力或阻尼.</paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term><reference internal="True" refuri="../../classes/class_staticbody2d#class-staticbody2d"><inline classes="std std-ref">StaticBody2D</inline></reference></term>
                            <definition>
                                <paragraph>静态主体是物理引擎不移动的主体. 它参与碰撞检测, 但不会响应碰撞而移动. 它们通常用于属于环境的对象或不需要任何动态行为的对象.</paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term><reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d"><inline classes="std std-ref">RigidBody2D</inline></reference></term>
                            <definition>
                                <paragraph>这是实现模拟2D物理的节点. 你不直接控制 <literal>RigidBody2D</literal> , 而是你对它施加力(重力, 冲动等), 物理引擎计算得到的运动. <reference internal="True" refuri="rigid_body#doc-rigid-body"><inline classes="std std-ref">阅读更多关于使用刚体的信息.</inline></reference></paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term><reference internal="True" refuri="../../classes/class_characterbody2d#class-characterbody2d"><inline classes="std std-ref">CharacterBody2D</inline></reference></term>
                            <definition>
                                <paragraph>提供碰撞检测的物体, 但没有物理特性. 所有移动和碰撞响应必须在代码中实现.</paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
            </bullet_list>
            <section ids="physics-material" names="physics\ material 物理材质">
                <title>物理材质</title>
                <paragraph>静态体和刚性体可以配置为使用 <reference internal="True" refuri="../../classes/class_physicsmaterial#class-physicsmaterial"><inline classes="std std-ref">物理材质</inline></reference> 。这允许调整物体的摩擦和弹性，并设置是否具有吸收性、粗糙性。</paragraph>
            </section>
            <section ids="collision-shapes" names="collision\ shapes 碰撞形状">
                <title>碰撞形状</title>
                <paragraph>物理体可以包含任意数量的 <reference internal="True" refuri="../../classes/class_shape2d#class-shape2d"><inline classes="std std-ref">Shape2D</inline></reference> 对象作为子对象. 这些形状用于定义对象的碰撞边界并检测与其他对象的接触.</paragraph>
                <note>
                    <paragraph>为了检测碰撞, 必须至少为对象分配一个 <literal>Shape2D</literal> .</paragraph>
                </note>
                <paragraph>分配形状的最常用方法是添加 <reference internal="True" refuri="../../classes/class_collisionshape2d#class-collisionshape2d"><inline classes="std std-ref">CollisionShape2D</inline></reference> 或 <reference internal="True" refuri="../../classes/class_collisionpolygon2d#class-collisionpolygon2d"><inline classes="std std-ref">CollisionPolygon2D</inline></reference> 作为对象的子项. 这些节点允许你直接在编辑器工作区中绘制形状.</paragraph>
                <important>
                    <paragraph>注意，不要在编辑器中缩放碰撞形状。“检查器”中的“Scale”属性应保持为 <literal>(1, 1)</literal>。改变碰撞形状的大小时，你应该使用尺寸控制柄，而<strong>不是</strong> <literal>Node2D</literal> 缩放控制柄。缩放形状可能会导致意外的碰撞行为。</paragraph>
                </important>
                <image candidates="{'*': 'tutorials/physics/img/player_coll_shape.png'}" uri="tutorials/physics/img/player_coll_shape.png"></image>
            </section>
            <section ids="physics-process-callback" names="physics\ process\ callback 物理过程回调">
                <title>物理过程回调</title>
                <paragraph>物理引擎以固定的速率运行（默认为每秒60次迭代）。这个速率通常与帧率不同，帧率会根据渲染内容和可用资源而波动。</paragraph>
                <paragraph>所有与物理相关的代码都必须以这个固定速率运行。因此，Godot 区分了 <reference internal="True" refuri="../scripting/idle_and_physics_processing#doc-idle-and-physics-processing"><inline classes="std std-ref">空闲处理与物理处理</inline></reference>. 每帧运行的代码称为空闲处理，而每个物理周期运行的代码称为物理处理。Godot 提供了两个不同的回调函数，分别用于这两种处理速率。</paragraph>
                <paragraph>物理回调函数 <inline classes="xref std std-ref">Node._physics_process()</inline> 在每个物理步骤之前被调用。任何需要访问物体属性的代码都应该在这个函数里运行。该方法将传递一个名为 <literal>delta</literal> 的参数，它是一个浮点数，表示自上一步以来经过的 <emphasis>秒数</emphasis> 。当使用默认的 60 Hz 物理更新速率时，它通常等于 <literal>0.01666...</literal> （但并不总是，详见下文）。</paragraph>
                <note>
                    <paragraph>建议在物理计算中使用 <literal>delta</literal> 参数, 以便当你更改物理更新速率或玩家设备跟不上时, 游戏能够正确运行.</paragraph>
                </note>
                <target refid="doc-physics-introduction-collision-layers-and-masks"></target>
            </section>
            <section ids="collision-layers-and-masks doc-physics-introduction-collision-layers-and-masks" names="collision\ layers\ and\ masks 碰撞层与遮罩 doc_physics_introduction_collision_layers_and_masks">
                <title>碰撞层与遮罩</title>
                <paragraph>One of the most powerful, but frequently misunderstood, collision features
                    is the collision layer system. This system allows you to build up complex
                    interactions between a variety of objects. The key concepts are <strong>layers</strong>
                    and <strong>masks</strong>. Each <literal>CollisionObject2D</literal> has 32 different physics layers
                    it can interact with.</paragraph>
                <paragraph>让我们依次看看每个属性：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <definition_list>
                            <definition_list_item>
                                <term>collision_layer</term>
                                <definition>
                                    <paragraph>表示该对象<strong>位于</strong>哪些层。默认情况下，所有实体都在图层 <literal>1</literal> 上。</paragraph>
                                </definition>
                            </definition_list_item>
                        </definition_list>
                    </list_item>
                    <list_item>
                        <definition_list>
                            <definition_list_item>
                                <term>collision_mask</term>
                                <definition>
                                    <paragraph>表示该对象会对哪些层上的实体进行<strong>扫描</strong>。如果对象不在任何遮罩层中，则该实体将其忽略。默认情况下，所有实体都会扫描图层 <literal>1</literal>。</paragraph>
                                </definition>
                            </definition_list_item>
                        </definition_list>
                    </list_item>
                </bullet_list>
                <paragraph>可以通过代码配置这些属性，也可以在“检查器”中对其进行编辑。</paragraph>
                <paragraph>跟踪你正在使用每个图层的内容可能很困难，因此你可能会发现为你正在使用的图层指定名称很有用。可以在“项目设置 -&gt; Layer Names”中指定名称。</paragraph>
                <image candidates="{'*': 'tutorials/physics/img/physics_layer_names.png'}" uri="tutorials/physics/img/physics_layer_names.png"></image>
                <section ids="gui-example" names="gui\ example 图形用户界面示例">
                    <title>图形用户界面示例</title>
                    <paragraph>游戏中有四种节点类型：墙（Wall）、玩家（Player）、敌人（Enemy）、金币（Coin）。玩家和敌人都应该与墙碰撞。玩家节点应该检测与敌人和硬币的碰撞，但敌人和硬币应该互相忽略。</paragraph>
                    <paragraph>首先将 1 至 4 层分别命名为“walls”（墙）“player”（玩家）“enemies”（敌人）“coins”（金币）并使用“Layer”属性将每个节点类型放在其各自的层中。然后通过选择它应该与之互动的层来设置每个节点的“Mash”属性。例如，玩家的设置将看起来像这样：</paragraph>
                    <image candidates="{'*': 'tutorials/physics/img/player_collision_layers.png'}" uri="tutorials/physics/img/player_collision_layers.png"></image>
                    <image candidates="{'*': 'tutorials/physics/img/player_collision_mask.png'}" uri="tutorials/physics/img/player_collision_mask.png"></image>
                    <target refid="doc-physics-introduction-collision-layer-code-example"></target>
                </section>
                <section ids="code-example doc-physics-introduction-collision-layer-code-example" names="code\ example 代码示例 doc_physics_introduction_collision_layer_code_example">
                    <title>代码示例</title>
                    <paragraph>In function calls, layers are specified as a bitmask. Where a function enables
                        all layers by default, the layer mask will be given as <literal>0xffffffff</literal>. Your code
                        can use binary, hexadecimal, or decimal notation for layer masks, depending
                        on your preference.</paragraph>
                    <paragraph>如果要用代码来启用第 1、3、4 层：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Example: Setting mask value for enabling layers 1, 3 and 4

# Binary - set the bit corresponding to the layers you want to enable (1, 3, and 4) to 1, set all other bits to 0.
# Note: Layer 32 is the first bit, layer 1 is the last. The mask for layers 4,3 and 1 is therefore
0b00000000_00000000_00000000_00001101
# (This can be shortened to 0b1101)

# Hexadecimal equivalent (1101 binary converted to hexadecimal)
0x000d
# (This value can be shortened to 0xd)

# Decimal - Add the results of 2 to the power of (layer to be enabled - 1).
# (2^(1-1)) + (2^(3-1)) + (2^(4-1)) = 1 + 4 + 8 = 13
pow(2, 1-1) + pow(2, 3-1) + pow(2, 4-1)</literal_block>
                </section>
            </section>
        </section>
        <section ids="area2d" names="area2d">
            <title>Area2D</title>
            <paragraph>Area 节点的作用是<strong>检测</strong>和<strong>影响</strong>。它们可以检测物体何时重叠，并在物体进入或离开时发出信号。Area 也可用于覆盖物理属性，例如一定区域内的重力或阻尼。</paragraph>
            <paragraph><reference internal="True" refuri="../../classes/class_area2d#class-area2d"><inline classes="std std-ref">Area2D</inline></reference> 的主要用途有三种：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>覆盖给定区域中的物理参数（例如重力）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>检测其他实体何时进入或退出某个区域或当前哪个实体位于某个区域。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>检查是否与其他区域重叠。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>默认情况下,area还会接收鼠标和触摸屏输入.</paragraph>
        </section>
        <section ids="staticbody2d" names="staticbody2d">
            <title>StaticBody2D</title>
            <paragraph>静态主体是物理引擎不移动的主体. 它参与碰撞检测, 但不会响应碰撞而移动. 然而, 它可以使用它的 <literal>constant_linear_velocity</literal> 和 <literal>constant_angular_velocity</literal> 属性将运动或旋转传递给碰撞体, <strong>好像</strong> 它正在移动一样.</paragraph>
            <paragraph><literal>StaticBody2D</literal> 节点最常用于属于环境的对象或不需要任何动态行为的对象.</paragraph>
            <paragraph><literal>StaticBody2D</literal> 的示例用法：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>平台（包括可移动的平台）</paragraph>
                </list_item>
                <list_item>
                    <paragraph>输送带</paragraph>
                </list_item>
                <list_item>
                    <paragraph>墙壁和其他障碍</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="rigidbody2d" names="rigidbody2d">
            <title>RigidBody2D</title>
            <paragraph>这是实现模拟2D物理的节点. 你不能直接控制一个 <reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d"><inline classes="std std-ref">RigidBody2D</inline></reference>. 取而代之的是, 对它施加力, 物理引擎会计算由此产生的运动, 包括与其他物体的碰撞, 以及碰撞响应, 如弹跳, 旋转等.</paragraph>
            <paragraph>你可以通过“Mass”（质量）“Friction”（摩擦）“Bounce”（反弹）等属性修改刚体的行为，这些都可以在检查器中设置。</paragraph>
            <paragraph>物体的行为也受到“项目设置 -&gt; Physics”中设置的世界属性的影响，或者通过输入覆盖全局物理属性的 <reference internal="True" refuri="../../classes/class_area2d#class-area2d"><inline classes="std std-ref">Area2D</inline></reference>。</paragraph>
            <paragraph>当一个刚体处于静止状态, 有一段时间没有移动, 它就会进入睡眠状态. 睡眠的物体就像一个静态的物体, 它的力不会被物理引擎计算. 当力被施加时, 无论是通过碰撞还是通过代码, 该物体都会被唤醒.</paragraph>
            <section ids="using-rigidbody2d" names="using\ rigidbody2d 使用\ rigidbody2d">
                <title>使用 RigidBody2D</title>
                <paragraph>使用刚体的一个好处是，可以“免费”获得许多行为而无需编写任何代码。例如，如果你正在制作一个带有下降块的《愤怒的小鸟》式游戏，你只需要创建 RigidBody2D 并调整它们的属性。堆叠、下降、弹跳将由物理引擎自动计算。</paragraph>
                <paragraph>However, if you do wish to have some control over the body, you should take
                    care - altering the <literal>position</literal>, <literal>linear_velocity</literal>, or other physics properties
                    of a rigid body can result in unexpected behavior. If you need to alter any
                    of the physics-related properties, you should use the <reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d-private-method-integrate-forces"><inline classes="std std-ref">_integrate_forces()</inline></reference>
                    callback instead of <literal>_physics_process()</literal>. In this callback, you have access
                    to the body's <reference internal="True" refuri="../../classes/class_physicsdirectbodystate2d#class-physicsdirectbodystate2d"><inline classes="std std-ref">PhysicsDirectBodyState2D</inline></reference>,
                    which allows for safely changing properties and synchronizing them with
                    the physics engine.</paragraph>
                <paragraph>例如，以下是《爆破彗星》式宇宙飞船的代码：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends RigidBody2D

var thrust = Vector2(0, -250)
var torque = 20000

func _integrate_forces(state):
    if Input.is_action_pressed("ui_up"):
        state.apply_force(thrust.rotated(rotation))
    else:
        state.apply_force(Vector2())
    var rotation_direction = 0
    if Input.is_action_pressed("ui_right"):
        rotation_direction += 1
    if Input.is_action_pressed("ui_left"):
        rotation_direction -= 1
    state.apply_torque(rotation_direction * torque)</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Spaceship : RigidBody2D
{
    private Vector2 _thrust = new Vector2(0, -250);
    private float _torque = 20000;

    public override void _IntegrateForces(PhysicsDirectBodyState2D state)
    {
        if (Input.IsActionPressed("ui_up"))
            state.ApplyForce(_thrust.Rotated(Rotation));
        else
            state.ApplyForce(new Vector2());

        var rotationDir = 0;
        if (Input.IsActionPressed("ui_right"))
            rotationDir += 1;
        if (Input.IsActionPressed("ui_left"))
            rotationDir -= 1;
        state.ApplyTorque(rotationDir * _torque);
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>请注意, 我们不是直接设置 <literal>linear_velocity</literal> 或 <literal>angular_velocity</literal> 属性, 而是将力( <literal>thrust</literal> 和 <literal>torque</literal> )施加到物体上并让物理引擎计算出最终的运动.</paragraph>
                <note>
                    <paragraph>当一个刚体进入睡眠状态时, <literal>_integrate_forces()</literal> 函数将不会被调用. 要重写这一行为, 你需要通过创建碰撞, 对其施加力或禁用 <reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d-property-can-sleep"><inline classes="std std-ref">can_sleep</inline></reference> 属性来保持物体的激活. 请注意, 这可能会对性能产生负面影响.</paragraph>
                </note>
            </section>
            <section ids="contact-reporting" names="contact\ reporting 接触报告">
                <title>接触报告</title>
                <paragraph>By default, rigid bodies do not keep track of contacts, because this can
                    require a huge amount of memory if many bodies are in the scene. To enable
                    contact reporting, set the <reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d-property-max-contacts-reported"><inline classes="std std-ref">max_contacts_reported</inline></reference>
                    property to a non-zero value. The contacts can then be obtained via
                    <reference internal="True" refuri="../../classes/class_physicsdirectbodystate2d#class-physicsdirectbodystate2d-method-get-contact-count"><inline classes="std std-ref">PhysicsDirectBodyState2D.get_contact_count()</inline></reference>
                    and related functions.</paragraph>
                <paragraph>通过信号的接触监控, 启用 <reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d-property-contact-monitor"><inline classes="std std-ref">contact_monitor</inline></reference> 属性. 请参阅 <reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d"><inline classes="std std-ref">RigidBody2D</inline></reference> 的可用信号列表.</paragraph>
            </section>
        </section>
        <section ids="characterbody2d" names="characterbody2d">
            <title>CharacterBody2D</title>
            <paragraph><reference internal="True" refuri="../../classes/class_characterbody2d#class-characterbody2d"><inline classes="std std-ref">CharacterBody2D</inline></reference> 物体能够检测到与其他物体的碰撞，但不会受到重力、摩擦力等物理属性的影响。必须由用户通过代码来控制。物理引擎不会移动角色体。</paragraph>
            <paragraph>移动角色体时，你不应该直接设置 <literal>position</literal>，而应该使用 <literal>move_and_collide()</literal> 或 <literal>move_and_slide()</literal> 方法。这些方法会让物体沿着给定的向量移动，与其他物体发生碰撞就会立即停止移动。发生碰撞后，必须手动编写对碰撞的响应逻辑。</paragraph>
            <section ids="character-collision-response" names="character\ collision\ response 响应角色碰撞">
                <title>响应角色碰撞</title>
                <paragraph>发生碰撞后，你可能会希望该物体发生反弹、沿着墙体滑动、或者修改被碰撞对象的属性。处理碰撞响应的方法取决于移动 CharacterBody2D 的方法。</paragraph>
                <section ids="move-and-collide" names="move_and_collide">
                    <title><reference internal="True" refuri="../../classes/class_physicsbody2d#class-physicsbody2d-method-move-and-collide"><inline classes="std std-ref">move_and_collide</inline></reference></title>
                    <paragraph>当使用 <literal>move_and_collide()</literal> 时, 该函数返回一个 <reference internal="True" refuri="../../classes/class_kinematiccollision2d#class-kinematiccollision2d"><inline classes="std std-ref">KinematicCollision2D</inline></reference> 对象, 其中包含有关碰撞和碰撞体的信息. 你可以使用此信息来确定响应.</paragraph>
                    <paragraph>例如, 如果要查找发生碰撞的空间点:</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                        </div>
                        <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends PhysicsBody2D

var velocity = Vector2(250, 250)

func _physics_process(delta):
    var collision_info = move_and_collide(velocity * delta)
    if collision_info:
        var collision_point = collision_info.get_position()</literal_block>
                        </div>
                        <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Body : PhysicsBody2D
{
    private Vector2 _velocity = new Vector2(250, 250);

    public override void _PhysicsProcess(double delta)
    {
        var collisionInfo = MoveAndCollide(_velocity * (float)delta);
        if (collisionInfo != null)
        {
            var collisionPoint = collisionInfo.GetPosition();
        }
    }
}</literal_block>
                        </div>
                    </container>
                    <paragraph>或者从碰撞物体反弹:</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                        </div>
                        <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends PhysicsBody2D

var velocity = Vector2(250, 250)

func _physics_process(delta):
    var collision_info = move_and_collide(velocity * delta)
    if collision_info:
        velocity = velocity.bounce(collision_info.get_normal())</literal_block>
                        </div>
                        <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Body : PhysicsBody2D
{
    private Vector2 _velocity = new Vector2(250, 250);

    public override void _PhysicsProcess(double delta)
    {
        var collisionInfo = MoveAndCollide(_velocity * (float)delta);
        if (collisionInfo != null)
            _velocity = _velocity.Bounce(collisionInfo.GetNormal());
    }
}</literal_block>
                        </div>
                    </container>
                </section>
                <section ids="move-and-slide" names="move_and_slide">
                    <title><reference internal="True" refuri="../../classes/class_characterbody2d#class-characterbody2d-method-move-and-slide"><inline classes="std std-ref">move_and_slide</inline></reference></title>
                    <paragraph>滑动是一种常见的碰撞响应; 想象一个游戏角色在上帝视角的游戏中沿着墙壁移动, 或者在平台游戏中上下坡. 虽然可在使用 <literal>move_and_collide()</literal> 之后自己编写这个响应, 但 <literal>move_and_slide()</literal> 提供了一种快捷方法来实现滑动且无需编写太多代码.</paragraph>
                    <warning>
                        <paragraph><literal>move_and_slide()</literal> 在计算中自动包含时间步长, 因此你 <strong>不</strong> 应将速度向量乘以 <literal>delta</literal> .</paragraph>
                    </warning>
                    <paragraph>例如, 使用以下代码制作一个可以沿着地面(包括斜坡)行走的角色, 并在站在地面时跳跃:</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                            <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                        </div>
                        <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var run_speed = 350
var jump_speed = -1000
var gravity = 2500

func get_input():
    velocity.x = 0
    var right = Input.is_action_pressed('ui_right')
    var left = Input.is_action_pressed('ui_left')
    var jump = Input.is_action_just_pressed('ui_select')

    if is_on_floor() and jump:
        velocity.y = jump_speed
    if right:
        velocity.x += run_speed
    if left:
        velocity.x -= run_speed

func _physics_process(delta):
    velocity.y += gravity * delta
    get_input()
    move_and_slide()</literal_block>
                        </div>
                        <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Body : CharacterBody2D
{
    private float _runSpeed = 350;
    private float _jumpSpeed = -1000;
    private float _gravity = 2500;

    private void GetInput()
    {
        var velocity = Velocity;
        velocity.X = 0;

        var right = Input.IsActionPressed("ui_right");
        var left = Input.IsActionPressed("ui_left");
        var jump = Input.IsActionPressed("ui_select");

        if (IsOnFloor() &amp;&amp; jump)
            velocity.Y = _jumpSpeed;
        if (right)
            velocity.X += _runSpeed;
        if (left)
            velocity.X -= _runSpeed;

        Velocity = velocity;
    }

    public override void _PhysicsProcess(double delta)
    {
        var velocity = Velocity;
        velocity.Y += _gravity * (float)delta;
        Velocity = velocity;
        GetInput();
        MoveAndSlide();
    }
}</literal_block>
                        </div>
                    </container>
                    <paragraph>有关使用 <literal>move_and_slide()</literal> 的更多详细信息, 请参阅 <reference internal="True" refuri="kinematic_character_2d#doc-kinematic-character-2d"><inline classes="std std-ref">运动学角色（2D）</inline></reference> , 包括带有详细代码的演示项目.</paragraph>
                    <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
                </section>
            </section>
        </section>
    </section>
</document>
