<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/physics/interpolation/advanced_physics_interpolation.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-advanced-physics-interpolation"></target>
    <section ids="advanced-physics-interpolation doc-advanced-physics-interpolation" names="advanced\ physics\ interpolation doc_advanced_physics_interpolation">
        <title>Advanced physics interpolation</title>
        <paragraph>Although the previous instructions will give satisfactory results in a lot of games,
            in some cases you will want to go a stage further to get the best possible results
            and the smoothest possible experience.</paragraph>
        <section ids="exceptions-to-automatic-physics-interpolation" names="exceptions\ to\ automatic\ physics\ interpolation">
            <title>Exceptions to automatic physics interpolation</title>
            <paragraph>Even with physics interpolation active, there may be some local situations where
                you would benefit from disabling automatic interpolation for a
                <reference internal="True" refuri="../../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> (or branch of the <reference internal="True" refuri="../../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>), and
                have the finer control of performing interpolation manually.</paragraph>
            <paragraph>This is possible using the <reference internal="True" refuri="../../../classes/class_node#class-node-property-physics-interpolation-mode"><inline classes="std std-ref">Node.physics_interpolation_mode</inline></reference>
                property which is present in all Nodes. If you for example, turn off interpolation
                for a Node, the children will recursively also be affected (as they default to
                inheriting the parent setting). This means you can easily disable interpolation for
                an entire subscene.</paragraph>
            <paragraph>The most common situation where you may want to perform your own interpolation is
                Cameras.</paragraph>
            <section ids="cameras" names="cameras">
                <title>Cameras</title>
                <paragraph>In many cases, a <reference internal="True" refuri="../../../classes/class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference> can use automatic interpolation
                    just like any other node. However, for best results, especially at low physics tick
                    rates, it is recommended that you take a manual approach to camera interpolation.</paragraph>
                <paragraph>This is because viewers are very sensitive to camera movement. For instance, a
                    Camera3D that realigns slightly every 1/10th of a second (at 10tps tick rate) will
                    often be noticeable. You can get a much smoother result by moving the camera each
                    frame in <literal>_process</literal>, and following an interpolated target manually.</paragraph>
            </section>
            <section ids="manual-camera-interpolation" names="manual\ camera\ interpolation">
                <title>Manual camera interpolation</title>
                <section ids="ensure-the-camera-is-using-global-coordinate-space" names="ensure\ the\ camera\ is\ using\ global\ coordinate\ space">
                    <title>Ensure the camera is using global coordinate space</title>
                    <paragraph>The very first step when performing manual camera interpolation is to make sure the
                        Camera3D transform is specified in <emphasis>global space</emphasis> rather than inheriting the
                        transform of a moving parent. This is because feedback can occur between the
                        movement of a parent node of a Camera3D and the movement of the camera Node itself,
                        which can mess up the interpolation.</paragraph>
                    <paragraph>There are two ways of doing this:</paragraph>
                    <enumerated_list enumtype="arabic" prefix="" suffix=")">
                        <list_item>
                            <paragraph>Move the Camera3D so it is independent on its own branch, rather than being a child of a moving object.</paragraph>
                        </list_item>
                    </enumerated_list>
                    <image candidates="{'*': 'tutorials/physics/interpolation/img/fti_camera_worldspace.webp'}" original_uri="img/fti_camera_worldspace.webp" uri="tutorials/physics/interpolation/img/fti_camera_worldspace.webp"></image>
                    <enumerated_list enumtype="arabic" prefix="" start="2" suffix=")">
                        <list_item>
                            <paragraph>Call <reference internal="True" refuri="../../../classes/class_node3d#class-node3d-property-top-level"><inline classes="std std-ref">Node3D.top_level</inline></reference> and set this to <literal>true</literal>, which will make the Camera ignore the transform of its parent.</paragraph>
                        </list_item>
                    </enumerated_list>
                </section>
                <section ids="typical-example" names="typical\ example">
                    <title>Typical example</title>
                    <paragraph>A typical example of a custom approach is to use the <literal>look_at</literal> function in the
                        Camera3D every frame in <literal>_process()</literal> to look at a target node (such as the player).</paragraph>
                    <paragraph>But there is a problem. If we use the traditional <literal>get_global_transform()</literal> on a
                        Camera3D "target" node, this transform will only focus the Camera3D on the target <emphasis>at
                            the current physics tick</emphasis>. This is <emphasis>not</emphasis> what we want, as the camera will jump
                        about on each physics tick as the target moves. Even though the camera may be
                        updated each frame, this does not help give smooth motion if the <emphasis>target</emphasis> is only
                        changing each physics tick.</paragraph>
                </section>
                <section ids="get-global-transform-interpolated" names="get_global_transform_interpolated()">
                    <title>get_global_transform_interpolated()</title>
                    <paragraph>What we really want to focus the camera on, is not the position of the target on
                        the physics tick, but the <emphasis>interpolated</emphasis> position, i.e. the position at which the
                        target will be rendered.</paragraph>
                    <paragraph>We can do this using the <reference internal="True" refuri="../../../classes/class_node3d#class-node3d-method-get-global-transform-interpolated"><inline classes="std std-ref">Node3D.get_global_transform_interpolated</inline></reference>
                        function. This acts exactly like getting <reference internal="True" refuri="../../../classes/class_node3d#class-node3d-property-global-transform"><inline classes="std std-ref">Node3D.global_transform</inline></reference>
                        but it gives you the <emphasis>interpolated</emphasis> transform (during a <literal>_process()</literal> call).</paragraph>
                    <important>
                        <paragraph><literal>get_global_transform_interpolated()</literal> should only be used once or
                            twice for special cases such as cameras. It should <strong>not</strong> be used
                            all over the place in your code (both for performance reasons, and
                            to give correct gameplay).</paragraph>
                    </important>
                    <note>
                        <paragraph>Aside from exceptions like the camera, in most cases, your game logic
                            should be in <literal>_physics_process()</literal>. In game logic you should be calling
                            <literal>get_global_transform()</literal> or <literal>get_transform()</literal>, which will give the
                            current physics transform (in global or local space respectively), which
                            is usually what you will want for gameplay code.</paragraph>
                    </note>
                </section>
                <section ids="example-manual-camera-script" names="example\ manual\ camera\ script">
                    <title>Example manual camera script</title>
                    <paragraph>Here is an example of a simple fixed camera which follows an interpolated target:</paragraph>
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Camera3D

# Node that the camera will follow
var _target

# We will smoothly lerp to follow the target
# rather than follow exactly
var _target_pos : Vector3 = Vector3()

func _ready() -&gt; void:
    # Find the target node
    _target = get_node("../Player")

    # Turn off automatic physics interpolation for the Camera3D,
    # we will be doing this manually
    set_physics_interpolation_mode(Node.PHYSICS_INTERPOLATION_MODE_OFF)

func _process(delta: float) -&gt; void:
    # Find the current interpolated transform of the target
    var tr : Transform = _target.get_global_transform_interpolated()

    # Provide some delayed smoothed lerping towards the target position
    _target_pos = lerp(_target_pos, tr.origin, min(delta, 1.0))

    # Fixed camera position, but it will follow the target
    look_at(_target_pos, Vector3(0, 1, 0))</literal_block>
                </section>
                <section ids="mouse-look" names="mouse\ look">
                    <title>Mouse look</title>
                    <paragraph>Mouse look is a very common way of controlling cameras. But there is a problem.
                        Unlike keyboard input which can be sampled periodically on the physics tick, mouse
                        move events can come in continuously. The camera will be expected to react and
                        follow these mouse movements on the next frame, rather than waiting until the next
                        physics tick.</paragraph>
                    <paragraph>In this situation, it can be better to disable physics interpolation for the camera
                        node (using <reference internal="True" refuri="../../../classes/class_node#class-node-property-physics-interpolation-mode"><inline classes="std std-ref">Node.physics_interpolation_mode</inline></reference>)
                        and directly apply the mouse input to the camera rotation, rather than apply it in
                        <literal>_physics_process</literal>.</paragraph>
                    <paragraph>Sometimes, especially with cameras, you will want to use a combination of
                        interpolation and non-interpolation:</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>A first person camera may position the camera at a player location (perhaps using
                                <reference internal="True" refuri="../../../classes/class_node3d#class-node3d-method-get-global-transform-interpolated"><inline classes="std std-ref">Node3D.get_global_transform_interpolated</inline></reference>),
                                but control the Camera rotation from mouse look <emphasis>without</emphasis> interpolation.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>A third person camera may similarly determine the look at (target location) of the camera using
                                <reference internal="True" refuri="../../../classes/class_node3d#class-node3d-method-get-global-transform-interpolated"><inline classes="std std-ref">Node3D.get_global_transform_interpolated</inline></reference>,
                                but position the camera using mouse look <emphasis>without</emphasis> interpolation.</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>There are many permutations and variations of camera types, but it should be clear
                        that in many cases, disabling automatic physics interpolation and handling this
                        yourself can give a better result.</paragraph>
                </section>
            </section>
            <section ids="disabling-interpolation-on-other-nodes" names="disabling\ interpolation\ on\ other\ nodes">
                <title>Disabling interpolation on other nodes</title>
                <paragraph>Although cameras are the most common example, there are a number of cases when you
                    may wish other nodes to control their own interpolation, or be non-interpolated.
                    Consider for example, a player in a top view game whose rotation is controlled by
                    mouse look. Disabling physics rotation allows the player rotation to match the
                    mouse in real-time.</paragraph>
            </section>
            <section ids="multimeshes" names="multimeshes">
                <title>MultiMeshes</title>
                <paragraph>Although most visual Nodes follow the single Node single visual instance paradigm,
                    MultiMeshes can control several instances from the same Node. Therefore, they have
                    some extra functions for controlling interpolation functionality on a
                    <emphasis>per-instance</emphasis> basis. You should explore these functions if you are using
                    interpolated MultiMeshes.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference internal="True" refuri="../../../classes/class_multimesh#class-multimesh-method-reset-instance-physics-interpolation"><inline classes="std std-ref">MultiMesh.reset_instance_physics_interpolation</inline></reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="True" refuri="../../../classes/class_multimesh#class-multimesh-method-set-buffer-interpolated"><inline classes="std std-ref">MultiMesh.set_buffer_interpolated</inline></reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Full details are in the <reference internal="True" refuri="../../../classes/class_multimesh#class-multimesh"><inline classes="std std-ref">MultiMesh</inline></reference> documentation.</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
