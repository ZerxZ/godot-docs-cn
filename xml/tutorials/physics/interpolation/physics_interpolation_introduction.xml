<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/physics/interpolation/physics_interpolation_introduction.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-physics-interpolation-introduction"></target>
    <section ids="introduction doc-physics-interpolation-introduction" names="introduction doc_physics_interpolation_introduction">
        <title>Introduction</title>
        <section ids="physics-ticks-and-rendered-frames" names="physics\ ticks\ and\ rendered\ frames">
            <title>Physics ticks and rendered frames</title>
            <paragraph>One key concept to understand in Godot is the distinction between physics ticks
                (sometimes referred to as iterations or physics frames), and rendered frames. The
                physics proceeds at a fixed tick rate (set in <reference internal="True" refuri="../../../classes/class_projectsettings#class-projectsettings-property-physics-common-physics-ticks-per-second"><inline classes="std std-ref">Project Settings &gt; Physics &gt; Common &gt; Physics Tick per Second</inline></reference>),
                which defaults to 60 ticks per second.</paragraph>
            <paragraph>However, the engine does not necessarily <strong>render</strong> at the same rate. Although many
                monitors refresh at 60 Hz (cycles per second), many refresh at completely different
                frequencies (e.g. 75 Hz, 144 Hz, 240 Hz or more). Even though a monitor may be able
                to show a new frame e.g. 60 times a second, there is no guarantee that the CPU and
                GPU will be able to <emphasis>supply</emphasis> frames at this rate. For instance, when running with
                V-Sync, the computer may be too slow for 60 and only reach the deadlines for 30
                FPS, in which case the frames you see will change at 30 FPS (resulting in
                stuttering).</paragraph>
            <paragraph>But there is a problem here. What happens if the physics ticks do not coincide with
                frames? What happens if the physics tick rate is out of phase with the frame rate?
                Or worse, what happens if the physics tick rate is <emphasis>lower</emphasis> than the rendered frame
                rate?</paragraph>
            <paragraph>This problem is easier to understand if we consider an extreme scenario. If you set
                the physics tick rate to 10 ticks per second, in a simple game with a rendered
                frame rate of 60 FPS. If we plot a graph of the positions of an object against the
                rendered frames, you can see that the positions will appear to "jump" every 1/10th
                of a second, rather than giving a smooth motion. When the physics calculates a new
                position for a new object, it is not rendered in this position for just one frame,
                but for 6 frames.</paragraph>
            <image candidates="{'*': 'tutorials/physics/interpolation/img/fti_graph_fixed_ticks.webp'}" original_uri="img/fti_graph_fixed_ticks.webp" uri="tutorials/physics/interpolation/img/fti_graph_fixed_ticks.webp"></image>
            <paragraph>This jump can be seen in other combinations of tick / frame rate as glitches, or
                jitter, caused by this staircasing effect due to the discrepancy between physics
                tick time and rendered frame time.</paragraph>
        </section>
        <section ids="what-can-we-do-about-frames-and-ticks-being-out-of-sync" names="what\ can\ we\ do\ about\ frames\ and\ ticks\ being\ out\ of\ sync?">
            <title>What can we do about frames and ticks being out of sync?</title>
            <section ids="lock-the-tick-frame-rate-together" names="lock\ the\ tick\ /\ frame\ rate\ together?">
                <title>Lock the tick / frame rate together?</title>
                <paragraph>The most obvious solution is to get rid of the problem, by ensuring there is a
                    physics tick that coincides with every frame. This used to be the approach on old
                    consoles and fixed hardware computers. If you know that every player will be using
                    the same hardware, you can ensure it is fast enough to calculate ticks and frames
                    at e.g. 50 FPS, and you will be sure it will work great for everybody.</paragraph>
                <paragraph>However, modern games are often no longer made for fixed hardware. You will often
                    be planning to release on desktop computers, mobiles, and more. All of which have
                    huge variations in performance, as well as different monitor refresh rates. We need
                    to come up with a better way of dealing with the problem.</paragraph>
            </section>
            <section ids="adapt-the-tick-rate" names="adapt\ the\ tick\ rate?">
                <title>Adapt the tick rate?</title>
                <paragraph>Instead of designing the game at a fixed physics tick rate, we could allow the tick
                    rate to scale according to the end user's hardware. We could for example use a fixed
                    tick rate that works for that hardware, or even vary the duration of each physics
                    tick to match a particular frame duration.</paragraph>
                <paragraph>This works, but there is a problem. Physics (<emphasis>and game logic</emphasis>, which is often also
                    run in the <literal>_physics_process</literal>) work best and most consistently when run at a
                    <strong>fixed</strong>, predetermined tick rate. If you attempt to run a racing game physics
                    that has been designed for 60 TPS (ticks per second) at e.g. 10 TPS, the physics
                    will behave completely differently. Controls may be less responsive, collisions /
                    trajectories can be completely different. You may test your game thoroughly at 60
                    TPS, then find it breaks on end users' machines when it runs at a different tick
                    rate.</paragraph>
                <paragraph>This can make quality assurance difficult with hard to reproduce bugs, especially
                    in AAA games where problems of this sort can be very costly. This can also be
                    problematic for multiplayer games for competitive integrity, as running the game at
                    certain tick rates may be more advantageous than others.</paragraph>
            </section>
            <section ids="lock-the-tick-rate-but-use-interpolation-to-smooth-frames-in-between-physics-ticks" names="lock\ the\ tick\ rate,\ but\ use\ interpolation\ to\ smooth\ frames\ in\ between\ physics\ ticks">
                <title>Lock the tick rate, but use interpolation to smooth frames in between physics ticks</title>
                <paragraph>This has become one of the most popular approaches to deal with the problem,
                    although it is optional and disabled by default.</paragraph>
                <paragraph>We have established that the most desirable physics/game logic arrangement for
                    consistency and predictability is a physics tick rate that is fixed at design-time.
                    The problem is the discrepancy between the physics position recorded, and where we
                    "want" a physics object to be shown on a frame to give smooth motion.</paragraph>
                <paragraph>The answer turns out to be simple, but can be a little hard to get your head around
                    at first.</paragraph>
                <paragraph>Instead of keeping track of just the current position of a physics object in the
                    engine, we keep track of <emphasis>both the current position of the object, and the previous
                        position</emphasis> on the previous physics tick.</paragraph>
                <paragraph>Why do we need the previous position <emphasis>(in fact the entire transform, including
                        rotation and scaling)</emphasis>? By using a little math magic, we can use <strong>interpolation</strong>
                    to calculate what the transform of the object would be between those two points, in
                    our ideal world of smooth continuous movement.</paragraph>
                <image candidates="{'*': 'tutorials/physics/interpolation/img/fti_graph_interpolated.webp'}" original_uri="img/fti_graph_interpolated.webp" uri="tutorials/physics/interpolation/img/fti_graph_interpolated.webp"></image>
            </section>
            <section ids="linear-interpolation" names="linear\ interpolation">
                <title>Linear interpolation</title>
                <paragraph>The simplest way to achieve this is linear interpolation, or lerping, which you may
                    have used before.</paragraph>
                <paragraph>Let us consider only the position, and a situation where we know that the previous
                    physics tick X coordinate was 10 units, and the current physics tick X coordinate
                    is 30 units.</paragraph>
                <note>
                    <paragraph>Although the maths is explained here, you do not have to worry about the
                        details, as this step will be performed for you. Under the hood, Godot
                        may use more complex forms of interpolation, but linear interpolation is
                        the easiest in terms of explanation.</paragraph>
                </note>
            </section>
            <section ids="the-physics-interpolation-fraction" names="the\ physics\ interpolation\ fraction">
                <title>The physics interpolation fraction</title>
                <paragraph>If our physics ticks are happening 10 times per second (for this example), what
                    happens if our rendered frame takes place at time 0.12 seconds? We can do some math
                    to figure out where the object would be to obtain a smooth motion between the two
                    ticks.</paragraph>
                <paragraph>First of all, we have to calculate how far through the physics tick we want the
                    object to be. If the last physics tick took place at 0.1 seconds, we are 0.02
                    seconds <emphasis>(0.12 - 0.1)</emphasis> through a tick that we know will take 0.1 seconds (10 ticks
                    per second). The fraction through the tick is thus:</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">fraction = 0.02 / 0.10
fraction = 0.2</literal_block>
                <paragraph>This is called the <strong>physics interpolation fraction</strong>, and is handily calculated
                    for you by Godot. It can be retrieved on any frame by calling <reference internal="True" refuri="../../../classes/class_engine#class-engine-method-get-physics-interpolation-fraction"><inline classes="std std-ref">Engine.get_physics_interpolation_fraction</inline></reference>.</paragraph>
            </section>
            <section ids="calculating-the-interpolated-position" names="calculating\ the\ interpolated\ position">
                <title>Calculating the interpolated position</title>
                <paragraph>Once we have the interpolation fraction, we can insert it into a standard linear
                    interpolation equation. The X coordinate would thus be:</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">x_interpolated = x_prev + ((x_curr - x_prev) * 0.2)</literal_block>
                <paragraph>So substituting our <literal>x_prev</literal> as 10, and <literal>x_curr</literal> as 30:</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">x_interpolated = 10 + ((30 - 10) * 0.2)
x_interpolated = 10 + 4
x_interpolated = 14</literal_block>
                <paragraph>Let's break that down:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>We know the X starts from the coordinate on the previous tick (<literal>x_prev</literal>) which
                            is 10 units.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>We know that after the full tick, the difference between the current tick and the
                            previous tick will have been added (<literal>x_curr - x_prev</literal>) (which is 20 units).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The only thing we need to vary is the proportion of this difference we add,
                            according to how far we are through the physics tick.</paragraph>
                    </list_item>
                </bullet_list>
                <note>
                    <paragraph>Although this example interpolates the position, the same thing can be
                        done with the rotation and scale of objects. It is not necessary to know
                        the details as Godot will do all this for you.</paragraph>
                </note>
            </section>
            <section ids="smoothed-transformations-between-physics-ticks" names="smoothed\ transformations\ between\ physics\ ticks?">
                <title>Smoothed transformations between physics ticks?</title>
                <paragraph>Putting all this together shows that it should be possible to have a nice smooth
                    estimation of the transform of objects between the current and previous physics
                    tick.</paragraph>
                <paragraph>But wait, you may have noticed something. If we are interpolating between the
                    current and previous ticks, we are not estimating the position of the object <emphasis>now</emphasis>,
                    we are estimating the position of the object in the past. To be exact, we are
                    estimating the position of the object <emphasis>between 1 and 2 ticks</emphasis> into the past.</paragraph>
            </section>
            <section ids="in-the-past" names="in\ the\ past">
                <title>In the past</title>
                <paragraph>What does this mean? This scheme does work, but it does mean we are effectively
                    introducing a delay between what we see on the screen, and where the objects
                    <emphasis>should</emphasis> be.</paragraph>
                <paragraph>In practice, most people won't notice this delay, or rather, it is typically not
                    <emphasis>objectionable</emphasis>. There are already significant delays involved in games, we just
                    don't typically notice them. The most significant effect is there can be a slight
                    delay to input, which can be a factor in fast twitch games. In some of these fast
                    input situations, you may wish to turn off physics interpolation and use a
                    different scheme, or use a high tick rate, which mitigates these delays.</paragraph>
            </section>
            <section ids="why-look-into-the-past-why-not-predict-the-future" names="why\ look\ into\ the\ past?\ why\ not\ predict\ the\ future?">
                <title>Why look into the past? Why not predict the future?</title>
                <paragraph>There is an alternative to this scheme, which is: instead of interpolating between
                    the previous and current tick, we use maths to <emphasis>extrapolate</emphasis> into the future. We
                    try to predict where the object <emphasis>will be</emphasis>, rather than show it where it was. This
                    can be done and may be offered as an option in future, but there are some
                    significant downsides:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>The prediction may not be correct, especially when an object collides with
                            another object during the physics tick.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Where a prediction was incorrect, the object may extrapolate into an "impossible"
                            position, like inside a wall.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Providing the movement speed is slow, these incorrect predictions may not be too
                            much of a problem.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>When a prediction was incorrect, the object may have to jump or snap back onto
                            the corrected path. This can be visually jarring.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="fixed-timestep-interpolation" names="fixed\ timestep\ interpolation">
                <title>Fixed timestep interpolation</title>
                <paragraph>In Godot this whole system is referred to as physics interpolation, but you may
                    also hear it referred to as <strong>"fixed timestep interpolation"</strong>, as it is
                    interpolating between objects moved with a fixed timestep (physics ticks per
                    second). In some ways the second term is more accurate, because it can also be used
                    to interpolate objects that are not driven by physics.</paragraph>
                <tip>
                    <paragraph>Although physics interpolation is usually a good choice, there are
                        exceptions where you may choose not to use Godot's built-in physics
                        interpolation (or use it in a limited fashion). An example category is
                        internet multiplayer games. Multiplayer games often receive tick or timing
                        based information from other players or a server and these may not
                        coincide with local physics ticks, so a custom interpolation technique can
                        often be a better fit.</paragraph>
                </tip>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
