<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/physics/interpolation/using_physics_interpolation.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-physics-interpolation"></target>
    <section ids="using-physics-interpolation doc-using-physics-interpolation" names="using\ physics\ interpolation doc_using_physics_interpolation">
        <title>Using physics interpolation</title>
        <paragraph>How do we incorporate physics interpolation into a Godot game? Are there any
            caveats?</paragraph>
        <paragraph>We have tried to make the system as easy to use as possible, and many existing
            games will work with few changes. That said there are some situations which require
            special treatment, and these will be described.</paragraph>
        <section ids="turn-on-the-physics-interpolation-setting" names="turn\ on\ the\ physics\ interpolation\ setting">
            <title>Turn on the physics interpolation setting</title>
            <paragraph>The first step is to turn on physics interpolation in
                <reference internal="True" refuri="../../../classes/class_projectsettings#class-projectsettings-property-physics-common-physics-interpolation"><inline classes="std std-ref">Project Settings &gt; Physics &gt; Common &gt; Physics Interpolation</inline></reference>
                You can now run your game.</paragraph>
            <paragraph>It is likely that nothing looks hugely different, particularly if you are running
                physics at 60 TPS or a multiple of it. However, quite a bit more is happening
                behind the scenes.</paragraph>
            <tip>
                <paragraph>To convert an existing game to use interpolation, it is highly recommended that
                    you temporarily set
                    <reference internal="True" refuri="../../../classes/class_projectsettings#class-projectsettings-property-physics-common-physics-ticks-per-second"><inline classes="std std-ref">Project Settings &gt; Physics &gt; Common &gt; Physics Tick per Second</inline></reference>
                    to a low value such as <literal>10</literal>, which will make interpolation problems more obvious.</paragraph>
            </tip>
        </section>
        <section ids="move-almost-all-game-logic-from-process-to-physics-process" names="move\ (almost)\ all\ game\ logic\ from\ _process\ to\ _physics_process">
            <title>Move (almost) all game logic from _process to _physics_process</title>
            <paragraph>The most fundamental requirement for physics interpolation (which you may be doing
                already) is that you should be moving and performing game logic on your objects
                within <literal>_physics_process</literal> (which runs at a physics tick) rather than <literal>_process</literal>
                (which runs on a rendered frame). This means your scripts should typically be doing
                the bulk of their processing within <literal>_physics_process</literal>, including responding to
                input and AI.</paragraph>
            <paragraph>Setting the transform of objects only within physics ticks allows the automatic
                interpolation to deal with transforms <emphasis>between</emphasis> physics ticks, and ensures the game
                will run the same whatever machine it is run on. As a bonus, this also reduces CPU
                usage if the game is rendering at high FPS, since AI logic (for example) will no
                longer run on every rendered frame.</paragraph>
            <note>
                <paragraph>If you attempt to set the transform of interpolated objects <emphasis>outside</emphasis> the
                    physics tick, the calculations for the interpolated position will be
                    incorrect, and you will get jitter. This jitter may not be visible on
                    your machine, but it <emphasis>will</emphasis> occur for some players. For this reason,
                    setting the transform of interpolated objects should be avoided outside
                    of the physics tick. Godot will attempt to produce warnings in the editor
                    if this case is detected.</paragraph>
            </note>
            <tip>
                <paragraph>This is only a <emphasis>soft rule</emphasis>. There are some occasions where you might want
                    to teleport objects outside of the physics tick (for instance when
                    starting a level, or respawning objects). Still, in general, you should be
                    applying transforms from the physics tick.</paragraph>
            </tip>
        </section>
        <section ids="ensure-that-all-indirect-movement-happens-during-physics-ticks" names="ensure\ that\ all\ indirect\ movement\ happens\ during\ physics\ ticks">
            <title>Ensure that all indirect movement happens during physics ticks</title>
            <paragraph>Consider that in Godot, nodes can be moved not just directly in your own scripts,
                but also by automatic methods such as tweening, animation, and navigation. All
                these methods should also have their timing set to operate on the physics tick
                rather than each frame ("idle"), <strong>if</strong> you are using them to move objects (<emphasis>these
                    methods can also be used to control properties that are not interpolated</emphasis>).</paragraph>
            <note>
                <paragraph>Also consider that nodes can be moved not just by moving themselves, but
                    also by moving parent nodes in the <reference internal="True" refuri="../../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>. The
                    movement of parents should therefore also only occur during physics ticks.</paragraph>
            </note>
        </section>
        <section ids="choose-a-physics-tick-rate" names="choose\ a\ physics\ tick\ rate">
            <title>Choose a physics tick rate</title>
            <paragraph>When using physics interpolation, the rendering is decoupled from physics, and you
                can choose any value that makes sense for your game. You are no longer limited to
                values that are multiples of the user's monitor refresh rate (for stutter-free
                gameplay if the target FPS is reached).</paragraph>
            <paragraph>As a rough guide:</paragraph>
            <table classes="colwidths-given">
                <tgroup cols="3">
                    <colspec colwidth="20"></colspec>
                    <colspec colwidth="20"></colspec>
                    <colspec colwidth="20"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Low tick rates (10-30)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Medium tick rates (30-60)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>High tick rates (60+)</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>Better CPU performance</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Good physics behavior in complex scenes</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Good with fast physics</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>Add some delay to input</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Good for first person games</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Good for racing games</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>Simple physics behaviour</paragraph>
                            </entry>
                            <entry>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <note>
                <paragraph>You can always change the tick rate as you develop, it is as simple as
                    changing the project setting.</paragraph>
            </note>
        </section>
        <section ids="call-reset-physics-interpolation-when-teleporting-objects" names="call\ reset_physics_interpolation()\ when\ teleporting\ objects">
            <title>Call <literal>reset_physics_interpolation()</literal> when teleporting objects</title>
            <paragraph>Most of the time, interpolation is what you want between two physics ticks.
                However, there is one situation in which it may <emphasis>not</emphasis> be what you want. That is
                when you are initially placing objects, or moving them to a new location. Here, you
                don't want a smooth motion between where the object was (e.g. the origin) and the
                initial position - you want an instantaneous move.</paragraph>
            <paragraph>The solution to this is to call the <reference internal="True" refuri="../../../classes/class_node#class-node-method-reset-physics-interpolation"><inline classes="std std-ref">Node.reset_physics_interpolation</inline></reference>
                function. What this function does under the hood is set the internally stored
                <emphasis>previous transform</emphasis> of the object to be equal to the <emphasis>current transform</emphasis>. This
                ensures that when interpolating between these two equal transforms, there will be
                no movement.</paragraph>
            <paragraph>Even if you forget to call this, it will usually not be a problem in most
                situations (especially at high tick rates). This is something you can easily leave
                to the polishing phase of your game. The worst that will happen is seeing a
                streaking motion for a frame or so when you move them - you will know when you need
                it!</paragraph>
            <paragraph>There are actually two ways to use <literal>reset_physics_interpolation()</literal>:</paragraph>
            <paragraph><emphasis>Standing start (e.g. player)</emphasis></paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=")">
                <list_item>
                    <paragraph>Set the initial transform</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Call <literal>reset_physics_interpolation()</literal></paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>The previous and current transforms will be identical, resulting in no initial
                movement.</paragraph>
            <paragraph><emphasis>Moving start (e.g. bullet)</emphasis></paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=")">
                <list_item>
                    <paragraph>Set the initial transform</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Call <literal>reset_physics_interpolation()</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph>Immediately set the transform expected after the first tick of motion</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>The previous transform will be the starting position, and the current transform
                will act as though a tick of simulation has already taken place. This will
                immediately start moving the object, instead of having a tick delay standing still.</paragraph>
            <important>
                <paragraph>Make sure you set the transform and call
                    <literal>reset_physics_interpolation()</literal> in the correct order as shown
                    above, otherwise you will see unwanted "streaking".</paragraph>
            </important>
        </section>
        <section ids="testing-and-debugging-tips" names="testing\ and\ debugging\ tips">
            <title>Testing and debugging tips</title>
            <paragraph>Even if you intend to run physics at 60 TPS, in order to thoroughly test your
                interpolation and get the smoothest gameplay, it is highly recommended to
                temporarily set the physics tick rate to a low value such as 10 TPS.</paragraph>
            <paragraph>The gameplay may not work perfectly, but it should enable you to more easily see
                cases where you should be calling <reference internal="True" refuri="../../../classes/class_node#class-node-method-reset-physics-interpolation"><inline classes="std std-ref">Node.reset_physics_interpolation</inline></reference>,
                or where you should be using your own custom interpolation on e.g. a
                <reference internal="True" refuri="../../../classes/class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference>. Once you have these cases fixed, you can set the
                physics tick rate back to the desired setting.</paragraph>
            <paragraph>The other great advantage to testing at a low tick rate is you can often notice
                other game systems that are synchronized to the physics tick and creating glitches
                which you may want to work around. Typical examples include setting animation blend
                values, which you may decide to set in <literal>_process()</literal> and interpolate manually.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
