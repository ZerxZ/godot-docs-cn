<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/physics/using_character_body_2d.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-character-body-2d"></target>
    <section ids="using-characterbody2d-3d doc-using-character-body-2d" names="using\ characterbody2d/3d 使用\ characterbody2d/3d doc_using_character_body_2d">
        <title>使用 CharacterBody2D/3D</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>Godot 提供了多种碰撞对象来提供碰撞检测和响应。试图决定在你的项目中使用哪一个可能会让你感到困惑。如果你了解它们中的每一个是如何工作的，以及它们的优点和缺点是什么，你就可以避免问题并简化开发。在本教程中，我们将查看 <reference internal="True" refuri="../../classes/class_characterbody2d#class-characterbody2d"><inline classes="std std-ref">CharacterBody2D</inline></reference> 节点，并展示一些如何使用它的例子.</paragraph>
            <note>
                <paragraph>虽然本文档在其示例中使用 <literal>CharacterBody2D</literal> ，但相同的概念也适用于 3D。</paragraph>
            </note>
        </section>
        <section ids="what-is-a-character-body" names="what\ is\ a\ character\ body? 什么是角色体？">
            <title>什么是角色体？</title>
            <paragraph><literal>CharacterBody2D</literal> 用于实现通过代码控制的物体。Character bodies 在移动时可以检测到与其他物体的碰撞，但不受引擎物理属性（如重力、摩擦力等）的影响。虽然这意味着你必须编写一些代码来创建它们的行为，但这也意味着你可以更精确地控制它们如何移动和反应。</paragraph>
            <note>
                <paragraph>本文假设你熟悉 Godot 中的各种物理体。否则请先阅读 <reference internal="True" refuri="physics_introduction#doc-physics-introduction"><inline classes="std std-ref">物理介绍</inline></reference> 。</paragraph>
            </note>
            <tip>
                <paragraph><title_reference>CharacterBody2D</title_reference> 可以受到重力和其他力的影响，但你必须在代码中计算它的运动。物理引擎不会移动 <title_reference>CharacterBody2D</title_reference> 。</paragraph>
            </tip>
        </section>
        <section ids="movement-and-collision" names="movement\ and\ collision 运动与碰撞">
            <title>运动与碰撞</title>
            <paragraph>当移动一个 <literal>CharacterBody2D</literal> 时，你不应该直接设置它的 <literal>position</literal> 属性，而应该使用 <literal>move_and_collide()</literal> 或 <literal>move_and_slide()</literal> 方法。这些方法沿着给定的向量移动物体，并且检测碰撞。</paragraph>
            <warning>
                <paragraph>你应该在 <literal>_physics_process()</literal> 回调中处理物理体的运动。</paragraph>
            </warning>
            <paragraph>这两种运动方法有不同的作用, 在后面的教程中, 你会看到它们如何工作的例子.</paragraph>
            <section ids="move-and-collide" names="move_and_collide">
                <title>move_and_collide</title>
                <paragraph>这个方法需要一个 <reference internal="True" refuri="../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> 参数以表示物体的相对运动。通常，这是速度向量乘以帧时间步长( <literal>delta</literal> )。如果引擎在沿着此向量方向的任何位置检测到碰撞，则物体将立即停止移动。如果发生这种情况，该方法将返回一个 <reference internal="True" refuri="../../classes/class_kinematiccollision2d#class-kinematiccollision2d"><inline classes="std std-ref">KinematicCollision2D</inline></reference> 对象。</paragraph>
                <paragraph><literal>KinematicCollision2D</literal> 是一个包含碰撞和碰撞对象数据的对象. 使用这些数据, 你可以计算出你的碰撞响应.</paragraph>
                <paragraph>当你只想移动物体并检测碰撞，并且不需要任何自动碰撞响应时， <literal>move_and_collide</literal> 最有用。例如，如果你需要一颗从墙上弹开的子弹，你可以在检测到碰撞时直接更改速度角度。请参阅下面的示例。</paragraph>
            </section>
            <section ids="move-and-slide" names="move_and_slide">
                <title>move_and_slide</title>
                <paragraph><literal>move_and_slide()</literal> 方法旨在简化常见情况下的碰撞响应, 即你希望一个物体沿着另一个物体滑动. 例如, 在平台游戏或自上而下的游戏中, 它特别有用.</paragraph>
                <paragraph>当调用 <literal>move_and_slide()</literal> 时，该函数使用许多节点属性来计算其滑动行为。这些属性可以在检查器中找到，或在代码中设置。</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><literal>velocity</literal> - <emphasis>默认值：</emphasis> <literal>Vector2( 0, 0 )</literal></paragraph>
                        <block_quote>
                            <paragraph>此属性表示身体的速度向量（以每秒像素为单位）。 <literal>move_and_slide()</literal> 会在碰撞时自动修改此值。</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>motion_mode</literal> - <emphasis>默认值：</emphasis> <literal>MOTION_MODE_GROUNDED</literal></paragraph>
                        <block_quote>
                            <paragraph>这个属性通常用于区分 <emphasis>横向滚动视角</emphasis> 和 <emphasis>俯视角</emphasis> 。默认情况下，你可以使用 <literal>is_on_floor()</literal> ， <literal>is_on_wall()</literal> 和 <literal>is_on_ceiling()</literal> 方法来检测物体与哪种表面接触，以及物体会与这些斜坡互动。当使用 <literal>MOTION_MODE_FLOATING</literal> 时，所有碰撞都会被认为是“墙”。</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>up_direction</literal> - <emphasis>默认值：</emphasis> <literal>Vector2( 0, -1 )</literal></paragraph>
                        <block_quote>
                            <paragraph>这个参数允许你定义哪些表面应该被引擎视为地板。设置这个参数然后使用 <literal>is_on_floor()</literal> ， <literal>is_on_wall()</literal> 和 <literal>is_on_ceiling()</literal> 方法来检测物体接触的表面类型。默认值意味着所有水平表面的顶部都被认为是“地面”。</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>floor_stop_on_slope</literal> - <emphasis>默认值：</emphasis> <literal>true</literal></paragraph>
                        <block_quote>
                            <paragraph>该参数可以防止物体站立不动时从斜坡上滑落.</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>wall_min_slide_angle</literal> - <emphasis>默认值：</emphasis> <literal>0.261799</literal> （以弧度表示，相当于 <literal>15</literal> 度）</paragraph>
                        <block_quote>
                            <paragraph>这是当身体在遇到斜坡时允许滑动的最小角度。</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>floor_max_angle</literal> - <emphasis>默认值：</emphasis> <literal>0.785398</literal> （以弧度表示，相当于 <literal>45</literal> 度）</paragraph>
                        <block_quote>
                            <paragraph>这是表面不再被视为 "地板" 之前的最大角度</paragraph>
                        </block_quote>
                    </list_item>
                </bullet_list>
                <paragraph>在特定情况下，还有许多其他属性可用于修改身体的行为。详情请参见 <reference internal="True" refuri="../../classes/class_characterbody2d#class-characterbody2d"><inline classes="std std-ref">CharacterBody2D</inline></reference> 文档。</paragraph>
            </section>
        </section>
        <section ids="detecting-collisions" names="detecting\ collisions 检测碰撞">
            <title>检测碰撞</title>
            <paragraph>当使用 <literal>move_and_collide()</literal> 时, 函数直接返回一个 <literal>KinematicCollision2D</literal> , 你可以在代码中使用这个.</paragraph>
            <paragraph>当使用 <literal>move_and_slide()</literal> 时，有可能发生多次碰撞，因为滑动响应也被计算在内。要处理这些碰撞，使用 <literal>get_slide_collision_count()</literal> 和 <literal>get_slide_collision()</literal>：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Using move_and_collide.
var collision = move_and_collide(velocity * delta)
if collision:
    print("I collided with ", collision.get_collider().name)

# Using move_and_slide.
move_and_slide()
for i in get_slide_collision_count():
    var collision = get_slide_collision(i)
    print("I collided with ", collision.get_collider().name)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Using MoveAndCollide.
var collision = MoveAndCollide(Velocity * (float)delta);
if (collision != null)
{
    GD.Print("I collided with ", ((Node)collision.GetCollider()).Name);
}

// Using MoveAndSlide.
MoveAndSlide();
for (int i = 0; i &lt; GetSlideCollisionCount(); i++)
{
    var collision = GetSlideCollision(i);
    GD.Print("I collided with ", ((Node)collision.GetCollider()).Name);
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph><title_reference>get_slide_collision_count()</title_reference> 只计算物体碰撞和改变方向的次数。</paragraph>
            </note>
            <paragraph>关于返回哪些碰撞数据, 请参见 <reference internal="True" refuri="../../classes/class_kinematiccollision2d#class-kinematiccollision2d"><inline classes="std std-ref">KinematicCollision2D</inline></reference> .</paragraph>
        </section>
        <section ids="which-movement-method-to-use" names="which\ movement\ method\ to\ use? 使用哪种移动方式？">
            <title>使用哪种移动方式？</title>
            <paragraph>Godot 新手的一个常见问题是：“你如何决定使用哪个移动函数？”通常，回答是 <literal>move_and_slide()</literal> ，因为它“更简单”，但情况不一定如此。有一种思路是， <literal>move_and_slide()</literal> 是一种特殊情况，而 <literal>move_and_collide()</literal> 更通用。例如，下面两个代码片段的结果是相同的碰撞响应：</paragraph>
            <image candidates="{'*': 'tutorials/physics/img/k2d_compare.gif'}" uri="tutorials/physics/img/k2d_compare.gif"></image>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># using move_and_collide
var collision = move_and_collide(velocity * delta)
if collision:
    velocity = velocity.slide(collision.get_normal())

# using move_and_slide
move_and_slide()</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// using MoveAndCollide
var collision = MoveAndCollide(Velocity * (float)delta);
if (collision != null)
{
    Velocity = Velocity.Slide(collision.GetNormal());
}

// using MoveAndSlide
MoveAndSlide();</literal_block>
                </div>
            </container>
            <paragraph>你用 <literal>move_and_slide()</literal> 做的任何事情都可以用 <literal>move_and_collide()</literal> 来完成, 但它可能需要更多的代码. 但是, 正如我们在下面的示例中将看到的, 有些情况下 <literal>move_and_slide()</literal> 不能提供你想要的响应.</paragraph>
            <paragraph>在上面的例子中， <literal>move_and_slide()</literal> 自动更改了 <literal>velocity</literal> 变量。这是因为当角色与环境发生碰撞时，函数会在内部重新计算速度，以反映减速的情况。</paragraph>
            <paragraph>例如, 如果角色倒在地上, 不希望它因为重力的影响而积累垂直速度, 而希望它的垂直速度重置为零.</paragraph>
            <paragraph><literal>move_and_slide()</literal> 将会在循环中多次重新计算运动物体的速度，以产生平滑的运动。默认情况下，他会移动角色并最多与环境碰撞5次。在这个过程结束时，角色的的新速度将会用于下一帧。</paragraph>
        </section>
        <section ids="examples" names="examples 示例">
            <title>示例</title>
            <paragraph>若要查看这些案例的实际效果，请下载示例项目：<reference name="character_body_2d_starter.zip" refuri="https://github.com/godotengine/godot-docs-project-starters/releases/download/latest-4.x/character_body_2d_starter.zip">character_body_2d_starter.zip</reference><target ids="character-body-2d-starter-zip" names="character_body_2d_starter.zip" refuri="https://github.com/godotengine/godot-docs-project-starters/releases/download/latest-4.x/character_body_2d_starter.zip"></target></paragraph>
            <section ids="movement-and-walls" names="movement\ and\ walls 移动和墙壁">
                <title>移动和墙壁</title>
                <paragraph>如果你已经下载了示例项目，这个例子在“basic_movement.tscn”中。</paragraph>
                <paragraph>在这个例子中，添加一个 <literal>CharacterBody2D</literal> ，并有两个子级： <literal>Sprite2D</literal> 和 <literal>CollisionShape2D</literal> 。使用 Godot 的 “icon.svg” 作为 Sprite2D 的纹理（将其从文件系统栏拖到 <literal>Sprite2D</literal> 的 <emphasis>Texture</emphasis> 属性）。在 <literal>CollisionShape2D</literal> 的 <emphasis>Shape</emphasis> 属性中，选择“New RectangleShape2D”，并将矩形的大小调整到适合sprite图像的大小。</paragraph>
                <note>
                    <paragraph>有关实现2D移动方案的示例, 请参阅 <reference internal="True" refuri="../2d/2d_movement#doc-2d-movement"><inline classes="std std-ref">2D 运动概述</inline></reference> .</paragraph>
                </note>
                <paragraph>将脚本附加到CharacterBody2D并添加以下代码：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var speed = 300

func get_input():
    var input_dir = Input.get_vector("ui_left", "ui_right", "ui_up", "ui_down")
    velocity = input_dir * speed

func _physics_process(delta):
    get_input()
    move_and_collide(velocity * delta)</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody2D : CharacterBody2D
{
    private int _speed = 300;

    public void GetInput()
    {
        Vector2 inputDir = Input.GetVector("ui_left", "ui_right", "ui_up", "ui_down");
        Velocity = inputDir * _speed;
    }

    public override void _PhysicsProcess(double delta)
    {
        GetInput();
        MoveAndCollide(Velocity * (float)delta);
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>运行这个场景，你会看到 <literal>move_and_collide()</literal> 按预期工作，沿着速度向量方向移动物体。现在让我们看看当你添加一些障碍时会发生什么。添加一个具有矩形碰撞形状的 <reference internal="True" refuri="../../classes/class_staticbody2d#class-staticbody2d"><inline classes="std std-ref">StaticBody2D</inline></reference> 。为了可见性，你可以使用Sprite2D，Polygon2D，或从“调试”菜单中打开“可见碰撞形状”。</paragraph>
                <paragraph>再次运行场景并尝试移动到障碍物上，你会看到 <literal>CharacterBody2D</literal> 无法穿过障碍物。 不过，当你以一个角度移动到障碍物上，你会发现障碍物就像胶水一样——感觉被卡住了。</paragraph>
                <paragraph>发生这种情况是因为没有 <emphasis>碰撞响应</emphasis> . <literal>move_and_collide()</literal> 在碰撞发生时停止物体的运动. 我们需要编写我们想要的碰撞响应.</paragraph>
                <paragraph>尝试将函数更改为 <literal>move_and_slide()</literal> 并再次运行。</paragraph>
                <paragraph><literal>move_and_slide()</literal> 提供了一个沿碰撞对象滑动物体的默认碰撞响应. 这对于许多游戏类型都很有用, 并且可能是获得所需行为所需的全部内容.</paragraph>
            </section>
            <section ids="bouncing-reflecting" names="bouncing/reflecting 弹跳/反射">
                <title>弹跳/反射</title>
                <paragraph>如果你不想要滑动碰撞响应怎么办？ 对于这个示例（示例项目中的 “bounce_and_collide.tscn”）， 我们有一个角色射击子弹，我们希望子弹从墙上反弹。</paragraph>
                <paragraph>此示例使用三个场景. 主场景包含游戏角色和墙壁. 子弹和墙是单独的场景, 以便它们可以实例化.</paragraph>
                <paragraph>游戏角色由 <literal>w</literal> 和 <literal>s</literal> 键控制前进和后退。瞄准使用鼠标指针。这是游戏角色的代码，使用 <literal>move_and_slide()</literal> ：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var Bullet = preload("res://bullet.tscn")
var speed = 200

func get_input():
    # Add these actions in Project Settings -&gt; Input Map.
    var input_dir = Input.get_axis("backward", "forward")
    velocity = transform.x * input_dir * speed
    if Input.is_action_just_pressed("shoot"):
        shoot()

func shoot():
    # "Muzzle" is a Marker2D placed at the barrel of the gun.
    var b = Bullet.instantiate()
    b.start($Muzzle.global_position, rotation)
    get_tree().root.add_child(b)

func _physics_process(delta):
    get_input()
    var dir = get_global_mouse_position() - global_position
    # Don't move if too close to the mouse pointer.
    if dir.length() &gt; 5:
        rotation = dir.angle()
        move_and_slide()</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody2D : CharacterBody2D
{
    private PackedScene _bullet = GD.Load&lt;PackedScene&gt;("res://Bullet.tscn");
    private int _speed = 200;

    public void GetInput()
    {
        // Add these actions in Project Settings -&gt; Input Map.
        float inputDir = Input.GetAxis("backward", "forward");
        Velocity = Transform.X * inputDir * _speed;
        if (Input.IsActionPressed("shoot"))
        {
            Shoot();
        }
    }

    public void Shoot()
    {
        // "Muzzle" is a Marker2D placed at the barrel of the gun.
        var b = (Bullet)_bullet.Instantiate();
        b.Start(GetNode&lt;Node2D&gt;("Muzzle").GlobalPosition, Rotation);
        GetTree().Root.AddChild(b);
    }

    public override void _PhysicsProcess(double delta)
    {
        GetInput();
        var dir = GetGlobalMousePosition() - GlobalPosition;
        // Don't move if too close to the mouse pointer.
        if (dir.Length() &gt; 5)
        {
            Rotation = dir.Angle();
            MoveAndSlide();
        }
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>子弹的代码:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var speed = 750

func start(_position, _direction):
    rotation = _direction
    position = _position
    velocity = Vector2(speed, 0).rotated(rotation)

func _physics_process(delta):
    var collision = move_and_collide(velocity * delta)
    if collision:
        velocity = velocity.bounce(collision.get_normal())
        if collision.get_collider().has_method("hit"):
            collision.get_collider().hit()

func _on_VisibilityNotifier2D_screen_exited():
    # Deletes the bullet when it exits the screen.
    queue_free()</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Bullet : CharacterBody2D
{
    public int _speed = 750;

    public void Start(Vector2 position, float direction)
    {
        Rotation = direction;
        Position = position;
        Velocity = new Vector2(speed, 0).Rotated(Rotation);
    }

    public override void _PhysicsProcess(double delta)
    {
        var collision = MoveAndCollide(Velocity * (float)delta);
        if (collision != null)
        {
            Velocity = Velocity.Bounce(collision.GetNormal());
            if (collision.GetCollider().HasMethod("Hit"))
            {
                collision.GetCollider().Call("Hit");
            }
        }
    }

    private void OnVisibilityNotifier2DScreenExited()
    {
        // Deletes the bullet when it exits the screen.
        QueueFree();
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>动作发生在 <literal>_physics_process()</literal> 中。在使用 <literal>move_and_collide()</literal> 后，如果发生碰撞，将返回一个 <literal>KinematicCollision2D</literal> 对象，否则，返回 <literal>null</literal> 。</paragraph>
                <paragraph>如果有一个返回的碰撞, 我们使用碰撞的 <literal>normal</literal> 来反映子弹的 <literal>velocity</literal> 和 <literal>Vector2.bounce()</literal> 方法.</paragraph>
                <paragraph>如果碰撞对象( <literal>collider</literal> )有一个 <literal>hit</literal> 方法, 我们也调用它. 在示例项目中, 我们为墙壁添加了一个颜色闪烁效果来演示这一点.</paragraph>
                <image candidates="{'*': 'tutorials/physics/img/k2d_bullet_bounce.gif'}" uri="tutorials/physics/img/k2d_bullet_bounce.gif"></image>
            </section>
            <section ids="platformer-movement" names="platformer\ movement 平台移动">
                <title>平台移动</title>
                <paragraph>让我们尝试一个更流行的示例：2D平台游戏。 <literal>move_and_slide()</literal> 非常适合快速创建一个功能性的角色控制器。如果你已下载示例项目，可以在“platformer.tscn”中找到它。</paragraph>
                <paragraph>在这个示例中，我们假设你的关卡由一个或多个 <literal>StaticBody2D</literal> 组成。它们可以是任何形状和大小。在示例项目中，我们使用 <reference internal="True" refuri="../../classes/class_polygon2d#class-polygon2d"><inline classes="std std-ref">Polygon2D</inline></reference> 来创建平台的形状。</paragraph>
                <paragraph>这是游戏角色物体的代码:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var speed = 300.0
var jump_speed = -400.0

# Get the gravity from the project settings so you can sync with rigid body nodes.
var gravity = ProjectSettings.get_setting("physics/2d/default_gravity")


func _physics_process(delta):
    # Add the gravity.
    velocity.y += gravity * delta

    # Handle Jump.
    if Input.is_action_just_pressed("jump") and is_on_floor():
        velocity.y = jump_speed

    # Get the input direction.
    var direction = Input.get_axis("ui_left", "ui_right")
    velocity.x = direction * speed

    move_and_slide()</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody2D : CharacterBody2D
{
    private float _speed = 100.0f;
    private float _jumpSpeed = -400.0f;

    // Get the gravity from the project settings so you can sync with rigid body nodes.
    public float Gravity = ProjectSettings.GetSetting("physics/2d/default_gravity").AsSingle();

    public override void _PhysicsProcess(double delta)
    {
        Vector2 velocity = Velocity;

        // Add the gravity.
        velocity.Y += Gravity * (float)delta;

        // Handle jump.
        if (Input.IsActionJustPressed("jump") &amp;&amp; IsOnFloor())
            velocity.Y = _jumpSpeed;

        // Get the input direction.
        float direction = Input.GetAxis("ui_left", "ui_right");
        velocity.X = direction * _speed;

        Velocity = velocity;
        MoveAndSlide();
    }
}</literal_block>
                    </div>
                </container>
                <image candidates="{'*': 'tutorials/physics/img/k2d_platform.gif'}" uri="tutorials/physics/img/k2d_platform.gif"></image>
                <paragraph>在本段代码实现中，我们调用了 <literal>move_and_slide()</literal> 方法，该方法根据物体的速度向量对物体进行平移，并在碰撞检测到地面或平台等碰撞体时，使物体沿碰撞表面滑动。此外，我们还利用了 <literal>is_on_floor()</literal> 方法来判断角色是否处于可跳跃状态。若缺少这一逻辑判断，角色将能够在非地面状态下执行跳跃动作；这种情况在开发如 “Flappy Bird” 这类的飞行躲避游戏中可能是可取的，但在开发平台跳跃类型的游戏中则不适宜。</paragraph>
                <paragraph>一个完整的平台游戏角色还有很多内容：加速度、二段跳、土狼时间，等等。上面的代码只是一个起点。你可以在此基础上扩展，以得到你的项目所需的任何运动行为。</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
