<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/physics/using_character_body_2d.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-character-body-2d"></target>
    <section ids="using-characterbody2d-3d doc-using-character-body-2d" names="using\ characterbody2d/3d doc_using_character_body_2d">
        <title>Using CharacterBody2D/3D</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>Godot offers several collision objects to provide both collision detection
                and response. Trying to decide which one to use for your project can be confusing.
                You can avoid problems and simplify development if you understand how each of them
                works and what their pros and cons are. In this tutorial, we'll look at the
                <reference internal="True" refuri="../../classes/class_characterbody2d#class-characterbody2d"><inline classes="std std-ref">CharacterBody2D</inline></reference> node and show some examples
                of how to use it.</paragraph>
            <note>
                <paragraph>While this document uses <literal>CharacterBody2D</literal> in its examples, the same
                    concepts apply in 3D as well.</paragraph>
            </note>
        </section>
        <section ids="what-is-a-character-body" names="what\ is\ a\ character\ body?">
            <title>What is a character body?</title>
            <paragraph><literal>CharacterBody2D</literal> is for implementing bodies that are controlled via code.
                Character bodies detect collisions with other bodies when moving, but are not affected by
                engine physics properties, like gravity or friction. While this means that you
                have to write some code to create their behavior, it also means you have more
                precise control over how they move and react.</paragraph>
            <note>
                <paragraph>This document assumes you're familiar with Godot's various physics
                    bodies. Please read <reference internal="True" refuri="physics_introduction#doc-physics-introduction"><inline classes="std std-ref">Physics introduction</inline></reference> first, for an overview
                    of the physics options.</paragraph>
            </note>
            <tip>
                <paragraph>A <title_reference>CharacterBody2D</title_reference> can be affected by gravity and other forces,
                    but you must calculate the movement in code. The physics engine will
                    not move a <title_reference>CharacterBody2D</title_reference>.</paragraph>
            </tip>
        </section>
        <section ids="movement-and-collision" names="movement\ and\ collision">
            <title>Movement and collision</title>
            <paragraph>When moving a <literal>CharacterBody2D</literal>, you should not set its <literal>position</literal> property
                directly. Instead, you use the <literal>move_and_collide()</literal> or <literal>move_and_slide()</literal> methods.
                These methods move the body along a given vector and detect collisions.</paragraph>
            <warning>
                <paragraph>You should handle physics body movement in the <literal>_physics_process()</literal> callback.</paragraph>
            </warning>
            <paragraph>The two movement methods serve different purposes, and later in this tutorial, you'll
                see examples of how they work.</paragraph>
            <section ids="move-and-collide" names="move_and_collide">
                <title>move_and_collide</title>
                <paragraph>This method takes one required parameter: a <reference internal="True" refuri="../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> indicating
                    the body's relative movement. Typically, this is your velocity vector multiplied by the
                    frame timestep (<literal>delta</literal>). If the engine detects a collision anywhere along
                    this vector, the body will immediately stop moving. If this happens, the
                    method will return a <reference internal="True" refuri="../../classes/class_kinematiccollision2d#class-kinematiccollision2d"><inline classes="std std-ref">KinematicCollision2D</inline></reference> object.</paragraph>
                <paragraph><literal>KinematicCollision2D</literal> is an object containing data about the collision
                    and the colliding object. Using this data, you can calculate your collision
                    response.</paragraph>
                <paragraph><literal>move_and_collide</literal> is most useful when you just want to move the body and
                    detect collision, but don't need any automatic collision response. For example,
                    if you need a bullet that ricochets off a wall, you can directly change the angle
                    of the velocity when you detect a collision. See below for an example.</paragraph>
            </section>
            <section ids="move-and-slide" names="move_and_slide">
                <title>move_and_slide</title>
                <paragraph>The <literal>move_and_slide()</literal> method is intended to simplify the collision
                    response in the common case where you want one body to slide along the other.
                    It is especially useful in platformers or top-down games, for example.</paragraph>
                <paragraph>When calling <literal>move_and_slide()</literal>, the function uses a number of node properties
                    to calculate its slide behavior. These properties can be found in the Inspector,
                    or set in code.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><literal>velocity</literal> - <emphasis>default value:</emphasis> <literal>Vector2( 0, 0 )</literal></paragraph>
                        <block_quote>
                            <paragraph>This property represents the body's velocity vector in pixels per second.
                                <literal>move_and_slide()</literal> will modify this value automatically when colliding.</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>motion_mode</literal> - <emphasis>default value:</emphasis> <literal>MOTION_MODE_GROUNDED</literal></paragraph>
                        <block_quote>
                            <paragraph>This property is typically used to distinguish between side-scrolling and
                                top-down movement. When using the default value, you can use the <literal>is_on_floor()</literal>,
                                <literal>is_on_wall()</literal>, and <literal>is_on_ceiling()</literal> methods to detect what type of
                                surface the body is in contact with, and the body will interact with slopes.
                                When using <literal>MOTION_MODE_FLOATING</literal>, all collisions will be considered "walls".</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>up_direction</literal> - <emphasis>default value:</emphasis> <literal>Vector2( 0, -1 )</literal></paragraph>
                        <block_quote>
                            <paragraph>This property allows you to define what surfaces the engine should consider
                                being the floor. Its value lets you use the <literal>is_on_floor()</literal>, <literal>is_on_wall()</literal>,
                                and <literal>is_on_ceiling()</literal> methods to detect what type of surface the body is
                                in contact with. The default value means that the top side of horizontal surfaces
                                will be considered "ground".</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>floor_stop_on_slope</literal> - <emphasis>default value:</emphasis> <literal>true</literal></paragraph>
                        <block_quote>
                            <paragraph>This parameter prevents a body from sliding down slopes when standing still.</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>wall_min_slide_angle</literal> - <emphasis>default value:</emphasis> <literal>0.261799</literal> (in radians, equivalent to <literal>15</literal> degrees)</paragraph>
                        <block_quote>
                            <paragraph>This is the minimum angle where the body is allowed to slide when it hits a
                                slope.</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>floor_max_angle</literal> - <emphasis>default value:</emphasis> <literal>0.785398</literal> (in radians, equivalent to <literal>45</literal> degrees)</paragraph>
                        <block_quote>
                            <paragraph>This parameter is the maximum angle before a surface is no longer considered a "floor."</paragraph>
                        </block_quote>
                    </list_item>
                </bullet_list>
                <paragraph>There are many other properties that can be used to modify the body's behavior under
                    specific circumstances. See the <reference internal="True" refuri="../../classes/class_characterbody2d#class-characterbody2d"><inline classes="std std-ref">CharacterBody2D</inline></reference> docs
                    for full details.</paragraph>
            </section>
        </section>
        <section ids="detecting-collisions" names="detecting\ collisions">
            <title>Detecting collisions</title>
            <paragraph>When using <literal>move_and_collide()</literal> the function returns a <literal>KinematicCollision2D</literal>
                directly, and you can use this in your code.</paragraph>
            <paragraph>When using <literal>move_and_slide()</literal> it's possible to have multiple collisions occur,
                as the slide response is calculated. To process these collisions, use <literal>get_slide_collision_count()</literal>
                and <literal>get_slide_collision()</literal>:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Using move_and_collide.
var collision = move_and_collide(velocity * delta)
if collision:
    print("I collided with ", collision.get_collider().name)

# Using move_and_slide.
move_and_slide()
for i in get_slide_collision_count():
    var collision = get_slide_collision(i)
    print("I collided with ", collision.get_collider().name)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Using MoveAndCollide.
var collision = MoveAndCollide(Velocity * (float)delta);
if (collision != null)
{
    GD.Print("I collided with ", ((Node)collision.GetCollider()).Name);
}

// Using MoveAndSlide.
MoveAndSlide();
for (int i = 0; i &lt; GetSlideCollisionCount(); i++)
{
    var collision = GetSlideCollision(i);
    GD.Print("I collided with ", ((Node)collision.GetCollider()).Name);
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph><title_reference>get_slide_collision_count()</title_reference> only counts times the body has collided and changed direction.</paragraph>
            </note>
            <paragraph>See <reference internal="True" refuri="../../classes/class_kinematiccollision2d#class-kinematiccollision2d"><inline classes="std std-ref">KinematicCollision2D</inline></reference> for details on what
                collision data is returned.</paragraph>
        </section>
        <section ids="which-movement-method-to-use" names="which\ movement\ method\ to\ use?">
            <title>Which movement method to use?</title>
            <paragraph>A common question from new Godot users is: "How do you decide which movement
                function to use?" Often, the response is to use <literal>move_and_slide()</literal> because
                it seems simpler, but this is not necessarily the case. One way to think of it
                is that <literal>move_and_slide()</literal> is a special case, and <literal>move_and_collide()</literal>
                is more general. For example, the following two code snippets result in
                the same collision response:</paragraph>
            <image candidates="{'*': 'tutorials/physics/img/k2d_compare.gif'}" original_uri="img/k2d_compare.gif" uri="tutorials/physics/img/k2d_compare.gif"></image>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># using move_and_collide
var collision = move_and_collide(velocity * delta)
if collision:
    velocity = velocity.slide(collision.get_normal())

# using move_and_slide
move_and_slide()</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// using MoveAndCollide
var collision = MoveAndCollide(Velocity * (float)delta);
if (collision != null)
{
    Velocity = Velocity.Slide(collision.GetNormal());
}

// using MoveAndSlide
MoveAndSlide();</literal_block>
                </div>
            </container>
            <paragraph>Anything you do with <literal>move_and_slide()</literal> can also be done with <literal>move_and_collide()</literal>,
                but it might take a little more code. However, as we'll see in the examples below,
                there are cases where <literal>move_and_slide()</literal> doesn't provide the response you want.</paragraph>
            <paragraph>In the example above, <literal>move_and_slide()</literal> automatically alters the <literal>velocity</literal>
                variable. This is because when the character collides with the environment,
                the function recalculates the speed internally to reflect
                the slowdown.</paragraph>
            <paragraph>For example, if your character fell on the floor, you don't want it to
                accumulate vertical speed due to the effect of gravity. Instead, you want its
                vertical speed to reset to zero.</paragraph>
            <paragraph><literal>move_and_slide()</literal> may also recalculate the kinematic body's velocity several
                times in a loop as, to produce a smooth motion, it moves the character and
                collides up to five times by default. At the end of the process, the character's
                new velocity is available for use on the next frame.</paragraph>
        </section>
        <section ids="examples" names="examples">
            <title>Examples</title>
            <paragraph>To see these examples in action, download the sample project:
                <reference name="character_body_2d_starter.zip" refuri="https://github.com/godotengine/godot-docs-project-starters/releases/download/latest-4.x/character_body_2d_starter.zip">character_body_2d_starter.zip</reference><target ids="character-body-2d-starter-zip" names="character_body_2d_starter.zip" refuri="https://github.com/godotengine/godot-docs-project-starters/releases/download/latest-4.x/character_body_2d_starter.zip"></target></paragraph>
            <section ids="movement-and-walls" names="movement\ and\ walls">
                <title>Movement and walls</title>
                <paragraph>If you've downloaded the sample project, this example is in "basic_movement.tscn".</paragraph>
                <paragraph>For this example, add a <literal>CharacterBody2D</literal> with two children: a <literal>Sprite2D</literal> and a
                    <literal>CollisionShape2D</literal>. Use the Godot "icon.svg" as the Sprite2D's texture (drag it
                    from the Filesystem dock to the <emphasis>Texture</emphasis> property of the <literal>Sprite2D</literal>). In the
                    <literal>CollisionShape2D</literal>'s <emphasis>Shape</emphasis> property, select "New RectangleShape2D" and
                    size the rectangle to fit over the sprite image.</paragraph>
                <note>
                    <paragraph>See <reference internal="True" refuri="../2d/2d_movement#doc-2d-movement"><inline classes="std std-ref">2D movement overview</inline></reference> for examples of implementing 2D movement schemes.</paragraph>
                </note>
                <paragraph>Attach a script to the CharacterBody2D and add the following code:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var speed = 300

func get_input():
    var input_dir = Input.get_vector("ui_left", "ui_right", "ui_up", "ui_down")
    velocity = input_dir * speed

func _physics_process(delta):
    get_input()
    move_and_collide(velocity * delta)</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody2D : CharacterBody2D
{
    private int _speed = 300;

    public void GetInput()
    {
        Vector2 inputDir = Input.GetVector("ui_left", "ui_right", "ui_up", "ui_down");
        Velocity = inputDir * _speed;
    }

    public override void _PhysicsProcess(double delta)
    {
        GetInput();
        MoveAndCollide(Velocity * (float)delta);
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>Run this scene and you'll see that <literal>move_and_collide()</literal> works as expected, moving
                    the body along the velocity vector. Now let's see what happens when you add
                    some obstacles. Add a <reference internal="True" refuri="../../classes/class_staticbody2d#class-staticbody2d"><inline classes="std std-ref">StaticBody2D</inline></reference> with a
                    rectangular collision shape. For visibility, you can use a Sprite2D, a
                    Polygon2D, or turn on "Visible Collision Shapes" from the "Debug" menu.</paragraph>
                <paragraph>Run the scene again and try moving into the obstacle. You'll see that the <literal>CharacterBody2D</literal>
                    can't penetrate the obstacle. However, try moving into the obstacle at an angle and
                    you'll find that the obstacle acts like glue - it feels like the body gets stuck.</paragraph>
                <paragraph>This happens because there is no <emphasis>collision response</emphasis>. <literal>move_and_collide()</literal> stops
                    the body's movement when a collision occurs. We need to code whatever response we
                    want from the collision.</paragraph>
                <paragraph>Try changing the function to <literal>move_and_slide()</literal> and running again.</paragraph>
                <paragraph><literal>move_and_slide()</literal> provides a default collision response of sliding the body along the
                    collision object. This is useful for a great many game types, and may be all you need
                    to get the behavior you want.</paragraph>
            </section>
            <section ids="bouncing-reflecting" names="bouncing/reflecting">
                <title>Bouncing/reflecting</title>
                <paragraph>What if you don't want a sliding collision response? For this example ("bounce_and_collide.tscn"
                    in the sample project), we have a character shooting bullets and we want the bullets to
                    bounce off the walls.</paragraph>
                <paragraph>This example uses three scenes. The main scene contains the Player and Walls.
                    The Bullet and Wall are separate scenes so that they can be instanced.</paragraph>
                <paragraph>The Player is controlled by the <literal>w</literal> and <literal>s</literal> keys for forward and back. Aiming
                    uses the mouse pointer. Here is the code for the Player, using <literal>move_and_slide()</literal>:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var Bullet = preload("res://bullet.tscn")
var speed = 200

func get_input():
    # Add these actions in Project Settings -&gt; Input Map.
    var input_dir = Input.get_axis("backward", "forward")
    velocity = transform.x * input_dir * speed
    if Input.is_action_just_pressed("shoot"):
        shoot()

func shoot():
    # "Muzzle" is a Marker2D placed at the barrel of the gun.
    var b = Bullet.instantiate()
    b.start($Muzzle.global_position, rotation)
    get_tree().root.add_child(b)

func _physics_process(delta):
    get_input()
    var dir = get_global_mouse_position() - global_position
    # Don't move if too close to the mouse pointer.
    if dir.length() &gt; 5:
        rotation = dir.angle()
        move_and_slide()</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody2D : CharacterBody2D
{
    private PackedScene _bullet = GD.Load&lt;PackedScene&gt;("res://Bullet.tscn");
    private int _speed = 200;

    public void GetInput()
    {
        // Add these actions in Project Settings -&gt; Input Map.
        float inputDir = Input.GetAxis("backward", "forward");
        Velocity = Transform.X * inputDir * _speed;
        if (Input.IsActionPressed("shoot"))
        {
            Shoot();
        }
    }

    public void Shoot()
    {
        // "Muzzle" is a Marker2D placed at the barrel of the gun.
        var b = (Bullet)_bullet.Instantiate();
        b.Start(GetNode&lt;Node2D&gt;("Muzzle").GlobalPosition, Rotation);
        GetTree().Root.AddChild(b);
    }

    public override void _PhysicsProcess(double delta)
    {
        GetInput();
        var dir = GetGlobalMousePosition() - GlobalPosition;
        // Don't move if too close to the mouse pointer.
        if (dir.Length() &gt; 5)
        {
            Rotation = dir.Angle();
            MoveAndSlide();
        }
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>And the code for the Bullet:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var speed = 750

func start(_position, _direction):
    rotation = _direction
    position = _position
    velocity = Vector2(speed, 0).rotated(rotation)

func _physics_process(delta):
    var collision = move_and_collide(velocity * delta)
    if collision:
        velocity = velocity.bounce(collision.get_normal())
        if collision.get_collider().has_method("hit"):
            collision.get_collider().hit()

func _on_VisibilityNotifier2D_screen_exited():
    # Deletes the bullet when it exits the screen.
    queue_free()</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Bullet : CharacterBody2D
{
    public int _speed = 750;

    public void Start(Vector2 position, float direction)
    {
        Rotation = direction;
        Position = position;
        Velocity = new Vector2(speed, 0).Rotated(Rotation);
    }

    public override void _PhysicsProcess(double delta)
    {
        var collision = MoveAndCollide(Velocity * (float)delta);
        if (collision != null)
        {
            Velocity = Velocity.Bounce(collision.GetNormal());
            if (collision.GetCollider().HasMethod("Hit"))
            {
                collision.GetCollider().Call("Hit");
            }
        }
    }

    private void OnVisibilityNotifier2DScreenExited()
    {
        // Deletes the bullet when it exits the screen.
        QueueFree();
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>The action happens in <literal>_physics_process()</literal>. After using <literal>move_and_collide()</literal>, if a
                    collision occurs, a <literal>KinematicCollision2D</literal> object is returned (otherwise, the return
                    is <literal>null</literal>).</paragraph>
                <paragraph>If there is a returned collision, we use the <literal>normal</literal> of the collision to reflect
                    the bullet's <literal>velocity</literal> with the <literal>Vector2.bounce()</literal> method.</paragraph>
                <paragraph>If the colliding object (<literal>collider</literal>) has a <literal>hit</literal> method,
                    we also call it. In the example project, we've added a flashing color effect to
                    the Wall to demonstrate this.</paragraph>
                <image candidates="{'*': 'tutorials/physics/img/k2d_bullet_bounce.gif'}" original_uri="img/k2d_bullet_bounce.gif" uri="tutorials/physics/img/k2d_bullet_bounce.gif"></image>
            </section>
            <section ids="platformer-movement" names="platformer\ movement">
                <title>Platformer movement</title>
                <paragraph>Let's try one more popular example: the 2D platformer. <literal>move_and_slide()</literal>
                    is ideal for quickly getting a functional character controller up and running.
                    If you've downloaded the sample project, you can find this in "platformer.tscn".</paragraph>
                <paragraph>For this example, we'll assume you have a level made of one or more <literal>StaticBody2D</literal>
                    objects. They can be any shape and size. In the sample project, we're using
                    <reference internal="True" refuri="../../classes/class_polygon2d#class-polygon2d"><inline classes="std std-ref">Polygon2D</inline></reference> to create the platform shapes.</paragraph>
                <paragraph>Here's the code for the player body:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var speed = 300.0
var jump_speed = -400.0

# Get the gravity from the project settings so you can sync with rigid body nodes.
var gravity = ProjectSettings.get_setting("physics/2d/default_gravity")


func _physics_process(delta):
    # Add the gravity.
    velocity.y += gravity * delta

    # Handle Jump.
    if Input.is_action_just_pressed("jump") and is_on_floor():
        velocity.y = jump_speed

    # Get the input direction.
    var direction = Input.get_axis("ui_left", "ui_right")
    velocity.x = direction * speed

    move_and_slide()</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody2D : CharacterBody2D
{
    private float _speed = 100.0f;
    private float _jumpSpeed = -400.0f;

    // Get the gravity from the project settings so you can sync with rigid body nodes.
    public float Gravity = ProjectSettings.GetSetting("physics/2d/default_gravity").AsSingle();

    public override void _PhysicsProcess(double delta)
    {
        Vector2 velocity = Velocity;

        // Add the gravity.
        velocity.Y += Gravity * (float)delta;

        // Handle jump.
        if (Input.IsActionJustPressed("jump") &amp;&amp; IsOnFloor())
        {
            velocity.Y = _jumpSpeed;
        }

        // Get the input direction.
        float direction = Input.GetAxis("ui_left", "ui_right");
        velocity.X = direction * _speed;

        Velocity = velocity;
        MoveAndSlide();
    }
}</literal_block>
                    </div>
                </container>
                <image candidates="{'*': 'tutorials/physics/img/k2d_platform.gif'}" original_uri="img/k2d_platform.gif" uri="tutorials/physics/img/k2d_platform.gif"></image>
                <paragraph>In this code we're using <literal>move_and_slide()</literal> as described above - to move the body
                    along its velocity vector, sliding along any collision surfaces such as the ground
                    or a platform. We're also using <literal>is_on_floor()</literal> to check if a jump should be
                    allowed. Without this, you'd be able to "jump" in midair; great if you're making
                    Flappy Bird, but not for a platformer game.</paragraph>
                <paragraph>There is a lot more that goes into a complete platformer character: acceleration,
                    double-jumps, coyote-time, and many more. The code above is just a starting point.
                    You can use it as a base to expand into whatever movement behavior you need for
                    your own projects.</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
