<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/physics/using_character_body_2d.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-character-body-2d"></target>
    <section ids="using-characterbody2d-3d doc-using-character-body-2d" names="using\ characterbody2d/3d 使用\ characterbody2d/3d doc_using_character_body_2d">
        <title>使用 CharacterBody2D/3D</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>Godot 提供了多种碰撞对象来提供碰撞检测和响应。试图决定在你的项目中使用哪一个可能会让你感到困惑。如果你了解它们中的每一个是如何工作的，以及它们的优点和缺点是什么，你就可以避免问题并简化开发。在本教程中，我们将查看 <reference internal="True" refuri="../../classes/class_characterbody2d#class-characterbody2d"><inline classes="std std-ref">CharacterBody2D</inline></reference> 节点，并展示一些如何使用它的例子.</paragraph>
            <note>
                <paragraph>虽然本文档在其示例中使用 <literal>CharacterBody2D</literal> ，但相同的概念也适用于 3D。</paragraph>
            </note>
        </section>
        <section ids="what-is-a-character-body" names="what\ is\ a\ character\ body? 什么是角色体？">
            <title>什么是角色体？</title>
            <paragraph><literal>CharacterBody2D</literal> 用于实现通过代码控制的物体。Character bodies 在移动时可以检测到与其他物体的碰撞，但不受引擎物理属性（如重力、摩擦力等）的影响。虽然这意味着你必须编写一些代码来创建它们的行为，但这也意味着你可以更精确地控制它们如何移动和反应。</paragraph>
            <note>
                <paragraph>本文假设你熟悉 Godot 中的各种物理体。否则请先阅读 <reference internal="True" refuri="physics_introduction#doc-physics-introduction"><inline classes="std std-ref">物理介绍</inline></reference> 。</paragraph>
            </note>
            <tip>
                <paragraph><title_reference>CharacterBody2D</title_reference> 可以受到重力和其他力的影响，但你必须在代码中计算它的运动。物理引擎不会移动 <title_reference>CharacterBody2D</title_reference> 。</paragraph>
            </tip>
        </section>
        <section ids="movement-and-collision" names="movement\ and\ collision 运动与碰撞">
            <title>运动与碰撞</title>
            <paragraph>当移动一个 <literal>CharacterBody2D</literal> 时，你不应该直接设置它的 <literal>position</literal> 属性，而应该使用 <literal>move_and_collide()</literal> 或 <literal>move_and_slide()</literal> 方法。这些方法沿着给定的向量移动物体，并且检测碰撞。</paragraph>
            <warning>
                <paragraph>你应该在 <literal>_physics_process()</literal> 回调中处理物理体的运动。</paragraph>
            </warning>
            <paragraph>这两种运动方法有不同的作用, 在后面的教程中, 你会看到它们如何工作的例子.</paragraph>
            <section ids="move-and-collide" names="move_and_collide">
                <title>move_and_collide</title>
                <paragraph>这个方法需要一个 <reference internal="True" refuri="../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> 参数以表示物体的相对运动。通常，这是速度向量乘以帧时间步长( <literal>delta</literal> )。如果引擎在沿着此向量方向的任何位置检测到碰撞，则物体将立即停止移动。如果发生这种情况，该方法将返回一个 <reference internal="True" refuri="../../classes/class_kinematiccollision2d#class-kinematiccollision2d"><inline classes="std std-ref">KinematicCollision2D</inline></reference> 对象。</paragraph>
                <paragraph><literal>KinematicCollision2D</literal> 是一个包含碰撞和碰撞对象数据的对象. 使用这些数据, 你可以计算出你的碰撞响应.</paragraph>
                <paragraph>当你只想移动物体并检测碰撞，并且不需要任何自动碰撞响应时， <literal>move_and_collide</literal> 最有用。例如，如果你需要一颗从墙上弹开的子弹，你可以在检测到碰撞时直接更改速度角度。请参阅下面的示例。</paragraph>
            </section>
            <section ids="move-and-slide" names="move_and_slide">
                <title>move_and_slide</title>
                <paragraph><literal>move_and_slide()</literal> 方法旨在简化常见情况下的碰撞响应, 即你希望一个物体沿着另一个物体滑动. 例如, 在平台游戏或自上而下的游戏中, 它特别有用.</paragraph>
                <paragraph>当调用 <literal>move_and_slide()</literal> 时，该函数使用许多节点属性来计算其滑动行为。这些属性可以在检查器中找到，或在代码中设置。</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><literal>velocity</literal> - <emphasis>default value:</emphasis> <literal>Vector2( 0, 0 )</literal></paragraph>
                        <block_quote>
                            <paragraph>此属性表示身体的速度向量（以每秒像素为单位）。 <literal>move_and_slide()</literal> 会在碰撞时自动修改此值。</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>motion_mode</literal> - <emphasis>default value:</emphasis> <literal>MOTION_MODE_GROUNDED</literal></paragraph>
                        <block_quote>
                            <paragraph>This property is typically used to distinguish between side-scrolling and
                                top-down movement. When using the default value, you can use the <literal>is_on_floor()</literal>,
                                <literal>is_on_wall()</literal>, and <literal>is_on_ceiling()</literal> methods to detect what type of
                                surface the body is in contact with, and the body will interact with slopes.
                                When using <literal>MOTION_MODE_FLOATING</literal>, all collisions will be considered "walls".</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>up_direction</literal> - <emphasis>default value:</emphasis> <literal>Vector2( 0, -1 )</literal></paragraph>
                        <block_quote>
                            <paragraph>This property allows you to define what surfaces the engine should consider
                                being the floor. Its value lets you use the <literal>is_on_floor()</literal>, <literal>is_on_wall()</literal>,
                                and <literal>is_on_ceiling()</literal> methods to detect what type of surface the body is
                                in contact with. The default value means that the top side of horizontal surfaces
                                will be considered "ground".</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>floor_stop_on_slope</literal> - <emphasis>default value:</emphasis> <literal>true</literal></paragraph>
                        <block_quote>
                            <paragraph>该参数可以防止物体站立不动时从斜坡上滑落.</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>wall_min_slide_angle</literal> - <emphasis>default value:</emphasis> <literal>0.261799</literal> (in radians, equivalent to <literal>15</literal> degrees)</paragraph>
                        <block_quote>
                            <paragraph>这是当身体在遇到斜坡时允许滑动的最小角度。</paragraph>
                        </block_quote>
                    </list_item>
                    <list_item>
                        <paragraph><literal>floor_max_angle</literal> - <emphasis>默认值:</emphasis> <literal>0.785398</literal> (以弧度表示, 相当于 <literal>45</literal> 度)</paragraph>
                        <block_quote>
                            <paragraph>这是表面不再被视为 "地板" 之前的最大角度</paragraph>
                        </block_quote>
                    </list_item>
                </bullet_list>
                <paragraph>在特定情况下，还有许多其他属性可用于修改身体的行为。详情请参见 <reference internal="True" refuri="../../classes/class_characterbody2d#class-characterbody2d"><inline classes="std std-ref">CharacterBody2D</inline></reference> 文档。</paragraph>
            </section>
        </section>
        <section ids="detecting-collisions" names="detecting\ collisions 检测碰撞">
            <title>检测碰撞</title>
            <paragraph>当使用 <literal>move_and_collide()</literal> 时, 函数直接返回一个 <literal>KinematicCollision2D</literal> , 你可以在代码中使用这个.</paragraph>
            <paragraph>When using <literal>move_and_slide()</literal> it's possible to have multiple collisions occur,
                as the slide response is calculated. To process these collisions, use <literal>get_slide_collision_count()</literal>
                and <literal>get_slide_collision()</literal>:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Using move_and_collide.
var collision = move_and_collide(velocity * delta)
if collision:
    print("I collided with ", collision.get_collider().name)

# Using move_and_slide.
move_and_slide()
for i in get_slide_collision_count():
    var collision = get_slide_collision(i)
    print("I collided with ", collision.get_collider().name)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Using MoveAndCollide.
var collision = MoveAndCollide(Velocity * (float)delta);
if (collision != null)
{
    GD.Print("I collided with ", ((Node)collision.GetCollider()).Name);
}

// Using MoveAndSlide.
MoveAndSlide();
for (int i = 0; i &lt; GetSlideCollisionCount(); i++)
{
    var collision = GetSlideCollision(i);
    GD.Print("I collided with ", ((Node)collision.GetCollider()).Name);
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph><title_reference>get_slide_collision_count()</title_reference> only counts times the body has collided and changed direction.</paragraph>
            </note>
            <paragraph>关于返回哪些碰撞数据, 请参见 <reference internal="True" refuri="../../classes/class_kinematiccollision2d#class-kinematiccollision2d"><inline classes="std std-ref">KinematicCollision2D</inline></reference> .</paragraph>
        </section>
        <section ids="which-movement-method-to-use" names="which\ movement\ method\ to\ use? 使用哪种移动方式？">
            <title>使用哪种移动方式？</title>
            <paragraph>A common question from new Godot users is: "How do you decide which movement
                function to use?" Often, the response is to use <literal>move_and_slide()</literal> because
                it seems simpler, but this is not necessarily the case. One way to think of it
                is that <literal>move_and_slide()</literal> is a special case, and <literal>move_and_collide()</literal>
                is more general. For example, the following two code snippets result in
                the same collision response:</paragraph>
            <image candidates="{'*': 'tutorials/physics/img/k2d_compare.gif'}" uri="tutorials/physics/img/k2d_compare.gif"></image>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># using move_and_collide
var collision = move_and_collide(velocity * delta)
if collision:
    velocity = velocity.slide(collision.get_normal())

# using move_and_slide
move_and_slide()</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// using MoveAndCollide
var collision = MoveAndCollide(Velocity * (float)delta);
if (collision != null)
{
    Velocity = Velocity.Slide(collision.GetNormal());
}

// using MoveAndSlide
MoveAndSlide();</literal_block>
                </div>
            </container>
            <paragraph>你用 <literal>move_and_slide()</literal> 做的任何事情都可以用 <literal>move_and_collide()</literal> 来完成, 但它可能需要更多的代码. 但是, 正如我们在下面的示例中将看到的, 有些情况下 <literal>move_and_slide()</literal> 不能提供你想要的响应.</paragraph>
            <paragraph>In the example above, <literal>move_and_slide()</literal> automatically alters the <literal>velocity</literal>
                variable. This is because when the character collides with the environment,
                the function recalculates the speed internally to reflect
                the slowdown.</paragraph>
            <paragraph>例如, 如果角色倒在地上, 不希望它因为重力的影响而积累垂直速度, 而希望它的垂直速度重置为零.</paragraph>
            <paragraph><literal>move_and_slide()</literal> may also recalculate the kinematic body's velocity several
                times in a loop as, to produce a smooth motion, it moves the character and
                collides up to five times by default. At the end of the process, the character's
                new velocity is available for use on the next frame.</paragraph>
        </section>
        <section ids="examples" names="examples 示例">
            <title>示例</title>
            <paragraph>若要查看这些案例的实际效果，请下载示例项目：<reference name="character_body_2d_starter.zip" refuri="https://github.com/godotengine/godot-docs-project-starters/releases/download/latest-4.x/character_body_2d_starter.zip">character_body_2d_starter.zip</reference><target ids="character-body-2d-starter-zip" names="character_body_2d_starter.zip" refuri="https://github.com/godotengine/godot-docs-project-starters/releases/download/latest-4.x/character_body_2d_starter.zip"></target></paragraph>
            <section ids="movement-and-walls" names="movement\ and\ walls 移动和墙壁">
                <title>移动和墙壁</title>
                <paragraph>If you've downloaded the sample project, this example is in "basic_movement.tscn".</paragraph>
                <paragraph>For this example, add a <literal>CharacterBody2D</literal> with two children: a <literal>Sprite2D</literal> and a
                    <literal>CollisionShape2D</literal>. Use the Godot "icon.svg" as the Sprite2D's texture (drag it
                    from the Filesystem dock to the <emphasis>Texture</emphasis> property of the <literal>Sprite2D</literal>). In the
                    <literal>CollisionShape2D</literal>'s <emphasis>Shape</emphasis> property, select "New RectangleShape2D" and
                    size the rectangle to fit over the sprite image.</paragraph>
                <note>
                    <paragraph>有关实现2D移动方案的示例, 请参阅 <reference internal="True" refuri="../2d/2d_movement#doc-2d-movement"><inline classes="std std-ref">2D 运动概述</inline></reference> .</paragraph>
                </note>
                <paragraph>Attach a script to the CharacterBody2D and add the following code:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var speed = 300

func get_input():
    var input_dir = Input.get_vector("ui_left", "ui_right", "ui_up", "ui_down")
    velocity = input_dir * speed

func _physics_process(delta):
    get_input()
    move_and_collide(velocity * delta)</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody2D : CharacterBody2D
{
    private int _speed = 300;

    public void GetInput()
    {
        Vector2 inputDir = Input.GetVector("ui_left", "ui_right", "ui_up", "ui_down");
        Velocity = inputDir * _speed;
    }

    public override void _PhysicsProcess(double delta)
    {
        GetInput();
        MoveAndCollide(Velocity * (float)delta);
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>Run this scene and you'll see that <literal>move_and_collide()</literal> works as expected, moving
                    the body along the velocity vector. Now let's see what happens when you add
                    some obstacles. Add a <reference internal="True" refuri="../../classes/class_staticbody2d#class-staticbody2d"><inline classes="std std-ref">StaticBody2D</inline></reference> with a
                    rectangular collision shape. For visibility, you can use a Sprite2D, a
                    Polygon2D, or turn on "Visible Collision Shapes" from the "Debug" menu.</paragraph>
                <paragraph>Run the scene again and try moving into the obstacle. You'll see that the <literal>CharacterBody2D</literal>
                    can't penetrate the obstacle. However, try moving into the obstacle at an angle and
                    you'll find that the obstacle acts like glue - it feels like the body gets stuck.</paragraph>
                <paragraph>发生这种情况是因为没有 <emphasis>碰撞响应</emphasis> . <literal>move_and_collide()</literal> 在碰撞发生时停止物体的运动. 我们需要编写我们想要的碰撞响应.</paragraph>
                <paragraph>Try changing the function to <literal>move_and_slide()</literal> and running again.</paragraph>
                <paragraph><literal>move_and_slide()</literal> 提供了一个沿碰撞对象滑动物体的默认碰撞响应. 这对于许多游戏类型都很有用, 并且可能是获得所需行为所需的全部内容.</paragraph>
            </section>
            <section ids="bouncing-reflecting" names="bouncing/reflecting 弹跳/反射">
                <title>弹跳/反射</title>
                <paragraph>What if you don't want a sliding collision response? For this example ("bounce_and_collide.tscn"
                    in the sample project), we have a character shooting bullets and we want the bullets to
                    bounce off the walls.</paragraph>
                <paragraph>此示例使用三个场景. 主场景包含游戏角色和墙壁. 子弹和墙是单独的场景, 以便它们可以实例化.</paragraph>
                <paragraph>The Player is controlled by the <literal>w</literal> and <literal>s</literal> keys for forward and back. Aiming
                    uses the mouse pointer. Here is the code for the Player, using <literal>move_and_slide()</literal>:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var Bullet = preload("res://bullet.tscn")
var speed = 200

func get_input():
    # Add these actions in Project Settings -&gt; Input Map.
    var input_dir = Input.get_axis("backward", "forward")
    velocity = transform.x * input_dir * speed
    if Input.is_action_just_pressed("shoot"):
        shoot()

func shoot():
    # "Muzzle" is a Marker2D placed at the barrel of the gun.
    var b = Bullet.instantiate()
    b.start($Muzzle.global_position, rotation)
    get_tree().root.add_child(b)

func _physics_process(delta):
    get_input()
    var dir = get_global_mouse_position() - global_position
    # Don't move if too close to the mouse pointer.
    if dir.length() &gt; 5:
        rotation = dir.angle()
        move_and_slide()</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody2D : CharacterBody2D
{
    private PackedScene _bullet = GD.Load&lt;PackedScene&gt;("res://Bullet.tscn");
    private int _speed = 200;

    public void GetInput()
    {
        // Add these actions in Project Settings -&gt; Input Map.
        float inputDir = Input.GetAxis("backward", "forward");
        Velocity = Transform.X * inputDir * _speed;
        if (Input.IsActionPressed("shoot"))
        {
            Shoot();
        }
    }

    public void Shoot()
    {
        // "Muzzle" is a Marker2D placed at the barrel of the gun.
        var b = (Bullet)_bullet.Instantiate();
        b.Start(GetNode&lt;Node2D&gt;("Muzzle").GlobalPosition, Rotation);
        GetTree().Root.AddChild(b);
    }

    public override void _PhysicsProcess(double delta)
    {
        GetInput();
        var dir = GetGlobalMousePosition() - GlobalPosition;
        // Don't move if too close to the mouse pointer.
        if (dir.Length() &gt; 5)
        {
            Rotation = dir.Angle();
            MoveAndSlide();
        }
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>子弹的代码:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var speed = 750

func start(_position, _direction):
    rotation = _direction
    position = _position
    velocity = Vector2(speed, 0).rotated(rotation)

func _physics_process(delta):
    var collision = move_and_collide(velocity * delta)
    if collision:
        velocity = velocity.bounce(collision.get_normal())
        if collision.get_collider().has_method("hit"):
            collision.get_collider().hit()

func _on_VisibilityNotifier2D_screen_exited():
    # Deletes the bullet when it exits the screen.
    queue_free()</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Bullet : CharacterBody2D
{
    public int _speed = 750;

    public void Start(Vector2 position, float direction)
    {
        Rotation = direction;
        Position = position;
        Velocity = new Vector2(speed, 0).Rotated(Rotation);
    }

    public override void _PhysicsProcess(double delta)
    {
        var collision = MoveAndCollide(Velocity * (float)delta);
        if (collision != null)
        {
            Velocity = Velocity.Bounce(collision.GetNormal());
            if (collision.GetCollider().HasMethod("Hit"))
            {
                collision.GetCollider().Call("Hit");
            }
        }
    }

    private void OnVisibilityNotifier2DScreenExited()
    {
        // Deletes the bullet when it exits the screen.
        QueueFree();
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>The action happens in <literal>_physics_process()</literal>. After using <literal>move_and_collide()</literal>, if a
                    collision occurs, a <literal>KinematicCollision2D</literal> object is returned (otherwise, the return
                    is <literal>null</literal>).</paragraph>
                <paragraph>如果有一个返回的碰撞, 我们使用碰撞的 <literal>normal</literal> 来反映子弹的 <literal>velocity</literal> 和 <literal>Vector2.bounce()</literal> 方法.</paragraph>
                <paragraph>如果碰撞对象( <literal>collider</literal> )有一个 <literal>hit</literal> 方法, 我们也调用它. 在示例项目中, 我们为墙壁添加了一个颜色闪烁效果来演示这一点.</paragraph>
                <image candidates="{'*': 'tutorials/physics/img/k2d_bullet_bounce.gif'}" uri="tutorials/physics/img/k2d_bullet_bounce.gif"></image>
            </section>
            <section ids="platformer-movement" names="platformer\ movement 平台移动">
                <title>平台移动</title>
                <paragraph>Let's try one more popular example: the 2D platformer. <literal>move_and_slide()</literal>
                    is ideal for quickly getting a functional character controller up and running.
                    If you've downloaded the sample project, you can find this in "platformer.tscn".</paragraph>
                <paragraph>For this example, we'll assume you have a level made of one or more <literal>StaticBody2D</literal>
                    objects. They can be any shape and size. In the sample project, we're using
                    <reference internal="True" refuri="../../classes/class_polygon2d#class-polygon2d"><inline classes="std std-ref">Polygon2D</inline></reference> to create the platform shapes.</paragraph>
                <paragraph>这是游戏角色物体的代码:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var speed = 300.0
var jump_speed = -400.0

# Get the gravity from the project settings so you can sync with rigid body nodes.
var gravity = ProjectSettings.get_setting("physics/2d/default_gravity")


func _physics_process(delta):
    # Add the gravity.
    velocity.y += gravity * delta

    # Handle Jump.
    if Input.is_action_just_pressed("jump") and is_on_floor():
        velocity.y = jump_speed

    # Get the input direction.
    var direction = Input.get_axis("ui_left", "ui_right")
    velocity.x = direction * speed

    move_and_slide()</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody2D : CharacterBody2D
{
    private float _speed = 100.0f;
    private float _jumpSpeed = -400.0f;

    // Get the gravity from the project settings so you can sync with rigid body nodes.
    public float Gravity = ProjectSettings.GetSetting("physics/2d/default_gravity").AsSingle();

    public override void _PhysicsProcess(double delta)
    {
        Vector2 velocity = Velocity;

        // Add the gravity.
        velocity.Y += Gravity * (float)delta;

        // Handle jump.
        if (Input.IsActionJustPressed("jump") &amp;&amp; IsOnFloor())
            velocity.Y = _jumpSpeed;

        // Get the input direction.
        float direction = Input.GetAxis("ui_left", "ui_right");
        velocity.X = direction * _speed;

        Velocity = velocity;
        MoveAndSlide();
    }
}</literal_block>
                    </div>
                </container>
                <image candidates="{'*': 'tutorials/physics/img/k2d_platform.gif'}" uri="tutorials/physics/img/k2d_platform.gif"></image>
                <paragraph>在本段代码实现中，我们调用了 <literal>move_and_slide()</literal> 方法，该方法根据物体的速度向量对物体进行平移，并在碰撞检测到地面或平台等碰撞体时，使物体沿碰撞表面滑动。此外，我们还利用了 <literal>is_on_floor()</literal> 方法来判断角色是否处于可跳跃状态。若缺少这一逻辑判断，角色将能够在非地面状态下执行跳跃动作；这种情况在开发如 “Flappy Bird” 这类的飞行躲避游戏中可能是可取的，但在开发平台跳跃类型的游戏中则不适宜。</paragraph>
                <paragraph>一个完整的平台游戏角色还有很多内容：加速度、二段跳、土狼时间，等等。上面的代码只是一个起点。你可以在此基础上扩展，以得到你的项目所需的任何运动行为。</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
