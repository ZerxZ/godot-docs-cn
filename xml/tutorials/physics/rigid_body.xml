<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/physics/rigid_body.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-rigid-body"></target>
    <section ids="using-rigidbody doc-rigid-body" names="using\ rigidbody 使用\ rigidbody doc_rigid_body">
        <title>使用 RigidBody</title>
        <section ids="what-is-a-rigid-body" names="what\ is\ a\ rigid\ body? 什么是刚体？">
            <title>什么是刚体？</title>
            <paragraph>刚体是由物理引擎直接控制的物体，用于模拟物体的的物理行为。为了定义刚体的形状，必须为其指定一个或多个 <reference internal="True" refuri="../../classes/class_shape3d#class-shape3d"><inline classes="std std-ref">Shape3D</inline></reference> 对象。注意，设置这些形状的位置将影响物体的质心。</paragraph>
        </section>
        <section ids="how-to-control-a-rigid-body" names="how\ to\ control\ a\ rigid\ body 如何控制刚体">
            <title>如何控制刚体</title>
            <paragraph>刚体的行为可以通过设置其属性（例如质量和重量）来进行调整。需要给刚体添加一个物理材质来调整它的摩擦和反弹，并设置它是否具有吸收性、粗糙度。这些属性可以在检查器中或通过代码来设置。参见 <reference internal="True" refuri="../../classes/class_rigidbody3d#class-rigidbody3d"><inline classes="std std-ref">RigidBody3D</inline></reference> 和 <reference internal="True" refuri="../../classes/class_physicsmaterial#class-physicsmaterial"><inline classes="std std-ref">PhysicsMaterial</inline></reference> 获取完整的属性列表和它们的效果。</paragraph>
            <paragraph>有几种方法可以控制刚体的运动, 这取决于你的应用程序.</paragraph>
            <paragraph>如果你只需要放置一次刚体，例如设置它的初始位置，你可以使用 <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> 节点提供的方法，例如 <literal>set_global_transform()</literal> 或 <literal>look_at()</literal> 。但是，这些方法不能每一帧都被调用，否则物理引擎将无法正确地仿真物体的状态。举个例子，考虑一个刚体，你想旋转它，使它指向另一个对象。在实现这种行为时，一个常见的错误是每一帧都使用 <literal>look_at()</literal> ，这样会破坏物理仿真。下面，我们将演示如何正确地实现这一点。</paragraph>
            <paragraph>你不能使用 <literal>set_global_transform()</literal> 或 <literal>look_at()</literal> 方法并不意味着你不能完全控制一个刚体. 相反, 你可以通过使用 <literal>_integrate_forces()</literal> 回调来控制它. 在这个方法中, 你可以添加 <emphasis>力</emphasis> , 应用 <emphasis>冲量</emphasis> , 或者设置 <emphasis>速度</emphasis> , 以实现你想要的任何运动.</paragraph>
        </section>
        <section ids="the-look-at-method" names='the\ "look\ at"\ method “look\ at”方法'>
            <title>“look at”方法</title>
            <paragraph>如上所述，使用 Node3D 节点的 <literal>look_at()</literal> 方法不能每一帧都用来跟踪一个目标。这里有一个自定义的 <literal>look_at()</literal> 方法叫做 <literal>look_follow()</literal> ，可以适用于刚体：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends RigidBody3D

var speed: float = 0.1

func look_follow(state: PhysicsDirectBodyState3D, current_transform: Transform3D, target_position: Vector3) -&gt; void:
    var forward_local_axis: Vector3 = Vector3(1, 0, 0)
    var forward_dir: Vector3 = (current_transform.basis * forward_local_axis).normalized()
    var target_dir: Vector3 = (target_position - current_transform.origin).normalized()
    var local_speed: float = clampf(speed, 0, acos(forward_dir.dot(target_dir)))
    if forward_dir.dot(target_dir) &gt; 1e-4:
        state.angular_velocity = local_speed * forward_dir.cross(target_dir) / state.step

func _integrate_forces(state):
    var target_position = $my_target_node3d_node.global_transform.origin
    look_follow(state, global_transform, target_position)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyRigidBody3D : RigidBody3D
{
    private float _speed = 0.1f;
    private void LookFollow(PhysicsDirectBodyState3D state, Transform3D currentTransform, Vector3 targetPosition)
    {
        Vector3 forwardLocalAxis = new Vector3(1, 0, 0);
        Vector3 forwardDir = (currentTransform.Basis * forwardLocalAxis).Normalized();
        Vector3 targetDir = (targetPosition - currentTransform.Origin).Normalized();
        float localSpeed = Mathf.Clamp(_speed, 0.0f, Mathf.Acos(forwardDir.Dot(targetDir)));
        if (forwardDir.Dot(targetDir) &gt; 1e-4)
        {
            state.AngularVelocity = forwardDir.Cross(targetDir) * localSpeed / state.Step;
        }
    }

    public override void _IntegrateForces(PhysicsDirectBodyState3D state)
    {
        Vector3 targetPosition = GetNode&lt;Node3D&gt;("MyTargetNode3DNode").GlobalTransform.Origin;
        LookFollow(state, GlobalTransform, targetPosition);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>该方法使用刚体的 <literal>angular_velocity</literal> 特性来旋转刚体。要绕其旋转的轴是由当前正向方向和想要观察的方向之间的叉积给出的。 <literal>clamp</literal> 是一种简单的方法，用于防止旋转量超过想要查看的方向，因为所需的旋转总量是由点积的反余弦给出的。此方法也可以与 <literal>axis_lock_angular_*</literal> 一起使用。如果需要更精确的控制，则可能需要依赖于 <reference internal="True" refuri="../../classes/class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> 的解决方案，如 <reference internal="True" refuri="../3d/using_transforms#doc-using-transforms"><inline classes="std std-ref">使用 3D 变换</inline></reference>。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
