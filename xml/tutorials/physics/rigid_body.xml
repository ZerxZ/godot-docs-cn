<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/physics/rigid_body.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-rigid-body"></target>
    <section ids="using-rigidbody doc-rigid-body" names="using\ rigidbody 使用\ rigidbody doc_rigid_body">
        <title>使用 RigidBody</title>
        <section ids="what-is-a-rigid-body" names="what\ is\ a\ rigid\ body? 什么是刚体？">
            <title>什么是刚体？</title>
            <paragraph>刚体是由物理引擎直接控制的物体，用于模拟物体的的物理行为。为了定义刚体的形状，必须为其指定一个或多个 <reference internal="True" refuri="../../classes/class_shape3d#class-shape3d"><inline classes="std std-ref">Shape3D</inline></reference> 对象。注意，设置这些形状的位置将影响物体的质心。</paragraph>
        </section>
        <section ids="how-to-control-a-rigid-body" names="how\ to\ control\ a\ rigid\ body 如何控制刚体">
            <title>如何控制刚体</title>
            <paragraph>A rigid body's behavior can be altered by setting its properties, such as mass and weight.
                A physics material needs to be added to the rigid body to adjust its friction and bounce,
                and set if it's absorbent and/or rough. These properties can be set in the Inspector or via code.
                See <reference internal="True" refuri="../../classes/class_rigidbody3d#class-rigidbody3d"><inline classes="std std-ref">RigidBody3D</inline></reference> and <reference internal="True" refuri="../../classes/class_physicsmaterial#class-physicsmaterial"><inline classes="std std-ref">PhysicsMaterial</inline></reference> for
                the full list of properties and their effects.</paragraph>
            <paragraph>有几种方法可以控制刚体的运动, 这取决于你的应用程序.</paragraph>
            <paragraph>If you only need to place a rigid body once, for example to set its initial location, you can use the methods provided by the <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> node, such as <literal>set_global_transform()</literal> or <literal>look_at()</literal>. However, these methods cannot be called every frame or the physics engine will not be able to correctly simulate the body's state.
                As an example, consider a rigid body that you want to rotate so that it points towards another object. A common mistake when implementing this kind of behavior is to use <literal>look_at()</literal> every frame, which breaks the physics simulation. Below, we'll demonstrate how to implement this correctly.</paragraph>
            <paragraph>你不能使用 <literal>set_global_transform()</literal> 或 <literal>look_at()</literal> 方法并不意味着你不能完全控制一个刚体. 相反, 你可以通过使用 <literal>_integrate_forces()</literal> 回调来控制它. 在这个方法中, 你可以添加 <emphasis>力</emphasis> , 应用 <emphasis>冲量</emphasis> , 或者设置 <emphasis>速度</emphasis> , 以实现你想要的任何运动.</paragraph>
        </section>
        <section ids="the-look-at-method" names='the\ "look\ at"\ method “look\ at”方法'>
            <title>“look at”方法</title>
            <paragraph>As described above, using the Node3D's <literal>look_at()</literal> method can't be used each frame to follow a target.
                Here is a custom <literal>look_at()</literal> method called <literal>look_follow()</literal> that will work with rigid bodies:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends RigidBody3D

var speed: float = 0.1

func look_follow(state: PhysicsDirectBodyState3D, current_transform: Transform3D, target_position: Vector3) -&gt; void:
    var forward_local_axis: Vector3 = Vector3(1, 0, 0)
    var forward_dir: Vector3 = (current_transform.basis * forward_local_axis).normalized()
    var target_dir: Vector3 = (target_position - current_transform.origin).normalized()
    var local_speed: float = clampf(speed, 0, acos(forward_dir.dot(target_dir)))
    if forward_dir.dot(target_dir) &gt; 1e-4:
        state.angular_velocity = local_speed * forward_dir.cross(target_dir) / state.step

func _integrate_forces(state):
    var target_position = $my_target_node3d_node.global_transform.origin
    look_follow(state, global_transform, target_position)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyRigidBody3D : RigidBody3D
{
    private float _speed = 0.1f;
    private void LookFollow(PhysicsDirectBodyState3D state, Transform3D currentTransform, Vector3 targetPosition)
    {
        Vector3 forwardLocalAxis = new Vector3(1, 0, 0);
        Vector3 forwardDir = (currentTransform.Basis * forwardLocalAxis).Normalized();
        Vector3 targetDir = (targetPosition - currentTransform.Origin).Normalized();
        float localSpeed = Mathf.Clamp(_speed, 0.0f, Mathf.Acos(forwardDir.Dot(targetDir)));
        if (forwardDir.Dot(targetDir) &gt; 1e-4)
        {
            state.AngularVelocity = forwardDir.Cross(targetDir) * localSpeed / state.Step;
        }
    }

    public override void _IntegrateForces(PhysicsDirectBodyState3D state)
    {
        Vector3 targetPosition = GetNode&lt;Node3D&gt;("MyTargetNode3DNode").GlobalTransform.Origin;
        LookFollow(state, GlobalTransform, targetPosition);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>This method uses the rigid body's <literal>angular_velocity</literal> property to rotate the body.
                The axis to rotate around is given by the cross product between the current forward direction and the direction one wants to look in.
                The <literal>clamp</literal> is a simple method used to prevent the amount of rotation from going past the direction which is wanted to be looked in,
                as the total amount of rotation needed is given by the arccosine of the dot product.
                This method can be used with <literal>axis_lock_angular_*</literal> as well. If more precise control is needed, solutions such as ones relying on <reference internal="True" refuri="../../classes/class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> may be required,
                as discussed in <reference internal="True" refuri="../3d/using_transforms#doc-using-transforms"><inline classes="std std-ref">使用 3D 变换</inline></reference>.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
