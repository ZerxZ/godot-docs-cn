<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/physics/rigid_body.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-rigid-body"></target>
    <section ids="using-rigidbody doc-rigid-body" names="using\ rigidbody doc_rigid_body">
        <title>Using RigidBody</title>
        <section ids="what-is-a-rigid-body" names="what\ is\ a\ rigid\ body?">
            <title>What is a rigid body?</title>
            <paragraph>A rigid body is one that is directly controlled by the physics engine in order to simulate the behavior of physical objects.
                In order to define the shape of the body, it must have one or more <reference internal="True" refuri="../../classes/class_shape3d#class-shape3d"><inline classes="std std-ref">Shape3D</inline></reference> objects assigned. Note that setting the position of these shapes will affect the body's center of mass.</paragraph>
        </section>
        <section ids="how-to-control-a-rigid-body" names="how\ to\ control\ a\ rigid\ body">
            <title>How to control a rigid body</title>
            <paragraph>A rigid body's behavior can be altered by setting its properties, such as mass and weight.
                A physics material needs to be added to the rigid body to adjust its friction and bounce,
                and set if it's absorbent and/or rough. These properties can be set in the Inspector or via code.
                See <reference internal="True" refuri="../../classes/class_rigidbody3d#class-rigidbody3d"><inline classes="std std-ref">RigidBody3D</inline></reference> and <reference internal="True" refuri="../../classes/class_physicsmaterial#class-physicsmaterial"><inline classes="std std-ref">PhysicsMaterial</inline></reference> for
                the full list of properties and their effects.</paragraph>
            <paragraph>There are several ways to control a rigid body's movement, depending on your desired application.</paragraph>
            <paragraph>If you only need to place a rigid body once, for example to set its initial location, you can use the methods provided by the <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> node, such as <literal>set_global_transform()</literal> or <literal>look_at()</literal>. However, these methods cannot be called every frame or the physics engine will not be able to correctly simulate the body's state.
                As an example, consider a rigid body that you want to rotate so that it points towards another object. A common mistake when implementing this kind of behavior is to use <literal>look_at()</literal> every frame, which breaks the physics simulation. Below, we'll demonstrate how to implement this correctly.</paragraph>
            <paragraph>The fact that you can't use <literal>set_global_transform()</literal> or <literal>look_at()</literal> methods doesn't mean that you can't have full control of a rigid body. Instead, you can control it by using the <literal>_integrate_forces()</literal> callback. In this method, you can add <emphasis>forces</emphasis>, apply <emphasis>impulses</emphasis>, or set the <emphasis>velocity</emphasis> in order to achieve any movement you desire.</paragraph>
        </section>
        <section ids="the-look-at-method" names='the\ "look\ at"\ method'>
            <title>The "look at" method</title>
            <paragraph>As described above, using the Node3D's <literal>look_at()</literal> method can't be used each frame to follow a target.
                Here is a custom <literal>look_at()</literal> method called <literal>look_follow()</literal> that will work with rigid bodies:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends RigidBody3D

var speed: float = 0.1

func look_follow(state: PhysicsDirectBodyState3D, current_transform: Transform3D, target_position: Vector3) -&gt; void:
    var forward_local_axis: Vector3 = Vector3(1, 0, 0)
    var forward_dir: Vector3 = (current_transform.basis * forward_local_axis).normalized()
    var target_dir: Vector3 = (target_position - current_transform.origin).normalized()
    var local_speed: float = clampf(speed, 0, acos(forward_dir.dot(target_dir)))
    if forward_dir.dot(target_dir) &gt; 1e-4:
        state.angular_velocity = local_speed * forward_dir.cross(target_dir) / state.step

func _integrate_forces(state):
    var target_position = $my_target_node3d_node.global_transform.origin
    look_follow(state, global_transform, target_position)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyRigidBody3D : RigidBody3D
{
    private float _speed = 0.1f;
    private void LookFollow(PhysicsDirectBodyState3D state, Transform3D currentTransform, Vector3 targetPosition)
    {
        Vector3 forwardLocalAxis = new Vector3(1, 0, 0);
        Vector3 forwardDir = (currentTransform.Basis * forwardLocalAxis).Normalized();
        Vector3 targetDir = (targetPosition - currentTransform.Origin).Normalized();
        float localSpeed = Mathf.Clamp(_speed, 0.0f, Mathf.Acos(forwardDir.Dot(targetDir)));
        if (forwardDir.Dot(targetDir) &gt; 1e-4)
        {
            state.AngularVelocity = forwardDir.Cross(targetDir) * localSpeed / state.Step;
        }
    }

    public override void _IntegrateForces(PhysicsDirectBodyState3D state)
    {
        Vector3 targetPosition = GetNode&lt;Node3D&gt;("MyTargetNode3DNode").GlobalTransform.Origin;
        LookFollow(state, GlobalTransform, targetPosition);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>This method uses the rigid body's <literal>angular_velocity</literal> property to rotate the body.
                The axis to rotate around is given by the cross product between the current forward direction and the direction one wants to look in.
                The <literal>clamp</literal> is a simple method used to prevent the amount of rotation from going past the direction which is wanted to be looked in,
                as the total amount of rotation needed is given by the arccosine of the dot product.
                This method can be used with <literal>axis_lock_angular_*</literal> as well. If more precise control is needed, solutions such as ones relying on <reference internal="True" refuri="../../classes/class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> may be required,
                as discussed in <reference internal="True" refuri="../3d/using_transforms#doc-using-transforms"><inline classes="std std-ref">Using 3D transforms</inline></reference>.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
