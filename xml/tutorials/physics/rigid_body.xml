<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/physics/rigid_body.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-rigid-body"></target>
    <section ids="using-rigidbody doc-rigid-body" names="using\ rigidbody 使用\ rigidbody doc_rigid_body">
        <title>使用 RigidBody</title>
        <section ids="what-is-a-rigid-body" names="what\ is\ a\ rigid\ body? 什么是刚体？">
            <title>什么是刚体？</title>
            <paragraph>刚体是由物理引擎直接控制的物体，用于模拟物体的的物理行为。为了定义刚体的形状，必须为其指定一个或多个 <reference internal="True" refuri="../../classes/class_shape3d#class-shape3d"><inline classes="std std-ref">Shape3D</inline></reference> 对象。注意，设置这些形状的位置将影响物体的质心。</paragraph>
        </section>
        <section ids="how-to-control-a-rigid-body" names="how\ to\ control\ a\ rigid\ body 如何控制刚体">
            <title>如何控制刚体</title>
            <paragraph>A rigid body's behavior can be altered by setting its properties, such as mass and weight.
                A physics material needs to be added to the rigid body to adjust its friction and bounce,
                and set if it's absorbent and/or rough. These properties can be set in the Inspector or via code.
                See <reference internal="True" refuri="../../classes/class_rigidbody3d#class-rigidbody3d"><inline classes="std std-ref">RigidBody3D</inline></reference> and <reference internal="True" refuri="../../classes/class_physicsmaterial#class-physicsmaterial"><inline classes="std std-ref">PhysicsMaterial</inline></reference> for
                the full list of properties and their effects.</paragraph>
            <paragraph>有几种方法可以控制刚体的运动, 这取决于你的应用程序.</paragraph>
            <paragraph>If you only need to place a rigid body once, for example to set its initial location, you can use the methods provided by the <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> node, such as <literal>set_global_transform()</literal> or <literal>look_at()</literal>. However, these methods cannot be called every frame or the physics engine will not be able to correctly simulate the body's state.
                As an example, consider a rigid body that you want to rotate so that it points towards another object. A common mistake when implementing this kind of behavior is to use <literal>look_at()</literal> every frame, which breaks the physics simulation. Below, we'll demonstrate how to implement this correctly.</paragraph>
            <paragraph>你不能使用 <literal>set_global_transform()</literal> 或 <literal>look_at()</literal> 方法并不意味着你不能完全控制一个刚体. 相反, 你可以通过使用 <literal>_integrate_forces()</literal> 回调来控制它. 在这个方法中, 你可以添加 <emphasis>力</emphasis> , 应用 <emphasis>冲量</emphasis> , 或者设置 <emphasis>速度</emphasis> , 以实现你想要的任何运动.</paragraph>
        </section>
        <section ids="the-look-at-method" names='the\ "look\ at"\ method “look\ at”方法'>
            <title>“look at”方法</title>
            <paragraph>As described above, using the Node3D's <literal>look_at()</literal> method can't be used each frame to follow a target.
                Here is a custom <literal>look_at()</literal> method called <literal>look_follow()</literal> that will work with rigid bodies:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends RigidBody3D

var speed: float = 0.1

func look_follow(state: PhysicsDirectBodyState3D, current_transform: Transform3D, target_position: Vector3) -&gt; void:
    var forward_local_axis: Vector3 = Vector3(1, 0, 0)
    var forward_dir: Vector3 = (current_transform.basis * forward_local_axis).normalized()
    var target_dir: Vector3 = (target_position - current_transform.origin).normalized()
    var local_speed: float = clampf(speed, 0, acos(forward_dir.dot(target_dir)))
    if forward_dir.dot(target_dir) &gt; 1e-4:
        state.angular_velocity = local_speed * forward_dir.cross(target_dir) / state.step

func _integrate_forces(state):
    var target_position = $my_target_node3d_node.global_transform.origin
    look_follow(state, global_transform, target_position)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyRigidBody3D : RigidBody3D
{
    private float _speed = 0.1f;
    private void LookFollow(PhysicsDirectBodyState3D state, Transform3D currentTransform, Vector3 targetPosition)
    {
        Vector3 forwardLocalAxis = new Vector3(1, 0, 0);
        Vector3 forwardDir = (currentTransform.Basis * forwardLocalAxis).Normalized();
        Vector3 targetDir = (targetPosition - currentTransform.Origin).Normalized();
        float localSpeed = Mathf.Clamp(_speed, 0.0f, Mathf.Acos(forwardDir.Dot(targetDir)));
        if (forwardDir.Dot(targetDir) &gt; 1e-4)
        {
            state.AngularVelocity = forwardDir.Cross(targetDir) * localSpeed / state.Step;
        }
    }

    public override void _IntegrateForces(PhysicsDirectBodyState3D state)
    {
        Vector3 targetPosition = GetNode&lt;Node3D&gt;("MyTargetNode3DNode").GlobalTransform.Origin;
        LookFollow(state, GlobalTransform, targetPosition);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>该方法使用刚体的 <literal>angular_velocity</literal> 特性来旋转刚体。要绕其旋转的轴是由当前正向方向和想要观察的方向之间的叉积给出的。 <literal>clamp</literal> 是一种简单的方法，用于防止旋转量超过想要查看的方向，因为所需的旋转总量是由点积的反余弦给出的。此方法也可以与 <literal>axis_lock_angular_*</literal> 一起使用。如果需要更精确的控制，则可能需要依赖于 <reference internal="True" refuri="../../classes/class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> 的解决方案，如 <reference internal="True" refuri="../3d/using_transforms#doc-using-transforms"><inline classes="std std-ref">使用 3D 变换</inline></reference>。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
