<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/physics/using_jolt_physics.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-jolt-physics"></target>
    <section ids="using-jolt-physics doc-using-jolt-physics" names="using\ jolt\ physics doc_using_jolt_physics">
        <title>Using Jolt Physics</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>The Jolt physics engine was added as an alternative to the existing Godot Physics
                physics engine in 4.4. Jolt is developed by Jorrit Rouwe with a focus on games and
                VR applications. Previously it was available as an extension but is now built into
                Godot.</paragraph>
            <paragraph>The existing extension is now considered in maintenance mode. That means bug fixes
                will be merged, and it will be kept compatible with new versions of Godot until
                the built-in module has feature parity with the extension. The extension can be
                found <reference name="here on GitHub" refuri="https://github.com/godot-jolt/godot-jolt">here on GitHub</reference><target ids="here-on-github" names="here\ on\ github" refuri="https://github.com/godot-jolt/godot-jolt"></target> and in Godot's asset
                library.</paragraph>
            <paragraph>To change the 3D physics engine to be Jolt Physics, set
                <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-3d-physics-engine"><inline classes="std std-ref">Project Settings &gt; Physics &gt; 3D &gt; Physics Engine</inline></reference>
                to <literal>Jolt Physics</literal>. Once you've done that, click the <strong>Save &amp; Restart</strong> button.
                When the editor opens again, 3D scenes should now be using Jolt for physics.</paragraph>
        </section>
        <section ids="notable-differences-to-godot-physics" names="notable\ differences\ to\ godot\ physics">
            <title>Notable differences to Godot Physics</title>
            <paragraph>There are many differences between the existing Godot Physics engine and Jolt.</paragraph>
            <section ids="joint-properties" names="joint\ properties">
                <title>Joint properties</title>
                <paragraph>The current interfaces for the 3D joint nodes don't quite line up with the interface
                    of Jolt's own joints. As such, there are a number of joint properties that are not
                    supported, mainly ones related to configuring the joint's soft limits.</paragraph>
                <paragraph>The unsupported properties are:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>PinJoint3D: <literal>bias</literal>, <literal>damping</literal>, <literal>impulse_clamp</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>HingeJoint3D: <literal>bias</literal>, <literal>softness</literal>, <literal>relaxation</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>SliderJoint3D: <literal>angular_\*</literal>, <literal>\*_limit/softness</literal>, <literal>\*_limit/restitution</literal>, <literal>\*_limit/damping</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>ConeTwistJoint3D: <literal>bias</literal>, <literal>relaxation</literal>, <literal>softness</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Generic6DOFJoint3D: <literal>*_limit_*/softness</literal>, <literal>*_limit_*/restitution</literal>, <literal>*_limit_*/damping</literal>, <literal>*_limit_*/erp</literal></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Currently a warning is emitted if you set these properties to anything but their
                    default values.</paragraph>
            </section>
            <section ids="single-body-joints" names="single-body\ joints">
                <title>Single-body joints</title>
                <paragraph>You can, in Godot, omit one of the joint bodies for a two-body joint and effectively
                    have "the world" be the other body. However, the node path that you assign your body
                    to (<reference internal="True" refuri="../../classes/class_joint3d#class-joint3d-property-node-a"><inline classes="std std-ref">node_a</inline></reference> vs <reference internal="True" refuri="../../classes/class_joint3d#class-joint3d-property-node-b"><inline classes="std std-ref">node_b</inline></reference>)
                    is ignored. Godot Physics will always behave as if you
                    assigned it to <literal>node_a</literal>, and since <literal>node_a</literal> is also what defines the frame of reference
                    for the joint limits, you end up with inverted limits and a potentially strange
                    limit shape, especially if your limits allow both linear and angular degrees of
                    freedom.</paragraph>
                <paragraph>Jolt will behave as if you assigned the body to <literal>node_b</literal> instead, with <literal>node_a</literal>
                    representing "the world". There is a project setting called <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-jolt-physics-3d-joints-world-node"><inline classes="std std-ref">Physics &gt; Jolt Physics 3D &gt; Joints &gt; World Node</inline></reference>
                    that lets you toggle this behavior, if you need compatibility for an existing project.</paragraph>
            </section>
            <section ids="collision-margins" names="collision\ margins">
                <title>Collision margins</title>
                <paragraph>Jolt (and other similar physics engines) uses something that Jolt refers to as
                    "convex radius" to help improve the performance and behavior of the types of
                    collision detection that Jolt relies on for convex shapes. Other physics engines
                    (Godot included) might refer to these as "collision margins" instead. Godot exposes
                    these as the <literal>margin</literal> property on every Shape3D-derived class, but Godot Physics
                    itself does not use them for anything.</paragraph>
                <paragraph>What these collision margins sometimes do in other engines (as described in Godot's
                    documentation) is effectively add a "shell" around the shape, slightly increasing
                    its size while also rounding off any edges/corners. In Jolt however, these margins
                    are first used to shrink the shape, and then the "shell" is applied, resulting in
                    edges/corners being similarly rounded off, but without increasing the size of the
                    shape.</paragraph>
                <paragraph>To prevent having to tweak this margin property manually, since its default value
                    can be problematic for smaller shapes, the Jolt module exposes a project setting
                    called <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-jolt-physics-3d-collisions-collision-margin-fraction"><inline classes="std std-ref">Physics &gt; Jolt Physics 3D &gt; Collisions &gt; Collision Margin Fraction</inline></reference>
                    which is multiplied with the smallest axis of the shape's AABB to calculate the
                    actual margin. The margin property of the shape is then instead used as an upper
                    bound.</paragraph>
                <paragraph>These margins should, for most use-cases, be more or less transparent, but can
                    sometimes result in odd collision normals when performing shape queries. You can
                    lower the above mentioned project setting to mitigate some of this, including
                    setting it to <literal>0.0</literal>, but too small of a margin can also cause odd collision results,
                    so is generally not recommended.</paragraph>
            </section>
            <section ids="baumgarte-stabilization" names="baumgarte\ stabilization">
                <title>Baumgarte stabilization</title>
                <paragraph>Baumgarte stabilization is a method to resolve penetrating bodies and push them to a
                    state where they are just touching. In Godot Physics this works like a spring. This
                    means that bodies can accelerate and may cause the bodies to overshoot and separate
                    completely. With Jolt, the stabilization is only applied to the position and not to
                    the velocity of the body. This means it cannot overshoot but it may take longer to
                    resolve the penetration.</paragraph>
                <paragraph>The strength of this stabilization can be tweaked using the project setting
                    <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-jolt-physics-3d-simulation-baumgarte-stabilization-factor"><inline classes="std std-ref">Physics &gt; Jolt Physics 3D &gt; Simulation &gt; Baumgarte Stabilization Factor</inline></reference>.
                    Setting this project setting to <literal>0.0</literal> will turn Baumgarte stabilization off.
                    Setting it to <literal>1.0</literal> will resolve penetration in 1 simulation step. This is fast
                    but often also unstable.</paragraph>
            </section>
            <section ids="ghost-collisions" names="ghost\ collisions">
                <title>Ghost collisions</title>
                <paragraph>Jolt employs two techniques to mitigate ghost collisions, meaning collisions with
                    internal edges of shapes/bodies that result in collision normals that oppose the
                    direction of movement.</paragraph>
                <paragraph>The first technique, called "active edge detection", marks edges of triangles in
                    <reference internal="True" refuri="../../classes/class_concavepolygonshape3d#class-concavepolygonshape3d"><inline classes="std std-ref">ConcavePolygonShape3D</inline></reference> or <reference internal="True" refuri="../../classes/class_heightmapshape3d#class-heightmapshape3d"><inline classes="std std-ref">HeightMapShape3D</inline></reference> as either "active" or "inactive", based on
                    the angle to the neighboring triangle. When a collision happens with an inactive
                    edge the collision normal will be replaced with the triangle's normal instead, to
                    lessen the effect of ghost collisions.</paragraph>
                <paragraph>The angle threshold for this active edge detection is configurable through the
                    project setting <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-jolt-physics-3d-collisions-active-edge-threshold"><inline classes="std std-ref">Physics &gt;Jolt Physics 3D &gt; Collisions &gt; Active Edge Threshold</inline></reference>.</paragraph>
                <paragraph>The second technique, called "enhanced internal edge removal", instead adds runtime
                    checks to detect whether an edge is active or inactive, based on the contact points
                    of the two bodies. This has the benefit of applying not only to collisions with
                    <reference internal="True" refuri="../../classes/class_concavepolygonshape3d#class-concavepolygonshape3d"><inline classes="std std-ref">ConcavePolygonShape3D</inline></reference> and <reference internal="True" refuri="../../classes/class_heightmapshape3d#class-heightmapshape3d"><inline classes="std std-ref">HeightMapShape3D</inline></reference>, but also edges between any shapes within
                    the same body.</paragraph>
                <paragraph>Enhanced internal edge removal can be toggled on and off for the various contexts to
                    which it's applied, using the <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-jolt-physics-3d-simulation-use-enhanced-internal-edge-removal"><inline classes="std std-ref">Physics &gt;Jolt Physics 3D &gt; Simulation &gt; Use Enhanced Internal Edge Removal</inline></reference>,
                    project setting, and the similar settings for <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-jolt-physics-3d-queries-use-enhanced-internal-edge-removal"><inline classes="std std-ref">queries</inline></reference>
                    and <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-jolt-physics-3d-motion-queries-use-enhanced-internal-edge-removal"><inline classes="std std-ref">motion queries</inline></reference>.</paragraph>
                <paragraph>Note that neither the active edge detection nor enhanced internal edge removal apply
                    when dealing with ghost collisions between two different bodies.</paragraph>
            </section>
            <section ids="memory-usage" names="memory\ usage">
                <title>Memory usage</title>
                <paragraph>Jolt uses a stack allocator for temporary allocations within its simulation step.
                    This stack allocator requires allocating a set amount of memory up front, which can
                    be configured using the <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-jolt-physics-3d-limits-temporary-memory-buffer-size"><inline classes="std std-ref">Physics &gt; Jolt Physics 3D &gt; Limits &gt; Temporary Memory Buffer Size</inline></reference>
                    project setting.</paragraph>
            </section>
            <section ids="ray-cast-face-index" names="ray-cast\ face\ index">
                <title>Ray-cast face index</title>
                <paragraph>The <literal>face_index</literal> property returned in the results of <reference internal="True" refuri="../../classes/class_physicsdirectspacestate3d#class-physicsdirectspacestate3d-method-intersect-ray"><inline classes="std std-ref">intersect_ray()</inline></reference>
                    and RayCast3D will by default always be <literal>-1</literal> with Jolt. The project setting <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-jolt-physics-3d-queries-enable-ray-cast-face-index"><inline classes="std std-ref">Physics &gt; Jolt Physics 3D &gt; Queries &gt; Enable Ray Cast Face Index</inline></reference>
                    will enable them.</paragraph>
                <paragraph>Note that enabling this setting will increase the memory requirement of <reference internal="True" refuri="../../classes/class_concavepolygonshape3d#class-concavepolygonshape3d"><inline classes="std std-ref">ConcavePolygonShape3D</inline></reference>
                    with about 25%.</paragraph>
            </section>
            <section ids="kinematic-rigidbody3d-contacts" names="kinematic\ rigidbody3d\ contacts">
                <title>Kinematic RigidBody3D contacts</title>
                <paragraph>When using Jolt, a <reference internal="True" refuri="../../classes/class_rigidbody3d#class-rigidbody3d"><inline classes="std std-ref">RigidBody3D</inline></reference> frozen with <reference internal="True" refuri="../../classes/class_rigidbody3d#class-rigidbody3d-constant-freeze-mode-kinematic"><inline classes="std std-ref">FREEZE_MODE_KINEMATIC</inline></reference>
                    will by default not report contacts from collisions with other static/kinematic
                    bodies, for performance reasons, even when setting a non-zero <reference internal="True" refuri="../../classes/class_rigidbody3d#class-rigidbody3d-property-max-contacts-reported"><inline classes="std std-ref">max_contacts_reported</inline></reference>.
                    If you have many/large kinematic bodies overlapping with complex static geometry,
                    such as <reference internal="True" refuri="../../classes/class_concavepolygonshape3d#class-concavepolygonshape3d"><inline classes="std std-ref">ConcavePolygonShape3D</inline></reference> or <reference internal="True" refuri="../../classes/class_heightmapshape3d#class-heightmapshape3d"><inline classes="std std-ref">HeightMapShape3D</inline></reference>, you can
                    end up wasting a significant amount of CPU performance and memory without realizing
                    it.</paragraph>
                <paragraph>For this reason this behavior is opt-in through the project setting
                    <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-jolt-physics-3d-simulation-generate-all-kinematic-contacts"><inline classes="std std-ref">Physics &gt; Jolt Physics 3D &gt; Simulation &gt; Generate All Kinematic Contacts</inline></reference>.</paragraph>
            </section>
            <section ids="contact-impulses" names="contact\ impulses">
                <title>Contact impulses</title>
                <paragraph>Due to limitations internal to Jolt, the contact impulses provided by <reference internal="True" refuri="../../classes/class_physicsdirectbodystate3d#class-physicsdirectbodystate3d-method-get-contact-impulse"><inline classes="std std-ref">PhysicsDirectBodyState3D.get_contact_impulse()</inline></reference>
                    are estimated ahead of time based on things like the contact manifold and velocities
                    of the colliding bodies. This means that the reported impulses will only be accurate
                    in cases where the two bodies in question are not colliding with any other bodies.</paragraph>
            </section>
            <section ids="area3d-and-softbody3d" names="area3d\ and\ softbody3d">
                <title>Area3D and SoftBody3D</title>
                <paragraph>Jolt does not currently support any interactions between <reference internal="True" refuri="../../classes/class_softbody3d#class-softbody3d"><inline classes="std std-ref">SoftBody3D</inline></reference>
                    and <reference internal="True" refuri="../../classes/class_area3d#class-area3d"><inline classes="std std-ref">Area3D</inline></reference>, such as the wind and gravity properties found on
                    <reference internal="True" refuri="../../classes/class_area3d#class-area3d"><inline classes="std std-ref">Area3D</inline></reference>.</paragraph>
            </section>
            <section ids="worldboundaryshape3d" names="worldboundaryshape3d">
                <title>WorldBoundaryShape3D</title>
                <paragraph><reference internal="True" refuri="../../classes/class_worldboundaryshape3d#class-worldboundaryshape3d"><inline classes="std std-ref">WorldBoundaryShape3D</inline></reference>, which is meant to represent an infinite plane, is
                    implemented a bit differently in Jolt compared to Godot Physics. Both engines have
                    an upper limit for how big the effective size of this plane can be, but this size is
                    much smaller when using Jolt, in order to avoid precision issues.</paragraph>
                <paragraph>You can configure this size using the <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-jolt-physics-3d-limits-world-boundary-shape-size"><inline classes="std std-ref">Physics &gt; Jolt Physics 3D &gt; Limits &gt; World Boundary Shape Size</inline></reference>
                    project setting.</paragraph>
            </section>
        </section>
        <section ids="notable-differences-to-the-godot-jolt-extension" names="notable\ differences\ to\ the\ godot\ jolt\ extension">
            <title>Notable differences to the Godot Jolt extension</title>
            <paragraph>While the built-in Jolt module is largely a straight port of the Godot Jolt
                extension, there are a few things that are different.</paragraph>
            <section ids="project-settings" names="project\ settings">
                <title>Project settings</title>
                <paragraph>All project settings have been moved from the <literal>physics/jolt_3d</literal> category to
                    <literal>physics/jolt_physics_3d</literal>.</paragraph>
                <paragraph>On top of that, there's been some renaming and refactoring of the individual project
                    settings as well. These include:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><literal>sleep/enabled</literal> is now <literal>simulation/allow_sleep.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>sleep/velocity_threshold</literal> is now <literal>simulation/sleep_velocity_threshold.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>sleep/time_threshold</literal> is now <literal>simulation/sleep_time_threshold.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>collisions/use_shape_margins</literal> is now <literal>collisions/collision_margin_fraction</literal>,
                            where a value of 0 is equivalent to disabling it.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>collisions/use_enhanced_internal_edge_removal</literal> is now <literal>simulation/use_enhanced_internal_edge_removal.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>collisions/areas_detect_static_bodies</literal> is now <literal>simulation/areas_detect_static_bodies.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>collisions/report_all_kinematic_contacts</literal> is now <literal>simulation/generate_all_kinematic_contacts.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>collisions/soft_body_point_margin</literal> is now <literal>simulation/soft_body_point_radius.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>collisions/body_pair_cache_enabled is now simulation/body_pair_contact_cache_enabled.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>collisions/body_pair_cache_distance_threshold</literal> is <literal>now simulation/body_pair_contact_cache_distance_threshold.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>collisions/body_pair_cache_angle_threshold is now simulation/body_pair_contact_cache_angle_threshold.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>continuous_cd/movement_threshold</literal> is now <literal>simulation/continuous_cd_movement_threshold</literal>,
                            but expressed as a fraction instead of a percentage.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>continuous_cd/max_penetration</literal> is now <literal>simulation/continuous_cd_max_penetration</literal>,
                            but expressed as a fraction instead of a percentage.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>kinematics/use_enhanced_internal_edge_removal</literal> is now <literal>motion_queries/use_enhanced_internal_edge_removal.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>kinematics/recovery_iterations</literal> is now <literal>motion_queries/recovery_iterations</literal>,
                            but expressed as a fraction instead of a percentage.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>kinematics/recovery_amount</literal> is now <literal>motion_queries/recovery_amount.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>queries/use_legacy_ray_casting</literal> has been removed.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>solver/position_iterations</literal> is now <literal>simulation/position_steps.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>solver/velocity_iterations</literal> is now <literal>simulation/velocity_steps.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>solver/position_correction</literal> is now <literal>simulation/baumgarte_stabilization_factor</literal>,
                            but expressed as a fraction instead of a percentage.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>solver/active_edge_threshold</literal> is now <literal>collisions/active_edge_threshold.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>solver/bounce_velocity_threshold</literal> is now <literal>simulation/bounce_velocity_threshold.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>solver/contact_speculative_distance</literal> is now <literal>simulation/speculative_contact_distance.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>solver/contact_allowed_penetration</literal> is now <literal>simulation/penetration_slop.</literal></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>limits/max_angular_velocity</literal> is now stored as radians instead.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>limits/max_temporary_memory</literal> is now <literal>limits/temporary_memory_buffer_size.</literal></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="joint-nodes" names="joint\ nodes">
                <title>Joint nodes</title>
                <paragraph>The joint nodes that are exposed in the Godot Jolt extension (JoltPinJoint3D,
                    JoltHingeJoint3D, JoltSliderJoint3D, JoltConeTwistJoint3D, and JoltGeneric6DOFJoint)
                    have not been included in the Jolt module.</paragraph>
            </section>
            <section ids="thread-safety" names="thread\ safety">
                <title>Thread safety</title>
                <paragraph>Unlike the Godot Jolt extension, the Jolt module does have thread-safety,
                    including support for the <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-3d-run-on-separate-thread"><inline classes="std std-ref">Physics &gt; 3D &gt; Run On Separate Thread</inline></reference>
                    project setting. However this has not been tested very thoroughly, so it should be
                    considered experimental.</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
