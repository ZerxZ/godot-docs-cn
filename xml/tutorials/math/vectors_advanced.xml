<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/math/vectors_advanced.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-vectors-advanced"></target>
    <section ids="advanced-vector-math doc-vectors-advanced" names="advanced\ vector\ math doc_vectors_advanced">
        <title>Advanced vector math</title>
        <section ids="planes" names="planes">
            <title>Planes</title>
            <paragraph>The dot product has another interesting property with unit vectors.
                Imagine that perpendicular to that vector (and through the origin)
                passes a plane. Planes divide the entire space into positive
                (over the plane) and negative (under the plane), and (contrary to
                popular belief) you can also use their math in 2D:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/tutovec10.png'}" original_uri="img/tutovec10.png" uri="tutorials/math/img/tutovec10.png"></image>
            <paragraph>Unit vectors that are perpendicular to a surface (so, they describe the
                orientation of the surface) are called <strong>unit normal vectors</strong>. Though,
                usually they are just abbreviated as <emphasis>normals</emphasis>. Normals appear in
                planes, 3D geometry (to determine where each face or vertex is siding),
                etc. A <strong>normal</strong> <emphasis>is</emphasis> a <strong>unit vector</strong>, but it's called <emphasis>normal</emphasis>
                because of its usage. (Just like we call (0,0) the Origin!).</paragraph>
            <paragraph>The plane passes by the origin and the
                surface of it is perpendicular to the unit vector (or <emphasis>normal</emphasis>). The
                side the vector points to is the positive half-space, while the
                other side is the negative half-space. In 3D this is exactly the same,
                except that the plane is an infinite surface (imagine an infinite, flat
                sheet of paper that you can orient and is pinned to the origin) instead
                of a line.</paragraph>
            <section ids="distance-to-plane" names="distance\ to\ plane">
                <title>Distance to plane</title>
                <paragraph>Now that it's clear what a plane is, let's go back to the dot product.
                    The dot product between a <strong>unit vector</strong> and any <strong>point in space</strong>
                    (yes, this time we do dot product between vector and position), returns
                    the <strong>distance from the point to the plane</strong>:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var distance = normal.dot(point)</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var distance = normal.Dot(point);</literal_block>
                    </div>
                </container>
                <paragraph>But not just the absolute distance, if the point is in the negative half
                    space the distance will be negative, too:</paragraph>
                <image candidates="{'*': 'tutorials/math/img/tutovec11.png'}" original_uri="img/tutovec11.png" uri="tutorials/math/img/tutovec11.png"></image>
                <paragraph>This allows us to tell which side of the plane a point is.</paragraph>
            </section>
            <section ids="away-from-the-origin" names="away\ from\ the\ origin">
                <title>Away from the origin</title>
                <paragraph>I know what you are thinking! So far this is nice, but <emphasis>real</emphasis> planes are
                    everywhere in space, not only passing through the origin. You want real
                    <emphasis>plane</emphasis> action and you want it <emphasis>now</emphasis>.</paragraph>
                <paragraph>Remember that planes not only split space in two, but they also have
                    <emphasis>polarity</emphasis>. This means that it is possible to have perfectly overlapping
                    planes, but their negative and positive half-spaces are swapped.</paragraph>
                <paragraph>With this in mind, let's describe a full plane as a <strong>normal</strong> <emphasis>N</emphasis> and a
                    <strong>distance from the origin</strong> scalar <emphasis>D</emphasis>. Thus, our plane is represented
                    by N and D. For example:</paragraph>
                <image candidates="{'*': 'tutorials/math/img/tutovec12.png'}" original_uri="img/tutovec12.png" uri="tutorials/math/img/tutovec12.png"></image>
                <paragraph>For 3D math, Godot provides a <reference internal="True" refuri="../../classes/class_plane#class-plane"><inline classes="std std-ref">Plane</inline></reference>
                    built-in type that handles this.</paragraph>
                <paragraph>Basically, N and D can represent any plane in space, be it for 2D or 3D
                    (depending on the amount of dimensions of N) and the math is the same
                    for both. It's the same as before, but D is the distance from the origin
                    to the plane, travelling in N direction. As an example, imagine you want
                    to reach a point in the plane, you will just do:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var point_in_plane = N*D</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var pointInPlane = N * D;</literal_block>
                    </div>
                </container>
                <paragraph>This will stretch (resize) the normal vector and make it touch the
                    plane. This math might seem confusing, but it's actually much simpler
                    than it seems. If we want to tell, again, the distance from the point to
                    the plane, we do the same but adjusting for distance:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var distance = N.dot(point) - D</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var distance = N.Dot(point) - D;</literal_block>
                    </div>
                </container>
                <paragraph>The same thing, using a built-in function:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var distance = plane.distance_to(point)</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var distance = plane.DistanceTo(point);</literal_block>
                    </div>
                </container>
                <paragraph>This will, again, return either a positive or negative distance.</paragraph>
                <paragraph>Flipping the polarity of the plane can be done by negating both
                    N and D. This will result in a plane in the same position, but with
                    inverted negative and positive half spaces:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">N = -N
D = -D</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">N = -N;
D = -D;</literal_block>
                    </div>
                </container>
                <paragraph>Godot also implements this operator in <reference internal="True" refuri="../../classes/class_plane#class-plane"><inline classes="std std-ref">Plane</inline></reference>.
                    So, using the format below will work as expected:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var inverted_plane = -plane</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var invertedPlane = -plane;</literal_block>
                    </div>
                </container>
                <paragraph>So, remember, the plane's main practical use is that we can
                    calculate the distance to it. So, when is it useful to calculate the
                    distance from a point to a plane? Let's see some examples.</paragraph>
            </section>
            <section ids="constructing-a-plane-in-2d" names="constructing\ a\ plane\ in\ 2d">
                <title>Constructing a plane in 2D</title>
                <paragraph>Planes clearly don't come out of nowhere, so they must be built.
                    Constructing them in 2D is easy, this can be done from either a normal
                    (unit vector) and a point, or from two points in space.</paragraph>
                <paragraph>In the case of a normal and a point, most of the work is done, as the
                    normal is already computed, so calculate D from the dot product of
                    the normal and the point.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var N = normal
var D = normal.dot(point)</literal_block>
                    </div>
                    <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var N = normal;
var D = normal.Dot(point);</literal_block>
                    </div>
                </container>
                <paragraph>For two points in space, there are actually two planes that pass through
                    them, sharing the same space but with normal pointing to the opposite
                    directions. To compute the normal from the two points, the direction
                    vector must be obtained first, and then it needs to be rotated 90
                    degrees to either side:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Calculate vector from `a` to `b`.
var dvec = point_a.direction_to(point_b)
# Rotate 90 degrees.
var normal = Vector2(dvec.y, -dvec.x)
# Alternatively (depending the desired side of the normal):
# var normal = Vector2(-dvec.y, dvec.x)</literal_block>
                    </div>
                    <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Calculate vector from `a` to `b`.
var dvec = pointA.DirectionTo(pointB);
// Rotate 90 degrees.
var normal = new Vector2(dvec.Y, -dvec.X);
// Alternatively (depending the desired side of the normal):
// var normal = new Vector2(-dvec.Y, dvec.X);</literal_block>
                    </div>
                </container>
                <paragraph>The rest is the same as the previous example. Either point_a or
                    point_b will work, as they are in the same plane:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var N = normal
var D = normal.dot(point_a)
# this works the same
# var D = normal.dot(point_b)</literal_block>
                    </div>
                    <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var N = normal;
var D = normal.Dot(pointA);
// this works the same
// var D = normal.Dot(pointB);</literal_block>
                    </div>
                </container>
                <paragraph>Doing the same in 3D is a little more complex and is explained
                    further down.</paragraph>
            </section>
            <section ids="some-examples-of-planes" names="some\ examples\ of\ planes">
                <title>Some examples of planes</title>
                <paragraph>Here is an example of what planes are useful for. Imagine you have
                    a <reference name="convex" refuri="https://www.mathsisfun.com/definitions/convex.html">convex</reference>
                    polygon. For example, a rectangle, a trapezoid, a triangle, or just any
                    polygon where no faces bend inwards.</paragraph>
                <paragraph>For every segment of the polygon, we compute the plane that passes by
                    that segment. Once we have the list of planes, we can do neat things,
                    for example checking if a point is inside the polygon.</paragraph>
                <paragraph>We go through all planes, if we can find a plane where the distance to
                    the point is positive, then the point is outside the polygon. If we
                    can't, then the point is inside.</paragraph>
                <image candidates="{'*': 'tutorials/math/img/tutovec13.png'}" original_uri="img/tutovec13.png" uri="tutorials/math/img/tutovec13.png"></image>
                <paragraph>Code should be something like this:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var inside = true
for p in planes:
    # check if distance to plane is positive
    if (p.distance_to(point) &gt; 0):
        inside = false
        break # with one that fails, it's enough</literal_block>
                    </div>
                    <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var inside = true;
foreach (var p in planes)
{
    // check if distance to plane is positive
    if (p.DistanceTo(point) &gt; 0)
    {
        inside = false;
        break; // with one that fails, it's enough
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>Pretty cool, huh? But this gets much better! With a little more effort,
                    similar logic will let us know when two convex polygons are overlapping
                    too. This is called the Separating Axis Theorem (or SAT) and most
                    physics engines use this to detect collision.</paragraph>
                <paragraph>With a point, just checking if a plane
                    returns a positive distance is enough to tell if the point is outside.
                    With another polygon, we must find a plane where <emphasis>all</emphasis> <emphasis>the</emphasis> <emphasis>other</emphasis>
                    <emphasis>polygon</emphasis> <emphasis>points</emphasis> return a positive distance to it. This check is
                    performed with the planes of A against the points of B, and then with
                    the planes of B against the points of A:</paragraph>
                <image candidates="{'*': 'tutorials/math/img/tutovec14.png'}" original_uri="img/tutovec14.png" uri="tutorials/math/img/tutovec14.png"></image>
                <paragraph>Code should be something like this:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-10-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-10-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-10-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var overlapping = true

for p in planes_of_A:
    var all_out = true
    for v in points_of_B:
        if (p.distance_to(v) &lt; 0):
            all_out = false
            break

    if (all_out):
        # a separating plane was found
        # do not continue testing
        overlapping = false
        break

if (overlapping):
    # only do this check if no separating plane
    # was found in planes of A
    for p in planes_of_B:
        var all_out = true
        for v in points_of_A:
            if (p.distance_to(v) &lt; 0):
                all_out = false
                break

        if (all_out):
            overlapping = false
            break

if (overlapping):
    print("Polygons Collided!")</literal_block>
                    </div>
                    <div aria-labelledby="tab-10-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-10-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var overlapping = true;

foreach (Plane plane in planesOfA)
{
    var allOut = true;
    foreach (Vector3 point in pointsOfB)
    {
        if (plane.DistanceTo(point) &lt; 0)
        {
            allOut = false;
            break;
        }
    }

    if (allOut)
    {
        // a separating plane was found
        // do not continue testing
        overlapping = false;
        break;
    }
}

if (overlapping)
{
    // only do this check if no separating plane
    // was found in planes of A
    foreach (Plane plane in planesOfB)
    {
        var allOut = true;
        foreach (Vector3 point in pointsOfA)
        {
            if (plane.DistanceTo(point) &lt; 0)
            {
                allOut = false;
                break;
            }
        }

        if (allOut)
        {
            overlapping = false;
            break;
        }
    }
}

if (overlapping)
{
    GD.Print("Polygons Collided!");
}</literal_block>
                    </div>
                </container>
                <paragraph>As you can see, planes are quite useful, and this is the tip of the
                    iceberg. You might be wondering what happens with non convex polygons.
                    This is usually just handled by splitting the concave polygon into
                    smaller convex polygons, or using a technique such as BSP (which is not
                    used much nowadays).</paragraph>
            </section>
        </section>
        <section ids="collision-detection-in-3d" names="collision\ detection\ in\ 3d">
            <title>Collision detection in 3D</title>
            <paragraph>This is another bonus bit, a reward for being patient and keeping up
                with this long tutorial. Here is another piece of wisdom. This might
                not be something with a direct use case (Godot already does collision
                detection pretty well) but it's used by almost all physics engines and collision
                detection libraries :)</paragraph>
            <paragraph>Remember that converting a convex shape in 2D to an array of 2D planes
                was useful for collision detection? You could detect if a point was
                inside any convex shape, or if two 2D convex shapes were overlapping.</paragraph>
            <paragraph>Well, this works in 3D too, if two 3D polyhedral shapes are colliding,
                you won't be able to find a separating plane. If a separating plane is
                found, then the shapes are definitely not colliding.</paragraph>
            <paragraph>To refresh a bit a separating plane means that all vertices of polygon A
                are in one side of the plane, and all vertices of polygon B are in the
                other side. This plane is always one of the face-planes of either
                polygon A or polygon B.</paragraph>
            <paragraph>In 3D though, there is a problem to this approach, because it is
                possible that, in some cases a separating plane can't be found. This is
                an example of such situation:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/tutovec22.png'}" original_uri="img/tutovec22.png" uri="tutorials/math/img/tutovec22.png"></image>
            <paragraph>To avoid it, some extra planes need to be tested as separators, these
                planes are the cross product between the edges of polygon A and the
                edges of polygon B</paragraph>
            <image candidates="{'*': 'tutorials/math/img/tutovec23.png'}" original_uri="img/tutovec23.png" uri="tutorials/math/img/tutovec23.png"></image>
            <paragraph>So the final algorithm is something like:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-11-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-11-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-11-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var overlapping = true

for p in planes_of_A:
    var all_out = true
    for v in points_of_B:
        if (p.distance_to(v) &lt; 0):
            all_out = false
            break

    if (all_out):
        # a separating plane was found
        # do not continue testing
        overlapping = false
        break

if (overlapping):
    # only do this check if no separating plane
    # was found in planes of A
    for p in planes_of_B:
        var all_out = true
        for v in points_of_A:
            if (p.distance_to(v) &lt; 0):
                all_out = false
                break

        if (all_out):
            overlapping = false
            break

if (overlapping):
    for ea in edges_of_A:
        for eb in edges_of_B:
            var n = ea.cross(eb)
            if (n.length() == 0):
                continue

            var max_A = -1e20 # tiny number
            var min_A = 1e20 # huge number

            # we are using the dot product directly
            # so we can map a maximum and minimum range
            # for each polygon, then check if they
            # overlap.

            for v in points_of_A:
                var d = n.dot(v)
                max_A = max(max_A, d)
                min_A = min(min_A, d)

            var max_B = -1e20 # tiny number
            var min_B = 1e20 # huge number

            for v in points_of_B:
                var d = n.dot(v)
                max_B = max(max_B, d)
                min_B = min(min_B, d)

            if (min_A &gt; max_B or min_B &gt; max_A):
                # not overlapping!
                overlapping = false
                break

        if (not overlapping):
            break

if (overlapping):
   print("Polygons collided!")</literal_block>
                </div>
                <div aria-labelledby="tab-11-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-11-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var overlapping = true;

foreach (Plane plane in planesOfA)
{
    var allOut = true;
    foreach (Vector3 point in pointsOfB)
    {
        if (plane.DistanceTo(point) &lt; 0)
        {
            allOut = false;
            break;
        }
    }

    if (allOut)
    {
        // a separating plane was found
        // do not continue testing
        overlapping = false;
        break;
    }
}

if (overlapping)
{
    // only do this check if no separating plane
    // was found in planes of A
    foreach (Plane plane in planesOfB)
    {
        var allOut = true;
        foreach (Vector3 point in pointsOfA)
        {
            if (plane.DistanceTo(point) &lt; 0)
            {
                allOut = false;
                break;
            }
        }

        if (allOut)
        {
            overlapping = false;
            break;
        }
    }
}

if (overlapping)
{
    foreach (Vector3 edgeA in edgesOfA)
    {
        foreach (Vector3 edgeB in edgesOfB)
        {
            var normal = edgeA.Cross(edgeB);
            if (normal.Length() == 0)
            {
                continue;
            }

            var maxA = float.MinValue; // tiny number
            var minA = float.MaxValue; // huge number

            // we are using the dot product directly
            // so we can map a maximum and minimum range
            // for each polygon, then check if they
            // overlap.

            foreach (Vector3 point in pointsOfA)
            {
                var distance = normal.Dot(point);
                maxA = Mathf.Max(maxA, distance);
                minA = Mathf.Min(minA, distance);
            }

            var maxB = float.MinValue; // tiny number
            var minB = float.MaxValue; // huge number

            foreach (Vector3 point in pointsOfB)
            {
                var distance = normal.Dot(point);
                maxB = Mathf.Max(maxB, distance);
                minB = Mathf.Min(minB, distance);
            }

            if (minA &gt; maxB || minB &gt; maxA)
            {
                // not overlapping!
                overlapping = false;
                break;
            }
        }

        if (!overlapping)
        {
            break;
        }

    }
}

if (overlapping)
{
    GD.Print("Polygons Collided!");
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="more-information" names="more\ information">
            <title>More information</title>
            <paragraph>For more information on using vector math in Godot, see the following article:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="matrices_and_transforms#doc-matrices-and-transforms"><inline classes="std std-ref">Matrices and transforms</inline></reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If you would like additional explanation, you should check out
                3Blue1Brown's excellent video series
                <reference name="Essence of Linear Algebra" refuri="https://www.youtube.com/watch?v=fNk_zzaMoSs&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">Essence of Linear Algebra</reference><target ids="essence-of-linear-algebra" names="essence\ of\ linear\ algebra" refuri="https://www.youtube.com/watch?v=fNk_zzaMoSs&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab"></target>.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
