<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/math/vectors_advanced.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-vectors-advanced"></target>
    <section ids="advanced-vector-math doc-vectors-advanced" names="advanced\ vector\ math 高等向量数学 doc_vectors_advanced">
        <title>高等向量数学</title>
        <section ids="planes" names="planes 平面">
            <title>平面</title>
            <paragraph>单位向量的点积还有一个有趣的性质。请想象一个垂直于这个向量（且经过原点）的平面。平面会将整个空间划分为正（在平面上方）和负（在平面下方）两部分，并且（与普遍的看法相反）你也可以在 2D 中进行这样的数学运算：</paragraph>
            <image candidates="{'*': 'tutorials/math/img/tutovec10.png'}" uri="tutorials/math/img/tutovec10.png"></image>
            <paragraph>垂直于表面的单位向量称为<strong>单位法向量</strong>（因此描述的是表面的朝向），不过通常会简称为<emphasis>法线</emphasis>。平面、3D 几何体等场合中都会用到法线（用来确定面或顶点的属于哪一侧）。<strong>法线</strong>是一种<strong>单位向量</strong>，因为用途才被称为<emphasis>法线</emphasis>。（就像我们说坐标 (0,0) 是“原点”一样！）。</paragraph>
            <paragraph>平面经过原点，它的表面垂直于这条单位向量（即<emphasis>法线</emphasis>）。这条向量指向的一侧为正半空间，而另一侧则为负半空间。以上概念在 3D 中依旧适用，只不过平面不再是直线，而是一个无限的表面（想象一张固定在原点，无限伸展的平坦纸张）。</paragraph>
            <section ids="distance-to-plane" names="distance\ to\ plane 到平面的距离">
                <title>到平面的距离</title>
                <paragraph>现在平面是什么就很清楚了，让我们再回到点积上。<strong>单位向量</strong>和任何<strong>空间点</strong>之间的点积（是的，这次我们在向量和位置之间进行点乘），将返回<strong>从该点到平面的距离</strong>：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var distance = normal.dot(point)</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var distance = normal.Dot(point);</literal_block>
                    </div>
                </container>
                <paragraph>但返回的不止是距离的绝对值，如果点位于负半空间，那么这个距离也是负的：</paragraph>
                <image candidates="{'*': 'tutorials/math/img/tutovec11.png'}" uri="tutorials/math/img/tutovec11.png"></image>
                <paragraph>这样我们就能够知道点位于平面的哪一侧。</paragraph>
            </section>
            <section ids="away-from-the-origin" names="away\ from\ the\ origin 脱离原点">
                <title>脱离原点</title>
                <paragraph>我知道你在想什么！到目前为止还算不错，但<emphasis>真正的</emphasis>平面在空间中无处不在，并不一定要经过原点。你想要的是真正<emphasis>平面</emphasis>，你<emphasis>现在</emphasis>就想行动起来。</paragraph>
                <paragraph>请记住，平面不仅仅是将空间一分为二，这两个空间还有<emphasis>极性</emphasis>。也就是说，如果两个平面完全重合，它们的正负半空间可以相反。</paragraph>
                <paragraph>明确了这一点，我们就可以将完整的平面描述为<strong>法线</strong> <emphasis>N</emphasis> 和<strong>与原点的距离</strong>标量 <emphasis>D</emphasis>。这样用 N 和 D 就可以表示我们的平面了。例如：</paragraph>
                <image candidates="{'*': 'tutorials/math/img/tutovec12.png'}" uri="tutorials/math/img/tutovec12.png"></image>
                <paragraph>对于 3D 空间中的平面，Godot 提供了 <reference internal="True" refuri="../../classes/class_plane#class-plane"><inline classes="std std-ref">Plane</inline></reference> 内置类型来处理这些计算。</paragraph>
                <paragraph>Basically, N and D can represent any plane in space, be it for 2D or 3D
                    (depending on the amount of dimensions of N) and the math is the same
                    for both. It's the same as before, but D is the distance from the origin
                    to the plane, travelling in N direction. As an example, imagine you want
                    to reach a point in the plane, you will just do:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var point_in_plane = N*D</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var pointInPlane = N * D;</literal_block>
                    </div>
                </container>
                <paragraph>This will stretch (resize) the normal vector and make it touch the
                    plane. This math might seem confusing, but it's actually much simpler
                    than it seems. If we want to tell, again, the distance from the point to
                    the plane, we do the same but adjusting for distance:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var distance = N.dot(point) - D</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var distance = N.Dot(point) - D;</literal_block>
                    </div>
                </container>
                <paragraph>也可以用内置函数执行同样的计算：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var distance = plane.distance_to(point)</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var distance = plane.DistanceTo(point);</literal_block>
                    </div>
                </container>
                <paragraph>这同样会返回一个正或负的距离。</paragraph>
                <paragraph>Flipping the polarity of the plane can be done by negating both
                    N and D. This will result in a plane in the same position, but with
                    inverted negative and positive half spaces:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">N = -N
D = -D</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">N = -N;
D = -D;</literal_block>
                    </div>
                </container>
                <paragraph>在Godot中，同样也可以使用 <reference internal="True" refuri="../../classes/class_plane#class-plane"><inline classes="std std-ref">Plane</inline></reference> 中实现这个操作，示范如下：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var inverted_plane = -plane</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var invertedPlane = -plane;</literal_block>
                    </div>
                </container>
                <paragraph>因此，谨记，向量数学当中，平面的主要用途就是计算某个点到它的距离。那么，什么时候计算点到平面的距离有用呢？下文将提供应用实例。</paragraph>
            </section>
            <section ids="constructing-a-plane-in-2d" names="constructing\ a\ plane\ in\ 2d 在二维空间中构造平面">
                <title>在二维空间中构造平面</title>
                <paragraph>平面不会凭空出现，必须先进行构造。在 2D 空间中构造平面很简单：只需要法线（单位向量）和某一个点，或者空间中任意两点都可以完成。</paragraph>
                <paragraph>在法线和点的情况下，由于法线已经被计算出来，大部分计算工作都已完成。因此，只需根据法线和点的点积计算 D 即可。</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var N = normal
var D = normal.dot(point)</literal_block>
                    </div>
                    <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var N = normal;
var D = normal.Dot(point);</literal_block>
                    </div>
                </container>
                <paragraph>而在空间中任意两点的情况下，空间内会有两个平面同时经过两点：这两个平面共享同一个空间，但其法线方向相反。因此，为计算这两点的法线，必须先获得方向向量，然后将其向两侧旋转 90° ：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Calculate vector from `a` to `b`.
var dvec = point_a.direction_to(point_b)
# Rotate 90 degrees.
var normal = Vector2(dvec.y, -dvec.x)
# Alternatively (depending the desired side of the normal):
# var normal = Vector2(-dvec.y, dvec.x)</literal_block>
                    </div>
                    <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Calculate vector from `a` to `b`.
var dvec = pointA.DirectionTo(pointB);
// Rotate 90 degrees.
var normal = new Vector2(dvec.Y, -dvec.X);
// Alternatively (depending the desired side of the normal):
// var normal = new Vector2(-dvec.Y, dvec.X);</literal_block>
                    </div>
                </container>
                <paragraph>剩余步骤与前例相同。point_a 和 point_b 都可以用于计算，毕竟两者位于同一个平面内：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var N = normal
var D = normal.dot(point_a)
# this works the same
# var D = normal.dot(point_b)</literal_block>
                    </div>
                    <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var N = normal;
var D = normal.Dot(pointA);
// this works the same
// var D = normal.Dot(pointB);</literal_block>
                    </div>
                </container>
                <paragraph>在 3D 空间中构造平面更加复杂，下文会进一步解释。</paragraph>
            </section>
            <section ids="some-examples-of-planes" names="some\ examples\ of\ planes 平面的一些示例">
                <title>平面的一些示例</title>
                <paragraph>该示例将介绍平面的用途。假设有一个 <reference name="凸" refuri="https://www.mathsisfun.com/definitions/convex.html">凸</reference> 多边形。比如矩形、梯形、三角形或任何没有面向内弯曲的多边形。</paragraph>
                <paragraph>对多边形的每一段，我们通过计算获取经过该段的平面。重复以上操作，直到获得多边形的平面列表后，我们就可以基于该列表，做些简单的事情，例如检查某点是否处于多边形内部。</paragraph>
                <paragraph>我们遍历所有平面，如果能找到一个到点的距离为正的平面，那么该点就在多边形外；反之，该点就在多边形内。</paragraph>
                <image candidates="{'*': 'tutorials/math/img/tutovec13.png'}" uri="tutorials/math/img/tutovec13.png"></image>
                <paragraph>上述思路的代码实现如下：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var inside = true
for p in planes:
    # check if distance to plane is positive
    if (p.distance_to(point) &gt; 0):
        inside = false
        break # with one that fails, it's enough</literal_block>
                    </div>
                    <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var inside = true;
foreach (var p in planes)
{
    // check if distance to plane is positive
    if (p.DistanceTo(point) &gt; 0)
    {
        inside = false;
        break; // with one that fails, it's enough
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>很酷吧？不过它还能做到更多！只要再花点心思，类似的逻辑也能让我们知道两个凸多边形是否重叠。这就是所谓的分离轴定理 ( Separating Axis Theorem, SAT )，多数物理引擎基于该定理检测碰撞。</paragraph>
                <paragraph>对于点的检测，只需检查平面是否返回正距离，就足以判断该点是否在外部。而对于多边形之间的检测，我们必须找到一个平面，使得另一个多边形上的所有点到该平面的距离都为正。在代码实现方面，可以先用多边形 A 的平面对多边形 B 的点进行检查，再用多边形 B 的平面对多边形 A 的点进行检查：</paragraph>
                <image candidates="{'*': 'tutorials/math/img/tutovec14.png'}" uri="tutorials/math/img/tutovec14.png"></image>
                <paragraph>上述思路的代码实现如下：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-10-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-10-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-10-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var overlapping = true

for p in planes_of_A:
    var all_out = true
    for v in points_of_B:
        if (p.distance_to(v) &lt; 0):
            all_out = false
            break

    if (all_out):
        # a separating plane was found
        # do not continue testing
        overlapping = false
        break

if (overlapping):
    # only do this check if no separating plane
    # was found in planes of A
    for p in planes_of_B:
        var all_out = true
        for v in points_of_A:
            if (p.distance_to(v) &lt; 0):
                all_out = false
                break

        if (all_out):
            overlapping = false
            break

if (overlapping):
    print("Polygons Collided!")</literal_block>
                    </div>
                    <div aria-labelledby="tab-10-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-10-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var overlapping = true;

foreach (Plane plane in planesOfA)
{
    var allOut = true;
    foreach (Vector3 point in pointsOfB)
    {
        if (plane.DistanceTo(point) &lt; 0)
        {
            allOut = false;
            break;
        }
    }

    if (allOut)
    {
        // a separating plane was found
        // do not continue testing
        overlapping = false;
        break;
    }
}

if (overlapping)
{
    // only do this check if no separating plane
    // was found in planes of A
    foreach (Plane plane in planesOfB)
    {
        var allOut = true;
        foreach (Vector3 point in pointsOfA)
        {
            if (plane.DistanceTo(point) &lt; 0)
            {
                allOut = false;
                break;
            }
        }

        if (allOut)
        {
            overlapping = false;
            break;
        }
    }
}

if (overlapping)
{
    GD.Print("Polygons Collided!");
}</literal_block>
                    </div>
                </container>
                <paragraph>As you can see, planes are quite useful, and this is the tip of the
                    iceberg. You might be wondering what happens with non convex polygons.
                    This is usually just handled by splitting the concave polygon into
                    smaller convex polygons, or using a technique such as BSP (which is not
                    used much nowadays).</paragraph>
            </section>
        </section>
        <section ids="collision-detection-in-3d" names="collision\ detection\ in\ 3d 三维环境下的碰撞检测">
            <title>三维环境下的碰撞检测</title>
            <paragraph>这是本章的另一个奖励内容，是对你耐心看完这本长篇教程的奖励：以下内容是又一个前人的智慧结晶，虽然它不算是个直接能拿来用的实例（ Godot 的碰撞检测功能已经足够好了），但是接下来的内容是几乎所有物理引擎和碰撞检测库都在使用的一个原理 : )</paragraph>
            <paragraph>还记得把 2D 中的凸形转换成 2D 平面阵列可用于碰撞检测吗？你可以检测一个点是否在任何凸面形内，或两个 2D 凸面形是否重叠。</paragraph>
            <paragraph>其实，这在 3D 中也同样适用：如果两个 3D 多面体相撞，你将无法找到这两个多面体的分离平面。反之，如果能找到分离平面，那么这两个图形肯定不会发生碰撞。</paragraph>
            <paragraph>To refresh a bit a separating plane means that all vertices of polygon A
                are in one side of the plane, and all vertices of polygon B are in the
                other side. This plane is always one of the face-planes of either
                polygon A or polygon B.</paragraph>
            <paragraph>不过，在 3D 空间中，这种思路存在一个问题：某些情况下可能找不到分离平面。下文就是这种情况的一个示例：</paragraph>
            <image candidates="{'*': 'tutorials/math/img/tutovec22.png'}" uri="tutorials/math/img/tutovec22.png"></image>
            <paragraph>为了避免这种情况，一些额外的平面需要作为分隔器被测试，这些平面是多边形 A 的边和多边形 B 的边的叉积</paragraph>
            <image candidates="{'*': 'tutorials/math/img/tutovec23.png'}" uri="tutorials/math/img/tutovec23.png"></image>
            <paragraph>所以，最后的算法代码差不多像这样：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-11-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-11-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-11-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var overlapping = true

for p in planes_of_A:
    var all_out = true
    for v in points_of_B:
        if (p.distance_to(v) &lt; 0):
            all_out = false
            break

    if (all_out):
        # a separating plane was found
        # do not continue testing
        overlapping = false
        break

if (overlapping):
    # only do this check if no separating plane
    # was found in planes of A
    for p in planes_of_B:
        var all_out = true
        for v in points_of_A:
            if (p.distance_to(v) &lt; 0):
                all_out = false
                break

        if (all_out):
            overlapping = false
            break

if (overlapping):
    for ea in edges_of_A:
        for eb in edges_of_B:
            var n = ea.cross(eb)
            if (n.length() == 0):
                continue

            var max_A = -1e20 # tiny number
            var min_A = 1e20 # huge number

            # we are using the dot product directly
            # so we can map a maximum and minimum range
            # for each polygon, then check if they
            # overlap.

            for v in points_of_A:
                var d = n.dot(v)
                max_A = max(max_A, d)
                min_A = min(min_A, d)

            var max_B = -1e20 # tiny number
            var min_B = 1e20 # huge number

            for v in points_of_B:
                var d = n.dot(v)
                max_B = max(max_B, d)
                min_B = min(min_B, d)

            if (min_A &gt; max_B or min_B &gt; max_A):
                # not overlapping!
                overlapping = false
                break

        if (not overlapping):
            break

if (overlapping):
   print("Polygons collided!")</literal_block>
                </div>
                <div aria-labelledby="tab-11-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-11-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var overlapping = true;

foreach (Plane plane in planesOfA)
{
    var allOut = true;
    foreach (Vector3 point in pointsOfB)
    {
        if (plane.DistanceTo(point) &lt; 0)
        {
            allOut = false;
            break;
        }
    }

    if (allOut)
    {
        // a separating plane was found
        // do not continue testing
        overlapping = false;
        break;
    }
}

if (overlapping)
{
    // only do this check if no separating plane
    // was found in planes of A
    foreach (Plane plane in planesOfB)
    {
        var allOut = true;
        foreach (Vector3 point in pointsOfA)
        {
            if (plane.DistanceTo(point) &lt; 0)
            {
                allOut = false;
                break;
            }
        }

        if (allOut)
        {
            overlapping = false;
            break;
        }
    }
}

if (overlapping)
{
    foreach (Vector3 edgeA in edgesOfA)
    {
        foreach (Vector3 edgeB in edgesOfB)
        {
            var normal = edgeA.Cross(edgeB);
            if (normal.Length() == 0)
            {
                continue;
            }

            var maxA = float.MinValue; // tiny number
            var minA = float.MaxValue; // huge number

            // we are using the dot product directly
            // so we can map a maximum and minimum range
            // for each polygon, then check if they
            // overlap.

            foreach (Vector3 point in pointsOfA)
            {
                var distance = normal.Dot(point);
                maxA = Mathf.Max(maxA, distance);
                minA = Mathf.Min(minA, distance);
            }

            var maxB = float.MinValue; // tiny number
            var minB = float.MaxValue; // huge number

            foreach (Vector3 point in pointsOfB)
            {
                var distance = normal.Dot(point);
                maxB = Mathf.Max(maxB, distance);
                minB = Mathf.Min(minB, distance);
            }

            if (minA &gt; maxB || minB &gt; maxA)
            {
                // not overlapping!
                overlapping = false;
                break;
            }
        }

        if (!overlapping)
        {
            break;
        }

    }
}

if (overlapping)
{
    GD.Print("Polygons Collided!");
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="more-information" names="more\ information 更多信息">
            <title>更多信息</title>
            <paragraph>有关在 Godot 中使用向量数学的更多信息，请参阅以下文章：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="matrices_and_transforms#doc-matrices-and-transforms"><inline classes="std std-ref">矩阵与变换</inline></reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>如果你需要进一步的解释，你可以看看 3Blue1Brown 的绝佳的系列视频《线性代数的本质》：<reference refuri="http://www.bilibili.com/video/BV1ys411472E?p=2">http://www.bilibili.com/video/BV1ys411472E?p=2</reference></paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
