<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/math/interpolation.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-interpolation"></target>
    <section ids="interpolation doc-interpolation" names="interpolation doc_interpolation">
        <title>Interpolation</title>
        <paragraph>Interpolation is a common operation in graphics programming, which is used to
            blend or transition between two values. Interpolation can also be used to smooth
            movement, rotation, etc. It's good to become familiar with it in order to expand
            your horizons as a game developer.</paragraph>
        <paragraph>The basic idea is that you want to transition from A to B. A value <literal>t</literal>, represents the states in-between.</paragraph>
        <paragraph>For example, if <literal>t</literal> is 0, then the state is A. If <literal>t</literal> is 1, then the state is B. Anything in-between is an <emphasis>interpolation</emphasis>.</paragraph>
        <paragraph>Between two real (floating-point) numbers, an interpolation can be described as:</paragraph>
        <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">interpolation = A * (1 - t) + B * t</literal_block>
        <paragraph>And often simplified to:</paragraph>
        <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">interpolation = A + (B - A) * t</literal_block>
        <paragraph>The name of this type of interpolation, which transforms a value into another at <emphasis>constant speed</emphasis> is <emphasis>"linear"</emphasis>. So, when you hear about <emphasis>Linear Interpolation</emphasis>, you know they are referring to this formula.</paragraph>
        <paragraph>There are other types of interpolations, which will not be covered here. A recommended read afterwards is the <reference internal="True" refuri="beziers_and_curves#doc-beziers-and-curves"><inline classes="std std-ref">Bezier</inline></reference> page.</paragraph>
        <section ids="vector-interpolation" names="vector\ interpolation">
            <title>Vector interpolation</title>
            <paragraph>Vector types (<reference internal="True" refuri="../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> and <reference internal="True" refuri="../../classes/class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) can also be interpolated, they come with handy functions to do it
                <reference internal="True" refuri="../../classes/class_vector2#class-vector2-method-lerp"><inline classes="std std-ref">Vector2.lerp()</inline></reference> and <reference internal="True" refuri="../../classes/class_vector3#class-vector3-method-lerp"><inline classes="std std-ref">Vector3.lerp()</inline></reference>.</paragraph>
            <paragraph>For cubic interpolation, there are also <reference internal="True" refuri="../../classes/class_vector2#class-vector2-method-cubic-interpolate"><inline classes="std std-ref">Vector2.cubic_interpolate()</inline></reference> and <reference internal="True" refuri="../../classes/class_vector3#class-vector3-method-cubic-interpolate"><inline classes="std std-ref">Vector3.cubic_interpolate()</inline></reference>, which do a <reference internal="True" refuri="beziers_and_curves#doc-beziers-and-curves"><inline classes="std std-ref">Bezier</inline></reference> style interpolation.</paragraph>
            <paragraph>Here is example pseudo-code for going from point A to B using interpolation:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var t = 0.0

func _physics_process(delta):
    t += delta * 0.4

    $Sprite2D.position = $A.position.lerp($B.position, t)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private float _t = 0.0f;

public override void _PhysicsProcess(double delta)
{
    _t += (float)delta * 0.4f;

    Marker2D a = GetNode&lt;Marker2D&gt;("A");
    Marker2D b = GetNode&lt;Marker2D&gt;("B");
    Sprite2D sprite = GetNode&lt;Sprite2D&gt;("Sprite2D");

    sprite.Position = a.Position.Lerp(b.Position, _t);
}</literal_block>
                </div>
            </container>
            <paragraph>It will produce the following motion:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/interpolation_vector.gif'}" original_uri="img/interpolation_vector.gif" uri="tutorials/math/img/interpolation_vector.gif"></image>
        </section>
        <section ids="transform-interpolation" names="transform\ interpolation">
            <title>Transform interpolation</title>
            <paragraph>It is also possible to interpolate whole transforms (make sure they have either uniform scale or, at least, the same non-uniform scale).
                For this, the function <reference internal="True" refuri="../../classes/class_transform3d#class-transform3d-method-interpolate-with"><inline classes="std std-ref">Transform3D.interpolate_with()</inline></reference> can be used.</paragraph>
            <paragraph>Here is an example of transforming a monkey from Position1 to Position2:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/interpolation_positions.png'}" original_uri="img/interpolation_positions.png" uri="tutorials/math/img/interpolation_positions.png"></image>
            <paragraph>Using the following pseudocode:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var t = 0.0

func _physics_process(delta):
    t += delta

    $Monkey.transform = $Position1.transform.interpolate_with($Position2.transform, t)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private float _t = 0.0f;

public override void _PhysicsProcess(double delta)
{
    _t += (float)delta;

    Marker3D p1 = GetNode&lt;Marker3D&gt;("Position1");
    Marker3D p2 = GetNode&lt;Marker3D&gt;("Position2");
    CSGMesh3D monkey = GetNode&lt;CSGMesh3D&gt;("Monkey");

    monkey.Transform = p1.Transform.InterpolateWith(p2.Transform, _t);
}</literal_block>
                </div>
            </container>
            <paragraph>And again, it will produce the following motion:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/interpolation_monkey.gif'}" original_uri="img/interpolation_monkey.gif" uri="tutorials/math/img/interpolation_monkey.gif"></image>
        </section>
        <section ids="smoothing-motion" names="smoothing\ motion">
            <title>Smoothing motion</title>
            <paragraph>Interpolation can be used to smoothly follow a moving target value, such as a
                position or a rotation. Each frame, <literal>lerp()</literal> moves the current value towards
                the target value by a fixed percentage of the remaining difference between the values.
                The current value will smoothly move towards the target, slowing down as it gets
                closer. Here is an example of a circle following the mouse using interpolation smoothing:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">const FOLLOW_SPEED = 4.0

func _physics_process(delta):
    var mouse_pos = get_local_mouse_position()

    $Sprite2D.position = $Sprite2D.position.lerp(mouse_pos, delta * FOLLOW_SPEED)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private const float FollowSpeed = 4.0f;

public override void _PhysicsProcess(double delta)
{
    Vector2 mousePos = GetLocalMousePosition();

    Sprite2D sprite = GetNode&lt;Sprite2D&gt;("Sprite2D");

    sprite.Position = sprite.Position.Lerp(mousePos, (float)delta * FollowSpeed);
}</literal_block>
                </div>
            </container>
            <paragraph>Here is how it looks:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/interpolation_follow.gif'}" original_uri="img/interpolation_follow.gif" uri="tutorials/math/img/interpolation_follow.gif"></image>
            <paragraph>This is useful for smoothing camera movement, for allies following the player
                (ensuring they stay within a certain range), and for many other common game patterns.</paragraph>
            <note>
                <paragraph>Despite using <literal>delta</literal>, the formula used above is framerate-dependent, because
                    the <literal>weight</literal> parameter of <literal>lerp()</literal> represents a <emphasis>percentage</emphasis> of the remaining
                    difference in values, not an <emphasis>absolute amount to change</emphasis>. In <literal>_physics_process()</literal>,
                    this is usually fine because physics is expected to maintain a constant framerate,
                    and therefore <literal>delta</literal> is expected to remain constant.</paragraph>
                <paragraph>For a framerate-independent version of interpolation smoothing that can also
                    be used in <literal>process()</literal>, use the following formula instead:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">const FOLLOW_SPEED = 4.0

func _process(delta):
    var mouse_pos = get_local_mouse_position()
    var weight = 1 - exp(-FOLLOW_SPEED * delta)
    $Sprite2D.position = $Sprite2D.position.lerp(mouse_pos, weight)</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private const float FollowSpeed = 4.0f;

public override void _Process(double delta)
{
    Vector2 mousePos = GetLocalMousePosition();

    Sprite2D sprite = GetNode&lt;Sprite2D&gt;("Sprite2D");
    float weight = 1f - Mathf.Exp(-FollowSpeed * (float)delta);
    sprite.Position = sprite.Position.Lerp(mousePos, weight);
}</literal_block>
                    </div>
                </container>
                <paragraph>Deriving this formula is beyond the scope of this page. For an explanation,
                    see <reference name="Improved Lerp Smoothing" refuri="https://www.gamedeveloper.com/programming/improved-lerp-smoothing-">Improved Lerp Smoothing</reference>
                    or watch <reference name="Lerp smoothing is broken" refuri="https://www.youtube.com/watch?v=LSNQuFEDOyQ">Lerp smoothing is broken</reference>.</paragraph>
            </note>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
