<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/math/vector_math.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-vector-math"></target>
    <section ids="vector-math doc-vector-math" names="vector\ math doc_vector_math">
        <title>Vector math</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>This tutorial is a short and practical introduction to linear algebra as it
                applies to game development. Linear algebra is the study of vectors and their
                uses. Vectors have many applications in both 2D and 3D development and Godot
                uses them extensively. Developing a good understanding of vector math is
                essential to becoming a strong game developer.</paragraph>
            <note>
                <paragraph>This tutorial is <strong>not</strong> a formal textbook on linear algebra. We will
                    only be looking at how it is applied to game development. For a
                    broader look at the mathematics, see
                    <reference refuri="https://www.khanacademy.org/math/linear-algebra">https://www.khanacademy.org/math/linear-algebra</reference></paragraph>
            </note>
        </section>
        <section ids="coordinate-systems-2d" names="coordinate\ systems\ (2d)">
            <title>Coordinate systems (2D)</title>
            <paragraph>In 2D space, coordinates are defined using a horizontal axis (<literal>x</literal>) and a
                vertical axis (<literal>y</literal>). A particular position in 2D space is written as a pair of
                values such as <literal>(4, 3)</literal>.</paragraph>
            <image candidates="{'*': 'tutorials/math/img/vector_axis1.png'}" original_uri="img/vector_axis1.png" uri="tutorials/math/img/vector_axis1.png"></image>
            <note>
                <paragraph>If you're new to computer graphics, it might seem odd that the
                    positive <literal>y</literal> axis points <strong>downwards</strong> instead of upwards, as you
                    probably learned in math class. However, this is common in most
                    computer graphics applications.</paragraph>
            </note>
            <paragraph>Any position in the 2D plane can be identified by a pair of numbers in this way.
                However, we can also think of the position <literal>(4, 3)</literal> as an <strong>offset</strong> from the
                <literal>(0, 0)</literal> point, or <strong>origin</strong>. Draw an arrow pointing from the origin to the
                point:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/vector_xy1.png'}" original_uri="img/vector_xy1.png" uri="tutorials/math/img/vector_xy1.png"></image>
            <paragraph>This is a <strong>vector</strong>. A vector represents a lot of useful information. As well
                as telling us that the point is at <literal>(4, 3)</literal>, we can also think of it as an
                angle <literal>θ</literal> (theta) and a length (or magnitude) <literal>m</literal>. In this case, the arrow
                is a <strong>position vector</strong> - it denotes a position in space, relative to the
                origin.</paragraph>
            <paragraph>A very important point to consider about vectors is that they only represent
                <strong>relative</strong> direction and magnitude. There is no concept of a vector's
                position. The following two vectors are identical:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/vector_xy2.png'}" original_uri="img/vector_xy2.png" uri="tutorials/math/img/vector_xy2.png"></image>
            <paragraph>Both vectors represent a point 4 units to the right and 3 units below some
                starting point. It does not matter where on the plane you draw the vector, it
                always represents a relative direction and magnitude.</paragraph>
        </section>
        <section ids="vector-operations" names="vector\ operations">
            <title>Vector operations</title>
            <paragraph>You can use either method (x and y coordinates or angle and magnitude) to refer
                to a vector, but for convenience, programmers typically use the coordinate
                notation. For example, in Godot, the origin is the top-left corner of the
                screen, so to place a 2D node named <literal>Node2D</literal> 400 pixels to the right and 300
                pixels down, use the following code:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">$Node2D.position = Vector2(400, 300)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var node2D = GetNode&lt;Node2D&gt;("Node2D");
node2D.Position = new Vector2(400, 300);</literal_block>
                </div>
            </container>
            <paragraph>Godot supports both <reference internal="True" refuri="../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> and <reference internal="True" refuri="../../classes/class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> for 2D and 3D usage, respectively. The same mathematical rules
                discussed in this article apply to both types, and wherever we link to
                <literal>Vector2</literal> methods in the class reference, you can also check out their
                <literal>Vector3</literal> counterparts.</paragraph>
            <section ids="member-access" names="member\ access">
                <title>Member access</title>
                <paragraph>The individual components of the vector can be accessed directly by name.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Create a vector with coordinates (2, 5).
var a = Vector2(2, 5)
# Create a vector and assign x and y manually.
var b = Vector2()
b.x = 3
b.y = 1</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Create a vector with coordinates (2, 5).
var a = new Vector2(2, 5);
// Create a vector and assign x and y manually.
var b = new Vector2();
b.X = 3;
b.Y = 1;</literal_block>
                    </div>
                </container>
            </section>
            <section ids="adding-vectors" names="adding\ vectors">
                <title>Adding vectors</title>
                <paragraph>When adding or subtracting two vectors, the corresponding components are added:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var c = a + b  # (2, 5) + (3, 1) = (5, 6)</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var c = a + b;  // (2, 5) + (3, 1) = (5, 6)</literal_block>
                    </div>
                </container>
                <paragraph>We can also see this visually by adding the second vector at the end of
                    the first:</paragraph>
                <image candidates="{'*': 'tutorials/math/img/vector_add1.png'}" original_uri="img/vector_add1.png" uri="tutorials/math/img/vector_add1.png"></image>
                <paragraph>Note that adding <literal>a + b</literal> gives the same result as <literal>b + a</literal>.</paragraph>
            </section>
            <section ids="scalar-multiplication" names="scalar\ multiplication">
                <title>Scalar multiplication</title>
                <note>
                    <paragraph>Vectors represent both direction and magnitude. A value representing
                        only magnitude is called a <strong>scalar</strong>. Scalars use the
                        <reference internal="True" refuri="../../classes/class_float#class-float"><inline classes="std std-ref">float</inline></reference> type in Godot.</paragraph>
                </note>
                <paragraph>A vector can be multiplied by a <strong>scalar</strong>:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var c = a * 2  # (2, 5) * 2 = (4, 10)
var d = b / 3  # (3, 6) / 3 = (1, 2)
var e = d * -2 # (1, 2) * -2 = (-2, -4)</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var c = a * 2;  // (2, 5) * 2 = (4, 10)
var d = b / 3;  // (3, 6) / 3 = (1, 2)
var e = d * -2; // (1, 2) * -2 = (-2, -4)</literal_block>
                    </div>
                </container>
                <image candidates="{'*': 'tutorials/math/img/vector_mult1.png'}" original_uri="img/vector_mult1.png" uri="tutorials/math/img/vector_mult1.png"></image>
                <note>
                    <paragraph>Multiplying a vector by a positive scalar does not change its direction, only
                        its magnitude. Multiplying with a negative scalar results in a vector in the
                        opposite direction. This is how you <strong>scale</strong> a vector.</paragraph>
                </note>
            </section>
        </section>
        <section ids="practical-applications" names="practical\ applications">
            <title>Practical applications</title>
            <paragraph>Let's look at two common uses for vector addition and subtraction.</paragraph>
            <section ids="movement" names="movement">
                <title>Movement</title>
                <paragraph>A vector can represent <strong>any</strong> quantity with a magnitude and direction. Typical
                    examples are: position, velocity, acceleration, and force. In this image, the
                    spaceship at step 1 has a position vector of <literal>(1, 3)</literal> and a velocity vector of
                    <literal>(2, 1)</literal>. The velocity vector represents how far the ship moves each step. We
                    can find the position for step 2 by adding the velocity to the current position.</paragraph>
                <image candidates="{'*': 'tutorials/math/img/vector_movement1.png'}" original_uri="img/vector_movement1.png" uri="tutorials/math/img/vector_movement1.png"></image>
                <tip>
                    <paragraph>Velocity measures the <strong>change</strong> in position per unit of time. The new
                        position is found by adding the velocity multiplied by the elapsed time
                        (here assumed to be one unit, e.g. 1 s) to the previous position.</paragraph>
                    <paragraph>In a typical 2D game scenario, you would have a velocity in pixels per
                        second, and multiply it by the <literal>delta</literal> parameter (time elapsed since
                        the previous frame) from the <reference internal="True" refuri="../../classes/class_node#class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference>
                        or <reference internal="True" refuri="../../classes/class_node#class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference>
                        callbacks.</paragraph>
                </tip>
            </section>
            <section ids="pointing-toward-a-target" names="pointing\ toward\ a\ target">
                <title>Pointing toward a target</title>
                <paragraph>In this scenario, you have a tank that wishes to point its turret at a robot.
                    Subtracting the tank's position from the robot's position gives the vector
                    pointing from the tank to the robot.</paragraph>
                <image candidates="{'*': 'tutorials/math/img/vector_subtract2.webp'}" original_uri="img/vector_subtract2.webp" uri="tutorials/math/img/vector_subtract2.webp"></image>
                <tip>
                    <paragraph>To find a vector pointing from <literal>A</literal> to <literal>B</literal>, use <literal>B - A</literal>.</paragraph>
                </tip>
            </section>
        </section>
        <section ids="unit-vectors" names="unit\ vectors">
            <title>Unit vectors</title>
            <paragraph>A vector with <strong>magnitude</strong> of <literal>1</literal> is called a <strong>unit vector</strong>. They are also
                sometimes referred to as <strong>direction vectors</strong> or <strong>normals</strong>. Unit vectors are
                helpful when you need to keep track of a direction.</paragraph>
            <section ids="normalization" names="normalization">
                <title>Normalization</title>
                <paragraph><strong>Normalizing</strong> a vector means reducing its length to <literal>1</literal> while preserving its
                    direction. This is done by dividing each of its components by its magnitude.
                    Because this is such a common operation, Godot provides a dedicated
                    <reference internal="True" refuri="../../classes/class_vector2#class-vector2-method-normalized"><inline classes="std std-ref">normalized()</inline></reference> method for this:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">a = a.normalized()</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">a = a.Normalized();</literal_block>
                    </div>
                </container>
                <warning>
                    <paragraph>Because normalization involves dividing by the vector's length, you
                        cannot normalize a vector of length <literal>0</literal>. Attempting to do so
                        would normally result in an error. In GDScript though, trying to
                        call the <literal>normalized()</literal> method on a vector of length 0 leaves the
                        value untouched and avoids the error for you.</paragraph>
                </warning>
            </section>
            <section ids="reflection" names="reflection">
                <title>Reflection</title>
                <paragraph>A common use of unit vectors is to indicate <strong>normals</strong>. Normal vectors are unit
                    vectors aligned perpendicularly to a surface, defining its direction. They are
                    commonly used for lighting, collisions, and other operations involving surfaces.</paragraph>
                <paragraph>For example, imagine we have a moving ball that we want to bounce off a wall or
                    other object:</paragraph>
                <image candidates="{'*': 'tutorials/math/img/vector_reflect1.png'}" original_uri="img/vector_reflect1.png" uri="tutorials/math/img/vector_reflect1.png"></image>
                <paragraph>The surface normal has a value of <literal>(0, -1)</literal> because this is a horizontal
                    surface. When the ball collides, we take its remaining motion (the amount left
                    over when it hits the surface) and reflect it using the normal. In Godot, there
                    is a <reference internal="True" refuri="../../classes/class_vector2#class-vector2-method-bounce"><inline classes="std std-ref">bounce()</inline></reference> method to handle this.
                    Here is a code example of the above diagram using a <reference internal="True" refuri="../../classes/class_characterbody2d#class-characterbody2d"><inline classes="std std-ref">CharacterBody2D</inline></reference>:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var collision: KinematicCollision2D = move_and_collide(velocity * delta)
if collision:
    var reflect = collision.get_remainder().bounce(collision.get_normal())
    velocity = velocity.bounce(collision.get_normal())
    move_and_collide(reflect)</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">KinematicCollision2D collision = MoveAndCollide(_velocity * (float)delta);
if (collision != null)
{
    var reflect = collision.GetRemainder().Bounce(collision.GetNormal());
    _velocity = _velocity.Bounce(collision.GetNormal());
    MoveAndCollide(reflect);
}</literal_block>
                    </div>
                </container>
            </section>
        </section>
        <section ids="dot-product" names="dot\ product">
            <title>Dot product</title>
            <paragraph>The <strong>dot product</strong> is one of the most important concepts in vector math, but is
                often misunderstood. Dot product is an operation on two vectors that returns a
                <strong>scalar</strong>. Unlike a vector, which contains both magnitude and direction, a
                scalar value has only magnitude.</paragraph>
            <paragraph>The formula for dot product takes two common forms:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/vector_dot1.png'}" original_uri="img/vector_dot1.png" uri="tutorials/math/img/vector_dot1.png"></image>
            <paragraph>and</paragraph>
            <image candidates="{'*': 'tutorials/math/img/vector_dot2.png'}" original_uri="img/vector_dot2.png" uri="tutorials/math/img/vector_dot2.png"></image>
            <paragraph>The mathematical notation <emphasis>||A||</emphasis> represents the magnitude of vector <literal>A</literal>, and
                <emphasis>A</emphasis><subscript>x</subscript> means the <literal>x</literal> component of vector <literal>A</literal>.</paragraph>
            <paragraph>However, in most cases it is easiest to use the built-in <reference internal="True" refuri="../../classes/class_vector2#class-vector2-method-dot"><inline classes="std std-ref">dot()</inline></reference> method. Note that the order of the two vectors does not matter:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var c = a.dot(b)
var d = b.dot(a)  # These are equivalent.</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">float c = a.Dot(b);
float d = b.Dot(a);  // These are equivalent.</literal_block>
                </div>
            </container>
            <paragraph>The dot product is most useful when used with unit vectors, making the first
                formula reduce to just <literal>cos(θ)</literal>. This means we can use the dot product to tell
                us something about the angle between two vectors:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/vector_dot3.png'}" original_uri="img/vector_dot3.png" uri="tutorials/math/img/vector_dot3.png"></image>
            <paragraph>When using unit vectors, the result will always be between <literal>-1</literal> (180°) and
                <literal>1</literal> (0°).</paragraph>
            <section ids="facing" names="facing">
                <title>Facing</title>
                <paragraph>We can use this fact to detect whether an object is facing toward another
                    object. In the diagram below, the player <literal>P</literal> is trying to avoid the zombies
                    <literal>A</literal> and <literal>B</literal>. Assuming a zombie's field of view is <strong>180°</strong>, can they see the
                    player?</paragraph>
                <image candidates="{'*': 'tutorials/math/img/vector_facing2.png'}" original_uri="img/vector_facing2.png" uri="tutorials/math/img/vector_facing2.png"></image>
                <paragraph>The green arrows <literal>fA</literal> and <literal>fB</literal> are <strong>unit vectors</strong> representing the
                    zombie's facing direction and the blue semicircle represents its field of view.
                    For zombie <literal>A</literal>, we find the direction vector <literal>AP</literal> pointing to the player
                    using <literal>P - A</literal> and normalize it, however, Godot has a helper method to do this
                    called <reference internal="True" refuri="../../classes/class_vector2#class-vector2-method-direction-to"><inline classes="std std-ref">direction_to()</inline></reference>. If the angle
                    between this vector and the facing vector is less than 90°, then the zombie can
                    see the player.</paragraph>
                <paragraph>In code it would look like this:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var AP = A.direction_to(P)
if AP.dot(fA) &gt; 0:
    print("A sees P!")</literal_block>
                    </div>
                    <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var AP = A.DirectionTo(P);
if (AP.Dot(fA) &gt; 0)
{
    GD.Print("A sees P!");
}</literal_block>
                    </div>
                </container>
            </section>
        </section>
        <section ids="cross-product" names="cross\ product">
            <title>Cross product</title>
            <paragraph>Like the dot product, the <strong>cross product</strong> is an operation on two vectors.
                However, the result of the cross product is a vector with a direction that is
                perpendicular to both. Its magnitude depends on their relative angle. If two
                vectors are parallel, the result of their cross product will be a null vector.</paragraph>
            <image candidates="{'*': 'tutorials/math/img/vector_cross1.png'}" original_uri="img/vector_cross1.png" uri="tutorials/math/img/vector_cross1.png"></image>
            <image candidates="{'*': 'tutorials/math/img/vector_cross2.png'}" original_uri="img/vector_cross2.png" uri="tutorials/math/img/vector_cross2.png"></image>
            <paragraph>The cross product is calculated like this:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var c = Vector3()
c.x = (a.y * b.z) - (a.z * b.y)
c.y = (a.z * b.x) - (a.x * b.z)
c.z = (a.x * b.y) - (a.y * b.x)</literal_block>
                </div>
                <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var c = new Vector3();
c.X = (a.Y * b.Z) - (a.Z * b.Y);
c.Y = (a.Z * b.X) - (a.X * b.Z);
c.Z = (a.X * b.Y) - (a.Y * b.X);</literal_block>
                </div>
            </container>
            <paragraph>With Godot, you can use the built-in <reference internal="True" refuri="../../classes/class_vector3#class-vector3-method-cross"><inline classes="std std-ref">Vector3.cross()</inline></reference>
                method:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var c = a.cross(b)</literal_block>
                </div>
                <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var c = a.Cross(b);</literal_block>
                </div>
            </container>
            <paragraph>The cross product is not mathematically defined in 2D. The <reference internal="True" refuri="../../classes/class_vector2#class-vector2-method-cross"><inline classes="std std-ref">Vector2.cross()</inline></reference> method is a commonly used analog of the 3D cross
                product for 2D vectors.</paragraph>
            <note>
                <paragraph>In the cross product, order matters. <literal>a.cross(b)</literal> does not give the
                    same result as <literal>b.cross(a)</literal>. The resulting vectors point in
                    <strong>opposite</strong> directions.</paragraph>
            </note>
            <section ids="calculating-normals" names="calculating\ normals">
                <title>Calculating normals</title>
                <paragraph>One common use of cross products is to find the surface normal of a plane or
                    surface in 3D space. If we have the triangle <literal>ABC</literal> we can use vector
                    subtraction to find two edges <literal>AB</literal> and <literal>AC</literal>. Using the cross product,
                    <literal>AB × AC</literal> produces a vector perpendicular to both: the surface normal.</paragraph>
                <paragraph>Here is a function to calculate a triangle's normal:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-10-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-10-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-10-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func get_triangle_normal(a, b, c):
    # Find the surface normal given 3 vertices.
    var side1 = b - a
    var side2 = c - a
    var normal = side1.cross(side2)
    return normal</literal_block>
                    </div>
                    <div aria-labelledby="tab-10-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-10-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Vector3 GetTriangleNormal(Vector3 a, Vector3 b, Vector3 c)
{
    // Find the surface normal given 3 vertices.
    var side1 = b - a;
    var side2 = c - a;
    var normal = side1.Cross(side2);
    return normal;
}</literal_block>
                    </div>
                </container>
            </section>
            <section ids="pointing-to-a-target" names="pointing\ to\ a\ target">
                <title>Pointing to a target</title>
                <paragraph>In the dot product section above, we saw how it could be used to find the angle
                    between two vectors. However, in 3D, this is not enough information. We also
                    need to know what axis to rotate around. We can find that by calculating the
                    cross product of the current facing direction and the target direction. The
                    resulting perpendicular vector is the axis of rotation.</paragraph>
            </section>
        </section>
        <section ids="more-information" names="more\ information">
            <title>More information</title>
            <paragraph>For more information on using vector math in Godot, see the following articles:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="vectors_advanced#doc-vectors-advanced"><inline classes="std std-ref">Advanced vector math</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="matrices_and_transforms#doc-matrices-and-transforms"><inline classes="std std-ref">Matrices and transforms</inline></reference></paragraph>
                </list_item>
            </bullet_list>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
