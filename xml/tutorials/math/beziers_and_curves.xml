<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/math/beziers_and_curves.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-beziers-and-curves"></target>
    <section ids="beziers-curves-and-paths doc-beziers-and-curves" names="beziers,\ curves\ and\ paths 贝塞尔、曲线和路径 doc_beziers_and_curves">
        <title>贝塞尔、曲线和路径</title>
        <paragraph>贝塞尔曲线是一种自然几何形状的数学近似. 我们用它们来代表一个曲线, 含有尽可能少的信息, 保持高水平的灵活性.</paragraph>
        <paragraph>不像抽象的数学概念, 贝塞尔曲线是为工业设计. 它们是图形软件行业中的流行工具.</paragraph>
        <paragraph>它们依赖于 <reference internal="True" refuri="interpolation#doc-interpolation"><inline classes="std std-ref">插值</inline></reference>, 我们在上一篇文章中看到, 如何结合多个步骤来创建平滑的曲线. 为了更好地理解贝塞尔曲线的工作原理, 我们从最简单的形式开始: 二次贝塞尔曲线.</paragraph>
        <section ids="quadratic-bezier" names="quadratic\ bezier 二次贝塞尔曲线">
            <title>二次贝塞尔曲线</title>
            <paragraph>取三个点, 这是建立二次贝塞尔曲线所需的最小值:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_quadratic_points.png'}" uri="tutorials/math/img/bezier_quadratic_points.png"></image>
            <paragraph>要在它们之间画一条曲线，我们首先使用 0 到 1 之间的值，在由这三个点构成的两个线段的每个顶点上逐步插值。当我们把 <literal>t</literal> 值从 0 变成 1 时，就得到了两个沿着线段移动的点。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _quadratic_bezier(p0: Vector2, p1: Vector2, p2: Vector2, t: float):
    var q0 = p0.lerp(p1, t)
    var q1 = p1.lerp(p2, t)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private Vector2 QuadraticBezier(Vector2 p0, Vector2 p1, Vector2 p2, float t)
{
    Vector2 q0 = p0.Lerp(p1, t);
    Vector2 q1 = p1.Lerp(p2, t);
}</literal_block>
                </div>
            </container>
            <paragraph>然后，我们插值 <literal>q0</literal> 和 <literal>q1</literal>，以获得沿着曲线移动的单点 <literal>r</literal>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var r = q0.lerp(q1, t)
return r</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Vector2 r = q0.Lerp(q1, t);
return r;</literal_block>
                </div>
            </container>
            <paragraph>这种类型的曲线就被称为<emphasis>二次贝塞尔</emphasis>曲线。</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_quadratic_points2.gif'}" uri="tutorials/math/img/bezier_quadratic_points2.gif"></image>
            <paragraph><emphasis>(图像来源: 维基百科)</emphasis></paragraph>
        </section>
        <section ids="cubic-bezier" names="cubic\ bezier 三次贝塞尔曲线">
            <title>三次贝塞尔曲线</title>
            <paragraph>基于前面的例子, 我们可以通过在四个点之间插值得到更多的控制.</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_cubic_points.png'}" uri="tutorials/math/img/bezier_cubic_points.png"></image>
            <paragraph>首先我们使用一个带有四个参数的函数，以 <literal>p0</literal>、<literal>p1</literal>、<literal>p2</literal>、<literal>p3</literal> 四个点作为输入：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _cubic_bezier(p0: Vector2, p1: Vector2, p2: Vector2, p3: Vector2, t: float):</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public Vector2 CubicBezier(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3, float t)
{

}</literal_block>
                </div>
            </container>
            <paragraph>我们对每两个点进行线性插值, 将它们减少到三个:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var q0 = p0.lerp(p1, t)
var q1 = p1.lerp(p2, t)
var q2 = p2.lerp(p3, t)</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Vector2 q0 = p0.Lerp(p1, t);
Vector2 q1 = p1.Lerp(p2, t);
Vector2 q2 = p2.Lerp(p3, t);</literal_block>
                </div>
            </container>
            <paragraph>然后我们把这三个点缩减为两个点:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var r0 = q0.lerp(q1, t)
var r1 = q1.lerp(q2, t)</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Vector2 r0 = q0.Lerp(q1, t);
Vector2 r1 = q1.Lerp(q2, t);</literal_block>
                </div>
            </container>
            <paragraph>然后到一个:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var s = r0.lerp(r1, t)
return s</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Vector2 s = r0.Lerp(r1, t);
return s;</literal_block>
                </div>
            </container>
            <paragraph>这里给出了完整的函数:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _cubic_bezier(p0: Vector2, p1: Vector2, p2: Vector2, p3: Vector2, t: float):
    var q0 = p0.lerp(p1, t)
    var q1 = p1.lerp(p2, t)
    var q2 = p2.lerp(p3, t)

    var r0 = q0.lerp(q1, t)
    var r1 = q1.lerp(q2, t)

    var s = r0.lerp(r1, t)
    return s</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private Vector2 CubicBezier(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3, float t)
{
    Vector2 q0 = p0.Lerp(p1, t);
    Vector2 q1 = p1.Lerp(p2, t);
    Vector2 q2 = p2.Lerp(p3, t);

    Vector2 r0 = q0.Lerp(q1, t);
    Vector2 r1 = q1.Lerp(q2, t);

    Vector2 s = r0.Lerp(r1, t);
    return s;
}</literal_block>
                </div>
            </container>
            <paragraph>结果将是在所有四个点之间的平滑曲线插值:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_cubic_points.gif'}" uri="tutorials/math/img/bezier_cubic_points.gif"></image>
            <paragraph><emphasis>(图像来源: 维基百科)</emphasis></paragraph>
            <note>
                <paragraph>三次贝塞尔插值在三维中也是一样的，只需使用 <literal>Vector3</literal> 代替 <literal>Vector2</literal>。</paragraph>
            </note>
        </section>
        <section ids="adding-control-points" names="adding\ control\ points 添加控制点">
            <title>添加控制点</title>
            <paragraph>在三次贝塞尔的基础上，我们可以通过改变两个点的工作方式来自由地控制曲线的形状。我们不使用 <literal>p0</literal>、<literal>p1</literal>、<literal>p2</literal>、<literal>p3</literal>，而是将它们存储为：</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph><literal>point0 = p0</literal>：是第一个点，即源</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>control0 = p1 - p0</literal>：是相对于第一个控制点的向量</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>control1 = p3 - p2</literal>：是相对于第二个控制点的向量</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>point1 = p3</literal>：是第二个点，即终点</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>使用这种方式, 有两个点和两个控制点, 它们是各自点的相对向量. 如果你以前用过图形或动画软件, 这可能看起来很熟悉:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_cubic_handles.png'}" uri="tutorials/math/img/bezier_cubic_handles.png"></image>
            <paragraph>这就是图形软件如何向用户呈现贝塞尔曲线, 以及它们在Godot引擎内的工作原理.</paragraph>
        </section>
        <section ids="curve2d-curve3d-path-and-path2d" names="curve2d,\ curve3d,\ path\ and\ path2d curve2d、curve3d、path\ 以及\ path2d">
            <title>Curve2D、Curve3D、Path 以及 Path2D</title>
            <paragraph>有两个对象包含曲线 <reference internal="True" refuri="../../classes/class_curve3d#class-curve3d"><inline classes="std std-ref">Curve3D</inline></reference> 和 <reference internal="True" refuri="../../classes/class_curve2d#class-curve2d"><inline classes="std std-ref">Curve2D</inline></reference>（分别代表 3D 和 2D）。</paragraph>
            <paragraph>They can contain several points, allowing for longer paths. It is also possible to set them to nodes: <reference internal="True" refuri="../../classes/class_path3d#class-path3d"><inline classes="std std-ref">Path3D</inline></reference> and <reference internal="True" refuri="../../classes/class_path2d#class-path2d"><inline classes="std std-ref">Path2D</inline></reference> (also for 3D and 2D respectively):</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_path_2d.png'}" uri="tutorials/math/img/bezier_path_2d.png"></image>
            <paragraph>然而它们的使用方法可能不是很直观，下面是对贝塞尔曲线最常见用例的描述。</paragraph>
        </section>
        <section ids="evaluating" names="evaluating 估值">
            <title>估值</title>
            <paragraph>Only evaluating them may be an option, but in most cases it's not very useful. The big drawback with Bezier curves is that if you traverse them at constant speed, from <literal>t = 0</literal> to <literal>t = 1</literal>, the actual interpolation will <emphasis>not</emphasis> move at constant speed. The speed is also an interpolation between the distances between points <literal>p0</literal>, <literal>p1</literal>, <literal>p2</literal> and <literal>p3</literal> and there is not a mathematically simple way to traverse the curve at constant speed.</paragraph>
            <paragraph>Let's do an example with the following pseudocode:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var t = 0.0

func _process(delta):
    t += delta
    position = _cubic_bezier(p0, p1, p2, p3, t)</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private float _t = 0.0f;

public override void _Process(double delta)
{
    _t += (float)delta;
    Position = CubicBezier(p0, p1, p2, p3, _t);
}</literal_block>
                </div>
            </container>
            <image candidates="{'*': 'tutorials/math/img/bezier_interpolation_speed.gif'}" uri="tutorials/math/img/bezier_interpolation_speed.gif"></image>
            <paragraph>如你所见，即便 <literal>t</literal> 在匀速递增，圆点的速度还是在不断变化的（以像素每秒为单位）。这也使贝塞尔难以做到任何实际的开箱即用。</paragraph>
        </section>
        <section ids="drawing" names="drawing 绘制">
            <title>绘制</title>
            <paragraph>绘制贝塞尔(或基于曲线的对象)是很常见的用例, 但这也不容易. 几乎在任何情况下, 贝塞尔曲线需要被转换成某种线段. 这通常很难, 然而, 并没有创建非常高数量的线段.</paragraph>
            <paragraph>原因是曲线的某些部分(具体来说是角落)可能需要相当多的点, 而其他部分不一定:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_point_amount.png'}" uri="tutorials/math/img/bezier_point_amount.png"></image>
            <paragraph>另外，如果两个控制点都是 <literal>0,0</literal>（请记住它们是相对向量），贝塞尔曲线就是一条直线（所以画很多点就是在浪费时间）。</paragraph>
            <paragraph>在绘制贝塞尔曲线之前, 需要进行 <emphasis>细分</emphasis> . 这通常是用递归函数或除法函数来完成的, 它可以分割曲线, 直到曲率变得小于某个阈值.</paragraph>
            <paragraph><emphasis>Curve</emphasis> 类通过 <reference internal="True" refuri="../../classes/class_curve2d#class-curve2d-method-tessellate"><inline classes="std std-ref">Curve2D.tessellate()</inline></reference> 函数来提供该功能(函数接收可选的 <literal>stages</literal> 递归和角度 <literal>tolerance</literal> 参数). 这样一来, 基于曲线画东西就比较容易了.</paragraph>
        </section>
        <section ids="traversal" names="traversal 遍历">
            <title>遍历</title>
            <paragraph>最后曲线最常见的用例是遍历. 因为之前提到关于匀速的内容, 这也是困难的.</paragraph>
            <paragraph>To make this easier, the curves need to be <emphasis>baked</emphasis> into equidistant points. This way, they can be approximated with regular interpolation (which can be improved further with a cubic option). To do this, just use the <reference internal="True" refuri="../../classes/class_curve3d#class-curve3d-method-sample-baked"><inline classes="std std-ref">Curve3D.sample_baked()</inline></reference> method together with
                <reference internal="True" refuri="../../classes/class_curve2d#class-curve2d-method-get-baked-length"><inline classes="std std-ref">Curve2D.get_baked_length()</inline></reference>. The first call to either of them will bake the curve internally.</paragraph>
            <paragraph>匀速遍历, 然后, 可以用下面的伪代码:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var t = 0.0

func _process(delta):
    t += delta
    position = curve.sample_baked(t * curve.get_baked_length(), true)</literal_block>
                </div>
                <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private float _t = 0.0f;

public override void _Process(double delta)
{
    _t += (float)delta;
    Position = curve.SampleBaked(_t * curve.GetBakedLength(), true);
}</literal_block>
                </div>
            </container>
            <paragraph>并且输出, 然后匀速移动:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_interpolation_baked.gif'}" uri="tutorials/math/img/bezier_interpolation_baked.gif"></image>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
