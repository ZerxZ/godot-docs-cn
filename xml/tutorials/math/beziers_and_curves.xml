<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/math/beziers_and_curves.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-beziers-and-curves"></target>
    <section ids="beziers-curves-and-paths doc-beziers-and-curves" names="beziers,\ curves\ and\ paths doc_beziers_and_curves">
        <title>Beziers, curves and paths</title>
        <paragraph>Bezier curves are a mathematical approximation of natural geometric shapes. We
            use them to represent a curve with as little information as possible and with a
            high level of flexibility.</paragraph>
        <paragraph>Unlike more abstract mathematical concepts, Bezier curves were created for
            industrial design. They are a popular tool in the graphics software industry.</paragraph>
        <paragraph>They rely on <reference internal="True" refuri="interpolation#doc-interpolation"><inline classes="std std-ref">interpolation</inline></reference>, which we saw in the
            previous article, combining multiple steps to create smooth curves. To better
            understand how Bezier curves work, let's start from its simplest form: Quadratic
            Bezier.</paragraph>
        <section ids="quadratic-bezier" names="quadratic\ bezier">
            <title>Quadratic Bezier</title>
            <paragraph>Take three points, the minimum required for Quadratic Bezier to work:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_quadratic_points.png'}" original_uri="img/bezier_quadratic_points.png" uri="tutorials/math/img/bezier_quadratic_points.png"></image>
            <paragraph>To draw a curve between them, we first interpolate gradually over the two
                vertices of each of the two segments formed by the three points, using values
                ranging from 0 to 1. This gives us two points that move along the segments as we
                change the value of <literal>t</literal> from 0 to 1.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _quadratic_bezier(p0: Vector2, p1: Vector2, p2: Vector2, t: float):
    var q0 = p0.lerp(p1, t)
    var q1 = p1.lerp(p2, t)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private Vector2 QuadraticBezier(Vector2 p0, Vector2 p1, Vector2 p2, float t)
{
    Vector2 q0 = p0.Lerp(p1, t);
    Vector2 q1 = p1.Lerp(p2, t);
}</literal_block>
                </div>
            </container>
            <paragraph>We then interpolate <literal>q0</literal> and <literal>q1</literal> to obtain a single point <literal>r</literal> that moves
                along a curve.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var r = q0.lerp(q1, t)
return r</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Vector2 r = q0.Lerp(q1, t);
return r;</literal_block>
                </div>
            </container>
            <paragraph>This type of curve is called a <emphasis>Quadratic Bezier</emphasis> curve.</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_quadratic_points2.gif'}" original_uri="img/bezier_quadratic_points2.gif" uri="tutorials/math/img/bezier_quadratic_points2.gif"></image>
            <paragraph><emphasis>(Image credit: Wikipedia)</emphasis></paragraph>
        </section>
        <section ids="cubic-bezier" names="cubic\ bezier">
            <title>Cubic Bezier</title>
            <paragraph>Building upon the previous example, we can get more control by interpolating
                between four points.</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_cubic_points.png'}" original_uri="img/bezier_cubic_points.png" uri="tutorials/math/img/bezier_cubic_points.png"></image>
            <paragraph>We first use a function with four parameters to take four points as an input,
                <literal>p0</literal>, <literal>p1</literal>, <literal>p2</literal> and <literal>p3</literal>:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _cubic_bezier(p0: Vector2, p1: Vector2, p2: Vector2, p3: Vector2, t: float):</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public Vector2 CubicBezier(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3, float t)
{

}</literal_block>
                </div>
            </container>
            <paragraph>We apply a linear interpolation to each couple of points to reduce them to
                three:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var q0 = p0.lerp(p1, t)
var q1 = p1.lerp(p2, t)
var q2 = p2.lerp(p3, t)</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Vector2 q0 = p0.Lerp(p1, t);
Vector2 q1 = p1.Lerp(p2, t);
Vector2 q2 = p2.Lerp(p3, t);</literal_block>
                </div>
            </container>
            <paragraph>We then take our three points and reduce them to two:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var r0 = q0.lerp(q1, t)
var r1 = q1.lerp(q2, t)</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Vector2 r0 = q0.Lerp(q1, t);
Vector2 r1 = q1.Lerp(q2, t);</literal_block>
                </div>
            </container>
            <paragraph>And to one:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var s = r0.lerp(r1, t)
return s</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Vector2 s = r0.Lerp(r1, t);
return s;</literal_block>
                </div>
            </container>
            <paragraph>Here is the full function:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _cubic_bezier(p0: Vector2, p1: Vector2, p2: Vector2, p3: Vector2, t: float):
    var q0 = p0.lerp(p1, t)
    var q1 = p1.lerp(p2, t)
    var q2 = p2.lerp(p3, t)

    var r0 = q0.lerp(q1, t)
    var r1 = q1.lerp(q2, t)

    var s = r0.lerp(r1, t)
    return s</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private Vector2 CubicBezier(Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3, float t)
{
    Vector2 q0 = p0.Lerp(p1, t);
    Vector2 q1 = p1.Lerp(p2, t);
    Vector2 q2 = p2.Lerp(p3, t);

    Vector2 r0 = q0.Lerp(q1, t);
    Vector2 r1 = q1.Lerp(q2, t);

    Vector2 s = r0.Lerp(r1, t);
    return s;
}</literal_block>
                </div>
            </container>
            <paragraph>The result will be a smooth curve interpolating between all four points:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_cubic_points.gif'}" original_uri="img/bezier_cubic_points.gif" uri="tutorials/math/img/bezier_cubic_points.gif"></image>
            <paragraph><emphasis>(Image credit: Wikipedia)</emphasis></paragraph>
            <note>
                <paragraph>Cubic Bezier interpolation works the same in 3D, just use <literal>Vector3</literal>
                    instead of <literal>Vector2</literal>.</paragraph>
            </note>
        </section>
        <section ids="adding-control-points" names="adding\ control\ points">
            <title>Adding control points</title>
            <paragraph>Building upon Cubic Bezier, we can change the way two of the points work to
                control the shape of our curve freely. Instead of having <literal>p0</literal>, <literal>p1</literal>, <literal>p2</literal>
                and <literal>p3</literal>, we will store them as:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph><literal>point0 = p0</literal>: Is the first point, the source</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>control0 = p1 - p0</literal>: Is a vector relative to the first control point</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>control1 = p3 - p2</literal>: Is a vector relative to the second control point</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>point1 = p3</literal>: Is the second point, the destination</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>This way, we have two points and two control points which are relative vectors
                to the respective points. If you've used graphics or animation software before,
                this might look familiar:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_cubic_handles.png'}" original_uri="img/bezier_cubic_handles.png" uri="tutorials/math/img/bezier_cubic_handles.png"></image>
            <paragraph>This is how graphics software presents Bezier curves to the users, and how they
                work and look in Godot.</paragraph>
        </section>
        <section ids="curve2d-curve3d-path-and-path2d" names="curve2d,\ curve3d,\ path\ and\ path2d">
            <title>Curve2D, Curve3D, Path and Path2D</title>
            <paragraph>There are two objects that contain curves: <reference internal="True" refuri="../../classes/class_curve3d#class-curve3d"><inline classes="std std-ref">Curve3D</inline></reference> and <reference internal="True" refuri="../../classes/class_curve2d#class-curve2d"><inline classes="std std-ref">Curve2D</inline></reference> (for 3D and 2D respectively).</paragraph>
            <paragraph>They can contain several points, allowing for longer paths. It is also possible to set them to nodes: <reference internal="True" refuri="../../classes/class_path3d#class-path3d"><inline classes="std std-ref">Path3D</inline></reference> and <reference internal="True" refuri="../../classes/class_path2d#class-path2d"><inline classes="std std-ref">Path2D</inline></reference> (also for 3D and 2D respectively):</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_path_2d.png'}" original_uri="img/bezier_path_2d.png" uri="tutorials/math/img/bezier_path_2d.png"></image>
            <paragraph>Using them, however, may not be completely obvious, so following is a description of the most common use cases for Bezier curves.</paragraph>
        </section>
        <section ids="evaluating" names="evaluating">
            <title>Evaluating</title>
            <paragraph>Only evaluating them may be an option, but in most cases it's not very useful. The big drawback with Bezier curves is that if you traverse them at constant speed, from <literal>t = 0</literal> to <literal>t = 1</literal>, the actual interpolation will <emphasis>not</emphasis> move at constant speed. The speed is also an interpolation between the distances between points <literal>p0</literal>, <literal>p1</literal>, <literal>p2</literal> and <literal>p3</literal> and there is not a mathematically simple way to traverse the curve at constant speed.</paragraph>
            <paragraph>Let's do an example with the following pseudocode:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var t = 0.0

func _process(delta):
    t += delta
    position = _cubic_bezier(p0, p1, p2, p3, t)</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private float _t = 0.0f;

public override void _Process(double delta)
{
    _t += (float)delta;
    Position = CubicBezier(p0, p1, p2, p3, _t);
}</literal_block>
                </div>
            </container>
            <image candidates="{'*': 'tutorials/math/img/bezier_interpolation_speed.gif'}" original_uri="img/bezier_interpolation_speed.gif" uri="tutorials/math/img/bezier_interpolation_speed.gif"></image>
            <paragraph>As you can see, the speed (in pixels per second) of the circle varies, even though <literal>t</literal> is increased at constant speed. This makes beziers difficult to use for anything practical out of the box.</paragraph>
        </section>
        <section ids="drawing" names="drawing">
            <title>Drawing</title>
            <paragraph>Drawing beziers (or objects based on the curve) is a very common use case, but it's also not easy. For pretty much any case, Bezier curves need to be converted to some sort of segments. This is normally difficult, however, without creating a very high amount of them.</paragraph>
            <paragraph>The reason is that some sections of a curve (specifically, corners) may require considerable amounts of points, while other sections may not:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_point_amount.png'}" original_uri="img/bezier_point_amount.png" uri="tutorials/math/img/bezier_point_amount.png"></image>
            <paragraph>Additionally, if both control points were <literal>0, 0</literal> (remember they are relative vectors), the Bezier curve would just be a straight line (so drawing a high amount of points would be wasteful).</paragraph>
            <paragraph>Before drawing Bezier curves, <emphasis>tessellation</emphasis> is required. This is often done with a recursive or divide and conquer function that splits the curve until the curvature amount becomes less than a certain threshold.</paragraph>
            <paragraph>The <emphasis>Curve</emphasis> classes provide this via the
                <reference internal="True" refuri="../../classes/class_curve2d#class-curve2d-method-tessellate"><inline classes="std std-ref">Curve2D.tessellate()</inline></reference> function (which receives optional <literal>stages</literal> of recursion and angle <literal>tolerance</literal> arguments). This way, drawing something based on a curve is easier.</paragraph>
        </section>
        <section ids="traversal" names="traversal">
            <title>Traversal</title>
            <paragraph>The last common use case for the curves is to traverse them. Because of what was mentioned before regarding constant speed, this is also difficult.</paragraph>
            <paragraph>To make this easier, the curves need to be <emphasis>baked</emphasis> into equidistant points. This way, they can be approximated with regular interpolation (which can be improved further with a cubic option). To do this, just use the <reference internal="True" refuri="../../classes/class_curve3d#class-curve3d-method-sample-baked"><inline classes="std std-ref">Curve3D.sample_baked()</inline></reference> method together with
                <reference internal="True" refuri="../../classes/class_curve2d#class-curve2d-method-get-baked-length"><inline classes="std std-ref">Curve2D.get_baked_length()</inline></reference>. The first call to either of them will bake the curve internally.</paragraph>
            <paragraph>Traversal at constant speed, then, can be done with the following pseudo-code:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var t = 0.0

func _process(delta):
    t += delta
    position = curve.sample_baked(t * curve.get_baked_length(), true)</literal_block>
                </div>
                <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private float _t = 0.0f;

public override void _Process(double delta)
{
    _t += (float)delta;
    Position = curve.SampleBaked(_t * curve.GetBakedLength(), true);
}</literal_block>
                </div>
            </container>
            <paragraph>And the output will, then, move at constant speed:</paragraph>
            <image candidates="{'*': 'tutorials/math/img/bezier_interpolation_baked.gif'}" original_uri="img/bezier_interpolation_baked.gif" uri="tutorials/math/img/bezier_interpolation_baked.gif"></image>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
