<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/math/matrices_and_transforms.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-matrices-and-transforms"></target>
    <section ids="matrices-and-transforms doc-matrices-and-transforms" names="matrices\ and\ transforms doc_matrices_and_transforms">
        <title>Matrices and transforms</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>Before reading this tutorial, we recommend that you thoroughly read
                and understand the <reference internal="True" refuri="vector_math#doc-vector-math"><inline classes="std std-ref">Vector math</inline></reference> tutorial, as this tutorial
                requires a knowledge of vectors.</paragraph>
            <paragraph>This tutorial is about <emphasis>transformations</emphasis> and how we represent them
                in Godot using matrices. It is not a full in-depth guide to matrices.
                Transformations are most of the time applied as translation, rotation,
                and scale, so we will focus on how to represent those with matrices.</paragraph>
            <paragraph>Most of this guide focuses on 2D, using <reference internal="True" refuri="../../classes/class_transform2d#class-transform2d"><inline classes="std std-ref">Transform2D</inline></reference> and
                <reference internal="True" refuri="../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, but the way things work in 3D is very similar.</paragraph>
            <note>
                <paragraph>As mentioned in the previous tutorial, it is important to
                    remember that in Godot, the Y axis points <emphasis>down</emphasis> in 2D.
                    This is the opposite of how most schools teach linear
                    algebra, with the Y axis pointing up.</paragraph>
            </note>
            <note>
                <paragraph>The convention is that the X axis is red, the Y axis is
                    green, and the Z axis is blue. This tutorial is color-coded
                    to match these conventions, but we will also represent
                    the origin vector with a blue color.</paragraph>
            </note>
            <section ids="matrix-components-and-the-identity-matrix" names="matrix\ components\ and\ the\ identity\ matrix">
                <title>Matrix components and the Identity matrix</title>
                <paragraph>The identity matrix represents a transform with no translation,
                    no rotation, and no scale. Let's start by looking at the identity
                    matrix and how its components relate to how it visually appears.</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/identity.png'}" original_uri="img/matrices_and_transforms/identity.png" uri="tutorials/math/img/matrices_and_transforms/identity.png"></image>
                <paragraph>Matrices have rows and columns, and a transformation matrix has
                    specific conventions on what each does.</paragraph>
                <paragraph>In the image above, we can see that the red X vector is represented
                    by the first column of the matrix, and the green Y vector is
                    likewise represented by the second column. A change to the columns
                    will change these vectors. We will see how they can be manipulated
                    in the next few examples.</paragraph>
                <paragraph>You should not worry about manipulating rows directly, as we usually
                    work with columns. However, you can think of the rows of the matrix
                    as showing which vectors contribute to moving in a given direction.</paragraph>
                <paragraph>When we refer to a value such as <literal>t.x.y</literal>, that's the Y component of
                    the X column vector. In other words, the bottom-left of the matrix.
                    Similarly, <literal>t.x.x</literal> is top-left, <literal>t.y.x</literal> is top-right, and <literal>t.y.y</literal>
                    is bottom-right, where <literal>t</literal> is the Transform2D.</paragraph>
            </section>
            <section ids="scaling-the-transformation-matrix" names="scaling\ the\ transformation\ matrix">
                <title>Scaling the transformation matrix</title>
                <paragraph>Applying a scale is one of the easiest operations to understand.
                    Let's start by placing the Godot logo underneath our vectors
                    so that we can visually see the effects on an object:</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/identity-godot.png'}" original_uri="img/matrices_and_transforms/identity-godot.png" uri="tutorials/math/img/matrices_and_transforms/identity-godot.png"></image>
                <paragraph>Now, to scale the matrix, all we need to do is multiply each
                    component by the scale we want. Let's scale it up by 2. 1 times 2
                    becomes 2, and 0 times 2 becomes 0, so we end up with this:</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/scale.png'}" original_uri="img/matrices_and_transforms/scale.png" uri="tutorials/math/img/matrices_and_transforms/scale.png"></image>
                <paragraph>To do this in code, we multiply each of the vectors:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var t = Transform2D()
# Scale
t.x *= 2
t.y *= 2
transform = t # Change the node's transform to what we calculated.</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Transform2D t = Transform2D.Identity;
// Scale
t.X *= 2;
t.Y *= 2;
Transform = t; // Change the node's transform to what we calculated.</literal_block>
                    </div>
                </container>
                <paragraph>If we wanted to return it to its original scale, we can multiply
                    each component by 0.5. That's pretty much all there is to scaling
                    a transformation matrix.</paragraph>
                <paragraph>To calculate the object's scale from an existing transformation
                    matrix, you can use <literal>length()</literal> on each of the column vectors.</paragraph>
                <note>
                    <paragraph>In actual projects, you can use the <literal>scaled()</literal>
                        method to perform scaling.</paragraph>
                </note>
            </section>
            <section ids="rotating-the-transformation-matrix" names="rotating\ the\ transformation\ matrix">
                <title>Rotating the transformation matrix</title>
                <paragraph>We'll start the same way as earlier, with the Godot logo underneath
                    the identity matrix:</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/identity-godot.png'}" original_uri="img/matrices_and_transforms/identity-godot.png" uri="tutorials/math/img/matrices_and_transforms/identity-godot.png"></image>
                <paragraph>As an example, let's say we want to rotate our Godot logo clockwise
                    by 90 degrees. Right now the X axis points right and the Y axis
                    points down. If we rotate these in our head, we would logically
                    see that the new X axis should point down and the new Y axis
                    should point left.</paragraph>
                <paragraph>You can imagine that you grab both the Godot logo and its vectors,
                    and then spin it around the center. Wherever you finish spinning,
                    the orientation of the vectors determines what the matrix is.</paragraph>
                <paragraph>We need to represent "down" and "left" in normal coordinates,
                    so means we'll set X to (0, 1) and Y to (-1, 0). These are
                    also the values of <literal>Vector2.DOWN</literal> and <literal>Vector2.LEFT</literal>.
                    When we do this, we get the desired result of rotating the object:</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/rotate1.png'}" original_uri="img/matrices_and_transforms/rotate1.png" uri="tutorials/math/img/matrices_and_transforms/rotate1.png"></image>
                <paragraph>If you have trouble understanding the above, try this exercise:
                    Cut a square of paper, draw X and Y vectors on top of it, place
                    it on graph paper, then rotate it and note the endpoints.</paragraph>
                <paragraph>To perform rotation in code, we need to be able to calculate
                    the values programmatically. This image shows the formulas needed
                    to calculate the transformation matrix from a rotation angle.
                    Don't worry if this part seems complicated, I promise it's the
                    hardest thing you need to know.</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/rotate2.png'}" original_uri="img/matrices_and_transforms/rotate2.png" uri="tutorials/math/img/matrices_and_transforms/rotate2.png"></image>
                <note>
                    <paragraph>Godot represents all rotations with radians, not degrees.
                        A full turn is <title_reference>TAU</title_reference> or <title_reference>PI*2</title_reference> radians, and a quarter
                        turn of 90 degrees is <title_reference>TAU/4</title_reference> or <title_reference>PI/2</title_reference> radians. Working
                        with <title_reference>TAU</title_reference> usually results in more readable code.</paragraph>
                </note>
                <note>
                    <paragraph>Fun fact: In addition to Y being <emphasis>down</emphasis> in Godot, rotation
                        is represented clockwise. This means that all the math and
                        trig functions behave the same as a Y-is-up CCW system,
                        since these differences "cancel out". You can think of
                        rotations in both systems being "from X to Y".</paragraph>
                </note>
                <paragraph>In order to perform a rotation of 0.5 radians (about 28.65 degrees),
                    we plug in a value of 0.5 to the formula above and evaluate
                    to find what the actual values should be:</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/rotate3.png'}" original_uri="img/matrices_and_transforms/rotate3.png" uri="tutorials/math/img/matrices_and_transforms/rotate3.png"></image>
                <paragraph>Here's how that would be done in code (place the script on a Node2D):</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var rot = 0.5 # The rotation to apply.
var t = Transform2D()
t.x.x = cos(rot)
t.y.y = cos(rot)
t.x.y = sin(rot)
t.y.x = -sin(rot)
transform = t # Change the node's transform to what we calculated.</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">float rot = 0.5f; // The rotation to apply.
Transform2D t = Transform2D.Identity;
t.X.X = t.Y.Y = Mathf.Cos(rot);
t.X.Y = t.Y.X = Mathf.Sin(rot);
t.Y.X *= -1;
Transform = t; // Change the node's transform to what we calculated.</literal_block>
                    </div>
                </container>
                <paragraph>To calculate the object's rotation from an existing transformation
                    matrix, you can use <literal>atan2(t.x.y, t.x.x)</literal>, where t is the Transform2D.</paragraph>
                <note>
                    <paragraph>In actual projects, you can use the <literal>rotated()</literal>
                        method to perform rotations.</paragraph>
                </note>
            </section>
            <section ids="basis-of-the-transformation-matrix" names="basis\ of\ the\ transformation\ matrix">
                <title>Basis of the transformation matrix</title>
                <paragraph>So far we have only been working with the <literal>x</literal> and <literal>y</literal>, vectors, which
                    are in charge of representing rotation, scale, and/or shearing
                    (advanced, covered at the end). The X and Y vectors are together
                    called the <emphasis>basis</emphasis> of the transformation matrix. The terms "basis"
                    and "basis vectors" are important to know.</paragraph>
                <paragraph>You might have noticed that <reference internal="True" refuri="../../classes/class_transform2d#class-transform2d"><inline classes="std std-ref">Transform2D</inline></reference> actually
                    has three <reference internal="True" refuri="../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> values: <literal>x</literal>, <literal>y</literal>, and <literal>origin</literal>.
                    The <literal>origin</literal> value is not part of the basis, but it is part of the
                    transform, and we need it to represent position. From now on we'll
                    keep track of the origin vector in all examples. You can think of
                    origin as another column, but it's often better to think of it as
                    completely separate.</paragraph>
                <paragraph>Note that in 3D, Godot has a separate <reference internal="True" refuri="../../classes/class_basis#class-basis"><inline classes="std std-ref">Basis</inline></reference> structure
                    for holding the three <reference internal="True" refuri="../../classes/class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> values of the basis,
                    since the code can get complex and it makes sense to separate
                    it from <reference internal="True" refuri="../../classes/class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference> (which is composed of one
                    <reference internal="True" refuri="../../classes/class_basis#class-basis"><inline classes="std std-ref">Basis</inline></reference> and one extra <reference internal="True" refuri="../../classes/class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> for the origin).</paragraph>
            </section>
            <section ids="translating-the-transformation-matrix" names="translating\ the\ transformation\ matrix">
                <title>Translating the transformation matrix</title>
                <paragraph>Changing the <literal>origin</literal> vector is called <emphasis>translating</emphasis> the transformation
                    matrix. Translating is basically a technical term for "moving" the
                    object, but it explicitly does not involve any rotation.</paragraph>
                <paragraph>Let's work through an example to help understand this. We will start
                    with the identity transform like last time, except we will keep track
                    of the origin vector this time.</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/identity-origin.png'}" original_uri="img/matrices_and_transforms/identity-origin.png" uri="tutorials/math/img/matrices_and_transforms/identity-origin.png"></image>
                <paragraph>If we want to move the object to a position of (1, 2), we need
                    to set its <literal>origin</literal> vector to (1, 2):</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/translate.png'}" original_uri="img/matrices_and_transforms/translate.png" uri="tutorials/math/img/matrices_and_transforms/translate.png"></image>
                <paragraph>There is also a <literal>translated_local()</literal> method, which performs a different
                    operation to adding or changing <literal>origin</literal> directly. The <literal>translated_local()</literal>
                    method will translate the object <emphasis>relative to its own rotation</emphasis>.
                    For example, an object rotated 90 degrees clockwise will move to
                    the right when <literal>translated_local()</literal> with <literal>Vector2.UP</literal>. To translate
                    <emphasis>relative to the global/parent frame</emphasis> use <literal>translated()</literal> instead.</paragraph>
                <note>
                    <paragraph>Godot's 2D uses coordinates based on pixels, so in actual
                        projects you will want to translate by hundreds of units.</paragraph>
                </note>
            </section>
            <section ids="putting-it-all-together" names="putting\ it\ all\ together">
                <title>Putting it all together</title>
                <paragraph>We're going to apply everything we mentioned so far onto one transform.
                    To follow along, create a project with a Sprite2D node and use the
                    Godot logo for the texture resource.</paragraph>
                <paragraph>Let's set the translation to (350, 150), rotate by -0.5 rad, and scale by 3.
                    I've posted a screenshot, and the code to reproduce it, but I encourage
                    you to try and reproduce the screenshot without looking at the code!</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/putting-all-together.png'}" original_uri="img/matrices_and_transforms/putting-all-together.png" uri="tutorials/math/img/matrices_and_transforms/putting-all-together.png"></image>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var t = Transform2D()
# Translation
t.origin = Vector2(350, 150)
# Rotation
var rot = -0.5 # The rotation to apply.
t.x.x = cos(rot)
t.y.y = cos(rot)
t.x.y = sin(rot)
t.y.x = -sin(rot)
# Scale
t.x *= 3
t.y *= 3
transform = t # Change the node's transform to what we calculated.</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Transform2D t = Transform2D.Identity;
// Translation
t.Origin = new Vector2(350, 150);
// Rotation
float rot = -0.5f; // The rotation to apply.
t.X.X = t.Y.Y = Mathf.Cos(rot);
t.X.Y = t.Y.X = Mathf.Sin(rot);
t.Y.X *= -1;
// Scale
t.X *= 3;
t.Y *= 3;
Transform = t; // Change the node's transform to what we calculated.</literal_block>
                    </div>
                </container>
            </section>
            <section ids="shearing-the-transformation-matrix-advanced" names="shearing\ the\ transformation\ matrix\ (advanced)">
                <title>Shearing the transformation matrix (advanced)</title>
                <note>
                    <paragraph>If you are only looking for how to <emphasis>use</emphasis> transformation matrices,
                        feel free to skip this section of the tutorial. This section
                        explores an uncommonly used aspect of transformation matrices
                        for the purpose of building an understanding of them.</paragraph>
                    <paragraph>Node2D provides a shearing property out of the box.</paragraph>
                </note>
                <paragraph>You may have noticed that a transform has more degrees of freedom than
                    the combination of the above actions. The basis of a 2D transformation
                    matrix has four total numbers in two <reference internal="True" refuri="../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> values, while
                    a rotation value and a Vector2 for scale only has 3 numbers. The high-level
                    concept for the missing degree of freedom is called <emphasis>shearing</emphasis>.</paragraph>
                <paragraph>Normally, you will always have the basis vectors perpendicular to each
                    other. However, shearing can be useful in some situations, and
                    understanding shearing helps you understand how transforms work.</paragraph>
                <paragraph>To show you visually how it will look, let's overlay a grid onto the Godot
                    logo:</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/identity-grid.png'}" original_uri="img/matrices_and_transforms/identity-grid.png" uri="tutorials/math/img/matrices_and_transforms/identity-grid.png"></image>
                <paragraph>Each point on this grid is obtained by adding the basis vectors together.
                    The bottom-right corner is X + Y, while the top-right corner is X - Y.
                    If we change the basis vectors, the entire grid moves with it, as the
                    grid is composed of the basis vectors. All lines on the grid that are
                    currently parallel will remain parallel no matter what changes we make to
                    the basis vectors.</paragraph>
                <paragraph>As an example, let's set Y to (1, 1):</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/shear.png'}" original_uri="img/matrices_and_transforms/shear.png" uri="tutorials/math/img/matrices_and_transforms/shear.png"></image>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var t = Transform2D()
# Shear by setting Y to (1, 1)
t.y = Vector2.ONE
transform = t # Change the node's transform to what we calculated.</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Transform2D t = Transform2D.Identity;
// Shear by setting Y to (1, 1)
t.Y = Vector2.One;
Transform = t; // Change the node's transform to what we calculated.</literal_block>
                    </div>
                </container>
                <note>
                    <paragraph>You can't set the raw values of a Transform2D in the editor,
                        so you <emphasis>must</emphasis> use code if you want to shear the object.</paragraph>
                </note>
                <paragraph>Due to the vectors no longer being perpendicular, the object has been
                    sheared. The bottom-center of the grid, which is (0, 1) relative
                    to itself, is now located at a world position of (1, 1).</paragraph>
                <paragraph>The intra-object coordinates are called UV coordinates in textures,
                    so let's borrow that terminology for here. To find the world position
                    from a relative position, the formula is U * X + V * Y, where U and V
                    are numbers and X and Y are the basis vectors.</paragraph>
                <paragraph>The bottom-right corner of the grid, which is always at the UV position
                    of (1, 1), is at the world position of (2, 1), which is calculated from
                    X*1 + Y*1, which is (1, 0) + (1, 1), or (1 + 1, 0 + 1), or (2, 1).
                    This matches up with our observation of where the bottom-right corner
                    of the image is.</paragraph>
                <paragraph>Similarly, the top-right corner of the grid, which is always at the UV
                    position of (1, -1), is at the world position of (0, -1), which is calculated
                    from X*1 + Y*-1, which is (1, 0) - (1, 1), or (1 - 1, 0 - 1), or (0, -1).
                    This matches up with our observation of where the top-right corner
                    of the image is.</paragraph>
                <paragraph>Hopefully you now fully understand how a transformation matrix affects
                    the object, and the relationship between the basis vectors and how the
                    object's "UV" or "intra-coordinates" have their world position changed.</paragraph>
                <note>
                    <paragraph>In Godot, all transform math is done relative to the parent node.
                        When we refer to "world position", that would be relative to the
                        node's parent instead, if the node had a parent.</paragraph>
                </note>
                <paragraph>If you would like additional explanation, you should check out
                    3Blue1Brown's excellent video about linear transformations:
                    <reference refuri="https://www.youtube.com/watch?v=kYB8IZa5AuE">https://www.youtube.com/watch?v=kYB8IZa5AuE</reference></paragraph>
            </section>
        </section>
        <section ids="practical-applications-of-transforms" names="practical\ applications\ of\ transforms">
            <title>Practical applications of transforms</title>
            <paragraph>In actual projects, you will usually be working with transforms inside
                transforms by having multiple <reference internal="True" refuri="../../classes/class_node2d#class-node2d"><inline classes="std std-ref">Node2D</inline></reference> or <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference>
                nodes parented to each other.</paragraph>
            <paragraph>However, it's useful to understand how to manually calculate the values we
                need. We will go over how you could use <reference internal="True" refuri="../../classes/class_transform2d#class-transform2d"><inline classes="std std-ref">Transform2D</inline></reference> or
                <reference internal="True" refuri="../../classes/class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference> to manually calculate transforms of nodes.</paragraph>
            <section ids="converting-positions-between-transforms" names="converting\ positions\ between\ transforms">
                <title>Converting positions between transforms</title>
                <paragraph>There are many cases where you'd want to convert a position in and out of
                    a transform. For example, if you have a position relative to the player
                    and would like to find the world (parent-relative) position, or if you
                    have a world position and want to know where it is relative to the player.</paragraph>
                <paragraph>We can find what a vector relative to the player would be defined in
                    world space as using the <literal>*</literal> operator:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># World space vector 100 units below the player.
print(transform * Vector2(0, 100))</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// World space vector 100 units below the player.
GD.Print(Transform * new Vector2(0, 100));</literal_block>
                    </div>
                </container>
                <paragraph>And we can use the <literal>*</literal> operator in the opposite order to find a what world
                    space position would be if it was defined relative to the player:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Where is (0, 100) relative to the player?
print(Vector2(0, 100) * transform)</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Where is (0, 100) relative to the player?
GD.Print(new Vector2(0, 100) * Transform);</literal_block>
                    </div>
                </container>
                <note>
                    <paragraph>If you know in advance that the transform is positioned at
                        (0, 0), you can use the "basis_xform" or "basis_xform_inv"
                        methods instead, which skip dealing with translation.</paragraph>
                </note>
            </section>
            <section ids="moving-an-object-relative-to-itself" names="moving\ an\ object\ relative\ to\ itself">
                <title>Moving an object relative to itself</title>
                <paragraph>A common operation, especially in 3D games, is to move an object relative
                    to itself. For example, in first-person shooter games, you would want the
                    character to move forward (-Z axis) when you press <literal classes="kbd">W</literal>.</paragraph>
                <paragraph>Since the basis vectors are the orientation relative to the parent,
                    and the origin vector is the position relative to the parent, we can
                    add multiples of the basis vectors to move an object relative to itself.</paragraph>
                <paragraph>This code moves an object 100 units to its own right:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">transform.origin += transform.x * 100</literal_block>
                    </div>
                    <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Transform2D t = Transform;
t.Origin += t.X * 100;
Transform = t;</literal_block>
                    </div>
                </container>
                <paragraph>For moving in 3D, you would need to replace "x" with "basis.x".</paragraph>
                <note>
                    <paragraph>In actual projects, you can use <literal>translate_object_local</literal> in 3D
                        or <literal>move_local_x</literal> and <literal>move_local_y</literal> in 2D to do this.</paragraph>
                </note>
            </section>
            <section ids="applying-transforms-onto-transforms" names="applying\ transforms\ onto\ transforms">
                <title>Applying transforms onto transforms</title>
                <paragraph>One of the most important things to know about transforms is how you
                    can use several of them together. A parent node's transform affects
                    all of its children. Let's dissect an example.</paragraph>
                <paragraph>In this image, the child node has a "2" after the component names
                    to distinguish them from the parent node. It might look a bit
                    overwhelming with so many numbers, but remember that each number
                    is displayed twice (next to the arrows and also in the matrices),
                    and that almost half of the numbers are zero.</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/apply.png'}" original_uri="img/matrices_and_transforms/apply.png" uri="tutorials/math/img/matrices_and_transforms/apply.png"></image>
                <paragraph>The only transformations going on here are that the parent node has
                    been given a scale of (2, 1), the child has been given a scale of
                    (0.5, 0.5), and both nodes have been given positions.</paragraph>
                <paragraph>All child transformations are affected by the parent transformations.
                    The child has a scale of (0.5, 0.5), so you would expect it to be
                    a 1:1 ratio square, and it is, but only relative to the parent.
                    The child's X vector ends up being (1, 0) in world space, because
                    it is scaled by the parent's basis vectors.
                    Similarly, the child node's <literal>origin</literal> vector is set to (1, 1), but this
                    actually moves it (2, 1) in world space, due to the parent node's
                    basis vectors.</paragraph>
                <paragraph>To calculate a child transform's world space transform manually, this is
                    the code we would use:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Set up transforms like in the image, except make positions be 100 times bigger.
var parent = Transform2D(Vector2(2, 0), Vector2(0, 1), Vector2(100, 200))
var child = Transform2D(Vector2(0.5, 0), Vector2(0, 0.5), Vector2(100, 100))

# Calculate the child's world space transform
# origin = (2, 0) * 100 + (0, 1) * 100 + (100, 200)
var origin = parent.x * child.origin.x + parent.y * child.origin.y + parent.origin
# basis_x = (2, 0) * 0.5 + (0, 1) * 0
var basis_x = parent.x * child.x.x + parent.y * child.x.y
# basis_y = (2, 0) * 0 + (0, 1) * 0.5
var basis_y = parent.x * child.y.x + parent.y * child.y.y

# Change the node's transform to what we calculated.
transform = Transform2D(basis_x, basis_y, origin)</literal_block>
                    </div>
                    <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Set up transforms like in the image, except make positions be 100 times bigger.
Transform2D parent = new Transform2D(2, 0, 0, 1, 100, 200);
Transform2D child = new Transform2D(0.5f, 0, 0, 0.5f, 100, 100);

// Calculate the child's world space transform
// origin = (2, 0) * 100 + (0, 1) * 100 + (100, 200)
Vector2 origin = parent.X * child.Origin.X + parent.Y * child.Origin.Y + parent.Origin;
// basisX = (2, 0) * 0.5 + (0, 1) * 0 = (0.5, 0)
Vector2 basisX = parent.X * child.X.X + parent.Y * child.X.Y;
// basisY = (2, 0) * 0 + (0, 1) * 0.5 = (0.5, 0)
Vector2 basisY = parent.X * child.Y.X + parent.Y * child.Y.Y;

// Change the node's transform to what we calculated.
Transform = new Transform2D(basisX, basisY, origin);</literal_block>
                    </div>
                </container>
                <paragraph>In actual projects, we can find the world transform of the child by
                    applying one transform onto another using the <literal>*</literal> operator:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Set up transforms like in the image, except make positions be 100 times bigger.
var parent = Transform2D(Vector2(2, 0), Vector2(0, 1), Vector2(100, 200))
var child = Transform2D(Vector2(0.5, 0), Vector2(0, 0.5), Vector2(100, 100))

# Change the node's transform to what would be the child's world transform.
transform = parent * child</literal_block>
                    </div>
                    <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Set up transforms like in the image, except make positions be 100 times bigger.
Transform2D parent = new Transform2D(2, 0, 0, 1, 100, 200);
Transform2D child = new Transform2D(0.5f, 0, 0, 0.5f, 100, 100);

// Change the node's transform to what would be the child's world transform.
Transform = parent * child;</literal_block>
                    </div>
                </container>
                <note>
                    <paragraph>When multiplying matrices, order matters! Don't mix them up.</paragraph>
                </note>
                <paragraph>Lastly, applying the identity transform will always do nothing.</paragraph>
                <paragraph>If you would like additional explanation, you should check out
                    3Blue1Brown's excellent video about matrix composition:
                    <reference refuri="https://www.youtube.com/watch?v=XkY2DOUCWMU">https://www.youtube.com/watch?v=XkY2DOUCWMU</reference></paragraph>
            </section>
            <section ids="inverting-a-transformation-matrix" names="inverting\ a\ transformation\ matrix">
                <title>Inverting a transformation matrix</title>
                <paragraph>The "affine_inverse" function returns a transform that "undoes" the
                    previous transform. This can be useful in some situations.
                    Let's take a look at a few examples.</paragraph>
                <paragraph>Multiplying an inverse transform by the normal transform undoes all
                    transformations:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var ti = transform.affine_inverse()
var t = ti * transform
# The transform is the identity transform.</literal_block>
                    </div>
                    <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Transform2D ti = Transform.AffineInverse();
Transform2D t = ti * Transform;
// The transform is the identity transform.</literal_block>
                    </div>
                </container>
                <paragraph>Transforming a position by a transform and its inverse results in the
                    same position:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-10-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-10-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-10-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var ti = transform.affine_inverse()
position = transform * position
position = ti * position
# The position is the same as before.</literal_block>
                    </div>
                    <div aria-labelledby="tab-10-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-10-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Transform2D ti = Transform.AffineInverse();
Position = Transform * Position;
Position = ti * Position;
// The position is the same as before.</literal_block>
                    </div>
                </container>
            </section>
        </section>
        <section ids="how-does-it-all-work-in-3d" names="how\ does\ it\ all\ work\ in\ 3d?">
            <title>How does it all work in 3D?</title>
            <paragraph>One of the great things about transformation matrices is that they
                work very similarly between 2D and 3D transformations.
                All the code and formulas used above for 2D work the same in 3D,
                with 3 exceptions: the addition of a third axis, that each
                axis is of type <reference internal="True" refuri="../../classes/class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, and also that Godot stores
                the <reference internal="True" refuri="../../classes/class_basis#class-basis"><inline classes="std std-ref">Basis</inline></reference> separately from the <reference internal="True" refuri="../../classes/class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference>,
                since the math can get complex and it makes sense to separate it.</paragraph>
            <paragraph>All of the concepts for how translation, rotation, scale, and shearing
                work in 3D are all the same compared to 2D. To scale, we take each
                component and multiply it; to rotate, we change where each basis vector
                is pointing; to translate, we manipulate the origin; and to shear, we
                change the basis vectors to be non-perpendicular.</paragraph>
            <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/3d-identity.png'}" original_uri="img/matrices_and_transforms/3d-identity.png" uri="tutorials/math/img/matrices_and_transforms/3d-identity.png"></image>
            <paragraph>If you would like, it's a good idea to play around with transforms
                to get an understanding of how they work. Godot allows you to edit
                3D transform matrices directly from the inspector. You can download
                this project which has colored lines and cubes to help visualize the
                <reference internal="True" refuri="../../classes/class_basis#class-basis"><inline classes="std std-ref">Basis</inline></reference> vectors and the origin in both 2D and 3D:
                <reference refuri="https://github.com/godotengine/godot-demo-projects/tree/master/misc/matrix_transform">https://github.com/godotengine/godot-demo-projects/tree/master/misc/matrix_transform</reference></paragraph>
            <comment xml:space="preserve">UPDATE: May change in future. When you can edit a Node2D's transform matrix</comment>
            <comment xml:space="preserve">directly, remove or update this note.</comment>
            <note>
                <paragraph>You cannot edit Node2D's transform matrix directly in Godot 4.0's
                    inspector. This may be changed in a future release of Godot.</paragraph>
            </note>
            <paragraph>If you would like additional explanation, you should check out
                3Blue1Brown's excellent video about 3D linear transformations:
                <reference refuri="https://www.youtube.com/watch?v=rHLEWRxRGiM">https://www.youtube.com/watch?v=rHLEWRxRGiM</reference></paragraph>
            <section ids="representing-rotation-in-3d-advanced" names="representing\ rotation\ in\ 3d\ (advanced)">
                <title>Representing rotation in 3D (advanced)</title>
                <paragraph>The biggest difference between 2D and 3D transformation matrices is
                    how you represent rotation by itself without the basis vectors.</paragraph>
                <paragraph>With 2D, we have an easy way (atan2) to switch between a transformation
                    matrix and an angle. In 3D, rotation is too complex to represent as one
                    number. There is something called Euler angles, which can represent
                    rotations as a set of 3 numbers, however, they are limited and not very
                    useful, except for trivial cases.</paragraph>
                <paragraph>In 3D we do not typically use angles, we either use a transformation basis
                    (used pretty much everywhere in Godot), or we use quaternions. Godot can
                    represent quaternions using the <reference internal="True" refuri="../../classes/class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> struct. My suggestion
                    to you is to completely ignore how they work under-the-hood, because
                    they are very complicated and unintuitive.</paragraph>
                <paragraph>However, if you really must know how it works, here are some great
                    resources, which you can follow in order:</paragraph>
                <paragraph><reference refuri="https://www.youtube.com/watch?v=mvmuCPvRoWQ">https://www.youtube.com/watch?v=mvmuCPvRoWQ</reference></paragraph>
                <paragraph><reference refuri="https://www.youtube.com/watch?v=d4EgbgTm0Bg">https://www.youtube.com/watch?v=d4EgbgTm0Bg</reference></paragraph>
                <paragraph><reference refuri="https://eater.net/quaternions">https://eater.net/quaternions</reference></paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
