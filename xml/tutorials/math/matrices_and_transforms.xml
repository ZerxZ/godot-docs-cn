<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/math/matrices_and_transforms.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-matrices-and-transforms"></target>
    <section ids="matrices-and-transforms doc-matrices-and-transforms" names="matrices\ and\ transforms 矩阵与变换 doc_matrices_and_transforms">
        <title>矩阵与变换</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>在阅读本教程之前，我们推荐你从头到尾阅读 <reference internal="True" refuri="vector_math#doc-vector-math"><inline classes="std std-ref">向量数学</inline></reference> 教程，因为本教程需要向量的知识，故需要对其内容有较为全面的理解。</paragraph>
            <paragraph>本教程会介绍<emphasis>变换</emphasis>以及如何在 Godot 中使用矩阵来表示变换，并不会深入完整地介绍矩阵与变换。变换在大多数情况下应用于平移、旋转、缩放，我们将会重点讲述如何使用矩阵来表示平移、旋转和缩放。</paragraph>
            <paragraph>虽然本教程主要侧重于 2D 的变换，用的是 <reference internal="True" refuri="../../classes/class_transform2d#class-transform2d"><inline classes="std std-ref">Transform2D</inline></reference> 和 <reference internal="True" refuri="../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>，但是对于 3D 中的变换，其工作方式也与 2D 的十分相似。</paragraph>
            <note>
                <paragraph>正如之前的教程中所提到的，在 Godot 中，要记住 2D 的 Y 轴的正方向是<emphasis>向下</emphasis>的，而学校里教的线性代数的坐标系，其 Y 轴正方向是向上的，这两个 Y 轴的方向是相反的，这一点需要注意。</paragraph>
            </note>
            <note>
                <paragraph>我们习惯 X 轴用红色表示、Y 轴用绿色表示、Z 轴用蓝色表示，本教程中的颜色都遵循这个惯例，不过我们也在原点向量上使用蓝色表示。</paragraph>
            </note>
            <section ids="matrix-components-and-the-identity-matrix" names="matrix\ components\ and\ the\ identity\ matrix 矩阵分量和单位矩阵">
                <title>矩阵分量和单位矩阵</title>
                <paragraph>单位矩阵代表一个没有平移、没有旋转、没有缩放的变换，现在就让我们看看单位矩阵以及其分量是如何与其视觉表现相联系的吧。</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/identity.png'}" uri="tutorials/math/img/matrices_and_transforms/identity.png"></image>
                <paragraph>矩阵有行和列，变换矩阵对行和列有特定的规定。</paragraph>
                <paragraph>在上图中，我们可以看到红色的 X 向量由矩阵的第一列数对表示，绿色的 Y 向量则由第二列数对表示，改变这几列数对就会改变这些数对所对应的向量。接下来，我们将会在几个例子中看到如何操作这些数对。</paragraph>
                <paragraph>由于我们通常使用列来进行操作，因此不必担心直接操作行可能会带来的问题。不过，你也可以把矩阵的行看作是一组表示在给定的方向上移动的向量。</paragraph>
                <paragraph>我们指定诸如 <title_reference>t.x.y</title_reference> 这样的值时，表示这是 X 列向量的 Y 分量，换言之，就是这个矩阵的左下角。类似地， <title_reference>t.x.x</title_reference> 就是左上角， <title_reference>t.y.x</title_reference> 就是右上角，那么 <title_reference>t.y.y</title_reference> 自然就是右下角。这里的 <title_reference>t</title_reference> 是一个 Transform2D。</paragraph>
            </section>
            <section ids="scaling-the-transformation-matrix" names="scaling\ the\ transformation\ matrix 缩放变换矩阵">
                <title>缩放变换矩阵</title>
                <paragraph>应用缩放变换是最容易理解的操作之一，既然如此，那就让我们开始动手尝试吧！把 Godot logo 放置于我们的向量之下，这样我们就可以直观地看出变换该对象上的应用效果：</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/identity-godot.png'}" uri="tutorials/math/img/matrices_and_transforms/identity-godot.png"></image>
                <paragraph>现在，要缩放矩阵，我们唯一需要做的就是将每个矩阵分量乘以我们想要缩放的比例。现在来将这个矩阵缩放两倍，1 × 2 = 2，0 × 2 = 0，于是我们便得到了这个结果：</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/scale.png'}" uri="tutorials/math/img/matrices_and_transforms/scale.png"></image>
                <paragraph>要在代码中实现这点，我们可以让缩放倍数去乘上每个列向量：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var t = Transform2D()
# Scale
t.x *= 2
t.y *= 2
transform = t # Change the node's transform to what we calculated.</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Transform2D t = Transform2D.Identity;
// Scale
t.X *= 2;
t.Y *= 2;
Transform = t; // Change the node's transform to what we calculated.</literal_block>
                    </div>
                </container>
                <paragraph>如果我们想要让该变换缩回到原来的尺度，那么我们可以让每个分向量乘以 0.5（即1/2）。以上便是缩放变换矩阵的所有基本介绍了。</paragraph>
                <paragraph>要从已存在的变换矩阵中计算对象的缩放尺度，可以对该矩阵的每个列向量使用 <title_reference>length()</title_reference> 方法。</paragraph>
                <note>
                    <paragraph>在实际项目中，你可以使用 <title_reference>scaled()</title_reference> 方法去执行缩放变换操作。</paragraph>
                </note>
            </section>
            <section ids="rotating-the-transformation-matrix" names="rotating\ the\ transformation\ matrix 旋转变换矩阵">
                <title>旋转变换矩阵</title>
                <paragraph>我们将以与前面相同的方式开始本节内容，先在单位矩阵下方叠加一个 Godot logo 吧：</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/identity-godot.png'}" uri="tutorials/math/img/matrices_and_transforms/identity-godot.png"></image>
                <paragraph>举个例子，假设我们想让 Godot logo 顺时针旋转 90 度，而现在 X 轴正方形向右，Y 轴正方向向下。如果我们在脑海中模拟旋转这两个轴，那么我们脑海中就理应会想到：旋转后的 X 轴正方向应该向下，旋转后的 Y 轴正方向应该向左。</paragraph>
                <paragraph>你可以这样子想：你用手抓住 Godot 的 logo 和其变换矩阵的列向量，然后绕着logo的中心点旋转这个logo以及这些向量。无论你在哪里完成该旋转，向量的方向都将会决定矩阵最终呈现的模样。</paragraph>
                <paragraph>我们需要在标准坐标系中表示“下方向”和“左方向”，故我们将 X 设为 (0, 1)，将 Y 设为 (-1, 0)。这些也正是 Vector2.DOWN 和 Vector2.LEFT 的值。这样做的话，我们就会得到旋转对象后所想看到的结果：</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/rotate1.png'}" uri="tutorials/math/img/matrices_and_transforms/rotate1.png"></image>
                <paragraph>如果你还是难以理解上面的内容，那就试着做下这个小实践：剪一个正方形的纸，在上面画 X 向量和 Y 向量，然后把它放在图表纸上，旋转这张正方形的纸，并记下其端点。</paragraph>
                <paragraph>要在代码中执行旋转，我们需要能以编程的方式计算旋转后的变换值。下图展示了由旋转角度计算旋转变换矩阵所需的公式。如果看下图觉得很复杂，不用担心，这保准是你需要知道的那个最难理解矩阵旋转的地方。</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/rotate2.png'}" uri="tutorials/math/img/matrices_and_transforms/rotate2.png"></image>
                <note>
                    <paragraph>Godot 用弧度（radians）表示所有的旋转，不用角度。完整转一圈是 <title_reference>TAU</title_reference> 或 <title_reference>PI*2</title_reference> 弧度，90 度（四分之一圈）是 <title_reference>TAU/4</title_reference> 或 <title_reference>PI/2</title_reference> 弧度。使用 <title_reference>TAU</title_reference> 通常会让代码更易读。</paragraph>
                </note>
                <note>
                    <paragraph>有趣的事实：在 Godot 中，不仅 Y 是<emphasis>朝下</emphasis>的，连旋转也成了顺时针的，也就是说，Godot 2D 所有的数学和三角函数行为都与 Y 轴朝上的 CCW 坐标系相同，因为这些差异“相互抵消”了。你可以认为在标准平面直角坐标系和 Godot 2D 的直角坐标系这两个坐标系中的旋转都是“从 X 到 Y”。</paragraph>
                </note>
                <paragraph>为了执行 0.5 弧度的旋转（约 28.65 度），我们只需将 0.5 代入上面的公式中，然后计算出实际的数值：</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/rotate3.png'}" uri="tutorials/math/img/matrices_and_transforms/rotate3.png"></image>
                <paragraph>这是在代码中完成的方法（将脚本放在 Node2D 上）：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var rot = 0.5 # The rotation to apply.
var t = Transform2D()
t.x.x = cos(rot)
t.y.y = cos(rot)
t.x.y = sin(rot)
t.y.x = -sin(rot)
transform = t # Change the node's transform to what we calculated.</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">float rot = 0.5f; // The rotation to apply.
Transform2D t = Transform2D.Identity;
t.X.X = t.Y.Y = Mathf.Cos(rot);
t.X.Y = t.Y.X = Mathf.Sin(rot);
t.Y.X *= -1;
Transform = t; // Change the node's transform to what we calculated.</literal_block>
                    </div>
                </container>
                <paragraph>To calculate the object's rotation from an existing transformation
                    matrix, you can use <literal>atan2(t.x.y, t.x.x)</literal>, where t is the Transform2D.</paragraph>
                <note>
                    <paragraph>In actual projects, you can use the <literal>rotated()</literal>
                        method to perform rotations.</paragraph>
                </note>
            </section>
            <section ids="basis-of-the-transformation-matrix" names="basis\ of\ the\ transformation\ matrix 变换矩阵的基">
                <title>变换矩阵的基</title>
                <paragraph>So far we have only been working with the <literal>x</literal> and <literal>y</literal>, vectors, which
                    are in charge of representing rotation, scale, and/or shearing
                    (advanced, covered at the end). The X and Y vectors are together
                    called the <emphasis>basis</emphasis> of the transformation matrix. The terms "basis"
                    and "basis vectors" are important to know.</paragraph>
                <paragraph>You might have noticed that <reference internal="True" refuri="../../classes/class_transform2d#class-transform2d"><inline classes="std std-ref">Transform2D</inline></reference> actually
                    has three <reference internal="True" refuri="../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> values: <literal>x</literal>, <literal>y</literal>, and <literal>origin</literal>.
                    The <literal>origin</literal> value is not part of the basis, but it is part of the
                    transform, and we need it to represent position. From now on we'll
                    keep track of the origin vector in all examples. You can think of
                    origin as another column, but it's often better to think of it as
                    completely separate.</paragraph>
                <paragraph>Note that in 3D, Godot has a separate <reference internal="True" refuri="../../classes/class_basis#class-basis"><inline classes="std std-ref">Basis</inline></reference> structure
                    for holding the three <reference internal="True" refuri="../../classes/class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> values of the basis,
                    since the code can get complex and it makes sense to separate
                    it from <reference internal="True" refuri="../../classes/class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference> (which is composed of one
                    <reference internal="True" refuri="../../classes/class_basis#class-basis"><inline classes="std std-ref">Basis</inline></reference> and one extra <reference internal="True" refuri="../../classes/class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> for the origin).</paragraph>
            </section>
            <section ids="translating-the-transformation-matrix" names="translating\ the\ transformation\ matrix 变换矩阵的平移">
                <title>变换矩阵的平移</title>
                <paragraph>Changing the <literal>origin</literal> vector is called <emphasis>translating</emphasis> the transformation
                    matrix. Translating is basically a technical term for "moving" the
                    object, but it explicitly does not involve any rotation.</paragraph>
                <paragraph>让我们通过一个例子来帮助理解这一点。我们将像上次一样从恒等变换开始，但这次我们将记录原点向量。</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/identity-origin.png'}" uri="tutorials/math/img/matrices_and_transforms/identity-origin.png"></image>
                <paragraph>If we want to move the object to a position of (1, 2), we need
                    to set its <literal>origin</literal> vector to (1, 2):</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/translate.png'}" uri="tutorials/math/img/matrices_and_transforms/translate.png"></image>
                <paragraph>There is also a <literal>translated_local()</literal> method, which performs a different
                    operation to adding or changing <literal>origin</literal> directly. The <literal>translated_local()</literal>
                    method will translate the object <emphasis>relative to its own rotation</emphasis>.
                    For example, an object rotated 90 degrees clockwise will move to
                    the right when <literal>translated_local()</literal> with <literal>Vector2.UP</literal>. To translate
                    <emphasis>relative to the global/parent frame</emphasis> use <literal>translated()</literal> instead.</paragraph>
                <note>
                    <paragraph>Godot 的 2D 使用基于像素的坐标，所以在实际项目中，你会想要转换成数百个单位。</paragraph>
                </note>
            </section>
            <section ids="putting-it-all-together" names="putting\ it\ all\ together 融会贯通">
                <title>融会贯通</title>
                <paragraph>We're going to apply everything we mentioned so far onto one transform.
                    To follow along, create a project with a Sprite2D node and use the
                    Godot logo for the texture resource.</paragraph>
                <paragraph>让我们将平移设置为 (350, 150)，旋转设为 -0.5 rad，缩放设为 3。我把屏幕截图和重现代码都发出来了，但我鼓励你不看代码来尝试重现屏幕截图！</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/putting-all-together.png'}" uri="tutorials/math/img/matrices_and_transforms/putting-all-together.png"></image>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var t = Transform2D()
# Translation
t.origin = Vector2(350, 150)
# Rotation
var rot = -0.5 # The rotation to apply.
t.x.x = cos(rot)
t.y.y = cos(rot)
t.x.y = sin(rot)
t.y.x = -sin(rot)
# Scale
t.x *= 3
t.y *= 3
transform = t # Change the node's transform to what we calculated.</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Transform2D t = Transform2D.Identity;
// Translation
t.Origin = new Vector2(350, 150);
// Rotation
float rot = -0.5f; // The rotation to apply.
t.X.X = t.Y.Y = Mathf.Cos(rot);
t.X.Y = t.Y.X = Mathf.Sin(rot);
t.Y.X *= -1;
// Scale
t.X *= 3;
t.Y *= 3;
Transform = t; // Change the node's transform to what we calculated.</literal_block>
                    </div>
                </container>
            </section>
            <section ids="shearing-the-transformation-matrix-advanced" names="shearing\ the\ transformation\ matrix\ (advanced) 剪切变换矩阵（高级）">
                <title>剪切变换矩阵（高级）</title>
                <note>
                    <paragraph>如果你只想了解如何<emphasis>使用</emphasis>变换矩阵，请随意跳过本教程的这一节。本节探讨变换矩阵的一个不常用的方面，目的是为了你建立对它们的理解。</paragraph>
                    <paragraph>Node2D提供了开箱即用的剪切属性。</paragraph>
                </note>
                <paragraph>你可能已经注意到，变换的自由度比上述操作的组合要多。2D 变换矩阵的基在两个 <reference internal="True" refuri="../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> 值中总共有四个数，而旋转值和缩放的 Vector2 只有三个数字。缺失自由度的高级概念称为<emphasis>剪切</emphasis>（Shearing）。</paragraph>
                <paragraph>通常，你将始终拥有彼此垂直的基向量。但是，剪切在某些情况下可能很有用，了解剪切可以帮助你理解变换的工作原理。</paragraph>
                <paragraph>为了直观地向你展示它的外观, 让我们在Godot徽标上叠加一个网格:</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/identity-grid.png'}" uri="tutorials/math/img/matrices_and_transforms/identity-grid.png"></image>
                <paragraph>此网格上的每个点都是通过将基向量相加而获得的。右下角是 X + Y，而右上角是 X - Y。如果我们更改基向量，整个栅格也会随之移动，因为栅格是由基向量组成的。无论我们对基向量做什么更改，栅格上当前平行的所有直线都将保持平行。</paragraph>
                <paragraph>例如, 让我们将Y设置为(1,1):</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/shear.png'}" uri="tutorials/math/img/matrices_and_transforms/shear.png"></image>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var t = Transform2D()
# Shear by setting Y to (1, 1)
t.y = Vector2.ONE
transform = t # Change the node's transform to what we calculated.</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Transform2D t = Transform2D.Identity;
// Shear by setting Y to (1, 1)
t.Y = Vector2.One;
Transform = t; // Change the node's transform to what we calculated.</literal_block>
                    </div>
                </container>
                <note>
                    <paragraph>不能在编辑器中设置Transform2D的原始值, 所以想要剪切对象, 必须使用代码.</paragraph>
                </note>
                <paragraph>由于向量不再垂直, 因此对象已被剪切. 栅格的底部中心(相对于自身为(0,1))现在位于世界位置(1,1).</paragraph>
                <paragraph>对象内部坐标在纹理中称为UV坐标, 因此我们借用此处的术语. 要从相对位置找到世界位置, 公式为U*X+V*Y, 其中U和V是数字,X和Y是基向量.</paragraph>
                <paragraph>栅格的右下角始终位于UV位置(1,1), 位于世界位置(2,1), 该位置是从X*1+Y*1(即(1,0)+(1,1)或(1+1,0+1)或(2,1)计算得出的. 这与我们观察到的图像右下角的位置相吻合.</paragraph>
                <paragraph>同样, 栅格的右上角始终位于UV位置(1, -1), 位于世界位置(0, -1), 该位置是从X*1+Y*-1计算得出的,X*1+Y*-1是(1,0)-(1,1)或(1-1,0-1)或(0, -1). 这与我们观察到的图像右上角的位置相吻合.</paragraph>
                <paragraph>希望你现在完全了解变换矩阵如何影响对象，以及基向量之间的关系以及对象的“UV”或“内部坐标”如何更改其世界位置。</paragraph>
                <note>
                    <paragraph>在Godot中, 所有变换数学运算都是相对于父节点完成的. 当我们提到 "世界位置" 时, 如果节点有父节点, 那么它将相对于节点的父位置.</paragraph>
                </note>
                <paragraph>如果你想要更多的解释，你可以查看 3Blue1Brown 关于线性变换的精彩视频：<reference refuri="http://www.bilibili.com/video/BV1ys411472E?p=4">http://www.bilibili.com/video/BV1ys411472E?p=4</reference></paragraph>
            </section>
        </section>
        <section ids="practical-applications-of-transforms" names="practical\ applications\ of\ transforms 变换的实际应用">
            <title>变换的实际应用</title>
            <paragraph>In actual projects, you will usually be working with transforms inside
                transforms by having multiple <reference internal="True" refuri="../../classes/class_node2d#class-node2d"><inline classes="std std-ref">Node2D</inline></reference> or <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference>
                nodes parented to each other.</paragraph>
            <paragraph>However, it's useful to understand how to manually calculate the values we
                need. We will go over how you could use <reference internal="True" refuri="../../classes/class_transform2d#class-transform2d"><inline classes="std std-ref">Transform2D</inline></reference> or
                <reference internal="True" refuri="../../classes/class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference> to manually calculate transforms of nodes.</paragraph>
            <section ids="converting-positions-between-transforms" names="converting\ positions\ between\ transforms 在变换之间转换位置">
                <title>在变换之间转换位置</title>
                <paragraph>在许多情况下，你可能需要将某个位置转换为变换前或者变换后的位置。例如，如果你有一个相对于玩家的位置并想要查找世界（相对于玩家来说是父级）位置，或者如果你有一个世界位置并想知道它相对于玩家的位置。</paragraph>
                <paragraph>We can find what a vector relative to the player would be defined in
                    world space as using the <literal>*</literal> operator:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># World space vector 100 units below the player.
print(transform * Vector2(0, 100))</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// World space vector 100 units below the player.
GD.Print(Transform * new Vector2(0, 100));</literal_block>
                    </div>
                </container>
                <paragraph>And we can use the <literal>*</literal> operator in the opposite order to find a what world
                    space position would be if it was defined relative to the player:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Where is (0, 100) relative to the player?
print(Vector2(0, 100) * transform)</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Where is (0, 100) relative to the player?
GD.Print(new Vector2(0, 100) * Transform);</literal_block>
                    </div>
                </container>
                <note>
                    <paragraph>如果你事先知道变换位于 (0, 0) 处，则可以改用“basis_xform”或“basis_xform_inv”方法，这将跳过处理平移的过程。</paragraph>
                </note>
            </section>
            <section ids="moving-an-object-relative-to-itself" names="moving\ an\ object\ relative\ to\ itself 相对于对象本身移动对象">
                <title>相对于对象本身移动对象</title>
                <paragraph>一种常见的操作，尤其是在 3D 游戏中，是相对于自身移动对象。例如，在第一人称射击游戏中，当你按下 <literal classes="kbd">W</literal> 键时，你希望角色向前移动（-Z 轴）。</paragraph>
                <paragraph>Since the basis vectors are the orientation relative to the parent,
                    and the origin vector is the position relative to the parent, we can
                    add multiples of the basis vectors to move an object relative to itself.</paragraph>
                <paragraph>此代码会让对象向它自己的右边移动 100 个单位：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">transform.origin += transform.x * 100</literal_block>
                    </div>
                    <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Transform2D t = Transform;
t.Origin += t.X * 100;
Transform = t;</literal_block>
                    </div>
                </container>
                <paragraph>要在 3D 中移动，需要将“x”替换为“basis.x”。</paragraph>
                <note>
                    <paragraph>In actual projects, you can use <literal>translate_object_local</literal> in 3D
                        or <literal>move_local_x</literal> and <literal>move_local_y</literal> in 2D to do this.</paragraph>
                </note>
            </section>
            <section ids="applying-transforms-onto-transforms" names="applying\ transforms\ onto\ transforms 将变换应用于变换">
                <title>将变换应用于变换</title>
                <paragraph>关于转换, 需要了解的最重要的事情之一是如何将几个转换一起使用. 父节点的变换会影响其所有子节点. 让我们来剖析一个例子.</paragraph>
                <paragraph>在此图像中, 子节点的组件名称后面有一个 "2", 以将其与父节点区分开来. 这么多数字可能看起来有点令人不知所措, 但请记住, 每个数字都会显示两次(在箭头旁边和矩阵中), 而且几乎一半的数字都是零.</paragraph>
                <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/apply.png'}" uri="tutorials/math/img/matrices_and_transforms/apply.png"></image>
                <paragraph>这里进行的唯一转换是父节点的比例为(2,1), 子节点的比例为(0.5,0.5), 两个节点都指定了位置.</paragraph>
                <paragraph>All child transformations are affected by the parent transformations.
                    The child has a scale of (0.5, 0.5), so you would expect it to be
                    a 1:1 ratio square, and it is, but only relative to the parent.
                    The child's X vector ends up being (1, 0) in world space, because
                    it is scaled by the parent's basis vectors.
                    Similarly, the child node's <literal>origin</literal> vector is set to (1, 1), but this
                    actually moves it (2, 1) in world space, due to the parent node's
                    basis vectors.</paragraph>
                <paragraph>要手动计算子变换的世界空间变换, 我们将使用以下代码:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Set up transforms like in the image, except make positions be 100 times bigger.
var parent = Transform2D(Vector2(2, 0), Vector2(0, 1), Vector2(100, 200))
var child = Transform2D(Vector2(0.5, 0), Vector2(0, 0.5), Vector2(100, 100))

# Calculate the child's world space transform
# origin = (2, 0) * 100 + (0, 1) * 100 + (100, 200)
var origin = parent.x * child.origin.x + parent.y * child.origin.y + parent.origin
# basis_x = (2, 0) * 0.5 + (0, 1) * 0
var basis_x = parent.x * child.x.x + parent.y * child.x.y
# basis_y = (2, 0) * 0 + (0, 1) * 0.5
var basis_y = parent.x * child.y.x + parent.y * child.y.y

# Change the node's transform to what we calculated.
transform = Transform2D(basis_x, basis_y, origin)</literal_block>
                    </div>
                    <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Set up transforms like in the image, except make positions be 100 times bigger.
Transform2D parent = new Transform2D(2, 0, 0, 1, 100, 200);
Transform2D child = new Transform2D(0.5f, 0, 0, 0.5f, 100, 100);

// Calculate the child's world space transform
// origin = (2, 0) * 100 + (0, 1) * 100 + (100, 200)
Vector2 origin = parent.X * child.Origin.X + parent.Y * child.Origin.Y + parent.Origin;
// basisX = (2, 0) * 0.5 + (0, 1) * 0 = (0.5, 0)
Vector2 basisX = parent.X * child.X.X + parent.Y * child.X.Y;
// basisY = (2, 0) * 0 + (0, 1) * 0.5 = (0.5, 0)
Vector2 basisY = parent.X * child.Y.X + parent.Y * child.Y.Y;

// Change the node's transform to what we calculated.
Transform = new Transform2D(basisX, basisY, origin);</literal_block>
                    </div>
                </container>
                <paragraph>In actual projects, we can find the world transform of the child by
                    applying one transform onto another using the <literal>*</literal> operator:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Set up transforms like in the image, except make positions be 100 times bigger.
var parent = Transform2D(Vector2(2, 0), Vector2(0, 1), Vector2(100, 200))
var child = Transform2D(Vector2(0.5, 0), Vector2(0, 0.5), Vector2(100, 100))

# Change the node's transform to what would be the child's world transform.
transform = parent * child</literal_block>
                    </div>
                    <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Set up transforms like in the image, except make positions be 100 times bigger.
Transform2D parent = new Transform2D(2, 0, 0, 1, 100, 200);
Transform2D child = new Transform2D(0.5f, 0, 0, 0.5f, 100, 100);

// Change the node's transform to what would be the child's world transform.
Transform = parent * child;</literal_block>
                    </div>
                </container>
                <note>
                    <paragraph>当矩阵相乘时, 顺序很重要！别把它们弄混了.</paragraph>
                </note>
                <paragraph>最后, 应用身份变换始终不起任何作用.</paragraph>
                <paragraph>如果你想了解更多信息，可以查看 3Blue1Brown 关于矩阵组成的精彩视频：<reference refuri="http://www.bilibili.com/video/BV1ys411472E?p=5">http://www.bilibili.com/video/BV1ys411472E?p=5</reference></paragraph>
            </section>
            <section ids="inverting-a-transformation-matrix" names="inverting\ a\ transformation\ matrix 求逆变换矩阵">
                <title>求逆变换矩阵</title>
                <paragraph>The "affine_inverse" function returns a transform that "undoes" the
                    previous transform. This can be useful in some situations.
                    Let's take a look at a few examples.</paragraph>
                <paragraph>将反变换乘以法线变换将撤消所有变换:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var ti = transform.affine_inverse()
var t = ti * transform
# The transform is the identity transform.</literal_block>
                    </div>
                    <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Transform2D ti = Transform.AffineInverse();
Transform2D t = ti * Transform;
// The transform is the identity transform.</literal_block>
                    </div>
                </container>
                <paragraph>Transforming a position by a transform and its inverse results in the
                    same position:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-10-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-10-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-10-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var ti = transform.affine_inverse()
position = transform * position
position = ti * position
# The position is the same as before.</literal_block>
                    </div>
                    <div aria-labelledby="tab-10-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-10-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Transform2D ti = Transform.AffineInverse();
Position = Transform * Position;
Position = ti * Position;
// The position is the same as before.</literal_block>
                    </div>
                </container>
            </section>
        </section>
        <section ids="how-does-it-all-work-in-3d" names="how\ does\ it\ all\ work\ in\ 3d? 这一切是如何在\ 3d\ 模式下工作的？">
            <title>这一切是如何在 3D 模式下工作的？</title>
            <paragraph>One of the great things about transformation matrices is that they
                work very similarly between 2D and 3D transformations.
                All the code and formulas used above for 2D work the same in 3D,
                with 3 exceptions: the addition of a third axis, that each
                axis is of type <reference internal="True" refuri="../../classes/class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, and also that Godot stores
                the <reference internal="True" refuri="../../classes/class_basis#class-basis"><inline classes="std std-ref">Basis</inline></reference> separately from the <reference internal="True" refuri="../../classes/class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference>,
                since the math can get complex and it makes sense to separate it.</paragraph>
            <paragraph>与二维相比, 有关平移, 旋转, 缩放和剪切在三维中的工作方式的所有概念都是相同的. 要缩放, 我们取每个分量并将其相乘；要旋转, 我们更改每个基向量指向的位置；要平移, 我们操纵原点；要剪切, 我们将基向量更改为不垂直.</paragraph>
            <image candidates="{'*': 'tutorials/math/img/matrices_and_transforms/3d-identity.png'}" uri="tutorials/math/img/matrices_and_transforms/3d-identity.png"></image>
            <paragraph>如果你愿意, 最好尝试一下转换, 以了解它们是如何工作的. Godot 允许你直接从检查器编辑 3D 变换矩阵. 你可以下载此项目, 其中包含彩色线条和立方体, 以帮助在 2D 和 3D 中可视化 <reference internal="True" refuri="../../classes/class_basis#class-basis"><inline classes="std std-ref">Basis</inline></reference> 向量和原点: <reference refuri="https://github.com/godotengine/godot-demo-projects/tree/master/misc/matrix_transform">https://github.com/godotengine/godot-demo-projects/tree/master/misc/matrix_transform</reference></paragraph>
            <note>
                <paragraph>You cannot edit Node2D's transform matrix directly in Godot 4.0's
                    inspector. This may be changed in a future release of Godot.</paragraph>
            </note>
            <paragraph>如果你想要更多的解释，你可以查看 3Blue1Brown 关于 3D 线性变换的精彩视频：<reference refuri="http://www.bilibili.com/video/BV1ys411472E?p=6">http://www.bilibili.com/video/BV1ys411472E?p=6</reference></paragraph>
            <section ids="representing-rotation-in-3d-advanced" names="representing\ rotation\ in\ 3d\ (advanced) 表示\ 3d\ 中的旋转（高级）">
                <title>表示 3D 中的旋转（高级）</title>
                <paragraph>2D 和 3D 变换矩阵之间最大的区别在于你如何在没有基向量的情况下自行表示旋转。</paragraph>
                <paragraph>With 2D, we have an easy way (atan2) to switch between a transformation
                    matrix and an angle. In 3D, rotation is too complex to represent as one
                    number. There is something called Euler angles, which can represent
                    rotations as a set of 3 numbers, however, they are limited and not very
                    useful, except for trivial cases.</paragraph>
                <paragraph>In 3D we do not typically use angles, we either use a transformation basis
                    (used pretty much everywhere in Godot), or we use quaternions. Godot can
                    represent quaternions using the <reference internal="True" refuri="../../classes/class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> struct. My suggestion
                    to you is to completely ignore how they work under-the-hood, because
                    they are very complicated and unintuitive.</paragraph>
                <paragraph>然而, 如果你真的想知道它是如何工作的, 这里有一些很棒的参考资料, 你可以按顺序跟随它们:</paragraph>
                <paragraph><reference refuri="http://www.bilibili.com/video/BV1fx41187tZ">http://www.bilibili.com/video/BV1fx41187tZ</reference></paragraph>
                <paragraph><reference refuri="http://www.bilibili.com/video/BV1SW411y7W1">http://www.bilibili.com/video/BV1SW411y7W1</reference></paragraph>
                <paragraph><reference refuri="https://eater.net/quaternions">https://eater.net/quaternions</reference></paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
