<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/screen-reading_shaders.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-screen-reading-shaders"></target>
    <section ids="screen-reading-shaders doc-screen-reading-shaders" names="screen-reading\ shaders doc_screen-reading_shaders">
        <title>Screen-reading shaders</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>It is often desired to make a shader that reads from the same
                screen to which it's writing. 3D APIs, such as OpenGL or DirectX, make this very
                difficult because of internal hardware limitations. GPUs are extremely
                parallel, so reading and writing causes all sorts of cache and coherency
                problems. As a result, not even the most modern hardware supports this
                properly.</paragraph>
            <paragraph>The workaround is to make a copy of the screen, or a part of the screen,
                to a back-buffer and then read from it while drawing. Godot provides a
                few tools that make this process easy.</paragraph>
        </section>
        <section ids="screen-texture" names="screen\ texture">
            <title>Screen texture</title>
            <paragraph>Godot <reference internal="True" refuri="shader_reference/shading_language#doc-shading-language"><inline classes="std std-ref">Shading language</inline></reference> has a special texture to access the already
                rendered contents of the screen. It is used by specifying a hint when declaring
                a <literal>sampler2D</literal> uniform: <literal>hint_screen_texture</literal>. A special built-in varying
                <literal>SCREEN_UV</literal> can be used to obtain the UV relative to the screen for the current
                fragment. As a result, this canvas_item fragment shader results in an invisible
                object, because it only shows what lies behind:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

uniform sampler2D screen_texture : hint_screen_texture, repeat_disable, filter_nearest;

void fragment() {
    COLOR = textureLod(screen_texture, SCREEN_UV, 0.0);
}</literal_block>
            <paragraph><literal>textureLod</literal> is used here as we only want to read from the bottom mipmap. If
                you want to read from a blurred version of the texture instead, you can increase
                the third argument to <literal>textureLod</literal> and change the hint <literal>filter_nearest</literal> to
                <literal>filter_nearest_mipmap</literal> (or any other filter with mipmaps enabled). If using a
                filter with mipmaps, Godot will automatically calculate the blurred texture for
                you.</paragraph>
            <warning>
                <paragraph>If the filter mode is not changed to a filter mode that contains <literal>mipmap</literal> in its name,
                    <literal>textureLod</literal> with an LOD parameter greater than <literal>0.0</literal> will have the same appearance
                    as with the <literal>0.0</literal> LOD parameter.</paragraph>
            </warning>
        </section>
        <section ids="screen-texture-example" names="screen\ texture\ example">
            <title>Screen texture example</title>
            <paragraph>The screen texture can be used for many things. There is a
                special demo for <emphasis>Screen Space Shaders</emphasis>, that you can download to see
                and learn. One example is a simple shader to adjust brightness, contrast
                and saturation:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

uniform sampler2D screen_texture : hint_screen_texture, repeat_disable, filter_nearest;

uniform float brightness = 1.0;
uniform float contrast = 1.0;
uniform float saturation = 1.0;

void fragment() {
    vec3 c = textureLod(screen_texture, SCREEN_UV, 0.0).rgb;

    c.rgb = mix(vec3(0.0), c.rgb, brightness);
    c.rgb = mix(vec3(0.5), c.rgb, contrast);
    c.rgb = mix(vec3(dot(vec3(1.0), c.rgb) * 0.33333), c.rgb, saturation);

    COLOR.rgb = c;
}</literal_block>
        </section>
        <section ids="behind-the-scenes" names="behind\ the\ scenes">
            <title>Behind the scenes</title>
            <paragraph>While this seems magical, it's not. In 2D, when <literal>hint_screen_texture</literal> is first
                found in a node that is about to be drawn, Godot does a full-screen copy to a
                back-buffer. Subsequent nodes that use it in shaders will not have the screen
                copied for them, because this ends up being inefficient. In 3D, the screen is
                copied after the opaque geometry pass, but before the transparent geometry pass,
                so transparent objects will not be captured in the screen texture.</paragraph>
            <paragraph>As a result, in 2D, if shaders that use <literal>hint_screen_texture</literal> overlap, the
                second one will not use the result of the first one, resulting in unexpected
                visuals:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/texscreen_demo1.png'}" original_uri="img/texscreen_demo1.png" uri="tutorials/shaders/img/texscreen_demo1.png"></image>
            <paragraph>In the above image, the second sphere (top right) is using the same source for
                the screen texture as the first one below, so the first one "disappears", or is
                not visible.</paragraph>
            <paragraph>In 2D, this can be corrected via the <reference internal="True" refuri="../../classes/class_backbuffercopy#class-backbuffercopy"><inline classes="std std-ref">BackBufferCopy</inline></reference>
                node, which can be instantiated between both spheres. BackBufferCopy can work by
                either specifying a screen region or the whole screen:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/texscreen_bbc.png'}" original_uri="img/texscreen_bbc.png" uri="tutorials/shaders/img/texscreen_bbc.png"></image>
            <paragraph>With correct back-buffer copying, the two spheres blend correctly:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/texscreen_demo2.png'}" original_uri="img/texscreen_demo2.png" uri="tutorials/shaders/img/texscreen_demo2.png"></image>
            <warning>
                <paragraph>In 3D, materials that use <literal>hint_screen_texture</literal> are considered transparent themselves and
                    will not appear in the resulting screen texture of other materials.
                    If you plan to instance a scene that uses a material with <literal>hint_screen_texture</literal>,
                    you will need to use a BackBufferCopy node.</paragraph>
            </warning>
            <paragraph>In 3D, there is less flexibility to solve this particular issue because the
                screen texture is only captured once. Be careful when using the screen texture
                in 3D as it won't capture transparent objects and may capture some opaque
                objects that are in front of the object using the screen texture.</paragraph>
            <paragraph>You can reproduce the back-buffer logic in 3D by creating a <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>
                with a camera in the same position as your object, and then use the
                <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport's</inline></reference> texture instead of the screen texture.</paragraph>
        </section>
        <section ids="back-buffer-logic" names="back-buffer\ logic">
            <title>Back-buffer logic</title>
            <paragraph>So, to make it clearer, here's how the backbuffer copying logic works in 2D in
                Godot:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>If a node uses <literal>hint_screen_texture</literal>, the entire screen is copied to the
                        back buffer before drawing that node. This only happens the first
                        time; subsequent nodes do not trigger this.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If a BackBufferCopy node was processed before the situation in the point
                        above (even if <literal>hint_screen_texture</literal> was not used), the behavior described
                        in the point above does not happen. In other words, automatic copying of the
                        entire screen only happens if <literal>hint_screen_texture</literal> is used in a node for
                        the first time and no BackBufferCopy node (not disabled) was found before in
                        tree-order.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>BackBufferCopy can copy either the entire screen or a region. If set to only
                        a region (not the whole screen) and your shader uses pixels not in the region
                        copied, the result of that read is undefined (most likely garbage from
                        previous frames). In other words, it's possible to use BackBufferCopy to copy
                        back a region of the screen and then read the screen texture from a different
                        region. Avoid this behavior!</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="depth-texture" names="depth\ texture">
            <title>Depth texture</title>
            <paragraph>For 3D shaders, it's also possible to access the screen depth buffer. For this,
                the <literal>hint_depth_texture</literal> hint is used. This texture is not linear; it must be
                converted using the inverse projection matrix.</paragraph>
            <paragraph>The following code retrieves the 3D position below the pixel being drawn:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform sampler2D depth_texture : hint_depth_texture, repeat_disable, filter_nearest;

void fragment() {
    float depth = textureLod(depth_texture, SCREEN_UV, 0.0).r;
    vec4 upos = INV_PROJECTION_MATRIX * vec4(SCREEN_UV * 2.0 - 1.0, depth, 1.0);
    vec3 pixel_position = upos.xyz / upos.w;
}</literal_block>
        </section>
        <section ids="normal-roughness-texture" names="normal-roughness\ texture">
            <title>Normal-roughness texture</title>
            <note>
                <paragraph>Normal-roughness texture is only supported in the Forward+ rendering method,
                    not Mobile or Compatibility.</paragraph>
            </note>
            <paragraph>Similarly, the normal-roughness texture can be used to read the normals and
                roughness of objects rendered in the depth prepass. The normal is stored in the
                <literal>.xyz</literal> channels (mapped to the 0-1 range) while the roughness is stored in the
                <literal>.w</literal> channel.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform sampler2D normal_roughness_texture : hint_normal_roughness_texture, repeat_disable, filter_nearest;

void fragment() {
    float screen_roughness = texture(normal_roughness_texture, SCREEN_UV).w;
    vec3 screen_normal = texture(normal_roughness_texture, SCREEN_UV).xyz;
    screen_normal = screen_normal * 2.0 - 1.0;</literal_block>
        </section>
        <section ids="redefining-screen-textures" names="redefining\ screen\ textures">
            <title>Redefining screen textures</title>
            <paragraph>The screen texture hints (<literal>hint_screen_texture</literal>, <literal>hint_depth_texture</literal>, and
                <literal>hint_normal_roughness_texture</literal>) can be used with multiple uniforms. For
                example, you may want to read from the texture multiple times with a different
                repeat flag or filter flag.</paragraph>
            <paragraph>The following example shows a shader that reads the screen space normal with
                linear filtering, but reads the screen space roughness using nearest neighbor
                filtering.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform sampler2D normal_roughness_texture : hint_normal_roughness_texture, repeat_disable, filter_nearest;
uniform sampler2D normal_roughness_texture2 : hint_normal_roughness_texture, repeat_enable, filter_linear;

void fragment() {
    float screen_roughness = texture(normal_roughness_texture, SCREEN_UV).w;
    vec3 screen_normal = texture(normal_roughness_texture2, SCREEN_UV).xyz;
    screen_normal = screen_normal * 2.0 - 1.0;</literal_block>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
