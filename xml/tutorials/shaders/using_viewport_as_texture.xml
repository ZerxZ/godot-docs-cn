<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/using_viewport_as_texture.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-viewport-as-texture"></target>
    <section ids="using-a-subviewport-as-a-texture doc-viewport-as-texture" names="using\ a\ subviewport\ as\ a\ texture doc_viewport_as_texture">
        <title>Using a SubViewport as a texture</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>This tutorial will introduce you to using the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> as a
                texture that can be applied to 3D objects. In order to do so, it will walk you through the process
                of making a procedural planet like the one below:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_example.png'}" original_uri="img/planet_example.png" uri="tutorials/shaders/img/planet_example.png"></image>
            <note>
                <paragraph>This tutorial does not cover how to code a dynamic atmosphere like the one this planet has.</paragraph>
            </note>
            <paragraph>This tutorial assumes you are familiar with how to set up a basic scene including:
                a <reference internal="True" refuri="../../classes/class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference>, a <reference internal="True" refuri="../../classes/class_omnilight3d#class-omnilight3d"><inline classes="std std-ref">light source</inline></reference>, a
                <reference internal="True" refuri="../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> with a <reference internal="True" refuri="../../classes/class_primitivemesh#class-primitivemesh"><inline classes="std std-ref">Primitive Mesh</inline></reference>,
                and applying a <reference internal="True" refuri="../../classes/class_standardmaterial3d#class-standardmaterial3d"><inline classes="std std-ref">StandardMaterial3D</inline></reference> to the mesh. The focus will be on using
                the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> to dynamically create textures that can be applied to the mesh.</paragraph>
            <paragraph>In this tutorial, we'll cover the following topics:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>How to use a <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> as a render texture</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Mapping a texture to a sphere with equirectangular mapping</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Fragment shader techniques for procedural planets</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Setting a Roughness map from a <reference internal="True" refuri="../../classes/class_viewporttexture#class-viewporttexture"><inline classes="std std-ref">Viewport Texture</inline></reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="setting-up-the-scene" names="setting\ up\ the\ scene">
            <title>Setting up the scene</title>
            <paragraph>Create a new scene and add the following nodes exactly as shown below.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/viewport_texture_node_tree.webp'}" original_uri="img/viewport_texture_node_tree.webp" uri="tutorials/shaders/img/viewport_texture_node_tree.webp"></image>
            <paragraph>Go into the the MeshInstance3D and make the mesh a SphereMesh</paragraph>
        </section>
        <section ids="setting-up-the-subviewport" names="setting\ up\ the\ subviewport">
            <title>Setting up the SubViewport</title>
            <paragraph>Click on the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> node and set its size to <literal>(1024, 512)</literal>. The
                <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> can actually be any size so long as the width is double the
                height. The width needs to be double the height so that the image will accurately map onto the
                sphere, as we will be using equirectangular projection, but more on that later.</paragraph>
            <paragraph>Next disable 3D. We will be using a <reference internal="True" refuri="../../classes/class_colorrect#class-colorrect"><inline classes="std std-ref">ColorRect</inline></reference> to render the surface, so
                we don't need 3D either.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_new_viewport.webp'}" original_uri="img/planet_new_viewport.webp" uri="tutorials/shaders/img/planet_new_viewport.webp"></image>
            <paragraph>Select the <reference internal="True" refuri="../../classes/class_colorrect#class-colorrect"><inline classes="std std-ref">ColorRect</inline></reference> and in the inspector set the anchors preset to <literal>Full Rect</literal>.
                This will ensure that the <reference internal="True" refuri="../../classes/class_colorrect#class-colorrect"><inline classes="std std-ref">ColorRect</inline></reference> takes up the entire <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_new_colorrect.webp'}" original_uri="img/planet_new_colorrect.webp" uri="tutorials/shaders/img/planet_new_colorrect.webp"></image>
            <paragraph>Next, we add a <reference internal="True" refuri="../../classes/class_shadermaterial#class-shadermaterial"><inline classes="std std-ref">Shader Material</inline></reference> to the <reference internal="True" refuri="../../classes/class_colorrect#class-colorrect"><inline classes="std std-ref">ColorRect</inline></reference> (ColorRect &gt; CanvasItem &gt; Material &gt; Material &gt; <literal>New ShaderMaterial</literal>).</paragraph>
            <note>
                <paragraph>Basic familiarity with shading is recommended for this tutorial. However, even if you are new
                    to shaders, all the code will be provided, so you should have no problem following along.</paragraph>
            </note>
            <paragraph>Click the dropdown menu button for the shader material and click / Edit. From here go to Shader &gt; <literal>New Shader</literal>.
                give it a name and click "Create". click the shader in the inspector to open the shader editor. Delete the default code
                and add the following:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

void fragment() {
    COLOR = vec4(UV.x, UV.y, 0.5, 1.0);
}</literal_block>
            <paragraph>save the shader code, you'll see in the inspector that the above code renders a gradient like the one below.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_gradient.png'}" original_uri="img/planet_gradient.png" uri="tutorials/shaders/img/planet_gradient.png"></image>
            <paragraph>Now we have the basics of a <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> that we render to and we have a unique image that we can
                apply to the sphere.</paragraph>
        </section>
        <section ids="applying-the-texture" names="applying\ the\ texture">
            <title>Applying the texture</title>
            <paragraph>Now go into the <reference internal="True" refuri="../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> and add a <reference internal="True" refuri="../../classes/class_standardmaterial3d#class-standardmaterial3d"><inline classes="std std-ref">StandardMaterial3D</inline></reference>
                to it. No need for a special <reference internal="True" refuri="../../classes/class_shadermaterial#class-shadermaterial"><inline classes="std std-ref">Shader Material</inline></reference> (although that would be a good idea
                for more advanced effects, like the atmosphere in the example above).</paragraph>
            <paragraph>MeshInstance3D &gt; GeometryInstance &gt; Geometry &gt; Material Override &gt; <literal>New StandardMaterial3D</literal></paragraph>
            <paragraph>Then click the dropdown for the StandardMaterial3D and click "Edit"</paragraph>
            <paragraph>Go to the "Resource" section and check the <literal>Local to scene</literal> box. Then, go to the "Albedo" section
                and click beside the "Texture" property to add an Albedo Texture. Here we will apply the texture we made.
                Choose "New ViewportTexture"</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_new_viewport_texture.webp'}" original_uri="img/planet_new_viewport_texture.webp" uri="tutorials/shaders/img/planet_new_viewport_texture.webp"></image>
            <paragraph>Click on the ViewportTexture you just created in the inspector, then click "Assign".
                Then, from the menu that pops up, select the Viewport that we rendered to earlier.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_pick_viewport_texture.webp'}" original_uri="img/planet_pick_viewport_texture.webp" uri="tutorials/shaders/img/planet_pick_viewport_texture.webp"></image>
            <paragraph>Your sphere should now be colored in with the colors we rendered to the Viewport.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_seam.webp'}" original_uri="img/planet_seam.webp" uri="tutorials/shaders/img/planet_seam.webp"></image>
            <paragraph>Notice the ugly seam that forms where the texture wraps around? This is because we are picking
                a color based on UV coordinates and UV coordinates do not wrap around the texture. This is a classic
                problem in 2D map projection. Game developers often have a 2-dimensional map they want to project
                onto a sphere, but when it wraps around, it has large seams. There is an elegant workaround for this
                problem that we will illustrate in the next section.</paragraph>
        </section>
        <section ids="making-the-planet-texture" names="making\ the\ planet\ texture">
            <title>Making the planet texture</title>
            <paragraph>So now, when we render to our <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>, it appears magically on the sphere. But there is an ugly
                seam created by our texture coordinates. So how do we get a range of coordinates that wrap around
                the sphere in a nice way? One solution is to use a function that repeats on the domain of our texture.
                <literal>sin</literal> and <literal>cos</literal> are two such functions. Let's apply them to the texture and see what happens. Replace the
                existing color code in the shader with the following:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">COLOR.xyz = vec3(sin(UV.x * 3.14159 * 4.0) * cos(UV.y * 3.14159 * 4.0) * 0.5 + 0.5);</literal_block>
            <image candidates="{'*': 'tutorials/shaders/img/planet_sincos.webp'}" original_uri="img/planet_sincos.webp" uri="tutorials/shaders/img/planet_sincos.webp"></image>
            <paragraph>Not too bad. If you look around, you can see that the seam has now disappeared, but in its place, we
                have pinching at the poles. This pinching is due to the way Godot maps textures to spheres in its
                <reference internal="True" refuri="../../classes/class_standardmaterial3d#class-standardmaterial3d"><inline classes="std std-ref">StandardMaterial3D</inline></reference>. It uses a projection technique called equirectangular
                projection, which translates a spherical map onto a 2D plane.</paragraph>
            <note>
                <paragraph>If you are interested in a little extra information on the technique, we will be converting from
                    spherical coordinates into Cartesian coordinates. Spherical coordinates map the longitude and
                    latitude of the sphere, while Cartesian coordinates are, for all intents and purposes, a
                    vector from the center of the sphere to the point.</paragraph>
            </note>
            <paragraph>For each pixel, we will calculate its 3D position on the sphere. From that, we will use
                3D noise to determine a color value. By calculating the noise in 3D, we solve the problem
                of the pinching at the poles. To understand why, picture the noise being calculated across the
                surface of the sphere instead of across the 2D plane. When you calculate across the
                surface of the sphere, you never hit an edge, and hence you never create a seam or
                a pinch point on the pole. The following code converts the <literal>UVs</literal> into Cartesian
                coordinates.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float theta = UV.y * 3.14159;
float phi = UV.x * 3.14159 * 2.0;
vec3 unit = vec3(0.0, 0.0, 0.0);

unit.x = sin(phi) * sin(theta);
unit.y = cos(theta) * -1.0;
unit.z = cos(phi) * sin(theta);
unit = normalize(unit);</literal_block>
            <paragraph>And if we use <literal>unit</literal> as an output <literal>COLOR</literal> value, we get:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_normals.webp'}" original_uri="img/planet_normals.webp" uri="tutorials/shaders/img/planet_normals.webp"></image>
            <paragraph>Now that we can calculate the 3D position of the surface of the sphere, we can use 3D noise
                to make the planet. We will be using this noise function directly from a <reference name="Shadertoy" refuri="https://www.shadertoy.com/view/Xsl3Dl">Shadertoy</reference><target ids="shadertoy" names="shadertoy" refuri="https://www.shadertoy.com/view/Xsl3Dl"></target>:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">vec3 hash(vec3 p) {
    p = vec3(dot(p, vec3(127.1, 311.7, 74.7)),
             dot(p, vec3(269.5, 183.3, 246.1)),
             dot(p, vec3(113.5, 271.9, 124.6)));

    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
}

float noise(vec3 p) {
  vec3 i = floor(p);
  vec3 f = fract(p);
  vec3 u = f * f * (3.0 - 2.0 * f);

  return mix(mix(mix(dot(hash(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0)),
                     dot(hash(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0)), u.x),
                 mix(dot(hash(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0)),
                     dot(hash(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0)), u.x), u.y),
             mix(mix(dot(hash(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0)),
                     dot(hash(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0)), u.x),
                 mix(dot(hash(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0)),
                     dot(hash(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z );
}</literal_block>
            <note>
                <paragraph>All credit goes to the author, Inigo Quilez. It is published under the <literal>MIT</literal> licence.</paragraph>
            </note>
            <paragraph>Now to use <literal>noise</literal>, add the following to the    <literal>fragment</literal> function:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float n = noise(unit * 5.0);
COLOR.xyz = vec3(n * 0.5 + 0.5);</literal_block>
            <image candidates="{'*': 'tutorials/shaders/img/planet_noise.webp'}" original_uri="img/planet_noise.webp" uri="tutorials/shaders/img/planet_noise.webp"></image>
            <note>
                <paragraph>In order to highlight the texture, we set the material to unshaded.</paragraph>
            </note>
            <paragraph>You can see now that the noise indeed wraps seamlessly around the sphere. Although this
                looks nothing like the planet you were promised. So let's move onto something more colorful.</paragraph>
        </section>
        <section ids="coloring-the-planet" names="coloring\ the\ planet">
            <title>Coloring the planet</title>
            <paragraph>Now to make the planet colors. While there are many ways to do this, for now, we will stick
                with a gradient between water and land.</paragraph>
            <paragraph>To make a gradient in GLSL, we use the <literal>mix</literal> function. <literal>mix</literal> takes two values to interpolate
                between and a third argument to choose how much to interpolate between them; in essence,
                it <emphasis>mixes</emphasis> the two values together. In other APIs, this function is often called <literal>lerp</literal>.
                However, <literal>lerp</literal> is typically reserved for mixing two floats together; <literal>mix</literal> can take any
                values whether it be floats or vector types.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">COLOR.xyz = mix(vec3(0.05, 0.3, 0.5), vec3(0.9, 0.4, 0.1), n * 0.5 + 0.5);</literal_block>
            <paragraph>The first color is blue for the ocean. The second color is a kind of reddish color (because
                all alien planets need red terrain). And finally, they are mixed together by <literal>n * 0.5 + 0.5</literal>.
                <literal>n</literal> smoothly varies between <literal>-1</literal> and <literal>1</literal>. So we map it into the <literal>0-1</literal> range that <literal>mix</literal> expects.
                Now you can see that the colors change between blue and red.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_noise_color.webp'}" original_uri="img/planet_noise_color.webp" uri="tutorials/shaders/img/planet_noise_color.webp"></image>
            <paragraph>That is a little more blurry than we want. Planets typically have a relatively clear separation between
                land and sea. In order to do that, we will change the last term to <literal>smoothstep(-0.1, 0.0, n)</literal>.
                And thus the whole line becomes:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">COLOR.xyz = mix(vec3(0.05, 0.3, 0.5), vec3(0.9, 0.4, 0.1), smoothstep(-0.1, 0.0, n));</literal_block>
            <paragraph>What <literal>smoothstep</literal> does is return <literal>0</literal> if the third argument is below the first and <literal>1</literal> if the
                third argument is larger than the second and smoothly blends between <literal>0</literal> and <literal>1</literal> if the third number
                is between the first and the second. So in this line, <literal>smoothstep</literal> returns <literal>0</literal> whenever <literal>n</literal> is less than <literal>-0.1</literal>
                and it returns <literal>1</literal> whenever <literal>n</literal> is above <literal>0</literal>.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_noise_smooth.webp'}" original_uri="img/planet_noise_smooth.webp" uri="tutorials/shaders/img/planet_noise_smooth.webp"></image>
            <paragraph>One more thing to make this a little more planet-y. The land shouldn't be so blobby; let's make the edges
                a little rougher. A trick that is often used in shaders to make rough looking terrain with noise is
                to layer levels of noise over one another at various frequencies. We use one layer to make the
                overall blobby structure of the continents. Then another layer breaks up the edges a bit, and then
                another, and so on. What we will do is calculate <literal>n</literal> with four lines of shader code
                instead of just one. <literal>n</literal> becomes:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float n = noise(unit * 5.0) * 0.5;
n += noise(unit * 10.0) * 0.25;
n += noise(unit * 20.0) * 0.125;
n += noise(unit * 40.0) * 0.0625;</literal_block>
            <paragraph>And now the planet looks like:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_noise_fbm.webp'}" original_uri="img/planet_noise_fbm.webp" uri="tutorials/shaders/img/planet_noise_fbm.webp"></image>
        </section>
        <section ids="making-an-ocean" names="making\ an\ ocean">
            <title>Making an ocean</title>
            <paragraph>One final thing to make this look more like a planet. The ocean and the land reflect light differently.
                So we want the ocean to shine a little more than the land. We can do this by passing a fourth value
                into the <literal>alpha</literal> channel of our output <literal>COLOR</literal> and using it as a Roughness map.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">COLOR.a = 0.3 + 0.7 * smoothstep(-0.1, 0.0, n);</literal_block>
            <paragraph>This line returns <literal>0.3</literal> for water and <literal>1.0</literal> for land. This means that the land is going to be quite
                rough, while the water will be quite smooth.</paragraph>
            <paragraph>And then, in the material, under the "Metallic" section, make sure <literal>Metallic</literal> is set to <literal>0</literal> and
                <literal>Specular</literal> is set to <literal>1</literal>. The reason for this is the water reflects light really well, but
                isn't metallic. These values are not physically accurate, but they are good enough for this demo.</paragraph>
            <paragraph>Next, under the "Roughness" section set the roughness texture to a
                <reference internal="True" refuri="../../classes/class_viewporttexture#class-viewporttexture"><inline classes="std std-ref">Viewport Texture</inline></reference> pointing to our planet texture <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>.
                Finally, set the <literal>Texture Channel</literal> to <literal>Alpha</literal>. This instructs the renderer to use the <literal>alpha</literal>
                channel of our output <literal>COLOR</literal> as the <literal>Roughness</literal> value.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_ocean.webp'}" original_uri="img/planet_ocean.webp" uri="tutorials/shaders/img/planet_ocean.webp"></image>
            <paragraph>You'll notice that very little changes except that the planet is no longer reflecting the sky.
                This is happening because, by default, when something is rendered with an
                alpha value, it gets drawn as a transparent object over the background. And since the default background
                of the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> is opaque, the <literal>alpha</literal> channel of the
                <reference internal="True" refuri="../../classes/class_viewporttexture#class-viewporttexture"><inline classes="std std-ref">Viewport Texture</inline></reference> is <literal>1</literal>, resulting in the planet texture being
                drawn with slightly fainter colors and a <literal>Roughness</literal> value of <literal>1</literal> everywhere. To correct this, we
                go into the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> and enable the "Transparent Bg" property. Since we are now
                rendering one transparent object on top of another, we want to enable <literal>blend_premul_alpha</literal>:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">render_mode blend_premul_alpha;</literal_block>
            <paragraph>This pre-multiplies the colors by the <literal>alpha</literal> value and then blends them correctly together. Typically,
                when blending one transparent color on top of another, even if the background has an <literal>alpha</literal> of <literal>0</literal> (as it
                does in this case), you end up with weird color bleed issues. Setting <literal>blend_premul_alpha</literal> fixes that.</paragraph>
            <paragraph>Now the planet should look like it is reflecting light on the ocean but not the land. move around the <reference internal="True" refuri="../../classes/class_omnilight3d#class-omnilight3d"><inline classes="std std-ref">OmniLight3D</inline></reference>
                in the scene so you can see the effect of the reflections on the ocean.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_ocean_reflect.webp'}" original_uri="img/planet_ocean_reflect.webp" uri="tutorials/shaders/img/planet_ocean_reflect.webp"></image>
            <paragraph>And there you have it. A procedural planet generated using a <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
