<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/using_viewport_as_texture.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-viewport-as-texture"></target>
    <section ids="using-a-subviewport-as-a-texture doc-viewport-as-texture" names="using\ a\ subviewport\ as\ a\ texture doc_viewport_as_texture">
        <title>Using a SubViewport as a texture</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>This tutorial will introduce you to using the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> as a
                texture that can be applied to 3D objects. In order to do so, it will walk you through the process
                of making a procedural planet like the one below:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_example.png'}" uri="tutorials/shaders/img/planet_example.png"></image>
            <note>
                <paragraph>本教程没有介绍如何编写像这个星球那样的动态氛围.</paragraph>
            </note>
            <paragraph>This tutorial assumes you are familiar with how to set up a basic scene including:
                a <reference internal="True" refuri="../../classes/class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference>, a <reference internal="True" refuri="../../classes/class_omnilight3d#class-omnilight3d"><inline classes="std std-ref">light source</inline></reference>, a
                <reference internal="True" refuri="../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> with a <reference internal="True" refuri="../../classes/class_primitivemesh#class-primitivemesh"><inline classes="std std-ref">Primitive Mesh</inline></reference>,
                and applying a <reference internal="True" refuri="../../classes/class_standardmaterial3d#class-standardmaterial3d"><inline classes="std std-ref">StandardMaterial3D</inline></reference> to the mesh. The focus will be on using
                the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> to dynamically create textures that can be applied to the mesh.</paragraph>
            <paragraph>在本教程中, 我们将介绍以下主题:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>How to use a <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> as a render texture</paragraph>
                </list_item>
                <list_item>
                    <paragraph>使用 equirectangular 映射将纹理映射到球体</paragraph>
                </list_item>
                <list_item>
                    <paragraph>程序式行星的片段着色器技术</paragraph>
                </list_item>
                <list_item>
                    <paragraph>从<reference internal="True" refuri="../../classes/class_viewporttexture#class-viewporttexture"><inline classes="std std-ref">视口纹理</inline></reference>设置粗糙度贴图</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="setting-up-the-scene" names="setting\ up\ the\ scene 设置场景">
            <title>设置场景</title>
            <paragraph>Create a new scene and add the following nodes exactly as shown below.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/viewport_texture_node_tree.webp'}" uri="tutorials/shaders/img/viewport_texture_node_tree.webp"></image>
            <paragraph>Go into the the MeshInstance3D and make the mesh a SphereMesh</paragraph>
        </section>
        <section ids="setting-up-the-subviewport" names="setting\ up\ the\ subviewport">
            <title>Setting up the SubViewport</title>
            <paragraph>Click on the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> node and set its size to <literal>(1024, 512)</literal>. The
                <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> can actually be any size so long as the width is double the
                height. The width needs to be double the height so that the image will accurately map onto the
                sphere, as we will be using equirectangular projection, but more on that later.</paragraph>
            <paragraph>Next disable 3D. We will be using a <reference internal="True" refuri="../../classes/class_colorrect#class-colorrect"><inline classes="std std-ref">ColorRect</inline></reference> to render the surface, so
                we don't need 3D either.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_new_viewport.webp'}" uri="tutorials/shaders/img/planet_new_viewport.webp"></image>
            <paragraph>Select the <reference internal="True" refuri="../../classes/class_colorrect#class-colorrect"><inline classes="std std-ref">ColorRect</inline></reference> and in the inspector set the anchors preset to <literal>Full Rect</literal>.
                This will ensure that the <reference internal="True" refuri="../../classes/class_colorrect#class-colorrect"><inline classes="std std-ref">ColorRect</inline></reference> takes up the entire <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_new_colorrect.webp'}" uri="tutorials/shaders/img/planet_new_colorrect.webp"></image>
            <paragraph>接下来, 我们为 <reference internal="True" refuri="../../classes/class_shadermaterial#class-shadermaterial"><inline classes="std std-ref">Shader Material</inline></reference> 添加一个 <reference internal="True" refuri="../../classes/class_colorrect#class-colorrect"><inline classes="std std-ref">ColorRect</inline></reference> (ColorRect &gt; CanvasItem &gt; Material &gt; Material &gt; <literal>New ShaderMaterial</literal>).</paragraph>
            <note>
                <paragraph>建议本教程基本了解阴影. 但是, 即使你不熟悉着色器, 也将提供所有代码, 因此后续操作应该没有问题.</paragraph>
            </note>
            <paragraph>Click the dropdown menu button for the shader material and click / Edit. From here go to Shader &gt; <literal>New Shader</literal>.
                give it a name and click "Create". click the shader in the inspector to open the shader editor. Delete the default code
                and add the following:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

void fragment() {
    COLOR = vec4(UV.x, UV.y, 0.5, 1.0);
}</literal_block>
            <paragraph>save the shader code, you'll see in the inspector that the above code renders a gradient like the one below.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_gradient.png'}" uri="tutorials/shaders/img/planet_gradient.png"></image>
            <paragraph>Now we have the basics of a <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> that we render to and we have a unique image that we can
                apply to the sphere.</paragraph>
        </section>
        <section ids="applying-the-texture" names="applying\ the\ texture 应用纹理">
            <title>应用纹理</title>
            <paragraph>Now go into the <reference internal="True" refuri="../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> and add a <reference internal="True" refuri="../../classes/class_standardmaterial3d#class-standardmaterial3d"><inline classes="std std-ref">StandardMaterial3D</inline></reference>
                to it. No need for a special <reference internal="True" refuri="../../classes/class_shadermaterial#class-shadermaterial"><inline classes="std std-ref">Shader Material</inline></reference> (although that would be a good idea
                for more advanced effects, like the atmosphere in the example above).</paragraph>
            <paragraph>MeshInstance3D &gt; GeometryInstance &gt; Geometry &gt; Material Override &gt; <literal>New StandardMaterial3D</literal></paragraph>
            <paragraph>Then click the dropdown for the StandardMaterial3D and click "Edit"</paragraph>
            <paragraph>Go to the "Resource" section and check the <literal>Local to scene</literal> box. Then, go to the "Albedo" section
                and click beside the "Texture" property to add an Albedo Texture. Here we will apply the texture we made.
                Choose "New ViewportTexture"</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_new_viewport_texture.webp'}" uri="tutorials/shaders/img/planet_new_viewport_texture.webp"></image>
            <paragraph>Click on the ViewportTexture you just created in the inspector, then click "Assign".
                Then, from the menu that pops up, select the Viewport that we rendered to earlier.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_pick_viewport_texture.webp'}" uri="tutorials/shaders/img/planet_pick_viewport_texture.webp"></image>
            <paragraph>现在, 你的球体应使用我们渲染到视口的颜色进行着色.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_seam.webp'}" uri="tutorials/shaders/img/planet_seam.webp"></image>
            <paragraph>注意到在纹理环绕的地方形成的丑陋缝隙吗？这是因为我们是根据UV坐标来选取颜色的, 而UV坐标并不会环绕纹理. 这是二维地图投影中的一个典型问题. 游戏开发人员通常有一个二维贴图, 他们想投射到一个球体上, 但是当它环绕时, 将有接缝. 这个问题有一个优雅的解决方法, 我们将在下一节中说明.</paragraph>
        </section>
        <section ids="making-the-planet-texture" names="making\ the\ planet\ texture 制作行星纹理">
            <title>制作行星纹理</title>
            <paragraph>So now, when we render to our <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>, it appears magically on the sphere. But there is an ugly
                seam created by our texture coordinates. So how do we get a range of coordinates that wrap around
                the sphere in a nice way? One solution is to use a function that repeats on the domain of our texture.
                <literal>sin</literal> and <literal>cos</literal> are two such functions. Let's apply them to the texture and see what happens. Replace the
                existing color code in the shader with the following:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">COLOR.xyz = vec3(sin(UV.x * 3.14159 * 4.0) * cos(UV.y * 3.14159 * 4.0) * 0.5 + 0.5);</literal_block>
            <image candidates="{'*': 'tutorials/shaders/img/planet_sincos.webp'}" uri="tutorials/shaders/img/planet_sincos.webp"></image>
            <paragraph>Not too bad. If you look around, you can see that the seam has now disappeared, but in its place, we
                have pinching at the poles. This pinching is due to the way Godot maps textures to spheres in its
                <reference internal="True" refuri="../../classes/class_standardmaterial3d#class-standardmaterial3d"><inline classes="std std-ref">StandardMaterial3D</inline></reference>. It uses a projection technique called equirectangular
                projection, which translates a spherical map onto a 2D plane.</paragraph>
            <note>
                <paragraph>如果你对技术方面的一些额外信息感兴趣，我们将从球面坐标转换为直角坐标。球面坐标映射的是球体的经度和纬度，而直角坐标则是从球体中心到点的一个向量。</paragraph>
            </note>
            <paragraph>对于每个像素, 我们将计算它在球体上的三维位置. 由此, 我们将使用3D噪波来确定一个颜色值. 通过计算3D噪波, 我们解决了两极的挤压问题. 要理解为什么, 想象一下在球体表面而不是在二维平面上计算噪声. 当你跨越球体表面进行计算时, 你永远不会碰到边缘, 因此你永远不会在极点上产生接缝或夹点。下面的代码会将“UV”转换为笛卡尔坐标。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float theta = UV.y * 3.14159;
float phi = UV.x * 3.14159 * 2.0;
vec3 unit = vec3(0.0, 0.0, 0.0);

unit.x = sin(phi) * sin(theta);
unit.y = cos(theta) * -1.0;
unit.z = cos(phi) * sin(theta);
unit = normalize(unit);</literal_block>
            <paragraph>如果我们使用 <literal>unit</literal> 作为输出 <literal>COLOR</literal> 值, 我们可以得到:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_normals.webp'}" uri="tutorials/shaders/img/planet_normals.webp"></image>
            <paragraph>现在我们可以计算出球体表面的3D位置, 可以使用3D噪声来制作球体. 直接从 <reference name="Shadertoy" refuri="https://www.shadertoy.com/view/Xsl3Dl">Shadertoy</reference><target ids="shadertoy" names="shadertoy" refuri="https://www.shadertoy.com/view/Xsl3Dl"></target> 中使用这个噪声函数:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">vec3 hash(vec3 p) {
    p = vec3(dot(p, vec3(127.1, 311.7, 74.7)),
             dot(p, vec3(269.5, 183.3, 246.1)),
             dot(p, vec3(113.5, 271.9, 124.6)));

    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
}

float noise(vec3 p) {
  vec3 i = floor(p);
  vec3 f = fract(p);
  vec3 u = f * f * (3.0 - 2.0 * f);

  return mix(mix(mix(dot(hash(i + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0)),
                     dot(hash(i + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0)), u.x),
                 mix(dot(hash(i + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0)),
                     dot(hash(i + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0)), u.x), u.y),
             mix(mix(dot(hash(i + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0)),
                     dot(hash(i + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0)), u.x),
                 mix(dot(hash(i + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0)),
                     dot(hash(i + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0)), u.x), u.y), u.z );
}</literal_block>
            <note>
                <paragraph>所有功劳归作者Inigo Quilez所有. 它是在 <literal>MIT</literal> 许可下发布的.</paragraph>
            </note>
            <paragraph>现在使用 <literal>noised</literal> , 将以下内容添加到 <literal>fragment</literal> 函数中:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float n = noise(unit * 5.0);
COLOR.xyz = vec3(n * 0.5 + 0.5);</literal_block>
            <image candidates="{'*': 'tutorials/shaders/img/planet_noise.webp'}" uri="tutorials/shaders/img/planet_noise.webp"></image>
            <note>
                <paragraph>为了突出显示纹理, 我们将材质设置为无阴影.</paragraph>
            </note>
            <paragraph>你现在可以看到, 尽管这看起来完全不像所承诺的球体, 但噪音确实无缝地包裹着球体. 对此, 让我们进入一些更丰富多彩的东西.</paragraph>
        </section>
        <section ids="coloring-the-planet" names="coloring\ the\ planet 着色这个星球">
            <title>着色这个星球</title>
            <paragraph>现在来制作行星的颜色. 虽然有很多方法可以做到这一点, 但目前, 我们将使用水和陆地之间的梯度.</paragraph>
            <paragraph>要在 GLSL 中创建渐变, 我们使用 <literal>mix</literal> 函数. <literal>mix</literal> 需要两个值来插值和第三个参数来选择在它们之间插入多少, 实质上它将两个值 <emphasis>混合</emphasis> 在一起. 在其他API中, 此函数通常称为 <literal>lerp</literal> . 虽然 <literal>lerp</literal> 通常用于将两个浮点数混合在一起, 但 <literal>mix</literal> 可以取任何值, 无论它是浮点数还是向量类型.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">COLOR.xyz = mix(vec3(0.05, 0.3, 0.5), vec3(0.9, 0.4, 0.1), n * 0.5 + 0.5);</literal_block>
            <paragraph>第一种颜色是蓝色, 代表海洋. 第二种颜色是一种偏红的颜色, 因为所有外星球都需要红色的地形. 最后, 它们 <literal>n * 0.5 + 0.5</literal> 混合在一起. <literal>n</literal> 在 <literal>-1</literal> 和 <literal>1</literal> 之间平滑变化. 所以我们把它映射到 <literal>mix</literal> 预期的 <literal>0-1</literal> 范围内. 现在你可以看到, 颜色在蓝色和红色之间变化.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_noise_color.webp'}" uri="tutorials/shaders/img/planet_noise_color.webp"></image>
            <paragraph>这比我们想要的还要模糊一些. 行星通常在陆地和海洋之间有一个相对清晰的分隔. 为了做到这一点, 我们将把最后一项改为 <literal>smoothstep(-0.1, 0.0, n)</literal> . 整条线就变成了这样:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">COLOR.xyz = mix(vec3(0.05, 0.3, 0.5), vec3(0.9, 0.4, 0.1), smoothstep(-0.1, 0.0, n));</literal_block>
            <paragraph><literal>smoothstep</literal> 所做的是, 如果第三个参数低于第一个参数, 则返回 <literal>0</literal> , 如果第三个参数大于第二个参数, 则返回 <literal>1</literal> , 如果第三个数字在第一个和第二个之间, 则在 <literal>0</literal> 和 <literal>1</literal> 之间平滑地混合. 所以在这一行中, 当 <literal>n</literal> 小于 <literal>-0.1</literal> 时, <literal>smoothstep</literal> 返回 <literal>0</literal> , 当 <literal>n</literal> 高于 <literal>0</literal> 时, 它返回 <literal>1</literal> .</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_noise_smooth.webp'}" uri="tutorials/shaders/img/planet_noise_smooth.webp"></image>
            <paragraph>还有一件事, 使其更像一个行星. 这片土地不应该是圆球状的；让我们把边缘变得更粗糙一些. 在着色器中经常使用的一个技巧是在不同的频率下将不同层次的噪声叠加在一起, 使地形看起来粗糙. 我们使用一个层来制作大陆的整体球状结构. 然后, 另一层将边缘打碎, 然后是另一层, 以此类推. 我们要做的是用四行着色器代码来计算 <literal>n</literal> , 而不是只有一行. <literal>n</literal> 变成了:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float n = noise(unit * 5.0) * 0.5;
n += noise(unit * 10.0) * 0.25;
n += noise(unit * 20.0) * 0.125;
n += noise(unit * 40.0) * 0.0625;</literal_block>
            <paragraph>现在这个星球看起来像:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_noise_fbm.webp'}" uri="tutorials/shaders/img/planet_noise_fbm.webp"></image>
        </section>
        <section ids="making-an-ocean" names="making\ an\ ocean 制作海洋">
            <title>制作海洋</title>
            <paragraph>让这个看起来更像是一颗行星的最后一件事. 海洋和陆地以不同的方式反射光线. 因此, 我们希望海洋比陆地更加闪耀. 我们可以通过将第四个值传递到输出 <literal>COLOR</literal> 的 <literal>alpha</literal> 通道并将其用作粗糙度图来实现.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">COLOR.a = 0.3 + 0.7 * smoothstep(-0.1, 0.0, n);</literal_block>
            <paragraph>该行对于水返回 <literal>0.3</literal> , 对于土地返回 <literal>1.0</literal> . 这意味着土地将变得很粗糙, 而水将变得非常光滑.</paragraph>
            <paragraph>然后，在材质中，在“Metallic”（金属性）部分，请确保 <literal>Metallic</literal> 为 <literal>0</literal>、<literal>Specular</literal> 为 <literal>1</literal>。这样做的原因是水对光线的反射非常好，但它不是金属的。这些值在物理上并不准确，但对于这个演示来说已经足够好了。</paragraph>
            <paragraph>Next, under the "Roughness" section set the roughness texture to a
                <reference internal="True" refuri="../../classes/class_viewporttexture#class-viewporttexture"><inline classes="std std-ref">Viewport Texture</inline></reference> pointing to our planet texture <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>.
                Finally, set the <literal>Texture Channel</literal> to <literal>Alpha</literal>. This instructs the renderer to use the <literal>alpha</literal>
                channel of our output <literal>COLOR</literal> as the <literal>Roughness</literal> value.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_ocean.webp'}" uri="tutorials/shaders/img/planet_ocean.webp"></image>
            <paragraph>You'll notice that very little changes except that the planet is no longer reflecting the sky.
                This is happening because, by default, when something is rendered with an
                alpha value, it gets drawn as a transparent object over the background. And since the default background
                of the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> is opaque, the <literal>alpha</literal> channel of the
                <reference internal="True" refuri="../../classes/class_viewporttexture#class-viewporttexture"><inline classes="std std-ref">Viewport Texture</inline></reference> is <literal>1</literal>, resulting in the planet texture being
                drawn with slightly fainter colors and a <literal>Roughness</literal> value of <literal>1</literal> everywhere. To correct this, we
                go into the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> and enable the "Transparent Bg" property. Since we are now
                rendering one transparent object on top of another, we want to enable <literal>blend_premul_alpha</literal>:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">render_mode blend_premul_alpha;</literal_block>
            <paragraph>这是将颜色预先乘以 <literal>alpha</literal> 值, 然后将它们正确地混合在一起. 通常情况下, 当在一个透明的颜色上混合另一个颜色时, 即使背景的 <literal>alpha</literal> 为 <literal>0</literal> (如本例), 也会出现奇怪的颜色渗漏问题. 设置 <literal>blend_premul_alpha</literal> 可以解决这个问题.</paragraph>
            <paragraph>Now the planet should look like it is reflecting light on the ocean but not the land. move around the <reference internal="True" refuri="../../classes/class_omnilight3d#class-omnilight3d"><inline classes="std std-ref">OmniLight3D</inline></reference>
                in the scene so you can see the effect of the reflections on the ocean.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/planet_ocean_reflect.webp'}" uri="tutorials/shaders/img/planet_ocean_reflect.webp"></image>
            <paragraph>And there you have it. A procedural planet generated using a <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
