<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/custom_postprocessing.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-custom-postprocessing"></target>
    <section ids="custom-post-processing doc-custom-postprocessing" names="custom\ post-processing 自定义后期处理 doc_custom_postprocessing">
        <title>自定义后期处理</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>Godot provides many post-processing effects out of the box, including Bloom,
                DOF, and SSAO, which are described in <reference internal="True" refuri="../3d/environment_and_post_processing#doc-environment-and-post-processing"><inline classes="std std-ref">环境和后期处理</inline></reference>.
                However, advanced use cases may require custom effects. This article explains how
                to write your own custom effects.</paragraph>
            <paragraph>实现自定义后期处理着色器的最简单方法是使用Godot的内置功能从屏幕纹理中读取. 如果你不熟悉这个, 你应该先阅读 <reference internal="True" refuri="screen-reading_shaders#doc-screen-reading-shaders"><inline classes="std std-ref">屏幕阅读着色器教程</inline></reference> .</paragraph>
        </section>
        <section ids="single-pass-post-processing" names="single\ pass\ post-processing 单阶段后期处理">
            <title>单阶段后期处理</title>
            <paragraph>Post-processing effects are shaders applied to a frame after Godot has rendered
                it. To apply a shader to a frame, create a <reference internal="True" refuri="../../classes/class_canvaslayer#class-canvaslayer"><inline classes="std std-ref">CanvasLayer</inline></reference>, and give it a <reference internal="True" refuri="../../classes/class_colorrect#class-colorrect"><inline classes="std std-ref">ColorRect</inline></reference>. Assign a
                new <reference internal="True" refuri="../../classes/class_shadermaterial#class-shadermaterial"><inline classes="std std-ref">ShaderMaterial</inline></reference> to the newly created
                <literal>ColorRect</literal>, and set the <literal>ColorRect</literal>'s layout to "Full Rect".</paragraph>
            <paragraph>Your scene tree will look something like this:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/post_tree1.png'}" uri="tutorials/shaders/img/post_tree1.png"></image>
            <note>
                <paragraph>Another more efficient method is to use a <reference internal="True" refuri="../../classes/class_backbuffercopy#class-backbuffercopy"><inline classes="std std-ref">BackBufferCopy</inline></reference> to copy a region of the screen to a buffer and to
                    access it in a shader script through a <literal>sampler2D</literal> using
                    <literal>hint_screen_texture</literal>.</paragraph>
            </note>
            <note>
                <paragraph>As of the time of writing, Godot does not support rendering to multiple
                    buffers at the same time. Your post-processing shader will not have access
                    to other render passes and buffers not exposed by Godot (such as depth or
                    normal/roughness). You only have access to the rendered frame and buffers
                    exposed by Godot as samplers.</paragraph>
            </note>
            <paragraph>这个演示中，我们使用的是这张小羊的<reference internal="True" refuri="../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">精灵</inline></reference>。</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/post_example1.png'}" uri="tutorials/shaders/img/post_example1.png"></image>
            <paragraph>为 <literal>ColorRect</literal> 的 <literal>ShaderMaterial</literal> 分配一个新的 <reference internal="True" refuri="../../classes/class_shader#class-shader"><inline classes="std std-ref">Shader</inline></reference>。你可以通过使用带 <literal>hint_screen_texture</literal> 的 <literal>sampler2D</literal> 以及内置的 uniform <literal>SCREEN_UV</literal> 来访问这一帧的纹理和 UV。</paragraph>
            <paragraph>将以下代码复制到着色器. 上面的代码是单通道边缘检测滤波器, <reference name="Sobel 滤波器" refuri="https://en.wikipedia.org/wiki/Sobel_operator">Sobel 滤波器</reference><target ids="sobel" names="sobel\ 滤波器" refuri="https://en.wikipedia.org/wiki/Sobel_operator"></target> ，</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

uniform vec2 size = vec2(32.0, 28.0);
// If you intend to read from mipmaps with `textureLod()` LOD values greater than `0.0`,
// use `filter_nearest_mipmap` instead. This shader doesn't require it.
uniform sampler2D screen_texture : hint_screen_texture, repeat_disable, filter_nearest;

void fragment() {
        vec2 norm_size = size * SCREEN_PIXEL_SIZE;
        bool half = mod(SCREEN_UV.y / 2.0, norm_size.y) / norm_size.y &lt; 0.5;
        vec2 uv = SCREEN_UV + vec2(norm_size.x * 0.5 * float(half), 0.0);
        vec2 center_uv = floor(uv / norm_size) * norm_size;
        vec2 norm_uv = mod(uv, norm_size) / norm_size;
        center_uv += mix(vec2(0.0, 0.0),
                         mix(mix(vec2(norm_size.x, -norm_size.y),
                                 vec2(0.0, -norm_size.y),
                                 float(norm_uv.x &lt; 0.5)),
                             mix(vec2(0.0, -norm_size.y),
                                 vec2(-norm_size.x, -norm_size.y),
                                 float(norm_uv.x &lt; 0.5)),
                             float(half)),
                         float(norm_uv.y &lt; 0.3333333) * float(norm_uv.y / 0.3333333 &lt; (abs(norm_uv.x - 0.5) * 2.0)));

        COLOR = textureLod(screen_texture, center_uv, 0.0);
}</literal_block>
            <paragraph>小羊就会变成这样：</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/post_example2.png'}" uri="tutorials/shaders/img/post_example2.png"></image>
        </section>
        <section ids="multi-pass-post-processing" names="multi-pass\ post-processing 多阶段后期处理">
            <title>多阶段后期处理</title>
            <paragraph>Some post-processing effects like blurs are resource intensive. You can make
                them run a lot faster if you break them down in multiple passes. In a multipass
                material, each pass takes the result from the previous pass as an input and
                processes it.</paragraph>
            <paragraph>To produce a multi-pass post-processing shader, you stack <literal>CanvasLayer</literal> and
                <literal>ColorRect</literal> nodes. In the example above, you use a <literal>CanvasLayer</literal> object to
                render a shader using the frame on the layer below. Apart from the node
                structure, the steps are the same as with the single-pass post-processing
                shader.</paragraph>
            <paragraph>Your scene tree will look something like this:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/post_tree2.png'}" uri="tutorials/shaders/img/post_tree2.png"></image>
            <paragraph>例如，可以通过将下面的代码段附加到每个 <literal>ColorRect</literal> 上来编写全屏高斯模糊效果。应用着色器的顺序取决于场景树中 <literal>CanvasLayer</literal> 的位置，越往上越早应用。对于这个模糊着色器而言，顺序是无所谓的。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

uniform sampler2D screen_texture : hint_screen_texture, repeat_disable, filter_nearest;

// Blurs the screen in the X-direction.
void fragment() {
    vec3 col = texture(screen_texture, SCREEN_UV).xyz * 0.16;
    col += texture(screen_texture, SCREEN_UV + vec2(SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.15;
    col += texture(screen_texture, SCREEN_UV + vec2(-SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.15;
    col += texture(screen_texture, SCREEN_UV + vec2(2.0 * SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.12;
    col += texture(screen_texture, SCREEN_UV + vec2(2.0 * -SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.12;
    col += texture(screen_texture, SCREEN_UV + vec2(3.0 * SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.09;
    col += texture(screen_texture, SCREEN_UV + vec2(3.0 * -SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.09;
    col += texture(screen_texture, SCREEN_UV + vec2(4.0 * SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.05;
    col += texture(screen_texture, SCREEN_UV + vec2(4.0 * -SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.05;
    COLOR.xyz = col;
}</literal_block>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

uniform sampler2D screen_texture : hint_screen_texture, repeat_disable, filter_nearest;

// Blurs the screen in the Y-direction.
void fragment() {
    vec3 col = texture(screen_texture, SCREEN_UV).xyz * 0.16;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, SCREEN_PIXEL_SIZE.y)).xyz * 0.15;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, -SCREEN_PIXEL_SIZE.y)).xyz * 0.15;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, 2.0 * SCREEN_PIXEL_SIZE.y)).xyz * 0.12;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, 2.0 * -SCREEN_PIXEL_SIZE.y)).xyz * 0.12;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, 3.0 * SCREEN_PIXEL_SIZE.y)).xyz * 0.09;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, 3.0 * -SCREEN_PIXEL_SIZE.y)).xyz * 0.09;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, 4.0 * SCREEN_PIXEL_SIZE.y)).xyz * 0.05;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, 4.0 * -SCREEN_PIXEL_SIZE.y)).xyz * 0.05;
    COLOR.xyz = col;
}</literal_block>
            <paragraph>使用上面的代码, 你应该得到如下所示的全屏模糊效果.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/post_example3.png'}" uri="tutorials/shaders/img/post_example3.png"></image>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
