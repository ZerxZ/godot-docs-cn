<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/custom_postprocessing.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-custom-postprocessing"></target>
    <section ids="custom-post-processing doc-custom-postprocessing" names="custom\ post-processing doc_custom_postprocessing">
        <title>Custom post-processing</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>Godot provides many post-processing effects out of the box, including Bloom,
                DOF, and SSAO, which are described in <reference internal="True" refuri="../3d/environment_and_post_processing#doc-environment-and-post-processing"><inline classes="std std-ref">Environment and post-processing</inline></reference>.
                However, advanced use cases may require custom effects. This article explains how
                to write your own custom effects.</paragraph>
            <paragraph>The easiest way to implement a custom post-processing shader is to use Godot's
                built-in ability to read from the screen texture. If you're not familiar with
                this, you should read the
                <reference internal="True" refuri="screen-reading_shaders#doc-screen-reading-shaders"><inline classes="std std-ref">Screen Reading Shaders Tutorial</inline></reference> first.</paragraph>
        </section>
        <section ids="single-pass-post-processing" names="single\ pass\ post-processing">
            <title>Single pass post-processing</title>
            <paragraph>Post-processing effects are shaders applied to a frame after Godot has rendered
                it. To apply a shader to a frame, create a <reference internal="True" refuri="../../classes/class_canvaslayer#class-canvaslayer"><inline classes="std std-ref">CanvasLayer</inline></reference>, and give it a <reference internal="True" refuri="../../classes/class_colorrect#class-colorrect"><inline classes="std std-ref">ColorRect</inline></reference>. Assign a
                new <reference internal="True" refuri="../../classes/class_shadermaterial#class-shadermaterial"><inline classes="std std-ref">ShaderMaterial</inline></reference> to the newly created
                <literal>ColorRect</literal>, and set the <literal>ColorRect</literal>'s anchor preset to Full Rect:</paragraph>
            <figure align="center" ids="id1">
                <image alt="Setting the anchor preset to Full Rect on the ColorRect node" candidates="{'*': 'tutorials/shaders/img/custom_postprocessing_anchors_preset_full_rect.webp'}" original_uri="img/custom_postprocessing_anchors_preset_full_rect.webp" uri="tutorials/shaders/img/custom_postprocessing_anchors_preset_full_rect.webp"></image>
                <caption>Setting the anchor preset to Full Rect on the ColorRect node</caption>
            </figure>
            <paragraph>Your scene tree will look something like this:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/post_tree1.png'}" original_uri="img/post_tree1.png" uri="tutorials/shaders/img/post_tree1.png"></image>
            <note>
                <paragraph>Another more efficient method is to use a <reference internal="True" refuri="../../classes/class_backbuffercopy#class-backbuffercopy"><inline classes="std std-ref">BackBufferCopy</inline></reference> to copy a region of the screen to a buffer and to
                    access it in a shader script through a <literal>sampler2D</literal> using
                    <literal>hint_screen_texture</literal>.</paragraph>
            </note>
            <note>
                <paragraph>As of the time of writing, Godot does not support rendering to multiple
                    buffers at the same time. Your post-processing shader will not have access
                    to other render passes and buffers not exposed by Godot (such as depth or
                    normal/roughness). You only have access to the rendered frame and buffers
                    exposed by Godot as samplers.</paragraph>
            </note>
            <paragraph>For this demo, we will use this <reference internal="True" refuri="../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite</inline></reference> of a sheep.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/post_example1.png'}" original_uri="img/post_example1.png" uri="tutorials/shaders/img/post_example1.png"></image>
            <paragraph>Assign a new <reference internal="True" refuri="../../classes/class_shader#class-shader"><inline classes="std std-ref">Shader</inline></reference> to the <literal>ColorRect</literal>'s
                <literal>ShaderMaterial</literal>. You can access the frame's texture and UV with a
                <literal>sampler2D</literal> using <literal>hint_screen_texture</literal> and the built-in <literal>SCREEN_UV</literal>
                uniforms.</paragraph>
            <paragraph>Copy the following code to your shader. The code below is a hex pixelization
                shader by <reference name="arlez80" refuri="https://bitbucket.org/arlez80/hex-mosaic/src/master/">arlez80</reference><target ids="arlez80" names="arlez80" refuri="https://bitbucket.org/arlez80/hex-mosaic/src/master/"></target>,</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

uniform vec2 size = vec2(32.0, 28.0);
// If you intend to read from mipmaps with `textureLod()` LOD values greater than `0.0`,
// use `filter_nearest_mipmap` instead. This shader doesn't require it.
uniform sampler2D screen_texture : hint_screen_texture, repeat_disable, filter_nearest;

void fragment() {
        vec2 norm_size = size * SCREEN_PIXEL_SIZE;
        bool less_than_half = mod(SCREEN_UV.y / 2.0, norm_size.y) / norm_size.y &lt; 0.5;
        vec2 uv = SCREEN_UV + vec2(norm_size.x * 0.5 * float(less_than_half), 0.0);
        vec2 center_uv = floor(uv / norm_size) * norm_size;
        vec2 norm_uv = mod(uv, norm_size) / norm_size;
        center_uv += mix(vec2(0.0, 0.0),
                         mix(mix(vec2(norm_size.x, -norm_size.y),
                                 vec2(0.0, -norm_size.y),
                                 float(norm_uv.x &lt; 0.5)),
                             mix(vec2(0.0, -norm_size.y),
                                 vec2(-norm_size.x, -norm_size.y),
                                 float(norm_uv.x &lt; 0.5)),
                             float(less_than_half)),
                         float(norm_uv.y &lt; 0.3333333) * float(norm_uv.y / 0.3333333 &lt; (abs(norm_uv.x - 0.5) * 2.0)));

        COLOR = textureLod(screen_texture, center_uv, 0.0);
}</literal_block>
            <paragraph>The sheep will look something like this:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/post_example2.png'}" original_uri="img/post_example2.png" uri="tutorials/shaders/img/post_example2.png"></image>
        </section>
        <section ids="multi-pass-post-processing" names="multi-pass\ post-processing">
            <title>Multi-pass post-processing</title>
            <paragraph>Some post-processing effects like blurs are resource intensive. You can make
                them run a lot faster if you break them down in multiple passes. In a multipass
                material, each pass takes the result from the previous pass as an input and
                processes it.</paragraph>
            <paragraph>To produce a multi-pass post-processing shader, you stack <literal>CanvasLayer</literal> and
                <literal>ColorRect</literal> nodes. In the example above, you use a <literal>CanvasLayer</literal> object to
                render a shader using the frame on the layer below. Apart from the node
                structure, the steps are the same as with the single-pass post-processing
                shader.</paragraph>
            <paragraph>Your scene tree will look something like this:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/post_tree2.png'}" original_uri="img/post_tree2.png" uri="tutorials/shaders/img/post_tree2.png"></image>
            <paragraph>As an example, you could write a full screen Gaussian blur effect by attaching
                the following pieces of code to each of the <literal>ColorRect</literal> nodes. The order in
                which you apply the shaders depends on the position of the <literal>CanvasLayer</literal> in
                the scene tree, higher means sooner. For this blur shader, the order does not
                matter.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

uniform sampler2D screen_texture : hint_screen_texture, repeat_disable, filter_nearest;

// Blurs the screen in the X-direction.
void fragment() {
    vec3 col = texture(screen_texture, SCREEN_UV).xyz * 0.16;
    col += texture(screen_texture, SCREEN_UV + vec2(SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.15;
    col += texture(screen_texture, SCREEN_UV + vec2(-SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.15;
    col += texture(screen_texture, SCREEN_UV + vec2(2.0 * SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.12;
    col += texture(screen_texture, SCREEN_UV + vec2(2.0 * -SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.12;
    col += texture(screen_texture, SCREEN_UV + vec2(3.0 * SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.09;
    col += texture(screen_texture, SCREEN_UV + vec2(3.0 * -SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.09;
    col += texture(screen_texture, SCREEN_UV + vec2(4.0 * SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.05;
    col += texture(screen_texture, SCREEN_UV + vec2(4.0 * -SCREEN_PIXEL_SIZE.x, 0.0)).xyz * 0.05;
    COLOR.xyz = col;
}</literal_block>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

uniform sampler2D screen_texture : hint_screen_texture, repeat_disable, filter_nearest;

// Blurs the screen in the Y-direction.
void fragment() {
    vec3 col = texture(screen_texture, SCREEN_UV).xyz * 0.16;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, SCREEN_PIXEL_SIZE.y)).xyz * 0.15;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, -SCREEN_PIXEL_SIZE.y)).xyz * 0.15;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, 2.0 * SCREEN_PIXEL_SIZE.y)).xyz * 0.12;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, 2.0 * -SCREEN_PIXEL_SIZE.y)).xyz * 0.12;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, 3.0 * SCREEN_PIXEL_SIZE.y)).xyz * 0.09;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, 3.0 * -SCREEN_PIXEL_SIZE.y)).xyz * 0.09;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, 4.0 * SCREEN_PIXEL_SIZE.y)).xyz * 0.05;
    col += texture(screen_texture, SCREEN_UV + vec2(0.0, 4.0 * -SCREEN_PIXEL_SIZE.y)).xyz * 0.05;
    COLOR.xyz = col;
}</literal_block>
            <paragraph>Using the above code, you should end up with a full screen blur effect like
                below.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/post_example3.png'}" original_uri="img/post_example3.png" uri="tutorials/shaders/img/post_example3.png"></image>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
