<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/visual_shaders.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-visual-shaders"></target>
    <section ids="using-visualshaders doc-visual-shaders" names="using\ visualshaders 使用\ visualshader doc_visual_shaders">
        <title>使用 VisualShader</title>
        <paragraph>VisualShaders 是创建着色器的可视化替代方案。</paragraph>
        <paragraph>由于着色器本质上与视觉效果有联系, 与纯粹基于脚本的着色器相比, 基于图的方式, 有纹理, 材质等的预览, 提供了很多额外的便利. 另一方面,VisualShaders并没有暴露出着色器脚本的所有功能, 对于特定的效果, 并行使用两者可能是必要的.</paragraph>
        <note>
            <paragraph>如果你对着色器不熟悉，可以从阅读 <reference internal="True" refuri="introduction_to_shaders#doc-introduction-to-shaders"><inline classes="std std-ref">着色器简介</inline></reference> 开始。</paragraph>
        </note>
        <section ids="creating-a-visualshader" names="creating\ a\ visualshader 创建\ visualshader">
            <title>创建 VisualShader</title>
            <paragraph>VisualShader 可以在任何 <reference internal="True" refuri="../../classes/class_shadermaterial#class-shadermaterial"><inline classes="std std-ref">ShaderMaterial</inline></reference> 中创建。要开始使用 VisualShader，请在你选择的对象中创建一个新的 <literal>ShaderMaterial</literal>。</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/shader_material_create_mesh.png'}" uri="tutorials/shaders/img/shader_material_create_mesh.png"></image>
            <paragraph>然后将一个 <reference internal="True" refuri="../../classes/class_visualshader#class-visualshader"><inline classes="std std-ref">VisualShader</inline></reference> 资源分配给 <literal>Shader</literal> 属性。</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/visual_shader_create.webp'}" uri="tutorials/shaders/img/visual_shader_create.webp"></image>
            <paragraph>Click on the new <literal>Shader</literal> resource and the Create Shader dialog will
                open automatically. Change the Type option to VisualShader in the dropdown.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/visual_shader_create2.webp'}" uri="tutorials/shaders/img/visual_shader_create2.webp"></image>
            <paragraph>The layout of the Visual Shader Editor comprises two parts:
                the upper toolbar and the graph itself.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/visual_shader_editor2.png'}" uri="tutorials/shaders/img/visual_shader_editor2.png"></image>
            <paragraph>在工具栏中从左到右：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>添加节点</literal> 按钮会显示一个弹出式菜单，让你为着色器图添加节点。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>下拉菜单是着色器类型. 顶点, 碎片和光线和脚本着色器一样, 它定义了哪些内置节点将是可用的.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>下面的按钮和数字输入控制缩放级别, 网格捕捉和网格线之间的距离(单位为像素).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>最后一个图标显示了与你的图形对应生成的着色器代码.</paragraph>
                </list_item>
            </bullet_list>
            <note>
                <paragraph>虽然 VisualShader 不需要编码，但它们与脚本着色器有着相同的逻辑。建议学习这两者的基础知识，以便对着色管道有一个很好的理解。</paragraph>
                <paragraph>可视化的着色器图形在场景后台转换为脚本着色器, 按下工具栏上的最后一个按钮就可以看到代码. 这可以方便理解特定节点的作用, 以及如何在脚本中呈现.</paragraph>
            </note>
        </section>
        <section ids="using-the-visual-shader-editor" names="using\ the\ visual\ shader\ editor 使用\ visual\ shader\ 编辑器">
            <title>使用 Visual Shader 编辑器</title>
            <paragraph>默认情况下, 每个新的 <literal>VisualShader</literal> 都会有一个输出节点. 每个节点的连接都在输出节点的一个套接处结束. 节点是创建着色器的基本单元. 要添加一个新的节点, 点击左上角的 <literal>添加节点</literal> 按钮, 或者在图形中的任何一个空的位置上右击, 就会弹出一个菜单.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/img/vs_popup.png'}" uri="tutorials/shaders/img/vs_popup.png"></image>
            <paragraph>此弹出窗口具有以下属性:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>如果你在图形上单击右键, 这个菜单将在光标位置被调出, 创建的节点, 在这种情况下, 也将被放在该位置, 否则, 将在图形的中心位置创建.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>它可以在水平和垂直方向上调整大小, 以允许显示更多的内容. 尺寸变换和树的内容位置在调用当中被保存, 所以如果突然关闭了弹出窗口, 可以很容易地恢复它以前的状态.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>下拉选项菜单中的 <literal>展开全部</literal> 和 <literal>折叠全部</literal> 选项可用于轻松列出可用节点.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>你也可以从弹出式菜单中拖放节点到图形上.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>虽然弹出的节点是按类别分类的, 但一开始会不知所以. 试着添加一些节点, 将它们插入输出套接处, 观察会发生什么.</paragraph>
            <paragraph>当把任何 <literal>scalar</literal> 输出连接到 <literal>vector</literal> 输入时, 向量的所有分量将取标量的值.</paragraph>
            <paragraph>当把任何 <literal>vector</literal> 输出连接到 <literal>scalar</literal> 输入时, 标量的值将是向量分量的平均值.</paragraph>
        </section>
        <section ids="visual-shader-node-interface" names="visual\ shader\ node\ interface">
            <title>Visual Shader node interface</title>
            <paragraph>Visual shader nodes have input and output ports. The input ports are located on the left side of the node, and output ports are located on the right side of the node.</paragraph>
            <figure>
                <image candidates="{'*': 'tutorials/shaders/img/vs_node.webp'}" uri="tutorials/shaders/img/vs_node.webp"></image>
            </figure>
            <paragraph>These ports are colored to differentiate type of port:</paragraph>
            <substitution_definition names="scalar"><image alt="scalar" candidates="{'*': 'tutorials/shaders/img/vs_scalar.webp'}" uri="tutorials/shaders/img/vs_scalar.webp"></image></substitution_definition>
            <substitution_definition names="vector"><image alt="vector" candidates="{'*': 'tutorials/shaders/img/vs_vector.webp'}" uri="tutorials/shaders/img/vs_vector.webp"></image></substitution_definition>
            <substitution_definition names="boolean"><image alt="boolean" candidates="{'*': 'tutorials/shaders/img/vs_boolean.webp'}" uri="tutorials/shaders/img/vs_boolean.webp"></image></substitution_definition>
            <substitution_definition names="transform"><image alt="transform" candidates="{'*': 'tutorials/shaders/img/vs_transform.webp'}" uri="tutorials/shaders/img/vs_transform.webp"></image></substitution_definition>
            <substitution_definition names="sampler"><image alt="sampler" candidates="{'*': 'tutorials/shaders/img/vs_sampler.webp'}" uri="tutorials/shaders/img/vs_sampler.webp"></image></substitution_definition>
            <table classes="colwidths-auto" ids="id1">
                <title>Port types</title>
                <tgroup cols="4">
                    <colspec colwidth="25"></colspec>
                    <colspec colwidth="25"></colspec>
                    <colspec colwidth="25"></colspec>
                    <colspec colwidth="25"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>类型</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Color</paragraph>
                            </entry>
                            <entry>
                                <paragraph>描述</paragraph>
                            </entry>
                            <entry>
                                <paragraph>示例</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>Scalar</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Cyan</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Scalar is a single value.</paragraph>
                            </entry>
                            <entry>
                                <paragraph><image alt="scalar" candidates="{'*': 'tutorials/shaders/img/vs_scalar.webp'}" uri="tutorials/shaders/img/vs_scalar.webp"></image></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>向量</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Purple</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Vector is a set of values.</paragraph>
                            </entry>
                            <entry>
                                <paragraph><image alt="vector" candidates="{'*': 'tutorials/shaders/img/vs_vector.webp'}" uri="tutorials/shaders/img/vs_vector.webp"></image></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>Boolean</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Blue</paragraph>
                            </entry>
                            <entry>
                                <paragraph>On or off, true or false.</paragraph>
                            </entry>
                            <entry>
                                <paragraph><image alt="boolean" candidates="{'*': 'tutorials/shaders/img/vs_boolean.webp'}" uri="tutorials/shaders/img/vs_boolean.webp"></image></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>变换</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Orange</paragraph>
                            </entry>
                            <entry>
                                <paragraph>A matrix, usually used to transform vertices.</paragraph>
                            </entry>
                            <entry>
                                <paragraph><image alt="transform" candidates="{'*': 'tutorials/shaders/img/vs_transform.webp'}" uri="tutorials/shaders/img/vs_transform.webp"></image></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>Sampler</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Yellow</paragraph>
                            </entry>
                            <entry>
                                <paragraph>A texture sampler. It can be used to sample textures.</paragraph>
                            </entry>
                            <entry>
                                <paragraph><image alt="sampler" candidates="{'*': 'tutorials/shaders/img/vs_sampler.webp'}" uri="tutorials/shaders/img/vs_sampler.webp"></image></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <paragraph>All of the types are used in the calculations of vertices, fragments, and lights in the shader. For example: matrix multiplication,
                vector addition, or scalar division.</paragraph>
            <paragraph>There are other types but these are the main ones.</paragraph>
        </section>
        <section ids="visual-shader-nodes" names="visual\ shader\ nodes 可视化着色器节点">
            <title>可视化着色器节点</title>
            <paragraph>以下是一些值得了解的特殊节点. 该清单并非详尽无遗, 可能会增加更多的节点和示例.</paragraph>
            <section ids="expression-node" names="expression\ node expression\ 节点">
                <title>Expression 节点</title>
                <paragraph><literal>Expression</literal> 节点允许你在视觉着色器中编写 Godot 着色语言(GLSL-like)表达式. 该节点具有添加任意数量的所需输入和输出端口的按钮, 并且可以调整其大小. 你还可以设置每个端口的名称和类型. 输入的表达式将立即应用于材质(焦点离开表达式文本框后). 任何解析或编译错误都将打印到 "输出" 选项卡. 默认情况下, 输出初始化为零值. 该节点位于 "特殊" 选项卡下, 可用于所有着色器模式.</paragraph>
                <image candidates="{'*': 'tutorials/shaders/img/vs_expression.gif'}" uri="tutorials/shaders/img/vs_expression.gif"></image>
                <paragraph>这个节点的可能性几乎无穷无尽 —— 你可以编写复杂的过程, 并使用基于文本的着色器的全部力量, 例如循环, 关键字 <literal>discard</literal> , 扩展类型, 等等. 例如:</paragraph>
                <image candidates="{'*': 'tutorials/shaders/img/vs_expression2.png'}" uri="tutorials/shaders/img/vs_expression2.png"></image>
            </section>
            <section ids="fresnel-node" names="fresnel\ node fresnel\ 结点">
                <title>Fresnel 结点</title>
                <paragraph><literal>Fresnel</literal> 节点用于接受法线向量和视图向量, 并生成一个标量, 即它们之间的饱和点积. 此外, 你可以设置反转和方程的幂. <literal>Fresnel</literal> 节点非常适合为对象添加类似边缘的照明效果.</paragraph>
                <image candidates="{'*': 'tutorials/shaders/img/vs_fresnel.png'}" uri="tutorials/shaders/img/vs_fresnel.png"></image>
            </section>
            <section ids="boolean-node" names="boolean\ node boolean\ 节点">
                <title>Boolean 节点</title>
                <paragraph><literal>Boolean</literal> 节点可以转换为或 <literal>Scalar</literal> 或 <literal>Vector</literal> , 分别表示 <literal>0</literal> 或 <literal>1</literal> 和 <literal>(0, 0, 0)</literal> 或 <literal>(1, 1, 1)</literal> . 该属性可用于一键启用或禁用某些效果部件.</paragraph>
                <image candidates="{'*': 'tutorials/shaders/img/vs_boolean.gif'}" uri="tutorials/shaders/img/vs_boolean.gif"></image>
            </section>
            <section ids="if-node" names="if\ node if\ 节点">
                <title>If 节点</title>
                <paragraph><literal>If</literal> 节点允许你设置一个向量, 它将返回 <literal>a</literal> 和 <literal>b</literal> 之间的比较结果. 有三个向量可以返回: <literal>a == b</literal> (在这种情况下, 容差参数是作为比较阈值提供的--默认情况下它等于最小值, 即 <literal>0.00001</literal> ), <literal>a &gt; b</literal> 和 <literal>a &lt; b</literal> .</paragraph>
                <image candidates="{'*': 'tutorials/shaders/img/vs_if.png'}" uri="tutorials/shaders/img/vs_if.png"></image>
            </section>
            <section ids="switch-node" names="switch\ node switch\ 节点">
                <title>Switch 节点</title>
                <paragraph>如果布尔条件是 <literal>true</literal> 或 <literal>false</literal> , <literal>Switch</literal> 节点返回一个向量. <literal>Boolean</literal> 在上面介绍过. 如果你把一个向量转换为真布尔值, 那么向量的所有分量都应该高于零.</paragraph>
                <image candidates="{'*': 'tutorials/shaders/img/vs_switch.png'}" uri="tutorials/shaders/img/vs_switch.png"></image>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
