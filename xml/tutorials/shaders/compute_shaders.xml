<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/compute_shaders.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-compute-shaders"></target>
    <section ids="using-compute-shaders doc-compute-shaders" names="using\ compute\ shaders 使用计算着色器 doc_compute_shaders">
        <title>使用计算着色器</title>
        <paragraph>This tutorial will walk you through the process of creating a minimal compute
            shader. But first, a bit of background on compute shaders and how they work with
            Godot.</paragraph>
        <note>
            <paragraph>This tutorial assumes you are familiar with shaders generally. If you are new
                to shaders please read <reference internal="True" refuri="introduction_to_shaders#doc-introduction-to-shaders"><inline classes="std std-ref">着色器简介</inline></reference> and <reference internal="True" refuri="your_first_shader/index#toc-your-first-shader"><inline classes="std std-ref">your
                        first shader</inline></reference> before proceeding with this tutorial.</paragraph>
        </note>
        <paragraph>A compute shader is a special type of shader program that is orientated towards
            general purpose programming. In other words, they are more flexible than vertex
            shaders and fragment shaders as they don't have a fixed purpose (i.e.
            transforming vertices or writing colors to an image). Unlike fragment shaders
            and vertex shaders, compute shaders have very little going on behind the scenes.
            The code you write is what the GPU runs and very little else. This can make them
            a very useful tool to offload heavy calculations to the GPU.</paragraph>
        <paragraph>Now let's get started by creating a short compute shader.</paragraph>
        <paragraph>First, in the <strong>external</strong> text editor of your choice, create a new file called
            <literal>compute_example.glsl</literal> in your project folder. When you write compute shaders
            in Godot, you write them in GLSL directly. The Godot shader language is based on
            GLSL. If you are familiar with normal shaders in Godot, the syntax below will
            look somewhat familiar.</paragraph>
        <note>
            <paragraph>Compute shaders can only be used from RenderingDevice-based renderers (the
                Forward+ or Mobile renderer). To follow along with this tutorial, ensure that
                you are using the Forward+ or Mobile renderer. The setting for which is
                located in the top right-hand corner of the editor.</paragraph>
            <paragraph>Note that compute shader support is generally poor on mobile devices (due to
                driver bugs), even if they are technically supported.</paragraph>
        </note>
        <paragraph>我们把它调成蓝色：</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">#[compute]
#version 450

// Invocations in the (x, y, z) dimension
layout(local_size_x = 2, local_size_y = 1, local_size_z = 1) in;

// A binding to the buffer we create in our script
layout(set = 0, binding = 0, std430) restrict buffer MyDataBuffer {
    float data[];
}
my_data_buffer;

// The code we want to execute in each invocation
void main() {
    // gl_GlobalInvocationID.x uniquely identifies this invocation across all work groups
    my_data_buffer.data[gl_GlobalInvocationID.x] *= 2.0;
}</literal_block>
        <paragraph>This code takes an array of floats, multiplies each element by 2 and store the
            results back in the buffer array. Now let's look at it line-by-line.</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">#[compute]
#version 450</literal_block>
        <paragraph>These two lines communicate two things:</paragraph>
        <block_quote>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>The following code is a compute shader. This is a Godot-specific hint that is needed for the editor to properly import the shader file.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The code is using GLSL version 450.</paragraph>
                </list_item>
            </enumerated_list>
        </block_quote>
        <paragraph>You should never have to change these two lines for your custom compute shaders.</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">// Invocations in the (x, y, z) dimension
layout(local_size_x = 2, local_size_y = 1, local_size_z = 1) in;</literal_block>
        <paragraph>Next, we communicate the number of invocations to be used in each workgroup.
            Invocations are instances of the shader that are running within the same
            workgroup. When we launch a compute shader from the CPU, we tell it how many
            workgroups to run. Workgroups run in parallel to each other. While running one
            workgroup, you cannot access information in another workgroup. However,
            invocations in the same workgroup can have some limited access to other invocations.</paragraph>
        <paragraph>Think about workgroups and invocations as a giant nested <literal>for</literal> loop.</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">for (int x = 0; x &lt; workgroup_size_x; x++) {
  for (int y = 0; y &lt; workgroup_size_y; y++) {
     for (int z = 0; z &lt; workgroup_size_z; z++) {
        // Each workgroup runs independently and in parallel.
        for (int local_x = 0; local_x &lt; invocation_size_x; local_x++) {
           for (int local_y = 0; local_y &lt; invocation_size_y; local_y++) {
              for (int local_z = 0; local_z &lt; invocation_size_z; local_z++) {
                 // Compute shader runs here.
              }
           }
        }
     }
  }
}</literal_block>
        <paragraph>Workgroups and invocations are an advanced topic. For now, remember that we will
            be running two invocations per workgroup.</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">// A binding to the buffer we create in our script
layout(set = 0, binding = 0, std430) restrict buffer MyDataBuffer {
    float data[];
}
my_data_buffer;</literal_block>
        <paragraph>Here we provide information about the memory that the compute shader will have
            access to. The <literal>layout</literal> property allows us to tell the shader where to look
            for the buffer, we will need to match these <literal>set</literal> and <literal>binding</literal> positions
            from the CPU side later.</paragraph>
        <paragraph>The <literal>restrict</literal> keyword tells the shader that this buffer is only going to be
            accessed from one place in this shader. In other words, we won't bind this
            buffer in another <literal>set</literal> or <literal>binding</literal> index. This is important as it allows
            the shader compiler to optimize the shader code. Always use <literal>restrict</literal> when
            you can.</paragraph>
        <paragraph>This is an <emphasis>unsized</emphasis> buffer, which means it can be any size. So we need to be
            careful not to read from an index larger than the size of the buffer.</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">// The code we want to execute in each invocation
void main() {
    // gl_GlobalInvocationID.x uniquely identifies this invocation across all work groups
    my_data_buffer.data[gl_GlobalInvocationID.x] *= 2.0;
}</literal_block>
        <paragraph>Finally, we write the <literal>main</literal> function which is where all the logic happens. We
            access a position in the storage buffer using the <literal>gl_GlobalInvocationID</literal>
            built in variables. <literal>gl_GlobalInvocationID</literal> gives you the global unique ID for
            the current invocation.</paragraph>
        <paragraph>To continue, write the code above into your newly created <literal>compute_example.glsl</literal>
            file.</paragraph>
        <section ids="create-a-local-renderingdevice" names="create\ a\ local\ renderingdevice 创建局部\ renderingdevice">
            <title>创建局部 RenderingDevice</title>
            <paragraph>To interact with and execute a compute shader, we need a script.
                Create a new script in the language of your choice and attach it to any Node
                in your scene.</paragraph>
            <paragraph>Now to execute our shader we need a local <reference internal="True" refuri="../../classes/class_renderingdevice#class-renderingdevice"><inline classes="std std-ref">RenderingDevice</inline></reference>
                which can be created using the <reference internal="True" refuri="../../classes/class_renderingserver#class-renderingserver"><inline classes="std std-ref">RenderingServer</inline></reference>:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Create a local rendering device.
var rd := RenderingServer.create_local_rendering_device()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Create a local rendering device.
var rd = RenderingServer.CreateLocalRenderingDevice();</literal_block>
                </div>
            </container>
            <paragraph>After that, we can load the newly created shader file <literal>compute_example.glsl</literal>
                and create a precompiled version of it using this:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Load GLSL shader
var shader_file := load("res://compute_example.glsl")
var shader_spirv: RDShaderSPIRV = shader_file.get_spirv()
var shader := rd.shader_create_from_spirv(shader_spirv)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Load GLSL shader
var shaderFile = GD.Load&lt;RDShaderFile&gt;("res://compute_example.glsl");
var shaderBytecode = shaderFile.GetSpirV();
var shader = rd.ShaderCreateFromSpirV(shaderBytecode);</literal_block>
                </div>
            </container>
            <warning>
                <paragraph>Local RenderingDevices cannot be debugged using tools such as
                    <reference name="RenderDoc" refuri="https://renderdoc.org/">RenderDoc</reference>.</paragraph>
            </warning>
        </section>
        <section ids="provide-input-data" names="provide\ input\ data 提供输入数据">
            <title>提供输入数据</title>
            <paragraph>As you might remember, we want to pass an input array to our shader, multiply
                each element by 2 and get the results.</paragraph>
            <paragraph>We need to create a buffer to pass values to a compute shader. We are dealing
                with an array of floats, so we will use a storage buffer for this example. A
                storage buffer takes an array of bytes and allows the CPU to transfer data to
                and from the GPU.</paragraph>
            <paragraph>So let's initialize an array of floats and create a storage buffer:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Prepare our data. We use floats in the shader, so we need 32 bit.
var input := PackedFloat32Array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
var input_bytes := input.to_byte_array()

# Create a storage buffer that can hold our float values.
# Each float has 4 bytes (32 bit) so 10 x 4 = 40 bytes
var buffer := rd.storage_buffer_create(input_bytes.size(), input_bytes)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Prepare our data. We use floats in the shader, so we need 32 bit.
var input = new float[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
var inputBytes = new byte[input.Length * sizeof(float)];
Buffer.BlockCopy(input, 0, inputBytes, 0, inputBytes.Length);

// Create a storage buffer that can hold our float values.
// Each float has 4 bytes (32 bit) so 10 x 4 = 40 bytes
var buffer = rd.StorageBufferCreate((uint)inputBytes.Length, inputBytes);</literal_block>
                </div>
            </container>
            <paragraph>With the buffer in place we need to tell the rendering device to use this
                buffer. To do that we will need to create a uniform (like in normal shaders) and
                assign it to a uniform set which we can pass to our shader later.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Create a uniform to assign the buffer to the rendering device
var uniform := RDUniform.new()
uniform.uniform_type = RenderingDevice.UNIFORM_TYPE_STORAGE_BUFFER
uniform.binding = 0 # this needs to match the "binding" in our shader file
uniform.add_id(buffer)
var uniform_set := rd.uniform_set_create([uniform], shader, 0) # the last parameter (the 0) needs to match the "set" in our shader file</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Create a uniform to assign the buffer to the rendering device
var uniform = new RDUniform
{
    UniformType = RenderingDevice.UniformType.StorageBuffer,
    Binding = 0
};
uniform.AddId(buffer);
var uniformSet = rd.UniformSetCreate(new Array&lt;RDUniform&gt; { uniform }, shader, 0);</literal_block>
                </div>
            </container>
        </section>
        <section ids="defining-a-compute-pipeline" names="defining\ a\ compute\ pipeline 定义计算管线">
            <title>定义计算管线</title>
            <paragraph>The next step is to create a set of instructions our GPU can execute.
                We need a pipeline and a compute list for that.</paragraph>
            <paragraph>需要执行以下步骤才能够得到计算结果：</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>新建管线。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Begin a list of instructions for our GPU to execute.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Bind our compute list to our pipeline</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Bind our buffer uniform to our pipeline</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Specify how many workgroups to use</paragraph>
                </list_item>
                <list_item>
                    <paragraph>End the list of instructions</paragraph>
                </list_item>
            </enumerated_list>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Create a compute pipeline
var pipeline := rd.compute_pipeline_create(shader)
var compute_list := rd.compute_list_begin()
rd.compute_list_bind_compute_pipeline(compute_list, pipeline)
rd.compute_list_bind_uniform_set(compute_list, uniform_set, 0)
rd.compute_list_dispatch(compute_list, 5, 1, 1)
rd.compute_list_end()</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Create a compute pipeline
var pipeline = rd.ComputePipelineCreate(shader);
var computeList = rd.ComputeListBegin();
rd.ComputeListBindComputePipeline(computeList, pipeline);
rd.ComputeListBindUniformSet(computeList, uniformSet, 0);
rd.ComputeListDispatch(computeList, xGroups: 5, yGroups: 1, zGroups: 1);
rd.ComputeListEnd();</literal_block>
                </div>
            </container>
            <paragraph>Note that we are dispatching the compute shader with 5 work groups in the
                X axis, and one in the others. Since we have 2 local invocations in the X axis
                (specified in our shader), 10 compute shader invocations will be launched in
                total. If you read or write to indices outside of the range of your buffer, you
                may access memory outside of your shaders control or parts of other variables
                which may cause issues on some hardware.</paragraph>
        </section>
        <section ids="execute-a-compute-shader" names="execute\ a\ compute\ shader 执行计算着色器">
            <title>执行计算着色器</title>
            <paragraph>After all of this we are almost done, but we still need to execute our pipeline.
                So far we have only recorded what we would like the GPU to do; we have not
                actually run the shader program.</paragraph>
            <paragraph>To execute our compute shader we need to submit the pipeline to the GPU and
                wait for the execution to finish:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Submit to GPU and wait for sync
rd.submit()
rd.sync()</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Submit to GPU and wait for sync
rd.Submit();
rd.Sync();</literal_block>
                </div>
            </container>
            <paragraph>Ideally, you would not call <literal>sync()</literal> to synchronize the RenderingDevice right
                away as it will cause the CPU to wait for the GPU to finish working. In our
                example, we synchronize right away because we want our data available for reading
                right away. In general, you will want to wait <emphasis>at least</emphasis> 2 or 3 frames before
                synchronizing so that the GPU is able to run in parallel with the CPU.</paragraph>
            <warning>
                <paragraph>Long computations can cause Windows graphics drivers to "crash" due to
                    <abbreviation explanation="Timeout Detection and Recovery">TDR</abbreviation> being triggered by Windows.
                    This is a mechanism that reinitializes the graphics driver after a certain
                    amount of time has passed without any activity from the graphics driver
                    (usually 5 to 10 seconds).</paragraph>
                <paragraph>Depending on the duration your compute shader takes to execute, you may need
                    to split it into multiple dispatches to reduce the time each dispatch takes
                    and reduce the chances of triggering a TDR. Given TDR is time-dependent,
                    slower GPUs may be more prone to TDRs when running a given compute shader
                    compared to a faster GPU.</paragraph>
            </warning>
        </section>
        <section ids="retrieving-results" names="retrieving\ results 获取结果">
            <title>获取结果</title>
            <paragraph>You may have noticed that, in the example shader, we modified the contents of the
                storage buffer. In other words, the shader read from our array and stored the data
                in the same array again so our results are already there. Let's retrieve
                the data and print the results to our console.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Read back the data from the buffer
var output_bytes := rd.buffer_get_data(buffer)
var output := output_bytes.to_float32_array()
print("Input: ", input)
print("Output: ", output)</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Read back the data from the buffers
var outputBytes = rd.BufferGetData(buffer);
var output = new float[input.Length];
Buffer.BlockCopy(outputBytes, 0, output, 0, outputBytes.Length);
GD.Print("Input: ", string.Join(", ", input));
GD.Print("Output: ", string.Join(", ", output));</literal_block>
                </div>
            </container>
            <paragraph>With that, you have everything you need to get started working with compute
                shaders.</paragraph>
            <seealso>
                <paragraph>The demo projects repository contains a
                    <reference name="Compute Shader Heightmap demo" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/misc/compute_shader_heightmap">Compute Shader Heightmap demo</reference>
                    This project performs heightmap image generation on the CPU and
                    GPU separately, which lets you compare how a similar algorithm can be
                    implemented in two different ways (with the GPU implementation being faster
                    in most cases).</paragraph>
            </seealso>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
