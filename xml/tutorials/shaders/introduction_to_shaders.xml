<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/introduction_to_shaders.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-introduction-to-shaders"></target>
    <section ids="introduction-to-shaders doc-introduction-to-shaders" names="introduction\ to\ shaders 着色器简介 doc_introduction_to_shaders">
        <title>着色器简介</title>
        <paragraph>本页面会讲解什么是着色器，会为你综述其在 Godot 中的使用方法。引擎中着色语言的详细参考见 <reference internal="True" refuri="shader_reference/shading_language#doc-shading-language"><inline classes="std std-ref">着色语言</inline></reference>。</paragraph>
        <paragraph>着色器（Shader）是一种在图形处理单元（GPU）上运行的特殊程序。他们最初使用来为 3D 场景着色的，不过现在能做的事情就更多了。你可以用它们来控制引擎在屏幕上绘制几何体以及像素的方式，可以用来实现各种特效。</paragraph>
        <paragraph>类似 Godot 的现代渲染引擎都会用着色器来执行所有绘制操作：图形卡可以并行执行成千上万条指令，可以达到惊人的渲染速度。</paragraph>
        <paragraph>因为天生就是并行的，所以着色器处理信息的方式与普通的程序有所不同。着色器代码是单独针对顶点或像素执行的。你也无法在帧与帧之间存储数据。因此，使用着色器时，你需要使用与其他编程语言不同的编码和思考方式。</paragraph>
        <paragraph>假设你想要把纹理中的所有像素点都设置成某个给定的颜色。使用 GDScript，你的代码会用 <literal>for</literal> 循环：</paragraph>
        <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for x in range(width):
  for y in range(height):
    set_color(x, y, some_color)</literal_block>
        <paragraph>在着色器中，你的代码已经是循环的一部分了，所以对应的代码应该类似这样。</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  COLOR = some_color;
}</literal_block>
        <note>
            <paragraph>图形卡会为需要绘制的每一个像素调用若干次 <literal>fragment()</literal> 函数。后面会详细说明。</paragraph>
        </note>
        <section ids="shaders-in-godot" names="shaders\ in\ godot godot\ 中的着色器">
            <title>Godot 中的着色器</title>
            <paragraph>Godot 所提供的着色语言是基于流行的 OpenGL 着色语言（GLSL）的简化。引擎会为你处理一些底层的初始化工作，让编写复杂着色器更为简单。</paragraph>
            <paragraph>在 Godot 中，着色器由若干主函数组成，这些函数被称为“处理器函数”。处理器函数是着色器程序的入口。有七种不同的处理器函数。</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><literal>vertex()</literal> 函数会为网格中的所有顶点各运行一次，用来设置顶点的位置和其他与顶点相关的变量。在 <reference internal="True" refuri="shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">canvas_item 着色器</inline></reference>和<reference internal="True" refuri="shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">空间着色器</inline></reference>中使用。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>fragment()</literal> 函数会为网格所覆盖的所有像素各运行一次。这个函数会用到 <literal>vertex()</literal> 函数输出的值，这些值会在顶点之间进行插值。在 <reference internal="True" refuri="shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">canvas_item 着色器</inline></reference>和<reference internal="True" refuri="shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">空间着色器</inline></reference>中使用。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>light()</literal> 函数会为每个像素和每个灯光各运行一次。这个函数会用到 <literal>fragment()</literal> 函数以及前几次运行中的变量。在 <reference internal="True" refuri="shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">canvas_item 着色器</inline></reference>和<reference internal="True" refuri="shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">空间着色器</inline></reference>中使用。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>start()</literal> 函数会在粒子系统中的每个粒子出生时各运行一次。在<reference internal="True" refuri="shader_reference/particle_shader#doc-particle-shader"><inline classes="std std-ref">粒子着色器</inline></reference>中使用。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>process()</literal> 函数会为粒子系统中的每个粒子每帧时各运行一次。在<reference internal="True" refuri="shader_reference/particle_shader#doc-particle-shader"><inline classes="std std-ref">粒子着色器</inline></reference>中使用。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>sky()</literal> 函数会在辐射度立方体贴图需要更新时为辐射度立方体贴图中的每个像素各运行一次，也会为当前屏幕上的每个像素运行一次。在<reference internal="True" refuri="shader_reference/sky_shader#doc-sky-shader"><inline classes="std std-ref">天空着色器</inline></reference>中使用。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>fog()</literal> 函数会为体积雾片段体素缓冲中与 <reference internal="True" refuri="../../classes/class_fogvolume#class-fogvolume"><inline classes="std std-ref">FogVolume</inline></reference> 相交的每个片段体素运行一次。在<reference internal="True" refuri="shader_reference/fog_shader#doc-fog-shader"><inline classes="std std-ref">雾着色器</inline></reference>中使用。</paragraph>
                </list_item>
            </enumerated_list>
            <warning>
                <paragraph>如果启用了 <literal>vertex_lighting</literal> 渲染模式，或者在项目设置中启用了 <strong>Rendering &gt; Quality &gt; Shading &gt; Force Vertex Shading</strong>（渲染 &gt; 质量 &gt; 着色 &gt; 强制顶点着色），则不会运行 <literal>light()</literal> 函数。在移动平台上默认启用。</paragraph>
            </warning>
            <note>
                <paragraph>Godot 还为用户编写完全自定义的 GLSL 着色器暴露了 API。详见 <reference internal="True" refuri="compute_shaders#doc-compute-shaders"><inline classes="std std-ref">使用计算着色器</inline></reference>。</paragraph>
            </note>
        </section>
        <section ids="shader-types" names="shader\ types 着色器类型">
            <title>着色器类型</title>
            <paragraph>你所编写的着色器必须指定类型（2D、3D、粒子、天空、雾），不存在所有场景都可以使用的通用配置。不同的类型支持不同的渲染模式、内置变量、处理函数。</paragraph>
            <paragraph>在 Godot 中，所有的着色器都需要在第一行指定它们的类型，类似这样：</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;</literal_block>
            <paragraph>有以下类型可用：</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>用于 3D 渲染的 <reference internal="True" refuri="shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">spatial</inline></reference>。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>用于 2D 渲染的 <reference internal="True" refuri="shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">canvas_item</inline></reference>。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>用于粒子系统的 <reference internal="True" refuri="shader_reference/particle_shader#doc-particle-shader"><inline classes="std std-ref">particles</inline></reference>。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>用于渲染 <reference internal="True" refuri="../../classes/class_sky#class-sky"><inline classes="std std-ref">Skies</inline></reference> 的 <reference internal="True" refuri="shader_reference/sky_shader#doc-sky-shader"><inline classes="std std-ref">sky</inline></reference>。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>用于渲染 <reference internal="True" refuri="../../classes/class_fogvolume#class-fogvolume"><inline classes="std std-ref">FogVolumes</inline></reference> 的 <reference internal="True" refuri="shader_reference/fog_shader#doc-fog-shader"><inline classes="std std-ref">fog</inline></reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="render-modes" names="render\ modes 渲染模式">
            <title>渲染模式</title>
            <paragraph>可以在着色器的第二行，也就是在着色器类型之后，指定渲染模式，类似这样：</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;
render_mode unshaded, cull_disabled;</literal_block>
            <paragraph>渲染模式会修改 Godot 应用着色器的方式。例如，<literal>unshaded</literal> 模式会让引擎跳过内置的光线处理器函数。</paragraph>
            <paragraph>每种着色器类型都有不同的渲染模式。每种着色器类型的完整渲染模式列表请参阅参考手册。</paragraph>
            <section ids="vertex-processor" names="vertex\ processor 顶点处理器">
                <title>顶点处理器</title>
                <paragraph>在 <literal>spatial</literal> 和 <literal>canvas_item</literal> 着色器中，会为每一个顶点调用 <literal>vertex()</literal> 处理函数。在 <literal>particles</literal> 着色器中则会为每一个粒子调用一次。</paragraph>
                <paragraph>你的世界中的几何体上，每一个顶点都有位置、颜色等属性。该函数会修改这些值，并将其传入片段函数。你也可以借助 varying 向片段着色器传递额外的数据。</paragraph>
                <paragraph>默认情况下，Godot 会为你对顶点信息进行变换，这是将几何体投影到屏幕上所必须的。你可以使用渲染模式来自行变换数据；示例见 <reference internal="True" refuri="shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">Spatial 着色器文档</inline></reference>。</paragraph>
            </section>
            <section ids="fragment-processor" names="fragment\ processor 片段处理器">
                <title>片段处理器</title>
                <paragraph><literal>fragment()</literal> 处理函数的作用是设置每一个像素的 Godot 材质参数。这里的代码会在绘制的对象或图元的每一个可见像素上执行。只能在 <literal>spatial</literal>、<literal>canvas_item</literal>、<literal>sky</literal> 着色器中使用。</paragraph>
                <paragraph>片段函数的标准用途是设置用于计算光照的材质属性。例如，你可以为 <literal>ROUGHNESS</literal>、<literal>RIM</literal>、<literal>TRNASMISSION</literal> 等设置值，告诉光照函数光照应该如何处理对应的片段。这样就可以控制复杂的着色管线，而不必让用户编写过多的代码。如果你不需要这一内置功能，那么你可以忽略它，自行编写光照处理函数，Godot 会将其优化掉。例如，如果你没有向 <literal>RIM</literal> 写入任何值，那么 Godot 就不会计算边缘光照。编译时，Godot 会检查是否使用了 <literal>RIM</literal>；如果没有，那么它就会把对应的代码删除。因此，你就不会在没有使用的效果上浪费算力。</paragraph>
            </section>
            <section ids="light-processor" names="light\ processor 光照处理器">
                <title>光照处理器</title>
                <paragraph><literal>light()</literal> 处理器也会在每一个像素上运行，并且同时还会在每一个影响该对象的灯光上运行。如果没有灯光影响该对象则不会运行。它会被用于 <literal>fragment()</literal> 处理器，一般会在 <literal>fragment()</literal> 函数中进行材质属性设置时执行。</paragraph>
                <paragraph><literal>light()</literal> 处理器在 2D 和 3D 中的工作方式不同；每种工作方式的详细描述请参阅它们对应的文档 <reference internal="True" refuri="shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">CanvasItem 着色器</inline></reference> and <reference internal="True" refuri="shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">Spatial 着色器</inline></reference>。</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
