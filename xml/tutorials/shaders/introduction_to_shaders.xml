<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/introduction_to_shaders.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-introduction-to-shaders"></target>
    <section ids="introduction-to-shaders doc-introduction-to-shaders" names="introduction\ to\ shaders doc_introduction_to_shaders">
        <title>Introduction to shaders</title>
        <paragraph>This page explains what shaders are and will give you an overview of how they
            work in Godot. For a detailed reference of the engine's shading language, see
            <reference internal="True" refuri="shader_reference/shading_language#doc-shading-language"><inline classes="std std-ref">Shading language</inline></reference>.</paragraph>
        <paragraph>Shaders are a special kind of program that runs on Graphics Processing Units
            (GPUs). They were initially used to shade 3D scenes but can nowadays do much
            more. You can use them to control how the engine draws geometry and pixels on
            the screen, allowing you to achieve all sorts of effects.</paragraph>
        <paragraph>Modern rendering engines like Godot draw everything with shaders: graphics cards
            can run thousands of instructions in parallel, leading to incredible rendering
            speed.</paragraph>
        <paragraph>Because of their parallel nature, though, shaders don't process information the
            way a typical program does. Shader code runs on each vertex or pixel in
            isolation. You cannot store data between frames either. As a result, when
            working with shaders, you need to code and think differently from other
            programming languages.</paragraph>
        <paragraph>Suppose you want to update all the pixels in a texture to a given color. In
            GDScript, your code would use <literal>for</literal> loops:</paragraph>
        <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for x in range(width):
    for y in range(height):
        set_color(x, y, some_color)</literal_block>
        <paragraph>Your code is already part of a loop in a shader, so the corresponding code would
            look like this.</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
    COLOR = some_color;
}</literal_block>
        <note>
            <paragraph>The graphics card calls the <literal>fragment()</literal> function once or more for each
                pixel it has to draw. More on that below.</paragraph>
        </note>
        <section ids="shaders-in-godot" names="shaders\ in\ godot">
            <title>Shaders in Godot</title>
            <paragraph>Godot provides a shading language based on the popular OpenGL Shading Language
                (GLSL) but simplified. The engine handles some of the lower-level initialization
                work for you, making it easier to write complex shaders.</paragraph>
            <paragraph>In Godot, shaders are made up of main functions called "processor functions".
                Processor functions are the entry point for your shader into the program. There
                are seven different processor functions.</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>The <literal>vertex()</literal> function runs over all the vertices in the mesh and sets
                        their positions and some other per-vertex variables. Used in
                        <reference internal="True" refuri="shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">canvas_item shaders</inline></reference> and
                        <reference internal="True" refuri="shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">spatial shaders</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal>fragment()</literal> function runs for every pixel covered by the mesh. It uses
                        values output by the <literal>vertex()</literal> function, interpolated between the
                        vertices. Used in <reference internal="True" refuri="shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">canvas_item shaders</inline></reference> and
                        <reference internal="True" refuri="shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">spatial shaders</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal>light()</literal> function runs for every pixel and for every light. It takes
                        variables from the <literal>fragment()</literal> function and from its previous runs. Used
                        in <reference internal="True" refuri="shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">canvas_item shaders</inline></reference> and
                        <reference internal="True" refuri="shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">spatial shaders</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal>start()</literal> function runs for every particle in a particle system once
                        when the particle is first spawned. Used in
                        <reference internal="True" refuri="shader_reference/particle_shader#doc-particle-shader"><inline classes="std std-ref">particles shaders</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal>process()</literal> function runs for every particle in a particle system for
                        each frame. Used in <reference internal="True" refuri="shader_reference/particle_shader#doc-particle-shader"><inline classes="std std-ref">particles shaders</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal>sky()</literal> function runs for every pixel in the radiance cubemap when the
                        radiance cubemap needs to be updated, and for every pixel on the current
                        screen. Used in <reference internal="True" refuri="shader_reference/sky_shader#doc-sky-shader"><inline classes="std std-ref">sky shaders</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal>fog()</literal> function runs for every froxel in the volumetric fog froxel
                        buffer that intersects with the <reference internal="True" refuri="../../classes/class_fogvolume#class-fogvolume"><inline classes="std std-ref">FogVolume</inline></reference>. Used by
                        <reference internal="True" refuri="shader_reference/fog_shader#doc-fog-shader"><inline classes="std std-ref">fog shaders</inline></reference>.</paragraph>
                </list_item>
            </enumerated_list>
            <warning>
                <paragraph>The <literal>light()</literal> function won't run if the <literal>vertex_lighting</literal> render mode is
                    enabled, or if <strong>Rendering &gt; Quality &gt; Shading &gt; Force Vertex Shading</strong> is
                    enabled in the Project Settings. It's enabled by default on mobile
                    platforms.</paragraph>
            </warning>
            <note>
                <paragraph>Godot also exposes an API for users to write totally custom GLSL shaders. For
                    more information see <reference internal="True" refuri="compute_shaders#doc-compute-shaders"><inline classes="std std-ref">Using compute shaders</inline></reference>.</paragraph>
            </note>
        </section>
        <section ids="shader-types" names="shader\ types">
            <title>Shader types</title>
            <paragraph>Instead of supplying a general-purpose configuration for all uses (2D, 3D,
                particles, sky, fog), you must specify the type of shader you're writing.
                Different types support different render modes, built-in variables, and
                processing functions.</paragraph>
            <paragraph>In Godot, all shaders need to specify their type in the first line, like so:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;</literal_block>
            <paragraph>Here are the available types:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph><reference internal="True" refuri="shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">spatial</inline></reference> for 3D rendering.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">canvas_item</inline></reference> for 2D rendering.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="shader_reference/particle_shader#doc-particle-shader"><inline classes="std std-ref">particles</inline></reference> for particle systems.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="shader_reference/sky_shader#doc-sky-shader"><inline classes="std std-ref">sky</inline></reference> to render <reference internal="True" refuri="../../classes/class_sky#class-sky"><inline classes="std std-ref">Skies</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="shader_reference/fog_shader#doc-fog-shader"><inline classes="std std-ref">fog</inline></reference> to render <reference internal="True" refuri="../../classes/class_fogvolume#class-fogvolume"><inline classes="std std-ref">FogVolumes</inline></reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="render-modes" names="render\ modes">
            <title>Render modes</title>
            <paragraph>Shaders have optional render modes you can specify on the second line, after the
                shader type, like so:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;
render_mode unshaded, cull_disabled;</literal_block>
            <paragraph>Render modes alter the way Godot applies the shader. For example, the
                <literal>unshaded</literal> mode makes the engine skip the built-in light processor function.</paragraph>
            <paragraph>Each shader type has different render modes. See the reference for each shader
                type for a complete list of render modes.</paragraph>
            <section ids="vertex-processor" names="vertex\ processor">
                <title>Vertex processor</title>
                <paragraph>The <literal>vertex()</literal> processing function is called once for every vertex in
                    <literal>spatial</literal> and <literal>canvas_item</literal> shaders.</paragraph>
                <paragraph>Each vertex in your world's geometry has properties like a position and color.
                    The function modifies those values and passes them to the fragment function. You
                    can also use it to send extra data to the fragment function using varyings.</paragraph>
                <paragraph>By default, Godot transforms your vertex information for you, which is necessary
                    to project geometry onto the screen. You can use render modes to transform the
                    data yourself; see the <reference internal="True" refuri="shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">Spatial shader doc</inline></reference> for an
                    example.</paragraph>
            </section>
            <section ids="fragment-processor" names="fragment\ processor">
                <title>Fragment processor</title>
                <paragraph>The <literal>fragment()</literal> processing function is used to set up the Godot material
                    parameters per pixel. This code runs on every visible pixel the object or
                    primitive draws. It is only available in <literal>spatial</literal> and <literal>canvas_item</literal> shaders.</paragraph>
                <paragraph>The standard use of the fragment function is to set up material properties used
                    to calculate lighting. For example, you would set values for <literal>ROUGHNESS</literal>,
                    <literal>RIM</literal>, or <literal>TRANSMISSION</literal>, which would tell the light function how the lights
                    respond to that fragment. This makes it possible to control a complex shading
                    pipeline without the user having to write much code. If you don't need this
                    built-in functionality, you can ignore it and write your own light processing
                    function, and Godot will optimize it away. For example, if you do not write a
                    value to <literal>RIM</literal>, Godot will not calculate rim lighting. During compilation,
                    Godot checks to see if <literal>RIM</literal> is used; if not, it cuts all the corresponding
                    code out. Therefore, you will not waste calculations on the effects that you do
                    not use.</paragraph>
            </section>
            <section ids="light-processor" names="light\ processor">
                <title>Light processor</title>
                <paragraph>The <literal>light()</literal> processor runs per pixel too, and it runs once for every light
                    that affects the object. It does not run if no lights affect the object. It
                    exists as a function called inside the <literal>fragment()</literal> processor and typically
                    operates on the material properties setup inside the <literal>fragment()</literal> function.</paragraph>
                <paragraph>The <literal>light()</literal> processor works differently in 2D than it does in 3D; for a
                    description of how it works in each, see their documentation, <reference internal="True" refuri="shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">CanvasItem
                            shaders</inline></reference> and <reference internal="True" refuri="shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">Spatial shaders</inline></reference>, respectively.</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
