<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/your_first_shader/your_first_2d_shader.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-your-first-canvasitem-shader"></target>
    <section ids="your-first-2d-shader doc-your-first-canvasitem-shader" names="your\ first\ 2d\ shader 你的第一个\ 2d\ 着色器 doc_your_first_canvasitem_shader">
        <title>你的第一个 2D 着色器</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>着色器是在 GPU 上运行，用来渲染图像的一种特殊程序。现代渲染都是通过着色器实现的。若想了解关于着色器更详细的说明，请查看<reference internal="True" refuri="../introduction_to_shaders#doc-introduction-to-shaders"><inline classes="std std-ref">着色器是什么</inline></reference>。</paragraph>
            <paragraph>本教程将重点介绍实际编写着色器程序的各个方面, 引导你走过使用顶点和片段函数编写着色器的整个流程. 本教程面向着色器.</paragraph>
            <note>
                <paragraph>如果你在着色器方面有一定的经验，只是想知道着色器在 Godot 中是如何运作的，请参阅<reference internal="True" refuri="../shader_reference/index#toc-shading-reference"><inline classes="std std-ref">着色器参考</inline></reference>。</paragraph>
            </note>
        </section>
        <section ids="setup" names="setup 场景布置">
            <title>场景布置</title>
            <paragraph><reference internal="True" refuri="../shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">CanvasItem shaders</inline></reference> are used to draw all 2D
                objects in Godot, while <reference internal="True" refuri="../shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">Spatial</inline></reference> shaders are used
                to draw all 3D objects.</paragraph>
            <paragraph>In order to use a shader it must be attached inside a <reference internal="True" refuri="../../../classes/class_material#class-material"><inline classes="std std-ref">Material</inline></reference> which must be attached to an object. Materials are a type of
                <reference internal="True" refuri="../../scripting/resources#doc-resources"><inline classes="std std-ref">Resource</inline></reference>. To draw multiple objects with the same
                material, the material must be attached to each object.</paragraph>
            <paragraph>All objects derived from a <reference internal="True" refuri="../../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference> have a material
                property. This includes all <reference internal="True" refuri="../../../classes/class_control#class-control"><inline classes="std std-ref">GUI elements</inline></reference>, <reference internal="True" refuri="../../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite2Ds</inline></reference>, <reference internal="True" refuri="../../../classes/class_tilemap#class-tilemap"><inline classes="std std-ref">TileMaps</inline></reference>, <reference internal="True" refuri="../../../classes/class_meshinstance2d#class-meshinstance2d"><inline classes="std std-ref">MeshInstance2Ds</inline></reference> etc. They also have an option to inherit their parent's
                material. This can be useful if you have a large number of nodes that you want
                to use the same material.</paragraph>
            <paragraph>To begin, create a Sprite2D node. <reference internal="True" refuri="../../2d/custom_drawing_in_2d#doc-custom-drawing-in-2d"><inline classes="std std-ref">You can use any CanvasItem</inline></reference>,
                so long as it is drawing to the canvas, so for this tutorial we will use a Sprite2D,
                as it is the easiest CanvasItem to start drawing with.</paragraph>
            <paragraph>In the Inspector, click beside "Texture" where it says "[empty]" and select
                "Load", then select "icon.svg". For new projects, this is the Godot icon. You
                should now see the icon in the viewport.</paragraph>
            <paragraph>接下来，在“检查器”下的 CanvasItem 部分中，在“Material”旁点击并选择“新建 ShaderMaterial”。这会创建一个新的材质资源。然后点击新出现的球体。Godot 目前还不知道你是要写 CanvasItem 着色器还是 Spatial 着色器，它显示 Spatial 着色器的输出预览，所以你看到的是默认的 Spatial 着色器的输出。</paragraph>
            <paragraph>Click beside "Shader" and select "New Shader". Finally, click on the shader
                you just created and the shader editor will open. You are now ready to begin writing
                your first shader.</paragraph>
        </section>
        <section ids="your-first-canvasitem-shader" names="your\ first\ canvasitem\ shader 你的第一个\ canvasitem\ 着色器">
            <title>你的第一个 CanvasItem 着色器</title>
            <paragraph>在Godot中, 所有的着色器第一行都是指定着色器类型的, 格式如下:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;</literal_block>
            <paragraph>因为我们正在编写CanvasItem着色器, 所以我们在第一行中指定了 <literal>canvas_item</literal>. 我们所有的代码都会在这个声明下面.</paragraph>
            <paragraph>这一行告诉游戏引擎要提供你哪些内置变量以及函数.</paragraph>
            <paragraph>在Godot中, 你可以重写三个函数来控制着色器的运作, 它们是 <literal>vertex</literal> (顶点函数), <literal>fragment</literal> (片段函数)和 <literal>light</literal> (光照函数). 本教程会引导你写出一个包含顶点和片段函数的着色器. 因为光照函数比另外两个函数要复杂非常多, 所以在这里不会进行讲解.</paragraph>
        </section>
        <section ids="your-first-fragment-function" names="your\ first\ fragment\ function 你的第一个片段函数">
            <title>你的第一个片段函数</title>
            <paragraph>The fragment function runs for every pixel in a Sprite2D and determines what color
                that pixel should be.</paragraph>
            <paragraph>They are restricted to the pixels covered by the Sprite2D, that means you cannot
                use one to, for example, create an outline around a Sprite2D.</paragraph>
            <paragraph>最基础的片段函数仅仅给每个像素赋予一个颜色.</paragraph>
            <paragraph>We do so by writing a <literal>vec4</literal> to the built-in variable <literal>COLOR</literal>. <literal>vec4</literal> is
                shorthand for constructing a vector with 4 numbers. For more information about
                vectors see the <reference internal="True" refuri="../../math/vector_math#doc-vector-math"><inline classes="std std-ref">Vector math tutorial</inline></reference>. <literal>COLOR</literal> is both
                an input variable to the fragment function and the final output from it.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment(){
  COLOR = vec4(0.4, 0.6, 0.9, 1.0);
}</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/blue-box.png'}" uri="tutorials/shaders/your_first_shader/img/blue-box.png"></image>
            <paragraph>恭喜你！你成功在 Godot 中写出了你的第一个着色器。</paragraph>
            <paragraph>接着, 我们来讨论更复杂的事情.</paragraph>
            <paragraph>There are many inputs to the fragment function that you can use for calculating
                <literal>COLOR</literal>. <literal>UV</literal> is one of them. UV coordinates are specified in your Sprite2D
                (without you knowing it!) and they tell the shader where to read from textures
                for each part of the mesh.</paragraph>
            <paragraph>在片段函数中你只能从 <literal>UV</literal> 中读取, 但是你可以在其他函数中使用, 或者直接对 <literal>COLOR</literal> 赋值.</paragraph>
            <paragraph><literal>UV</literal> 取值在0-1之间, 从左到右, 由上到下.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/iconuv.png'}" uri="tutorials/shaders/your_first_shader/img/iconuv.png"></image>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  COLOR = vec4(UV, 0.5, 1.0);
}</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/UV.png'}" uri="tutorials/shaders/your_first_shader/img/UV.png"></image>
            <section ids="using-texture-built-in" names="using\ texture\ built-in 使用内置变量\ texture">
                <title>使用内置变量 <literal>TEXTURE</literal></title>
                <paragraph>默认的片段函数会读取 Sprite2D 设置的纹理并将其显示出来。</paragraph>
                <paragraph>When you want to adjust a color in a Sprite2D you can adjust the color
                    from the texture manually like in the code below.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment(){
  // This shader will result in a blue-tinted icon
  COLOR.b = 1.0;
}</literal_block>
                <paragraph>Certain nodes, like Sprite2Ds, have a dedicated texture variable that can be accessed
                    in the shader using <literal>TEXTURE</literal>. If you want to use the Sprite2D texture to combine
                    with other colors, you can use the <literal>UV</literal> with the <literal>texture</literal> function to access
                    this variable. Use them to redraw the Sprite2D with the texture.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment(){
  COLOR = texture(TEXTURE, UV); // Read from texture again.
  COLOR.b = 1.0; //set blue channel to 1.0
}</literal_block>
                <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/blue-tex.png'}" uri="tutorials/shaders/your_first_shader/img/blue-tex.png"></image>
            </section>
            <section ids="uniform-input" names="uniform\ input uniform\ 输入">
                <title>Uniform 输入</title>
                <paragraph>Uniform 输入是用来向着色器传递数据的，这些数据在整个着色器中都是一致的。</paragraph>
                <paragraph>你可以像这样通过在着色器顶部定义来使用 Uniform 值：</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform float size;</literal_block>
                <paragraph>用法的更多详情请参见<reference internal="True" refuri="../shader_reference/shading_language#doc-shading-language"><inline classes="std std-ref">着色语言文档</inline></reference>。</paragraph>
                <paragraph>Add a uniform to change the amount of blue in our Sprite2D.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform float blue = 1.0; // you can assign a default value to uniforms

void fragment(){
  COLOR = texture(TEXTURE, UV); // Read from texture
  COLOR.b = blue;
}</literal_block>
                <paragraph>Now you can change the amount of blue in the Sprite2D from the editor. Look back
                    at the Inspector under where you created your shader. You should see a section
                    called "Shader Param". Unfold that section and you will see the uniform you just
                    declared. If you change the value in the editor, it will overwrite the default
                    value you provided in the shader.</paragraph>
            </section>
            <section ids="interacting-with-shaders-from-code" names="interacting\ with\ shaders\ from\ code 代码与着色器的交互">
                <title>代码与着色器的交互</title>
                <paragraph>You can change uniforms from code using the function <literal>set_shader_parameter()</literal>
                    which is called on the node's material resource. With a Sprite2D node, the
                    following code can be used to set the <literal>blue</literal> uniform.</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var blue_value = 1.0
material.set_shader_parameter("blue", blue_value)</literal_block>
                <paragraph>注意,uniform值的名称是一个字符串. 字符串必须与它在着色器中的书写方式完全匹配, 包括拼写和大小写.</paragraph>
            </section>
        </section>
        <section ids="your-first-vertex-function" names="your\ first\ vertex\ function 你的第一个顶点函数">
            <title>你的第一个顶点函数</title>
            <paragraph>现在我们有了一个片段函数, 我们再写一个顶点函数.</paragraph>
            <paragraph>使用顶点函数计算屏幕上每个顶点的结束位置.</paragraph>
            <paragraph>顶点函数中最重要的变量是 <literal>VERTEX</literal>。它最初指定的是模型中的顶点坐标，但你也会通过往里面写值来决定把这些顶点画到哪里。<literal>VERTEX</literal> 是一个 <literal>vec2</literal>，最初使用的是局部空间（即与摄像机、视口、父节点无关）。</paragraph>
            <paragraph>你可以通过直接调整 <literal>VERTEX</literal> 来偏移顶点。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void vertex() {
  VERTEX += vec2(10.0, 0.0);
}</literal_block>
            <paragraph>Combined with the <literal>TIME</literal> built-in variable, this can be used for basic
                animation.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void vertex() {
  // Animate Sprite2D moving in big circle around its location
  VERTEX += vec2(cos(TIME)*100.0, sin(TIME)*100.0);
}</literal_block>
        </section>
        <section ids="conclusion" names="conclusion 总结">
            <title>总结</title>
            <paragraph>着色器的核心, 如你所见, 是计算 <literal>VERTEX</literal> 和 <literal>COLOR</literal>. 你可以制定更复杂的数学策略来给这些变量赋值.</paragraph>
            <paragraph>一些更高级的着色器教程可以给你启发, 如 <reference name="Shadertoy" refuri="https://www.shadertoy.com/results?query=&amp;sort=popular&amp;from=10&amp;num=4">Shadertoy</reference><target ids="shadertoy" names="shadertoy" refuri="https://www.shadertoy.com/results?query=&amp;sort=popular&amp;from=10&amp;num=4"></target> 和 <reference name="着色器之书" refuri="https://thebookofshaders.com/?lan=ch">着色器之书</reference><target ids="id1" names="着色器之书" refuri="https://thebookofshaders.com/?lan=ch"></target> .</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
