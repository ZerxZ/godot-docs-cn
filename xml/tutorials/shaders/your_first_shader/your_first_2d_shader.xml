<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/your_first_shader/your_first_2d_shader.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-your-first-canvasitem-shader"></target>
    <section ids="your-first-2d-shader doc-your-first-canvasitem-shader" names="your\ first\ 2d\ shader doc_your_first_canvasitem_shader">
        <title>Your first 2D shader</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>Shaders are special programs that execute on the GPU and are used for rendering
                graphics. All modern rendering is done with shaders. For a more detailed
                description of what shaders are please see <reference internal="True" refuri="../introduction_to_shaders#doc-introduction-to-shaders"><inline classes="std std-ref">What are shaders</inline></reference>.</paragraph>
            <paragraph>This tutorial will focus on the practical aspects of writing shader programs by
                walking you through the process of writing a shader with both vertex and
                fragment functions. This tutorial targets absolute beginners to shaders.</paragraph>
            <note>
                <paragraph>If you have experience writing shaders and are just looking for an
                    overview of how shaders work in Godot, see the <reference internal="True" refuri="../shader_reference/index#toc-shading-reference"><inline classes="std std-ref">Shading Reference</inline></reference>.</paragraph>
            </note>
        </section>
        <section ids="setup" names="setup">
            <title>Setup</title>
            <paragraph><reference internal="True" refuri="../shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">CanvasItem shaders</inline></reference> are used to draw all 2D
                objects in Godot, while <reference internal="True" refuri="../shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">Spatial</inline></reference> shaders are used
                to draw all 3D objects.</paragraph>
            <paragraph>In order to use a shader it must be attached inside a <reference internal="True" refuri="../../../classes/class_material#class-material"><inline classes="std std-ref">Material</inline></reference> which must be attached to an object. Materials are a type of
                <reference internal="True" refuri="../../scripting/resources#doc-resources"><inline classes="std std-ref">Resource</inline></reference>. To draw multiple objects with the same
                material, the material must be attached to each object.</paragraph>
            <paragraph>All objects derived from a <reference internal="True" refuri="../../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference> have a material
                property. This includes all <reference internal="True" refuri="../../../classes/class_control#class-control"><inline classes="std std-ref">GUI elements</inline></reference>, <reference internal="True" refuri="../../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite2Ds</inline></reference>, <reference internal="True" refuri="../../../classes/class_tilemaplayer#class-tilemaplayer"><inline classes="std std-ref">TileMapLayers</inline></reference>, <reference internal="True" refuri="../../../classes/class_meshinstance2d#class-meshinstance2d"><inline classes="std std-ref">MeshInstance2Ds</inline></reference> etc. They also have an option to inherit their parent's
                material. This can be useful if you have a large number of nodes that you want
                to use the same material.</paragraph>
            <paragraph>To begin, create a Sprite2D node. <reference internal="True" refuri="../../2d/custom_drawing_in_2d#doc-custom-drawing-in-2d"><inline classes="std std-ref">You can use any CanvasItem</inline></reference>,
                so long as it is drawing to the canvas, so for this tutorial we will use a Sprite2D,
                as it is the easiest CanvasItem to start drawing with.</paragraph>
            <paragraph>In the Inspector, click beside "Texture" where it says "[empty]" and select
                "Load", then select "icon.svg". For new projects, this is the Godot icon. You
                should now see the icon in the viewport.</paragraph>
            <paragraph>Next, look down in the Inspector, under the CanvasItem section, click beside
                "Material" and select "New ShaderMaterial". This creates a new Material
                resource. Click on the sphere that appears. Godot currently doesn't know whether
                you are writing a CanvasItem Shader or a Spatial Shader and it previews the
                output of spatial shaders. So what you are seeing is the output of the default
                Spatial Shader.</paragraph>
            <note>
                <paragraph>Materials that inherit from the <reference internal="True" refuri="../../../classes/class_material#class-material"><inline classes="std std-ref">Material</inline></reference> resource, such as <reference internal="True" refuri="../../../classes/class_standardmaterial3d#class-standardmaterial3d"><inline classes="std std-ref">StandardMaterial3D</inline></reference>
                    and <reference internal="True" refuri="../../../classes/class_particleprocessmaterial#class-particleprocessmaterial"><inline classes="std std-ref">ParticleProcessMaterial</inline></reference>, can be converted to a <reference internal="True" refuri="../../../classes/class_shadermaterial#class-shadermaterial"><inline classes="std std-ref">ShaderMaterial</inline></reference>
                    and their existing properties will be converted to an accompanying text shader.
                    To do so, right-click on the material in the FileSystem dock and choose
                    <strong>Convert to ShaderMaterial</strong>. You can also do so by right-clicking on any
                    property holding a reference to the material in the inspector.</paragraph>
            </note>
            <paragraph>Click beside "Shader" and select "New Shader". Finally, click on the shader
                you just created and the shader editor will open. You are now ready to begin writing
                your first shader.</paragraph>
        </section>
        <section ids="your-first-canvasitem-shader" names="your\ first\ canvasitem\ shader">
            <title>Your first CanvasItem shader</title>
            <paragraph>In Godot, all shaders start with a line specifying what type of shader they are.
                It uses the following format:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;</literal_block>
            <paragraph>Because we are writing a CanvasItem shader, we specify <literal>canvas_item</literal> in the
                first line. All our code will go beneath this declaration.</paragraph>
            <paragraph>This line tells the engine which built-in variables and functionality to supply
                you with.</paragraph>
            <paragraph>In Godot you can override three functions to control how the shader operates;
                <literal>vertex</literal>, <literal>fragment</literal>, and <literal>light</literal>. This tutorial will walk you through
                writing a shader with both vertex and fragment functions. Light functions are
                significantly more complex than vertex and fragment functions and so will not be
                covered here.</paragraph>
        </section>
        <section ids="your-first-fragment-function" names="your\ first\ fragment\ function">
            <title>Your first fragment function</title>
            <paragraph>The fragment function runs for every pixel in a Sprite2D and determines what color
                that pixel should be.</paragraph>
            <paragraph>They are restricted to the pixels covered by the Sprite2D, that means you cannot
                use one to, for example, create an outline around a Sprite2D.</paragraph>
            <paragraph>The most basic fragment function does nothing except assign a single color to
                every pixel.</paragraph>
            <paragraph>We do so by writing a <literal>vec4</literal> to the built-in variable <literal>COLOR</literal>. <literal>vec4</literal> is
                shorthand for constructing a vector with 4 numbers. For more information about
                vectors see the <reference internal="True" refuri="../../math/vector_math#doc-vector-math"><inline classes="std std-ref">Vector math tutorial</inline></reference>. <literal>COLOR</literal> is both
                an input variable to the fragment function and the final output from it.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment(){
  COLOR = vec4(0.4, 0.6, 0.9, 1.0);
}</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/blue-box.png'}" original_uri="img/blue-box.png" uri="tutorials/shaders/your_first_shader/img/blue-box.png"></image>
            <paragraph>Congratulations! You're done. You have successfully written your first shader in
                Godot.</paragraph>
            <paragraph>Now let's make things more complex.</paragraph>
            <paragraph>There are many inputs to the fragment function that you can use for calculating
                <literal>COLOR</literal>. <literal>UV</literal> is one of them. UV coordinates are specified in your Sprite2D
                (without you knowing it!) and they tell the shader where to read from textures
                for each part of the mesh.</paragraph>
            <paragraph>In the fragment function you can only read from <literal>UV</literal>, but you can use it in
                other functions or to assign values to <literal>COLOR</literal> directly.</paragraph>
            <paragraph><literal>UV</literal> varies between 0-1 from left-right and from top-bottom.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/iconuv.png'}" original_uri="img/iconuv.png" uri="tutorials/shaders/your_first_shader/img/iconuv.png"></image>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  COLOR = vec4(UV, 0.5, 1.0);
}</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/UV.png'}" original_uri="img/UV.png" uri="tutorials/shaders/your_first_shader/img/UV.png"></image>
            <section ids="using-texture-built-in" names="using\ texture\ built-in">
                <title>Using <literal>TEXTURE</literal> built-in</title>
                <paragraph>The default fragment function reads from the set Sprite2D texture and displays it.</paragraph>
                <paragraph>When you want to adjust a color in a Sprite2D you can adjust the color
                    from the texture manually like in the code below.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment(){
  // This shader will result in a blue-tinted icon
  COLOR.b = 1.0;
}</literal_block>
                <paragraph>Certain nodes, like Sprite2Ds, have a dedicated texture variable that can be accessed
                    in the shader using <literal>TEXTURE</literal>. If you want to use the Sprite2D texture to combine
                    with other colors, you can use the <literal>UV</literal> with the <literal>texture</literal> function to access
                    this variable. Use them to redraw the Sprite2D with the texture.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment(){
  COLOR = texture(TEXTURE, UV); // Read from texture again.
  COLOR.b = 1.0; //set blue channel to 1.0
}</literal_block>
                <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/blue-tex.png'}" original_uri="img/blue-tex.png" uri="tutorials/shaders/your_first_shader/img/blue-tex.png"></image>
            </section>
            <section ids="uniform-input" names="uniform\ input">
                <title>Uniform input</title>
                <paragraph>Uniform input is used to pass data into a shader that will be the same across
                    the entire shader.</paragraph>
                <paragraph>You can use uniforms by defining them at the top of your shader like so:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform float size;</literal_block>
                <paragraph>For more information about usage see the <reference internal="True" refuri="../shader_reference/shading_language#doc-shading-language"><inline classes="std std-ref">Shading Language doc</inline></reference>.</paragraph>
                <paragraph>Add a uniform to change the amount of blue in our Sprite2D.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform float blue = 1.0; // you can assign a default value to uniforms

void fragment(){
  COLOR = texture(TEXTURE, UV); // Read from texture
  COLOR.b = blue;
}</literal_block>
                <paragraph>Now you can change the amount of blue in the Sprite2D from the editor. Look back
                    at the Inspector under where you created your shader. You should see a section
                    called "Shader Param". Unfold that section and you will see the uniform you just
                    declared. If you change the value in the editor, it will overwrite the default
                    value you provided in the shader.</paragraph>
            </section>
            <section ids="interacting-with-shaders-from-code" names="interacting\ with\ shaders\ from\ code">
                <title>Interacting with shaders from code</title>
                <paragraph>You can change uniforms from code using the function <literal>set_shader_parameter()</literal>
                    which is called on the node's material resource. With a Sprite2D node, the
                    following code can be used to set the <literal>blue</literal> uniform.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var blue_value = 1.0
material.set_shader_parameter("blue", blue_value)</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var blueValue = 1.0;
((ShaderMaterial)Material).SetShaderParameter("blue", blueValue);</literal_block>
                    </div>
                </container>
                <paragraph>Note that the name of the uniform is a string. The string must match exactly
                    with how it is written in the shader, including spelling and case.</paragraph>
            </section>
        </section>
        <section ids="your-first-vertex-function" names="your\ first\ vertex\ function">
            <title>Your first vertex function</title>
            <paragraph>Now that we have a fragment function, let's write a vertex function.</paragraph>
            <paragraph>Use the vertex function to calculate where on the screen each vertex should end
                up.</paragraph>
            <paragraph>The most important variable in the vertex function is <literal>VERTEX</literal>. Initially, it
                specifies the vertex coordinates in your model, but you also write to it to
                determine where to actually draw those vertices. <literal>VERTEX</literal> is a <literal>vec2</literal> that
                is initially presented in local-space (i.e. not relative to the camera,
                viewport, or parent nodes).</paragraph>
            <paragraph>You can offset the vertices by directly adding to <literal>VERTEX</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void vertex() {
  VERTEX += vec2(10.0, 0.0);
}</literal_block>
            <paragraph>Combined with the <literal>TIME</literal> built-in variable, this can be used for basic
                animation.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void vertex() {
  // Animate Sprite2D moving in big circle around its location
  VERTEX += vec2(cos(TIME)*100.0, sin(TIME)*100.0);
}</literal_block>
        </section>
        <section ids="conclusion" names="conclusion">
            <title>Conclusion</title>
            <paragraph>At their core, shaders do what you have seen so far, they compute <literal>VERTEX</literal> and
                <literal>COLOR</literal>. It is up to you to dream up more complex mathematical strategies for
                assigning values to those variables.</paragraph>
            <paragraph>For inspiration, take a look at some of the more advanced shader tutorials, and
                look at other sites like <reference name="Shadertoy" refuri="https://www.shadertoy.com/results?query=&amp;sort=popular&amp;from=10&amp;num=4">Shadertoy</reference><target ids="shadertoy" names="shadertoy" refuri="https://www.shadertoy.com/results?query=&amp;sort=popular&amp;from=10&amp;num=4"></target> and <reference name="The Book of Shaders" refuri="https://thebookofshaders.com">The
                    Book of Shaders</reference><target ids="the-book-of-shaders" names="the\ book\ of\ shaders" refuri="https://thebookofshaders.com"></target>.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
