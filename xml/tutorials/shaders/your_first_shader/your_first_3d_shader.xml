<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/your_first_shader/your_first_3d_shader.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-your-first-spatial-shader"></target>
    <section ids="your-first-3d-shader doc-your-first-spatial-shader" names="your\ first\ 3d\ shader 你的第一个\ 3d\ 着色器 doc_your_first_spatial_shader">
        <title>你的第一个 3D 着色器</title>
        <paragraph>You have decided to start writing your own custom Spatial shader. Maybe you saw
            a cool trick online that was done with shaders, or you have found that the
            <reference internal="True" refuri="../../../classes/class_standardmaterial3d#class-standardmaterial3d"><inline classes="std std-ref">StandardMaterial3D</inline></reference> isn't quite meeting your
            needs. Either way, you have decided to write your own and now you need to figure
            out where to start.</paragraph>
        <paragraph>这个教程将说明如何编写空间着色器, 并将涵盖比 <reference internal="True" refuri="your_first_2d_shader#doc-your-first-canvasitem-shader"><inline classes="std std-ref">CanvasItem</inline></reference> 更多的主题.</paragraph>
        <paragraph>空间着色器比CanvasItem着色器有更多的内置功能. 对空间着色器的期望是:Godot为常见的用例提供了功能, 用户仅需在着色器中设置适当的参数. 这对于PBR(基于物理的渲染)工作流来说尤其如此.</paragraph>
        <paragraph>This is a two-part tutorial. In this first part we will create terrain using
            vertex displacement from a heightmap in the
            vertex function. In the <reference internal="True" refuri="your_second_3d_shader#doc-your-second-spatial-shader"><inline classes="std std-ref">second part</inline></reference> we
            will take the concepts from this tutorial and set up
            custom materials in a fragment shader by writing an ocean water shader.</paragraph>
        <note>
            <paragraph>这个教程假定你对着色器有一些基本的了解, 例如类型( <literal>vec2</literal> , <literal>float</literal> , <literal>sampler2D</literal> ), 和函数. 如果你对这些概念摸不着头脑, 那么你在完成这个教程之前, 最好先从 <title_reference>着色器之书 &lt;https://thebookofshaders.com/?lan=ch&gt;</title_reference> 获取一些基本知识.</paragraph>
        </note>
        <section ids="where-to-assign-my-material" names="where\ to\ assign\ my\ material 在何处设定材质">
            <title>在何处设定材质</title>
            <paragraph>在3D中, 对象是使用 <reference internal="True" refuri="../../../classes/class_mesh#class-mesh"><inline classes="std std-ref">Meshes</inline></reference> 绘制的.Mesh是一种资源类型, 它以 "表面(surface)" 为单位存储几何体(对象的形状)和材质(对象的颜色和对光线的反应). 一个Mesh可以有多个表面, 也可以只有一个. 通常情况下, 你会从另一个程序(如Blender)导入一个Mesh. 但是Godot也有一些 <reference internal="True" refuri="../../../classes/class_primitivemesh#class-primitivemesh"><inline classes="std std-ref">PrimitiveMeshes</inline></reference> 允许你在不导入Mesh的情况下为场景添加基本几何体.</paragraph>
            <paragraph>There are multiple node types that you can use to draw a mesh. The main one is
                <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference>, but you can also use <reference internal="True" refuri="../../../classes/class_gpuparticles3d#class-gpuparticles3d"><inline classes="std std-ref">GPUParticles3D</inline></reference>, <reference internal="True" refuri="../../../classes/class_multimesh#class-multimesh"><inline classes="std std-ref">MultiMeshes</inline></reference> (with a
                <reference internal="True" refuri="../../../classes/class_multimeshinstance3d#class-multimeshinstance3d"><inline classes="std std-ref">MultiMeshInstance3D</inline></reference>), or others.</paragraph>
            <paragraph>Typically, a material is associated with a given surface in a mesh, but some
                nodes, like MeshInstance3D, allow you to override the material for a specific
                surface, or for all surfaces.</paragraph>
            <paragraph>如果你在表面或网格本身上设置了材质，那么所有共享该网格的 MeshInstance3D 都共享该材质。但是如果你想在多个网格实例中重用同一个网格，而每个实例又要具有不同的材质，那么你就应该在 MeshInstance3D 上设置材质。</paragraph>
            <paragraph>For this tutorial we will set our material on the mesh itself rather than taking
                advantage of the MeshInstance3D's ability to override materials.</paragraph>
        </section>
        <section ids="setting-up" names="setting\ up 设置">
            <title>设置</title>
            <paragraph>向场景添加一个新的 <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> 节点。</paragraph>
            <paragraph>在检查器选项卡中，点击“Mesh”旁边的“[空]”，然后选择“新建 PlaneMesh”。然后点击出现的平面的图像。</paragraph>
            <paragraph>这会在场景中添加一个 <reference internal="True" refuri="../../../classes/class_planemesh#class-planemesh"><inline classes="std std-ref">PlaneMesh</inline></reference> .</paragraph>
            <paragraph>然后，在视图中，单击左上角的“透视”按钮。会出现一个菜单，在菜单中间找到如何显示场景的选项。选择“显示线框”。</paragraph>
            <paragraph>这将允许你查看构成平面的三角形.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/plane.png'}" uri="tutorials/shaders/your_first_shader/img/plane.png"></image>
            <paragraph>现在将 <reference internal="True" refuri="../../../classes/class_planemesh#class-planemesh"><inline classes="std std-ref">PlaneMesh</inline></reference> 的 <literal>Subdivide Width</literal> 和 <literal>Subdivide Depth</literal> 设置为 <literal>32</literal>。</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/plane-sub-set.webp'}" uri="tutorials/shaders/your_first_shader/img/plane-sub-set.webp"></image>
            <paragraph>You can see that there are now many more triangles in the
                <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference>. This will give us more vertices to work with
                and thus allow us to add more detail.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/plane-sub.png'}" uri="tutorials/shaders/your_first_shader/img/plane-sub.png"></image>
            <paragraph><reference internal="True" refuri="../../../classes/class_primitivemesh#class-primitivemesh"><inline classes="std std-ref">PrimitiveMeshes</inline></reference>, like PlaneMesh, only have one
                surface, so instead of an array of materials there is only one. Click
                beside "Material" where it says "[empty]" and select "New ShaderMaterial".
                Then click the sphere that appears.</paragraph>
            <paragraph>现在点击“Shader”旁边写着“[空]”的地方，选择“新建 Shader”。</paragraph>
            <paragraph>现在将弹出一个着色器编辑器, 你已经准备好编写你的第一个空间着色器了！</paragraph>
        </section>
        <section ids="shader-magic" names="shader\ magic 着色器魔术">
            <title>着色器魔术</title>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/shader-editor.webp'}" uri="tutorials/shaders/your_first_shader/img/shader-editor.webp"></image>
            <paragraph>The new shader is already generated with a <literal>shader_type</literal>
                variable and the <literal>fragment()</literal> function.
                The first thing Godot shaders need is a declaration
                of what type of shader they are.
                In this case the <literal>shader_type</literal> is set to <literal>spatial</literal>
                because this is a spatial shader.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;</literal_block>
            <paragraph>For now ignore the <literal>fragment()</literal> function
                and define the <literal>vertex()</literal> function. The <literal>vertex()</literal> function
                determines where the vertices of your <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> appear in
                the final scene. We will be using it to offset the height of each vertex and
                make our flat plane appear like a little terrain.</paragraph>
            <paragraph>我们像这样定义顶点着色器:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void vertex() {

}</literal_block>
            <paragraph>在 <literal>vertex()</literal> 函数中没有任何内容,Godot将使用其默认的顶点着色器. 我们可以简单地通过添加一行进行更改:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void vertex() {
  VERTEX.y += cos(VERTEX.x) * sin(VERTEX.z);
}</literal_block>
            <paragraph>添加此行后, 你应该会得到类似下方的图像.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/cos.png'}" uri="tutorials/shaders/your_first_shader/img/cos.png"></image>
            <paragraph>好, 我们来解读一下. <literal>VERTEX</literal> 的 <literal>y</literal> 值正在增加. 我们将 <literal>VERTEX</literal> 的 <literal>x</literal> 和 <literal>z</literal> 分量作为参数传递给 <literal>cos</literal> 和 <literal>sin</literal> ；这样就得到了在 <literal>x</literal> 和 <literal>z</literal> 轴上呈现出波浪状的图像.</paragraph>
            <paragraph>我们想要实现的是小山丘的外观. 而 <literal>cos</literal> 和 <literal>sin</literal> 已经有点像山丘了. 我们便可以通过缩放 <literal>cos</literal> 和 <literal>sin</literal> 函数的输入来实现.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void vertex() {
  VERTEX.y += cos(VERTEX.x * 4.0) * sin(VERTEX.z * 4.0);
}</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/cos4.png'}" uri="tutorials/shaders/your_first_shader/img/cos4.png"></image>
            <paragraph>看起来效果好了一些, 但它仍然过于尖锐和重复, 让我们把它变得更有趣一点.</paragraph>
        </section>
        <section ids="noise-heightmap" names="noise\ heightmap 噪声高度图">
            <title>噪声高度图</title>
            <paragraph>噪声是一种非常流行的伪造地形的工具. 可以认为它和余弦函数一样生成重复的小山, 只是在噪声的影响下每个小山都拥有不同的高度.</paragraph>
            <paragraph>Godot provides the <reference internal="True" refuri="../../../classes/class_noisetexture2d#class-noisetexture2d"><inline classes="std std-ref">NoiseTexture2D</inline></reference> resource for
                generating a noise texture that can be accessed from a shader.</paragraph>
            <paragraph>要在着色器中访问纹理，请在着色器顶部附近、<literal>vertex()</literal> 函数外部添加以下代码。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform sampler2D noise;</literal_block>
            <paragraph>你可以用它将噪声纹理发送给着色器。现在看看检查器中的材质。你应该会看到一个名为“Shader Params”（着色器参数）的区域。如果展开该区域，就会看到一个叫“noise”的部分。</paragraph>
            <paragraph>Click beside it where it says "[empty]" and select "New NoiseTexture2D". Then in
                your <reference internal="True" refuri="../../../classes/class_noisetexture2d#class-noisetexture2d"><inline classes="std std-ref">NoiseTexture2D</inline></reference> click beside where it says "Noise" and select "New
                FastNoiseLite".</paragraph>
            <note>
                <paragraph>NoiseTexture2D 使用 <reference internal="True" refuri="../../../classes/class_fastnoiselite#class-fastnoiselite"><inline classes="std std-ref">FastNoiseLite</inline></reference> 来生成高度图。</paragraph>
            </note>
            <paragraph>设置好后, 看起来应该像这样.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/noise-set.webp'}" uri="tutorials/shaders/your_first_shader/img/noise-set.webp"></image>
            <paragraph>Now, access the noise texture using the <literal>texture()</literal> function. <literal>texture()</literal>
                takes a texture as the first argument and a <literal>vec2</literal> for the position on the
                texture as the second argument. We use the <literal>x</literal> and <literal>z</literal> channels of
                <literal>VERTEX</literal> to determine where on the texture to look up. Note that the PlaneMesh
                coordinates are within the [-1,1] range (for a size of 2), while the texture
                coordinates are within [0,1], so to normalize we divide by the size of the
                PlaneMesh by 2.0 and add 0.5. <literal>texture()</literal> returns a <literal>vec4</literal> of the <literal>r, g, b,
a</literal> channels at the position. Since the noise texture is grayscale, all of the
                values are the same, so we can use any one of the channels as the height. In
                this case we'll use the <literal>r</literal>, or <literal>x</literal> channel.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void vertex() {
  float height = texture(noise, VERTEX.xz / 2.0 + 0.5).x;
  VERTEX.y += height;
}</literal_block>
            <paragraph>注意: <literal>xyzw</literal> 和GLSL中的 <literal>rgba</literal> 是相同的, 所以我们可以用 <literal>texture().x</literal> 代替上面的 <literal>texture().r</literal> . 详情请参见 <reference name="OpenGL 文档" refuri="https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Vectors">OpenGL 文档</reference><target ids="opengl" names="opengl\ 文档" refuri="https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Vectors"></target> .</paragraph>
            <paragraph>使用此代码后, 你可以看到纹理创建了随机外观的山峰.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/noise.png'}" uri="tutorials/shaders/your_first_shader/img/noise.png"></image>
            <paragraph>目前它还很尖锐, 我们需要稍微柔化一下山峰. 这将用到uniform值. 你在之前已经使用了uniform 值来传递噪声纹理, 现在让我们来学习一下其中的工作原理.</paragraph>
        </section>
        <section ids="uniforms" names="uniforms uniform">
            <title>Uniform</title>
            <paragraph>uniform值变量允许你把游戏的变量传递到着色器. 它们对于控制着色器效果非常有用. 几乎所有在着色器中使用的数据类型都可以作为uniform值. 要使用uniform值, 请在 <reference internal="True" refuri="../../../classes/class_shader#class-shader"><inline classes="std std-ref">Shader</inline></reference> 中使用关键字 <literal>uniform</literal> 声明它.</paragraph>
            <paragraph>让我们做一个改变地形高度的uniform.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform float height_scale = 0.5;</literal_block>
            <paragraph>Godot lets you initialize a uniform with a value; here, <literal>height_scale</literal> is set
                to <literal>0.5</literal>. You can set uniforms from GDScript by calling the function
                <literal>set_shader_parameter()</literal> on the material corresponding to the shader. The value
                passed from GDScript takes precedence over the value used to initialize it in
                the shader.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># called from the MeshInstance3D
mesh.material.set_shader_parameter("height_scale", 0.5)</literal_block>
            <note>
                <paragraph>Changing uniforms in Spatial-based nodes is different from
                    CanvasItem-based nodes. Here, we set the material inside the PlaneMesh
                    resource. In other mesh resources you may need to first access the
                    material by calling <literal>surface_get_material()</literal>. While in the
                    MeshInstance3D you would access the material using
                    <literal>get_surface_material()</literal> or <literal>material_override</literal>.</paragraph>
            </note>
            <paragraph>Remember that the string passed into <literal>set_shader_parameter()</literal> must match the name
                of the uniform variable in the <reference internal="True" refuri="../../../classes/class_shader#class-shader"><inline classes="std std-ref">Shader</inline></reference>. You can use the
                uniform variable anywhere inside your <reference internal="True" refuri="../../../classes/class_shader#class-shader"><inline classes="std std-ref">Shader</inline></reference>. Here, we will
                use it to set the height value instead of arbitrarily multiplying by <literal>0.5</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">VERTEX.y += height * height_scale;</literal_block>
            <paragraph>现在它看起来好多了.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/noise-low.png'}" uri="tutorials/shaders/your_first_shader/img/noise-low.png"></image>
            <paragraph>Using uniforms, we can even change the value every frame to animate the height
                of the terrain. Combined with <reference internal="True" refuri="../../../classes/class_tween#class-tween"><inline classes="std std-ref">Tweens</inline></reference>, this can be
                especially useful for animations.</paragraph>
        </section>
        <section ids="interacting-with-light" names="interacting\ with\ light 与光交互">
            <title>与光交互</title>
            <paragraph>首先关闭线框显示。再次点击视口左上角的“透视”字样，选择“显示标准”。</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/normal.png'}" uri="tutorials/shaders/your_first_shader/img/normal.png"></image>
            <paragraph>注意网格颜色是如何变得平滑的. 这是因为它的光线是平滑的. 让我们加一盏灯吧!</paragraph>
            <paragraph>First, we will add an <reference internal="True" refuri="../../../classes/class_omnilight3d#class-omnilight3d"><inline classes="std std-ref">OmniLight3D</inline></reference> to the scene.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/light.png'}" uri="tutorials/shaders/your_first_shader/img/light.png"></image>
            <paragraph>你会看到光线影响了地形, 但这看起来很奇怪. 问题是光线对地形的影响就像在平面上一样. 这是因为光着色器使用 <reference internal="True" refuri="../../../classes/class_mesh#class-mesh"><inline classes="std std-ref">网格</inline></reference> 中的法线来计算光.</paragraph>
            <paragraph>法线存储在网格中, 但是我们在着色器中改变网格的形状, 所以法线不再正确. 为了解决这个问题, 我们可以在着色器中重新计算法线, 或者使用与我们的噪声相对应的法线纹理.Godot让这一切变得很简单.</paragraph>
            <paragraph>你可以在顶点函数中手动计算新的法线，然后只需设置法线 <literal>NORMAL</literal>。设置好 <literal>NORMAL</literal> 后，Godot 将为我们完成所有困难的光照计算。我们将在本教程的下一部分介绍这种方法，现在我们将从纹理中读取法线。</paragraph>
            <paragraph>相反, 我们将再次依靠噪声来计算法线. 我们通过传入第二个噪声纹理来做到这一点.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform sampler2D normalmap;</literal_block>
            <paragraph>Set this second uniform texture to another <reference internal="True" refuri="../../../classes/class_noisetexture2d#class-noisetexture2d"><inline classes="std std-ref">NoiseTexture2D</inline></reference> with another
                <reference internal="True" refuri="../../../classes/class_fastnoiselite#class-fastnoiselite"><inline classes="std std-ref">FastNoiseLite</inline></reference>. But this time, check <strong>As Normalmap</strong>.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/normal-set.webp'}" uri="tutorials/shaders/your_first_shader/img/normal-set.webp"></image>
            <paragraph>现在, 因为这是一个法线贴图, 而不是每个顶点的法线, 我们将在 <literal>fragment()</literal> 函数中分配它. <literal>fragment()</literal> 函数将在本教程的下一部分中详细解释.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
}</literal_block>
            <paragraph>When we have normals that correspond to a specific vertex we set <literal>NORMAL</literal>, but
                if you have a normalmap that comes from a texture, set the normal using
                <literal>NORMAL_MAP</literal>. This way Godot will handle the wrapping of texture around the
                mesh automatically.</paragraph>
            <paragraph>最后, 为了确保我们从噪声纹理和法线图纹理的相同位置读取数据, 我们将把 <literal>vertex()</literal> 函数中的 <literal>VERTEX.xz</literal> 坐标传递给 <literal>fragment()</literal> 函数. 我们用variings来做这个.</paragraph>
            <paragraph>在 <literal>vertex()</literal> 上面定义一个 <literal>vec2</literal> 叫做 <literal>tex_position</literal> . 在 <literal>vertex()</literal> 函数中, 将 <literal>VERTEX.xz</literal> 分配给 <literal>tex_position</literal> .</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">varying vec2 tex_position;

void vertex() {
  ...
  tex_position = VERTEX.xz / 2.0 + 0.5;
  float height = texture(noise, tex_position).x;
  ...
}</literal_block>
            <paragraph>现在我们可以从 <literal>fragment()</literal> 函数中访问 <literal>tex_position</literal> .</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  NORMAL_MAP = texture(normalmap, tex_position).xyz;
}</literal_block>
            <paragraph>法线就位后, 光线就会对网格的高度做出动态反应.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/normalmap.png'}" uri="tutorials/shaders/your_first_shader/img/normalmap.png"></image>
            <paragraph>我们甚至可以把灯拖来拖去, 灯光会自动更新.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/normalmap2.png'}" uri="tutorials/shaders/your_first_shader/img/normalmap2.png"></image>
            <paragraph>以下是本教程的完整代码. 你可以看到,Godot会为你处理大多数繁琐的事情, 本教程篇幅不会太长.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

uniform float height_scale = 0.5;
uniform sampler2D noise;
uniform sampler2D normalmap;

varying vec2 tex_position;

void vertex() {
  tex_position = VERTEX.xz / 2.0 + 0.5;
  float height = texture(noise, tex_position).x;
  VERTEX.y += height * height_scale;
}

void fragment() {
  NORMAL_MAP = texture(normalmap, tex_position).xyz;
}</literal_block>
            <paragraph>这就是这部分的全部内容. 希望你现在已了解Godot中顶点着色器的基本知识. 在本教程的下一部分中, 我们将编写一个片段函数来配合这个顶点函数, 并且我们将介绍一种更高级的技术来将这个地形转换成一个移动的波浪海洋.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
