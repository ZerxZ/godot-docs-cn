<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/your_first_shader/your_first_3d_shader.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-your-first-spatial-shader"></target>
    <section ids="your-first-3d-shader doc-your-first-spatial-shader" names="your\ first\ 3d\ shader doc_your_first_spatial_shader">
        <title>Your first 3D shader</title>
        <paragraph>You have decided to start writing your own custom Spatial shader. Maybe you saw
            a cool trick online that was done with shaders, or you have found that the
            <reference internal="True" refuri="../../../classes/class_standardmaterial3d#class-standardmaterial3d"><inline classes="std std-ref">StandardMaterial3D</inline></reference> isn't quite meeting your
            needs. Either way, you have decided to write your own and now you need to figure
            out where to start.</paragraph>
        <paragraph>This tutorial will explain how to write a Spatial shader and will cover more
            topics than the <reference internal="True" refuri="your_first_2d_shader#doc-your-first-canvasitem-shader"><inline classes="std std-ref">CanvasItem</inline></reference> tutorial.</paragraph>
        <paragraph>Spatial shaders have more built-in functionality than CanvasItem shaders. The
            expectation with spatial shaders is that Godot has already provided the
            functionality for common use cases and all the user needs to do in the shader is
            set the proper parameters. This is especially true for a PBR (physically based
            rendering) workflow.</paragraph>
        <paragraph>This is a two-part tutorial. In this first part we will create terrain using
            vertex displacement from a heightmap in the
            vertex function. In the <reference internal="True" refuri="your_second_3d_shader#doc-your-second-spatial-shader"><inline classes="std std-ref">second part</inline></reference> we
            will take the concepts from this tutorial and set up
            custom materials in a fragment shader by writing an ocean water shader.</paragraph>
        <note>
            <paragraph>This tutorial assumes some basic shader knowledge such as types
                (<literal>vec2</literal>, <literal>float</literal>, <literal>sampler2D</literal>), and functions. If you are
                uncomfortable with these concepts it is best to get a gentle
                introduction from <reference name="The Book of Shaders" refuri="https://thebookofshaders.com">The Book of Shaders</reference><target ids="the-book-of-shaders" names="the\ book\ of\ shaders" refuri="https://thebookofshaders.com"></target> before completing this tutorial.</paragraph>
        </note>
        <section ids="where-to-assign-my-material" names="where\ to\ assign\ my\ material">
            <title>Where to assign my material</title>
            <paragraph>In 3D, objects are drawn using <reference internal="True" refuri="../../../classes/class_mesh#class-mesh"><inline classes="std std-ref">Meshes</inline></reference>. Meshes are a resource
                type that store geometry (the shape of your object) and materials (the color and
                how the object reacts to light) in units called "surfaces". A Mesh can have
                multiple surfaces, or just one. Typically, you would import a mesh from another
                program (e.g. Blender). But Godot also has a few <reference internal="True" refuri="../../../classes/class_primitivemesh#class-primitivemesh"><inline classes="std std-ref">PrimitiveMeshes</inline></reference> that allow you to add basic geometry to a scene without
                importing Meshes.</paragraph>
            <paragraph>There are multiple node types that you can use to draw a mesh. The main one is
                <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference>, but you can also use <reference internal="True" refuri="../../../classes/class_gpuparticles3d#class-gpuparticles3d"><inline classes="std std-ref">GPUParticles3D</inline></reference>, <reference internal="True" refuri="../../../classes/class_multimesh#class-multimesh"><inline classes="std std-ref">MultiMeshes</inline></reference> (with a
                <reference internal="True" refuri="../../../classes/class_multimeshinstance3d#class-multimeshinstance3d"><inline classes="std std-ref">MultiMeshInstance3D</inline></reference>), or others.</paragraph>
            <paragraph>Typically, a material is associated with a given surface in a mesh, but some
                nodes, like MeshInstance3D, allow you to override the material for a specific
                surface, or for all surfaces.</paragraph>
            <paragraph>If you set a material on the surface or mesh itself, then all MeshInstance3Ds that
                share that mesh will share that material. However, if you want to reuse the same
                mesh across multiple mesh instances, but have different materials for each
                instance then you should set the material on the MeshInstance3D.</paragraph>
            <paragraph>For this tutorial we will set our material on the mesh itself rather than taking
                advantage of the MeshInstance3D's ability to override materials.</paragraph>
        </section>
        <section ids="setting-up" names="setting\ up">
            <title>Setting up</title>
            <paragraph>Add a new <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> node to your scene.</paragraph>
            <paragraph>In the inspector tab, set the MeshInstance3D's <strong>Mesh</strong> property to a new
                <reference internal="True" refuri="../../../classes/class_planemesh#class-planemesh"><inline classes="std std-ref">PlaneMesh</inline></reference> resource, by clicking on <literal>&lt;empty&gt;</literal> and
                choosing <strong>New PlaneMesh</strong>. Then expand the resource by clicking on the image of
                a plane that appears.</paragraph>
            <paragraph>This adds a plane to our scene.</paragraph>
            <paragraph>Then, in the viewport, click in the upper left corner on the <strong>Perspective</strong> button.
                In the menu that appears, select <strong>Display Wireframe</strong>.</paragraph>
            <paragraph>This will allow you to see the triangles making up the plane.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/plane.webp'}" original_uri="img/plane.webp" uri="tutorials/shaders/your_first_shader/img/plane.webp"></image>
            <paragraph>Now set <strong>Subdivide Width</strong> and <strong>Subdivide Depth</strong> of the <reference internal="True" refuri="../../../classes/class_planemesh#class-planemesh"><inline classes="std std-ref">PlaneMesh</inline></reference> to <literal>32</literal>.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/plane-sub-set.webp'}" original_uri="img/plane-sub-set.webp" uri="tutorials/shaders/your_first_shader/img/plane-sub-set.webp"></image>
            <paragraph>You can see that there are now many more triangles in the
                <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference>. This will give us more vertices to work with
                and thus allow us to add more detail.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/plane-sub.webp'}" original_uri="img/plane-sub.webp" uri="tutorials/shaders/your_first_shader/img/plane-sub.webp"></image>
            <paragraph><reference internal="True" refuri="../../../classes/class_primitivemesh#class-primitivemesh"><inline classes="std std-ref">PrimitiveMeshes</inline></reference>, like PlaneMesh, only have one
                surface, so instead of an array of materials there is only one. Set the
                <strong>Material</strong> to a new ShaderMaterial, then expand the material by clicking on
                the sphere that appears.</paragraph>
            <note>
                <paragraph>Materials that inherit from the <reference internal="True" refuri="../../../classes/class_material#class-material"><inline classes="std std-ref">Material</inline></reference> resource, such as <reference internal="True" refuri="../../../classes/class_standardmaterial3d#class-standardmaterial3d"><inline classes="std std-ref">StandardMaterial3D</inline></reference>
                    and <reference internal="True" refuri="../../../classes/class_particleprocessmaterial#class-particleprocessmaterial"><inline classes="std std-ref">ParticleProcessMaterial</inline></reference>, can be converted to a <reference internal="True" refuri="../../../classes/class_shadermaterial#class-shadermaterial"><inline classes="std std-ref">ShaderMaterial</inline></reference>
                    and their existing properties will be converted to an accompanying text shader.
                    To do so, right-click on the material in the FileSystem dock and choose
                    <strong>Convert to ShaderMaterial</strong>. You can also do so by right-clicking on any
                    property holding a reference to the material in the inspector.</paragraph>
            </note>
            <paragraph>Now set the material's <strong>Shader</strong> to a new Shader by clicking <literal>&lt;empty&gt;</literal> and
                select <strong>New Shader...</strong>. Leave the default settings, give your shader a name,
                and click <strong>Create</strong>.</paragraph>
            <paragraph>Click on the shader in the inspector, and the shader editor should now pop up. You
                are ready to begin writing your first Spatial shader!</paragraph>
        </section>
        <section ids="shader-magic" names="shader\ magic">
            <title>Shader magic</title>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/shader-editor.webp'}" original_uri="img/shader-editor.webp" uri="tutorials/shaders/your_first_shader/img/shader-editor.webp"></image>
            <paragraph>The new shader is already generated with a <literal>shader_type</literal> variable, the
                <literal>vertex()</literal> function, and the <literal>fragment()</literal> function. The first thing Godot
                shaders need is a declaration of what type of shader they are. In this case the
                <literal>shader_type</literal> is set to <literal>spatial</literal> because this is a spatial shader.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;</literal_block>
            <paragraph>The <literal>vertex()</literal> function determines where the vertices of your <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference>
                appear in the final scene. We will be using it to offset the height of each vertex
                and make our flat plane appear like a little terrain.</paragraph>
            <paragraph>With nothing in the <literal>vertex()</literal> function, Godot will use its default vertex
                shader. We can start to make changes by adding a single line:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void vertex() {
  VERTEX.y += cos(VERTEX.x) * sin(VERTEX.z);
}</literal_block>
            <paragraph>Adding this line, you should get an image like the one below.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/cos.webp'}" original_uri="img/cos.webp" uri="tutorials/shaders/your_first_shader/img/cos.webp"></image>
            <paragraph>Okay, let's unpack this. The <literal>y</literal> value of the <literal>VERTEX</literal> is being increased.
                And we are passing the <literal>x</literal> and <literal>z</literal> components of the <literal>VERTEX</literal> as arguments
                to <reference internal="True" refuri="../shader_reference/shader_functions#shader-func-cos"><inline classes="std std-ref">cos()</inline></reference> and <reference internal="True" refuri="../shader_reference/shader_functions#shader-func-sin"><inline classes="std std-ref">sin()</inline></reference>; that gives
                us a wave-like appearance across the <literal>x</literal> and <literal>z</literal> axes.</paragraph>
            <paragraph>What we want to achieve is the look of little hills; after all. <literal>cos()</literal> and
                <literal>sin()</literal> already look kind of like hills. We do so by scaling the inputs to the
                <literal>cos()</literal> and <literal>sin()</literal> functions.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void vertex() {
  VERTEX.y += cos(VERTEX.x * 4.0) * sin(VERTEX.z * 4.0);
}</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/cos4.webp'}" original_uri="img/cos4.webp" uri="tutorials/shaders/your_first_shader/img/cos4.webp"></image>
            <paragraph>This looks better, but it is still too spiky and repetitive, let's make it a
                little more interesting.</paragraph>
        </section>
        <section ids="noise-heightmap" names="noise\ heightmap">
            <title>Noise heightmap</title>
            <paragraph>Noise is a very popular tool for faking the look of terrain. Think of it as
                similar to the cosine function where you have repeating hills except, with
                noise, each hill has a different height.</paragraph>
            <paragraph>Godot provides the <reference internal="True" refuri="../../../classes/class_noisetexture2d#class-noisetexture2d"><inline classes="std std-ref">NoiseTexture2D</inline></reference> resource for
                generating a noise texture that can be accessed from a shader.</paragraph>
            <paragraph>To access a texture in a shader add the following code near the top of your
                shader, outside the <literal>vertex()</literal> function.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform sampler2D noise;</literal_block>
            <paragraph>This will allow you to send a noise texture to the shader. Now look in the
                inspector under your material. You should see a section called <strong>Shader Parameters</strong>.
                If you open it up, you'll see a parameter called "Noise".</paragraph>
            <paragraph>Set this <strong>Noise</strong> parameter to a new <reference internal="True" refuri="../../../classes/class_noisetexture2d#class-noisetexture2d"><inline classes="std std-ref">NoiseTexture2D</inline></reference>.
                Then in your NoiseTexture2D, set its <strong>Noise</strong> property to a new
                <reference internal="True" refuri="../../../classes/class_fastnoiselite#class-fastnoiselite"><inline classes="std std-ref">FastNoiseLite</inline></reference>. The FastNoiseLite class is used by
                the NoiseTexture2D to generate a heightmap.</paragraph>
            <paragraph>Once you set it up and should look like this.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/noise-set.webp'}" original_uri="img/noise-set.webp" uri="tutorials/shaders/your_first_shader/img/noise-set.webp"></image>
            <paragraph>Now, access the noise texture using the <literal>texture()</literal> function:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void vertex() {
  float height = texture(noise, VERTEX.xz / 2.0 + 0.5).x;
  VERTEX.y += height;
}</literal_block>
            <paragraph><reference internal="True" refuri="../shader_reference/shader_functions#shader-func-texture"><inline classes="std std-ref">texture()</inline></reference> takes a texture as the first argument and
                a <literal>vec2</literal> for the position on the texture as the second argument. We use the
                <literal>x</literal> and <literal>z</literal> channels of <literal>VERTEX</literal> to determine where on the texture to look
                up.</paragraph>
            <paragraph>Since the PlaneMesh coordinates are within the <literal>[-1.0, 1.0]</literal> range (for a size
                of <literal>2.0</literal>), while the texture coordinates are within <literal>[0.0, 1.0]</literal>, to remap
                the coordinates we divide by the size of the PlaneMesh by <literal>2.0</literal> and add
                <literal>0.5</literal> .</paragraph>
            <paragraph><literal>texture()</literal> returns a <literal>vec4</literal> of the <literal>r, g, b, a</literal> channels at the position.
                Since the noise texture is grayscale, all of the values are the same, so we can
                use any one of the channels as the height. In this case we'll use the <literal>r</literal>, or
                <literal>x</literal> channel.</paragraph>
            <note>
                <paragraph><literal>xyzw</literal> is the same as <literal>rgba</literal> in GLSL, so instead of <literal>texture().x</literal>
                    above, we could use <literal>texture().r</literal>. See the <reference name="OpenGL documentation" refuri="https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Vectors">OpenGL documentation</reference><target ids="opengl-documentation" names="opengl\ documentation" refuri="https://www.khronos.org/opengl/wiki/Data_Type_(GLSL)#Vectors"></target> for more
                    details.</paragraph>
            </note>
            <paragraph>Using this code you can see the texture creates random looking hills.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/noise.webp'}" original_uri="img/noise.webp" uri="tutorials/shaders/your_first_shader/img/noise.webp"></image>
            <paragraph>Right now it is too spiky, we want to soften the hills a bit. To do that, we
                will use a uniform. You already used a uniform above to pass in the noise
                texture, now let's learn how they work.</paragraph>
        </section>
        <section ids="uniforms" names="uniforms">
            <title>Uniforms</title>
            <paragraph><reference internal="True" refuri="../shader_reference/shading_language#doc-shading-language-uniforms"><inline classes="std std-ref">Uniform variables</inline></reference> allow you to pass data
                from the game into the shader. They are
                very useful for controlling shader effects. Uniforms can be almost any datatype
                that can be used in the shader. To use a uniform, you declare it in your
                <reference internal="True" refuri="../../../classes/class_shader#class-shader"><inline classes="std std-ref">Shader</inline></reference> using the keyword <literal>uniform</literal>.</paragraph>
            <paragraph>Let's make a uniform that changes the height of the terrain.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform float height_scale = 0.5;</literal_block>
            <paragraph>Godot lets you initialize a uniform with a value; here, <literal>height_scale</literal> is set
                to <literal>0.5</literal>. You can set uniforms from GDScript by calling the function
                <reference internal="True" refuri="../../../classes/class_shadermaterial#class-shadermaterial-method-set-shader-parameter"><inline classes="std std-ref">set_shader_parameter()</inline></reference>
                on the material corresponding to the shader. The value passed from GDScript
                takes precedence over the value used to initialize it in the shader.</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># called from the MeshInstance3D
mesh.material.set_shader_parameter("height_scale", 0.5)</literal_block>
            <note>
                <paragraph>Changing uniforms in Spatial-based nodes is different from
                    CanvasItem-based nodes. Here, we set the material inside the PlaneMesh
                    resource. In other mesh resources you may need to first access the
                    material by calling <literal>surface_get_material()</literal>. While in the
                    MeshInstance3D you would access the material using
                    <literal>get_surface_material()</literal> or <literal>material_override</literal>.</paragraph>
            </note>
            <paragraph>Remember that the string passed into <literal>set_shader_parameter()</literal> must match the name
                of the uniform variable in the shader. You can use the
                uniform variable anywhere inside your shader. Here, we will
                use it to set the height value instead of arbitrarily multiplying by <literal>0.5</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">VERTEX.y += height * height_scale;</literal_block>
            <paragraph>Now it looks much better.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/noise-low.webp'}" original_uri="img/noise-low.webp" uri="tutorials/shaders/your_first_shader/img/noise-low.webp"></image>
            <paragraph>Using uniforms, we can even change the value every frame to animate the height
                of the terrain. Combined with <reference internal="True" refuri="../../../classes/class_tween#class-tween"><inline classes="std std-ref">Tweens</inline></reference>, this can be
                especially useful for animations.</paragraph>
        </section>
        <section ids="interacting-with-light" names="interacting\ with\ light">
            <title>Interacting with light</title>
            <paragraph>First, turn wireframe off. To do so, open the <strong>Perspective</strong> menu in the
                upper-left of the viewport again, and select <strong>Display Normal</strong>. Additionally in
                the 3D scene toolbar, turn off preview sunlight.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/normal.webp'}" original_uri="img/normal.webp" uri="tutorials/shaders/your_first_shader/img/normal.webp"></image>
            <paragraph>Note how the mesh color goes flat. This is because the lighting on it is flat.
                Let's add a light!</paragraph>
            <paragraph>First, we will add an <reference internal="True" refuri="../../../classes/class_omnilight3d#class-omnilight3d"><inline classes="std std-ref">OmniLight3D</inline></reference> to the scene, and
                drag it up so it is above the terrain.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/light.webp'}" original_uri="img/light.webp" uri="tutorials/shaders/your_first_shader/img/light.webp"></image>
            <paragraph>You can see the light affecting the terrain, but it looks odd. The problem is
                the light is affecting the terrain as if it were a flat plane. This is because
                the light shader uses the normals from the <reference internal="True" refuri="../../../classes/class_mesh#class-mesh"><inline classes="std std-ref">Mesh</inline></reference> to calculate
                light.</paragraph>
            <paragraph>The normals are stored in the Mesh, but we are changing the shape of the Mesh in
                the shader, so the normals are no longer correct. To fix this, we can
                recalculate the normals in the shader or use a normal texture that corresponds
                to our noise. Godot makes both easy for us.</paragraph>
            <paragraph>You can calculate the new normal manually in the vertex function and then just
                set <literal>NORMAL</literal>. With <literal>NORMAL</literal> set, Godot will do all the difficult lighting
                calculations for us. We will cover this method in the next part of this
                tutorial, for now we will read normals from a texture.</paragraph>
            <paragraph>Instead we will rely on the NoiseTexture again to calculate normals for us. We
                do that by passing in a second noise texture.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform sampler2D normalmap;</literal_block>
            <paragraph>Set this second uniform texture to another <reference internal="True" refuri="../../../classes/class_noisetexture2d#class-noisetexture2d"><inline classes="std std-ref">NoiseTexture2D</inline></reference> with another
                <reference internal="True" refuri="../../../classes/class_fastnoiselite#class-fastnoiselite"><inline classes="std std-ref">FastNoiseLite</inline></reference>. But this time, check <strong>As Normal Map</strong>.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/normal-set.webp'}" original_uri="img/normal-set.webp" uri="tutorials/shaders/your_first_shader/img/normal-set.webp"></image>
            <paragraph>When we have normals that correspond to a specific vertex we set <literal>NORMAL</literal>, but
                if you have a normalmap that comes from a texture, set the normal using
                <literal>NORMAL_MAP</literal> in the <literal>fragment()</literal> function. This way Godot will handle
                wrapping the texture around the mesh automatically.</paragraph>
            <paragraph>Lastly, in order to ensure that we are reading from the same places on the noise
                texture and the normalmap texture, we are going to pass the <literal>VERTEX.xz</literal>
                position from the <literal>vertex()</literal> function to the <literal>fragment()</literal> function. We do
                that using a <reference internal="True" refuri="../shader_reference/shading_language#doc-shading-language-varyings"><inline classes="std std-ref">varying</inline></reference>.</paragraph>
            <paragraph>Above the <literal>vertex()</literal> define a <literal>varying vec2</literal> called <literal>tex_position</literal>. And
                inside the <literal>vertex()</literal> function assign <literal>VERTEX.xz</literal> to <literal>tex_position</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">varying vec2 tex_position;

void vertex() {
  tex_position = VERTEX.xz / 2.0 + 0.5;
  float height = texture(noise, tex_position).x;
  VERTEX.y += height * height_scale;
}</literal_block>
            <paragraph>And now we can access <literal>tex_position</literal> from the <literal>fragment()</literal> function.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  NORMAL_MAP = texture(normalmap, tex_position).xyz;
}</literal_block>
            <paragraph>With the normals in place the light now reacts to the height of the mesh
                dynamically.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/normalmap.webp'}" original_uri="img/normalmap.webp" uri="tutorials/shaders/your_first_shader/img/normalmap.webp"></image>
            <paragraph>We can even drag the light around and the lighting will update automatically.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/normalmap2.webp'}" original_uri="img/normalmap2.webp" uri="tutorials/shaders/your_first_shader/img/normalmap2.webp"></image>
        </section>
        <section ids="full-code" names="full\ code">
            <title>Full code</title>
            <paragraph>Here is the full code for this tutorial. You can see it is not very long as
                Godot handles most of the difficult stuff for you.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

uniform float height_scale = 0.5;
uniform sampler2D noise;
uniform sampler2D normalmap;

varying vec2 tex_position;

void vertex() {
  tex_position = VERTEX.xz / 2.0 + 0.5;
  float height = texture(noise, tex_position).x;
  VERTEX.y += height * height_scale;
}

void fragment() {
  NORMAL_MAP = texture(normalmap, tex_position).xyz;
}</literal_block>
            <paragraph>That is everything for this part. Hopefully, you now understand the basics of
                vertex shaders in Godot. In the next part of this tutorial we will write a
                fragment function to accompany this vertex function and we will cover a more
                advanced technique to turn this terrain into an ocean of moving waves.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
