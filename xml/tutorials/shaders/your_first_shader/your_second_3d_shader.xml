<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/your_first_shader/your_second_3d_shader.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-your-second-spatial-shader"></target>
    <section ids="your-second-3d-shader doc-your-second-spatial-shader" names="your\ second\ 3d\ shader 你的第二个\ 3d\ 着色器 doc_your_second_spatial_shader">
        <title>你的第二个 3D 着色器</title>
        <paragraph>从高级设置开始,Godot所做的是为用户提供一组可选设置的参数("环境光遮蔽" , "次表面散射强度" , "边缘" 等等)这些参数对应不同的复杂效应(环境遮挡, 次表面散射, 边缘照明等等)如果没有写入, 代码在编译之前被抛出, 因此着色器不会产生额外特性的成本. 这使得用户很容易拥有复杂的支持PBR着色, 而不需要编写复杂的着色器. 当然,Godot还允许你忽略所有这些参数, 并编写一个完全定制的着色器.</paragraph>
        <paragraph>有关这些参数的完整列表, 请参见 <reference internal="True" refuri="../shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">空间着色器</inline></reference> 参考文档.</paragraph>
        <paragraph>A difference between the vertex function and a fragment function is that the
            vertex function runs per vertex and sets properties such as <literal>VERTEX</literal>
            (position) and <literal>NORMAL</literal>, while the fragment shader runs per pixel and, most
            importantly, sets the <literal>ALBEDO</literal> color of the <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference>.</paragraph>
        <section ids="your-first-spatial-fragment-function" names="your\ first\ spatial\ fragment\ function 第一个空间片段函数">
            <title>第一个空间片段函数</title>
            <paragraph>如本教程前一部分所述. 在Godot中, 片段函数的标准用法是设置不同的材质属性, 然后让Godot处理剩下的部分. 为了提供更大的灵活性,Godot还提供了渲染模式. 渲染模式设置在着色器的顶部, 直接在 "着色_方式" 下面, 它们指定了你想要着色器的内置方面具有什么样的功能.</paragraph>
            <paragraph>例如, 如果你不想让灯光影响一个物体, 设置渲染模式为 "无阴影":</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">render_mode unshaded;</literal_block>
            <paragraph>你还可以将多个渲染模式堆叠在一起。例如，如果你想使用卡通材质而不是更真实的 PBR 材质，将漫反射模式和镜面反射模式设置为卡通：</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">render_mode diffuse_toon, specular_toon;</literal_block>
            <paragraph>这个内置功能模型允许你通过更改几个参数来编写复杂的自定义着色器.</paragraph>
            <paragraph>有关渲染模式的完整列表, 请参见空间着色器参考 <reference internal="True" refuri="../shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">Spatial shader reference</inline></reference>.</paragraph>
            <paragraph>在本教程的这一部分中, 我们将介绍如何将前一部分的崎岖地形变成海洋.</paragraph>
            <paragraph>首先让我们设置水的颜色. 我们通过设置 <literal>ALBEDO</literal> 来做到这一点.</paragraph>
            <paragraph><literal>ALBEDO</literal> 是一个 <literal>vec3</literal> , 包含物体的颜色.</paragraph>
            <paragraph>我们把它调成蓝色.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  ALBEDO = vec3(0.1, 0.3, 0.5);
}</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/albedo.png'}" uri="tutorials/shaders/your_first_shader/img/albedo.png"></image>
            <paragraph>我们将其设置为深蓝色, 因为水的大部分蓝色来自天空的反射.</paragraph>
            <paragraph>PBR模型的Godot用户两个主要参数:"金属度" 和 "粗糙度".</paragraph>
            <paragraph>粗糙度是指材料表面的光滑程度. 低 "粗糙度" 会使材料看起来像闪亮的塑料, 而高粗糙度使材料在颜色上看起来更坚实.</paragraph>
            <paragraph><literal>METALLIC</literal> 指定该物体有多像金属, 它最好设置为接近 <literal>0</literal> 或 <literal>1</literal> . 把 <literal>METALLIC</literal> 看作是改变反射和 <literal>ALBEDO</literal> 颜色之间的平衡. 高的 <literal>METALLIC</literal> 几乎完全忽略了 <literal>ALBEDO</literal> , 看起来像天空的镜子. 而低的 <literal>METALLIC</literal> 对天空的颜色和 <literal>ALBEDO</literal> 的颜色有一个更平实的表现.</paragraph>
            <paragraph>"粗糙度" 从左到右从0增加到1, 而 "金属度" 从上到下从0增加到1.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/PBR.png'}" uri="tutorials/shaders/your_first_shader/img/PBR.png"></image>
            <note>
                <paragraph>对恰当的PBR阴影,"金属度" 应当接近0或者1. 为了混合不同的材料, 只有将其设置在0和1之间.</paragraph>
            </note>
            <paragraph>水不是金属，所以我们将其 <literal>METALLIC</literal> 属性设置成 <literal>0.0</literal>。水的反射性也很高，因此我们将其``ROUGHNESS`` 属性也设置得非常低。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  METALLIC = 0.0;
  ROUGHNESS = 0.01;
  ALBEDO = vec3(0.1, 0.3, 0.5);
}</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/plastic.png'}" uri="tutorials/shaders/your_first_shader/img/plastic.png"></image>
            <paragraph>现在，我们有了光滑的塑料外观表面。现在该考虑要模拟的水的某些特定属性了。这里有两种主要的方法可以把诡异的塑料表面变成好看的水。首先是镜面反射（Specular）。镜面反射是那些来自太阳直接反射到你眼里的明亮斑点。第二个是菲涅耳反射（Fresnel）。菲涅尔反射是物体在小角度下更具反射性的属性。这就是为什么你可以看见自己身下的水，却在更远处看见天空倒影的原因。</paragraph>
            <paragraph>为了增强镜面反射，我们需要做两件事。首先，由于卡通渲染模式具有更高的镜面反射高光，我们将更改镜面反射为卡通渲染模式。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">render_mode specular_toon;</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/specular-toon.png'}" uri="tutorials/shaders/your_first_shader/img/specular-toon.png"></image>
            <paragraph>其次, 我们将添加边缘照明. 边缘照明增加了掠射角度的光线效果. 通常, 它用于模拟光线穿过对象边缘上的织物的路径, 但是我们将在此处使用它来帮助实现良好的水润效果.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  RIM = 0.2;
  METALLIC = 0.0;
  ROUGHNESS = 0.01;
  ALBEDO = vec3(0.1, 0.3, 0.5);
}</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/rim.png'}" uri="tutorials/shaders/your_first_shader/img/rim.png"></image>
            <paragraph>In order to add fresnel reflectance, we will compute a fresnel term in our
                fragment shader. Here, we aren't going to use a real fresnel term for
                performance reasons. Instead, we'll approximate it using the dot product of the
                <literal>NORMAL</literal> and <literal>VIEW</literal> vectors. The <literal>NORMAL</literal> vector points away from the
                mesh's surface, while the <literal>VIEW</literal> vector is the direction between your eye and
                that point on the surface. The dot product between them is a handy way to tell
                when you are looking at the surface head-on or at a glancing angle.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float fresnel = sqrt(1.0 - dot(NORMAL, VIEW));</literal_block>
            <paragraph>And mix it into both <literal>ROUGHNESS</literal> and <literal>ALBEDO</literal>. This is the benefit of
                ShaderMaterials over StandardMaterial3Ds. With StandardMaterial3D, we could set
                these properties with a texture, or to a flat number. But with shaders we can
                set them based on any mathematical function that we can dream up.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  float fresnel = sqrt(1.0 - dot(NORMAL, VIEW));
  RIM = 0.2;
  METALLIC = 0.0;
  ROUGHNESS = 0.01 * (1.0 - fresnel);
  ALBEDO = vec3(0.1, 0.3, 0.5) + (0.1 * fresnel);
}</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/fresnel.png'}" uri="tutorials/shaders/your_first_shader/img/fresnel.png"></image>
            <paragraph>而现在, 只需要5行代码, 你就可以拥有看起来很复杂的水. 现在, 我们有了照明, 这个水看起来太亮了. 让我们把它变暗. 这可以通过减少我们传入 <literal>ALBEDO</literal> 的 <literal>vec3</literal> 的值来轻松实现. 让我们把它们设置为 <literal>vec3(0.01, 0.03, 0.05)</literal> .</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/dark-water.png'}" uri="tutorials/shaders/your_first_shader/img/dark-water.png"></image>
        </section>
        <section ids="animating-with-time" names="animating\ with\ time 用\ time\ 做动画">
            <title>用 <literal>TIME</literal> 做动画</title>
            <paragraph>回到顶点功能，我们可以使用内置变量 <literal>TIME</literal> 对波浪进行动画处理。</paragraph>
            <paragraph><literal>TIME</literal> 是一个内置变量，可从顶点和片段函数访问。</paragraph>
            <paragraph>在上一个教程中，我们通过从高度图读取来计算高度。对于本教程，我们将做同样的事情。将高度图代码放在一个名为 <literal>height()</literal> 的函数中。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float height(vec2 position) {
  return texture(noise, position / 10.0).x; // Scaling factor is based on mesh size (this PlaneMesh is 10×10).
}</literal_block>
            <paragraph>为了在 <literal>height()</literal> 函数中使用 <literal>TIME</literal>，我们需要将其传递进去。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float height(vec2 position, float time) {
}</literal_block>
            <paragraph>确保其正确传递到顶点函数中.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void vertex() {
  vec2 pos = VERTEX.xz;
  float k = height(pos, TIME);
  VERTEX.y = k;
}</literal_block>
            <paragraph>而不是使用法线贴图来计算法线。我们将在 <literal>vertex()</literal> 函数中手动计算它们。为此，请使用以下代码行。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">NORMAL = normalize(vec3(k - height(pos + vec2(0.1, 0.0), TIME), 0.1, k - height(pos + vec2(0.0, 0.1), TIME)));</literal_block>
            <paragraph>我们需要手动计算 <literal>NORMAL</literal>，因为在下一节中，我们将使用数学来创建外观复杂的波形。</paragraph>
            <paragraph>现在，我们要通过使 <literal>positon</literal> 偏移 <literal>TIME</literal> 的余弦来使 <literal>height()</literal> 函数更加复杂。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float height(vec2 position, float time) {
  vec2 offset = 0.01 * cos(position + time);
  return texture(noise, (position / 10.0) - offset).x;
}</literal_block>
            <paragraph>这会实现缓慢移动的波纹效果, 但显得有点不自然. 下一节将深入探讨, 通过加入更多的数学函数, 来用着色器实现更复杂的效果, 比如更加真实的波纹.</paragraph>
        </section>
        <section ids="advanced-effects-waves" names="advanced\ effects:\ waves 进阶效果：水波">
            <title>进阶效果：水波</title>
            <paragraph>利用数学, 着色器可以实现复杂的效果, 这是着色器的强大之处. 为阐述这一点, 我们将修改 <literal>height()</literal> 函数和引入新函数 <literal>wave()</literal> , 来让波纹效果更进一层.</paragraph>
            <paragraph><literal>wave()</literal> 有一个参数, <literal>position</literal>, 和在 <literal>height()</literal> 中一样.</paragraph>
            <paragraph>我们将在 <literal>height()</literal> 函数中多次调用 <literal>wave()</literal> 函数, 来改变波纹的样子.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float wave(vec2 position){
  position += texture(noise, position / 10.0).x * 2.0 - 1.0;
  vec2 wv = 1.0 - abs(sin(position));
  return pow(1.0 - pow(wv.x * wv.y, 0.65), 4.0);
}</literal_block>
            <paragraph>这在一开始会让人觉得很复杂, 所以我们一行一行地来实现.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">position += texture(noise, position / 10.0).x * 2.0 - 1.0;</literal_block>
            <paragraph>通过 <literal>noise</literal> 纹理来偏移位置. 这将会使波浪成为曲线, 所以它们将不会是与网格所对齐的直线.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">vec2 wv = 1.0 - abs(sin(position));</literal_block>
            <paragraph>用 <literal>sin()</literal> 和 <literal>position</literal> 定义一个类似波浪的函数. 通常 <literal>sin()</literal> 波是很圆的. 我们使用 <literal>abs()</literal> 去将其绝对化, 让它有一个尖锐波峰, 并将其约束于0-1的范围内. 然后我们再从 <literal>1.0</literal> 中减去, 将峰值放在上方.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">return pow(1.0 - pow(wv.x * wv.y, 0.65), 4.0);</literal_block>
            <paragraph>将x方向的波乘以y方向的波, 并将其提高到使峰值变得尖锐的幂. 然后从 <literal>1.0</literal> 中减去它, 使山脊成为山峰, 并提高山脊锐化的能力.</paragraph>
            <paragraph>现在我们可以用 <literal>wave()</literal> 代替 <literal>height()</literal> 函数的内容.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float height(vec2 position, float time) {
  float h = wave(position);
  return h;
}</literal_block>
            <paragraph>这样一来, 你会得到:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/wave1.png'}" uri="tutorials/shaders/your_first_shader/img/wave1.png"></image>
            <paragraph>正弦曲线的形状太明显了. 所以让我们把波型分散一下. 我们通过缩放 <literal>位置</literal> 来实现.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float height(vec2 position, float time) {
  float h = wave(position * 0.4);
  return h;
}</literal_block>
            <paragraph>现在它看起来好多了.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/wave2.png'}" uri="tutorials/shaders/your_first_shader/img/wave2.png"></image>
            <paragraph>如果我们将多个波以不同的频率和幅度彼此叠加, 则可以做得更好. 这意味着我们将按比例缩放每个位置, 以使波形更细或更宽(频率). 我们将乘以波的输出, 以使它们变低或变高(振幅).</paragraph>
            <paragraph>下面以四种波形为例, 说明如何将四种波形分层, 以达到更漂亮的波形效果.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float height(vec2 position, float time) {
  float d = wave((position + time) * 0.4) * 0.3;
  d += wave((position - time) * 0.3) * 0.3;
  d += wave((position + time) * 0.5) * 0.2;
  d += wave((position - time) * 0.6) * 0.2;
  return d;
}</literal_block>
            <paragraph>请注意, 我们把时间加到两个上, 再从另外两个上减去. 这使得波在不同的方向上移动, 产生了复杂的效果. 还要注意, 振幅(结果乘以的数字)全部加起来是 <literal>1.0</literal>. 这使波浪保持在0-1的范围内.</paragraph>
            <paragraph>有了这段代码, 你应该可以得到更复杂的波形, 而你所要做的只是增加一点数学运算！</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/wave3.png'}" uri="tutorials/shaders/your_first_shader/img/wave3.png"></image>
            <paragraph>有关空间着色器的更多信息, 请阅读 <reference internal="True" refuri="../shader_reference/shading_language#doc-shading-language"><inline classes="std std-ref">Shading Language</inline></reference> 文档和 <reference internal="True" refuri="../shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">Spatial Shaders</inline></reference> 文档. 也可以看看 <reference internal="True" refuri="../index#toc-learn-features-shading"><inline classes="std std-ref">Shading 部分</inline></reference> 和 <reference internal="True" refuri="../../3d/index#toc-learn-features-3d"><inline classes="std std-ref">3D</inline></reference> 部分的高级教程.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
