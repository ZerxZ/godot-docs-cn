<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/your_first_shader/your_second_3d_shader.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-your-second-spatial-shader"></target>
    <section ids="your-second-3d-shader doc-your-second-spatial-shader" names="your\ second\ 3d\ shader doc_your_second_spatial_shader">
        <title>Your second 3D shader</title>
        <paragraph>From a high-level, what Godot does is give the user a bunch of parameters that
            can be optionally set (<literal>AO</literal>, <literal>SSS_Strength</literal>, <literal>RIM</literal>, etc.). These
            parameters correspond to different complex effects (Ambient Occlusion,
            SubSurface Scattering, Rim Lighting, etc.). When not written to, the code is
            thrown out before it is compiled and so the shader does not incur the cost of
            the extra feature. This makes it easy for users to have complex PBR-correct
            shading, without writing complex shaders. Of course, Godot also allows you to
            ignore all these parameters and write a fully customized shader.</paragraph>
        <paragraph>For a full list of these parameters see the <reference internal="True" refuri="../shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">spatial shader</inline></reference> reference doc.</paragraph>
        <paragraph>A difference between the vertex function and a fragment function is that the
            vertex function runs per vertex and sets properties such as <literal>VERTEX</literal>
            (position) and <literal>NORMAL</literal>, while the fragment shader runs per pixel and, most
            importantly, sets the <literal>ALBEDO</literal> color of the <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference>.</paragraph>
        <section ids="your-first-spatial-fragment-function" names="your\ first\ spatial\ fragment\ function">
            <title>Your first spatial fragment function</title>
            <paragraph>As mentioned in the previous part of this tutorial. The standard use of the
                fragment function in Godot is to set up different material properties and let
                Godot handle the rest. In order to provide even more flexibility, Godot also
                provides things called render modes. Render modes are set at the top of the
                shader, directly below <literal>shader_type</literal>, and they specify what sort of
                functionality you want the built-in aspects of the shader to have.</paragraph>
            <paragraph>For example, if you do not want to have lights affect an object, set the render
                mode to <literal>unshaded</literal>:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">render_mode unshaded;</literal_block>
            <paragraph>You can also stack multiple render modes together. For example, if you want to
                use toon shading instead of more-realistic PBR shading, set the diffuse mode and
                specular mode to toon:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">render_mode diffuse_toon, specular_toon;</literal_block>
            <paragraph>This model of built-in functionality allows you to write complex custom shaders
                by changing only a few parameters.</paragraph>
            <paragraph>For a full list of render modes see the <reference internal="True" refuri="../shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">Spatial shader reference</inline></reference>.</paragraph>
            <paragraph>In this part of the tutorial, we will walk through how to take the bumpy terrain
                from the previous part and turn it into an ocean.</paragraph>
            <paragraph>First let's set the color of the water. We do that by setting <literal>ALBEDO</literal>.</paragraph>
            <paragraph><literal>ALBEDO</literal> is a <literal>vec3</literal> that contains the color of the object.</paragraph>
            <paragraph>Let's set it to a nice shade of blue.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  ALBEDO = vec3(0.1, 0.3, 0.5);
}</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/albedo.png'}" original_uri="img/albedo.png" uri="tutorials/shaders/your_first_shader/img/albedo.png"></image>
            <paragraph>We set it to a very dark shade of blue because most of the blueness of the water
                will come from reflections from the sky.</paragraph>
            <paragraph>The PBR model that Godot uses relies on two main parameters: <literal>METALLIC</literal> and
                <literal>ROUGHNESS</literal>.</paragraph>
            <paragraph><literal>ROUGHNESS</literal> specifies how smooth/rough the surface of a material is. A low
                <literal>ROUGHNESS</literal> will make a material appear like a shiny plastic, while a high
                roughness makes the material appear more solid in color.</paragraph>
            <paragraph><literal>METALLIC</literal> specifies how much like a metal the object is. It is better set
                close to <literal>0</literal> or <literal>1</literal>. Think of <literal>METALLIC</literal> as changing the balance between
                the reflection and the <literal>ALBEDO</literal> color. A high <literal>METALLIC</literal> almost ignores
                <literal>ALBEDO</literal> altogether, and looks like a mirror of the sky. While a low
                <literal>METALLIC</literal> has a more equal representation of sky color and <literal>ALBEDO</literal> color.</paragraph>
            <paragraph><literal>ROUGHNESS</literal> increases from <literal>0</literal> to <literal>1</literal> from left to right while
                <literal>METALLIC</literal> increase from <literal>0</literal> to <literal>1</literal> from top to bottom.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/PBR.png'}" original_uri="img/PBR.png" uri="tutorials/shaders/your_first_shader/img/PBR.png"></image>
            <note>
                <paragraph><literal>METALLIC</literal> should be close to <literal>0</literal> or <literal>1</literal> for proper PBR shading.
                    Only set it between them for blending between materials.</paragraph>
            </note>
            <paragraph>Water is not a metal, so we will set its <literal>METALLIC</literal> property to <literal>0.0</literal>. Water
                is also highly reflective, so we will set its <literal>ROUGHNESS</literal> property to be quite
                low as well.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  METALLIC = 0.0;
  ROUGHNESS = 0.01;
  ALBEDO = vec3(0.1, 0.3, 0.5);
}</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/plastic.png'}" original_uri="img/plastic.png" uri="tutorials/shaders/your_first_shader/img/plastic.png"></image>
            <paragraph>Now we have a smooth plastic looking surface. It is time to think about some
                particular properties of water that we want to emulate. There are two main ones
                that will take this from a weird plastic surface to nice stylized water. The
                first is specular reflections. Specular reflections are those bright spots you
                see from where the sun reflects directly into your eye. The second is fresnel
                reflectance. Fresnel reflectance is the property of objects to become more
                reflective at shallow angles. It is the reason why you can see into water below
                you, but farther away it reflects the sky.</paragraph>
            <paragraph>In order to increase the specular reflections, we will do two things. First, we
                will change the render mode for specular to toon because the toon render mode
                has larger specular highlights.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">render_mode specular_toon;</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/specular-toon.png'}" original_uri="img/specular-toon.png" uri="tutorials/shaders/your_first_shader/img/specular-toon.png"></image>
            <paragraph>Second we will add rim lighting. Rim lighting increases the effect of light at
                glancing angles. Usually it is used to emulate the way light passes through
                fabric on the edges of an object, but we will use it here to help achieve a nice
                watery effect.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  RIM = 0.2;
  METALLIC = 0.0;
  ROUGHNESS = 0.01;
  ALBEDO = vec3(0.1, 0.3, 0.5);
}</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/rim.png'}" original_uri="img/rim.png" uri="tutorials/shaders/your_first_shader/img/rim.png"></image>
            <paragraph>In order to add fresnel reflectance, we will compute a fresnel term in our
                fragment shader. Here, we aren't going to use a real fresnel term for
                performance reasons. Instead, we'll approximate it using the dot product of the
                <literal>NORMAL</literal> and <literal>VIEW</literal> vectors. The <literal>NORMAL</literal> vector points away from the
                mesh's surface, while the <literal>VIEW</literal> vector is the direction between your eye and
                that point on the surface. The dot product between them is a handy way to tell
                when you are looking at the surface head-on or at a glancing angle.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float fresnel = sqrt(1.0 - dot(NORMAL, VIEW));</literal_block>
            <paragraph>And mix it into both <literal>ROUGHNESS</literal> and <literal>ALBEDO</literal>. This is the benefit of
                ShaderMaterials over StandardMaterial3Ds. With StandardMaterial3D, we could set
                these properties with a texture, or to a flat number. But with shaders we can
                set them based on any mathematical function that we can dream up.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  float fresnel = sqrt(1.0 - dot(NORMAL, VIEW));
  RIM = 0.2;
  METALLIC = 0.0;
  ROUGHNESS = 0.01 * (1.0 - fresnel);
  ALBEDO = vec3(0.1, 0.3, 0.5) + (0.1 * fresnel);
}</literal_block>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/fresnel.png'}" original_uri="img/fresnel.png" uri="tutorials/shaders/your_first_shader/img/fresnel.png"></image>
            <paragraph>And now, with only 5 lines of code, you can have complex looking water. Now that
                we have lighting, this water is looking too bright. Let's darken it. This is
                done easily by decreasing the values of the <literal>vec3</literal> we pass into <literal>ALBEDO</literal>.
                Let's set them to <literal>vec3(0.01, 0.03, 0.05)</literal>.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/dark-water.png'}" original_uri="img/dark-water.png" uri="tutorials/shaders/your_first_shader/img/dark-water.png"></image>
        </section>
        <section ids="animating-with-time" names="animating\ with\ time">
            <title>Animating with <literal>TIME</literal></title>
            <paragraph>Going back to the vertex function, we can animate the waves using the built-in
                variable <literal>TIME</literal>.</paragraph>
            <paragraph><literal>TIME</literal> is a built-in variable that is accessible from the vertex and fragment
                functions.</paragraph>
            <paragraph>In the last tutorial we calculated height by reading from a heightmap. For this
                tutorial, we will do the same. Put the heightmap code in a function called
                <literal>height()</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float height(vec2 position) {
  return texture(noise, position / 10.0).x; // Scaling factor is based on mesh size (this PlaneMesh is 10Ã—10).
}</literal_block>
            <paragraph>In order to use <literal>TIME</literal> in the <literal>height()</literal> function, we need to pass it in.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float height(vec2 position, float time) {
}</literal_block>
            <paragraph>And make sure to correctly pass it in inside the vertex function.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void vertex() {
  vec2 pos = VERTEX.xz;
  float k = height(pos, TIME);
  VERTEX.y = k;
}</literal_block>
            <paragraph>Instead of using a normalmap to calculate normals. We are going to compute them
                manually in the <literal>vertex()</literal> function. To do so use the following line of code.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">NORMAL = normalize(vec3(k - height(pos + vec2(0.1, 0.0), TIME), 0.1, k - height(pos + vec2(0.0, 0.1), TIME)));</literal_block>
            <paragraph>We need to compute <literal>NORMAL</literal> manually because in the next section we will be
                using math to create complex-looking waves.</paragraph>
            <paragraph>Now, we are going to make the <literal>height()</literal> function a little more complicated by
                offsetting <literal>position</literal> by the cosine of <literal>TIME</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float height(vec2 position, float time) {
  vec2 offset = 0.01 * cos(position + time);
  return texture(noise, (position / 10.0) - offset).x;
}</literal_block>
            <paragraph>This results in waves that move slowly, but not in a very natural way. The next
                section will dig deeper into using shaders to create more complex effects, in
                this case realistic waves, by adding a few more mathematical functions.</paragraph>
        </section>
        <section ids="advanced-effects-waves" names="advanced\ effects:\ waves">
            <title>Advanced effects: waves</title>
            <paragraph>What makes shaders so powerful is that you can achieve complex effects by using
                math. To illustrate this, we are going to take our waves to the next level by
                modifying the <literal>height()</literal> function and by introducing a new function called
                <literal>wave()</literal>.</paragraph>
            <paragraph><literal>wave()</literal> has one parameter, <literal>position</literal>, which is the same as it is in
                <literal>height()</literal>.</paragraph>
            <paragraph>We are going to call <literal>wave()</literal> multiple times in <literal>height()</literal> in order to fake
                the way waves look.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float wave(vec2 position){
  position += texture(noise, position / 10.0).x * 2.0 - 1.0;
  vec2 wv = 1.0 - abs(sin(position));
  return pow(1.0 - pow(wv.x * wv.y, 0.65), 4.0);
}</literal_block>
            <paragraph>At first this looks complicated. So let's go through it line-by-line.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">position += texture(noise, position / 10.0).x * 2.0 - 1.0;</literal_block>
            <paragraph>Offset the position by the <literal>noise</literal> texture. This will make the waves curve, so
                they won't be straight lines completely aligned with the grid.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">vec2 wv = 1.0 - abs(sin(position));</literal_block>
            <paragraph>Define a wave-like function using <literal>sin()</literal> and <literal>position</literal>. Normally <literal>sin()</literal>
                waves are very round. We use <literal>abs()</literal> to absolute to give them a sharp ridge
                and constrain them to the 0-1 range. And then we subtract it from <literal>1.0</literal> to put
                the peak on top.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">return pow(1.0 - pow(wv.x * wv.y, 0.65), 4.0);</literal_block>
            <paragraph>Multiply the x-directional wave by the y-directional wave and raise it to a
                power to sharpen the peaks. Then subtract that from <literal>1.0</literal> so that the ridges
                become peaks and raise that to a power to sharpen the ridges.</paragraph>
            <paragraph>We can now replace the contents of our <literal>height()</literal> function with <literal>wave()</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float height(vec2 position, float time) {
  float h = wave(position);
  return h;
}</literal_block>
            <paragraph>Using this, you get:</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/wave1.png'}" original_uri="img/wave1.png" uri="tutorials/shaders/your_first_shader/img/wave1.png"></image>
            <paragraph>The shape of the sin wave is too obvious. So let's spread the waves out a bit.
                We do this by scaling <literal>position</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float height(vec2 position, float time) {
  float h = wave(position * 0.4);
  return h;
}</literal_block>
            <paragraph>Now it looks much better.</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/wave2.png'}" original_uri="img/wave2.png" uri="tutorials/shaders/your_first_shader/img/wave2.png"></image>
            <paragraph>We can do even better if we layer multiple waves on top of each other at varying
                frequencies and amplitudes. What this means is that we are going to scale
                position for each one to make the waves thinner or wider (frequency). And we are
                going to multiply the output of the wave to make them shorter or taller
                (amplitude).</paragraph>
            <paragraph>Here is an example for how you could layer the four waves to achieve nicer
                looking waves.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float height(vec2 position, float time) {
  float d = wave((position + time) * 0.4) * 0.3;
  d += wave((position - time) * 0.3) * 0.3;
  d += wave((position + time) * 0.5) * 0.2;
  d += wave((position - time) * 0.6) * 0.2;
  return d;
}</literal_block>
            <paragraph>Note that we add time to two and subtract it from the other two. This makes the
                waves move in different directions creating a complex effect. Also note that the
                amplitudes (the number the result is multiplied by) all add up to <literal>1.0</literal>. This
                keeps the wave in the 0-1 range.</paragraph>
            <paragraph>With this code you should end up with more complex looking waves and all you had
                to do was add a bit of math!</paragraph>
            <image candidates="{'*': 'tutorials/shaders/your_first_shader/img/wave3.png'}" original_uri="img/wave3.png" uri="tutorials/shaders/your_first_shader/img/wave3.png"></image>
            <paragraph>For more information about Spatial shaders read the <reference internal="True" refuri="../shader_reference/shading_language#doc-shading-language"><inline classes="std std-ref">Shading Language</inline></reference> doc and the <reference internal="True" refuri="../shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">Spatial Shaders</inline></reference>
                doc. Also look at more advanced tutorials in the <reference internal="True" refuri="../index#toc-learn-features-shading"><inline classes="std std-ref">Shading section</inline></reference> and the <reference internal="True" refuri="../../3d/index#toc-learn-features-3d"><inline classes="std std-ref">3D</inline></reference>
                sections.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
