<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/shader_reference/shading_language.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-shading-language"></target>
    <section ids="shading-language doc-shading-language" names="shading\ language 着色语言 doc_shading_language">
        <title>着色语言</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>Godot 使用类似于 GLSL ES 3.0 的着色语言。支持大多数数据类型和函数，并且可能会随着时间的推移添加剩余的几种类型和函数。</paragraph>
            <paragraph>如果你已经熟悉 GLSL，<reference internal="True" refuri="../converting_glsl_to_godot_shaders#doc-converting-glsl-to-godot-shaders"><inline classes="std std-ref">Godot 着色器迁移指南</inline></reference>是一个帮助你从常规 GLSL 转换到 Godot 着色语言的资源。</paragraph>
        </section>
        <section ids="data-types" names="data\ types 数据类型">
            <title>数据类型</title>
            <paragraph>支持大多数GLSL ES 3.0数据类型:</paragraph>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="22"></colspec>
                    <colspec colwidth="81"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>类型</paragraph>
                            </entry>
                            <entry>
                                <paragraph>描述</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><strong>void</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Void数据类型, 只对不返回任何内容的函数有用.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>bool</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>布尔数据类型，只能包含 <literal>true</literal> 或 <literal>false</literal>。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>bvec2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>布尔值的两个分量向量.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>bvec3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>布尔值的三分量向量.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>bvec4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>布尔值的四分量向量.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>int</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>带正负的符号标量整数.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>ivec2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>有符号整数的双分量向量.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>ivec3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>有符号整数的三分量向量.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>ivec4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>有符号整数的四分量向量.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>uint</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>无符号标量整数, 不能包含负数.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>uvec2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>无符号整数的两分量向量.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>uvec3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>无符号整数的三分量向量.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>uvec4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>无符号整数的四分量向量.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>float</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>浮点标量.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>vec2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>浮点值的两分量向量.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>vec3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>浮点值的三分量向量.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>vec4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>浮点值的四分量向量.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>mat2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>2x2矩阵, 按主要顺序排列.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>mat3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>3x3矩阵, 在列的主要顺序.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>mat4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>4x4矩阵, 按主要顺序排列.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>用于绑定2D纹理的采样器类型, 以浮点形式读取.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>isampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>用于绑定2D纹理的采样器类型, 它们被读取为有符号整数.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>usampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>用于绑定2D纹理的采样器类型, 读取为无符号整数.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2DArray</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>用于绑定2D纹理数组的采样器类型, 以浮点数形式读取.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>isampler2DArray</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>用于绑定2D纹理数组的采样器类型, 以有符号整数形式读取.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>usampler2DArray</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>用于绑定2D纹理数组的采样器类型, 以无符号整数形式读取.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler3D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>用于绑定3D纹理的采样器类型, 以浮点形式读取.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>isampler3D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>用于绑定3D纹理的采样器类型, 以有符号整数形式读取.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>usampler3D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>用于绑定3D纹理的采样器类型, 以无符号整数形式读取.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>samplerCube</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>用于绑定立方体贴图的采样器类型，作为 float 读取。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>samplerCubeArray</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>用于绑定立方体贴图数组的采样器类型，作为 float 读取。</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <section ids="comments" names="comments 注释">
                <title>注释</title>
                <paragraph>The shading language supports the same comment syntax as used in C# and C++:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">// Single-line comment.
int a = 2;  // Another single-line comment.

/*
Multi-line comment.
The comment ends when the ending delimiter is found
(here, it's on the line below).
*/
int b = 3;</literal_block>
                <paragraph>Additionally, you can use documentation comments that are displayed in the
                    inspector when hovering a shader parameter. Documentation comments are currently
                    only supported when placed immediately above a <literal>uniform</literal> declaration. These
                    documentation comments only support the <strong>multiline</strong> comment syntax and must use
                    <strong>two</strong> leading asterisks (<literal>/**</literal>) instead of just one (<literal>/*</literal>):</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">/**
 * This is a documentation comment.
 * These lines will appear in the inspector when hovering the shader parameter
 * named "Something".
 * You can use [b]BBCode[/b] [i]formatting[/i] in the comment.
 */
uniform int something = 1;</literal_block>
                <paragraph>The asterisks on the follow-up lines are not required, but are recommended as
                    per the <reference internal="True" refuri="../shaders_style_guide#doc-shaders-style-guide"><inline classes="std std-ref">着色器风格指南</inline></reference>. These asterisks are automatically
                    stripped by the inspector, so they won't appear in the tooltip.</paragraph>
            </section>
            <section ids="casting" names="casting 类型转换">
                <title>类型转换</title>
                <paragraph>就像GLSL ES 3.0一样, 不允许在标量和相同大小但不同类型的向量之间进行隐式转换. 也不允许铸造不同大小的类型. 转换必须通过构造函数明确完成.</paragraph>
                <paragraph>示例：</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float a = 2; // invalid
float a = 2.0; // valid
float a = float(2); // valid</literal_block>
                <paragraph>默认整数常量是有符号的, 所以转换为无符号总是需要强制类型转换:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">int a = 2; // valid
uint a = 2; // invalid
uint a = uint(2); // valid</literal_block>
            </section>
            <section ids="members" names="members 成员">
                <title>成员</title>
                <paragraph>向量类型的单个标量成员通过 "x" , "y" , "z" 和 "w" 成员访问. 另外, 使用 "r" , "g" , "b" 和 "a" 也可以, 而且是等效的. 使用最适合你的需求的方法.</paragraph>
                <paragraph>对于矩阵，使用 <literal>m[column][row]</literal> 索引语法来访问每个标量，或者 <literal>m[idx]</literal> 按行索引来访问一个向量。例如，为了访问 mat4 中一个对象的 y 位置，使用 <literal>m[3][1]</literal>。</paragraph>
            </section>
            <section ids="constructing" names="constructing 构建">
                <title>构建</title>
                <paragraph>向量类型的构造必须始终通过:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">// The required amount of scalars
vec4 a = vec4(0.0, 1.0, 2.0, 3.0);
// Complementary vectors and/or scalars
vec4 a = vec4(vec2(0.0, 1.0), vec2(2.0, 3.0));
vec4 a = vec4(vec3(0.0, 1.0, 2.0), 3.0);
// A single scalar for the whole vector
vec4 a = vec4(0.0);</literal_block>
                <paragraph>构建矩阵类型需要与矩阵相同维度的向量. 你也可以使用 <literal>matx(float)</literal> 语法构建一个对角矩阵. 相应地, <literal>mat4(1.0)</literal> 是一个单位矩阵.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">mat2 m2 = mat2(vec2(1.0, 0.0), vec2(0.0, 1.0));
mat3 m3 = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));
mat4 identity = mat4(1.0);</literal_block>
                <paragraph>矩阵也可以由另一维度的矩阵建立。有两种规则：</paragraph>
                <paragraph>1. If a larger matrix is constructed from a smaller matrix, the additional rows
                    and columns are set to the values they would have in an identity matrix.
                    2. If a smaller matrix is constructed from a larger matrix, the top, left
                    submatrix of the larger matrix is used.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">mat3 basis = mat3(MODEL_MATRIX);
mat4 m4 = mat4(basis);
mat2 m2 = mat2(m4);</literal_block>
            </section>
            <section ids="swizzling" names="swizzling 混写swizzling">
                <title>混写Swizzling</title>
                <paragraph>只要结果是另一种向量类型(或标量), 就可以以任何顺序获得组件的组合. 这一点展示起来比解释起来容易:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">vec4 a = vec4(0.0, 1.0, 2.0, 3.0);
vec3 b = a.rgb; // Creates a vec3 with vec4 components.
vec3 b = a.ggg; // Also valid; creates a vec3 and fills it with a single vec4 component.
vec3 b = a.bgr; // "b" will be vec3(2.0, 1.0, 0.0).
vec3 b = a.xyz; // Also rgba, xyzw are equivalent.
vec3 b = a.stp; // And stpq (for texture coordinates).
float c = b.w; // Invalid, because "w" is not present in vec3 b.
vec3 c = b.xrt; // Invalid, mixing different styles is forbidden.
b.rrr = a.rgb; // Invalid, assignment with duplication.
b.bgr = a.rgb; // Valid assignment. "b"'s "blue" component will be "a"'s "red" and vice versa.</literal_block>
            </section>
            <section ids="precision" names="precision 精度">
                <title>精度</title>
                <paragraph>可以为数据类型添加精度修饰符；将它们用于 uniform、变量、参数、varying：</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">lowp vec4 a = vec4(0.0, 1.0, 2.0, 3.0); // low precision, usually 8 bits per component mapped to 0-1
mediump vec4 a = vec4(0.0, 1.0, 2.0, 3.0); // medium precision, usually 16 bits or half float
highp vec4 a = vec4(0.0, 1.0, 2.0, 3.0); // high precision, uses full float or integer range (default)</literal_block>
                <paragraph>对某些操作使用较低的精度可以加快相关的数学运算(以较低的精度为代价). 这在顶点处理器功能中很少需要(大部分时间都需要全精度), 但在片段处理器中经常需要.</paragraph>
                <paragraph>一些架构(主要是移动架构)可以从中受益匪浅, 但也有缺点, 比如在不同精度之间转换的额外开销. 请参考目标架构的文档以获得更多信息. 在许多情况下, 移动驱动会导致不一致或意外的行为, 除非有必要, 最好避免指定精度.</paragraph>
            </section>
        </section>
        <section ids="arrays" names="arrays 数组">
            <title>数组</title>
            <paragraph>Arrays are containers for multiple variables of a similar type.</paragraph>
            <section ids="local-arrays" names="local\ arrays 局部数组">
                <title>局部数组</title>
                <paragraph>局部数组在函数中声明. 它们可以使用所有允许的数据类型, 但采样器除外. 数组声明遵循C-style的语法. <literal>[const] + [precision] + typename + identifier + [array size]</literal>.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
    float arr[3];
}</literal_block>
                <paragraph>它们可以在开始时进行初始化, 例如:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float float_arr[3] = float[3] (1.0, 0.5, 0.0); // first constructor

int int_arr[3] = int[] (2, 1, 0); // second constructor

vec2 vec2_arr[3] = { vec2(1.0, 1.0), vec2(0.5, 0.5), vec2(0.0, 0.0) }; // third constructor

bool bool_arr[] = { true, true, false }; // fourth constructor - size is defined automatically from the element count</literal_block>
                <paragraph>你可以在一个表达式中声明多个数组(即使大小不同):</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float a[3] = float[3] (1.0, 0.5, 0.0),
b[2] = { 1.0, 0.5 },
c[] = { 0.7 },
d = 0.0,
e[5];</literal_block>
                <paragraph>要访问一个数组元素, 请使用索引语法:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float arr[3];

arr[0] = 1.0; // setter

COLOR.r = arr[0]; // getter</literal_block>
                <paragraph>数组有一个内置函数 <literal>.length()``(不要与内置的 ``length()</literal> 函数混淆). 它不接受任何参数, 作用是返回数组的大小.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float arr[] = { 0.0, 1.0, 0.5, -1.0 };
for (int i = 0; i &lt; arr.length(); i++) {
    // ...
}</literal_block>
                <note>
                    <paragraph>If you use an index either below 0 or greater than array size - the shader will
                        crash and break rendering. To prevent this, use <literal>length()</literal>, <literal>if</literal>, or
                        <literal>clamp()</literal> functions to ensure the index is between 0 and the array's
                        length. Always carefully test and check your code. If you pass a constant
                        expression or a number, the editor will check its bounds to prevent
                        this crash.</paragraph>
                </note>
            </section>
            <section ids="global-arrays" names="global\ arrays">
                <title>Global arrays</title>
                <paragraph>你可以在全局空间声明数组，例如：</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

const lowp vec3 v[1] = lowp vec3[1] ( vec3(0, 0, 1) );

void fragment() {
  ALBEDO = v[0];
}</literal_block>
                <note>
                    <paragraph>全局数组必须声明为全局常量，否则就可以声明为与本地数组相同的全局常量。</paragraph>
                </note>
            </section>
        </section>
        <section ids="constants" names="constants 常量">
            <title>常量</title>
            <paragraph>在变量声明前使用 <literal>const</literal> 关键字, 可以使该变量成为不可变的, 这意味着它不能被修改. 所有的基本类型, 除了采样器, 都可以被声明为常量. 访问和使用常量值的速度比使用uniform的速度略快. 常量必须在其声明时被初始化.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">const vec2 a = vec2(0.0, 1.0);
vec2 b;

a = b; // invalid
b = a; // valid</literal_block>
            <paragraph>常量不能被修改, 另外也不能有提示, 但可以在一个表达式中声明多个常量(如果它们具有相同的类型), 如</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">const vec2 V1 = vec2(1, 1), V2 = vec2(2, 2);</literal_block>
            <paragraph>与变量类似, 数组也可以用 <literal>const</literal> 来声明.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">const float arr[] = { 1.0, 0.5, 0.0 };

arr[0] = 1.0; // invalid

COLOR.r = arr[0]; // valid</literal_block>
            <paragraph>常量可以在全局(在任何函数之外)或局部(在一个函数之内)进行声明. 当你想在整个着色器中访问一个不需要修改的值时, 全局常量很有用. 像uniform一样, 全局常量在所有着色器阶段之间共享, 但它们在着色器之外是不可访问的.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

const float PI = 3.14159265358979323846;</literal_block>
            <paragraph><literal>float ``类型常量的初始化必须在小数部分后使用</literal>. <literal>符号或使用科学符号。还支持可选的 ``f</literal> 后缀。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float a = 1.0;
float b = 1.0f; // same, using suffix for clarity
float c = 1e-1; // gives 0.1 by using the scientific notation</literal_block>
            <paragraph><literal>uint``（无符号 int）类型的常量必须有后缀 ``u</literal>，以区别于有符号整数。或者，也可以使用 <problematic ids="id2" refid="id1">``</problematic>uint(x)``内置转换函数来实现这一点。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uint a = 1u;
uint b = uint(1);</literal_block>
        </section>
        <section ids="structs" names="structs 结构体">
            <title>结构体</title>
            <paragraph>结构体是一种复合类型，可以对着色器代码进行更好的抽象。你可以像这样在全局作用域进行声明：</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">struct PointLight {
    vec3 position;
    vec3 color;
    float intensity;
};</literal_block>
            <paragraph>声明后可以这样进行实例化和初始化：</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment()
{
    PointLight light;
    light.position = vec3(0.0);
    light.color = vec3(1.0, 0.0, 0.0);
    light.intensity = 0.5;
}</literal_block>
            <paragraph>或者使用结构体的构造函数达到同样的效果：</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">PointLight light = PointLight(vec3(0.0), vec3(1.0, 0.0, 0.0), 0.5);</literal_block>
            <paragraph>结构体中可以包含其他结构体或者数组，你还可以把它们作为全局常量实例化：</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

...

struct Scene {
    PointLight lights[2];
};

const Scene scene = Scene(PointLight[2](PointLight(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.0), PointLight(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.0)));

void fragment()
{
    ALBEDO = scene.lights[0].color;
}</literal_block>
            <paragraph>你还可以把它们传递给函数：</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

...

Scene construct_scene(PointLight light1, PointLight light2) {
    return Scene({light1, light2});
}

void fragment()
{
    COLOR.rgb = construct_scene(PointLight(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.0), PointLight(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0), 1.0)).lights[0].color;
}</literal_block>
        </section>
        <section ids="operators" names="operators 运算符">
            <title>运算符</title>
            <paragraph>Godot 着色器语言支持与GLSL ES 3.0相同的操作符集. 下面是它们的优先级列表:</paragraph>
            <table>
                <tgroup cols="3">
                    <colspec colwidth="13"></colspec>
                    <colspec colwidth="24"></colspec>
                    <colspec colwidth="18"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>优先级</paragraph>
                            </entry>
                            <entry>
                                <paragraph>类</paragraph>
                            </entry>
                            <entry>
                                <paragraph>操作符</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>1（最高）</paragraph>
                            </entry>
                            <entry>
                                <paragraph>括号分组</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>()</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>2</paragraph>
                            </entry>
                            <entry>
                                <paragraph>单目</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>+, -, !, ~</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>3</paragraph>
                            </entry>
                            <entry>
                                <paragraph>乘除法</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>/, *, %</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>4</paragraph>
                            </entry>
                            <entry>
                                <paragraph>加减法</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>+, -</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>5</paragraph>
                            </entry>
                            <entry>
                                <paragraph>移位</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>&lt;&lt;, &gt;&gt;</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>6</paragraph>
                            </entry>
                            <entry>
                                <paragraph>关系比较</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>&lt;, &gt;, &lt;=, &gt;=</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>7</paragraph>
                            </entry>
                            <entry>
                                <paragraph>相等比较</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>==, !=</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>8</paragraph>
                            </entry>
                            <entry>
                                <paragraph>按位与</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>&amp;</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>9</paragraph>
                            </entry>
                            <entry>
                                <paragraph>按位异或</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>^</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>10</paragraph>
                            </entry>
                            <entry>
                                <paragraph>按位或</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>|</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>11</paragraph>
                            </entry>
                            <entry>
                                <paragraph>逻辑与</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>&amp;&amp;</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>12（最低）</paragraph>
                            </entry>
                            <entry>
                                <paragraph>逻辑或</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>||</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section ids="flow-control" names="flow\ control 流控制">
            <title>流控制</title>
            <paragraph>Godot 着色器语言支持最常见的控制流类型：</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">// `if` and `else`.
if (cond) {

} else {

}

// Ternary operator.
// This is an expression that behaves like `if`/`else` and returns the value.
// If `cond` evaluates to `true`, `result` will be `9`.
// Otherwise, `result` will be `5`.
int result = cond ? 9 : 5;

// `switch`.
switch (i) { // `i` should be a signed integer expression.
    case -1:
        break;
    case 0:
        return; // `break` or `return` to avoid running the next `case`.
    case 1: // Fallthrough (no `break` or `return`): will run the next `case`.
    case 2:
        break;
    //...
    default: // Only run if no `case` above matches. Optional.
        break;
}

// `for` loop. Best used when the number of elements to iterate on
// is known in advance.
for (int i = 0; i &lt; 10; i++) {

}

// `while` loop. Best used when the number of elements to iterate on
// is not known in advance.
while (cond) {

}

// `do while`. Like `while`, but always runs at least once even if `cond`
// never evaluates to `true`.
do {

} while (cond);</literal_block>
            <paragraph>Keep in mind that in modern GPUs, an infinite loop can exist and can freeze
                your application (including editor). Godot can't protect you from this, so be
                careful not to make this mistake!</paragraph>
            <paragraph>此外，在将浮点数值与数字进行比较时，请确保将其与*范围*而非精确数字进行比较。</paragraph>
            <paragraph>像 <literal>if (value == 0.3)</literal> 这样的比较可能不会求得``true``。浮点运算通常是近似的，可能违背预期。根据硬件的不同，它的表现也可能不同。</paragraph>
            <paragraph><strong>不要</strong> 写 "of the X"。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float value = 0.1 + 0.2;

// May not evaluate to `true`!
if (value == 0.3) {
    // ...
}</literal_block>
            <paragraph>相反，应始终使用ε进行范围比较。浮点数越大（浮点数越不精确），ε值就应该越大。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">const float EPSILON = 0.0001;
if (value &gt;= 0.3 - EPSILON &amp;&amp; value &lt;= 0.3 + EPSILON) {
    // ...
}</literal_block>
            <paragraph>See <reference name="floating-point-gui.de" refuri="https://floating-point-gui.de/">floating-point-gui.de</reference> for more
                information.</paragraph>
        </section>
        <section ids="discarding" names="discarding 丢弃">
            <title>丢弃</title>
            <paragraph>Fragment and light functions can use the <literal>discard</literal> keyword. If used, the
                fragment is discarded and nothing is written.</paragraph>
            <paragraph>请注意，使用 <literal>discard</literal> 时会产生性能代价，因为它会阻止深度预传递在使用着色器的任何表面上生效。此外，被丢弃的像素仍需在顶点着色器中进行渲染，这意味着对所有像素都使用 <literal>discard</literal> 的着色器与不渲染任何对象相比，渲染成本仍然更高。</paragraph>
        </section>
        <section ids="functions" names="functions 函数">
            <title>函数</title>
            <paragraph>可以在Godot着色器中定义函数. 它们使用以下语法:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">ret_type func_name(args) {
    return ret_type; // if returning a value
}

// a more specific example:

int sum2(int a, int b) {
    return a + b;
}</literal_block>
            <paragraph>You can only use functions that have been defined above (higher in the editor)
                the function from which you are calling them. Redefining a function that has
                already been defined above (or is a built-in function name) will cause an error.</paragraph>
            <paragraph>函数参数可以有特殊的限定符:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph><strong>in</strong> : 表示参数仅用于读取(默认).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>out</strong> : 表示该参数只用于写入.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>inout</strong> : 表示该参数以引用传递.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>const</strong>：表示参数是常量，不能更改，可与 <strong>in</strong> 限定符结合使用。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>示例:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void sum2(int a, int b, inout int result) {
    result = a + b;
}</literal_block>
            <note>
                <paragraph>与 GLSL 不同，Godot 的着色器语言不支持函数重载。这意味着一个函数不能用不同的参数类型或参数个数定义多次。作为一种变通方法，可以为接受不同数量或不同类型参数的函数使用不同的名称。</paragraph>
            </note>
        </section>
        <section ids="varyings" names="varyings varying">
            <title>Varying</title>
            <paragraph>要从顶点处理器函数往片段（或者灯光）处理器函数里发送数据，可以使用 <emphasis>varying</emphasis>。<emphasis>顶点处理器</emphasis>中的每一个图元顶点都是 varying 的，会为<emphasis>片段处理器</emphasis>中的每一个像素做插值。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

varying vec3 some_color;

void vertex() {
    some_color = NORMAL; // Make the normal the color.
}

void fragment() {
    ALBEDO = some_color;
}

void light() {
    DIFFUSE_LIGHT = some_color * 100; // optionally
}</literal_block>
            <paragraph>Varying 也可以是数组：</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

varying float var_arr[3];

void vertex() {
    var_arr[0] = 1.0;
    var_arr[1] = 0.0;
}

void fragment() {
    ALBEDO = vec3(var_arr[0], var_arr[1], var_arr[2]); // red color
}</literal_block>
            <paragraph>也可以使用 <emphasis>varying</emphasis> 关键字将数据从<emphasis>片段</emphasis>处理器送往<emphasis>灯光</emphasis>处理器。在 <emphasis>fragment</emphasis> 函数中赋值，然后在 <emphasis>light</emphasis> 函数中使用即可。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

varying vec3 some_light;

void fragment() {
    some_light = ALBEDO * 100.0; // Make a shining light.
}

void light() {
    DIFFUSE_LIGHT = some_light;
}</literal_block>
            <paragraph>注意，在自定义函数或<emphasis>灯光处理器</emphasis>中是不能为 varying 赋值的：</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

varying float test;

void foo() {
    test = 0.0; // Error.
}

void vertex() {
    test = 0.0;
}

void light() {
    test = 0.0; // Error too.
}</literal_block>
            <paragraph>加入这一限制的目的是为了防止在初始化前进行错误的使用。</paragraph>
        </section>
        <section ids="interpolation-qualifiers" names="interpolation\ qualifiers 插值限定符">
            <title>插值限定符</title>
            <paragraph>在着色管线期间内插某些值. 你可以使用 <emphasis>插值限定符</emphasis> 修改这些插值的完成方式.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

varying flat vec3 our_color;

void vertex() {
    our_color = COLOR.rgb;
}

void fragment() {
    ALBEDO = our_color;
}</literal_block>
            <paragraph>有两种可能的插值限定符:</paragraph>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="19"></colspec>
                    <colspec colwidth="81"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>限定符</paragraph>
                            </entry>
                            <entry>
                                <paragraph>描述</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><strong>flat</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>该值未插值.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>smooth</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>该值以透视正确的方式进行插值. 这是默认值.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section ids="uniforms" names="uniforms uniform">
            <title>Uniform</title>
            <paragraph>可以将值传递给着色器。这些值对整个着色器来说是全局的，被称为 <emphasis>uniform</emphasis>。当一个着色器后来被分配给一个材质时，uniform 将作为可编辑的参数出现在其中。uniform 不能从着色器内部写入。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

uniform float some_value;

uniform vec3 colors[3];</literal_block>
            <paragraph>你可以在编辑器中设置材质中的 uniform。或者你可以通过 GDScript 来设置它们：</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">material.set_shader_parameter("some_value", some_value)

material.set_shader_parameter("colors", [Vector3(1, 0, 0), Vector3(0, 1, 0), Vector3(0, 0, 1)])</literal_block>
            <note>
                <paragraph>The first argument to <literal>set_shader_parameter</literal> is the name of the uniform
                    in the shader. It must match <emphasis>exactly</emphasis> to the name of the uniform in
                    the shader or else it will not be recognized.</paragraph>
            </note>
            <paragraph>除了 <emphasis>void</emphasis> 之外，任何 GLSL 类型都可以成为 uniform。此外，Godot 还提供了可选的着色器提示，以使编译器了解 uniform 是用来干什么的，以及编辑器应该让用户进行何种修改。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

uniform vec4 color : source_color;
uniform float amount : hint_range(0, 1);
uniform vec4 other_color : source_color = vec4(1.0); // Default values go after the hint.
uniform sampler2D image : source_color;</literal_block>
            <paragraph>It's important to understand that textures <emphasis>that are supplied as color</emphasis> require
                hints for proper sRGB -&gt; linear conversion (i.e. <literal>source_color</literal>), as Godot's
                3D engine renders in linear color space. If this is not done, the texture will
                appear washed out.</paragraph>
            <note>
                <paragraph>如果启用了**渲染 &gt; 视口 &gt; HDR 2D**项目设置，2D 渲染器也会以线性色彩空间进行渲染，因此``source_color``也必须在``canvas_item``着色器中使用。如果禁用了 2D HDR，<literal>source_color</literal> 将继续在``canvas_item``着色器中正常工作，因此建议无论如何都使用它。</paragraph>
            </note>
            <paragraph>以下是完整的提示列表：</paragraph>
            <table>
                <tgroup cols="3">
                    <colspec colwidth="22"></colspec>
                    <colspec colwidth="50"></colspec>
                    <colspec colwidth="77"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>类型</paragraph>
                            </entry>
                            <entry>
                                <paragraph>提示</paragraph>
                            </entry>
                            <entry>
                                <paragraph>描述</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><strong>vec3, vec4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>source_color</paragraph>
                            </entry>
                            <entry>
                                <paragraph>用作颜色。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>int、float</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>hint_range(min,max [,step] )</paragraph>
                            </entry>
                            <entry>
                                <paragraph>限制取值范围（最小值/最大值/步长）。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>source_color</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Used as albedo color.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>hint_normal</paragraph>
                            </entry>
                            <entry>
                                <paragraph>用作法线贴图。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>hint_default_white</paragraph>
                            </entry>
                            <entry>
                                <paragraph>As value or albedo color, default to opaque white.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>hint_default_black</paragraph>
                            </entry>
                            <entry>
                                <paragraph>As value or albedo color, default to opaque black.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>hint_default_transparent</paragraph>
                            </entry>
                            <entry>
                                <paragraph>As value or albedo color, default to transparent black.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>hint_anisotropy</paragraph>
                            </entry>
                            <entry>
                                <paragraph>作为 FlowMap，默认为右。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>hint_roughness[_r, _g, _b, _a, _normal, _gray]</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Used for roughness limiter on import (attempts reducing specular aliasing).
                                    <literal>_normal</literal> is a normal map that guides the roughness limiter,
                                    with roughness increasing in areas that have high-frequency detail.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>filter[_nearest, _linear][_mipmap][_anisotropic]</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Enabled specified texture filtering.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>repeat[_enable, _disable]</paragraph>
                            </entry>
                            <entry>
                                <paragraph>启用纹理重复。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>hint_screen_texture</paragraph>
                            </entry>
                            <entry>
                                <paragraph>纹理是屏幕纹理。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>hint_depth_texture</paragraph>
                            </entry>
                            <entry>
                                <paragraph>纹理是深度纹理。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>hint_normal_roughness_texture</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Texture is the normal roughness texture (only supported in Forward+).</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <paragraph>GDScript 使用的变量类型与 GLSL 不同，所以当把变量从 GDScript 传递到着色器时，Godot 会自动转换类型。以下是相应类型的表格：</paragraph>
            <table>
                <tgroup cols="3">
                    <colspec colwidth="22"></colspec>
                    <colspec colwidth="25"></colspec>
                    <colspec colwidth="60"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>GLSL 类型</paragraph>
                            </entry>
                            <entry>
                                <paragraph>GDScript 类型</paragraph>
                            </entry>
                            <entry>
                                <paragraph>注意</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><strong>bool</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>bool</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>bvec2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>int</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Bitwise packed int where bit 0 (LSB) corresponds to x.</paragraph>
                                <paragraph>For example, a bvec2 of (bx, by) could be created in
                                    the following way:</paragraph>
                                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">bvec2_input: int = (int(bx)) | (int(by) &lt;&lt; 1)</literal_block>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>bvec3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>int</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Bitwise packed int where bit 0 (LSB) corresponds to x.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>bvec4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>int</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Bitwise packed int where bit 0 (LSB) corresponds to x.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>int</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>int</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>ivec2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Vector2i</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>ivec3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Vector3i</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>ivec4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Vector4i</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>uint</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>int</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>uvec2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Vector2i</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>uvec3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Vector3i</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>uvec4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Vector4i</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>float</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>float</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>vec2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Vector2</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>vec3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Vector3</strong>, <strong>Color</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>When Color is used, it will be interpreted as (r, g, b).</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>vec4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Vector4</strong>, <strong>Color</strong>,
                                    <strong>Rect2</strong>, <strong>Plane</strong>,
                                    <strong>Quaternion</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>When Color is used, it will be interpreted as (r, g, b, a).</paragraph>
                                <paragraph>When Rect2 is used, it will be interpreted as
                                    (position.x, position.y, size.x, size.y).</paragraph>
                                <paragraph>When Plane is used it will be interpreted as
                                    (normal.x, normal.y, normal.z, d).</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>mat2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Transform2D</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>mat3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Basis</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>mat4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Projection</strong>,
                                    <strong>Transform3D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>When a Transform3D is used, the w Vector is set to the
                                    identity.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Texture2D</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>isampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Texture2D</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>usampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Texture2D</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2DArray</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Texture2DArray</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>isampler2DArray</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Texture2DArray</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>usampler2DArray</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Texture2DArray</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler3D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Texture3D</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>isampler3D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Texture3D</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>usampler3D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Texture3D</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>samplerCube</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>Cubemap</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>samplerCubeArray</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>CubemapArray</strong></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <note>
                <paragraph>当从 GDScript 中设置着色器 uniform 时要小心，如果类型不匹配，不会产生错误。你的着色器只会表现出未定义的行为。</paragraph>
            </note>
            <paragraph>Uniform 也可以分配默认值：</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

uniform vec4 some_vector = vec4(0.0);
uniform vec4 some_color : source_color = vec4(1.0);</literal_block>
            <paragraph>Note that when adding a default value and a hint, the default value goes after the hint.</paragraph>
            <paragraph>If you need to make multiple uniforms to be grouped in the specific category of an inspector, you can use a <title_reference>group_uniform</title_reference> keyword like:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">group_uniforms MyGroup;
uniform sampler2D test;</literal_block>
            <paragraph>You can close the group by using:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">group_uniforms;</literal_block>
            <paragraph>The syntax also supports subgroups (it's not mandatory to declare the base group before this):</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">group_uniforms MyGroup.MySubgroup;</literal_block>
            <section ids="global-uniforms" names="global\ uniforms 全局\ uniform">
                <title>全局 Uniform</title>
                <paragraph>Sometimes, you want to modify a parameter in many different shaders at once.
                    With a regular uniform, this takes a lot of work as all these shaders need to be
                    tracked and the uniform needs to be set for each of them. Global uniforms allow
                    you to create and update uniforms that will be available in all shaders, in
                    every shader type (<literal>canvas_item</literal>, <literal>spatial</literal>, <literal>particles</literal>, <literal>sky</literal> and
                    <literal>fog</literal>).</paragraph>
                <paragraph>Global uniforms are especially useful for environmental effects that affect many
                    objects in a scene, like having foliage bend when the player is nearby, or having
                    objects move with the wind.</paragraph>
                <paragraph>To create a global uniform, open the <strong>Project Settings</strong> then go to the
                    <strong>Shader Globals</strong> tab. Specify a name for the uniform (case-sensitive) and a
                    type, then click <strong>Add</strong> in the top-right corner of the dialog. You can then
                    edit the value assigned to the uniform by clicking the value in the list of
                    uniforms:</paragraph>
                <figure align="center" ids="id1">
                    <image alt="在“项目设置”的“着色器全局量”中添加全局 uniform" candidates="{'*': 'tutorials/shaders/shader_reference/img/shading_language_adding_global_uniforms.webp'}" uri="tutorials/shaders/shader_reference/img/shading_language_adding_global_uniforms.webp"></image>
                    <caption>在“项目设置”的“着色器全局量”中添加全局 uniform</caption>
                </figure>
                <paragraph>创建全局 uniform 之后，在着色器中的使用方法如下：</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

global uniform vec4 my_color;

void fragment() {
    COLOR = my_color.rgb;
}</literal_block>
                <paragraph>请注意，保存着色器的时候该全局 uniform <emphasis>必须</emphasis>在“项目设置”中存在，否则编译就会失败。虽然可以在着色器代码中使用 <literal>global uniform vec4 my_color = ...</literal> 赋默认值，但是这个默认值会被忽略，因为全局 uniform 必须在“项目设置”中定义。</paragraph>
                <paragraph>要在运行时修改全局 uniform 的值，请在脚本中使用 <reference internal="True" refuri="../../../classes/class_renderingserver#class-renderingserver-method-global-shader-parameter-set"><inline classes="std std-ref">RenderingServer.global_shader_parameter_set</inline></reference> 方法：</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">RenderingServer.global_shader_parameter_set("my_color", Color(0.3, 0.6, 1.0))</literal_block>
                <paragraph>全局 uniform 可以重复赋值，不会影响性能，因为设置数据不需要在 CPU 和 GPU 之间进行同步。</paragraph>
                <paragraph>你还可以在运行时添加和移除全局 uniform：</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">RenderingServer.global_shader_parameter_add("my_color", RenderingServer.GLOBAL_VAR_TYPE_COLOR, Color(0.3, 0.6, 1.0))
RenderingServer.global_shader_parameter_remove("my_color")</literal_block>
                <paragraph>在运行时添加和移除全局 uniform 存在一定的性能开销，但是不会像从脚本中获取全局 uniform 值的开销一样大（见下面的警告）。</paragraph>
                <warning>
                    <paragraph>运行时，虽然<emphasis>可以</emphasis>在脚本中使用 <literal>RenderingServer.global_shader_parameter_get("uniform_name")</literal> 来查询全局 uniform 的取值，但是这样做有很大的性能开销，因为需要进行调用线程与渲染线程的同步。</paragraph>
                    <paragraph>因此，不建议在脚本中频繁读取全局着色器 uniform 的取值。如果你需要在设值之后用脚本读取，请考虑创建一个<reference internal="True" refuri="../../scripting/singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">自动加载</inline></reference>，在设置需要查询的全局 uniform 的同时保存对应的值。</paragraph>
                </warning>
                <target refid="doc-shading-language-per-instance-uniforms"></target>
            </section>
            <section ids="per-instance-uniforms doc-shading-language-per-instance-uniforms" names="per-instance\ uniforms 单实例\ uniform doc_shading_language_per_instance_uniforms">
                <title>单实例 uniform</title>
                <note>
                    <paragraph>只有 <literal>spatial</literal>（3D）着色器中才可以使用单实例 uniform。</paragraph>
                </note>
                <note>
                    <paragraph>Per-instance uniforms are not supported when using the Compatibility renderer.</paragraph>
                </note>
                <paragraph>Sometimes, you want to modify a parameter on each node using the material. As an
                    example, in a forest full of trees, when you want each tree to have a slightly
                    different color that is editable by hand. Without per-instance uniforms, this
                    requires creating a unique material for each tree (each with a slightly
                    different hue). This makes material management more complex, and also has a
                    performance overhead due to the scene requiring more unique material instances.
                    Vertex colors could also be used here, but they'd require creating unique copies
                    of the mesh for each different color, which also has a performance overhead.</paragraph>
                <paragraph>Per-instance uniforms are set on each GeometryInstance3D, rather than on each
                    Material instance. Take this into account when working with meshes that have
                    multiple materials assigned to them, or MultiMesh setups.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

// Provide a hint to edit as a color. Optionally, a default value can be provided.
// If no default value is provided, the type's default is used (e.g. opaque black for colors).
instance uniform vec4 my_color : source_color = vec4(1.0, 0.5, 0.0, 1.0);

void fragment() {
    ALBEDO = my_color.rgb;
}</literal_block>
                <paragraph>After saving the shader, you can change the per-instance uniform's value using
                    the inspector:</paragraph>
                <figure align="center" ids="id2">
                    <image alt="Setting a per-instance uniform's value in the GeometryInstance3D section of the inspector" candidates="{'*': 'tutorials/shaders/shader_reference/img/shading_language_per_instance_uniforms_inspector.webp'}" uri="tutorials/shaders/shader_reference/img/shading_language_per_instance_uniforms_inspector.webp"></image>
                    <caption>Setting a per-instance uniform's value in the GeometryInstance3D section of the inspector</caption>
                </figure>
                <paragraph>Per-instance uniform values can also be set at run-time using
                    <reference internal="True" refuri="../../../classes/class_geometryinstance3d#class-geometryinstance3d-method-set-instance-shader-parameter"><inline classes="std std-ref">set_instance_shader_parameter</inline></reference>
                    method on a node that inherits from <reference internal="True" refuri="../../../classes/class_geometryinstance3d#class-geometryinstance3d"><inline classes="std std-ref">GeometryInstance3D</inline></reference>:</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">$MeshInstance3D.set_instance_shader_parameter("my_color", Color(0.3, 0.6, 1.0))</literal_block>
                <paragraph>When using per-instance uniforms, there are some restrictions you should be aware of:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Per-instance uniforms do not support textures</strong>, only regular scalar and
                            vector types. As a workaround, you can pass a texture array as a regular
                            uniform, then pass the index of the texture to be drawn using a per-instance
                            uniform.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>There is a practical maximum limit of 16 instance uniforms per shader.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>If your mesh uses multiple materials, the parameters for the first mesh
                            material found will "win" over the subsequent ones, unless they have the same
                            name, index <emphasis>and</emphasis> type. In this case, all parameters are affected correctly.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>If you run into the above situation, you can avoid clashes by manually
                            specifying the index (0-15) of the instance uniform by using the
                            <literal>instance_index</literal> hint:</paragraph>
                    </list_item>
                </bullet_list>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">instance uniform vec4 my_color : source_color, instance_index(5);</literal_block>
            </section>
        </section>
        <section ids="built-in-variables" names="built-in\ variables 内置变量">
            <title>内置变量</title>
            <paragraph>A large number of built-in variables are available, like <literal>UV</literal>, <literal>COLOR</literal> and <literal>VERTEX</literal>. What variables are available depends on the type of shader (<literal>spatial</literal>, <literal>canvas_item</literal> or <literal>particle</literal>) and the function used (<literal>vertex</literal>, <literal>fragment</literal> or <literal>light</literal>).
                For a list of the built-in variables that are available, please see the corresponding pages:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="spatial_shader#doc-spatial-shader"><inline classes="std std-ref">空间着色器</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">画布物品着色器</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="particle_shader#doc-particle-shader"><inline classes="std std-ref">粒子着色器</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="sky_shader#doc-sky-shader"><inline classes="std std-ref">Sky shaders</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="fog_shader#doc-fog-shader"><inline classes="std std-ref">Fog shaders</inline></reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="built-in-functions" names="built-in\ functions 内置函数">
            <title>内置函数</title>
            <paragraph>支持大量的内置函数, 符合GLSL ES 3.0. 当使用 vec_type (float), vec_int_type, vec_uint_type, vec_bool_type 命名法时, 它可以是标量或向量.</paragraph>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="77"></colspec>
                    <colspec colwidth="69"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>函数</paragraph>
                            </entry>
                            <entry>
                                <paragraph>描述/返回值</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>radians</strong> (vec_type degrees度)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>将度数转换为弧度。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>degrees</strong> ( vec_type radians弧度)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>将弧度转换为度数。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>sin</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>正弦。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>cos</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>余弦。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>tan</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>正切。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>asin</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>反正弦。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>acos</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>反余弦。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>atan</strong> (vec_type y_over_x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>反正切。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>atan</strong> (vec_type y, vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>反正切。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>sinh</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>双曲正弦。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>cosh</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>双曲余弦。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>tanh</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>双曲正切。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>asinh</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>反双曲正弦。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>acosh</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>反双曲余弦。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>atanh</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>反双曲正切。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>pow</strong> (vec_type x, vec_type y)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>幂（<literal>x</literal> &lt; 0 或 <literal>x</literal> = 0 且 <literal>y</literal> &lt;= 0 时未定义）。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>exp</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>基数 e 的指数。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>exp2</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>基数 2 的指数。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>log</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>自然对数。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>log2</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>基数 2 的对数。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>sqrt</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>平方根。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>inversesqrt</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>反平方根。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>abs</strong> (vec_type x)</paragraph>
                                <paragraph>ivec_type <strong>abs</strong> (ivec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Absolute value (returns positive value if negative).</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>sign</strong> ( vec_type )</paragraph>
                                <paragraph>ivec_type <strong>sign</strong> (ivec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sign (returns <literal>1.0</literal> if positive, <literal>-1.0</literal> if negative,
                                    <literal>0.0</literal> if zero).</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>floor</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>向下舍入为整数。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>round</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>舍入到最接近的整数。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>roundEven</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>舍入到最接近的偶数。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>trunc</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>截断。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>ceil</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>向上舍入为整数。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>fract</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Fractional (returns <literal>x - floor(x)</literal>).</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>mod</strong> (vec_type x, vec_type y)</paragraph>
                                <paragraph>vec_type <strong>mod</strong> (vec_type x, float y)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>模（除法余数）。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>modf</strong> (vec_type x, out vec_type i)</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>x</literal> 的小数部分，<literal>i</literal> 为整数部分。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>min</strong> (vec_type a, vec_type b)</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>a</literal> 和 <literal>b</literal> 之间的较小值。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>max</strong> (vec_type a, vec_type b)</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>a</literal> 和 <literal>b</literal> 之间的较大值。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>clamp</strong> (vec_type x, vec_type min, vec_type max)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Clamp <literal>x</literal> between <literal>min</literal> and <literal>max</literal> (inclusive).</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>float <strong>mix</strong> (float a, float b, float c)</paragraph>
                                <paragraph>vec_type <strong>mix</strong> (vec_type a, vec_type b, float c)</paragraph>
                                <paragraph>vec_type <strong>mix</strong> (vec_type a, vec_type b, bvec_type c)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>根据 <literal>c</literal> 在 <literal>a</literal> 和 <literal>b</literal> 之间进行线性插值。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>fma</strong> (vec_type a, vec_type b, vec_type c)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Performs a fused multiply-add operation: <literal>(a * b + c)</literal>
                                    (faster than doing it manually).</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>step</strong> (vec_type a, vec_type b)</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>b[i] &lt; a[i] ? 0.0 : 1.0</literal>。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>step</strong> (float a, vec_type b)</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>b[i] &lt; a ? 0.0 : 1.0</literal>。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>smoothstep</strong> (vec_type a, vec_type b, vec_type c)</paragraph>
                                <paragraph>vec_type <strong>smoothstep</strong> (float a, float b, vec_type c)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Hermite interpolate between <literal>a</literal> and <literal>b</literal> by <literal>c</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>bvec_type <strong>isnan</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>如果标量或向量分量是 <literal>NaN</literal> 则返回 <literal>true</literal>。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>bvec_type <strong>isinf</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>如果标量或向量分量是 <literal>INF</literal> , 则返回 <literal>true</literal>。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>ivec_type <strong>floatBitsToInt</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Float-&gt;Int 位复制，无转换。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>uvec_type <strong>floatBitsToUint</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Float-&gt;UInt 位复制，无转换。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>intBitsToFloat</strong> (ivec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Int-&gt; Float 位复制，无转换。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>uintBitsToFloat</strong> (uvec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>UInt-&gt;Float 位复制，无转换。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>float <strong>length</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>向量长度。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>float <strong>distance</strong> (vec_type a, vec_type b)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>向量间距，即 <literal>length(a - b)</literal>。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>float <strong>dot</strong> (vec_type a, vec_type b)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>点积。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec3 <strong>cross</strong> (vec3 a, vec3 b)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>叉积。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>normalize</strong> (vec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>标准化为单位长度。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec3 <strong>reflect</strong> (vec3 I, vec3 N)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>反射。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec3 <strong>refract</strong> (vec3 I, vec3 N, float eta)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>折射。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>faceforward</strong> (vec_type N, vec_type I, vec_type Nref)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>如果 <literal>dot(Nref, I)</literal> &lt;0, 则返回N, 否则返回-N。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>mat_type <strong>matrixCompMult</strong> (mat_type x, mat_type y)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>矩阵分量乘法。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>mat_type <strong>outerProduct</strong> (vec_type column, vec_type row)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>矩阵外积。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>mat_type <strong>transpose</strong> (mat_type m)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>转置矩阵。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>float <strong>determinant</strong> (mat_type m)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>矩阵行列式。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>mat_type <strong>inverse</strong> (mat_type m)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>逆矩阵。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>bvec_type <strong>lessThan</strong> (vec_type x, vec_type y)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Bool vector 对比 &lt; int/uint/float vectors。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>bvec_type <strong>greaterThan</strong> (vec_type x, vec_type y)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Bool vector 对比 &gt; int/uint/float vectors。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>bvec_type <strong>lessThanEqual</strong> (vec_type x, vec_type y)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Bool vector 对比 &lt;= int/uint/float vectors。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>bvec_type <strong>greaterThanEqual</strong> (vec_type x, vec_type y)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Bool vector 对比 &gt;= int/uint/float vectors。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>bvec_type <strong>equal</strong> (vec_type x, vec_type y)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Bool vector 对比 == int/uint/float vectors。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>bvec_type <strong>notEqual</strong> (vec_type x, vec_type y)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Bool vector 对比 != int/uint/float vectors。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>bool <strong>any</strong> (bvec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>true</literal> if any component is <literal>true</literal>, <literal>false</literal> otherwise.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>bool <strong>all</strong> (bvec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>true</literal> if all components are <literal>true</literal>, <literal>false</literal> otherwise.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>bvec_type <strong>not</strong> (bvec_type x)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>反转布尔向量。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>ivec2 <strong>textureSize</strong> (gsampler2D s, int lod)</paragraph>
                                <paragraph>ivec3 <strong>textureSize</strong> (gsampler2DArray s, int lod)</paragraph>
                                <paragraph>ivec3 <strong>textureSize</strong> (gsampler3D s, int lod)</paragraph>
                                <paragraph>ivec2 <strong>textureSize</strong> (samplerCube s, int lod)</paragraph>
                                <paragraph>ivec2 <strong>textureSize</strong> (samplerCubeArray s, int lod)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>获取纹理的大小。</paragraph>
                                <paragraph>The LOD defines which mipmap level is used. An LOD value of <literal>0</literal>
                                    will use the full resolution texture.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec2 <strong>textureQueryLod</strong> (gsampler2D s, vec2 p)</paragraph>
                                <paragraph>vec3 <strong>textureQueryLod</strong> (gsampler2DArray s, vec2 p)</paragraph>
                                <paragraph>vec2 <strong>textureQueryLod</strong> (gsampler3D s, vec3 p)</paragraph>
                                <paragraph>vec2 <strong>textureQueryLod</strong> (samplerCube s, vec3 p)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Compute the level-of-detail that would be used to sample from a
                                    texture. The <literal>x</literal> component of the resulted value is the mipmap
                                    array that would be accessed. The <literal>y</literal> component is computed
                                    level-of-detail relative to the base level (regardless of the
                                    mipmap levels of the texture).</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>int <strong>textureQueryLevels</strong> (gsampler2D s)</paragraph>
                                <paragraph>int <strong>textureQueryLevels</strong> (gsampler2DArray s)</paragraph>
                                <paragraph>int <strong>textureQueryLevels</strong> (gsampler3D s)</paragraph>
                                <paragraph>int <strong>textureQueryLevels</strong> (samplerCube s)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>获取cubemap纹理的大小。</paragraph>
                                <paragraph>If the texture is unassigned to a sampler, <literal>1</literal> is returned (Godot
                                    always internally assigns a texture even to an empty sampler).</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>gvec4_type <strong>texture</strong> (gsampler2D s, vec2 p [, float bias])</paragraph>
                                <paragraph>gvec4_type <strong>texture</strong> (gsampler2DArray s, vec3 p [, float bias])</paragraph>
                                <paragraph>gvec4_type <strong>texture</strong> (gsampler3D s, vec3 p [, float bias])</paragraph>
                                <paragraph>vec4 <strong>texture</strong> (samplerCube s, vec3 p [, float bias])</paragraph>
                                <paragraph>vec4 <strong>texture</strong> (samplerCubeArray s, vec4 p [, float bias])</paragraph>
                            </entry>
                            <entry>
                                <paragraph>执行纹理读取。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>gvec4_type <strong>textureProj</strong> (gsampler2D s, vec3 p [, float bias])</paragraph>
                                <paragraph>gvec4_type <strong>textureProj</strong> (gsampler2D s, vec4 p [, float bias])</paragraph>
                                <paragraph>gvec4_type <strong>textureProj</strong> (gsampler3D s, vec4 p [, float bias])</paragraph>
                            </entry>
                            <entry>
                                <paragraph>执行带投影的纹理读取。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>gvec4_type <strong>textureLod</strong> (gsampler2D s, vec2 p, float lod)</paragraph>
                                <paragraph>gvec4_type <strong>textureLod</strong> (gsampler2DArray s, vec3 p, float lod)</paragraph>
                                <paragraph>gvec4_type <strong>textureLod</strong> (gsampler3D s, vec3 p, float lod)</paragraph>
                                <paragraph>vec4 <strong>textureLod</strong> (samplerCube s, vec3 p, float lod)</paragraph>
                                <paragraph>vec4 <strong>textureLod</strong> (samplerCubeArray s, vec4 p, float lod)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>在自定义 mipmap 上执行纹理读取。</paragraph>
                                <paragraph>The LOD defines which mipmap level is used. An LOD value of <literal>0.0</literal>
                                    will use the full resolution texture. If the texture lacks mipmaps,
                                    all LOD values will act like <literal>0.0</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>gvec4_type <strong>textureProjLod</strong> (gsampler2D s, vec3 p, float lod)</paragraph>
                                <paragraph>gvec4_type <strong>textureProjLod</strong> (gsampler2D s, vec4 p, float lod)</paragraph>
                                <paragraph>gvec4_type <strong>textureProjLod</strong> (gsampler3D s, vec4 p, float lod)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>执行带投影/LOD的2D纹理读取。</paragraph>
                                <paragraph>The LOD defines which mipmap level is used. An LOD value of <literal>0.0</literal>
                                    will use the full resolution texture. If the texture lacks mipmaps,
                                    all LOD values will act like <literal>0.0</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>gvec4_type <strong>textureGrad</strong> (gsampler2D s, vec2 p, vec2 dPdx,
                                    vec2 dPdy)</paragraph>
                                <paragraph>gvec4_type <strong>textureGrad</strong> (gsampler2DArray s, vec3 p, vec2 dPdx,
                                    vec2 dPdy)</paragraph>
                                <paragraph>gvec4_type <strong>textureGrad</strong> (gsampler3D s, vec3 p, vec2 dPdx,
                                    vec2 dPdy)</paragraph>
                                <paragraph>vec4 <strong>textureGrad</strong> (samplerCube s, vec3 p, vec3 dPdx, vec3 dPdy)</paragraph>
                                <paragraph>vec4 <strong>textureGrad</strong> (samplerCubeArray s, vec3 p, vec3 dPdx,
                                    vec3 dPdy)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>执行带显式渐变的纹理读取。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>gvec4_type <strong>textureProjGrad</strong> (gsampler2D s, vec3 p, vec2 dPdx, vec2 dPdy)</paragraph>
                                <paragraph>gvec4_type <strong>textureProjGrad</strong> (gsampler2D s, vec4 p, vec2 dPdx, vec2 dPdy)</paragraph>
                                <paragraph>gvec4_type <strong>textureProjGrad</strong> (gsampler3D s, vec4 p, vec3 dPdx, vec3 dPdy)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Performs a texture read with projection/LOD and with explicit
                                    gradients.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>gvec4_type <strong>texelFetch</strong> (gsampler2D s, ivec2 p, int lod)</paragraph>
                                <paragraph>gvec4_type <strong>texelFetch</strong> (gsampler2DArray s, ivec3 p, int lod)</paragraph>
                                <paragraph>gvec4_type <strong>texelFetch</strong> (gsampler3D s, ivec3 p, int lod)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>使用整数坐标获取单个纹素。</paragraph>
                                <paragraph>The LOD defines which mipmap level is used. An LOD value of <literal>0</literal>
                                    will use the full resolution texture.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>gvec4_type <strong>textureGather</strong> (gsampler2D s, vec2 p [, int comps])</paragraph>
                                <paragraph>gvec4_type <strong>textureGather</strong> (gsampler2DArray s, vec3 p [, int comps])</paragraph>
                                <paragraph>vec4 <strong>textureGather</strong> (samplerCube s, vec3 p [, int comps])</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Gathers four texels from a texture.
                                    Use <literal>comps</literal> within range of 0..3 to
                                    define which component (x, y, z, w) is returned.
                                    If <literal>comps</literal> is not provided: 0 (or x-component) is used.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>dFdx</strong> (vec_type p)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Derivative in <literal>x</literal> using local differencing.
                                    Internally, can use either <literal>dFdxCoarse</literal> or <literal>dFdxFine</literal>, but the
                                    decision for which to use is made by the GPU driver.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>dFdxCoarse</strong> (vec_type p)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Calculates derivative with respect to <literal>x</literal> window coordinate using
                                    local differencing based on the value of <literal>p</literal> for the current
                                    fragment neighbour(s), and will possibly, but not necessarily,
                                    include the value for the current fragment.
                                    This function is not available on <literal>gl_compatibility</literal> profile.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>dFdxFine</strong> (vec_type p)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Calculates derivative with respect to <literal>x</literal> window coordinate using
                                    local differencing based on the value of <literal>p</literal> for the current
                                    fragment and its immediate neighbour(s).
                                    This function is not available on <literal>gl_compatibility</literal> profile.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>dFdy</strong> (vec_type p)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Derivative in <literal>y</literal> using local differencing.
                                    Internally, can use either <literal>dFdyCoarse</literal> or <literal>dFdyFine</literal>, but the
                                    decision for which to use is made by the GPU driver.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>dFdyCoarse</strong> (vec_type p)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Calculates derivative with respect to <literal>y</literal> window coordinate using
                                    local differencing based on the value of <literal>p</literal> for the current
                                    fragment neighbour(s), and will possibly, but not necessarily,
                                    include the value for the current fragment.
                                    This function is not available on <literal>gl_compatibility</literal> profile.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>dFdyFine</strong> (vec_type p)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Calculates derivative with respect to <literal>y</literal> window coordinate using
                                    local differencing based on the value of <literal>p</literal> for the current
                                    fragment and its immediate neighbour(s).
                                    This function is not available on <literal>gl_compatibility</literal> profile.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>fwidth</strong> (vec_type p)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sum of absolute derivative in <literal>x</literal> and <literal>y</literal>.
                                    This is the equivalent of using <literal>abs(dFdx(p)) + abs(dFdy(p))</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>fwidthCoarse</strong> (vec_type p)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sum of absolute derivative in <literal>x</literal> and <literal>y</literal>.
                                    This is the equivalent of using
                                    <literal>abs(dFdxCoarse(p)) + abs(dFdyCoarse(p))</literal>.
                                    This function is not available on <literal>gl_compatibility</literal> profile.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>fwidthFine</strong> (vec_type p)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sum of absolute derivative in <literal>x</literal> and <literal>y</literal>.
                                    This is the equivalent of using
                                    <literal>abs(dFdxFine(p)) + abs(dFdyFine(p))</literal>.
                                    This function is not available on <literal>gl_compatibility</literal> profile.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>uint <strong>packHalf2x16</strong> (vec2 v)</paragraph>
                                <paragraph>vec2 <strong>unpackHalf2x16</strong> (uint v)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Convert two 32-bit floating-point numbers into 16-bit
                                    and pack them into a 32-bit unsigned integer and vice-versa.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>uint <strong>packUnorm2x16</strong> (vec2 v)</paragraph>
                                <paragraph>vec2 <strong>unpackUnorm2x16</strong> (uint v)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Convert two 32-bit floating-point numbers (clamped
                                    within 0..1 range) into 16-bit and pack them
                                    into a 32-bit unsigned integer and vice-versa.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>uint <strong>packSnorm2x16</strong> (vec2 v)</paragraph>
                                <paragraph>vec2 <strong>unpackSnorm2x16</strong> (uint v)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Convert two 32-bit floating-point numbers (clamped
                                    within -1..1 range) into 16-bit and pack them
                                    into a 32-bit unsigned integer and vice-versa.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>uint <strong>packUnorm4x8</strong> (vec4 v)</paragraph>
                                <paragraph>vec4 <strong>unpackUnorm4x8</strong> (uint v)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Convert four 32-bit floating-point numbers (clamped
                                    within 0..1 range) into 8-bit and pack them
                                    into a 32-bit unsigned integer and vice-versa.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>uint <strong>packSnorm4x8</strong> (vec4 v)</paragraph>
                                <paragraph>vec4 <strong>unpackSnorm4x8</strong> (uint v)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Convert four 32-bit floating-point numbers (clamped
                                    within -1..1 range) into 8-bit and pack them
                                    into a 32-bit unsigned integer and vice-versa.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>ivec_type <strong>bitfieldExtract</strong> (ivec_type value, int offset, int bits)</paragraph>
                                <paragraph>uvec_type <strong>bitfieldExtract</strong> (uvec_type value, int offset, int bits)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Extracts a range of bits from an integer.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>ivec_type <strong>bitfieldInsert</strong> (ivec_type base, ivec_type insert,
                                    int offset, int bits)</paragraph>
                                <paragraph>uvec_type <strong>bitfieldInsert</strong> (uvec_type base, uvec_type insert,
                                    int offset, int bits)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Insert a range of bits into an integer.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>ivec_type <strong>bitfieldReverse</strong> (ivec_type value)</paragraph>
                                <paragraph>uvec_type <strong>bitfieldReverse</strong> (uvec_type value)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Reverse the order of bits in an integer.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>ivec_type <strong>bitCount</strong> (ivec_type value)</paragraph>
                                <paragraph>uvec_type <strong>bitCount</strong> (uvec_type value)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Counts the number of 1 bits in an integer.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>ivec_type <strong>findLSB</strong> (ivec_type value)</paragraph>
                                <paragraph>uvec_type <strong>findLSB</strong> (uvec_type value)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Find the index of the least significant bit set to 1 in an integer.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>ivec_type <strong>findMSB</strong> (ivec_type value)</paragraph>
                                <paragraph>uvec_type <strong>findMSB</strong> (uvec_type value)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Find the index of the most significant bit set to 1 in an integer.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void <strong>imulExtended</strong> (ivec_type x, ivec_type y, out ivec_type msb,
                                    out ivec_type lsb)</paragraph>
                                <paragraph>void <strong>umulExtended</strong> (uvec_type x, uvec_type y, out uvec_type msb,
                                    out uvec_type lsb)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Multiplies two 32-bit numbers and produce a 64-bit result.
                                    <literal>x</literal> - the first number.
                                    <literal>y</literal> - the second number.
                                    <literal>msb</literal> - will contain the most significant bits.
                                    <literal>lsb</literal> - will contain the least significant bits.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>uvec_type <strong>uaddCarry</strong> (uvec_type x, uvec_type y, out uvec_type carry)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Adds two unsigned integers and generates carry.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>uvec_type <strong>usubBorrow</strong> (uvec_type x, uvec_type y, out uvec_type borrow)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Subtracts two unsigned integers and generates borrow.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>ldexp</strong> (vec_type x, out ivec_type exp)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Assemble a floating-point number from a value and exponent.</paragraph>
                                <paragraph>If this product is too large to be represented in the
                                    floating-point type the result is undefined.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec_type <strong>frexp</strong> (vec_type x, out ivec_type exp)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Splits a floating-point number(<literal>x</literal>) into significand
                                    (in the range of [0.5, 1.0]) and an integral exponent.</paragraph>
                                <paragraph>For <literal>x</literal> equals zero the significand and exponent are both zero.
                                    For <literal>x</literal> of infinity or NaN, the results are undefined.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
