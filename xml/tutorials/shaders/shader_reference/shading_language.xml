<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/shader_reference/shading_language.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-shading-language"></target>
    <section ids="shading-language doc-shading-language" names="shading\ language doc_shading_language">
        <title>Shading language</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>Godot uses a shading language similar to GLSL ES 3.0. Most datatypes and
                functions are supported, and the few remaining ones will likely be added over
                time.</paragraph>
            <paragraph>If you are already familiar with GLSL, the <reference internal="True" refuri="../converting_glsl_to_godot_shaders#doc-converting-glsl-to-godot-shaders"><inline classes="std std-ref">Godot Shader Migration
                        Guide</inline></reference> is a resource that will help you
                transition from regular GLSL to Godot's shading language.</paragraph>
            <target refid="doc-shading-language-data-types"></target>
        </section>
        <section ids="data-types doc-shading-language-data-types" names="data\ types doc_shading_language_data_types">
            <title>Data types</title>
            <paragraph>Most GLSL ES 3.0 datatypes are supported:</paragraph>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="24"></colspec>
                    <colspec colwidth="81"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Type</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Description</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><strong>void</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Void datatype, useful only for functions that return nothing.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>bool</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Boolean datatype, can only contain <literal>true</literal> or <literal>false</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>bvec2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Two-component vector of booleans.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>bvec3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Three-component vector of booleans.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>bvec4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Four-component vector of booleans.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>int</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>32 bit signed scalar integer.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>ivec2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Two-component vector of signed integers.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>ivec3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Three-component vector of signed integers.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>ivec4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Four-component vector of signed integers.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>uint</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Unsigned scalar integer; can't contain negative numbers.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>uvec2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Two-component vector of unsigned integers.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>uvec3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Three-component vector of unsigned integers.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>uvec4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Four-component vector of unsigned integers.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>float</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>32 bit floating-point scalar.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>vec2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Two-component vector of floating-point values.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>vec3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Three-component vector of floating-point values.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>vec4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Four-component vector of floating-point values.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>mat2</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>2x2 matrix, in column major order.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>mat3</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>3x3 matrix, in column major order.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>mat4</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>4x4 matrix, in column major order.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sampler type for binding 2D textures, which are read as float.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>isampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sampler type for binding 2D textures, which are read as signed integer.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>usampler2D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sampler type for binding 2D textures, which are read as unsigned integer.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler2DArray</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sampler type for binding 2D texture arrays, which are read as float.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>isampler2DArray</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sampler type for binding 2D texture arrays, which are read as signed integer.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>usampler2DArray</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sampler type for binding 2D texture arrays, which are read as unsigned integer.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>sampler3D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sampler type for binding 3D textures, which are read as float.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>isampler3D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sampler type for binding 3D textures, which are read as signed integer.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>usampler3D</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sampler type for binding 3D textures, which are read as unsigned integer.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>samplerCube</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sampler type for binding Cubemaps, which are read as float.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>samplerCubeArray</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Sampler type for binding Cubemap arrays, which are read as float.
                                    Only supported in Forward+ and Mobile, not Compatibility.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>samplerExternalOES</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>External sampler type.
                                    Only supported in Compatibility/Android platform.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <paragraph>These types can also be put inside <reference internal="True" refid="doc-shading-language-arrays"><inline classes="std std-ref">arrays</inline></reference>
                or <reference internal="True" refid="doc-shading-language-structs"><inline classes="std std-ref">structs</inline></reference>, which are also usable as function parameters
                or return values. Arrays can be used as uniforms, but structs cannot.</paragraph>
            <warning>
                <paragraph>Local variables are not initialized to a default value such as <literal>0.0</literal>. If
                    you use a variable without assigning it first, it will contain whatever
                    value was already present at that memory location, and unpredictable visual
                    glitches will appear. However, uniforms and varyings are initialized to a
                    default value.</paragraph>
            </warning>
            <section ids="comments" names="comments">
                <title>Comments</title>
                <paragraph>The shading language supports the same comment syntax as used in C# and C++,
                    using <literal>//</literal> for single-line comments and <literal>/* */</literal> for multi-line comments:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">// Single-line comment.
int a = 2;  // Another single-line comment.

/*
Multi-line comment.
The comment ends when the ending delimiter is found
(here, it's on the line below).
*/
int b = 3;</literal_block>
                <paragraph>Additionally, you can use documentation comments that are displayed in the
                    inspector when hovering a shader parameter. Documentation comments are currently
                    only supported when placed immediately above a <literal>uniform</literal> declaration. These
                    documentation comments only support the <strong>multiline</strong> comment syntax and must use
                    <strong>two</strong> leading asterisks (<literal>/**</literal>) instead of just one (<literal>/*</literal>):</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">/**
 * This is a documentation comment.
 * These lines will appear in the inspector when hovering the shader parameter
 * named "Something".
 * You can use [b]BBCode[/b] [i]formatting[/i] in the comment.
 */
uniform int something = 1;</literal_block>
                <paragraph>The asterisks on the follow-up lines are not required, but are recommended as
                    per the <reference internal="True" refuri="../shaders_style_guide#doc-shaders-style-guide"><inline classes="std std-ref">Shaders style guide</inline></reference>. These asterisks are automatically
                    stripped by the inspector, so they won't appear in the tooltip.</paragraph>
            </section>
            <section ids="casting" names="casting">
                <title>Casting</title>
                <paragraph>Just like GLSL ES 3.0, implicit casting between scalars and vectors of the same
                    size but different type is not allowed. Casting of types of different size is
                    also not allowed. Conversion must be done explicitly via constructors.</paragraph>
                <paragraph>Example:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float a = 2; // invalid
float a = 2.0; // valid
float a = float(2); // valid</literal_block>
                <paragraph>Default integer constants are signed, so casting is always needed to convert to
                    unsigned:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">int a = 2; // valid
uint a = 2; // invalid
uint a = uint(2); // valid</literal_block>
            </section>
            <section ids="members" names="members">
                <title>Members</title>
                <paragraph>Individual scalar members of vector types are accessed via the "x", "y", "z" and
                    "w" members. Alternatively, using "r", "g", "b" and "a" also works and is
                    equivalent. Use whatever fits best for your needs.</paragraph>
                <paragraph>For matrices, use the <literal>m[column][row]</literal> indexing syntax to access each scalar,
                    or <literal>m[column]</literal> to access a vector by column index. For example, for accessing the
                    y-component of the translation from a mat4 transform matrix (4th column, 2nd line) you use <literal>m[3][1]</literal> or <literal>m[3].y</literal>.</paragraph>
            </section>
            <section ids="constructing" names="constructing">
                <title>Constructing</title>
                <paragraph>Construction of vector types must always pass:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">// The required amount of scalars
vec4 a = vec4(0.0, 1.0, 2.0, 3.0);
// Complementary vectors and/or scalars
vec4 a = vec4(vec2(0.0, 1.0), vec2(2.0, 3.0));
vec4 a = vec4(vec3(0.0, 1.0, 2.0), 3.0);
// A single scalar for the whole vector
vec4 a = vec4(0.0);</literal_block>
                <paragraph>Construction of matrix types requires vectors of the same dimension as the
                    matrix, interpreted as columns. You can also build a diagonal matrix using <literal>matx(float)</literal> syntax.
                    Accordingly, <literal>mat4(1.0)</literal> is an identity matrix.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">mat2 m2 = mat2(vec2(1.0, 0.0), vec2(0.0, 1.0));
mat3 m3 = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0));
mat4 identity = mat4(1.0);</literal_block>
                <paragraph>Matrices can also be built from a matrix of another dimension. There are two
                    rules:</paragraph>
                <paragraph>1. If a larger matrix is constructed from a smaller matrix, the additional rows
                    and columns are set to the values they would have in an identity matrix.
                    1. If a smaller matrix is constructed from a larger matrix, the top, left
                    submatrix of the larger matrix is used.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">mat3 basis = mat3(MODEL_MATRIX);
mat4 m4 = mat4(basis);
mat2 m2 = mat2(m4);</literal_block>
            </section>
            <section ids="swizzling" names="swizzling">
                <title>Swizzling</title>
                <paragraph>It is possible to obtain any combination of components in any order, as long as
                    the result is another vector type (or scalar). This is easier shown than
                    explained:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">vec4 a = vec4(0.0, 1.0, 2.0, 3.0);
vec3 b = a.rgb; // Creates a vec3 with vec4 components.
vec3 b = a.ggg; // Also valid; creates a vec3 and fills it with a single vec4 component.
vec3 b = a.bgr; // "b" will be vec3(2.0, 1.0, 0.0).
vec3 b = a.xyz; // Also rgba, xyzw are equivalent.
vec3 b = a.stp; // And stpq (for texture coordinates).
float c = b.w; // Invalid, because "w" is not present in vec3 b.
vec3 c = b.xrt; // Invalid, mixing different styles is forbidden.
b.rrr = a.rgb; // Invalid, assignment with duplication.
b.bgr = a.rgb; // Valid assignment. "b"'s "blue" component will be "a"'s "red" and vice versa.</literal_block>
            </section>
            <section ids="precision" names="precision">
                <title>Precision</title>
                <paragraph>It is possible to add precision modifiers to datatypes; use them for uniforms,
                    variables, arguments and varyings:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">lowp vec4 a = vec4(0.0, 1.0, 2.0, 3.0); // low precision, usually 8 bits per component mapped to 0-1
mediump vec4 a = vec4(0.0, 1.0, 2.0, 3.0); // medium precision, usually 16 bits or half float
highp vec4 a = vec4(0.0, 1.0, 2.0, 3.0); // high precision, uses full float or integer range (32 bit default)</literal_block>
                <paragraph>Using lower precision for some operations can speed up the math involved (at the
                    cost of less precision). This is rarely needed in the vertex processor function
                    (where full precision is needed most of the time), but is often useful in the
                    fragment processor.</paragraph>
                <paragraph>Some architectures (mainly mobile) can benefit significantly from this, but
                    there are downsides such as the additional overhead of conversion between
                    precisions. Refer to the documentation of the target architecture for further
                    information. In many cases, mobile drivers cause inconsistent or unexpected
                    behavior and it is best to avoid specifying precision unless necessary.</paragraph>
                <target refid="doc-shading-language-arrays"></target>
            </section>
        </section>
        <section ids="arrays doc-shading-language-arrays" names="arrays doc_shading_language_arrays">
            <title>Arrays</title>
            <paragraph>Arrays are containers for multiple variables of a similar type.</paragraph>
            <section ids="local-arrays" names="local\ arrays">
                <title>Local arrays</title>
                <paragraph>Local arrays are declared in functions. They can use all of the allowed
                    datatypes, except samplers. The array declaration follows a C-style syntax:
                    <literal>[const] + [precision] + typename + identifier + [array size]</literal>.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
    float arr[3];
}</literal_block>
                <paragraph>They can be initialized at the beginning like:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float float_arr[3] = float[3] (1.0, 0.5, 0.0); // first constructor

int int_arr[3] = int[] (2, 1, 0); // second constructor

vec2 vec2_arr[3] = { vec2(1.0, 1.0), vec2(0.5, 0.5), vec2(0.0, 0.0) }; // third constructor

bool bool_arr[] = { true, true, false }; // fourth constructor - size is defined automatically from the element count</literal_block>
                <paragraph>You can declare multiple arrays (even with different sizes) in one expression:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float a[3] = float[3] (1.0, 0.5, 0.0),
b[2] = { 1.0, 0.5 },
c[] = { 0.7 },
d = 0.0,
e[5];</literal_block>
                <paragraph>To access an array element, use the indexing syntax:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float arr[3];

arr[0] = 1.0; // setter

COLOR.r = arr[0]; // getter</literal_block>
                <paragraph>Arrays also have a built-in function <literal>.length()</literal> (not to be confused with the
                    built-in <literal>length()</literal> function). It doesn't accept any parameters and will
                    return the array's size.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float arr[] = { 0.0, 1.0, 0.5, -1.0 };
for (int i = 0; i &lt; arr.length(); i++) {
    // ...
}</literal_block>
                <note>
                    <paragraph>If you use an index either below 0 or greater than array size - the shader will
                        crash and break rendering. To prevent this, use <literal>length()</literal>, <literal>if</literal>, or
                        <literal>clamp()</literal> functions to ensure the index is between 0 and the array's
                        length. Always carefully test and check your code. If you pass a constant
                        expression or a number, the editor will check its bounds to prevent
                        this crash.</paragraph>
                </note>
            </section>
            <section ids="global-arrays" names="global\ arrays">
                <title>Global arrays</title>
                <paragraph>You can declare arrays in global space as either <literal>const</literal> or <literal>uniform</literal>:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

const lowp vec3 v[1] = lowp vec3[1] ( vec3(0, 0, 1) );
uniform lowp vec3 w[1];

void fragment() {
  ALBEDO = v[0] + w[0];
}</literal_block>
                <note>
                    <paragraph>Global arrays use the same syntax as local arrays, except with a <literal>const</literal>
                        or <literal>uniform</literal> added to their declaration. Note that uniform arrays can't
                        have a default value.</paragraph>
                </note>
            </section>
        </section>
        <section ids="constants" names="constants">
            <title>Constants</title>
            <paragraph>Use the <literal>const</literal> keyword before the variable declaration to make that variable
                immutable, which means that it cannot be modified. All basic types, except
                samplers can be declared as constants. Accessing and using a constant value is
                slightly faster than using a uniform. Constants must be initialized at their
                declaration.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">const vec2 a = vec2(0.0, 1.0);
vec2 b;

a = b; // invalid
b = a; // valid</literal_block>
            <paragraph>Constants cannot be modified and additionally cannot have hints, but multiple of
                them (if they have the same type) can be declared in a single expression e.g</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">const vec2 V1 = vec2(1, 1), V2 = vec2(2, 2);</literal_block>
            <paragraph>Similar to variables, arrays can also be declared with <literal>const</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">const float arr[] = { 1.0, 0.5, 0.0 };

arr[0] = 1.0; // invalid

COLOR.r = arr[0]; // valid</literal_block>
            <paragraph>Constants can be declared both globally (outside of any function) or locally
                (inside a function). Global constants are useful when you want to have access to
                a value throughout your shader that does not need to be modified. Like uniforms,
                global constants are shared between all shader stages, but they are not
                accessible outside of the shader.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

const float GOLDEN_RATIO = 1.618033988749894;</literal_block>
            <paragraph>Constants of the <literal>float</literal> type must be initialized using <literal>.</literal> notation after the
                decimal part or by using the scientific notation. The optional <literal>f</literal> post-suffix is
                also supported.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float a = 1.0;
float b = 1.0f; // same, using suffix for clarity
float c = 1e-1; // gives 0.1 by using the scientific notation</literal_block>
            <paragraph>Constants of the <literal>uint</literal> (unsigned int) type must have a <literal>u</literal> suffix to differentiate them from signed integers.
                Alternatively, this can be done by using the <literal>uint(x)</literal> built-in conversion function.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uint a = 1u;
uint b = uint(1);</literal_block>
            <target refid="doc-shading-language-structs"></target>
        </section>
        <section ids="structs doc-shading-language-structs" names="structs doc_shading_language_structs">
            <title>Structs</title>
            <paragraph>Structs are compound types which can be used for better abstraction of shader
                code. You can declare them at the global scope like:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">struct PointLight {
    vec3 position;
    vec3 color;
    float intensity;
};</literal_block>
            <paragraph>After declaration, you can instantiate and initialize them like:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment()
{
    PointLight light;
    light.position = vec3(0.0);
    light.color = vec3(1.0, 0.0, 0.0);
    light.intensity = 0.5;
}</literal_block>
            <paragraph>Or use struct constructor for same purpose:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">PointLight light = PointLight(vec3(0.0), vec3(1.0, 0.0, 0.0), 0.5);</literal_block>
            <paragraph>Structs may contain other struct or array, you can also instance them as global
                constant:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

...

struct Scene {
    PointLight lights[2];
};

const Scene scene = Scene(PointLight[2](PointLight(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.0), PointLight(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.0)));

void fragment()
{
    ALBEDO = scene.lights[0].color;
}</literal_block>
            <paragraph>You can also pass them to functions:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

...

Scene construct_scene(PointLight light1, PointLight light2) {
    return Scene({light1, light2});
}

void fragment()
{
    COLOR.rgb = construct_scene(PointLight(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.0), PointLight(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0), 1.0)).lights[0].color;
}</literal_block>
        </section>
        <section ids="operators" names="operators">
            <title>Operators</title>
            <paragraph>Godot shading language supports the same set of operators as GLSL ES 3.0. Below
                is the list of them in precedence order:</paragraph>
            <table classes="nowrap-col3">
                <tgroup cols="3">
                    <colspec colwidth="13"></colspec>
                    <colspec colwidth="24"></colspec>
                    <colspec colwidth="18"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>Precedence</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Class</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Operator</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>1 (highest)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>parenthetical grouping</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>()</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>2</paragraph>
                            </entry>
                            <entry>
                                <paragraph>unary</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>+, -, !, ~</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>3</paragraph>
                            </entry>
                            <entry>
                                <paragraph>multiplicative</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>/, *, %</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>4</paragraph>
                            </entry>
                            <entry>
                                <paragraph>additive</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>+, -</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>5</paragraph>
                            </entry>
                            <entry>
                                <paragraph>bit-wise shift</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>&lt;&lt;, &gt;&gt;</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>6</paragraph>
                            </entry>
                            <entry>
                                <paragraph>relational</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>&lt;, &gt;, &lt;=, &gt;=</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>7</paragraph>
                            </entry>
                            <entry>
                                <paragraph>equality</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>==, !=</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>8</paragraph>
                            </entry>
                            <entry>
                                <paragraph>bit-wise AND</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>&amp;</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>9</paragraph>
                            </entry>
                            <entry>
                                <paragraph>bit-wise exclusive OR</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>^</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>10</paragraph>
                            </entry>
                            <entry>
                                <paragraph>bit-wise inclusive OR</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>|</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>11</paragraph>
                            </entry>
                            <entry>
                                <paragraph>logical AND</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>&amp;&amp;</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>12 (lowest)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>logical inclusive OR</paragraph>
                            </entry>
                            <entry>
                                <paragraph><strong>||</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <note>
                <paragraph>Most operators that accept vectors or matrices (multiplication, division, etc) operate component-wise, meaning the function
                    is applied to the first value of each vector and then on the second value of each vector, etc. Some examples:</paragraph>
                <table classes="nowrap-col2 nowrap-col1 colwidths-auto">
                    <tgroup cols="2">
                        <colspec colwidth="39"></colspec>
                        <colspec colwidth="54"></colspec>
                        <thead>
                            <row>
                                <entry>
                                    <paragraph>Operation</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Equivalent Scalar Operation</paragraph>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph><literal>vec3(4, 5, 6) + 2</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><literal>vec3(4 + 2, 5 + 2, 6 + 2)</literal></paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>vec2(3, 4) * vec2(10, 20)</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><literal>vec2(3 * 10, 4 * 20)</literal></paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>mat2(vec2(1, 2), vec2(3, 4)) + 10</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><literal>mat2(vec2(1 + 10, 2 + 10), vec2(3 + 10, 4 + 10))</literal></paragraph>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <paragraph>The <reference name="GLSL Language Specification" refuri="http://www.opengl.org/registry/doc/GLSLangSpec.4.30.6.pdf">GLSL Language Specification</reference><target ids="glsl-language-specification" names="glsl\ language\ specification" refuri="http://www.opengl.org/registry/doc/GLSLangSpec.4.30.6.pdf"></target> says under section 5.10 Vector and Matrix Operations:</paragraph>
                <block_quote>
                    <paragraph>With a few exceptions, operations are component-wise. Usually, when an operator operates on a
                        vector or matrix, it is operating independently on each component of the vector or matrix,
                        in a component-wise fashion. [...] The exceptions are matrix multiplied by vector,
                        vector multiplied by matrix, and matrix multiplied by matrix. These do not operate component-wise,
                        but rather perform the correct linear algebraic multiply.</paragraph>
                </block_quote>
            </note>
        </section>
        <section ids="flow-control" names="flow\ control">
            <title>Flow control</title>
            <paragraph>Godot Shading language supports the most common types of flow control:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">// `if`, `else if` and `else`.
if (cond) {

} else if (other_cond) {

} else {

}

// Ternary operator.
// This is an expression that behaves like `if`/`else` and returns the value.
// If `cond` evaluates to `true`, `result` will be `9`.
// Otherwise, `result` will be `5`.
int result = cond ? 9 : 5;

// `switch`.
switch (i) { // `i` should be a signed integer expression.
    case -1:
        break;
    case 0:
        return; // `break` or `return` to avoid running the next `case`.
    case 1: // Fallthrough (no `break` or `return`): will run the next `case`.
    case 2:
        break;
    //...
    default: // Only run if no `case` above matches. Optional.
        break;
}

// `for` loop. Best used when the number of elements to iterate on
// is known in advance.
for (int i = 0; i &lt; 10; i++) {

}

// `while` loop. Best used when the number of elements to iterate on
// is not known in advance.
while (cond) {

}

// `do while`. Like `while`, but always runs at least once even if `cond`
// never evaluates to `true`.
do {

} while (cond);</literal_block>
            <paragraph>Keep in mind that in modern GPUs, an infinite loop can exist and can freeze
                your application (including editor). Godot can't protect you from this, so be
                careful not to make this mistake!</paragraph>
            <paragraph>Also, when comparing floating-point values against a number, make sure to
                compare them against a <emphasis>range</emphasis> instead of an exact number.</paragraph>
            <paragraph>A comparison like <literal>if (value == 0.3)</literal> may not evaluate to <literal>true</literal>.
                Floating-point math is often approximate and can defy expectations. It can also
                behave differently depending on the hardware.</paragraph>
            <paragraph><strong>Don't</strong> do this.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float value = 0.1 + 0.2;

// May not evaluate to `true`!
if (value == 0.3) {
    // ...
}</literal_block>
            <paragraph>Instead, always perform a range comparison with an epsilon value. The larger the
                floating-point number (and the less precise the floating-point number), the
                larger the epsilon value should be.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">const float EPSILON = 0.0001;
if (value &gt;= 0.3 - EPSILON &amp;&amp; value &lt;= 0.3 + EPSILON) {
    // ...
}</literal_block>
            <paragraph>See <reference name="floating-point-gui.de" refuri="https://floating-point-gui.de/">floating-point-gui.de</reference> for more
                information.</paragraph>
        </section>
        <section ids="discarding" names="discarding">
            <title>Discarding</title>
            <paragraph>Fragment, light, and custom functions (called from fragment or light) can use the
                <literal>discard</literal> keyword. If used, the fragment is discarded and nothing is written.</paragraph>
            <paragraph>Beware that <literal>discard</literal> has a performance cost when used, as it will prevent the
                depth prepass from being effective on any surfaces using the shader. Also, a
                discarded pixel still needs to be rendered in the vertex shader, which means a
                shader that uses <literal>discard</literal> on all of its pixels is still more expensive to
                render compared to not rendering any object in the first place.</paragraph>
        </section>
        <section ids="functions" names="functions">
            <title>Functions</title>
            <paragraph>It is possible to define functions in a Godot shader. They use the following
                syntax:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">ret_type func_name(args) {
    return ret_type; // if returning a value
}

// a more specific example:

int sum2(int a, int b) {
    return a + b;
}</literal_block>
            <paragraph>You can only use functions that have been defined above (higher in the editor)
                the function from which you are calling them. Redefining a function that has
                already been defined above (or is a built-in function name) will cause an error.</paragraph>
            <paragraph>Function arguments can have special qualifiers:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph><strong>in</strong>: Means the argument is only for reading (default).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>out</strong>: Means the argument is only for writing.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>inout</strong>: Means the argument is fully passed via reference.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>const</strong>: Means the argument is a constant and cannot be changed, may be
                        combined with <strong>in</strong> qualifier.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Example below:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void sum2(int a, int b, inout int result) {
    result = a + b;
}</literal_block>
            <paragraph>Function overloading is supported. You can define multiple functions with the same
                name, but different arguments. Note that <reference name="implicit casting" refid="casting">implicit casting</reference><target names="implicit\ casting" refid="casting"></target> in overloaded
                function calls is not allowed, such as from <literal>int</literal> to <literal>float</literal> (<literal>1</literal> to <literal>1.0</literal>).</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">vec3 get_color(int t) {
    return vec3(1, 0, 0); // Red color.
}
vec3 get_color(float t) {
    return vec3(0, 1, 0); // Green color.
}
void fragment() {
    vec3 red = get_color(1);
    vec3 green = get_color(1.0);
}</literal_block>
            <target refid="doc-shading-language-varyings"></target>
        </section>
        <section ids="varyings doc-shading-language-varyings" names="varyings doc_shading_language_varyings">
            <title>Varyings</title>
            <paragraph>To send data from the vertex to the fragment (or light) processor function, <emphasis>varyings</emphasis> are
                used. They are set for every primitive vertex in the <emphasis>vertex processor</emphasis>, and the
                value is interpolated for every pixel in the <emphasis>fragment processor</emphasis>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

varying vec3 some_color;

void vertex() {
    some_color = NORMAL; // Make the normal the color.
}

void fragment() {
    ALBEDO = some_color;
}

void light() {
    DIFFUSE_LIGHT = some_color * 100; // optionally
}</literal_block>
            <paragraph>Varying can also be an array:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

varying float var_arr[3];

void vertex() {
    var_arr[0] = 1.0;
    var_arr[1] = 0.0;
}

void fragment() {
    ALBEDO = vec3(var_arr[0], var_arr[1], var_arr[2]); // red color
}</literal_block>
            <paragraph>It's also possible to send data from <emphasis>fragment</emphasis> to <emphasis>light</emphasis> processors using <emphasis>varying</emphasis> keyword. To do so you can assign it in the <emphasis>fragment</emphasis> and later use it in the <emphasis>light</emphasis> function.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

varying vec3 some_light;

void fragment() {
    some_light = ALBEDO * 100.0; // Make a shining light.
}

void light() {
    DIFFUSE_LIGHT = some_light;
}</literal_block>
            <paragraph>Note that varying may not be assigned in custom functions or a <emphasis>light processor</emphasis> function like:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

varying float test;

void foo() {
    test = 0.0; // Error.
}

void vertex() {
    test = 0.0;
}

void light() {
    test = 0.0; // Error too.
}</literal_block>
            <paragraph>This limitation was introduced to prevent incorrect usage before initialization.</paragraph>
        </section>
        <section ids="interpolation-qualifiers" names="interpolation\ qualifiers">
            <title>Interpolation qualifiers</title>
            <paragraph>Certain values are interpolated during the shading pipeline. You can modify how
                these interpolations are done by using <emphasis>interpolation qualifiers</emphasis>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

varying flat vec3 our_color;

void vertex() {
    our_color = COLOR.rgb;
}

void fragment() {
    ALBEDO = our_color;
}</literal_block>
            <paragraph>There are two possible interpolation qualifiers:</paragraph>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="19"></colspec>
                    <colspec colwidth="81"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Qualifier</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Description</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><strong>flat</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>The value is not interpolated.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>smooth</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>The value is interpolated in a perspective-correct fashion. This is the default.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <target refid="doc-shading-language-uniforms"></target>
        </section>
        <section ids="uniforms doc-shading-language-uniforms" names="uniforms doc_shading_language_uniforms">
            <title>Uniforms</title>
            <paragraph>Passing values to shaders is possible with <emphasis>uniforms</emphasis>, which are defined in the
                global scope of the shader, outside of functions. When a shader is later
                assigned to a material, the uniforms will appear as editable parameters in the
                material's inspector. Uniforms can't be written from within the shader. Any
                <reference internal="True" refid="doc-shading-language-data-types"><inline classes="std std-ref">data type</inline></reference> except for <literal>void</literal> can be a uniform.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

uniform float some_value;

uniform vec3 colors[3];</literal_block>
            <paragraph>You can set uniforms in the editor in the material's inspector. Alternately, you
                can set them <reference internal="True" refid="doc-shading-language-setting-uniforms-from-code"><inline classes="std std-ref">from code</inline></reference>.</paragraph>
            <section ids="uniform-hints" names="uniform\ hints">
                <title>Uniform hints</title>
                <paragraph>Godot provides optional uniform hints to make the compiler understand what the
                    uniform is used for, and how the editor should allow users to modify it.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

uniform vec4 color : source_color;
uniform float amount : hint_range(0, 1);
uniform vec4 other_color : source_color = vec4(1.0); // Default values go after the hint.
uniform sampler2D image : source_color;</literal_block>
                <paragraph>Uniforms can also be assigned default values:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

uniform vec4 some_vector = vec4(0.0);
uniform vec4 some_color : source_color = vec4(1.0);</literal_block>
                <paragraph>Note that when adding a default value and a hint, the default value goes after the hint.</paragraph>
                <paragraph>Full list of uniform hints below:</paragraph>
                <table>
                    <tgroup cols="3">
                        <colspec colwidth="22"></colspec>
                        <colspec colwidth="50"></colspec>
                        <colspec colwidth="77"></colspec>
                        <thead>
                            <row>
                                <entry>
                                    <paragraph>Type</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Hint</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Description</paragraph>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph><strong>vec3, vec4</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>source_color</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Used as color.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>int</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>hint_enum("String1", "String2")</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Displays int input as a dropdown widget in the editor.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>int, float</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>hint_range(min, max[, step])</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Restricted to values in a range (with min/max/step).</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>source_color</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Used as albedo color.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>hint_normal</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Used as normalmap.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>hint_default_white</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>As value or albedo color, default to opaque white.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>hint_default_black</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>As value or albedo color, default to opaque black.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>hint_default_transparent</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>As value or albedo color, default to transparent black.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>hint_anisotropy</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>As flowmap, default to right.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>hint_roughness[_r, _g, _b, _a, _normal, _gray]</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Used for roughness limiter on import (attempts reducing specular aliasing).
                                        <literal>_normal</literal> is a normal map that guides the roughness limiter,
                                        with roughness increasing in areas that have high-frequency detail.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>filter[_nearest, _linear][_mipmap][_anisotropic]</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Enabled specified texture filtering.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>repeat[_enable, _disable]</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Enabled texture repeating.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>hint_screen_texture</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Texture is the screen texture.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>hint_depth_texture</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Texture is the depth texture.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>hint_normal_roughness_texture</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Texture is the normal roughness texture (only supported in Forward+).</paragraph>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <section ids="using-hint-enum" names="using\ hint_enum">
                    <title>Using <literal>hint_enum</literal></title>
                    <paragraph>You can access <literal>int</literal> values as a readable dropdown widget using the <literal>hint_enum</literal> uniform:</paragraph>
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">uniform int noise_type : hint_enum("OpenSimplex2", "Cellular", "Perlin", "Value") = 0;</literal_block>
                    <paragraph>You can assign explicit values to the <literal>hint_enum</literal> uniform using colon syntax similar to GDScript:</paragraph>
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">uniform int character_speed: hint_enum("Slow:30", "Average:60", "Very Fast:200") = 60;</literal_block>
                    <paragraph>The value will be stored as an integer, corresponding to the index of the selected
                        option (i.e. <literal>0</literal>, <literal>1</literal>, or <literal>2</literal>) or the value assigned by colon syntax
                        (i.e. <literal>30</literal>, <literal>60</literal>, or <literal>200</literal>). When setting the value with
                        <literal>set_shader_parameter()</literal>, you must use the integer value, not the <literal>String</literal>
                        name.</paragraph>
                </section>
                <section ids="using-source-color" names="using\ source_color">
                    <title>Using <literal>source_color</literal></title>
                    <paragraph>Any texture which contains <emphasis>sRGB color data</emphasis> requires a <literal>source_color</literal> hint
                        in order to be correctly sampled. This is because Godot renders in linear
                        color space, but some textures contain sRGB color data. If this hint is not
                        used, the texture will appear washed out.</paragraph>
                    <paragraph>Albedo and color textures should typically have a <literal>source_color</literal> hint. Normal,
                        roughness, metallic, and height textures typically do not need a <literal>source_color</literal>
                        hint.</paragraph>
                    <paragraph>Using <literal>source_color</literal> hint is required in the Forward+ and Mobile renderers,
                        and in <literal>canvas_item</literal> shaders when <reference internal="True" refuri="../../../classes/class_projectsettings#class-projectsettings-property-rendering-viewport-hdr-2d"><inline classes="std std-ref">HDR 2D</inline></reference>
                        is enabled. The <literal>source_color</literal> hint is optional for the Compatibility renderer,
                        and for <literal>canvas_item</literal> shaders if <literal>HDR 2D</literal> is disabled. However, it is
                        recommended to always use the <literal>source_color</literal> hint, because it works even
                        if you change renderers or disable <literal>HDR 2D</literal>.</paragraph>
                </section>
            </section>
            <section ids="uniform-groups" names="uniform\ groups">
                <title>Uniform groups</title>
                <paragraph>To group multiple uniforms in a section in the inspector, you can use a
                    <literal>group_uniform</literal> keyword like this:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">group_uniforms MyGroup;
uniform sampler2D test;</literal_block>
                <paragraph>You can close the group by using:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">group_uniforms;</literal_block>
                <paragraph>The syntax also supports subgroups (it's not mandatory to declare the base group before this):</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">group_uniforms MyGroup.MySubgroup;</literal_block>
                <target refid="doc-shading-language-global-uniforms"></target>
            </section>
            <section ids="global-uniforms doc-shading-language-global-uniforms" names="global\ uniforms doc_shading_language_global_uniforms">
                <title>Global uniforms</title>
                <paragraph>Sometimes, you want to modify a parameter in many different shaders at once.
                    With a regular uniform, this takes a lot of work as all these shaders need to be
                    tracked and the uniform needs to be set for each of them. Global uniforms allow
                    you to create and update uniforms that will be available in all shaders, in
                    every shader type (<literal>canvas_item</literal>, <literal>spatial</literal>, <literal>particles</literal>, <literal>sky</literal> and
                    <literal>fog</literal>).</paragraph>
                <paragraph>Global uniforms are especially useful for environmental effects that affect many
                    objects in a scene, like having foliage bend when the player is nearby, or having
                    objects move with the wind.</paragraph>
                <note>
                    <paragraph><emphasis>Global uniforms</emphasis> are not the same as <emphasis>global scope</emphasis> for an individual
                        shader. While regular uniforms are defined outside of shader functions and are
                        therefore the global scope of the shader, global uniforms are global to all
                        shaders in the entire project (but within each shader, are also in the global
                        scope).</paragraph>
                </note>
                <paragraph>To create a global uniform, open the <strong>Project Settings</strong> then go to the
                    <strong>Shader Globals</strong> tab. Specify a name for the uniform (case-sensitive) and a
                    type, then click <strong>Add</strong> in the top-right corner of the dialog. You can then
                    edit the value assigned to the uniform by clicking the value in the list of
                    uniforms:</paragraph>
                <figure align="center" ids="id1">
                    <image alt="Adding a global uniform in the Shader Globals tab of the Project Settings" candidates="{'*': 'tutorials/shaders/shader_reference/img/shading_language_adding_global_uniforms.webp'}" original_uri="img/shading_language_adding_global_uniforms.webp" uri="tutorials/shaders/shader_reference/img/shading_language_adding_global_uniforms.webp"></image>
                    <caption>Adding a global uniform in the Shader Globals tab of the Project Settings</caption>
                </figure>
                <paragraph>After creating a global uniform, you can use it in a shader as follows:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

global uniform vec4 my_color;

void fragment() {
    COLOR = my_color.rgb;
}</literal_block>
                <paragraph>Note that the global uniform <emphasis>must</emphasis> exist in the Project Settings at the time
                    the shader is saved, or compilation will fail. While you can assign a default
                    value using <literal>global uniform vec4 my_color = ...</literal> in the shader code, it will
                    be ignored as the global uniform must always be defined in the Project Settings
                    anyway.</paragraph>
                <paragraph>To change the value of a global uniform at runtime, use the
                    <reference internal="True" refuri="../../../classes/class_renderingserver#class-renderingserver-method-global-shader-parameter-set"><inline classes="std std-ref">RenderingServer.global_shader_parameter_set</inline></reference>
                    method in a script:</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">RenderingServer.global_shader_parameter_set("my_color", Color(0.3, 0.6, 1.0))</literal_block>
                <paragraph>Assigning global uniform values can be done as many times as desired without
                    impacting performance, as setting data doesn't require synchronization between
                    the CPU and GPU.</paragraph>
                <paragraph>You can also add or remove global uniforms at runtime:</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">RenderingServer.global_shader_parameter_add("my_color", RenderingServer.GLOBAL_VAR_TYPE_COLOR, Color(0.3, 0.6, 1.0))
RenderingServer.global_shader_parameter_remove("my_color")</literal_block>
                <paragraph>Adding or removing global uniforms at runtime has a performance cost, although
                    it's not as pronounced compared to getting global uniform values from a script
                    (see the warning below).</paragraph>
                <warning>
                    <paragraph>While you <emphasis>can</emphasis> query the value of a global uniform at runtime in a script
                        using <literal>RenderingServer.global_shader_parameter_get("uniform_name")</literal>, this
                        has a large performance penalty as the rendering thread needs to synchronize
                        with the calling thread.</paragraph>
                    <paragraph>Therefore, it's not recommended to read global shader uniform values
                        continuously in a script. If you need to read values in a script after
                        setting them, consider creating an <reference internal="True" refuri="../../scripting/singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">autoload</inline></reference>
                        where you store the values you need to query at the same time you're setting
                        them as global uniforms.</paragraph>
                </warning>
                <target refid="doc-shading-language-per-instance-uniforms"></target>
            </section>
            <section ids="per-instance-uniforms doc-shading-language-per-instance-uniforms" names="per-instance\ uniforms doc_shading_language_per_instance_uniforms">
                <title>Per-instance uniforms</title>
                <note>
                    <paragraph>Per-instance uniforms are available in both <literal>canvas_item</literal> (2D) and <literal>spatial</literal> (3D) shaders.</paragraph>
                </note>
                <paragraph>Sometimes, you want to modify a parameter on each node using the material. As an
                    example, in a forest full of trees, when you want each tree to have a slightly
                    different color that is editable by hand. Without per-instance uniforms, this
                    requires creating a unique material for each tree (each with a slightly
                    different hue). This makes material management more complex, and also has a
                    performance overhead due to the scene requiring more unique material instances.
                    Vertex colors could also be used here, but they'd require creating unique copies
                    of the mesh for each different color, which also has a performance overhead.</paragraph>
                <paragraph>Per-instance uniforms are set on each GeometryInstance3D, rather than on each
                    Material instance. Take this into account when working with meshes that have
                    multiple materials assigned to them, or MultiMesh setups.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

// Provide a hint to edit as a color. Optionally, a default value can be provided.
// If no default value is provided, the type's default is used (e.g. opaque black for colors).
instance uniform vec4 my_color : source_color = vec4(1.0, 0.5, 0.0, 1.0);

void fragment() {
    ALBEDO = my_color.rgb;
}</literal_block>
                <paragraph>After saving the shader, you can change the per-instance uniform's value using
                    the inspector:</paragraph>
                <figure align="center" ids="id2">
                    <image alt="Setting a per-instance uniform's value in the GeometryInstance3D section of the inspector" candidates="{'*': 'tutorials/shaders/shader_reference/img/shading_language_per_instance_uniforms_inspector.webp'}" original_uri="img/shading_language_per_instance_uniforms_inspector.webp" uri="tutorials/shaders/shader_reference/img/shading_language_per_instance_uniforms_inspector.webp"></image>
                    <caption>Setting a per-instance uniform's value in the GeometryInstance3D section of the inspector</caption>
                </figure>
                <paragraph>Per-instance uniform values can also be set at runtime using
                    <reference internal="True" refuri="../../../classes/class_geometryinstance3d#class-geometryinstance3d-method-set-instance-shader-parameter"><inline classes="std std-ref">set_instance_shader_parameter</inline></reference>
                    method on a node that inherits from <reference internal="True" refuri="../../../classes/class_geometryinstance3d#class-geometryinstance3d"><inline classes="std std-ref">GeometryInstance3D</inline></reference>:</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">$MeshInstance3D.set_instance_shader_parameter("my_color", Color(0.3, 0.6, 1.0))</literal_block>
                <paragraph>When using per-instance uniforms, there are some restrictions you should be aware of:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Per-instance uniforms do not support textures or arrays</strong>, only regular scalar and vector types.</paragraph>
                    </list_item>
                </bullet_list>
                <note>
                    <block_quote>
                        <paragraph>Due to GLSL limitations, you cannot directly index a texture array
                            using a per-instance uniform. Sampler arrays can only be indexed by
                            compile-time constant expressions.</paragraph>
                        <paragraph>As a workaround, pass a texture array as a regular uniform and the
                            desired texture index as a per-instance uniform. Then use a <literal>switch</literal>
                            statement to select the texture:</paragraph>
                    </block_quote>
                    <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform sampler2D texture_array[4];
instance uniform int texture_index;

void fragment() {
    vec4 color;
    switch (texture_index) {
        case 0:
            color = texture(texture_array[0], UV);
            break;
        case 1:
            color = texture(texture_array[1], UV);
            break;
        case 2:
            color = texture(texture_array[2], UV);
            break;
        case 3:
            color = texture(texture_array[3], UV);
            break;
    }

    COLOR = color;
}</literal_block>
                </note>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>There is a practical maximum limit of 16 instance uniforms per shader.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>If your mesh uses multiple materials, the parameters for the first mesh
                            material found will "win" over the subsequent ones, unless they have the same
                            name, index <emphasis>and</emphasis> type. In this case, all parameters are affected correctly.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>If you run into the above situation, you can avoid clashes by manually
                            specifying the index (0-15) of the instance uniform by using the
                            <literal>instance_index</literal> hint:</paragraph>
                    </list_item>
                </bullet_list>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">instance uniform vec4 my_color : source_color, instance_index(5);</literal_block>
                <target refid="doc-shading-language-setting-uniforms-from-code"></target>
            </section>
            <section ids="setting-uniforms-from-code doc-shading-language-setting-uniforms-from-code" names="setting\ uniforms\ from\ code doc_shading_language_setting_uniforms_from_code">
                <title>Setting uniforms from code</title>
                <paragraph>You can set uniforms from GDScript using the
                    <reference internal="True" refuri="../../../classes/class_shadermaterial#class-shadermaterial-method-set-shader-parameter"><inline classes="std std-ref">set_shader_parameter()</inline></reference>
                    method:</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">material.set_shader_parameter("some_value", some_value)

material.set_shader_parameter("colors", [Vector3(1, 0, 0), Vector3(0, 1, 0), Vector3(0, 0, 1)])</literal_block>
                <note>
                    <paragraph>The first argument to <literal>set_shader_parameter()</literal> is the name of the uniform
                        in the shader. It must match <emphasis>exactly</emphasis> to the name of the uniform in
                        the shader or else it will not be recognized.</paragraph>
                </note>
                <paragraph>GDScript uses different variable types than GLSL does, so when passing variables
                    from GDScript to shaders, Godot converts the type automatically. Below is a
                    table of the corresponding types:</paragraph>
                <table>
                    <tgroup cols="3">
                        <colspec colwidth="24"></colspec>
                        <colspec colwidth="25"></colspec>
                        <colspec colwidth="60"></colspec>
                        <thead>
                            <row>
                                <entry>
                                    <paragraph>GLSL type</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>GDScript type</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Notes</paragraph>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph><strong>bool</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>bool</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>bvec2</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>int</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Bitwise packed int where bit 0 (LSB) corresponds to x.</paragraph>
                                    <paragraph>For example, a bvec2 of (bx, by) could be created in
                                        the following way:</paragraph>
                                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">bvec2_input: int = (int(bx)) | (int(by) &lt;&lt; 1)</literal_block>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>bvec3</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>int</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Bitwise packed int where bit 0 (LSB) corresponds to x.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>bvec4</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>int</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Bitwise packed int where bit 0 (LSB) corresponds to x.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>int</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>int</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>ivec2</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Vector2i</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>ivec3</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Vector3i</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>ivec4</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Vector4i</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>uint</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>int</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>uvec2</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Vector2i</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>uvec3</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Vector3i</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>uvec4</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Vector4i</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>float</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>float</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>vec2</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Vector2</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>vec3</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Vector3</strong>, <strong>Color</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>When Color is used, it will be interpreted as (r, g, b).</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>vec4</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Vector4</strong>, <strong>Color</strong>,
                                        <strong>Rect2</strong>, <strong>Plane</strong>,
                                        <strong>Quaternion</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>When Color is used, it will be interpreted as (r, g, b, a).</paragraph>
                                    <paragraph>When Rect2 is used, it will be interpreted as
                                        (position.x, position.y, size.x, size.y).</paragraph>
                                    <paragraph>When Plane is used it will be interpreted as
                                        (normal.x, normal.y, normal.z, d).</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>mat2</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Transform2D</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>mat3</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Basis</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>mat4</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Projection</strong>,
                                        <strong>Transform3D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>When a Transform3D is used, the w Vector is set to the
                                        identity.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Texture2D</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>isampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Texture2D</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>usampler2D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Texture2D</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler2DArray</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Texture2DArray</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>isampler2DArray</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Texture2DArray</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>usampler2DArray</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Texture2DArray</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>sampler3D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Texture3D</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>isampler3D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Texture3D</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>usampler3D</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Texture3D</strong></paragraph>
                                </entry>
                                <entry>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>samplerCube</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>Cubemap</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>See <reference internal="True" refuri="../../assets_pipeline/importing_images#doc-importing-images-changing-import-type"><inline classes="std std-ref">Changing import type</inline></reference> for
                                        instructions on importing cubemaps for use in Godot.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>samplerCubeArray</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>CubemapArray</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Only supported in Forward+ and Mobile, not Compatibility.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>samplerExternalOES</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>ExternalTexture</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Only supported in Compatibility/Android platform.</paragraph>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <note>
                    <paragraph>Be careful when setting shader uniforms from GDScript, since no error
                        will be thrown if the type does not match. Your shader will just exhibit
                        undefined behavior. Specifically, this includes setting a GDScript
                        int/float (64 bit) into a Godot shader language int/float (32 bit).
                        This may lead to unintended consequences in cases where high
                        precision is required.</paragraph>
                </note>
            </section>
            <section ids="uniform-limits" names="uniform\ limits">
                <title>Uniform limits</title>
                <paragraph>There is a limit to the total size of shader uniforms that you can use
                    in a single shader. On most desktop platforms, this limit is <literal>65536</literal>
                    bytes, or 4096 <literal>vec4</literal> uniforms. On mobile platforms, the limit is
                    typically <literal>16384</literal> bytes, or 1024 <literal>vec4</literal> uniforms. Vector uniforms
                    smaller than a <literal>vec4</literal>, such as <literal>vec2</literal> or <literal>vec3</literal>, are padded to
                    the size of a <literal>vec4</literal>. Scalar uniforms such as <literal>int</literal> or <literal>float</literal>
                    are not padded, and <literal>bool</literal> is padded to the size of an <literal>int</literal>.</paragraph>
                <paragraph>Arrays count as the total size of their contents. If you need a uniform
                    array that is larger than this limit, consider packing the data into a
                    texture instead, since the <emphasis>contents</emphasis> of a texture do not count towards
                    this limit, only the size of the sampler uniform.</paragraph>
            </section>
        </section>
        <section ids="built-in-variables" names="built-in\ variables">
            <title>Built-in variables</title>
            <paragraph>A large number of built-in variables are available, like <literal>UV</literal>, <literal>COLOR</literal> and
                <literal>VERTEX</literal>. What variables are available depends on the type of shader
                (<literal>spatial</literal>, <literal>canvas_item</literal>, <literal>particle</literal>, etc) and the
                function used (<literal>vertex</literal>, <literal>fragment</literal>, <literal>light</literal>, <literal>start</literal>, <literal>process</literal>,
                <literal>sky</literal>, or <literal>fog</literal>). For a list of the built-in variables that are available,
                please see the corresponding pages:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="spatial_shader#doc-spatial-shader"><inline classes="std std-ref">Spatial shaders</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">Canvas item shaders</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="particle_shader#doc-particle-shader"><inline classes="std std-ref">Particle shaders</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="sky_shader#doc-sky-shader"><inline classes="std std-ref">Sky shaders</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="fog_shader#doc-fog-shader"><inline classes="std std-ref">Fog shaders</inline></reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="built-in-functions" names="built-in\ functions">
            <title>Built-in functions</title>
            <paragraph>A large number of built-in functions are supported, conforming to GLSL ES 3.0.
                See the <reference internal="True" refuri="shader_functions#doc-shader-functions"><inline classes="std std-ref">Built-in functions</inline></reference> page for details.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
