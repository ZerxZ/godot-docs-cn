<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/shader_reference/shader_preprocessor.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-shader-preprocessor"></target>
    <section ids="shader-preprocessor doc-shader-preprocessor" names="shader\ preprocessor 着色器预处理器 doc_shader_preprocessor">
        <title>着色器预处理器</title>
        <section ids="why-use-a-shader-preprocessor" names="why\ use\ a\ shader\ preprocessor? 为什么要使用着色器预处理器？">
            <title>为什么要使用着色器预处理器？</title>
            <paragraph>In programming languages, a <emphasis>preprocessor</emphasis> allows changing the code before the
                compiler reads it. Unlike the compiler, the preprocessor does not care about
                whether the syntax of the preprocessed code is valid. The preprocessor always
                performs what the <emphasis>directives</emphasis> tell it to do. A directive is a statement
                starting with a hash symbol (<literal>#</literal>). It is not a <emphasis>keyword</emphasis> of the shader
                language (such as <literal>if</literal> or <literal>for</literal>), but a special kind of token within the
                language.</paragraph>
            <paragraph>From Godot 4.0 onwards, you can use a shader preprocessor within text-based
                shaders. The syntax is similar to what most GLSL shader compilers support
                (which in turn is similar to the C/C++ preprocessor).</paragraph>
            <note>
                <paragraph>The shader preprocessor is not available in <reference internal="True" refuri="../visual_shaders#doc-visual-shaders"><inline classes="std std-ref">visual shaders</inline></reference>.
                    If you need to introduce preprocessor statements to a visual shader, you can
                    convert it to a text-based shader using the <strong>Convert to Shader</strong> option in
                    the VisualShader inspector resource dropdown. This conversion is a one-way
                    operation; text shaders cannot be converted back to visual shaders.</paragraph>
            </note>
        </section>
        <section ids="directives" names="directives 指令">
            <title>指令</title>
            <section ids="general-syntax" names="general\ syntax 常规语法">
                <title>常规语法</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>预处理器指令不使用大括号（<literal>{}</literal>），但会用到括号。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>预处理器指令<strong>从不</strong>以分号结尾（除非是 <literal>#define</literal>，允许这么做，但是可能比较危险）。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Preprocessor directives can span several lines by ending each line with a
                            backslash (<literal>\</literal>). The first line break <emphasis>not</emphasis> featuring a backslash will end
                            the preprocessor statement.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="define" names="#define">
                <title>#define</title>
                <paragraph><strong>语法：</strong><literal>#define &lt;标识符&gt; [替换代码]</literal>.</paragraph>
                <paragraph>Defines the identifier after that directive as a macro, and replaces all
                    successive occurrences of it with the replacement code given in the shader.
                    Replacement is performed on a "whole words" basis, which means no replacement is
                    performed if the string is part of another string (without any spaces or
                    operators separating it).</paragraph>
                <paragraph>Defines with replacements may also have one or more <emphasis>arguments</emphasis>, which can then
                    be passed when referencing the define (similar to a function call).</paragraph>
                <paragraph>If the replacement code is not defined, the identifier may only be used with
                    <literal>#ifdef</literal> or <literal>#ifndef</literal> directives.</paragraph>
                <paragraph>If the <emphasis>concatenation</emphasis> symbol (<literal>##</literal>) is present in the replacement code then
                    it will be removed upon macro insertion, together with any space surrounding
                    it, and join the surrounding words and arguments into a new token.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform sampler2D material0;

#define SAMPLE(N) vec4 tex##N = texture(material##N, UV)

void fragment() {
    SAMPLE(0);
    ALBEDO = tex0.rgb;
}</literal_block>
                <paragraph>Compared to constants (<literal>const CONSTANT = value;</literal>), <literal>#define</literal> can be used
                    anywhere within the shader (including in uniform hints).
                    <literal>#define</literal> can also be used to insert arbitrary shader code at any location,
                    while constants can't do that.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

// Notice the lack of semicolon at the end of the line, as the replacement text
// shouldn't insert a semicolon on its own.
// If the directive ends with a semicolon, the semicolon is inserted in every usage
// of the directive, even when this causes a syntax error.
#define USE_MY_COLOR
#define MY_COLOR vec3(1, 0, 0)

// Replacement with arguments.
// All arguments are required (no default values can be provided).
#define BRIGHTEN_COLOR(r, g, b) vec3(r + 0.5, g + 0.5, b + 0.5)

// Multiline replacement using backslashes for continuation:
#define SAMPLE(param1, param2, param3, param4) long_function_call( \
        param1, \
        param2, \
        param3, \
        param4 \
)

void fragment() {
#ifdef USE_MY_COLOR
    ALBEDO = MY_COLOR;
#endif
}</literal_block>
                <paragraph>Defining a <literal>#define</literal> for an identifier that is already defined results in an
                    error. To prevent this, use <literal>#undef &lt;identifier&gt;</literal>.</paragraph>
            </section>
            <section ids="undef" names="#undef">
                <title>#undef</title>
                <paragraph><strong>语法：</strong><literal>#undef 标识符</literal></paragraph>
                <paragraph>The <literal>#undef</literal> directive may be used to cancel a previously defined <literal>#define</literal> directive:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">#define MY_COLOR vec3(1, 0, 0)

vec3 get_red_color() {
    return MY_COLOR;
}

#undef MY_COLOR
#define MY_COLOR vec3(0, 1, 0)

vec3 get_green_color() {
    return MY_COLOR;
}

// Like in most preprocessors, undefining a define that was not previously defined is allowed
// (and won't print any warning or error).
#undef THIS_DOES_NOT_EXIST</literal_block>
                <paragraph>Without <literal>#undef</literal> in the above example, there would be a macro redefinition error.</paragraph>
            </section>
            <section ids="if" names="#if">
                <title>#if</title>
                <paragraph><strong>语法：</strong><literal>#if &lt;条件&gt;</literal></paragraph>
                <paragraph>The <literal>#if</literal> directive checks whether the <literal>condition</literal> passed. If it evaluates
                    to a non-zero value, the code block is included, otherwise it is skipped.</paragraph>
                <paragraph>To evaluate correctly, the condition must be an expression giving a simple
                    floating-point, integer or boolean result. There may be multiple condition
                    blocks connected by <literal>&amp;&amp;</literal> (AND) or <literal>||</literal> (OR) operators. It may be continued
                    by a <literal>#else</literal> block, but <strong>must</strong> be ended with the <literal>#endif</literal> directive.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">#define VAR 3
#define USE_LIGHT 0 // Evaluates to `false`.
#define USE_COLOR 1 // Evaluates to `true`.

#if VAR == 3 &amp;&amp; (USE_LIGHT || USE_COLOR)
// Condition is `true`. Include this portion in the final shader.
#endif</literal_block>
                <paragraph>Using the <literal>defined()</literal> <emphasis>preprocessor function</emphasis>, you can check whether the
                    passed identifier is defined a by <literal>#define</literal> placed above that directive. This
                    is useful for creating multiple shader versions in the same file. It may be
                    continued by a <literal>#else</literal> block, but must be ended with the <literal>#endif</literal> directive.</paragraph>
                <paragraph>The <literal>defined()</literal> function's result can be negated by using the <literal>!</literal> (boolean NOT)
                    symbol in front of it. This can be used to check whether a define is <emphasis>not</emphasis> set.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">#define USE_LIGHT
#define USE_COLOR

// Correct syntax:
#if defined(USE_LIGHT) || defined(USE_COLOR) || !defined(USE_REFRACTION)
// Condition is `true`. Include this portion in the final shader.
#endif</literal_block>
                <paragraph>Be careful, as <literal>defined()</literal> must only wrap a single identifier within parentheses, never more:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">// Incorrect syntax (parentheses are not placed where they should be):
#if defined(USE_LIGHT || USE_COLOR || !USE_REFRACTION)
// This will cause an error or not behave as expected.
#endif</literal_block>
                <tip>
                    <paragraph>In the shader editor, preprocessor branches that evaluate to <literal>false</literal> (and
                        are therefore excluded from the final compiled shader) will appear grayed
                        out. This does not apply to run-time <literal>if</literal> statements.</paragraph>
                </tip>
                <paragraph><strong>#if 预处理器与 if 语句：性能注意事项</strong></paragraph>
                <paragraph><reference internal="True" refuri="shading_language#doc-shading-language"><inline classes="std std-ref">着色语言</inline></reference>支持运行时 <literal>if</literal> 语句：</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uniform bool USE_LIGHT = true;

if (USE_LIGHT) {
    // This part is included in the compiled shader, and always run.
} else {
    // This part is included in the compiled shader, but never run.
}</literal_block>
                <paragraph>如果 uniform 从未改变，那么行为和下面的 <literal>#if</literal> 预处理语句用法是等价的：</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">#define USE_LIGHT

#if defined(USE_LIGHT)
// This part is included in the compiled shader, and always run.
#else
// This part is *not* included in the compiled shader (and therefore never run).
#endif</literal_block>
                <paragraph>不过部分场合 <literal>#if</literal> 的版本会更快一些。这是因为着色器中的运行时分支仍然是会参与编译的，即便运行时不会用到，这些分支中的变量仍然可能会占据寄存器空间。</paragraph>
                <paragraph>现代 GPU 在执行“静态”分支时<reference name="相当高效" refuri="https://medium.com/@jasonbooth_86226/branching-on-a-gpu-18bfc83694f2">相当高效</reference>。这里的“静态”分支指的是在一次给定的着色器调用中，对<emphasis>所有</emphasis>像素/顶点都求得相同结果的 <literal>if</literal> 语句。不过大量的 <abbreviation explanation="Vector General-Purpose Register">VGPR</abbreviation>（分支过多就可能造成这种情况）仍然会显著拖慢着色器的运行。</paragraph>
            </section>
            <section ids="elif" names="#elif">
                <title>#elif</title>
                <paragraph><literal>#elif</literal> 指令就是“else if”的意思，会在之前的 <literal>#if</literal> 求得 <literal>false</literal> 时检查条件是否成立。<literal>#elif</literal> 只能在 <literal>#if</literal> 块中使用。一个 <literal>#if</literal> 语句后面可以使用多个 <literal>#elif</literal>。</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">#define VAR 2

#if VAR == 0
// Not included.
#elif VAR == 1
// Not included.
#elif VAR == 2
// Condition is `true`. Include this portion in the final shader.
#else
// Not included.
#endif</literal_block>
                <paragraph>可以和 <literal>#if</literal> 一样使用预处理器函数 <literal>defined()</literal>：</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">#define SHADOW_QUALITY_MEDIUM

#if defined(SHADOW_QUALITY_HIGH)
// High shadow quality.
#elif defined(SHADOW_QUALITY_MEDIUM)
// Medium shadow quality.
#else
// Low shadow quality.
#endif</literal_block>
            </section>
            <section ids="ifdef" names="#ifdef">
                <title>#ifdef</title>
                <paragraph><strong>语法：</strong><literal>#ifdef &lt;标识符&gt;</literal></paragraph>
                <paragraph>This is a shorthand for <literal>#if defined(...)</literal>. Checks whether the passed
                    identifier is defined by <literal>#define</literal> placed above that directive. This is useful
                    for creating multiple shader versions in the same file. It may be continued by a
                    <literal>#else</literal> block, but must be ended with the <literal>#endif</literal> directive.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">#define USE_LIGHT

#ifdef USE_LIGHT
// USE_LIGHT is defined. Include this portion in the final shader.
#endif</literal_block>
                <paragraph>The processor does <emphasis>not</emphasis> support <literal>#elifdef</literal> as a shortcut for <literal>#elif defined(...)</literal>.
                    Instead, use the following series of <literal>#ifdef</literal> and <literal>#else</literal> when you need more
                    than two branches:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">#define SHADOW_QUALITY_MEDIUM

#ifdef SHADOW_QUALITY_HIGH
// High shadow quality.
#else
#ifdef SHADOW_QUALITY_MEDIUM
// Medium shadow quality.
#else
// Low shadow quality.
#endif // This ends `SHADOW_QUALITY_MEDIUM`'s branch.
#endif // This ends `SHADOW_QUALITY_HIGH`'s branch.</literal_block>
            </section>
            <section ids="ifndef" names="#ifndef">
                <title>#ifndef</title>
                <paragraph><strong>语法：</strong><literal>#ifndef &lt;标识符&gt;</literal></paragraph>
                <paragraph>This is a shorthand for <literal>#if !defined(...)</literal>. Similar to <literal>#ifdef</literal>, but checks
                    whether the passed identifier is <strong>not</strong> defined by <literal>#define</literal> before that
                    directive.</paragraph>
                <paragraph>This is the exact opposite of <literal>#ifdef</literal>; it will always match in situations
                    where <literal>#ifdef</literal> would never match, and vice versa.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">#define USE_LIGHT

#ifndef USE_LIGHT
// Evaluates to `false`. This portion won't be included in the final shader.
#endif

#ifndef USE_COLOR
// Evaluates to `true`. This portion will be included in the final shader.
#endif</literal_block>
            </section>
            <section ids="else" names="#else">
                <title>#else</title>
                <paragraph><strong>语法：</strong><literal>#else</literal></paragraph>
                <paragraph>Defines the optional block which is included when the previously defined <literal>#if</literal>,
                    <literal>#elif</literal>, <literal>#ifdef</literal> or <literal>#ifndef</literal> directive evaluates to false.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;

#define MY_COLOR vec3(1.0, 0, 0)

void fragment() {
#ifdef MY_COLOR
    ALBEDO = MY_COLOR;
#else
    ALBEDO = vec3(0, 0, 1.0);
#endif
}</literal_block>
            </section>
            <section ids="endif" names="#endif">
                <title>#endif</title>
                <paragraph><strong>语法：</strong><literal>#endif</literal></paragraph>
                <paragraph>Used as terminator for the <literal>#if</literal>, <literal>#ifdef</literal>, <literal>#ifndef</literal> or subsequent <literal>#else</literal> directives.</paragraph>
            </section>
            <section ids="include" names="#include">
                <title>#include</title>
                <paragraph><strong>语法：</strong><literal>#include "路径"</literal></paragraph>
                <paragraph>The <literal>#include</literal> directive includes the <emphasis>entire</emphasis> content of a shader include
                    file in a shader. <literal>"path"</literal> can be an absolute <literal>res://</literal> path or relative to
                    the current shader file. Relative paths are only allowed in shaders that are
                    saved to <literal>.gdshader</literal> or <literal>.gdshaderinc</literal> files, while absolute paths can be
                    used in shaders that are built into a scene/resource file.</paragraph>
                <paragraph>You can create new shader includes by using the <strong>File &gt; Create Shader Include</strong>
                    menu option of the shader editor, or by creating a new <reference internal="True" refuri="../../../classes/class_shaderinclude#class-shaderinclude"><inline classes="std std-ref">ShaderInclude</inline></reference> resource
                    in the FileSystem dock.</paragraph>
                <paragraph>Shader includes can be included from within any shader, or other shader include, at
                    any point in the file.</paragraph>
                <paragraph>When including shader includes in the global scope of a shader, it is recommended
                    to do this after the initial <literal>shader_type</literal> statement.</paragraph>
                <paragraph>You can also include shader includes from within the body a function. Please note that
                    the shader editor is likely going to report errors for your shader include's code, as it
                    may not be valid outside of the context that it was written for. You can either choose
                    to ignore these errors (the shader will still compile fine), or you can wrap the include
                    in an <literal>#ifdef</literal> block that checks for a define from your shader.</paragraph>
                <paragraph><literal>#include</literal> is useful for creating libraries of helper functions (or macros)
                    and reducing code duplication. When using <literal>#include</literal>, be careful about naming
                    collisions, as redefining functions or macros is not allowed.</paragraph>
                <paragraph><literal>#include</literal> is subject to several restrictions:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Only shader include resources (ending with <literal>.gdshaderinc</literal>) can be included.
                            <literal>.gdshader</literal> files cannot be included by another shader, but a
                            <literal>.gdshaderinc</literal> file can include other <literal>.gdshaderinc</literal> files.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Cyclic dependencies are <strong>not</strong> allowed and will result in an error.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>To avoid infinite recursion, include depth is limited to 25 steps.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>示例着色器头文件：</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">// fancy_color.gdshaderinc

// While technically allowed, there is usually no `shader_type` declaration in include files.

vec3 get_fancy_color() {
    return vec3(0.3, 0.6, 0.9);
}</literal_block>
                <paragraph>Example base shader (using the include file we created above):</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">// material.gdshader

shader_type spatial;

#include "res://fancy_color.gdshaderinc"

void fragment() {
    // No error, as we've included a definition for `get_fancy_color()` via the shader include.
    COLOR = get_fancy_color();
}</literal_block>
            </section>
            <section ids="pragma" names="#pragma">
                <title>#pragma</title>
                <paragraph><strong>语法：</strong><literal>#pragma 值</literal></paragraph>
                <paragraph>The <literal>#pragma</literal> directive provides additional information to the preprocessor or compiler.</paragraph>
                <paragraph>Currently, it may have only one value: <literal>disable_preprocessor</literal>. If you don't need
                    the preprocessor, use that directive to speed up shader compilation by excluding
                    the preprocessor step.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">#pragma disable_preprocessor

#if USE_LIGHT
// This causes a shader compilation error, as the `#if USE_LIGHT` and `#endif`
// are included as-is in the final shader code.
#endif</literal_block>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
