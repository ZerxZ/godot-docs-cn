<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/shaders/shader_reference/canvas_item_shader.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-canvas-item-shader"></target>
    <section ids="canvasitem-shaders doc-canvas-item-shader" names="canvasitem\ shaders doc_canvas_item_shader">
        <title>CanvasItem shaders</title>
        <paragraph>CanvasItem shaders are used to draw all 2D elements in Godot. These include
            all nodes that inherit from CanvasItems, and all GUI elements.</paragraph>
        <paragraph>CanvasItem shaders contain fewer built-in variables and functionality than
            <reference internal="True" refuri="spatial_shader#doc-spatial-shader"><inline classes="std std-ref">Spatial shaders</inline></reference>, but they maintain the same basic structure
            with vertex, fragment, and light processor functions.</paragraph>
        <section ids="render-modes" names="render\ modes">
            <title>Render modes</title>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="33"></colspec>
                    <colspec colwidth="70"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Render mode</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Description</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><strong>blend_mix</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Mix blend mode (alpha is transparency), default.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>blend_add</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Additive blend mode.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>blend_sub</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Subtractive blend mode.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>blend_mul</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Multiplicative blend mode.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>blend_premul_alpha</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Pre-multiplied alpha blend mode.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>blend_disabled</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Disable blending, values (including alpha) are written as-is.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>unshaded</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Result is just albedo. No lighting/shading happens in material.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>light_only</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Only draw in the light pass.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>skip_vertex_transform</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>VERTEX</literal> needs to be transformed manually in the <literal>vertex()</literal>
                                    function.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><strong>world_vertex_coords</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>VERTEX</literal> is modified in world coordinates instead of local.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section ids="built-ins" names="built-ins">
            <title>Built-ins</title>
            <paragraph>Values marked as <literal>in</literal> are read-only. Values marked as <literal>out</literal> can optionally be written to and will
                not necessarily contain sensible values. Values marked as <literal>inout</literal> provide a sensible default
                value, and can optionally be written to. Samplers cannot be written to so they are not marked.</paragraph>
            <paragraph>Not all built-ins are available in all processing functions. To access a vertex
                built-in from the <literal>fragment()</literal> function, you can use a <reference internal="True" refuri="shading_language#doc-shading-language-varyings"><inline classes="std std-ref">varying</inline></reference>.
                The same applies for accessing fragment built-ins from the <literal>light()</literal> function.</paragraph>
        </section>
        <section ids="global-built-ins" names="global\ built-ins">
            <title>Global built-ins</title>
            <paragraph>Global built-ins are available everywhere, including custom functions.</paragraph>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="19"></colspec>
                    <colspec colwidth="97"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Built-in</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Description</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>in float <strong>TIME</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Global time since the engine has started, in seconds. It repeats after every <literal>3,600</literal>
                                    seconds (which can be changed with the
                                    <reference internal="True" refuri="../../../classes/class_projectsettings#class-projectsettings-property-rendering-limits-time-time-rollover-secs"><inline classes="std std-ref">rollover</inline></reference>
                                    setting). It's affected by
                                    <reference internal="True" refuri="../../../classes/class_engine#class-engine-property-time-scale"><inline classes="std std-ref">time_scale</inline></reference> but not by pausing. If you need a
                                    <literal>TIME</literal> variable that is not affected by time scale, add your own
                                    <reference internal="True" refuri="shading_language#doc-shading-language-global-uniforms"><inline classes="std std-ref">global shader uniform</inline></reference> and update it each
                                    frame.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in float <strong>PI</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>A <literal>PI</literal> constant (<literal>3.141592</literal>).
                                    The ratio of a circle's circumference to its diameter and the number of radians in a half turn.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in float <strong>TAU</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>A <literal>TAU</literal> constant (<literal>6.283185</literal>).
                                    Equivalent to <literal>PI * 2</literal> and the number of radians in a full turn.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in float <strong>E</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>An <literal>E</literal> constant (<literal>2.718281</literal>).
                                    Euler's number, the base of the natural logarithm.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section ids="vertex-built-ins" names="vertex\ built-ins">
            <title>Vertex built-ins</title>
            <paragraph>Vertex data (<literal>VERTEX</literal>) is presented in local space (pixel coordinates, relative to the Node2D's origin).
                If not written to, these values will not be modified and be passed through as they came.</paragraph>
            <paragraph>The user can disable the built-in model to world transform (world to screen and projection will still
                happen later) and do it manually with the following code:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;
render_mode skip_vertex_transform;

void vertex() {

    VERTEX = (MODEL_MATRIX * vec4(VERTEX, 0.0, 1.0)).xy;
}</literal_block>
            <paragraph>Other built-ins, such as <literal>UV</literal> and <literal>COLOR</literal>, are also passed through to the <literal>fragment()</literal> function if not modified.</paragraph>
            <paragraph>For instancing, the <literal>INSTANCE_CUSTOM</literal> variable contains the instance custom data. When using particles, this information
                is usually:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph><strong>x</strong>: Rotation angle in radians.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>y</strong>: Phase during lifetime (<literal>0.0</literal> to <literal>1.0</literal>).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>z</strong>: Animation frame.</paragraph>
                </list_item>
            </bullet_list>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="32"></colspec>
                    <colspec colwidth="64"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Built-in</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Description</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>in mat4 <strong>MODEL_MATRIX</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Local space to world space transform. World space
                                    is the coordinates you normally use in the editor.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in mat4 <strong>CANVAS_MATRIX</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>World space to canvas space transform. In canvas
                                    space the origin is the upper-left corner of the
                                    screen and coordinates range from <literal>(0.0, 0.0)</literal>
                                    to viewport size.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in mat4 <strong>SCREEN_MATRIX</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Canvas space to clip space transform. In clip space
                                    coordinates range from <literal>(-1.0, -1.0)</literal> to
                                    <literal>(1.0, 1.0).</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in int  <strong>INSTANCE_ID</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Instance ID for instancing.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec4 <strong>INSTANCE_CUSTOM</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Instance custom data.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in bool <strong>AT_LIGHT_PASS</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Always <literal>false</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec2 <strong>TEXTURE_PIXEL_SIZE</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Normalized pixel size of the default 2D texture.
                                    For a Sprite2D with a texture of size 64x32px,
                                    <strong>TEXTURE_PIXEL_SIZE</strong> = <literal>vec2(1.0/64.0, 1.0/32.0)</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>inout vec2 <strong>VERTEX</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Vertex position, in local space.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in int <strong>VERTEX_ID</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>The index of the current vertex in the vertex
                                    buffer.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>inout vec2 <strong>UV</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Normalized texture coordinates. Range from <literal>0.0</literal>
                                    to <literal>1.0</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>inout vec4 <strong>COLOR</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Color from vertex primitive multiplied by the CanvasItem's
                                    <reference internal="True" refuri="../../../classes/class_canvasitem#class-canvasitem-property-modulate"><inline classes="std std-ref">modulate</inline></reference>
                                    multiplied by CanvasItem's
                                    <reference internal="True" refuri="../../../classes/class_canvasitem#class-canvasitem-property-self-modulate"><inline classes="std std-ref">self_modulate</inline></reference>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>inout float <strong>POINT_SIZE</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Point size for point drawing.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec4 <strong>CUSTOM0</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Custom value from vertex primitive.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec4 <strong>CUSTOM1</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Custom value from vertex primitive.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section ids="fragment-built-ins" names="fragment\ built-ins">
            <title>Fragment built-ins</title>
            <section ids="color-and-texture" names="color\ and\ texture">
                <title>COLOR and TEXTURE</title>
                <paragraph>The built-in variable <literal>COLOR</literal> is used for a few things:</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>In the <literal>vertex()</literal> function, <literal>COLOR</literal> contains the color from the vertex
                                primitive multiplied by the CanvasItem's
                                <reference internal="True" refuri="../../../classes/class_canvasitem#class-canvasitem-property-modulate"><inline classes="std std-ref">modulate</inline></reference> multiplied by the
                                CanvasItem's <reference internal="True" refuri="../../../classes/class_canvasitem#class-canvasitem-property-self-modulate"><inline classes="std std-ref">self_modulate</inline></reference>.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>In the <literal>fragment()</literal> function, the input value <literal>COLOR</literal> is that same value
                                multiplied by the color from the default <literal>TEXTURE</literal> (if present).</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>In the <literal>fragment()</literal> function, <literal>COLOR</literal> is also the final output.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
                <paragraph>Certain nodes (for example, <reference internal="True" refuri="../../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite2D</inline></reference>) display a texture
                    by default, for example <reference internal="True" refuri="../../../classes/class_sprite2d#class-sprite2d-property-texture"><inline classes="std std-ref">texture</inline></reference>. When
                    using a custom <literal>fragment()</literal> function, you have a few options on how to sample
                    this texture.</paragraph>
                <paragraph>To read only the contents of the default texture, ignoring the vertex <literal>COLOR</literal>:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  COLOR = texture(TEXTURE, UV);
}</literal_block>
                <paragraph>To read the contents of the default texture multiplied by vertex <literal>COLOR</literal>:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void fragment() {
  // Equivalent to an empty fragment() function, since COLOR is also the output variable.
  COLOR = COLOR;
}</literal_block>
                <paragraph>To read only the vertex <literal>COLOR</literal> in <literal>fragment()</literal>, ignoring the main texture,
                    you must pass <literal>COLOR</literal> as a varying, then read it in <literal>fragment()</literal>:</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">varying vec4 vertex_color;
void vertex() {
  vertex_color = COLOR;
}
void fragment() {
  COLOR = vertex_color;
}</literal_block>
            </section>
            <section ids="normal" names="normal">
                <title>NORMAL</title>
                <paragraph>Similarly, if a normal map is used in the <reference internal="True" refuri="../../../classes/class_canvastexture#class-canvastexture"><inline classes="std std-ref">CanvasTexture</inline></reference>, Godot uses
                    it by default and assigns its value to the built-in <literal>NORMAL</literal> variable. If you are using a normal
                    map meant for use in 3D, it will appear inverted. In order to use it in your shader, you must assign
                    it to the <literal>NORMAL_MAP</literal> property. Godot will handle converting it for use in 2D and overwriting <literal>NORMAL</literal>.</paragraph>
                <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">NORMAL_MAP = texture(NORMAL_TEXTURE, UV).rgb;</literal_block>
                <table>
                    <tgroup cols="2">
                        <colspec colwidth="45"></colspec>
                        <colspec colwidth="63"></colspec>
                        <thead>
                            <row>
                                <entry>
                                    <paragraph>Built-in</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Description</paragraph>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph>in vec4 <strong>FRAGCOORD</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Coordinate of pixel center. In screen space. <literal>xy</literal> specifies
                                        position in viewport. Upper-left of the viewport is the
                                        origin, <literal>(0.0, 0.0)</literal>.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>in vec2 <strong>SCREEN_PIXEL_SIZE</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Size of individual pixels. Equal to the inverse of resolution.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>in vec4 <strong>REGION_RECT</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Visible area of the sprite region in format
                                        <literal>(x, y, width, height)</literal>. Varies according to
                                        Sprite2D's <literal>region_enabled</literal> property.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>in vec2 <strong>POINT_COORD</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Coordinate for drawing points.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>sampler2D <strong>TEXTURE</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Default 2D texture.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>in vec2 <strong>TEXTURE_PIXEL_SIZE</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Normalized pixel size of the default 2D texture.
                                        For a Sprite2D with a texture of size 64x32px,
                                        <literal>TEXTURE_PIXEL_SIZE</literal> = <literal>vec2(1/64, 1/32)</literal></paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>in bool <strong>AT_LIGHT_PASS</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Always <literal>false</literal>.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>sampler2D <strong>SPECULAR_SHININESS_TEXTURE</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Specular shininess texture of this object.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>in vec4 <strong>SPECULAR_SHININESS</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Specular shininess color, as sampled from the texture.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>in vec2 <strong>UV</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>UV from the <literal>vertex()</literal> function.
                                        For a Sprite2D with region enabled, this will sample the
                                        entire texture. Use <literal>REGION_RECT</literal> instead to sample only
                                        the region defined in the Sprite2D's properties.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>in vec2 <strong>SCREEN_UV</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Screen UV coordinate for the current pixel.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>sampler2D <strong>SCREEN_TEXTURE</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Removed in Godot 4. Use a <literal>sampler2D</literal> with
                                        <literal>hint_screen_texture</literal> instead.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>inout vec3 <strong>NORMAL</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Normal read from <literal>NORMAL_TEXTURE</literal>. Writable.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>sampler2D <strong>NORMAL_TEXTURE</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Default 2D normal texture.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>out vec3 <strong>NORMAL_MAP</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Configures normal maps meant for 3D for use in 2D. If used,
                                        overrides <literal>NORMAL</literal>.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>out float <strong>NORMAL_MAP_DEPTH</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Normal map depth for scaling.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>inout vec2 <strong>VERTEX</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Pixel position in screen space.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>inout vec2 <strong>SHADOW_VERTEX</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Same as <literal>VERTEX</literal> but can be written to alter shadows.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>inout vec3 <strong>LIGHT_VERTEX</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Same as <literal>VERTEX</literal> but can be written to alter lighting.
                                        Z component represents height.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>inout vec4 <strong>COLOR</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><literal>COLOR</literal> from the <literal>vertex()</literal> function multiplied by the
                                        <literal>TEXTURE</literal> color. Also output color value.</paragraph>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </section>
        </section>
        <section ids="light-built-ins" names="light\ built-ins">
            <title>Light built-ins</title>
            <paragraph>Light processor functions work differently in Godot 4.x than they did in Godot
                3.x. In Godot 4.x all lighting is done during the regular draw pass. In other
                words, Godot no longer draws the object again for each light.</paragraph>
            <paragraph>Use the <literal>unshaded</literal> render mode if you do not want the <literal>light()</literal> function to
                run. Use the <literal>light_only</literal> render mode if you only want to see the impact of
                lighting on an object; this can be useful when you only want the object visible
                where it is covered by light.</paragraph>
            <paragraph>If you define a <literal>light()</literal> function it will replace the built-in light function,
                even if your light function is empty.</paragraph>
            <paragraph>Below is an example of a light shader that takes a CanvasItem's normal map into account:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">void light() {
  float cNdotL = max(0.0, dot(NORMAL, LIGHT_DIRECTION));
  LIGHT = vec4(LIGHT_COLOR.rgb * COLOR.rgb * LIGHT_ENERGY * cNdotL, LIGHT_COLOR.a);
}</literal_block>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="34"></colspec>
                    <colspec colwidth="78"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Built-in</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Description</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>in vec4 <strong>FRAGCOORD</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Coordinate of pixel center. In screen space. <literal>xy</literal> specifies
                                    position in viewport. Upper-left of the viewport is the origin,
                                    <literal>(0.0, 0.0)</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec3 <strong>NORMAL</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Input normal.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec4 <strong>COLOR</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Input color. This is the output of the <literal>fragment()</literal> function.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec2 <strong>UV</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>UV from the <literal>vertex()</literal> function, equivalent to the UV in the
                                    <literal>fragment()</literal> function.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>sampler2D <strong>TEXTURE</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Current texture in use for the CanvasItem.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec2 <strong>TEXTURE_PIXEL_SIZE</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Normalized pixel size of <literal>TEXTURE</literal>.
                                    For a Sprite2D with a <literal>TEXTURE</literal> of size <literal>64x32</literal> pixels,
                                    <strong>TEXTURE_PIXEL_SIZE</strong> = <literal>vec2(1/64, 1/32)</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec2 <strong>SCREEN_UV</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Screen UV coordinate for the current pixel.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec2 <strong>POINT_COORD</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>UV for Point Sprite.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec4 <strong>LIGHT_COLOR</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../../classes/class_light2d#class-light2d-property-color"><inline classes="std std-ref">Color</inline></reference> of the <reference internal="True" refuri="../../../classes/class_light2d#class-light2d"><inline classes="std std-ref">Light2D</inline></reference>.
                                    If the light is a <reference internal="True" refuri="../../../classes/class_pointlight2d#class-pointlight2d"><inline classes="std std-ref">PointLight2D</inline></reference>, multiplied by the light's
                                    <reference internal="True" refuri="../../../classes/class_pointlight2d#class-pointlight2d-property-texture"><inline classes="std std-ref">texture</inline></reference>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in float <strong>LIGHT_ENERGY</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../../classes/class_light2d#class-light2d-property-energy"><inline classes="std std-ref">Energy multiplier</inline></reference> of the
                                    <reference internal="True" refuri="../../../classes/class_light2d#class-light2d"><inline classes="std std-ref">Light2D</inline></reference>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec3 <strong>LIGHT_POSITION</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Position of the <reference internal="True" refuri="../../../classes/class_light2d#class-light2d"><inline classes="std std-ref">Light2D</inline></reference> in screen space. If using a
                                    <reference internal="True" refuri="../../../classes/class_directionallight2d#class-directionallight2d"><inline classes="std std-ref">DirectionalLight2D</inline></reference> this is always <literal>(0.0, 0.0, 0.0)</literal>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec3 <strong>LIGHT_DIRECTION</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Direction of the <reference internal="True" refuri="../../../classes/class_light2d#class-light2d"><inline classes="std std-ref">Light2D</inline></reference> in screen space.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in bool <strong>LIGHT_IS_DIRECTIONAL</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>true</literal> if this pass is a <reference internal="True" refuri="../../../classes/class_directionallight2d#class-directionallight2d"><inline classes="std std-ref">DirectionalLight2D</inline></reference>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec3 <strong>LIGHT_VERTEX</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Pixel position, in screen space as modified in the <literal>fragment()</literal> function.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>inout vec4 <strong>LIGHT</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Output color for this <reference internal="True" refuri="../../../classes/class_light2d#class-light2d"><inline classes="std std-ref">Light2D</inline></reference>.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>in vec4 <strong>SPECULAR_SHININESS</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Specular shininess, as set in the object's texture.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>out vec4 <strong>SHADOW_MODULATE</strong></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Multiply shadows cast at this point by this color.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section ids="sdf-functions" names="sdf\ functions">
            <title>SDF functions</title>
            <paragraph>There are a few additional functions implemented to sample an automatically
                generated Signed Distance Field texture. These functions are available in the <literal>fragment()</literal>
                and <literal>light()</literal> functions of CanvasItem shaders. Custom functions may also use them as long
                as they are called from supported functions.</paragraph>
            <paragraph>The signed distance field is generated from <reference internal="True" refuri="../../../classes/class_lightoccluder2d#class-lightoccluder2d"><inline classes="std std-ref">LightOccluder2D</inline></reference> nodes
                present in the scene with the <strong>SDF Collision</strong> property enabled (which is the
                default). See the <reference internal="True" refuri="../../2d/2d_lights_and_shadows#doc-2d-lights-and-shadows-setting-up-shadows"><inline classes="std std-ref">2D lights and shadows</inline></reference>
                documentation for more information.</paragraph>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="47"></colspec>
                    <colspec colwidth="43"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Function</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Description</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>float <strong>texture_sdf</strong> (vec2 sdf_pos)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Performs an SDF texture lookup.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec2 <strong>texture_sdf_normal</strong> (vec2 sdf_pos)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Calculates a normal from the SDF texture.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec2 <strong>sdf_to_screen_uv</strong> (vec2 sdf_pos)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Converts an SDF to screen UV.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>vec2 <strong>screen_uv_to_sdf</strong> (vec2 uv)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Converts screen UV to an SDF.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
