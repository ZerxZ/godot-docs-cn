<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/export/exporting_for_dedicated_servers.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-exporting-for-dedicated-servers"></target>
    <section ids="exporting-for-dedicated-servers doc-exporting-for-dedicated-servers" names="exporting\ for\ dedicated\ servers 为专用服务器导出 doc_exporting_for_dedicated_servers">
        <title>为专用服务器导出</title>
        <paragraph>如果要在没有 GPU 或没有显示服务器的机器上为项目运行专用服务器，你需要在运行 Godot 的时候使用 <literal>headless</literal> 显示服务器和 <literal>Dummy</literal> <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-audio-driver-driver"><inline classes="std std-ref">音频驱动</inline></reference>。</paragraph>
        <paragraph>从Godot 4.0开始，这可以透过在任何平台上使用「--headless」命令列参数来执行Godot二进位档案或执行导出为专用服务器的项目来完成。与Godot 3.x不同，你不再需要使用专门的服务器二进位。</paragraph>
        <section ids="editor-versus-export-template" names="editor\ versus\ export\ template 编辑器与导出模板">
            <title>编辑器与导出模板</title>
            <paragraph>可以在无头模式下使用编辑器或导出模板（调试或发布）二进位。你应该使用哪一种取决于你的用例：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Export template:</strong> Use this one for running dedicated servers. It does not
                        contain editor functionality, and is therefore smaller and more optimized.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Editor:</strong> This binary contains editor functionality and is intended to be
                        used for exporting projects. This binary <emphasis>can</emphasis> be used to run dedicated
                        servers, but it's not recommended as it's larger and less optimized.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="export-approaches" names="export\ approaches 导出方法">
            <title>导出方法</title>
            <paragraph>有两种方法可以导出服务项目:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Create a separate export preset for the platform that will host the server, then
                        export your project as usual.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>仅导出PCK档案，最好是与将托管服务器的平台相配对的平台。将此PCK档案放在与导出模板二进位档案相同的文件夹中，将二进位档案重新命名为与PCK相同的名称（减去文件扩展名），然后执行该二进位档案。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Both methods should result in identical output. The rest of the page will focus
                on the first approach.</paragraph>
            <paragraph>详见 <reference internal="True" refuri="exporting_projects#doc-exporting-projects"><inline classes="std std-ref">导出项目</inline></reference> .</paragraph>
            <target refid="doc-exporting-for-dedicated-servers-exporting-project"></target>
        </section>
        <section ids="exporting-a-project-for-a-dedicated-server doc-exporting-for-dedicated-servers-exporting-project" names="exporting\ a\ project\ for\ a\ dedicated\ server 为专用服务器导出项目 doc_exporting_for_dedicated_servers_exporting_project">
            <title>为专用服务器导出项目</title>
            <paragraph>如果你在以服务器为目标时照常导出项目，你会注意到PCK档案与客户端一样大。这是因为它包含所有资源，包括服务器不需要的资源（例如纹理数据）。此外，不会自动使用无头模式；使用者必须指定“--headless”以确保没有视窗生成。</paragraph>
            <paragraph>许多资源（例如纹理）可以从PCK档案中剥离，以大大减少其大小。Godot提供了一种对纹理和材质执行此操作的方法，可保留场景或资源档案（内置或外部）中的参考。</paragraph>
            <paragraph>首先，请确保你的服务器有专用的导出预设，然后选择它，转到其**Resources**标签并更改其导出模式：</paragraph>
            <figure align="center" ids="id1">
                <image alt="在导出预设中选择**导出为专用服务器**导出模式" candidates="{'*': 'tutorials/export/img/exporting_for_dedicated_servers_export_mode.webp'}" uri="tutorials/export/img/exporting_for_dedicated_servers_export_mode.webp"></image>
                <caption>在导出预设中选择**导出为专用服务器**导出模式</caption>
            </figure>
            <paragraph>选择此导出模式后，「dedicated_server」功能标记将自动新增至导出的项目。</paragraph>
            <note>
                <paragraph>如果你不想使用此导出模式但仍需要功能标签，则可以在导出预设的**功能**标签中写入名称``dedicated_server``。当运作导出的项目时，这也会强制“--headless”。</paragraph>
            </note>
            <paragraph>选择此导出模式后，你将看到项目中的资源列表：</paragraph>
            <figure align="center" ids="id2">
                <image alt="选择要保留的资源、保留剥离的视觉效果或删除" candidates="{'*': 'tutorials/export/img/exporting_for_dedicated_servers_export_resources.webp'}" uri="tutorials/export/img/exporting_for_dedicated_servers_export_resources.webp"></image>
                <caption>选择要保留的资源、保留剥离的视觉效果或删除</caption>
            </figure>
            <paragraph>勾选复选框可让你复写指定档案或文件夹的选项。复选框**不会**影响导出哪些档案；这是透过为每个复选框选择的选项来完成的。</paragraph>
            <paragraph>预设情况下，提取文件夹中的档案将自动使用父级选项，这由选项名称的**（Inherited）**后缀表示（并且选项名称呈灰色）。若要变更目前继承选项的档案的选项，必须先勾选该档案旁的方块。</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><problematic ids="id2" refid="id1">**</problematic>Strip Visuals：<problematic ids="id4" refid="id3">**</problematic>导出此资源，并将视觉档案（纹理和材质）替换为占位符类别。占位符类别储存图像大小（因为它有时用于在2D场景中定位元素），但不储存其他内容。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><problematic ids="id2" refid="id1">**</problematic>Keep：<problematic ids="id4" refid="id3">**</problematic>照常导出此资源，并保留完整的视觉文件。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><problematic ids="id2" refid="id1">**</problematic>Remove：<problematic ids="id4" refid="id3">**</problematic>该档案不包含在PCK中。这对于忽略只有客户端需要的场景和资源很有用。如果这样做，请确保服务器不会以任何方式引用这些仅限客户端的场景和资源。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>一般建议是尽可能使用**Strip Visuals**，除非服务器需要存取图像数据（例如像素颜色）。例如，如果你的服务器根据图象的内容产生碰撞数据，则你需要对该特定图象使用**Keep**。</paragraph>
            <tip>
                <paragraph>若要检查导出的PCK的档案结构，请使用带有「.zip」文件扩展名的「<strong>Export PCK/ZIP…</strong>」按钮，然后在档案管理器中开启产生的ZIP档案。</paragraph>
            </tip>
            <warning>
                <paragraph>使用**Remove**模式时要小心，因为引用已删除档案的场景/资源将无法再成功加载。</paragraph>
                <paragraph>If you wish to remove specific resources but make the scenes still be able
                    to load without them, you'll have to remove the reference in the scene file
                    and load the files to the nodes' properties using <literal>load()</literal> in a script.
                    This approach can be used to strip resources that Godot doesn't support
                    replacing with placeholders yet, such as audio.</paragraph>
                <paragraph>删除纹理通常对PCK大小影响最大，因此建议先坚持使用**Strip Visuals**。</paragraph>
            </warning>
            <paragraph>使用上面的选项后，客户端的 PCK（正常导出所有资源）是这样的：</paragraph>
            <literal_block force="False" language="none" linenos="False" xml:space="preserve">.
├── .godot
│   ├── exported
│   │   └── 133200997
│   │       └── export-78c237d4bfdb4e1d02e0b5f38ddfd8bd-scene.scn
│   ├── global_script_class_cache.cfg
│   ├── imported
│   │   ├── map_data.png-ce840618f399a990343bfc7298195a13.ctex
│   │   ├── music.ogg-fa883da45ae49695a3d022f64e60aee2.oggvorbisstr
│   │   └── sprite.png-7958af25f91bb9dbae43f35388f8e840.ctex
│   └── uid_cache.bin
├── client
│   ├── music.ogg.import
│   └── sprite.png.import
├── server
│   └── map_data.png.import
├── test
│   └── scene.gd
└── unused
│   └── development_test.gd
├── project.binary
├── scene.gd
├── scene.tscn.remap</literal_block>
            <paragraph>服务器的 PCK 文件结构是这样的：</paragraph>
            <literal_block force="False" language="none" linenos="False" xml:space="preserve">.
├── .godot
│   ├── exported
│   │   └── 3400186661
│   │       ├── export-78c237d4bfdb4e1d02e0b5f38ddfd8bd-scene.scn
│   │       ├── export-7958af25f91bb9dbae43f35388f8e840-sprite.res  # Placeholder texture
│   │       └── export-fa883da45ae49695a3d022f64e60aee2-music.res
│   ├── global_script_class_cache.cfg
│   ├── imported
│   │   └── map_data.png-ce840618f399a990343bfc7298195a13.ctex
│   └── uid_cache.bin
├── client
│   ├── music.ogg.import
│   └── sprite.png.import  # Points to placeholder texture
└── server
│   └── map_data.png.import
├── project.binary
├── scene.gd
├── scene.tscn.remap</literal_block>
        </section>
        <section ids="starting-the-dedicated-server" names="starting\ the\ dedicated\ server 启动专用服务">
            <title>启动专用服务</title>
            <paragraph>如果你的客户端和服务都是同一个 Godot 项目的一部分，你必须添加一个使用命令行参数直接启动服务的方法。这可以通过在你的主场景（或单例）的 <literal>_ready()</literal> 方法中添加以下代码片段来实现。</paragraph>
            <paragraph>如果你使用**导出为专用服务器**导出模式导出了项目&lt;doc_exporting_for_dedicated_servers_exporting_project&gt;`（或已新增``dedicated_server``作为自定义功能标记），则可以使用``dedicated_server``用于侦测是否正在使用专用服务器PCK的功能标记：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Note: Feature tags are case-sensitive.
if OS.has_feature("dedicated_server"):
    # Run your server startup code here...
    pass</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Note: Feature tags are case-sensitive.
if (OS.HasFeature("dedicated_server"))
{
    // Run your server startup code here...
}</literal_block>
                </div>
            </container>
            <paragraph>If you also wish to host a server when using the built-in <literal>--headless</literal> command
                line argument, this can be done by adding the following code snippet in your
                main scene (or an autoload)'s <literal>_ready()</literal> method:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">if DisplayServer.get_name() == "headless":
    # Run your server startup code here...
    #
    # Using this check, you can start a dedicated server by running
    # a Godot binary (editor or export template) with the `--headless`
    # command-line argument.
    pass</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using System.Linq;

if (DisplayServer.GetName() == "headless")
{
    // Run your server startup code here...
    //
    // Using this check, you can start a dedicated server by running
    // a Godot binary (editor or export template) with the `--headless`
    // command-line argument.
}</literal_block>
                </div>
            </container>
            <paragraph>If you wish to use a custom command line argument, this can be done by adding
                the following code snippet in your main scene (or an autoload)'s <literal>_ready()</literal>
                method:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">if "--server" in OS.get_cmdline_user_args():
    # Run your server startup code here...
    #
    # Using this check, you can start a dedicated server by running
    # a Godot binary (editor or export template) with the `--server`
    # command-line argument.
    pass</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using System.Linq;

if (OS.GetCmdlineUserArgs().Contains("--server"))
{
    // Run your server startup code here...
    //
    // Using this check, you can start a dedicated server by running
    // a Godot binary (editor or export template) with the `--server`
    // command-line argument.
}</literal_block>
                </div>
            </container>
            <paragraph>最好新增至少一个上述命令列参数来启动服务器，因为它可用于从命令列测试服务器功能，而无需导出项目。</paragraph>
            <paragraph>如果你的客户端和服务器是独立的Godot项目, 服务器通常应该配置成运行主场景时自启服务的方式.</paragraph>
        </section>
        <section ids="next-steps" names="next\ steps 下一步">
            <title>下一步</title>
            <paragraph>在Linux上, 为了让你的专用服务在崩溃或系统重启后重新启动, 你可以 <reference name="创建一个系统服务" refuri="https://medium.com/@benmorel/creating-a-linux-servicewith-systemd-611b5c8b91d6">创建一个系统服务</reference> . 这也可以更方便的查看服务器日志, 系统提供的日志自动轮询功能.</paragraph>
            <paragraph>如果你有容器的经验, 可以考虑将专用服务器包装在一个 <reference name="Docker" refuri="https://www.docker.com/">Docker</reference> 容器中. 这样, 在弹性配置中可以更容易地使用它(这不在本教程的范围内).</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
