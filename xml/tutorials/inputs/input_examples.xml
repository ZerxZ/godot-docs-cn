<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/inputs/input_examples.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-input-examples"></target>
    <section ids="input-examples doc-input-examples" names="input\ examples 输入示例 doc_input_examples">
        <title>输入示例</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>在本教程中, 你将学习如何使用Godot的 <reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">输入事件</inline></reference> 系统捕获玩家输入. 你的游戏可以使用多种不同类型的输入——键盘, 游戏手柄, 鼠标等等. 还有许多不同的方法, 将这些输入转化为游戏中的动作. 本文将向你展示一些最常见的场景, 你可以将其作为你自己项目的起点.</paragraph>
            <note>
                <paragraph>要详细了解 Godot 的输入事件系统是如何工作的，请参阅 <reference internal="True" refuri="inputevent#doc-inputevent"><inline classes="std std-ref">使用 InputEvent</inline></reference>。</paragraph>
            </note>
        </section>
        <section ids="events-versus-polling" names="events\ versus\ polling 事件和轮询">
            <title>事件和轮询</title>
            <paragraph>有时你想让你的游戏对某一输入事件作出反应--例如按下 "跳跃" 按钮. 在其他情况下, 你可能希望只要有一个键被按下就会发生一些事情, 比如移动. 在第一种情况下, 你可以使用 <literal>_input()</literal> 函数, 只要有输入事件发生就会调用该函数. 在第二种情况下,Godot提供了 <reference internal="True" refuri="../../classes/class_input#class-input"><inline classes="std std-ref">Input</inline></reference> 单例, 你可以用它来查询一个输入的状态.</paragraph>
            <paragraph>示例：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _input(event):
    if event.is_action_pressed("jump"):
        jump()


func _physics_process(delta):
    if Input.is_action_pressed("move_right"):
        # Move as long as the key/button is pressed.
        position.x += speed * delta</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Input(InputEvent @event)
{
    if (@event.IsActionPressed("jump"))
    {
        Jump();
    }
}

public override void _PhysicsProcess(double delta)
{
    if (Input.IsActionPressed("move_right"))
    {
        // Move as long as the key/button is pressed.
        position.X += speed * (float)delta;
    }
}</literal_block>
                </div>
            </container>
            <paragraph>这使你能够灵活地混合和匹配所执行输入的处理类型.</paragraph>
            <paragraph>对于本教程的其余部分, 我们将专注于使用 <literal>_input ()</literal> 捕捉单个事件.</paragraph>
        </section>
        <section ids="input-events" names="input\ events 输入事件">
            <title>输入事件</title>
            <paragraph>输入事件是继承自 <reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">输入事件</inline></reference> 的对象. 根据事件类型, 对象将包含与该事件相关的特定属性. 为了了解事件的实际情况, 添加一个节点并附加以下脚本:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node


func _input(event):
    print(event.as_text())</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Node : Godot.Node
{
    public override void _Input(InputEvent @event)
    {
        GD.Print(@event.AsText());
    }
}</literal_block>
                </div>
            </container>
            <paragraph>当你按下按键, 移动鼠标, 并执行其他输入, 你会在输出窗口中看到每个事件滚动. 下面是输出的一个例子:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">A
Mouse motion at position ((971, 5)) with velocity ((0, 0))
Right Mouse Button
Mouse motion at position ((870, 243)) with velocity ((0.454937, -0.454937))
Left Mouse Button
Mouse Wheel Up
A
B
Shift
Alt+Shift
Alt
Shift+T
Mouse motion at position ((868, 242)) with velocity ((-2.134768, 2.134768))</literal_block>
            <paragraph>如你所见, 对于不同类型的输入, 结果是非常不同的. 按键事件甚至被打印为按键符号. 例如, 让我们考虑 <reference internal="True" refuri="../../classes/class_inputeventmousebutton#class-inputeventmousebutton"><inline classes="std std-ref">鼠标按钮输入事件</inline></reference> . 它继承自以下类:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> - 所有输入事件的基类</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_inputeventwithmodifiers#class-inputeventwithmodifiers"><inline classes="std std-ref">InputEventWithModifiers</inline></reference> - 增加了检查是否按下修饰按键, 如 <literal classes="kbd">Shift</literal> 或 <literal classes="kbd">Alt</literal> .</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_inputeventmouse#class-inputeventmouse"><inline classes="std std-ref">InputEventMouse</inline></reference> - 增加鼠标事件属性, 如 <literal>position</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_inputeventmousebutton#class-inputeventmousebutton"><inline classes="std std-ref">鼠标按钮输入事件</inline></reference> 包含按下的按钮的索引, 无论是双击, 或是其他.</paragraph>
                </list_item>
            </bullet_list>
            <tip>
                <paragraph>在处理事件时, 打开类引用是一个好主意, 这样可以检查事件类型的可用属性和方法.</paragraph>
            </tip>
            <paragraph>如果你尝试访问不包含属性的输入类型上的属性, 则可能会遇到错误-例如, 对 <literal>InputEventKey</literal> 调用 <literal>Position</literal> . 要避免这种情况, 请确保首先测试事件类型:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _input(event):
    if event is InputEventMouseButton:
        print("mouse button event at ", event.position)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Input(InputEvent @event)
{
    if (@event is InputEventMouseButton mouseEvent)
    {
        GD.Print("mouse button event at ", mouseEvent.Position);
    }
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="inputmap" names="inputmap">
            <title>InputMap</title>
            <paragraph>The <reference internal="True" refuri="../../classes/class_inputmap#class-inputmap"><inline classes="std std-ref">InputMap</inline></reference> is the most flexible way to handle a
                variety of inputs. You use this by creating named input <emphasis>actions</emphasis>, to which
                you can assign any number of input events, such as keypresses or mouse clicks.
                To see them, and to add your own, open Project -&gt; Project Settings and select
                the InputMap tab:</paragraph>
            <image candidates="{'*': 'tutorials/inputs/img/inputs_inputmap.webp'}" uri="tutorials/inputs/img/inputs_inputmap.webp"></image>
            <tip>
                <paragraph>A new Godot project includes a number of default actions already defined.
                    To see them, turn on <literal>Show Built-in Actions</literal> in the InputMap dialog.</paragraph>
            </tip>
            <section ids="capturing-actions" names="capturing\ actions 捕捉动作">
                <title>捕捉动作</title>
                <paragraph>一旦你定义了动作, 可以在脚本中使用 <literal>is_action_pressed()</literal> 和 <literal>is_action_released ()</literal> 处理它们. 通过名称查找响应的动作:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _input(event):
    if event.is_action_pressed("my_action"):
        print("my_action occurred!")</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Input(InputEvent @event)
{
    if (@event.IsActionPressed("my_action"))
    {
        GD.Print("my_action occurred!");
    }
}</literal_block>
                    </div>
                </container>
            </section>
        </section>
        <section ids="keyboard-events" names="keyboard\ events 键盘事件">
            <title>键盘事件</title>
            <paragraph>键盘事件在 <reference internal="True" refuri="../../classes/class_inputeventkey#class-inputeventkey"><inline classes="std std-ref">InputEventKey</inline></reference> 中被捕获. 虽然建议使用输入动作来代替, 但在某些情况下, 你可能会想专门查看按键事件. 对于当前示例, 来检查一下 <literal classes="kbd">T</literal> :</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _input(event):
    if event is InputEventKey and event.pressed:
        if event.keycode == KEY_T:
            print("T was pressed")</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Input(InputEvent @event)
{
    if (@event is InputEventKey keyEvent &amp;&amp; keyEvent.Pressed)
    {
        if (keyEvent.Keycode == Key.T)
        {
            GD.Print("T was pressed");
        }
    }
}</literal_block>
                </div>
            </container>
            <tip>
                <paragraph>See <reference internal="True" refuri="../../classes/class_@globalscope#enum-globalscope-key"><inline classes="std std-ref">@GlobalScope_Key</inline></reference> for a list of keycode
                    constants.</paragraph>
            </tip>
            <warning>
                <paragraph>由于<emphasis>键盘冲突</emphasis>，如果你一次性按下了太多的键，那么在特定时间点，可能是无法将所有按键输入都进行注册的。根据按键在键盘上位置的不同，某些按键产生冲突的可能性会比其他的要高。有些键盘在硬件层面会提供抗冲突功能，不过在低端键盘和笔记本键盘上很少见。</paragraph>
                <paragraph>因此，建议使用能够在不具备抗冲突功能的键盘上也能正常工作的默认键盘布局。详情请参阅<reference name="这个 Gamedev Stack Exchange 问题" refuri="https://gamedev.stackexchange.com/a/109002">这个 Gamedev Stack Exchange 问题</reference>。</paragraph>
            </warning>
            <section ids="keyboard-modifiers" names="keyboard\ modifiers 键盘修饰键">
                <title>键盘修饰键</title>
                <paragraph>修饰键属性继承自 <reference internal="True" refuri="../../classes/class_inputeventwithmodifiers#class-inputeventwithmodifiers"><inline classes="std std-ref">InputEventWithModifiers</inline></reference> ，可使用布尔属性检查修饰键的组合。试想，如果需要在按下 <literal classes="kbd">T</literal> 时发生一件事，而按下 <literal classes="kbd">Shift + T</literal> 时发生不同的事：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _input(event):
    if event is InputEventKey and event.pressed:
        if event.keycode == KEY_T:
            if event.shift_pressed:
                print("Shift+T was pressed")
            else:
                print("T was pressed")</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Input(InputEvent @event)
{
    if (@event is InputEventKey keyEvent &amp;&amp; keyEvent.Pressed)
    {
        switch (keyEvent.Keycode)
        {
            case Key.T:
                GD.Print(keyEvent.ShiftPressed ? "Shift+T was pressed" : "T was pressed");
                break;
        }
    }
}</literal_block>
                    </div>
                </container>
                <tip>
                    <paragraph>See <reference internal="True" refuri="../../classes/class_@globalscope#enum-globalscope-key"><inline classes="std std-ref">@GlobalScope_Key</inline></reference> for a list of keycode
                        constants.</paragraph>
                </tip>
            </section>
        </section>
        <section ids="mouse-events" names="mouse\ events 鼠标事件">
            <title>鼠标事件</title>
            <paragraph>鼠标事件继承自 <reference internal="True" refuri="../../classes/class_inputeventmouse#class-inputeventmouse"><inline classes="std std-ref">InputEventMouse</inline></reference> 并被分成 <reference internal="True" refuri="../../classes/class_inputeventmousebutton#class-inputeventmousebutton"><inline classes="std std-ref">InputEventMouseButton</inline></reference> 和 <reference internal="True" refuri="../../classes/class_inputeventmousemotion#class-inputeventmousemotion"><inline classes="std std-ref">InputEventMouseMotion</inline></reference> 两种类型。注意，这意味着所有鼠标事件都包含 <literal>position</literal> 属性。</paragraph>
            <section ids="mouse-buttons" names="mouse\ buttons 鼠标按钮">
                <title>鼠标按钮</title>
                <paragraph>Capturing mouse buttons is very similar to handling key events. <reference internal="True" refuri="../../classes/class_@globalscope#enum-globalscope-mousebutton"><inline classes="std std-ref">@GlobalScope_MouseButton</inline></reference>
                    contains a list of <literal>MOUSE_BUTTON_*</literal> constants for each possible button, which will
                    be reported in the event's <literal>button_index</literal> property. Note that the scrollwheel
                    also counts as a button - two buttons, to be precise, with both
                    <literal>MOUSE_BUTTON_WHEEL_UP</literal> and <literal>MOUSE_BUTTON_WHEEL_DOWN</literal> being separate events.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _input(event):
    if event is InputEventMouseButton:
        if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
            print("Left button was clicked at ", event.position)
        if event.button_index == MOUSE_BUTTON_WHEEL_UP and event.pressed:
            print("Wheel up")</literal_block>
                    </div>
                    <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Input(InputEvent @event)
{
    if (@event is InputEventMouseButton mouseEvent &amp;&amp; mouseEvent.Pressed)
    {
        switch (mouseEvent.ButtonIndex)
        {
            case MouseButton.Left:
                GD.Print($"Left button was clicked at {mouseEvent.Position}");
                break;
            case MouseButton.WheelUp:
                GD.Print("Wheel up");
                break;
        }
    }
}</literal_block>
                    </div>
                </container>
            </section>
            <section ids="mouse-motion" names="mouse\ motion 鼠标行为">
                <title>鼠标行为</title>
                <paragraph><reference internal="True" refuri="../../classes/class_inputeventmousemotion#class-inputeventmousemotion"><inline classes="std std-ref">InputEventMouseMotion</inline></reference> 只要鼠标移动就会发生事件. 可以通过 <literal>relative</literal> 属性找到移动的距离.</paragraph>
                <paragraph>Here's an example using mouse events to drag-and-drop a <reference internal="True" refuri="../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite2D</inline></reference>
                    node:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node


var dragging = false
var click_radius = 32 # Size of the sprite.


func _input(event):
    if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
        if (event.position - $Sprite2D.position).length() &lt; click_radius:
            # Start dragging if the click is on the sprite.
            if not dragging and event.pressed:
                dragging = true
        # Stop dragging if the button is released.
        if dragging and not event.pressed:
            dragging = false

    if event is InputEventMouseMotion and dragging:
        # While dragging, move the sprite with the mouse.
        $Sprite2D.position = event.position</literal_block>
                    </div>
                    <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode2D : Node2D
{
    private bool _dragging = false;
    private int _clickRadius = 32; // Size of the sprite.

    public override void _Input(InputEvent @event)
    {
        Sprite2D sprite = GetNodeOrNull&lt;Sprite2D&gt;("Sprite2D");
        if (sprite == null)
        {
            return; // No suitable node was found.
        }

        if (@event is InputEventMouseButton mouseEvent &amp;&amp; mouseEvent.ButtonIndex == MouseButton.Left)
        {
            if ((mouseEvent.Position - sprite.Position).Length() &lt; _clickRadius)
            {
                // Start dragging if the click is on the sprite.
                if (!_dragging &amp;&amp; mouseEvent.Pressed)
                {
                    _dragging = true;
                }
            }
            // Stop dragging if the button is released.
            if (_dragging &amp;&amp; !mouseEvent.Pressed)
            {
                _dragging = false;
            }
        }
        else
        {
            if (@event is InputEventMouseMotion motionEvent &amp;&amp; _dragging)
            {
                // While dragging, move the sprite with the mouse.
                sprite.Position = motionEvent.Position;
            }
        }
    }
}</literal_block>
                    </div>
                </container>
            </section>
        </section>
        <section ids="touch-events" names="touch\ events 触摸事件">
            <title>触摸事件</title>
            <paragraph>如果你使用的是触摸屏设备，就可以生成触摸事件。<reference internal="True" refuri="../../classes/class_inputeventscreentouch#class-inputeventscreentouch"><inline classes="std std-ref">InputEventScreenTouch</inline></reference> 相当于鼠标点击事件，而 <reference internal="True" refuri="../../classes/class_inputeventscreendrag#class-inputeventscreendrag"><inline classes="std std-ref">InputEventScreenDrag</inline></reference> 的工作原理与鼠标移动一致。</paragraph>
            <tip>
                <paragraph>要在非触摸屏设备上测试触摸事件，请打开“项目设置”，进入“Input Devices/Pointing”（输入设备/触点）部分。启用“Emulate Touch From Mouse”（根据鼠标模拟触摸），你的项目将把鼠标单击和移动解释为触摸事件。</paragraph>
            </tip>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
