<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/inputs/input_examples.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-input-examples"></target>
    <section ids="input-examples doc-input-examples" names="input\ examples doc_input_examples">
        <title>Input examples</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>In this tutorial, you'll learn how to use Godot's <reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference>
                system to capture player input. There are many different types of input your
                game may use - keyboard, gamepad, mouse, etc. - and many different ways to
                turn those inputs into actions in your game. This document will show you some
                of the most common scenarios, which you can use as starting points for your
                own projects.</paragraph>
            <note>
                <paragraph>For a detailed overview of how Godot's input event system works,
                    see <reference internal="True" refuri="inputevent#doc-inputevent"><inline classes="std std-ref">Using InputEvent</inline></reference>.</paragraph>
            </note>
        </section>
        <section ids="events-versus-polling" names="events\ versus\ polling">
            <title>Events versus polling</title>
            <paragraph>Sometimes you want your game to respond to a certain input event - pressing
                the "jump" button, for example. For other situations, you might want something
                to happen as long as a key is pressed, such as movement. In the first case,
                you can use the <literal>_input()</literal> function, which will be called whenever an input
                event occurs. In the second case, Godot provides the <reference internal="True" refuri="../../classes/class_input#class-input"><inline classes="std std-ref">Input</inline></reference>
                singleton, which you can use to query the state of an input.</paragraph>
            <paragraph>Examples:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _input(event):
    if event.is_action_pressed("jump"):
        jump()


func _physics_process(delta):
    if Input.is_action_pressed("move_right"):
        # Move as long as the key/button is pressed.
        position.x += speed * delta</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Input(InputEvent @event)
{
    if (@event.IsActionPressed("jump"))
    {
        Jump();
    }
}

public override void _PhysicsProcess(double delta)
{
    if (Input.IsActionPressed("move_right"))
    {
        // Move as long as the key/button is pressed.
        position.X += speed * (float)delta;
    }
}</literal_block>
                </div>
            </container>
            <paragraph>This gives you the flexibility to mix-and-match the type of input processing
                you do.</paragraph>
            <paragraph>For the remainder of this tutorial, we'll focus on capturing individual
                events in <literal>_input()</literal>.</paragraph>
        </section>
        <section ids="input-events" names="input\ events">
            <title>Input events</title>
            <paragraph>Input events are objects that inherit from <reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference>.
                Depending on the event type, the object will contain specific properties
                related to that event. To see what events actually look like, add a Node and
                attach the following script:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node


func _input(event):
    print(event.as_text())</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Node : Godot.Node
{
    public override void _Input(InputEvent @event)
    {
        GD.Print(@event.AsText());
    }
}</literal_block>
                </div>
            </container>
            <paragraph>As you press keys, move the mouse, and perform other inputs, you'll see each
                event scroll by in the output window. Here's an example of the output:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">A
Mouse motion at position ((971, 5)) with velocity ((0, 0))
Right Mouse Button
Mouse motion at position ((870, 243)) with velocity ((0.454937, -0.454937))
Left Mouse Button
Mouse Wheel Up
A
B
Shift
Alt+Shift
Alt
Shift+T
Mouse motion at position ((868, 242)) with velocity ((-2.134768, 2.134768))</literal_block>
            <paragraph>As you can see, the results are very different for the different types of
                input. Key events are even printed as their key symbols. For example, let's
                consider <reference internal="True" refuri="../../classes/class_inputeventmousebutton#class-inputeventmousebutton"><inline classes="std std-ref">InputEventMouseButton</inline></reference>.
                It inherits from the following classes:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> - the base class for all input events</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_inputeventwithmodifiers#class-inputeventwithmodifiers"><inline classes="std std-ref">InputEventWithModifiers</inline></reference> - adds the ability to check if modifiers are pressed, such as <literal classes="kbd">Shift</literal> or <literal classes="kbd">Alt</literal>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_inputeventmouse#class-inputeventmouse"><inline classes="std std-ref">InputEventMouse</inline></reference> - adds mouse event properties, such as <literal>position</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_inputeventmousebutton#class-inputeventmousebutton"><inline classes="std std-ref">InputEventMouseButton</inline></reference> - contains the index of the button that was pressed, whether it was a double-click, etc.</paragraph>
                </list_item>
            </bullet_list>
            <tip>
                <paragraph>It's a good idea to keep the class reference open while you're working
                    with events so you can check the event type's available properties and
                    methods.</paragraph>
            </tip>
            <paragraph>You can encounter errors if you try to access a property on an input type that
                doesn't contain it - calling <literal>position</literal> on <literal>InputEventKey</literal> for example. To
                avoid this, make sure to test the event type first:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _input(event):
    if event is InputEventMouseButton:
        print("mouse button event at ", event.position)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Input(InputEvent @event)
{
    if (@event is InputEventMouseButton mouseEvent)
    {
        GD.Print("mouse button event at ", mouseEvent.Position);
    }
}</literal_block>
                </div>
            </container>
            <target refid="doc-input-examples-input-map"></target>
        </section>
        <section ids="inputmap doc-input-examples-input-map" names="inputmap doc_input_examples_input_map">
            <title>InputMap</title>
            <paragraph>The <reference internal="True" refuri="../../classes/class_inputmap#class-inputmap"><inline classes="std std-ref">InputMap</inline></reference> is the most flexible way to handle a
                variety of inputs. You use this by creating named input <emphasis>actions</emphasis>, to which
                you can assign any number of input events, such as keypresses or mouse clicks.
                To see them, and to add your own, open Project -&gt; Project Settings and select
                the InputMap tab:</paragraph>
            <image candidates="{'*': 'tutorials/inputs/img/inputs_inputmap.webp'}" original_uri="img/inputs_inputmap.webp" uri="tutorials/inputs/img/inputs_inputmap.webp"></image>
            <tip>
                <paragraph>A new Godot project includes a number of default actions already defined.
                    To see them, turn on <literal>Show Built-in Actions</literal> in the InputMap dialog.</paragraph>
            </tip>
            <section ids="capturing-actions" names="capturing\ actions">
                <title>Capturing actions</title>
                <paragraph>Once you've defined your actions, you can process them in your scripts using
                    <literal>is_action_pressed()</literal> and <literal>is_action_released()</literal> by passing the name of
                    the action you're looking for:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _input(event):
    if event.is_action_pressed("my_action"):
        print("my_action occurred!")</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Input(InputEvent @event)
{
    if (@event.IsActionPressed("my_action"))
    {
        GD.Print("my_action occurred!");
    }
}</literal_block>
                    </div>
                </container>
            </section>
        </section>
        <section ids="keyboard-events" names="keyboard\ events">
            <title>Keyboard events</title>
            <paragraph>Keyboard events are captured in <reference internal="True" refuri="../../classes/class_inputeventkey#class-inputeventkey"><inline classes="std std-ref">InputEventKey</inline></reference>.
                While it's recommended to use input actions instead, there may be cases where
                you want to specifically look at key events. For this example, let's check for
                the <literal classes="kbd">T</literal>:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _input(event):
    if event is InputEventKey and event.pressed:
        if event.keycode == KEY_T:
            print("T was pressed")</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Input(InputEvent @event)
{
    if (@event is InputEventKey keyEvent &amp;&amp; keyEvent.Pressed)
    {
        if (keyEvent.Keycode == Key.T)
        {
            GD.Print("T was pressed");
        }
    }
}</literal_block>
                </div>
            </container>
            <tip>
                <paragraph>See <reference internal="True" refuri="../../classes/class_@globalscope#enum-globalscope-key"><inline classes="std std-ref">@GlobalScope_Key</inline></reference> for a list of keycode
                    constants.</paragraph>
            </tip>
            <warning>
                <paragraph>Due to <emphasis>keyboard ghosting</emphasis>, not all key inputs may be registered at a given time
                    if you press too many keys at once. Due to their location on the keyboard,
                    certain keys are more prone to ghosting than others. Some keyboards feature
                    antighosting at a hardware level, but this feature is generally
                    not present on low-end keyboards and laptop keyboards.</paragraph>
                <paragraph>As a result, it's recommended to use a default keyboard layout that is designed to work well
                    on a keyboard without antighosting. See
                    <reference name="this Gamedev Stack Exchange question" refuri="https://gamedev.stackexchange.com/a/109002">this Gamedev Stack Exchange question</reference>
                    for more information.</paragraph>
            </warning>
            <section ids="keyboard-modifiers" names="keyboard\ modifiers">
                <title>Keyboard modifiers</title>
                <paragraph>Modifier properties are inherited from
                    <reference internal="True" refuri="../../classes/class_inputeventwithmodifiers#class-inputeventwithmodifiers"><inline classes="std std-ref">InputEventWithModifiers</inline></reference>. This allows
                    you to check for modifier combinations using boolean properties. Let's imagine
                    you want one thing to happen when the <literal classes="kbd">T</literal> is pressed, but something
                    different when it's <literal classes="kbd">Shift + T</literal>:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _input(event):
    if event is InputEventKey and event.pressed:
        if event.keycode == KEY_T:
            if event.shift_pressed:
                print("Shift+T was pressed")
            else:
                print("T was pressed")</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Input(InputEvent @event)
{
    if (@event is InputEventKey keyEvent &amp;&amp; keyEvent.Pressed)
    {
        switch (keyEvent.Keycode)
        {
            case Key.T:
                GD.Print(keyEvent.ShiftPressed ? "Shift+T was pressed" : "T was pressed");
                break;
        }
    }
}</literal_block>
                    </div>
                </container>
                <tip>
                    <paragraph>See <reference internal="True" refuri="../../classes/class_@globalscope#enum-globalscope-key"><inline classes="std std-ref">@GlobalScope_Key</inline></reference> for a list of keycode
                        constants.</paragraph>
                </tip>
            </section>
        </section>
        <section ids="mouse-events" names="mouse\ events">
            <title>Mouse events</title>
            <paragraph>Mouse events stem from the <reference internal="True" refuri="../../classes/class_inputeventmouse#class-inputeventmouse"><inline classes="std std-ref">InputEventMouse</inline></reference> class, and
                are separated into two types: <reference internal="True" refuri="../../classes/class_inputeventmousebutton#class-inputeventmousebutton"><inline classes="std std-ref">InputEventMouseButton</inline></reference>
                and <reference internal="True" refuri="../../classes/class_inputeventmousemotion#class-inputeventmousemotion"><inline classes="std std-ref">InputEventMouseMotion</inline></reference>. Note that this
                means that all mouse events will contain a <literal>position</literal> property.</paragraph>
            <section ids="mouse-buttons" names="mouse\ buttons">
                <title>Mouse buttons</title>
                <paragraph>Capturing mouse buttons is very similar to handling key events. <reference internal="True" refuri="../../classes/class_@globalscope#enum-globalscope-mousebutton"><inline classes="std std-ref">@GlobalScope_MouseButton</inline></reference>
                    contains a list of <literal>MOUSE_BUTTON_*</literal> constants for each possible button, which will
                    be reported in the event's <literal>button_index</literal> property. Note that the scrollwheel
                    also counts as a button - two buttons, to be precise, with both
                    <literal>MOUSE_BUTTON_WHEEL_UP</literal> and <literal>MOUSE_BUTTON_WHEEL_DOWN</literal> being separate events.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _input(event):
    if event is InputEventMouseButton:
        if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
            print("Left button was clicked at ", event.position)
        if event.button_index == MOUSE_BUTTON_WHEEL_UP and event.pressed:
            print("Wheel up")</literal_block>
                    </div>
                    <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Input(InputEvent @event)
{
    if (@event is InputEventMouseButton mouseEvent &amp;&amp; mouseEvent.Pressed)
    {
        switch (mouseEvent.ButtonIndex)
        {
            case MouseButton.Left:
                GD.Print($"Left button was clicked at {mouseEvent.Position}");
                break;
            case MouseButton.WheelUp:
                GD.Print("Wheel up");
                break;
        }
    }
}</literal_block>
                    </div>
                </container>
            </section>
            <section ids="mouse-motion" names="mouse\ motion">
                <title>Mouse motion</title>
                <paragraph><reference internal="True" refuri="../../classes/class_inputeventmousemotion#class-inputeventmousemotion"><inline classes="std std-ref">InputEventMouseMotion</inline></reference> events occur whenever
                    the mouse moves. You can find the move's distance with the <literal>relative</literal>
                    property.</paragraph>
                <paragraph>Here's an example using mouse events to drag-and-drop a <reference internal="True" refuri="../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite2D</inline></reference>
                    node:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node


var dragging = false
var click_radius = 32 # Size of the sprite.


func _input(event):
    if event is InputEventMouseButton and event.button_index == MOUSE_BUTTON_LEFT:
        if (event.position - $Sprite2D.position).length() &lt; click_radius:
            # Start dragging if the click is on the sprite.
            if not dragging and event.pressed:
                dragging = true
        # Stop dragging if the button is released.
        if dragging and not event.pressed:
            dragging = false

    if event is InputEventMouseMotion and dragging:
        # While dragging, move the sprite with the mouse.
        $Sprite2D.position = event.position</literal_block>
                    </div>
                    <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode2D : Node2D
{
    private bool _dragging = false;
    private int _clickRadius = 32; // Size of the sprite.

    public override void _Input(InputEvent @event)
    {
        Sprite2D sprite = GetNodeOrNull&lt;Sprite2D&gt;("Sprite2D");
        if (sprite == null)
        {
            return; // No suitable node was found.
        }

        if (@event is InputEventMouseButton mouseEvent &amp;&amp; mouseEvent.ButtonIndex == MouseButton.Left)
        {
            if ((mouseEvent.Position - sprite.Position).Length() &lt; _clickRadius)
            {
                // Start dragging if the click is on the sprite.
                if (!_dragging &amp;&amp; mouseEvent.Pressed)
                {
                    _dragging = true;
                }
            }
            // Stop dragging if the button is released.
            if (_dragging &amp;&amp; !mouseEvent.Pressed)
            {
                _dragging = false;
            }
        }
        else
        {
            if (@event is InputEventMouseMotion motionEvent &amp;&amp; _dragging)
            {
                // While dragging, move the sprite with the mouse.
                sprite.Position = motionEvent.Position;
            }
        }
    }
}</literal_block>
                    </div>
                </container>
            </section>
        </section>
        <section ids="touch-events" names="touch\ events">
            <title>Touch events</title>
            <paragraph>If you are using a touchscreen device, you can generate touch events.
                <reference internal="True" refuri="../../classes/class_inputeventscreentouch#class-inputeventscreentouch"><inline classes="std std-ref">InputEventScreenTouch</inline></reference> is equivalent to
                a mouse click event, and <reference internal="True" refuri="../../classes/class_inputeventscreendrag#class-inputeventscreendrag"><inline classes="std std-ref">InputEventScreenDrag</inline></reference>
                works much the same as mouse motion.</paragraph>
            <tip>
                <paragraph>To test your touch events on a non-touchscreen device, open Project
                    Settings and go to the "Input Devices/Pointing" section. Enable "Emulate
                    Touch From Mouse" and your project will interpret mouse clicks and
                    motion as touch events.</paragraph>
            </tip>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
