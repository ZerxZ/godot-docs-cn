<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/inputs/inputevent.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-inputevent"></target>
    <section ids="using-inputevent doc-inputevent" names="using\ inputevent doc_inputevent">
        <title>Using InputEvent</title>
        <section ids="what-is-it" names="what\ is\ it?">
            <title>What is it?</title>
            <paragraph>Managing input is usually complex, no matter the OS or platform. To ease
                this a little, a special built-in type is provided, <reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference>.
                This datatype can be configured to contain several types of input
                events. Input events travel through the engine and can be received in
                multiple locations, depending on the purpose.</paragraph>
            <paragraph>Here is a quick example, closing your game if the escape key is hit:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _unhandled_input(event):
    if event is InputEventKey:
        if event.pressed and event.keycode == KEY_ESCAPE:
            get_tree().quit()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _UnhandledInput(InputEvent @event)
{
    if (@event is InputEventKey eventKey)
    {
        if (eventKey.Pressed &amp;&amp; eventKey.Keycode == Key.Escape)
        {
            GetTree().Quit();
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>However, it is cleaner and more flexible to use the provided <reference internal="True" refuri="../../classes/class_inputmap#class-inputmap"><inline classes="std std-ref">InputMap</inline></reference> feature,
                which allows you to define input actions and assign them different keys. This way,
                you can define multiple keys for the same action (e.g. the keyboard escape key and the start button on a gamepad).
                You can then more easily change this mapping in the project settings without updating your code,
                and even build a key mapping feature on top of it to allow your game to change the key mapping at runtime!</paragraph>
            <paragraph>You can set up your InputMap under <strong>Project &gt; Project Settings &gt; Input Map</strong> and then use those actions like this:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _process(delta):
    if Input.is_action_pressed("ui_right"):
        # Move right.</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Process(double delta)
{
    if (Input.IsActionPressed("ui_right"))
    {
        // Move right.
    }
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="how-does-it-work" names="how\ does\ it\ work?">
            <title>How does it work?</title>
            <paragraph>Every input event is originated from the user/player (though it's
                possible to generate an InputEvent and feed them back to the engine,
                which is useful for gestures). The DisplayServer for each platform will read
                events from the operating system, then feed them to the root <reference internal="True" refuri="../../classes/class_window#class-window"><inline classes="std std-ref">Window</inline></reference>.</paragraph>
            <paragraph>The window's <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> does quite a lot of stuff with the
                received input, in order:</paragraph>
            <image candidates="{'*': 'tutorials/inputs/img/input_event_flow.webp'}" original_uri="img/input_event_flow.webp" uri="tutorials/inputs/img/input_event_flow.webp"></image>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>If the Viewport is embedding Windows, the Viewport tries to interpret the event in its
                        capability as a Window-Manager (e.g. for resizing or moving Windows).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Next if an embedded Window is focused, the event is sent to that Window and processed in
                        the Window's Viewport and afterwards treated as handled. If no embedded Window is focused,
                        the event is sent to the nodes of the current viewport in the following order.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>First of all, the standard <reference internal="True" refuri="../../classes/class_node#class-node-private-method-input"><inline classes="std std-ref">Node._input()</inline></reference> function
                        will be called in any node that overrides it (and hasn't disabled input processing with <reference internal="True" refuri="../../classes/class_node#class-node-method-set-process-input"><inline classes="std std-ref">Node.set_process_input()</inline></reference>).
                        If any function consumes the event, it can call <reference internal="True" refuri="../../classes/class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled()</inline></reference>, and the event will
                        not spread any more. This ensures that you can filter all events of interest, even before the GUI.
                        For gameplay input, <reference internal="True" refuri="../../classes/class_node#class-node-private-method-unhandled-input"><inline classes="std std-ref">Node._unhandled_input()</inline></reference> is generally a better fit, because it allows the GUI to intercept the events.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Second, it will try to feed the input to the GUI, and see if any
                        control can receive it. If so, the <reference internal="True" refuri="../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference> will be called via the
                        virtual function <reference internal="True" refuri="../../classes/class_control#class-control-private-method-gui-input"><inline classes="std std-ref">Control._gui_input()</inline></reference> and the signal
                        "gui_input" will be emitted (this function is re-implementable by
                        script by inheriting from it). If the control wants to "consume" the
                        event, it will call <reference internal="True" refuri="../../classes/class_control#class-control-method-accept-event"><inline classes="std std-ref">Control.accept_event()</inline></reference> and the event will
                        not spread any more. Use the <reference internal="True" refuri="../../classes/class_control#class-control-property-mouse-filter"><inline classes="std std-ref">Control.mouse_filter</inline></reference>
                        property to control whether a <reference internal="True" refuri="../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference> is notified
                        of mouse events via <reference internal="True" refuri="../../classes/class_control#class-control-private-method-gui-input"><inline classes="std std-ref">Control._gui_input()</inline></reference>
                        callback, and whether these events are propagated further.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If so far no one consumed the event, the <reference internal="True" refuri="../../classes/class_node#class-node-private-method-shortcut-input"><inline classes="std std-ref">Node._shortcut_input()</inline></reference> callback
                        will be called if overridden (and not disabled with
                        <reference internal="True" refuri="../../classes/class_node#class-node-method-set-process-shortcut-input"><inline classes="std std-ref">Node.set_process_shortcut_input()</inline></reference>).
                        This happens only for <reference internal="True" refuri="../../classes/class_inputeventkey#class-inputeventkey"><inline classes="std std-ref">InputEventKey</inline></reference>,
                        <reference internal="True" refuri="../../classes/class_inputeventshortcut#class-inputeventshortcut"><inline classes="std std-ref">InputEventShortcut</inline></reference> and <reference internal="True" refuri="../../classes/class_inputeventjoypadbutton#class-inputeventjoypadbutton"><inline classes="std std-ref">InputEventJoypadButton</inline></reference>.
                        If any function consumes the event, it can call <reference internal="True" refuri="../../classes/class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled()</inline></reference>, and the
                        event will not spread any more. The shortcut input callback is ideal for treating events that are intended as shortcuts.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If so far no one consumed the event, the <reference internal="True" refuri="../../classes/class_node#class-node-private-method-unhandled-key-input"><inline classes="std std-ref">Node._unhandled_key_input()</inline></reference> callback
                        will be called if overridden (and not disabled with
                        <reference internal="True" refuri="../../classes/class_node#class-node-method-set-process-unhandled-key-input"><inline classes="std std-ref">Node.set_process_unhandled_key_input()</inline></reference>).
                        This happens only if the event is an <reference internal="True" refuri="../../classes/class_inputeventkey#class-inputeventkey"><inline classes="std std-ref">InputEventKey</inline></reference>.
                        If any function consumes the event, it can call <reference internal="True" refuri="../../classes/class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled()</inline></reference>, and the
                        event will not spread any more. The unhandled key input callback is ideal for key events.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If so far no one consumed the event, the <reference internal="True" refuri="../../classes/class_node#class-node-private-method-unhandled-input"><inline classes="std std-ref">Node._unhandled_input()</inline></reference> callback
                        will be called if overridden (and not disabled with
                        <reference internal="True" refuri="../../classes/class_node#class-node-method-set-process-unhandled-input"><inline classes="std std-ref">Node.set_process_unhandled_input()</inline></reference>).
                        If any function consumes the event, it can call <reference internal="True" refuri="../../classes/class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled()</inline></reference>, and the
                        event will not spread any more. The unhandled input callback is ideal for full-screen gameplay events, so they are not received when a GUI is active.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If no one wanted the event so far, and <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-physics-object-picking"><inline classes="std std-ref">Object Picking</inline></reference>
                        is turned on, the event is used for object picking. For the root viewport, this can also be
                        enabled in <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-common-enable-object-picking"><inline classes="std std-ref">Project Settings</inline></reference>.
                        In the case of a 3D scene if a <reference internal="True" refuri="../../classes/class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference> is assigned to the Viewport, a ray
                        to the physics world (in the ray direction from the click) will be cast. If this ray hits an object,
                        it will call the <reference internal="True" refuri="../../classes/class_collisionobject3d#class-collisionobject3d-private-method-input-event"><inline classes="std std-ref">CollisionObject3D._input_event()</inline></reference>
                        function in the relevant physics object.
                        In the case of a 2D scene, conceptually the same happens with <reference internal="True" refuri="../../classes/class_collisionobject2d#class-collisionobject2d-private-method-input-event"><inline classes="std std-ref">CollisionObject2D._input_event()</inline></reference>.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>When sending events to its child and descendant nodes, the viewport will do so, as depicted in
                the following graphic, in a reverse depth-first order, starting with the node at the bottom of
                the scene tree, and ending at the root node. Excluded from this process are Windows
                and SubViewports.</paragraph>
            <image candidates="{'*': 'tutorials/inputs/img/input_event_scene_flow.webp'}" original_uri="img/input_event_scene_flow.webp" uri="tutorials/inputs/img/input_event_scene_flow.webp"></image>
            <note>
                <paragraph>This order doesn't apply to <reference internal="True" refuri="../../classes/class_control#class-control-private-method-gui-input"><inline classes="std std-ref">Control._gui_input()</inline></reference>, which uses
                    a different method based on event location or focused Control. GUI <strong>mouse</strong> events also travel
                    up the scene tree, subject to the <reference internal="True" refuri="../../classes/class_control#class-control-property-mouse-filter"><inline classes="std std-ref">Control.mouse_filter</inline></reference>
                    restrictions described above. However, since these events target specific Controls, only direct ancestors of
                    the targeted Control node receive the event. GUI <strong>keyboard and joypad</strong> events <emphasis>do not</emphasis> travel
                    up the scene tree, and can only be handled by the Control that received them. Otherwise, they will be
                    propagated as non-GUI events through <reference internal="True" refuri="../../classes/class_node#class-node-private-method-unhandled-input"><inline classes="std std-ref">Node._unhandled_input()</inline></reference>.</paragraph>
            </note>
            <paragraph>Since Viewports don't send events to other <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewports</inline></reference>, one of the following
                methods has to be used:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Use a <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainer</inline></reference>, which automatically
                        sends events to its child <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewports</inline></reference> after
                        <reference internal="True" refuri="../../classes/class_node#class-node-private-method-input"><inline classes="std std-ref">Node._input()</inline></reference> or <reference internal="True" refuri="../../classes/class_control#class-control-private-method-gui-input"><inline classes="std std-ref">Control._gui_input()</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Implement event propagation based on the individual requirements.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>In accordance with Godot's node-based design, this enables
                specialized child nodes to handle and consume particular events, while
                their ancestors, and ultimately the scene root, can provide more
                generalized behavior if needed.</paragraph>
        </section>
        <section ids="anatomy-of-an-inputevent" names="anatomy\ of\ an\ inputevent">
            <title>Anatomy of an InputEvent</title>
            <paragraph><reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> is just a base built-in type, it does not represent
                anything and only contains some basic information, such as event ID
                (which is increased for each event), device index, etc.</paragraph>
            <paragraph>There are several specialized types of InputEvent, described in the table below:</paragraph>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="67"></colspec>
                    <colspec colwidth="41"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>Event</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Description</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Empty Input Event.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventkey#class-inputeventkey"><inline classes="std std-ref">InputEventKey</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains a keycode and Unicode value,
                                    as well as modifiers.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventmousebutton#class-inputeventmousebutton"><inline classes="std std-ref">InputEventMouseButton</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains click information, such as
                                    button, modifiers, etc.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventmousemotion#class-inputeventmousemotion"><inline classes="std std-ref">InputEventMouseMotion</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains motion information, such as
                                    relative and absolute positions and
                                    speed.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventjoypadmotion#class-inputeventjoypadmotion"><inline classes="std std-ref">InputEventJoypadMotion</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains Joystick/Joypad analog axis
                                    information.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventjoypadbutton#class-inputeventjoypadbutton"><inline classes="std std-ref">InputEventJoypadButton</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains Joystick/Joypad button
                                    information.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventscreentouch#class-inputeventscreentouch"><inline classes="std std-ref">InputEventScreenTouch</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains multi-touch press/release
                                    information. (only available on mobile
                                    devices)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventscreendrag#class-inputeventscreendrag"><inline classes="std std-ref">InputEventScreenDrag</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains multi-touch drag information.
                                    (only available on mobile devices)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventmagnifygesture#class-inputeventmagnifygesture"><inline classes="std std-ref">InputEventMagnifyGesture</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains a position, a factor as well
                                    as modifiers.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventpangesture#class-inputeventpangesture"><inline classes="std std-ref">InputEventPanGesture</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains a position, a delta as well as
                                    modifiers.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventmidi#class-inputeventmidi"><inline classes="std std-ref">InputEventMIDI</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains MIDI-related information.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventshortcut#class-inputeventshortcut"><inline classes="std std-ref">InputEventShortcut</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains a shortcut.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventaction#class-inputeventaction"><inline classes="std std-ref">InputEventAction</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains a generic action. These events
                                    are often generated by the programmer
                                    as feedback. (more on this below)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section ids="input-actions" names="input\ actions">
            <title>Input actions</title>
            <paragraph>Input actions are a grouping of zero or more InputEvents into a commonly
                understood title (for example, the default "ui_left" action grouping both joypad-left input and a keyboard's left arrow key). They are not required to represent an
                InputEvent but are useful because they abstract various inputs when
                programming the game logic.</paragraph>
            <paragraph>This allows for:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The same code to work on different devices with different inputs (e.g.,
                        keyboard on PC, Joypad on console).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Input to be reconfigured at runtime.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Actions to be triggered programmatically at runtime.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Actions can be created from the Project Settings menu in the <strong>Input Map</strong>
                tab and assigned input events.</paragraph>
            <paragraph>Any event has the methods <reference internal="True" refuri="../../classes/class_inputevent#class-inputevent-method-is-action"><inline classes="std std-ref">InputEvent.is_action()</inline></reference>,
                <reference internal="True" refuri="../../classes/class_inputevent#class-inputevent-method-is-pressed"><inline classes="std std-ref">InputEvent.is_pressed()</inline></reference> and <reference internal="True" refuri="../../classes/class_inputevent#class-inputevent-method-is-echo"><inline classes="std std-ref">InputEvent.is_echo()</inline></reference>.</paragraph>
            <paragraph>Alternatively, it may be desired to supply the game back with an action
                from the game code (a good example of this is detecting gestures).
                The Input singleton has a method for this:
                <reference internal="True" refuri="../../classes/class_input#class-input-method-parse-input-event"><inline classes="std std-ref">Input.parse_input_event()</inline></reference>. You would normally use it like this:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var ev = InputEventAction.new()
# Set as ui_left, pressed.
ev.action = "ui_left"
ev.pressed = true
# Feedback.
Input.parse_input_event(ev)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var ev = new InputEventAction();
// Set as ui_left, pressed.
ev.Action = "ui_left";
ev.Pressed = true;
// Feedback.
Input.ParseInputEvent(ev);</literal_block>
                </div>
            </container>
            <seealso>
                <paragraph>See <reference internal="True" refuri="../../getting_started/first_3d_game/02.player_input#doc-first-3d-game-input-actions"><inline classes="std std-ref">Creating input actions</inline></reference> for a tutorial on adding input
                    actions in the project settings.</paragraph>
            </seealso>
        </section>
        <section ids="inputmap" names="inputmap">
            <title>InputMap</title>
            <paragraph>Customizing and re-mapping input from code is often desired. If your
                whole workflow depends on actions, the <reference internal="True" refuri="../../classes/class_inputmap#class-inputmap"><inline classes="std std-ref">InputMap</inline></reference> singleton is
                ideal for reassigning or creating different actions at runtime. This
                singleton is not saved (must be modified manually) and its state is run
                from the project settings (project.godot). So any dynamic system of this
                type needs to store settings in the way the programmer best sees fit.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
