<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/inputs/inputevent.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-inputevent"></target>
    <section ids="using-inputevent doc-inputevent" names="using\ inputevent 使用\ inputevent doc_inputevent">
        <title>使用 InputEvent</title>
        <section ids="what-is-it" names="what\ is\ it? 它是什么？">
            <title>它是什么？</title>
            <paragraph>无论是在操作系统或平台上, 管理输入通常很复杂. 为了简化输入管理, 引擎提供了一个特殊的内置类型 <reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference>. 此类型可被设置成包含多种类型的输入事件. 输入事件通过引擎传递, 可在多个位置接收, 具体位置取决于目的.</paragraph>
            <paragraph>这里有一个简单的示例，按下 ESC 键时关闭你的游戏：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _unhandled_input(event):
    if event is InputEventKey:
        if event.pressed and event.keycode == KEY_ESCAPE:
            get_tree().quit()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _UnhandledInput(InputEvent @event)
{
    if (@event is InputEventKey eventKey)
        if (eventKey.Pressed &amp;&amp; eventKey.Keycode == Key.Escape)
            GetTree().Quit();
}</literal_block>
                </div>
            </container>
            <paragraph>但是，使用所提供的 <reference internal="True" refuri="../../classes/class_inputmap#class-inputmap"><inline classes="std std-ref">InputMap</inline></reference> 功能更简洁灵活，它允许你定义输入操作并分配不同的键。这样，你可以定义多个键的相同动作，例如键盘ESC键和游戏手柄上的启动按钮。然后，你可以在不更新代码的情况下轻松更改项目设置中的此映射，甚至在上面构建键映射功能，以便你的游戏在运行时更改键值映射！</paragraph>
            <paragraph>你可以在<strong>项目 &gt; 项目设置 &gt; 按键映射</strong>下设置你的输入映射，这些动作的使用方法如下：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _process(delta):
    if Input.is_action_pressed("ui_right"):
        # Move right.</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Process(double delta)
{
    if (Input.IsActionPressed("ui_right"))
    {
        // Move right.
    }
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="how-does-it-work" names="how\ does\ it\ work? 工作原理是怎样的？">
            <title>工作原理是怎样的？</title>
            <paragraph>每个输入事件都来源于用户/玩家（虽然也可以自己生成 InputEvent 并提供给引擎，多用于手势）。各个平台的 DisplayServer 都会从操作系统读取事件，然后提供给根 <reference internal="True" refuri="../../classes/class_window#class-window"><inline classes="std std-ref">Window</inline></reference>。</paragraph>
            <paragraph>窗口的 <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> 会对收到的输入进行很多处理，依次为：</paragraph>
            <image candidates="{'*': 'tutorials/inputs/img/input_event_flow.webp'}" uri="tutorials/inputs/img/input_event_flow.webp"></image>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>如果该 Viewport 内嵌了 Window，则该 Viewport 会尝试以窗口管理器的身份解释事件（例如对 Window 进行大小调整和移动）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>接下来，如果存在聚焦的内嵌 Window，则会将事件发送给该 Window，在该窗口的 Viewport 中进行处理，然后将事件标记为已处理。如果不存在聚焦的内嵌 Window，则会将事件发送给当前视口中的节点，顺序如下。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>首先会调用标准的 <reference internal="True" refuri="../../classes/class_node#class-node-private-method-input"><inline classes="std std-ref">Node._input()</inline></reference> 函数，调用只会发生在覆盖了这个函数（并且没有通过 <reference internal="True" refuri="../../classes/class_node#class-node-method-set-process-input"><inline classes="std std-ref">Node.set_process_input()</inline></reference> 禁用）的节点上。如果某个函数消耗了该事件，就可以调用 <reference internal="True" refuri="../../classes/class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled()</inline></reference>，事件就不会再继续传播。这样就保证了你可以在 GUI 之前过滤自己感兴趣的事件。对于游戏输入，<reference internal="True" refuri="../../classes/class_node#class-node-private-method-unhandled-input"><inline classes="std std-ref">Node._unhandled_input()</inline></reference> 通常更合适，因为这个函数能够让 GUI 拦截事件。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>然后，它会尝试将输入提供给 GUI，并查看是否有任何控件可以接收它。如果有，<reference internal="True" refuri="../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 将通过虚函数 <reference internal="True" refuri="../../classes/class_control#class-control-private-method-gui-input"><inline classes="std std-ref">Control._gui_input()</inline></reference> 被调用并发出“gui_input”信号（此函数可通过继承它的脚本重新实现）。如果控件想“消耗”该事件，它将调用 <reference internal="True" refuri="../../classes/class_control#class-control-method-accept-event"><inline classes="std std-ref">Control.accept_event()</inline></reference> 阻止事件的传播。请使用 <reference internal="True" refuri="../../classes/class_control#class-control-property-mouse-filter"><inline classes="std std-ref">Control.mouse_filter</inline></reference> 属性来控制 <reference internal="True" refuri="../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 是否通过 <reference internal="True" refuri="../../classes/class_control#class-control-private-method-gui-input"><inline classes="std std-ref">Control._gui_input()</inline></reference> 回调接收鼠标事件的通知，以及是否进一步传播这些事件。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>如果事件到目前为止还没有被消耗，并且覆盖了 <reference internal="True" refuri="../../classes/class_node#class-node-private-method-shortcut-input"><inline classes="std std-ref">Node._shortcut_input()</inline></reference> 函数（并且没有通过 <reference internal="True" refuri="../../classes/class_node#class-node-method-set-process-shortcut-input"><inline classes="std std-ref">Node.set_process_shortcut_input()</inline></reference> 禁用），那么就会调用这个回调。只有 <reference internal="True" refuri="../../classes/class_inputeventkey#class-inputeventkey"><inline classes="std std-ref">InputEventKey</inline></reference>、<reference internal="True" refuri="../../classes/class_inputeventshortcut#class-inputeventshortcut"><inline classes="std std-ref">InputEventShortcut</inline></reference> 和 <reference internal="True" refuri="../../classes/class_inputeventjoypadbutton#class-inputeventjoypadbutton"><inline classes="std std-ref">InputEventJoypadButton</inline></reference> 才有这一步。如果某个函数消耗了该事件，就可以调用 <reference internal="True" refuri="../../classes/class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled()</inline></reference>，事件就不会再继续传播。快捷键输入回调主要用于处理快捷键相关的事件。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If so far no one consumed the event, the <reference internal="True" refuri="../../classes/class_node#class-node-private-method-unhandled-key-input"><inline classes="std std-ref">Node._unhandled_key_input()</inline></reference> callback
                        will be called if overridden (and not disabled with
                        <reference internal="True" refuri="../../classes/class_node#class-node-method-set-process-unhandled-key-input"><inline classes="std std-ref">Node.set_process_unhandled_key_input()</inline></reference>).
                        This happens only if the event is an <reference internal="True" refuri="../../classes/class_inputeventkey#class-inputeventkey"><inline classes="std std-ref">InputEventKey</inline></reference>.
                        If any function consumes the event, it can call <reference internal="True" refuri="../../classes/class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled()</inline></reference>, and the
                        event will not spread any more. The unhandled key input callback is ideal for key events.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>如果事件到目前为止还没有被消耗，并且覆盖了 <reference internal="True" refuri="../../classes/class_node#class-node-private-method-unhandled-input"><inline classes="std std-ref">Node._unhandled_input()</inline></reference> 函数（并且没有通过 <reference internal="True" refuri="../../classes/class_node#class-node-method-set-process-unhandled-input"><inline classes="std std-ref">Node.set_process_unhandled_input()</inline></reference> 禁用），那么就会调用这个回调。如果某个函数消耗了该事件，就可以调用 <reference internal="True" refuri="../../classes/class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled()</inline></reference>，事件就不会再继续传播。未处理输入回调主要用于处理全屏游戏事件，GUI 处于活动状态时不会收到。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If no one wanted the event so far, and <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-physics-object-picking"><inline classes="std std-ref">Object Picking</inline></reference>
                        is turned on, the event is used for object picking. For the root viewport, this can also be
                        enabled in <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-common-enable-object-picking"><inline classes="std std-ref">Project Settings</inline></reference>.
                        In the case of a 3D scene if a <reference internal="True" refuri="../../classes/class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference> is assigned to the Viewport, a ray
                        to the physics world (in the ray direction from the click) will be cast. If this ray hits an object,
                        it will call the <reference internal="True" refuri="../../classes/class_collisionobject3d#class-collisionobject3d-private-method-input-event"><inline classes="std std-ref">CollisionObject3D._input_event()</inline></reference>
                        function in the relevant physics object.
                        In the case of a 2D scene, conceptually the same happens with <reference internal="True" refuri="../../classes/class_collisionobject2d#class-collisionobject2d-private-method-input-event"><inline classes="std std-ref">CollisionObject2D._input_event()</inline></reference>.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>视口会向子孙节点发送事件，如下图所示，发送时会按照逆深度优先顺序进行，从场景树最底部的节点开始，到根节点结束。这个过程中会跳过 Window 和 SubViewport。</paragraph>
            <image candidates="{'*': 'tutorials/inputs/img/input_event_scene_flow.png'}" uri="tutorials/inputs/img/input_event_scene_flow.png"></image>
            <paragraph>这个顺序并不适用于 <reference internal="True" refuri="../../classes/class_control#class-control-private-method-gui-input"><inline classes="std std-ref">Control._gui_input()</inline></reference>，这个函数的调用顺序与事件的位置和聚焦的 Control 有关，使用的是不同的方法。</paragraph>
            <paragraph>由于 Viewport 不会将事件发送给其他 <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>，所以需要在下列方法中选择一个：</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>使用 <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainer</inline></reference>，这个节点会在 <reference internal="True" refuri="../../classes/class_node#class-node-private-method-input"><inline classes="std std-ref">Node._input()</inline></reference> 或 <reference internal="True" refuri="../../classes/class_control#class-control-private-method-gui-input"><inline classes="std std-ref">Control._gui_input()</inline></reference> 之后，自动将事件发送给子级 <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>根据具体需求实现事件传播逻辑。</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>GUI 事件也会沿着场景树向上传播，但由于这些事件针对的是特定的 Control，所以只有目标 Control 节点的直接父节点才会收到该事件。</paragraph>
            <paragraph>根据Godot基于节点的设计, 这使得专门的子节点能够处理和消费特定的事件, 而它们的父级节点, 以及最终的场景根节点, 可以在需要时提供更通用的行为.</paragraph>
        </section>
        <section ids="anatomy-of-an-inputevent" names="anatomy\ of\ an\ inputevent inputevent\ 剖析">
            <title>InputEvent 剖析</title>
            <paragraph><reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> 只是一个基本的内置类型, 它不代表任何东西, 只包含一些基本信息, 如事件ID(每个事件增加), 设备索引等.</paragraph>
            <paragraph>InputEvent有几种专门的类型, 如下表所述:</paragraph>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="67"></colspec>
                    <colspec colwidth="41"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>事件</paragraph>
                            </entry>
                            <entry>
                                <paragraph>描述</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>空输入事件.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventkey#class-inputeventkey"><inline classes="std std-ref">InputEventKey</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains a keycode and Unicode value,
                                    as well as modifiers.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventmousebutton#class-inputeventmousebutton"><inline classes="std std-ref">InputEventMouseButton</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>包含点击信息, 例如按钮, 修饰键等.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventmousemotion#class-inputeventmousemotion"><inline classes="std std-ref">InputEventMouseMotion</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains motion information, such as
                                    relative and absolute positions and
                                    speed.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventjoypadmotion#class-inputeventjoypadmotion"><inline classes="std std-ref">InputEventJoypadMotion</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>包含操纵杆/ Joypad模拟轴信息.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventjoypadbutton#class-inputeventjoypadbutton"><inline classes="std std-ref">InputEventJoypadButton</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>包含操纵杆/ Joypad按钮信息.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventscreentouch#class-inputeventscreentouch"><inline classes="std std-ref">InputEventScreenTouch</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>包含多点触控按下/释放信息. (仅适用于移动设备)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventscreendrag#class-inputeventscreendrag"><inline classes="std std-ref">InputEventScreenDrag</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>包含多点触控拖动信息. (仅适用于移动设备)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventmagnifygesture#class-inputeventmagnifygesture"><inline classes="std std-ref">InputEventMagnifyGesture</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains a position, a factor as well
                                    as modifiers.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventpangesture#class-inputeventpangesture"><inline classes="std std-ref">InputEventPanGesture</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains a position, a delta as well as
                                    modifiers.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventmidi#class-inputeventmidi"><inline classes="std std-ref">InputEventMIDI</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Contains MIDI-related information.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventshortcut#class-inputeventshortcut"><inline classes="std std-ref">InputEventShortcut</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>容器布局。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../classes/class_inputeventaction#class-inputeventaction"><inline classes="std std-ref">InputEventAction</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph>包含一般动作. 这些事件通常由程序员作为反馈生成. (以下更多内容)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section ids="actions" names="actions 动作">
            <title>动作</title>
            <paragraph>动作是将零个或多个输入事件群组为通常理解的标题（例如，预设的「ui_left」动作将手柄左输入和键盘左箭头键群组）。它们不需要表示输入事件，但很有用，因为它们在编写游戏逻辑时抽象化了各种输入。</paragraph>
            <paragraph>This allows for:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>相同的代码可以在具有不同输入的不同设备上工作(例如,PC上的键盘, 控制台上的Joypad).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>输入要在运行时重新配置.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Actions to be triggered programmatically at run-time.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Actions can be created from the Project Settings menu in the <strong>Input Map</strong>
                tab and assigned input events.</paragraph>
            <paragraph>任何事件都有方法 <reference internal="True" refuri="../../classes/class_inputevent#class-inputevent-method-is-action"><inline classes="std std-ref">InputEvent.is_action()</inline></reference>, <reference internal="True" refuri="../../classes/class_inputevent#class-inputevent-method-is-pressed"><inline classes="std std-ref">InputEvent.is_pressed()</inline></reference> and <reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference>.</paragraph>
            <paragraph>或者, 可能希望从游戏代码中向游戏提供一个动作, 一个很好的例子是检测手势.Input单例有一个方法来实现这个功能 <reference internal="True" refuri="../../classes/class_input#class-input-method-parse-input-event"><inline classes="std std-ref">Input.parse_input_event()</inline></reference> . 通常这样使用它:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var ev = InputEventAction.new()
# Set as ui_left, pressed.
ev.action = "ui_left"
ev.pressed = true
# Feedback.
Input.parse_input_event(ev)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var ev = new InputEventAction();
// Set as ui_left, pressed.
ev.SetAction("ui_left");
ev.SetPressed(true);
// Feedback.
Input.ParseInputEvent(ev);</literal_block>
                </div>
            </container>
        </section>
        <section ids="inputmap" names="inputmap">
            <title>InputMap</title>
            <paragraph>经常需要的从代码中定制和重新映射输入. 如果你的整个运行流程依赖于动作, 那么 <reference internal="True" refuri="../../classes/class_inputmap#class-inputmap"><inline classes="std std-ref">InputMap</inline></reference> 单例是在运行时重新分配或创建不同动作的理想选择. 这个单例不被保存(必须手动修改), 其状态从项目设置进行(project.godot). 所以任何这种类型的动态系统, 都需要以程序员认为最合适的方式来存储设置.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
