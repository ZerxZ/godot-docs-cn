<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/inputs/controllers_gamepads_joysticks.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-controllers-gamepads-joysticks"></target>
    <section ids="controllers-gamepads-and-joysticks doc-controllers-gamepads-joysticks" names="controllers,\ gamepads,\ and\ joysticks doc_controllers_gamepads_joysticks">
        <title>Controllers, gamepads, and joysticks</title>
        <paragraph>Godot supports hundreds of controller models out of the box.
            Controllers are supported on Windows, macOS, Linux, Android, iOS, and Web.</paragraph>
        <note>
            <paragraph>Since Godot 4.5, the engine relies on <reference name="SDL 3" refuri="https://www.libsdl.org/index.php">SDL 3</reference>
                for controller support on Windows, macOS, and Linux. This means the list of
                supported controllers and their behavior should closely match what is available
                in other games and engines using SDL 3. Note that SDL is only used for input,
                not for windowing or sound.</paragraph>
            <paragraph>Prior to Godot 4.5, the engine used its own controller support code.
                This can cause certain controllers to behave incorrectly.
                This custom code is still used to support controllers on Android, iOS,
                and Web, so it may result in issues appearing only on those platforms.</paragraph>
        </note>
        <paragraph>Note that more specialized devices such as steering wheels, rudder pedals and
            <reference name="HOTAS" refuri="https://en.wikipedia.org/wiki/HOTAS">HOTAS</reference> are less tested and may not
            always work as expected. Overriding force feedback for those devices is also not
            implemented yet. If you have access to one of those devices, don't hesitate to
            <reference name="report bugs on GitHub" refuri="https://github.com/godotengine/godot/blob/master/CONTRIBUTING.md#reporting-bugs">report bugs on GitHub</reference>.</paragraph>
        <paragraph>In this guide, you will learn:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><strong>How to write your input logic to support both keyboard and controller inputs.</strong></paragraph>
            </list_item>
            <list_item>
                <paragraph><strong>How controllers can behave differently from keyboard/mouse input.</strong></paragraph>
            </list_item>
            <list_item>
                <paragraph><strong>Troubleshooting issues with controllers in Godot.</strong></paragraph>
            </list_item>
        </bullet_list>
        <section ids="supporting-universal-input" names="supporting\ universal\ input">
            <title>Supporting universal input</title>
            <paragraph>Thanks to Godot's input action system, Godot makes it possible to support both
                keyboard and controller input without having to write separate code paths.
                Instead of hardcoding keys or controller buttons in your scripts, you should
                create <emphasis>input actions</emphasis> in the Project Settings which will then refer to
                specified key and controller inputs.</paragraph>
            <paragraph>Input actions are explained in detail on the <reference internal="True" refuri="inputevent#doc-inputevent"><inline classes="std std-ref">Using InputEvent</inline></reference> page.</paragraph>
            <note>
                <paragraph>Unlike keyboard input, supporting both mouse and controller input for an
                    action (such as looking around in a first-person game) will require
                    different code paths since these have to be handled separately.</paragraph>
            </note>
            <section ids="which-input-singleton-method-should-i-use" names="which\ input\ singleton\ method\ should\ i\ use?">
                <title>Which Input singleton method should I use?</title>
                <paragraph>There are 3 ways to get input in an analog-aware way:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>When you have two axes (such as joystick or WASD movement) and want both
                            axes to behave as a single input, use <literal>Input.get_vector()</literal>:</paragraph>
                    </list_item>
                </bullet_list>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># `velocity` will be a Vector2 between `Vector2(-1.0, -1.0)` and `Vector2(1.0, 1.0)`.
# This handles deadzone in a correct way for most use cases.
# The resulting deadzone will have a circular shape as it generally should.
var velocity = Input.get_vector("move_left", "move_right", "move_forward", "move_back")

# The line below is similar to `get_vector()`, except that it handles
# the deadzone in a less optimal way. The resulting deadzone will have
# a square-ish shape when it should ideally have a circular shape.
var velocity = Vector2(
        Input.get_action_strength("move_right") - Input.get_action_strength("move_left"),
        Input.get_action_strength("move_back") - Input.get_action_strength("move_forward")
).limit_length(1.0)</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// `velocity` will be a Vector2 between `Vector2(-1.0, -1.0)` and `Vector2(1.0, 1.0)`.
// This handles deadzone in a correct way for most use cases.
// The resulting deadzone will have a circular shape as it generally should.
Vector2 velocity = Input.GetVector("move_left", "move_right", "move_forward", "move_back");

// The line below is similar to `get_vector()`, except that it handles
// the deadzone in a less optimal way. The resulting deadzone will have
// a square-ish shape when it should ideally have a circular shape.
Vector2 velocity = new Vector2(
        Input.GetActionStrength("move_right") - Input.GetActionStrength("move_left"),
        Input.GetActionStrength("move_back") - Input.GetActionStrength("move_forward")
).LimitLength(1.0);</literal_block>
                    </div>
                </container>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>When you have one axis that can go both ways (such as a throttle on a
                            flight stick), or when you want to handle separate axes individually,
                            use <literal>Input.get_axis()</literal>:</paragraph>
                    </list_item>
                </bullet_list>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># `walk` will be a floating-point number between `-1.0` and `1.0`.
var walk = Input.get_axis("move_left", "move_right")

# The line above is a shorter form of:
var walk = Input.get_action_strength("move_right") - Input.get_action_strength("move_left")</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// `walk` will be a floating-point number between `-1.0` and `1.0`.
float walk = Input.GetAxis("move_left", "move_right");

// The line above is a shorter form of:
float walk = Input.GetActionStrength("move_right") - Input.GetActionStrength("move_left");</literal_block>
                    </div>
                </container>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>For other types of analog input, such as handling a trigger or handling
                            one direction at a time, use <literal>Input.get_action_strength()</literal>:</paragraph>
                    </list_item>
                </bullet_list>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># `strength` will be a floating-point number between `0.0` and `1.0`.
var strength = Input.get_action_strength("accelerate")</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// `strength` will be a floating-point number between `0.0` and `1.0`.
float strength = Input.GetActionStrength("accelerate");</literal_block>
                    </div>
                </container>
                <paragraph>For non-analog digital/boolean input (only "pressed" or "not pressed" values),
                    such as controller buttons, mouse buttons or keyboard keys,
                    use <literal>Input.is_action_pressed()</literal>:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># `jumping` will be a boolean with a value of `true` or `false`.
var jumping = Input.is_action_pressed("jump")</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// `jumping` will be a boolean with a value of `true` or `false`.
bool jumping = Input.IsActionPressed("jump");</literal_block>
                    </div>
                </container>
                <note>
                    <paragraph>If you need to know whether an input was <emphasis>just</emphasis> pressed in the previous
                        frame, use <literal>Input.is_action_just_pressed()</literal> instead of
                        <literal>Input.is_action_pressed()</literal>. Unlike <literal>Input.is_action_pressed()</literal> which
                        returns <literal>true</literal> as long as the input is
                        held, <literal>Input.is_action_just_pressed()</literal> will only return <literal>true</literal> for one
                        frame after the button has been pressed.</paragraph>
                </note>
            </section>
        </section>
        <section ids="vibration" names="vibration">
            <title>Vibration</title>
            <paragraph>Vibration (also called <emphasis>haptic feedback</emphasis>) can be used to enhance the feel of a
                game. For instance, in a racing game, you can convey the surface the car is
                currently driving on through vibration, or create a sudden vibration on a crash.</paragraph>
            <paragraph>Use the Input singleton's
                <reference internal="True" refuri="../../classes/class_input#class-input-method-start-joy-vibration"><inline classes="std std-ref">start_joy_vibration</inline></reference> method to
                start vibrating a gamepad. Use
                <reference internal="True" refuri="../../classes/class_input#class-input-method-stop-joy-vibration"><inline classes="std std-ref">stop_joy_vibration</inline></reference> to stop
                vibration early (useful if no duration was specified when starting).</paragraph>
            <paragraph>On mobile devices, you can also use
                <reference internal="True" refuri="../../classes/class_input#class-input-method-vibrate-handheld"><inline classes="std std-ref">vibrate_handheld</inline></reference> to vibrate the
                device itself (independently from the gamepad). On Android, this requires the
                <literal>VIBRATE</literal> permission to be enabled in the Android export preset before
                exporting the project.</paragraph>
            <note>
                <paragraph>Vibration can be uncomfortable for certain players. Make sure to provide an
                    in-game slider to disable vibration or reduce its intensity.</paragraph>
            </note>
        </section>
        <section ids="differences-between-keyboard-mouse-and-controller-input" names="differences\ between\ keyboard/mouse\ and\ controller\ input">
            <title>Differences between keyboard/mouse and controller input</title>
            <paragraph>If you're used to handling keyboard and mouse input, you may be surprised by how
                controllers handle specific situations.</paragraph>
            <section ids="dead-zone" names="dead\ zone">
                <title>Dead zone</title>
                <paragraph>Unlike keyboards and mice, controllers offer axes with <emphasis>analog</emphasis> inputs. The
                    upside of analog inputs is that they offer additional flexibility for actions.
                    Unlike digital inputs which can only provide strengths of <literal>0.0</literal> and <literal>1.0</literal>,
                    an analog input can provide <emphasis>any</emphasis> strength between <literal>0.0</literal> and <literal>1.0</literal>. The
                    downside is that without a deadzone system, an analog axis' strength will never
                    be equal to <literal>0.0</literal> due to how the controller is physically built. Instead, it
                    will linger at a low value such as <literal>0.062</literal>. This phenomenon is known as
                    <emphasis>drifting</emphasis> and can be more noticeable on old or faulty controllers.</paragraph>
                <paragraph>Let's take a racing game as a real-world example. Thanks to analog inputs, we
                    can steer the car slowly in one direction or another. However, without a
                    deadzone system, the car would slowly steer by itself even if the player isn't
                    touching the joystick. This is because the directional axis strength won't be
                    equal to <literal>0.0</literal> when we expect it to. Since we don't want our car to steer by
                    itself in this case, we define a "dead zone" value of <literal>0.2</literal> which will ignore
                    all input whose strength is lower than <literal>0.2</literal>. An ideal dead zone value is high
                    enough to ignore the input caused by joystick drifting, but is low enough to not
                    ignore actual input from the player.</paragraph>
                <paragraph>Godot features a built-in deadzone system to tackle this problem. The default
                    value is <literal>0.5</literal>, but you can adjust it on a per-action basis in the Project
                    Settings' Input Map tab. For <literal>Input.get_vector()</literal>, the deadzone can be
                    specified as an optional 5th parameter. If not specified, it will calculate the
                    average deadzone value from all of the actions in the vector.</paragraph>
            </section>
            <section ids="echo-events" names='"echo"\ events'>
                <title>"Echo" events</title>
                <paragraph>Unlike keyboard input, holding down a controller button such as a D-pad
                    direction will <strong>not</strong> generate repeated input events at fixed intervals (also
                    known as "echo" events). This is because the operating system never sends "echo"
                    events for controller input in the first place.</paragraph>
                <paragraph>If you want controller buttons to send echo events, you will have to generate
                    <reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> objects by code and parse them using
                    <reference internal="True" refuri="../../classes/class_input#class-input-method-parse-input-event"><inline classes="std std-ref">Input.parse_input_event()</inline></reference>
                    at regular intervals. This can be accomplished
                    with the help of a <reference internal="True" refuri="../../classes/class_timer#class-timer"><inline classes="std std-ref">Timer</inline></reference> node.</paragraph>
            </section>
            <section ids="window-focus" names="window\ focus">
                <title>Window focus</title>
                <paragraph>Unlike keyboard input, controller inputs can be seen by <strong>all</strong> windows on the
                    operating system, including unfocused windows.</paragraph>
                <paragraph>While this is useful for
                    <reference name="third-party split screen functionality" refuri="https://nucleus-coop.github.io/">third-party split screen functionality</reference>,
                    it can also have adverse effects. Players may accidentally send controller inputs
                    to the running project while interacting with another window.</paragraph>
                <paragraph>If you wish to ignore events when the project window isn't focused, you will
                    need to create an <reference internal="True" refuri="../scripting/singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">autoload</inline></reference> called <literal>Focus</literal>
                    with the following script and use it to check all your inputs:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Focus.gd
extends Node

var focused := true

func _notification(what: int) -&gt; void:
    match what:
        NOTIFICATION_APPLICATION_FOCUS_OUT:
            focused = false
        NOTIFICATION_APPLICATION_FOCUS_IN:
            focused = true


func input_is_action_pressed(action: StringName) -&gt; bool:
    if focused:
        return Input.is_action_pressed(action)

    return false


func event_is_action_pressed(event: InputEvent, action: StringName) -&gt; bool:
    if focused:
        return event.is_action_pressed(action)

    return false</literal_block>
                <paragraph>Then, instead of using <literal>Input.is_action_pressed(action)</literal>, use
                    <literal>Focus.input_is_action_pressed(action)</literal> where <literal>action</literal> is the name of
                    the input action. Also, instead of using <literal>event.is_action_pressed(action)</literal>,
                    use <literal>Focus.event_is_action_pressed(event, action)</literal> where <literal>event</literal> is an
                    InputEvent reference and <literal>action</literal> is the name of the input action.</paragraph>
            </section>
            <section ids="power-saving-prevention" names="power\ saving\ prevention">
                <title>Power saving prevention</title>
                <paragraph>Unlike keyboard and mouse input, controller inputs do <strong>not</strong> inhibit sleep and
                    power saving measures (such as turning off the screen after a certain amount of
                    time has passed).</paragraph>
                <paragraph>To combat this, Godot enables power saving prevention by default when a project
                    is running. If you notice the system is turning off its display when playing
                    with a gamepad, check the value of <strong>Display &gt; Window &gt; Energy Saving &gt; Keep Screen On</strong>
                    in the Project Settings.</paragraph>
            </section>
        </section>
        <section ids="troubleshooting" names="troubleshooting">
            <title>Troubleshooting</title>
            <seealso>
                <paragraph>You can view a list of
                    <reference name="known issues with controller support" refuri="https://github.com/godotengine/godot/issues?q=is%3Aopen+is%3Aissue+label%3Atopic%3Ainput+gamepad">known issues with controller support</reference>
                    on GitHub.</paragraph>
            </seealso>
            <section ids="my-controller-isn-t-recognized-by-godot" names="my\ controller\ isn't\ recognized\ by\ godot.">
                <title>My controller isn't recognized by Godot.</title>
                <paragraph>First, check that your controller is recognized by other applications. You can
                    use the <reference name="Gamepad Tester" refuri="https://hardwaretester.com/gamepad">Gamepad Tester</reference> website to confirm
                    that your controller is recognized.</paragraph>
                <paragraph>On Windows Godot only supports up to 4 controllers at a time. This is
                    because Godot uses the XInput API, which is limited to supporting 4 controllers
                    at once. Additional controllers above this limit are ignored by Godot.</paragraph>
            </section>
            <section ids="my-controller-has-incorrectly-mapped-buttons-or-axes" names="my\ controller\ has\ incorrectly\ mapped\ buttons\ or\ axes.">
                <title>My controller has incorrectly mapped buttons or axes.</title>
                <paragraph>First, if your controller provides some kind of firmware update utility,
                    make sure to run it to get the latest fixes from the manufacturer. For instance,
                    Xbox One and Xbox Series controllers can have their firmware updated using the
                    <reference name="Xbox Accessories app" refuri="https://www.microsoft.com/en-us/p/xbox-accessories/9nblggh30xj3">Xbox Accessories app</reference>.
                    (This application only runs on Windows, so you have to use a Windows machine
                    or a Windows virtual machine with USB support to update the controller's firmware.)
                    After updating the controller's firmware, unpair the controller and pair it again
                    with your PC if you are using the controller in wireless mode.</paragraph>
                <paragraph>If buttons are incorrectly mapped, this may be due to an erroneous mapping from
                    the SDL game controller database used by Godot or the
                    <reference name="Godot game controller database" refuri="https://github.com/godotengine/godot/blob/master/core/input/godotcontrollerdb.txt">Godot game controller database</reference>.
                    In this case, you will need to create a custom mapping for your controller.</paragraph>
                <paragraph>There are many ways to create mappings. One option is to use the mapping wizard
                    in the <reference name="official Joypads demo" refuri="https://godotengine.org/asset-library/asset/2785">official Joypads demo</reference>.
                    Once you have a working mapping for your controller, you can test it by defining
                    the <literal>SDL_GAMECONTROLLERCONFIG</literal> environment variable before running Godot:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-TGludXgvbWFjT1M=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-TGludXgvbWFjT1M=" name="TGludXgvbWFjT1M=" role="tab" tabindex="0">Linux/macOS</button>
                        <button aria-controls="panel-4-V2luZG93cyAoY21kKQ==" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-V2luZG93cyAoY21kKQ==" name="V2luZG93cyAoY21kKQ==" role="tab" tabindex="-1">Windows (cmd)</button>
                        <button aria-controls="panel-4-V2luZG93cyAoUG93ZXJTaGVsbCk=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-V2luZG93cyAoUG93ZXJTaGVsbCk=" name="V2luZG93cyAoUG93ZXJTaGVsbCk=" role="tab" tabindex="-1">Windows (PowerShell)</button>
                    </div>
                    <div aria-labelledby="tab-4-TGludXgvbWFjT1M=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-TGludXgvbWFjT1M=" name="TGludXgvbWFjT1M=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="bash" linenos="False" xml:space="preserve">export SDL_GAMECONTROLLERCONFIG="your:mapping:here"
./path/to/godot.x86_64</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-V2luZG93cyAoY21kKQ==" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-V2luZG93cyAoY21kKQ==" name="V2luZG93cyAoY21kKQ==" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="bat" linenos="False" xml:space="preserve">set SDL_GAMECONTROLLERCONFIG=your:mapping:here
path\to\godot.exe</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-V2luZG93cyAoUG93ZXJTaGVsbCk=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-V2luZG93cyAoUG93ZXJTaGVsbCk=" name="V2luZG93cyAoUG93ZXJTaGVsbCk=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="powershell" linenos="False" xml:space="preserve">$env:SDL_GAMECONTROLLERCONFIG="your:mapping:here"
path\to\godot.exe</literal_block>
                    </div>
                </container>
                <paragraph>To test mappings on non-desktop platforms or to distribute your project with
                    additional controller mappings, you can add them by calling
                    <reference internal="True" refuri="../../classes/class_input#class-input-method-add-joy-mapping"><inline classes="std std-ref">Input.add_joy_mapping()</inline></reference>
                    as early as possible in a script's <literal>_ready()</literal> function.</paragraph>
                <paragraph>Once you are satisfied with the custom mapping, you can contribute it for
                    the next Godot version by opening a pull request on the
                    <reference name="Godot game controller database" refuri="https://github.com/godotengine/godot/blob/master/core/input/godotcontrollerdb.txt">Godot game controller database</reference>.</paragraph>
            </section>
            <section ids="my-controller-works-on-a-given-platform-but-not-on-another-platform" names="my\ controller\ works\ on\ a\ given\ platform,\ but\ not\ on\ another\ platform.">
                <title>My controller works on a given platform, but not on another platform.</title>
                <section ids="linux" names="linux">
                    <title>Linux</title>
                    <paragraph>If you're using a self-compiled engine binary, make sure it was compiled with
                        udev support. This is enabled by default, but it is possible to disable udev
                        support by specifying <literal>udev=no</literal> on the SCons command line. If you're using an
                        engine binary supplied by a Linux distribution, double-check whether it was
                        compiled with udev support.</paragraph>
                    <paragraph>Controllers can still work without udev support, but it is less reliable as
                        regular polling must be used to check for controllers being connected or
                        disconnected during gameplay (hotplugging).</paragraph>
                </section>
                <section ids="android-ios" names="android/ios">
                    <title>Android/iOS</title>
                    <paragraph>As described at the top of the page, controller support on mobile platforms relies
                        on a custom implementation instead of using SDL for input. This means controller
                        support may be less reliable than on desktop platforms.</paragraph>
                    <paragraph>Support for SDL-based controller input on mobile platforms is
                        <reference name="planned" refuri="https://github.com/godotengine/godot/pull/109645">planned</reference>
                        in a future release.</paragraph>
                </section>
                <section ids="web" names="web">
                    <title>Web</title>
                    <paragraph>Web controller support is often less reliable compared to "native" platforms.
                        The quality of controller support tends to vary wildly across browsers. As a
                        result, you may have to instruct your players to use a different browser if they
                        can't get their controller to work.</paragraph>
                    <paragraph>Like for mobile platforms, support for SDL-based controller input on the web platform
                        is <reference name="planned" refuri="https://github.com/godotengine/godot/pull/109645">planned</reference> in a future release.</paragraph>
                    <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
                </section>
            </section>
        </section>
    </section>
</document>
