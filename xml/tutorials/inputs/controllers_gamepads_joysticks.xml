<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/inputs/controllers_gamepads_joysticks.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-controllers-gamepads-joysticks"></target>
    <section ids="controllers-gamepads-and-joysticks doc-controllers-gamepads-joysticks" names="controllers,\ gamepads,\ and\ joysticks 控制器、手柄和摇杆 doc_controllers_gamepads_joysticks">
        <title>控制器、手柄和摇杆</title>
        <paragraph>Godot支持数百种控制器模型，这要归功于社区提供的 <reference name="SDL游戏控制器数据库" refuri="https://github.com/gabomdq/SDL_GameControllerDB">SDL游戏控制器数据库</reference> 。</paragraph>
        <paragraph>控制器支持Windows、macOS、Linux、Android、iOS和HTML5。</paragraph>
        <paragraph>请注意，诸如方向盘、方向盘踏板和 <reference name="HOTAS" refuri="https://en.wikipedia.org/wiki/HOTAS">HOTAS</reference> 等更专业的设备测试较少，可能并不总是按照预期工作。目前尚未实现在这些设备上的力反馈覆盖。如果你有机会使用这些设备，请不要犹豫，<reference name="在 GitHub" refuri="https://github.com/godotengine/godot/blob/master/CONTRIBUTING.md#reporting-bugs">在 GitHub</reference> 上报告错误。</paragraph>
        <paragraph>在本指南中，你将学会：</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><strong>如何编写你的输入逻辑，从而支持键盘和控制器输入。</strong></paragraph>
            </list_item>
            <list_item>
                <paragraph><strong>控制器的行为如何与键盘/鼠标输入不同。</strong></paragraph>
            </list_item>
            <list_item>
                <paragraph><strong>解决 Godot 中控制器的问题。</strong></paragraph>
            </list_item>
        </bullet_list>
        <section ids="supporting-universal-input" names="supporting\ universal\ input 支持通用导出">
            <title>支持通用导出</title>
            <paragraph>得益于 Godot 的输入动作系统，Godot 可以同时支持键盘和控制器输入，而不需要编写单独的代码路径。你不应该在脚本中对控制器的按键进行硬编码，应该在项目设置中创建<emphasis>输入动作</emphasis>，这些动作引用按键和控制器输入。</paragraph>
            <paragraph>输入动作在 <reference internal="True" refuri="inputevent#doc-inputevent"><inline classes="std std-ref">使用 InputEvent</inline></reference> 页面上有详细解释。</paragraph>
            <note>
                <paragraph>与键盘输入不同，支持鼠标和控制器输入的动作将需要不同的代码路径，例如在第一人称游戏中四处查看，因为这些必须被分开处理。</paragraph>
            </note>
            <section ids="which-input-singleton-method-should-i-use" names="which\ input\ singleton\ method\ should\ i\ use? 我应该使用哪个输入单例方法？">
                <title>我应该使用哪个输入单例方法？</title>
                <paragraph>有3种方式可以以模拟感知的方式获得输入:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>当你有两个轴，如操纵杆或WASD运动，并希望两个轴都表现为单一输入时，使用 <literal>Input.get_vector()</literal> :</paragraph>
                    </list_item>
                </bullet_list>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># `velocity` will be a Vector2 between `Vector2(-1.0, -1.0)` and `Vector2(1.0, 1.0)`.
# This handles deadzone in a correct way for most use cases.
# The resulting deadzone will have a circular shape as it generally should.
var velocity = Input.get_vector("move_left", "move_right", "move_forward", "move_back")

# The line below is similar to `get_vector()`, except that it handles
# the deadzone in a less optimal way. The resulting deadzone will have
# a square-ish shape when it should ideally have a circular shape.
var velocity = Vector2(
        Input.get_action_strength("move_right") - Input.get_action_strength("move_left"),
        Input.get_action_strength("move_back") - Input.get_action_strength("move_forward")
).limit_length(1.0)</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// `velocity` will be a Vector2 between `Vector2(-1.0, -1.0)` and `Vector2(1.0, 1.0)`.
// This handles deadzone in a correct way for most use cases.
// The resulting deadzone will have a circular shape as it generally should.
Vector2 velocity = Input.GetVector("move_left", "move_right", "move_forward", "move_back");

// The line below is similar to `get_vector()`, except that it handles
// the deadzone in a less optimal way. The resulting deadzone will have
// a square-ish shape when it should ideally have a circular shape.
Vector2 velocity = new Vector2(
        Input.GetActionStrength("move_right") - Input.GetActionStrength("move_left"),
        Input.GetActionStrength("move_back") - Input.GetActionStrength("move_forward")
).LimitLength(1.0);</literal_block>
                    </div>
                </container>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>当你有一个轴可以双向移动时，比如飞行操纵杆上的油门，或者你想单独处理不同的轴时，使用 <literal>Input.get_axis()</literal> :</paragraph>
                    </list_item>
                </bullet_list>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># `walk` will be a floating-point number between `-1.0` and `1.0`.
var walk = Input.get_axis("move_left", "move_right")

# The line above is a shorter form of:
var walk = Input.get_action_strength("move_right") - Input.get_action_strength("move_left")</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// `walk` will be a floating-point number between `-1.0` and `1.0`.
float walk = Input.GetAxis("move_left", "move_right");

// The line above is a shorter form of:
float walk = Input.GetActionStrength("move_right") - Input.GetActionStrength("move_left");</literal_block>
                    </div>
                </container>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>对于其他类型的模拟输入，例如处理一个触发器或一次处理一个方向，使用 <literal>Input.get_action_strength()</literal> :</paragraph>
                    </list_item>
                </bullet_list>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># `strength` will be a floating-point number between `0.0` and `1.0`.
var strength = Input.get_action_strength("accelerate")</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// `strength` will be a floating-point number between `0.0` and `1.0`.
float strength = Input.GetActionStrength("accelerate");</literal_block>
                    </div>
                </container>
                <paragraph>对于非模拟数字/布尔输入（只有 "按下 " 或 "未按下 " 的值），如控制器按钮、鼠标按钮或键盘按键，使用 <literal>Input.is_action_pressed()</literal> :</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># `jumping` will be a boolean with a value of `true` or `false`.
var jumping = Input.is_action_pressed("jump")</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// `jumping` will be a boolean with a value of `true` or `false`.
bool jumping = Input.IsActionPressed("jump");</literal_block>
                    </div>
                </container>
                <note>
                    <paragraph>如果你想要知道上一帧是否<emphasis>刚刚</emphasis>按下了某个输入，请使用 <literal>Input.is_action_just_pressed()</literal>，不要使用 <literal>Input.is_action_pressed()</literal>。<literal>Input.is_action_pressed()</literal> 是只要输入处于按下的状态就会返回 <literal>true</literal>，而 <literal>Input.is_action_just_pressed()</literal> 只会在按下按钮后的一帧内返回 <literal>true</literal>。</paragraph>
                </note>
                <paragraph>在3.4之前的Godot版本，如3.3， <literal>Input.get_vector()</literal> 和 <literal>Input.get_axis()</literal> 不可用。只有 <literal>Input.get_action_strength()</literal> 和 <literal>Input.is_action_pressed()</literal> 在Godot 3.3中可用。</paragraph>
            </section>
        </section>
        <section ids="vibration" names="vibration 振动">
            <title>振动</title>
            <paragraph>振动（也叫<emphasis>触觉反馈</emphasis>）可以用来提升游戏手感。比如在赛车游戏中，可以通过振动来体现车辆当前所处的路面，也可以在撞车时进行突然的振动。</paragraph>
            <paragraph>请使用 Input 单例的 <reference internal="True" refuri="../../classes/class_input#class-input-method-start-joy-vibration"><inline classes="std std-ref">start_joy_vibration</inline></reference> 方法开启游戏手柄的振动。要提前结束振动，请使用 <reference internal="True" refuri="../../classes/class_input#class-input-method-stop-joy-vibration"><inline classes="std std-ref">stop_joy_vibration</inline></reference>（尤其适用于启动时未指定时长的情况）。</paragraph>
            <paragraph>在移动设备上，你还可以使用 <reference internal="True" refuri="../../classes/class_input#class-input-method-vibrate-handheld"><inline classes="std std-ref">vibrate_handheld</inline></reference> 来振动设备本身（与游戏手柄的振动是分开的）。在 Android 上，这个功能需要在导出项目前启用 Android 导出预设的 <literal>VIBRATE</literal> 权限。</paragraph>
            <note>
                <paragraph>振动可能造成某些玩家的不适。请确保在游戏中提供滑块，用来禁用振动或降低振动强度。</paragraph>
            </note>
        </section>
        <section ids="differences-between-keyboard-mouse-and-controller-input" names="differences\ between\ keyboard/mouse\ and\ controller\ input 键盘/鼠标和控制器输入之间的差异">
            <title>键盘/鼠标和控制器输入之间的差异</title>
            <paragraph>如果你习惯于处理键盘和鼠标输入，可能会对控制器处理特定情况的方式感到惊讶。</paragraph>
            <section ids="dead-zone" names="dead\ zone 死区">
                <title>死区</title>
                <paragraph>与键盘和鼠标不同，控制器提供带有<emphasis>模拟</emphasis>输入的轴。模拟输入的好处是它们为动作提供了额外的灵活性。不像数字输入只能提供 <literal>0.0</literal> 和 <literal>1.0</literal> 的强度，模拟输入可以提供 <literal>0.0</literal> 和 <literal>1.0</literal> 之间的<emphasis>任何</emphasis>强度。缺点是没有死区系统，由于控制器的物理结构，模拟轴的强度永远不会等于 <literal>0.0</literal>。相反，它将徘徊在一个低值，如 <literal>0.062</literal>。这种现象被称为<emphasis>漂移</emphasis>，在旧的或有问题的控制器上会更加明显。</paragraph>
                <paragraph>让我们把赛车游戏作为一个现实世界的例子。由于有了模拟输入，我们可以将汽车慢慢地转向一个或另一个方向。然而，如果没有死区系统，即使玩家不接触操纵杆，汽车也会自己慢慢转向。这是因为方向轴的强度在我们期望的时候不会等于 <literal>0.0</literal>。因为我们不希望我们的车在这种情况下自动转向，我们定义了一个“死区”值 <literal>0.2</literal>，它将忽略所有强度低于 <literal>0.2</literal> 的输入。一个理想的死区值是足够高的，可以忽略操纵杆漂移引起的输入，但又足够低，不会忽略玩家的实际输入。</paragraph>
                <paragraph>Godot 提供了内置的死区系统来解决这个问题。默认值是 <literal>0.5</literal>，但你可以在“项目设置”的“输入映射”选项卡中针对具体的动作进行调整。<literal>Input.get_vector()</literal>可以在第五个参数中指定死区。如果没有指定，则会计算向量中的所有动作死区的平均值。</paragraph>
            </section>
            <section ids="echo-events" names='"echo"\ events “回声”事件'>
                <title>“回声”事件</title>
                <paragraph>与键盘输入不同，按住一个控制器按钮，如十字方向键，<strong>不会</strong>产生固定间隔的重复输入事件（也被称为“回声”事件）。这是因为操作系统首先不会为控制器输入发送“回声”事件。</paragraph>
                <paragraph>如果你想让控制器按钮发送回声事件，你将不得不通过代码生成 <reference internal="True" refuri="../../classes/class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> 对象，并使用 <reference internal="True" refuri="../../classes/class_input#class-input-method-parse-input-event"><inline classes="std std-ref">Input.parse_input_event()</inline></reference> 定期解析它们。这可以在 <reference internal="True" refuri="../../classes/class_timer#class-timer"><inline classes="std std-ref">Timer</inline></reference> 节点的帮助下完成。</paragraph>
            </section>
            <section ids="window-focus" names="window\ focus 窗口焦点">
                <title>窗口焦点</title>
                <paragraph>与键盘输入不同，控制器的输入可以被操作系统中的<strong>所有</strong>窗口看到，包括未持有焦点的窗口。</paragraph>
                <paragraph>While this is useful for
                    <reference name="third-party split screen functionality" refuri="https://nucleus-coop.github.io/">third-party split screen functionality</reference>,
                    it can also have adverse effects. Players may accidentally send controller inputs
                    to the running project while interacting with another window.</paragraph>
                <paragraph>If you wish to ignore events when the project window isn't focused, you will
                    need to create an <reference internal="True" refuri="../scripting/singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">autoload</inline></reference> called <literal>Focus</literal>
                    with the following script and use it to check all your inputs:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Focus.gd
extends Node

var focused := true

func _notification(what: int) -&gt; void:
    match what:
        NOTIFICATION_APPLICATION_FOCUS_OUT:
            focused = false
        NOTIFICATION_APPLICATION_FOCUS_IN:
            focused = true


func input_is_action_pressed(action: StringName) -&gt; bool:
    if focused:
        return Input.is_action_pressed(action)

    return false


func event_is_action_pressed(event: InputEvent, action: StringName) -&gt; bool:
    if focused:
        return event.is_action_pressed(action)

    return false</literal_block>
                <paragraph>Then, instead of using <literal>Input.is_action_pressed(action)</literal>, use
                    <literal>Focus.input_is_action_pressed(action)</literal> where <literal>action</literal> is the name of
                    the input action. Also, instead of using <literal>event.is_action_pressed(action)</literal>,
                    use <literal>Focus.event_is_action_pressed(event, action)</literal> where <literal>event</literal> is an
                    InputEvent reference and <literal>action</literal> is the name of the input action.</paragraph>
            </section>
            <section ids="power-saving-prevention" names="power\ saving\ prevention 防止省电模式">
                <title>防止省电模式</title>
                <paragraph>Unlike keyboard and mouse input, controller inputs do <strong>not</strong> inhibit sleep and
                    power saving measures (such as turning off the screen after a certain amount of
                    time has passed).</paragraph>
                <paragraph>To combat this, Godot enables power saving prevention by default when a project
                    is running. If you notice the system is turning off its display when playing
                    with a gamepad, check the value of <strong>Display &gt; Window &gt; Energy Saving &gt; Keep Screen On</strong>
                    in the Project Settings.</paragraph>
                <paragraph>On Linux, power saving prevention requires the engine to be able to use D-Bus.
                    Check whether D-Bus is installed and reachable if running the project within a
                    Flatpak, as sandboxing restrictions may make this impossible by default.</paragraph>
            </section>
        </section>
        <section ids="troubleshooting" names="troubleshooting 故障排除">
            <title>故障排除</title>
            <seealso>
                <paragraph>你可以在 GitHub 上查看<reference name="控制器支持的已知问题列表" refuri="https://github.com/godotengine/godot/issues?q=is%3Aopen+is%3Aissue+label%3Atopic%3Ainput+gamepad">控制器支持的已知问题列表</reference>。</paragraph>
            </seealso>
            <section ids="my-controller-isn-t-recognized-by-godot" names="my\ controller\ isn't\ recognized\ by\ godot. godot\ 无法识别我的控制器。">
                <title>Godot 无法识别我的控制器。</title>
                <paragraph>首先，检查你的控制器是否被其他应用程序识别。你可以使用 <reference name="Gamepad Tester" refuri="https://gamepad-tester.com/">Gamepad Tester</reference> 网站来确认你的控制器被识别。</paragraph>
                <paragraph>On Windows Godot only supports up to 4 controllers at a time. This is
                    because Godot uses the XInput API, which is limited to supporting 4 controllers
                    at once. Additional controllers above this limit are ignored by Godot.</paragraph>
            </section>
            <section ids="my-controller-has-incorrectly-mapped-buttons-or-axes" names="my\ controller\ has\ incorrectly\ mapped\ buttons\ or\ axes. 我的控制器的按钮或轴映射不正确。">
                <title>我的控制器的按钮或轴映射不正确。</title>
                <paragraph>First, if your controller provides some kind of firmware update utility,
                    make sure to run it to get the latest fixes from the manufacturer. For instance,
                    Xbox One and Xbox Series controllers can have their firmware updated using the
                    <reference name="Xbox Accessories app" refuri="https://www.microsoft.com/en-us/p/xbox-accessories/9nblggh30xj3">Xbox Accessories app</reference>.
                    (This application only runs on Windows, so you have to use a Windows machine
                    or a Windows virtual machine with USB support to update the controller's firmware.)
                    After updating the controller's firmware, unpair the controller and pair it again
                    with your PC if you are using the controller in wireless mode.</paragraph>
                <paragraph>如果按钮存在映射错误，可能是由于来自 <reference name="SDL 游戏控制器数据库" refuri="https://github.com/gabomdq/SDL_GameControllerDB">SDL 游戏控制器数据库</reference>的错误的映射。你可以在链接的仓库中提交拉取请求，为下一个 Godot 版本提供映射更新。</paragraph>
                <paragraph>There are many ways to create mappings. One option is to use the mapping wizard
                    in the <reference name="official Joypads demo" refuri="https://godotengine.org/asset-library/asset/2785">official Joypads demo</reference>.
                    Once you have a working mapping for your controller, you can test it by defining
                    the <literal>SDL_GAMECONTROLLERCONFIG</literal> environment variable before running Godot:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-TGludXgvbWFjT1M=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-TGludXgvbWFjT1M=" name="TGludXgvbWFjT1M=" role="tab" tabindex="0">Linux/macOS</button>
                        <button aria-controls="panel-4-V2luZG93cyAoY21kKQ==" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-V2luZG93cyAoY21kKQ==" name="V2luZG93cyAoY21kKQ==" role="tab" tabindex="-1">Windows (cmd)</button>
                        <button aria-controls="panel-4-V2luZG93cyAoUG93ZXJTaGVsbCk=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-V2luZG93cyAoUG93ZXJTaGVsbCk=" name="V2luZG93cyAoUG93ZXJTaGVsbCk=" role="tab" tabindex="-1">Windows (PowerShell)</button>
                    </div>
                    <div aria-labelledby="tab-4-TGludXgvbWFjT1M=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-TGludXgvbWFjT1M=" name="TGludXgvbWFjT1M=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="bash" linenos="False" xml:space="preserve">export SDL_GAMECONTROLLERCONFIG="your:mapping:here"
./path/to/godot.x86_64</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-V2luZG93cyAoY21kKQ==" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-V2luZG93cyAoY21kKQ==" name="V2luZG93cyAoY21kKQ==" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="bat" linenos="False" xml:space="preserve">set SDL_GAMECONTROLLERCONFIG=your:mapping:here
path\to\godot.exe</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-V2luZG93cyAoUG93ZXJTaGVsbCk=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-V2luZG93cyAoUG93ZXJTaGVsbCk=" name="V2luZG93cyAoUG93ZXJTaGVsbCk=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="powershell" linenos="False" xml:space="preserve">$env:SDL_GAMECONTROLLERCONFIG="your:mapping:here"
path\to\godot.exe</literal_block>
                    </div>
                </container>
                <paragraph>要在非桌面平台上测试映射，或者用额外的控制器映射来分发你的项目，你可以通过调用 <reference internal="True" refuri="../../classes/class_input#class-input-method-add-joy-mapping"><inline classes="std std-ref">Input.add_joy_mapping()</inline></reference> 尽早在脚本的 <literal>_ready()</literal> 函数中添加它们。</paragraph>
            </section>
            <section ids="my-controller-works-on-a-given-platform-but-not-on-another-platform" names="my\ controller\ works\ on\ a\ given\ platform,\ but\ not\ on\ another\ platform. 我的控制器在特定的平台上工作，但在另一个平台上却不能。">
                <title>我的控制器在特定的平台上工作，但在另一个平台上却不能。</title>
                <section ids="linux" names="linux">
                    <title>Linux</title>
                    <paragraph>If you're using a self-compiled engine binary, make sure it was compiled with
                        udev support. This is enabled by default, but it is possible to disable udev
                        support by specifying <literal>udev=no</literal> on the SCons command line. If you're using an
                        engine binary supplied by a Linux distribution, double-check whether it was
                        compiled with udev support.</paragraph>
                    <paragraph>Controllers can still work without udev support, but it is less reliable as
                        regular polling must be used to check for controllers being connected or
                        disconnected during gameplay (hotplugging).</paragraph>
                </section>
                <section ids="html5" names="html5">
                    <title>HTML5</title>
                    <paragraph>与 "本地" 平台相比，HTML5 控制器的支持通常不太可靠。各个浏览器对控制器的支持质量往往相差甚远。因此，如果玩家无法使用他们的控制器，你可能不得不指示他们使用不同的浏览器。</paragraph>
                    <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
                </section>
            </section>
        </section>
    </section>
</document>
