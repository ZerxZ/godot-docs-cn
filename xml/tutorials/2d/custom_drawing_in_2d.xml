<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/2d/custom_drawing_in_2d.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-custom-drawing-in-2d"></target>
    <section ids="custom-drawing-in-2d doc-custom-drawing-in-2d" names="custom\ drawing\ in\ 2d doc_custom_drawing_in_2d">
        <title>Custom drawing in 2D</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>Godot has nodes to draw sprites, polygons, particles, text, and many other
                common game development needs. However, if you need something specific
                not covered with the standard nodes you can make any 2D node (for example,
                <reference internal="True" refuri="../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference> or <reference internal="True" refuri="../../classes/class_node2d#class-node2d"><inline classes="std std-ref">Node2D</inline></reference>-based)
                draw on screen using custom commands.</paragraph>
            <paragraph>Custom drawing in a 2D node is <emphasis>really</emphasis> useful. Here are some use cases:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Drawing shapes or logic that existing nodes can't do, such as an image
                        with trails or a special animated polygon.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Drawing a large number of simple objects, such as a grid or a board
                        for a 2d game. Custom drawing avoids the overhead of using a large number
                        of nodes, possibly lowering memory usage and improving performance.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Making a custom UI control. There are plenty of controls available,
                        but when you have unusual needs, you will likely need a custom
                        control.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="drawing" names="drawing">
            <title>Drawing</title>
            <paragraph>Add a script to any <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference>
                derived node, like <reference internal="True" refuri="../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference> or
                <reference internal="True" refuri="../../classes/class_node2d#class-node2d"><inline classes="std std-ref">Node2D</inline></reference>. Then override the
                <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-private-method-draw"><inline classes="std std-ref">_draw()</inline></reference> function.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

func _draw():
    pass  # Your draw commands here.</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode2D : Node2D
{
    public override void _Draw()
    {
        // Your draw commands here.
    }
}</literal_block>
                </div>
            </container>
            <paragraph>Draw commands are described in the <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference>
                class reference. There are plenty of them and we will see some of them
                in the examples below.</paragraph>
        </section>
        <section ids="updating" names="updating">
            <title>Updating</title>
            <paragraph>The <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-private-method-draw"><inline classes="std std-ref">_draw</inline></reference> function is only called
                once, and then the draw commands are cached and remembered, so further calls
                are unnecessary.</paragraph>
            <paragraph>If re-drawing is required because a variable or something else changed,
                call <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-queue-redraw"><inline classes="std std-ref">CanvasItem.queue_redraw</inline></reference>
                in that same node and a new <literal>_draw()</literal> call will happen.</paragraph>
            <paragraph>Here is a little more complex example, where we have a texture variable
                that can be modified at any time, and using a
                <reference internal="True" refuri="../scripting/gdscript/gdscript_basics#doc-gdscript-basics-setters-getters"><inline classes="std std-ref">setter</inline></reference>, it forces a redraw
                of the texture when modified:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

@export var texture : Texture2D:
    set(value):
        texture = value
        queue_redraw()

func _draw():
    draw_texture(texture, Vector2())</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode2D : Node2D
{
    private Texture2D _texture;

    [Export]
    public Texture2D Texture
    {
        get
        {
            return _texture;
        }

        set
        {
            _texture = value;
            QueueRedraw();
        }
    }

    public override void _Draw()
    {
        DrawTexture(_texture, new Vector2());
    }
}</literal_block>
                </div>
            </container>
            <paragraph>To see it in action, you can set the texture to be the Godot icon on the
                editor by dragging and dropping the default <literal>icon.svg</literal> from the
                <literal>FileSystem</literal> tab to the Texture property on the <literal>Inspector</literal> tab.
                When changing the <literal>Texture</literal> property value while the previous script is
                running, the texture will also change automatically.</paragraph>
            <paragraph>In some cases, we may need to redraw every frame. For this,
                call <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-queue-redraw"><inline classes="std std-ref">queue_redraw</inline></reference>
                from the <reference internal="True" refuri="../../classes/class_node#class-node-private-method-process"><inline classes="std std-ref">_process</inline></reference> method, like this:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

func _draw():
    pass  # Your draw commands here.

func _process(_delta):
    queue_redraw()</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode2D : Node2D
{
    public override void _Draw()
    {
        // Your draw commands here.
    }

    public override void _Process(double delta)
    {
        QueueRedraw();
    }
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="coordinates-and-line-width-alignment" names="coordinates\ and\ line\ width\ alignment">
            <title>Coordinates and line width alignment</title>
            <paragraph>The drawing API uses the CanvasItem's coordinate system, not necessarily pixel
                coordinates. This means <literal>_draw()</literal> uses the coordinate space created after
                applying the CanvasItem's transform. Additionally, you can apply a custom
                transform on top of it by using
                <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-draw-set-transform"><inline classes="std std-ref">draw_set_transform</inline></reference> or
                <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-draw-set-transform-matrix"><inline classes="std std-ref">draw_set_transform_matrix</inline></reference>.</paragraph>
            <paragraph>When using <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-draw-line"><inline classes="std std-ref">draw_line</inline></reference>, you should
                consider the width of the line. When using a width that is an odd size, the
                position of the start and end points should be shifted by <literal>0.5</literal> to keep the
                line centered, as shown below.</paragraph>
            <image candidates="{'*': 'tutorials/2d/img/draw_line.png'}" original_uri="img/draw_line.png" uri="tutorials/2d/img/draw_line.png"></image>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _draw():
    draw_line(Vector2(1.5, 1.0), Vector2(1.5, 4.0), Color.GREEN, 1.0)
    draw_line(Vector2(4.0, 1.0), Vector2(4.0, 4.0), Color.GREEN, 2.0)
    draw_line(Vector2(7.5, 1.0), Vector2(7.5, 4.0), Color.GREEN, 3.0)</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Draw()
{
    DrawLine(new Vector2(1.5f, 1.0f), new Vector2(1.5f, 4.0f), Colors.Green, 1.0f);
    DrawLine(new Vector2(4.0f, 1.0f), new Vector2(4.0f, 4.0f), Colors.Green, 2.0f);
    DrawLine(new Vector2(7.5f, 1.0f), new Vector2(7.5f, 4.0f), Colors.Green, 3.0f);
}</literal_block>
                </div>
            </container>
            <paragraph>The same applies to the <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-draw-rect"><inline classes="std std-ref">draw_rect</inline></reference>
                method with <literal>filled = false</literal>.</paragraph>
            <image candidates="{'*': 'tutorials/2d/img/draw_rect.png'}" original_uri="img/draw_rect.png" uri="tutorials/2d/img/draw_rect.png"></image>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _draw():
    draw_rect(Rect2(1.0, 1.0, 3.0, 3.0), Color.GREEN)
    draw_rect(Rect2(5.5, 1.5, 2.0, 2.0), Color.GREEN, false, 1.0)
    draw_rect(Rect2(9.0, 1.0, 5.0, 5.0), Color.GREEN)
    draw_rect(Rect2(16.0, 2.0, 3.0, 3.0), Color.GREEN, false, 2.0)</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Draw()
{
    DrawRect(new Rect2(1.0f, 1.0f, 3.0f, 3.0f), Colors.Green);
    DrawRect(new Rect2(5.5f, 1.5f, 2.0f, 2.0f), Colors.Green, false, 1.0f);
    DrawRect(new Rect2(9.0f, 1.0f, 5.0f, 5.0f), Colors.Green);
    DrawRect(new Rect2(16.0f, 2.0f, 3.0f, 3.0f), Colors.Green, false, 2.0f);
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="antialiased-drawing" names="antialiased\ drawing">
            <title>Antialiased drawing</title>
            <paragraph>Godot offers method parameters in <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-draw-line"><inline classes="std std-ref">draw_line</inline></reference>
                to enable antialiasing, but not all custom drawing methods offer this <literal>antialiased</literal>
                parameter.</paragraph>
            <paragraph>For custom drawing methods that don't provide an <literal>antialiased</literal> parameter,
                you can enable 2D MSAA instead, which affects rendering in the entire viewport.
                This provides high-quality antialiasing, but a higher performance cost and only
                on specific elements. See <reference internal="True" refuri="2d_antialiasing#doc-2d-antialiasing"><inline classes="std std-ref">2D antialiasing</inline></reference> for more information.</paragraph>
            <paragraph>Here is a comparison of a line of minimal width (<literal>width=-1</literal>) drawn with
                <literal>antialiased=false</literal>, <literal>antialiased=true</literal>, and <literal>antialiased=false</literal> with
                2D MSAA 2x, 4x, and 8x enabled.</paragraph>
            <image candidates="{'*': 'tutorials/2d/img/draw_antialiasing_options.webp'}" original_uri="img/draw_antialiasing_options.webp" uri="tutorials/2d/img/draw_antialiasing_options.webp"></image>
        </section>
        <section ids="tools" names="tools">
            <title>Tools</title>
            <paragraph>Drawing your own nodes might also be desired while running them in the
                editor. This can be used as a preview or visualization of some feature or
                behavior.</paragraph>
            <paragraph>To do this, you can use the <reference internal="True" refuri="../scripting/gdscript/gdscript_basics#doc-gdscript-tool-mode"><inline classes="std std-ref">tool annotation</inline></reference>
                on both GDScript and C#. See
                <reference internal="True" refid="doc-draw-show-drawing-while-editing-example"><inline classes="std std-ref">the example below</inline></reference> and
                <reference internal="True" refuri="../plugins/running_code_in_the_editor#doc-running-code-in-the-editor"><inline classes="std std-ref">Running code in the editor</inline></reference> for more information.</paragraph>
            <target refid="doc-draw-custom-example-1"></target>
        </section>
        <section ids="example-1-drawing-a-custom-shape doc-draw-custom-example-1" names="example\ 1:\ drawing\ a\ custom\ shape doc_draw_custom_example_1">
            <title>Example 1: drawing a custom shape</title>
            <paragraph>We will now use the custom drawing functionality of the Godot Engine to draw
                something that Godot doesn't provide functions for. We will recreate the Godot
                logo but with code- only using drawing functions.</paragraph>
            <paragraph>You will have to code a function to perform this and draw it yourself.</paragraph>
            <note>
                <paragraph>The following instructions use a fixed set of coordinates that could be too small
                    for high resolution screens (larger than 1080p). If that is your case, and the
                    drawing is too small consider increasing your window scale in the project setting
                    <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-display-window-stretch-scale"><inline classes="std std-ref">Display &gt; Window &gt; Stretch &gt; Scale</inline></reference>
                    to adjust the project to a higher resolution (a 2 or 4 scale tends to work well).</paragraph>
            </note>
            <section ids="drawing-a-custom-polygon-shape" names="drawing\ a\ custom\ polygon\ shape">
                <title>Drawing a custom polygon shape</title>
                <paragraph>While there is a dedicated node to draw custom polygons (
                    <reference internal="True" refuri="../../classes/class_polygon2d#class-polygon2d"><inline classes="std std-ref">Polygon2D</inline></reference>), we will use in this case exclusively lower
                    level drawing functions to combine them on the same node and be able to create
                    more complex shapes later on.</paragraph>
                <paragraph>First, we will define a set of points -or X and Y coordinates- that will form
                    the base of our shape:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

var coords_head : Array = [
    [ 22.952, 83.271 ],  [ 28.385, 98.623 ],
    [ 53.168, 107.647 ], [ 72.998, 107.647 ],
    [ 99.546, 98.623 ],  [ 105.048, 83.271 ],
    [ 105.029, 55.237 ], [ 110.740, 47.082 ],
    [ 102.364, 36.104 ], [ 94.050, 40.940 ],
    [ 85.189, 34.445 ],  [ 85.963, 24.194 ],
    [ 73.507, 19.930 ],  [ 68.883, 28.936 ],
    [ 59.118, 28.936 ],  [ 54.494, 19.930 ],
    [ 42.039, 24.194 ],  [ 42.814, 34.445 ],
    [ 33.951, 40.940 ],  [ 25.637, 36.104 ],
    [ 17.262, 47.082 ],  [ 22.973, 55.237 ]
]</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode2D : Node2D
{
    private float[,] _coordsHead =
    {
        { 22.952f, 83.271f },  { 28.385f, 98.623f },
        { 53.168f, 107.647f }, { 72.998f, 107.647f },
        { 99.546f, 98.623f },  { 105.048f, 83.271f },
        { 105.029f, 55.237f }, { 110.740f, 47.082f },
        { 102.364f, 36.104f }, { 94.050f, 40.940f },
        { 85.189f, 34.445f },  { 85.963f, 24.194f },
        { 73.507f, 19.930f },  { 68.883f, 28.936f },
        { 59.118f, 28.936f },  { 54.494f, 19.930f },
        { 42.039f, 24.194f },  { 42.814f, 34.445f },
        { 33.951f, 40.940f },  { 25.637f, 36.104f },
        { 17.262f, 47.082f },  { 22.973f, 55.237f }
    };
}</literal_block>
                    </div>
                </container>
                <paragraph>This format, while compact, is not the one that Godot understands to
                    draw a polygon. In a different scenario we could have to load
                    these coordinates from a file or calculate the positions while the
                    application is running, so some transformation may be needed.</paragraph>
                <paragraph>To transform these coordinates into the right format, we will create a new
                    method <literal>float_array_to_Vector2Array()</literal>. Then we will override the <literal>_ready()</literal>
                    function, which Godot will call only once -at the start of the execution-
                    to load those coordinates into a variable:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var head : PackedVector2Array

func float_array_to_Vector2Array(coords : Array) -&gt; PackedVector2Array:
    # Convert the array of floats into a PackedVector2Array.
    var array : PackedVector2Array = []
    for coord in coords:
        array.append(Vector2(coord[0], coord[1]))
    return array

func _ready():
    head = float_array_to_Vector2Array(coords_head);</literal_block>
                    </div>
                    <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private Vector2[] _head;

private Vector2[] FloatArrayToVector2Array(float[,] coords)
{
    // Convert the array of floats into an array of Vector2.
    int size = coords.GetUpperBound(0);
    Vector2[] array = new Vector2[size + 1];
    for (int i = 0; i &lt;= size; i++)
    {
        array[i] = new Vector2(coords[i, 0], coords[i, 1]);
    }
    return array;
}

public override void _Ready()
{
    _head = FloatArrayToVector2Array(_coordsHead);
}</literal_block>
                    </div>
                </container>
                <paragraph>To finally draw our first shape, we will use the method
                    <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-draw-polygon"><inline classes="std std-ref">draw_polygon</inline></reference>
                    and pass the points (as an array of Vector2 coordinates) and its color,
                    like this:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _draw():
    # We are going to paint with this color.
    var godot_blue : Color = Color("478cbf")
    # We pass the PackedVector2Array to draw the shape.
    draw_polygon(head, [ godot_blue ])</literal_block>
                    </div>
                    <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Draw()
{
    // We are going to paint with this color.
    Color godotBlue = new Color("478cbf");
    // We pass the array of Vector2 to draw the shape.
    DrawPolygon(_head, [godotBlue]);
}</literal_block>
                    </div>
                </container>
                <paragraph>When running it you should see something like this:</paragraph>
                <image candidates="{'*': 'tutorials/2d/img/draw_godot_logo_polygon.webp'}" original_uri="img/draw_godot_logo_polygon.webp" uri="tutorials/2d/img/draw_godot_logo_polygon.webp"></image>
                <paragraph>Note the lower part of the logo looks segmented- this is because a low
                    amount of points were used to define that part. To simulate a smooth curve,
                    we could add more points to our array, or maybe use a mathematical function to
                    interpolate a curve and create a smooth shape from code (see
                    <reference internal="True" refid="doc-draw-custom-example-2"><inline classes="std std-ref">example 2</inline></reference>).</paragraph>
                <paragraph>Polygons will always <strong>connect its last defined point to its first
                        one</strong> in order to have a closed shape.</paragraph>
            </section>
            <section ids="drawing-connected-lines" names="drawing\ connected\ lines">
                <title>Drawing connected lines</title>
                <paragraph>Drawing a sequence of connected lines that don't close down to form a polygon
                    is very similar to the previous method. We will use a connected set of lines to
                    draw Godot's logo mouth.</paragraph>
                <paragraph>First, we will define the list of coordinates that form the mouth shape, like this:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var coords_mouth = [
    [ 22.817, 81.100 ], [ 38.522, 82.740 ],
    [ 39.001, 90.887 ], [ 54.465, 92.204 ],
    [ 55.641, 84.260 ], [ 72.418, 84.177 ],
    [ 73.629, 92.158 ], [ 88.895, 90.923 ],
    [ 89.556, 82.673 ], [ 105.005, 81.100 ]
]</literal_block>
                    </div>
                    <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private float[,] _coordsMouth =
{
    { 22.817f, 81.100f }, { 38.522f, 82.740f },
    { 39.001f, 90.887f }, { 54.465f, 92.204f },
    { 55.641f, 84.260f }, { 72.418f, 84.177f },
    { 73.629f, 92.158f }, { 88.895f, 90.923f },
    { 89.556f, 82.673f }, { 105.005f, 81.100f }
};</literal_block>
                    </div>
                </container>
                <paragraph>We will load these coordinates into a variable and define an additional
                    variable with the configurable line thickness:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var mouth : PackedVector2Array
var _mouth_width : float = 4.4

func _ready():
    head = float_array_to_Vector2Array(coords_head);
    mouth = float_array_to_Vector2Array(coords_mouth);</literal_block>
                    </div>
                    <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private Vector2[] _mouth;
private float _mouthWidth = 4.4f;

public override void _Ready()
{
    _head = FloatArrayToVector2Array(_coordsHead);
    _mouth = FloatArrayToVector2Array(_coordsMouth);
}</literal_block>
                    </div>
                </container>
                <paragraph>And finally we will use the method
                    <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-draw-polyline"><inline classes="std std-ref">draw_polyline</inline></reference> to actually
                    draw the line, like this:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-10-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-10-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-10-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _draw():
    # We will use white to draw the line.
    var white : Color = Color.WHITE
    var godot_blue : Color = Color("478cbf")

    draw_polygon(head, [ godot_blue ])

    # We draw the while line on top of the previous shape.
    draw_polyline(mouth, white, _mouth_width)</literal_block>
                    </div>
                    <div aria-labelledby="tab-10-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-10-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Draw()
{
    // We will use white to draw the line.
    Color white = Colors.White;
    Color godotBlue = new Color("478cbf");

    DrawPolygon(_head, [godotBlue]);

    // We draw the while line on top of the previous shape.
    DrawPolyline(_mouth, white, _mouthWidth);
}</literal_block>
                    </div>
                </container>
                <paragraph>You should get the following output:</paragraph>
                <image candidates="{'*': 'tutorials/2d/img/draw_godot_logo_polyline.webp'}" original_uri="img/draw_godot_logo_polyline.webp" uri="tutorials/2d/img/draw_godot_logo_polyline.webp"></image>
                <paragraph>Unlike <literal>draw_polygon()</literal>, polylines can only have a single unique color
                    for all its points (the second argument). This method has 2 additional
                    arguments: the width of the line (which is as small as possible by default)
                    and enabling or disabling the antialiasing (it is disabled by default).</paragraph>
                <paragraph>The order of the <literal>_draw</literal> calls is important- like with the Node positions on
                    the tree hierarchy, the different shapes will be drawn from top to bottom,
                    resulting in the latest shapes hiding earlier ones if they overlap. In this
                    case we want the mouth drawn over the head, so we put it afterwards.</paragraph>
                <paragraph>Notice how we can define colors in different ways, either with a hexadecimal
                    code or a predefined color name. Check the class <reference internal="True" refuri="../../classes/class_color#class-color"><inline classes="std std-ref">Color</inline></reference> for other
                    constants and ways to define Colors.</paragraph>
            </section>
            <section ids="drawing-circles" names="drawing\ circles">
                <title>Drawing circles</title>
                <paragraph>To create the eyes, we are going to add 4 additional calls to draw the eye
                    shapes, in different sizes, colors and positions.</paragraph>
                <paragraph>To draw a circle, you position it based on its center using the
                    <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-draw-circle"><inline classes="std std-ref">draw_circle</inline></reference> method. The first
                    parameter is a <reference internal="True" refuri="../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> with the coordinates of its center, the second is
                    its radius, and the third is its color:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-11-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-11-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-11-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _draw():
    var white : Color = Color.WHITE
    var godot_blue : Color = Color("478cbf")
    var grey : Color = Color("414042")

    draw_polygon(head, [ godot_blue ])
    draw_polyline(mouth, white, _mouth_width)

    # Four circles for the 2 eyes: 2 white, 2 grey.
    draw_circle(Vector2(42.479, 65.4825), 9.3905, white)
    draw_circle(Vector2(85.524, 65.4825), 9.3905, white)
    draw_circle(Vector2(43.423, 65.92), 6.246, grey)
    draw_circle(Vector2(84.626, 66.008), 6.246, grey)</literal_block>
                    </div>
                    <div aria-labelledby="tab-11-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-11-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Draw()
{
    Color white = Colors.White;
    Color godotBlue = new Color("478cbf");
    Color grey = new Color("414042");

    DrawPolygon(_head, [godotBlue]);
    DrawPolyline(_mouth, white, _mouthWidth);

    // Four circles for the 2 eyes: 2 white, 2 grey.
    DrawCircle(new Vector2(42.479f, 65.4825f), 9.3905f, white);
    DrawCircle(new Vector2(85.524f, 65.4825f), 9.3905f, white);
    DrawCircle(new Vector2(43.423f, 65.92f), 6.246f, grey);
    DrawCircle(new Vector2(84.626f, 66.008f), 6.246f, grey);
}</literal_block>
                    </div>
                </container>
                <paragraph>When executing it, you should have something like this:</paragraph>
                <image candidates="{'*': 'tutorials/2d/img/draw_godot_logo_circle.webp'}" original_uri="img/draw_godot_logo_circle.webp" uri="tutorials/2d/img/draw_godot_logo_circle.webp"></image>
                <paragraph>For partial, unfilled arcs (portions of a circle shape between certain
                    arbitrary angles), you can use the method
                    <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-draw-arc"><inline classes="std std-ref">draw_arc</inline></reference>.</paragraph>
            </section>
            <section ids="drawing-lines" names="drawing\ lines">
                <title>Drawing lines</title>
                <paragraph>To draw the final shape (the nose) we will use a line to approximate it.</paragraph>
                <paragraph><reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-draw-line"><inline classes="std std-ref">draw_line</inline></reference> can be used to draw
                    a single segment by providing its start and end coordinates as arguments,
                    like this:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-12-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-12-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-12-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-12-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-12-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-12-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _draw():
    var white : Color = Color.WHITE
    var godot_blue : Color = Color("478cbf")
    var grey : Color = Color("414042")

    draw_polygon(head, [ godot_blue ])
    draw_polyline(mouth, white, _mouth_width)
    draw_circle(Vector2(42.479, 65.4825), 9.3905, white)
    draw_circle(Vector2(85.524, 65.4825), 9.3905, white)
    draw_circle(Vector2(43.423, 65.92), 6.246, grey)
    draw_circle(Vector2(84.626, 66.008), 6.246, grey)

    # Draw a short but thick white vertical line for the nose.
    draw_line(Vector2(64.273, 60.564), Vector2(64.273, 74.349), white, 5.8)</literal_block>
                    </div>
                    <div aria-labelledby="tab-12-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-12-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Draw()
{
    Color white = Colors.White;
    Color godotBlue = new Color("478cbf");
    Color grey = new Color("414042");

    DrawPolygon(_head, [godotBlue]);
    DrawPolyline(_mouth, white, _mouthWidth);
    DrawCircle(new Vector2(42.479f, 65.4825f), 9.3905f, white);
    DrawCircle(new Vector2(85.524f, 65.4825f), 9.3905f, white);
    DrawCircle(new Vector2(43.423f, 65.92f), 6.246f, grey);
    DrawCircle(new Vector2(84.626f, 66.008f), 6.246f, grey);

    // Draw a short but thick white vertical line for the nose.
    DrawLine(new Vector2(64.273f, 60.564f), new Vector2(64.273f, 74.349f),
             white, 5.8f);
}</literal_block>
                    </div>
                </container>
                <paragraph>You should now be able to see the following shape on screen:</paragraph>
                <image candidates="{'*': 'tutorials/2d/img/draw_godot_logo_line.webp'}" original_uri="img/draw_godot_logo_line.webp" uri="tutorials/2d/img/draw_godot_logo_line.webp"></image>
                <paragraph>Note that if multiple unconnected lines are going to be drawn at the same time,
                    you may get additional performance by drawing all of them in a single call, using
                    the <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-draw-multiline"><inline classes="std std-ref">draw_multiline</inline></reference> method.</paragraph>
            </section>
            <section ids="drawing-text" names="drawing\ text">
                <title>Drawing text</title>
                <paragraph>While using the <reference internal="True" refuri="../../classes/class_label#class-label"><inline classes="std std-ref">Label</inline></reference> Node is the most common way to add
                    text to your application, the low-level <title_reference>_draw</title_reference> function includes functionality
                    to add text to your custom Node drawing. We will use it to add the name "GODOT"
                    under the robot head.</paragraph>
                <paragraph>We will use the <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-draw-string"><inline classes="std std-ref">draw_string</inline></reference> method
                    to do it, like this:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-13-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-13-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-13-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-13-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-13-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-13-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var default_font : Font = ThemeDB.fallback_font;

func _draw():
    var white : Color = Color.WHITE
    var godot_blue : Color = Color("478cbf")
    var grey : Color = Color("414042")

    draw_polygon(head, [ godot_blue ])
    draw_polyline(mouth, white, _mouth_width)
    draw_circle(Vector2(42.479, 65.4825), 9.3905, white)
    draw_circle(Vector2(85.524, 65.4825), 9.3905, white)
    draw_circle(Vector2(43.423, 65.92), 6.246, grey)
    draw_circle(Vector2(84.626, 66.008), 6.246, grey)
    draw_line(Vector2(64.273, 60.564), Vector2(64.273, 74.349), white, 5.8)

    # Draw GODOT text below the logo with the default font, size 22.
    draw_string(default_font, Vector2(20, 130), "GODOT",
                HORIZONTAL_ALIGNMENT_CENTER, 90, 22)</literal_block>
                    </div>
                    <div aria-labelledby="tab-13-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-13-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private Font _defaultFont = ThemeDB.FallbackFont;

public override void _Draw()
{
    Color white = Colors.White;
    Color godotBlue = new Color("478cbf");
    Color grey = new Color("414042");

    DrawPolygon(_head, [godotBlue]);
    DrawPolyline(_mouth, white, _mouthWidth);
    DrawCircle(new Vector2(42.479f, 65.4825f), 9.3905f, white);
    DrawCircle(new Vector2(85.524f, 65.4825f), 9.3905f, white);
    DrawCircle(new Vector2(43.423f, 65.92f), 6.246f, grey);
    DrawCircle(new Vector2(84.626f, 66.008f), 6.246f, grey);
    DrawLine(new Vector2(64.273f, 60.564f), new Vector2(64.273f, 74.349f),
             white, 5.8f);

    // Draw GODOT text below the logo with the default font, size 22.
    DrawString(_defaultFont, new Vector2(20f, 130f), "GODOT",
               HorizontalAlignment.Center, 90, 22);
}</literal_block>
                    </div>
                </container>
                <paragraph>Here we first load into the defaultFont variable the configured default theme
                    font (a custom one can be set instead) and then we pass the following
                    parameters: font, position, text, horizontal alignment, width, and font size.</paragraph>
                <paragraph>You should see the following on your screen:</paragraph>
                <image candidates="{'*': 'tutorials/2d/img/draw_godot_logo_text.webp'}" original_uri="img/draw_godot_logo_text.webp" uri="tutorials/2d/img/draw_godot_logo_text.webp"></image>
                <paragraph>Additional parameters as well as other methods related to text and characters
                    can be found on the <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference> class reference.</paragraph>
                <target refid="doc-draw-show-drawing-while-editing-example"></target>
            </section>
            <section ids="show-the-drawing-while-editing doc-draw-show-drawing-while-editing-example" names="show\ the\ drawing\ while\ editing doc_draw_show_drawing_while_editing_example">
                <title>Show the drawing while editing</title>
                <paragraph>While the code so far is able to draw the logo on a running window, it will
                    not show up on the <literal>2D view</literal> on the editor. In certain cases you would
                    also like to show your custom Node2D or control on the editor, to position
                    and scale it appropriately, like most other nodes do.</paragraph>
                <paragraph>To show the logo directly on the editor (without running it), you can use the
                    <reference internal="True" refuri="../scripting/gdscript/gdscript_basics#doc-gdscript-tool-mode"><inline classes="std std-ref">@tool</inline></reference> annotation to request the custom drawing
                    of the node to also appear while editing, like this:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-14-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-14-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-14-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-14-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-14-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-14-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@tool
extends Node2D</literal_block>
                    </div>
                    <div aria-labelledby="tab-14-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-14-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

[Tool]
public partial class MyNode2D : Node2D</literal_block>
                    </div>
                </container>
                <paragraph>You will need to save your scene, rebuild your project (for C# only) and reload
                    the current scene manually at the menu option <literal>Scene &gt; Reload Saved Scene</literal>
                    to refresh the current node in the <literal>2D</literal> view the first time you add or remove
                    the <literal>@tool</literal> annotation.</paragraph>
            </section>
            <section ids="animation" names="animation">
                <title>Animation</title>
                <paragraph>If we wanted to make the custom shape change at runtime, we could modify the
                    methods called or its arguments at execution time, or apply a transform.</paragraph>
                <paragraph>For example, if we want the custom shape we just designed to rotate, we could add
                    the following variable and code to the <literal>_ready</literal> and <literal>_process</literal> methods:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-15-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-15-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-15-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-15-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-15-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-15-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

@export var rotation_speed : float = 1  # In radians per second.

func _ready():
    rotation = 0
    ...

func _process(delta: float):
    rotation -= rotation_speed * delta</literal_block>
                    </div>
                    <div aria-labelledby="tab-15-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-15-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public float RotationSpeed { get; set; } = 1.0f;  // In radians per second.

public override void _Ready()
{
    Rotation = 0;
    ...
}

public override void _Process(double delta)
{
    Rotation -= RotationSpeed * (float)delta;
}</literal_block>
                    </div>
                </container>
                <paragraph>The problem with the above code is that because we have created the points
                    approximately on a rectangle starting from the upper left corner, the <literal>(0, 0)</literal>
                    coordinate and extending to the right and down, we see that the rotation is done
                    using the top left corner as pivot. A position transform change on the node
                    won't help us here, as the rotation transform is applied first.</paragraph>
                <paragraph>While we could rewrite all of the points' coordinates to be centered around
                    <literal>(0, 0)</literal>, including negative coordinates, that would be a lot of work.</paragraph>
                <paragraph>One possible way to work around this is to use the lower level
                    <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-draw-set-transform"><inline classes="std std-ref">draw_set_transform</inline></reference>
                    method to fix this issue, translating all points in the CanvasItem's own space,
                    and then moving it back to its original place with a regular node transform,
                    either in the editor or in code, like this:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-16-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-16-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-16-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-16-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-16-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-16-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    rotation = 0
    position = Vector2(60, 60)
    ...

func _draw():
    draw_set_transform(Vector2(-60, -60))
    ...</literal_block>
                    </div>
                    <div aria-labelledby="tab-16-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-16-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    Rotation = 0;
    Position = new Vector2(60, 60);
    ...
}

public override void _Draw()
{
    DrawSetTransform(new Vector2(-60.0f, -60.0f));
    ...
}</literal_block>
                    </div>
                </container>
                <paragraph>This is the result, rotating around a pivot now on <literal>(60, 60)</literal>:</paragraph>
                <image candidates="{'*': 'tutorials/2d/img/draw_godot_rotation.webp'}" original_uri="img/draw_godot_rotation.webp" uri="tutorials/2d/img/draw_godot_rotation.webp"></image>
                <paragraph>If what we wanted to animate was a property inside the <literal>_draw()</literal> call, we must remember to
                    call <literal>queue_redraw()</literal> to force a refresh, as otherwise it would not be updated on screen.</paragraph>
                <paragraph>For example, this is how we can make the robot appear to open and close its mouth, by
                    changing the width of its mouth line follow a sinusoidal (<reference internal="True" refuri="../../classes/class_@globalscope#class-globalscope-method-sin"><inline classes="std std-ref">sin</inline></reference>) curve:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-17-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-17-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-17-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-17-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-17-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-17-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var _mouth_width : float = 4.4
var _max_width : float = 7
var _time : float = 0

func _process(delta : float):
    _time += delta
    _mouth_width = abs(sin(_time) * _max_width)
    queue_redraw()

func _draw():
    ...
    draw_polyline(mouth, white, _mouth_width)
    ...</literal_block>
                    </div>
                    <div aria-labelledby="tab-17-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-17-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private float _mouthWidth = 4.4f;
private float _maxWidth = 7f;
private float _time = 0f;

public override void _Process(double delta)
{
    _time += (float)delta;
    _mouthWidth = Mathf.Abs(Mathf.Sin(_time) * _maxWidth);
    QueueRedraw();
}

public override void _Draw()
{
    ...
    DrawPolyline(_mouth, white, _mouthWidth);
    ...
}</literal_block>
                    </div>
                </container>
                <paragraph>It will look somewhat like this when run:</paragraph>
                <image candidates="{'*': 'tutorials/2d/img/draw_godot_mouth_animation.webp'}" original_uri="img/draw_godot_mouth_animation.webp" uri="tutorials/2d/img/draw_godot_mouth_animation.webp"></image>
                <paragraph>Please note that <literal>_mouth_width</literal> is a user defined property like any other
                    and it or any other used as a drawing argument can be animated using more
                    standard and high-level methods such as a <reference internal="True" refuri="../../classes/class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference> or an
                    <reference internal="True" refuri="../../classes/class_animationplayer#class-animationplayer"><inline classes="std std-ref">AnimationPlayer</inline></reference> Node. The only difference is
                    that a <literal>queue_redraw()</literal> call is needed to apply those changes so they get
                    shown on screen.</paragraph>
                <target refid="doc-draw-custom-example-2"></target>
            </section>
        </section>
        <section ids="example-2-drawing-a-dynamic-line doc-draw-custom-example-2" names="example\ 2:\ drawing\ a\ dynamic\ line doc_draw_custom_example_2">
            <title>Example 2: drawing a dynamic line</title>
            <paragraph>The previous example was useful to learn how to draw and modify nodes with
                custom shapes and animations. This could have some advantages, such as using
                exact coordinates and vectors for drawing, rather than bitmaps -which means
                they will scale well when transformed on screen. In some cases, similar results
                could be achieved composing higher level functionality with nodes such as
                <reference internal="True" refuri="../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">sprites</inline></reference> or
                <reference internal="True" refuri="../../classes/class_animatedsprite2d#class-animatedsprite2d"><inline classes="std std-ref">AnimatedSprites</inline></reference> loading SVG resources (which are
                also images defined with vectors) and the
                <reference internal="True" refuri="../../classes/class_animationplayer#class-animationplayer"><inline classes="std std-ref">AnimationPlayer</inline></reference> node.</paragraph>
            <paragraph>In other cases that will not be possible because we will not know what the
                resulting graphical representation will be before running the code. Here we
                will see how to draw a dynamic line whose coordinates are not known beforehand,
                and are affected by the user's input.</paragraph>
            <section ids="drawing-a-straight-line-between-2-points" names="drawing\ a\ straight\ line\ between\ 2\ points">
                <title>Drawing a straight line between 2 points</title>
                <paragraph>Let's assume we want to draw a straight line between 2 points, the first one
                    will be fixed on the upper left corner <literal>(0, 0)</literal> and the second will be defined
                    by the cursor position on screen.</paragraph>
                <paragraph>We could draw a dynamic line between those 2 points like this:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-18-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-18-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-18-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-18-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-18-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-18-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

var point1 : Vector2 = Vector2(0, 0)
var width : int = 10
var color : Color = Color.GREEN

var _point2 : Vector2

func _process(_delta):
    var mouse_position = get_viewport().get_mouse_position()
    if mouse_position != _point2:
        _point2 = mouse_position
        queue_redraw()

func _draw():
    draw_line(point1, _point2, color, width)</literal_block>
                    </div>
                    <div aria-labelledby="tab-18-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-18-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;
using System;

public partial class MyNode2DLine : Node2D
{
    public Vector2 Point1 { get; set; } = new Vector2(0f, 0f);
    public int Width { get; set; } = 10;
    public Color Color { get; set; } = Colors.Green;

    private Vector2 _point2;

    public override void _Process(double delta)
    {
        Vector2 mousePosition = GetViewport().GetMousePosition();
        if (mousePosition != _point2)
        {
            _point2 = mousePosition;
            QueueRedraw();
        }
    }

    public override void _Draw()
    {
        DrawLine(Point1, _point2, Color, Width);
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>In this example we obtain the position of the mouse in the default viewport
                    every frame with the method
                    <reference internal="True" refuri="../../classes/class_viewport#class-viewport-method-get-mouse-position"><inline classes="std std-ref">get_mouse_position</inline></reference>. If the
                    position has changed since the last draw request (a small optimization to
                    avoid redrawing on every frame)- we will schedule a redraw. Our <literal>_draw()</literal>
                    method only has one line: requesting the drawing of a green line of
                    width 10 pixels between the top left corner and that obtained position.</paragraph>
                <paragraph>The width, color, and position of the starting point can be configured with
                    with the corresponding properties.</paragraph>
                <paragraph>It should look like this when run:</paragraph>
                <image candidates="{'*': 'tutorials/2d/img/draw_line_between_2_points.webp'}" original_uri="img/draw_line_between_2_points.webp" uri="tutorials/2d/img/draw_line_between_2_points.webp"></image>
            </section>
            <section ids="drawing-an-arc-between-2-points" names="drawing\ an\ arc\ between\ 2\ points">
                <title>Drawing an arc between 2 points</title>
                <paragraph>The above example works, but we may want to join those 2 points with a
                    different shape or function, other than a straight line.</paragraph>
                <paragraph>Let's try now creating an arc (a portion of a circumference) between
                    both points.</paragraph>
                <paragraph>Exporting the line starting point, segments, width, color, and antialiasing will
                    allow us to modify those properties very easily directly from the editor
                    inspector panel:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-19-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-19-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-19-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-19-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-19-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-19-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

@export var point1 : Vector2 = Vector2(0, 0)
@export_range(1, 1000) var segments : int = 100
@export var width : int = 10
@export var color : Color = Color.GREEN
@export var antialiasing : bool = false

var _point2 : Vector2</literal_block>
                    </div>
                    <div aria-labelledby="tab-19-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-19-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;
using System;

public partial class MyNode2DLine : Node2D
{
    [Export]
    public Vector2 Point1 { get; set; } = new Vector2(0f, 0f);
    [Export]
    public float Length { get; set; } = 350f;
    [Export(PropertyHint.Range, "1,1000,")]
    public int Segments { get; set; } = 100;
    [Export]
    public int Width { get; set; } = 10;
    [Export]
    public Color Color { get; set; } = Colors.Green;
    [Export]
    public bool AntiAliasing { get; set; } = false;

    private Vector2 _point2;
}</literal_block>
                    </div>
                </container>
                <image candidates="{'*': 'tutorials/2d/img/draw_dynamic_exported_properties.webp'}" original_uri="img/draw_dynamic_exported_properties.webp" uri="tutorials/2d/img/draw_dynamic_exported_properties.webp"></image>
                <paragraph>To draw the arc, we can use the method
                    <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-draw-arc"><inline classes="std std-ref">draw_arc</inline></reference>. There are many
                    arcs that pass through 2 points, so we will chose for this example
                    the semicircle that has its center in the middle point between the 2 initial
                    points.</paragraph>
                <paragraph>Calculating this arc will be more complex than in the case of the line:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-20-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-20-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-20-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-20-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-20-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-20-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _draw():
    # Average points to get center.
    var center : Vector2 = Vector2((_point2.x + point1.x) / 2,
                                   (_point2.y + point1.y) / 2)
    # Calculate the rest of the arc parameters.
    var radius : float = point1.distance_to(_point2) / 2
    var start_angle : float = (_point2 - point1).angle()
    var end_angle : float = (point1 - _point2).angle()
    if end_angle &lt; 0:  # end_angle is likely negative, normalize it.
        end_angle += TAU

    # Finally, draw the arc.
    draw_arc(center, radius, start_angle, end_angle, segments, color,
             width, antialiasing)</literal_block>
                    </div>
                    <div aria-labelledby="tab-20-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-20-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Draw()
{
    // Average points to get center.
    Vector2 center = new Vector2((_point2.X + Point1.X) / 2.0f,
                                    (_point2.Y + Point1.Y) / 2.0f);
    // Calculate the rest of the arc parameters.
    float radius = Point1.DistanceTo(_point2) / 2.0f;
    float startAngle = (_point2 - Point1).Angle();
    float endAngle = (Point1 - _point2).Angle();
    if (endAngle &lt; 0.0f)  // endAngle is likely negative, normalize it.
    {
        endAngle += Mathf.Tau;
    }

    // Finally, draw the arc.
    DrawArc(center, radius, startAngle, endAngle, Segments, Color,
            Width, AntiAliasing);
}</literal_block>
                    </div>
                </container>
                <paragraph>The center of the semicircle will be the middle point between both points.
                    The radius will be half the distance between both points.
                    The start and end angles will be the angles of the vector from point1
                    to point2 and vice-versa.
                    Note we had to normalize the <literal>end_angle</literal> in positive values because if
                    <literal>end_angle</literal> is less than <literal>start_angle</literal>, the arc will be drawn
                    counter-clockwise, which we don't want in this case (the arc would be
                    upside-down).</paragraph>
                <paragraph>The result should be something like this, with the arc going down and
                    between the points:</paragraph>
                <image candidates="{'*': 'tutorials/2d/img/draw_arc_between_2_points.webp'}" original_uri="img/draw_arc_between_2_points.webp" uri="tutorials/2d/img/draw_arc_between_2_points.webp"></image>
                <paragraph>Feel free to play with the parameters in the inspector to obtain different
                    results: change the color, the width, the antialiasing, and increase the
                    number of segments to increase the curve smoothness, at the cost of extra
                    performance.</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
