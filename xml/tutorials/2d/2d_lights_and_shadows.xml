<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/2d/2d_lights_and_shadows.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-2d-lights-and-shadows"></target>
    <section ids="d-lights-and-shadows doc-2d-lights-and-shadows" names="2d\ lights\ and\ shadows doc_2d_lights_and_shadows">
        <title>2D lights and shadows</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>By default, 2D scenes in Godot are unshaded, with no lights and shadows visible.
                While this is fast to render, unshaded scenes can look bland. Godot provides the
                ability to use real-time 2D lighting and shadows, which can greatly enhance the
                sense of depth in your project.</paragraph>
            <figure align="center" ids="id1">
                <image alt="No 2D lights or shadows, scene is unshaded" candidates="{'*': 'tutorials/2d/img/2d_lights_and_shadows_disabled.webp'}" original_uri="img/2d_lights_and_shadows_disabled.webp" uri="tutorials/2d/img/2d_lights_and_shadows_disabled.webp"></image>
                <caption>No 2D lights or shadows, scene is unshaded</caption>
            </figure>
            <figure align="center" ids="id2">
                <image alt="2D lights enabled (without shadows)" candidates="{'*': 'tutorials/2d/img/2d_lights_and_shadows_enabled_no_shadows.webp'}" original_uri="img/2d_lights_and_shadows_enabled_no_shadows.webp" uri="tutorials/2d/img/2d_lights_and_shadows_enabled_no_shadows.webp"></image>
                <caption>2D lights enabled (without shadows)</caption>
            </figure>
            <figure align="center" ids="id3">
                <image alt="2D lights and shadows enabled" candidates="{'*': 'tutorials/2d/img/2d_lights_and_shadows_enabled.webp'}" original_uri="img/2d_lights_and_shadows_enabled.webp" uri="tutorials/2d/img/2d_lights_and_shadows_enabled.webp"></image>
                <caption>2D lights and shadows enabled</caption>
            </figure>
        </section>
        <section ids="nodes" names="nodes">
            <title>Nodes</title>
            <paragraph>There are several nodes involved in a complete 2D lighting setup:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_canvasmodulate#class-canvasmodulate"><inline classes="std std-ref">CanvasModulate</inline></reference> (to darken the rest of the scene)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_pointlight2d#class-pointlight2d"><inline classes="std std-ref">PointLight2D</inline></reference> (for omnidirectional or spot lights)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_directionallight2d#class-directionallight2d"><inline classes="std std-ref">DirectionalLight2D</inline></reference> (for sunlight or moonlight)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_lightoccluder2d#class-lightoccluder2d"><inline classes="std std-ref">LightOccluder2D</inline></reference> (for light shadow casters)</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Other 2D nodes that receive lighting, such as Sprite2D or TileMapLayer.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><reference internal="True" refuri="../../classes/class_canvasmodulate#class-canvasmodulate"><inline classes="std std-ref">CanvasModulate</inline></reference> is used to darken the scene by
                specifying a color that will act as the base "ambient" color. This is the final
                lighting color in areas that are <emphasis>not</emphasis> reached by any 2D light. Without a
                CanvasModulate node, the final scene would look too bright as 2D lights would
                only brighten the existing unshaded appearance (which appears fully lit).</paragraph>
            <paragraph><reference internal="True" refuri="../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite2Ds</inline></reference> are used to display the textures for the light
                blobs, the background, and for the shadow casters.</paragraph>
            <paragraph><reference internal="True" refuri="../../classes/class_pointlight2d#class-pointlight2d"><inline classes="std std-ref">PointLight2Ds</inline></reference> are used to light the scene. The way a
                light typically works is by adding a selected texture over the rest of the scene
                to simulate lighting.</paragraph>
            <paragraph><reference internal="True" refuri="../../classes/class_lightoccluder2d#class-lightoccluder2d"><inline classes="std std-ref">LightOccluder2Ds</inline></reference> are used to tell the shader
                which parts of the scene cast shadows. These occluders can be placed as
                independent nodes or can be part of a TileMapLayer node.</paragraph>
            <paragraph>The shadows appear only on areas covered by the <reference internal="True" refuri="../../classes/class_pointlight2d#class-pointlight2d"><inline classes="std std-ref">PointLight2D</inline></reference> and their direction is based on the center of the
                <reference internal="True" refuri="../../classes/class_pointlight2d#class-pointlight2d"><inline classes="std std-ref">Light</inline></reference>.</paragraph>
            <note>
                <paragraph>The background color does <strong>not</strong> receive any lighting. If you want light to
                    be cast on the background, you need to add a visual representation for the
                    background, such as a Sprite2D.</paragraph>
                <paragraph>The Sprite2D's <strong>Region</strong> properties can be helpful to quickly create a
                    repeating background texture, but remember to also set <strong>Texture &gt; Repeat</strong> to
                    <strong>Enabled</strong> in the Sprite2D's properties.</paragraph>
            </note>
        </section>
        <section ids="point-lights" names="point\ lights">
            <title>Point lights</title>
            <paragraph>Point lights (also called positional lights) are the most common element in 2D
                lighting. Point lights can be used to represent light from torches, fire,
                projectiles, etc.</paragraph>
            <paragraph>PointLight2D offers the following properties to tweak in the inspector:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Texture:</strong> The texture to use as a light source. The texture's size
                        determines the size of the light. The texture may have an alpha channel, which
                        is useful when using Light2D's <strong>Mix</strong> blend mode, but it is not required if
                        using the <strong>Add</strong> (default) or <strong>Subtract</strong> blend modes.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Offset:</strong> The offset for the light texture. Unlike when you move the light
                        node, changing the offset does <emphasis>not</emphasis> cause shadows to move.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Texture Scale:</strong> The multiplier for the light's size. Higher values will
                        make the light extend out further. Larger lights have a higher performance
                        cost as they affect more pixels on screen, so consider this before increasing
                        a light's size.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Height:</strong> The light's virtual height with regards to normal mapping. By
                        default, the light is very close to surfaces receiving lights. This will make
                        lighting hardly visible if normal mapping is used, so consider increasing this
                        value. Adjusting the light's height only makes a visible difference on
                        surfaces that use normal mapping.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If you don't have a pre-made texture to use in a light, you can use this "neutral"
                point light texture (right-click &gt; <strong>Save Image As…</strong>):</paragraph>
            <figure align="center" ids="id4">
                <image alt="Neutral point light texture" candidates="{'*': 'tutorials/2d/img/2d_lights_and_shadows_neutral_point_light.webp'}" original_uri="img/2d_lights_and_shadows_neutral_point_light.webp" uri="tutorials/2d/img/2d_lights_and_shadows_neutral_point_light.webp"></image>
                <caption>Neutral point light texture</caption>
            </figure>
            <paragraph>If you need different falloff, you can procedurally create a texture by assigning
                a <strong>New GradientTexture2D</strong> on the light's <strong>Texture</strong> property. After creating
                the resource, expand its <strong>Fill</strong> section and set the fill mode to <strong>Radial</strong>.
                You will then have to adjust the gradient itself to start from opaque white to
                transparent white, and move its starting location to be in the center.</paragraph>
        </section>
        <section ids="directional-light" names="directional\ light">
            <title>Directional light</title>
            <paragraph>Directional lighting is used to represent sunlight or moonlight. Light rays are
                casted parallel to each other, as if the sun or moon was infinitely far away
                from the surface that is receiving the light.</paragraph>
            <paragraph>DirectionalLight2D offers the following properties:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Height:</strong> The light's virtual height with regards to normal mapping (<literal>0.0</literal>
                        = parallel to surfaces, <literal>1.0</literal> = perpendicular to surfaces). By default, the
                        light is fully parallel with the surfaces receiving lights. This will make
                        lighting hardly visible if normal mapping is used, so consider increasing this
                        value. Adjusting the light's height only makes a visual difference on surfaces
                        that use normal mapping. <strong>Height</strong> does not affect shadows' appearance.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Max Distance:</strong> The maximum distance from the camera center objects can be
                        before their shadows are culled (in pixels). Decreasing this value can prevent
                        objects located outside the camera from casting shadows (while also improving
                        performance). Camera2D zoom is not taken into account by <strong>Max Distance</strong>,
                        which means that at higher zoom values, shadows will appear to fade out sooner
                        when zooming onto a given point.</paragraph>
                </list_item>
            </bullet_list>
            <note>
                <paragraph>Directional shadows will always appear to be infinitely long, regardless
                    of the value of the <strong>Height</strong> property. This is a limitation of the shadow
                    rendering method used for 2D lights in Godot.</paragraph>
                <paragraph>To have directional shadows that are not infinitely long, you should disable
                    shadows in the DirectionalLight2D and use a custom shader that reads from
                    the 2D signed distance field instead. This distance field is automatically
                    generated from LightOccluder2D nodes present in the scene.</paragraph>
            </note>
        </section>
        <section ids="common-light-properties" names="common\ light\ properties">
            <title>Common light properties</title>
            <paragraph>Both PointLight2D and DirectionalLight2D offer common properties, which are part
                of the Light2D base class:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Enabled:</strong> Allows toggling the light's visibility. Unlike hiding the light
                        node, disabling this property will not hide the light's children.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Editor Only:</strong> If enabled, the light is only visible within the editor. It
                        will be automatically disabled in the running project.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Color:</strong> The light's color.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Energy:</strong> The light's intensity multiplier. Higher values result in a brighter light.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Blend Mode:</strong> The blending formula used for light computations. The default
                        <strong>Add</strong> is suited for most use cases. <strong>Subtract</strong> can be used for negative
                        lights, which are not physically accurate but can be used for special effects.
                        The <strong>Mix</strong> blend mode mixes the value of pixels corresponding to the light's
                        texture with the values of pixels under it by linear interpolation.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Range &gt; Z Min:</strong> The lowest Z index affected by the light.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Range &gt; Z Max:</strong> The highest Z index affected by the light.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Range &gt; Layer Min:</strong> The lowest visual layer affected by the light.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Range &gt; Layer Max:</strong> The highest visual layer affected by the light.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Range &gt; Item Cull Mask:</strong> Controls which nodes receive light from this node,
                        depending on the other nodes' enabled visual layers <strong>Occluder Light Mask</strong>.
                        This can be used to prevent certain objects from receiving light.</paragraph>
                </list_item>
            </bullet_list>
            <target refid="doc-2d-lights-and-shadows-setting-up-shadows"></target>
        </section>
        <section ids="setting-up-shadows doc-2d-lights-and-shadows-setting-up-shadows" names="setting\ up\ shadows doc_2d_lights_and_shadows_setting_up_shadows">
            <title>Setting up shadows</title>
            <paragraph>After enabling the <strong>Shadow &gt; Enabled</strong> property on a PointLight2D or
                DirectionalLight2D node, you will not see any visual difference initially. This
                is because no nodes in your scene have any <emphasis>occluders</emphasis> yet, which are used as a
                basis for shadow casting.</paragraph>
            <paragraph>For shadows to appear in the scene, LightOccluder2D nodes must be added to the
                scene. These nodes must also have occluder polygons that are designed to match
                the sprite's outline.</paragraph>
            <paragraph>Along with their polygon resource (which must be set to have any visual effect),
                LightOccluder2D nodes have 2 properties:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>SDF Collision:</strong> If enabled, the occluder will be part of a real-time
                        generated <emphasis>signed distance field</emphasis> that can be used in custom shaders. When not
                        using custom shaders that read from this SDF, enabling this makes no visual
                        difference and has no performance cost, so this is enabled by default for
                        convenience.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Occluder Light Mask:</strong> This is used in tandem with PointLight2D and
                        DirectionalLight2D's <strong>Shadow &gt; Item Cull Mask</strong> property to control which
                        objects cast shadows for each light. This can be used to prevent specific
                        objects from casting shadows.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>There are two ways to create light occluders:</paragraph>
            <section ids="automatically-generating-a-light-occluder" names="automatically\ generating\ a\ light\ occluder">
                <title>Automatically generating a light occluder</title>
                <paragraph>Occluders can be created automatically from Sprite2D nodes by selecting the
                    node, clicking the <strong>Sprite2D</strong> menu at the top of the 2D editor then choosing
                    <strong>Create LightOccluder2D Sibling</strong>.</paragraph>
                <paragraph>In the dialog that appears, an outline will surround your sprite's edges. If the
                    outline matches the sprite's edges closely, you can click <strong>OK</strong>. If the outline
                    is too far away from the sprite's edges (or is "eating" into the sprite's
                    edges), adjust <strong>Grow (pixels)</strong> and <strong>Shrink (pixels)</strong>, then click <strong>Update
                        Preview</strong>. Repeat this operation until you get satisfactory results.</paragraph>
            </section>
            <section ids="manually-drawing-a-light-occluder" names="manually\ drawing\ a\ light\ occluder">
                <title>Manually drawing a light occluder</title>
                <paragraph>Create a LightOccluder2D node, then select the node and click the "+" button at
                    the top of the 2D editor. When asked to create a polygon resource, answer
                    <strong>Yes</strong>. You can then start drawing an occluder polygon by clicking to create
                    new points. You can remove existing points by right-clicking them, and you can
                    create new points from the existing line by clicking on the line then dragging.</paragraph>
                <paragraph>The following properties can be adjusted on 2D lights that have shadows enabled:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Color:</strong> The color of shaded areas. By default, shaded areas are fully
                            black, but this can be changed for artistic purposes. The color's alpha
                            channel controls how much the shadow is tinted by the specified color.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Filter:</strong> The filter mode to use for shadows. The default <strong>None</strong> is the
                            fastest to render, and is well suited for games with a pixel art aesthetic
                            (due to its "blocky" visuals). If you want a soft shadow, use <strong>PCF5</strong>
                            instead. <strong>PCF13</strong> is even softer, but is the most demanding to render. PCF13
                            should only be used for a few lights at once due to its high rendering cost.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Filter Smooth:</strong> Controls how much softening is applied to shadows when
                            <strong>Filter</strong> is set to <strong>PCF5</strong> or <strong>PCF13</strong>. Higher values result in a softer
                            shadow, but may cause banding artifacts to be visible (especially with PCF5).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Item Cull Mask:</strong> Controls which LightOccluder2D nodes cast shadows,
                            depending on their respective <strong>Occluder Light Mask</strong> properties.</paragraph>
                    </list_item>
                </bullet_list>
                <note>
                    <paragraph><strong>Lighting and shadow resolution in pixel-art games</strong></paragraph>
                    <paragraph>The engine computes 2D lighting and shadows at the <strong>Viewport's pixel resolution</strong>,
                        not at the source texture's texel resolution. The appearance of lights and shadows
                        depends on your window or Viewport resolution, not on the resolution of individual
                        sprite textures.</paragraph>
                    <paragraph>If you create a pixel-art game and want pixelated or blocky lighting and shadows
                        that match your art style, <strong>Nearest</strong> texture filtering will <strong>not</strong> achieve
                        this effect. Nearest filtering affects only how the engine samples textures — it
                        does not change how the engine renders lighting and shadows.</paragraph>
                    <paragraph>To achieve pixelated lighting and shadows, use a custom shader to modify
                        <literal>LIGHT_VERTEX</literal> and <literal>SHADOW_VERTEX</literal> to snap light sampling to a pixel grid.
                        The following shader snaps lighting to a grid using the <literal>floor()</literal> function:</paragraph>
                    <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type canvas_item;

uniform float pixel_size = 4.0;

void fragment() {
    // Snap lighting and shadows to pixel grid.
    LIGHT_VERTEX.xy = floor(LIGHT_VERTEX.xy / pixel_size) * pixel_size;
    SHADOW_VERTEX = floor(SHADOW_VERTEX / pixel_size) * pixel_size;

    // Normal rendering.
    COLOR = texture(TEXTURE, UV);
}</literal_block>
                    <paragraph>This works by dividing the position by <literal>pixel_size</literal> to convert to grid space,
                        using <literal>floor()</literal> to round down to the nearest grid point, then multiplying back
                        to convert to screen space. The result forces the engine to sample lighting from
                        discrete grid positions, which creates the pixelated effect.</paragraph>
                    <paragraph>For more information on canvas item shaders, see <reference internal="True" refuri="../shaders/shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">CanvasItem shaders</inline></reference>.</paragraph>
                </note>
                <figure align="center" ids="id5">
                    <image alt="Hard shadows" candidates="{'*': 'tutorials/2d/img/2d_lights_and_shadows_hard_shadow.webp'}" original_uri="img/2d_lights_and_shadows_hard_shadow.webp" uri="tutorials/2d/img/2d_lights_and_shadows_hard_shadow.webp"></image>
                    <caption>Hard shadows</caption>
                </figure>
                <figure align="center" ids="id6">
                    <image alt="Soft shadows (PCF13, Filter Smooth 1.5)" candidates="{'*': 'tutorials/2d/img/2d_lights_and_shadows_soft_shadow.webp'}" original_uri="img/2d_lights_and_shadows_soft_shadow.webp" uri="tutorials/2d/img/2d_lights_and_shadows_soft_shadow.webp"></image>
                    <caption>Soft shadows (PCF13, Filter Smooth 1.5)</caption>
                </figure>
                <figure align="center" ids="id7">
                    <image alt="Soft shadows with streaking artifacts due to Filter Smooth being too high (PCF5, Filter Smooth 4)" candidates="{'*': 'tutorials/2d/img/2d_lights_and_shadows_soft_shadow_streaks.webp'}" original_uri="img/2d_lights_and_shadows_soft_shadow_streaks.webp" uri="tutorials/2d/img/2d_lights_and_shadows_soft_shadow_streaks.webp"></image>
                    <caption>Soft shadows with streaking artifacts due to Filter Smooth being too high (PCF5, Filter Smooth 4)</caption>
                </figure>
            </section>
        </section>
        <section ids="normal-and-specular-maps" names="normal\ and\ specular\ maps">
            <title>Normal and specular maps</title>
            <paragraph>Normal maps and specular maps can greatly enhance the sense of depth of your 2D
                lighting. Similar to how these work in 3D rendering, normal maps can help make
                lighting look less flat by varying its intensity depending on the direction of
                the surface receiving light (on a per-pixel basis). Specular maps further help
                improve visuals by making some of the light reflect back to the viewer.</paragraph>
            <paragraph>Both PointLight2D and DirectionalLight2D support normal mapping and specular
                mapping. Normal and specular maps can be assigned to any 2D element,
                including nodes that inherit from Node2D or Control.</paragraph>
            <paragraph>A normal map represents the direction in which each pixel is "pointing" towards.
                This information is then used by the engine to correctly apply lighting to 2D
                surfaces in a physically plausible way. Normal maps are typically created from
                hand-painted height maps, but they can also be automatically generated from
                other textures.</paragraph>
            <paragraph>A specular map defines how much each pixel should reflect light (and in which
                color, if the specular map contains color). Brighter values will result in a
                brighter reflection at that given spot on the texture. Specular maps are
                typically created with manual editing, using the diffuse texture as a base.</paragraph>
            <tip>
                <paragraph>If you don't have normal or specular maps for your sprites, you can generate
                    them using the free and open source <reference name="Laigter" refuri="https://azagaya.itch.io/laigter">Laigter</reference>
                    tool.</paragraph>
            </tip>
            <paragraph>To set up normal maps and/or specular maps on a 2D node, create a new
                CanvasTexture resource for the property that draws the node's texture. For
                example, on a Sprite2D:</paragraph>
            <figure align="center" ids="id8">
                <image alt="Creating a CanvasTexture resource for a Sprite2D node" candidates="{'*': 'tutorials/2d/img/2d_lights_and_shadows_create_canvastexture.webp'}" original_uri="img/2d_lights_and_shadows_create_canvastexture.webp" uri="tutorials/2d/img/2d_lights_and_shadows_create_canvastexture.webp"></image>
                <caption>Creating a CanvasTexture resource for a Sprite2D node</caption>
            </figure>
            <paragraph>Expand the newly created resource. You can find several properties you will need
                to adjust:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Diffuse &gt; Texture:</strong> The base color texture. In this property, load the
                        texture you're using for the sprite itself.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Normal Map &gt; Texture:</strong> The normal map texture. In this property, load a
                        normal map texture you've generated from a height map (see the tip above).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Specular &gt; Texture:</strong> The specular map texture, which controls the specular
                        intensity of each pixel on the diffuse texture. The specular map is usually
                        grayscale, but it can also contain color to multiply the color of reflections
                        accordingly. In this property, load a specular map texture you've created (see
                        the tip above).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Specular &gt; Color:</strong> The color multiplier for specular reflections.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Specular &gt; Shininess:</strong> The specular exponent to use for reflections. Lower
                        values will increase the brightness of reflections and make them more diffuse,
                        while higher values will make reflections more localized. High values are more
                        suited for wet-looking surfaces.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Texture &gt; Filter:</strong> Can be set to override the texture filtering mode,
                        regardless of what the node's property is set to (or the
                        <strong>Rendering &gt; Textures &gt; Canvas Textures &gt; Default Texture Filter</strong> project
                        setting).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Texture &gt; Repeat:</strong> Can be set to override the texture filtering mode,
                        regardless of what the node's property is set to (or the
                        <strong>Rendering &gt; Textures &gt; Canvas Textures &gt; Default Texture Repeat</strong> project
                        setting).</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>After enabling normal mapping, you may notice that your lights appear to be
                weaker. To resolve this, increase the <strong>Height</strong> property on your PointLight2D
                and DirectionalLight2D nodes. You may also want to increase the lights's
                <strong>Energy</strong> property slightly to get closer to how your lighting's intensity
                looked prior to enabling normal mapping.</paragraph>
        </section>
        <section ids="using-additive-sprites-as-a-faster-alternative-to-2d-lights" names="using\ additive\ sprites\ as\ a\ faster\ alternative\ to\ 2d\ lights">
            <title>Using additive sprites as a faster alternative to 2D lights</title>
            <paragraph>If you run into performance issues when using 2D lights, it may be worth
                replacing some of them with Sprite2D nodes that use additive blending. This is
                particularly suited for short-lived dynamic effects, such as bullets or explosions.</paragraph>
            <paragraph>Additive sprites are much faster to render, since they don't need to go through
                a separate rendering pipeline. Additionally, it is possible to use this approach
                with AnimatedSprite2D (or Sprite2D + AnimationPlayer), which allows for animated
                2D "lights" to be created.</paragraph>
            <paragraph>However, additive sprites have a few downsides compared to 2D lights:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The blending formula is inaccurate compared to "actual" 2D lighting. This is
                        usually not a problem in sufficiently lit areas, but this prevents additive
                        sprites from correctly lighting up areas that are fully dark.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Additive sprites cannot cast shadows, since they are not lights.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Additive sprites ignore normal and specular maps used on other sprites.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>To display a sprite with additive blending, create a Sprite2D node and assign a
                texture to it. In the inspector, scroll down to the <strong>CanvasItem &gt; Material</strong>
                section, unfold it and click the dropdown next to the <strong>Material</strong> property.
                Choose <strong>New CanvasItemMaterial</strong>, click the newly created material to edit it,
                then set <strong>Blend Mode</strong> to <strong>Add</strong>.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
