<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/2d/2d_movement.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-2d-movement"></target>
    <section ids="d-movement-overview doc-2d-movement" names="2d\ movement\ overview 2d\ 运动概述 doc_2d_movement">
        <title>2D 运动概述</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>每个初学者都问过“我该如何移动我的游戏角色呢？”根据你正在制作的游戏的风格，可能有特殊的需求，但一般来说，大多数 2D 游戏的运动都基于一组不太多的操作之上。</paragraph>
            <paragraph>在这些示例中，我们将使用 <reference internal="True" refuri="../../classes/class_characterbody2d#class-characterbody2d"><inline classes="std std-ref">CharacterBody2D</inline></reference>，但这些原则也适用于其他节点类型（如 Area2D、RigidBody2D）。</paragraph>
            <target refid="doc-2d-movement-setup"></target>
        </section>
        <section ids="setup doc-2d-movement-setup" names="setup 场景布置 doc_2d_movement_setup">
            <title>场景布置</title>
            <paragraph>以下每个示例都使用相同的场景布置。从带有 <literal>Sprite2D</literal> 和 <literal>CollisionShape2D</literal> 这两个子节点的 <literal>CharacterBody2D</literal> 开始。你可以将 Godot 图标（“icon.png”）用于 Sprite2D 的纹理，也可以使用你拥有的任何其他 2D 图像。</paragraph>
            <paragraph>打开<literal>项目 -&gt; 项目设置</literal>并选择“输入映射”选项卡。添加以下输入操作（相关详细信息请参阅 <reference internal="True" refuri="../inputs/inputevent#doc-inputevent"><inline classes="std std-ref">InputEvent</inline></reference>）：</paragraph>
            <image candidates="{'*': 'tutorials/2d/img/movement_inputs.webp'}" uri="tutorials/2d/img/movement_inputs.webp"></image>
        </section>
        <section ids="way-movement" names="8-way\ movement 八向移动">
            <title>八向移动</title>
            <paragraph>在这种情况下，你希望用户按下四个方向键（上/左/下/右或W / A / S / D）并沿所选方向移动。“8向移动” 意味着游戏角色可以通过同时按下两个键实现斜向移动。</paragraph>
            <image candidates="{'*': 'tutorials/2d/img/movement_8way.gif'}" uri="tutorials/2d/img/movement_8way.gif"></image>
            <paragraph>为角色体添加脚本，并添加以下代码：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

@export var speed = 400

func get_input():
    var input_direction = Input.get_vector("left", "right", "up", "down")
    velocity = input_direction * speed

func _physics_process(delta):
    get_input()
    move_and_slide()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Movement : CharacterBody2D
{
    [Export]
    public int Speed { get; set; } = 400;

    public void GetInput()
    {

        Vector2 inputDirection = Input.GetVector("left", "right", "up", "down");
        Velocity = inputDirection * Speed;
    }

    public override void _PhysicsProcess(double delta)
    {
        GetInput();
        MoveAndSlide();
    }
}</literal_block>
                </div>
            </container>
            <paragraph>在函数 <literal>get_input()</literal> 中，我们使用 <reference internal="True" refuri="../../classes/class_input#class-input"><inline classes="std std-ref">Input</inline></reference> 的 <literal>get_vector()</literal> 来检查四个按键事件，并返回一个方向向量的累加值。</paragraph>
            <paragraph>然后，我们可以将长度为 <literal>1</literal> 的方向矢量乘以所需的速度来设定速度。</paragraph>
            <tip>
                <paragraph>如果你之前从未接触过向量数学, 或者需要复习, 你可以在 <reference internal="True" refuri="../math/vector_math#doc-vector-math"><inline classes="std std-ref">向量数学</inline></reference> 看到Godot中向量用法的解释.</paragraph>
            </tip>
            <note>
                <paragraph>如果在你按下键时上面的代码不起任何作用, 请仔细检查你是否按照本教程的 <reference internal="True" refid="doc-2d-movement-setup"><inline classes="std std-ref">场景布置</inline></reference> 部分所描述的正确设置了输入操作.</paragraph>
            </note>
        </section>
        <section ids="rotation-movement" names="rotation\ +\ movement 旋转+移动">
            <title>旋转+移动</title>
            <paragraph>这种类型的运动有时被称为 "Asteroids式运动", 因为它类似于经典街机游戏Asteroids的工作方式. 按左/右旋转角色, 而按上/下使得角色在面向的方向上向前或向后.</paragraph>
            <image candidates="{'*': 'tutorials/2d/img/movement_rotate1.gif'}" uri="tutorials/2d/img/movement_rotate1.gif"></image>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

@export var speed = 400
@export var rotation_speed = 1.5

var rotation_direction = 0

func get_input():
    rotation_direction = Input.get_axis("left", "right")
    velocity = transform.x * Input.get_axis("down", "up") * speed

func _physics_process(delta):
    get_input()
    rotation += rotation_direction * rotation_speed * delta
    move_and_slide()</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Movement : CharacterBody2D
{
    [Export]
    public int Speed { get; set; } = 400;

    [Export]
    public float RotationSpeed { get; set; } = 1.5f;

    private float _rotationDirection;

    public void GetInput()
    {
        _rotationDirection = Input.GetAxis("left", "right");
        Velocity = Transform.X * Input.GetAxis("down", "up") * Speed;
    }

    public override void _PhysicsProcess(double delta)
    {
        GetInput();
        Rotation += _rotationDirection * RotationSpeed * (float)delta;
        MoveAndSlide();
    }
}</literal_block>
                </div>
            </container>
            <paragraph>这里我们添加了两个变量来跟踪我们的旋转方向和速度。旋转直接应用于主体的 <literal>rotation</literal> 属性。</paragraph>
            <paragraph>要设置速度，我们使用物体的 <literal>transform.x</literal> ，这是一个指向物体 “前进” 方向的矢量，然后乘以速度。</paragraph>
        </section>
        <section ids="rotation-movement-mouse" names="rotation\ +\ movement\ (mouse) 旋转+移动（鼠标）">
            <title>旋转+移动（鼠标）</title>
            <paragraph>这种运动方式是前一种运动方式的变体。这次，方向由鼠标位置而不是键盘设置。角色将始终“看向”鼠标指针。前进/后退输入保持不变。</paragraph>
            <image candidates="{'*': 'tutorials/2d/img/movement_rotate2.gif'}" uri="tutorials/2d/img/movement_rotate2.gif"></image>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

@export var speed = 400

func get_input():
    look_at(get_global_mouse_position())
    velocity = transform.x * Input.get_axis("down", "up") * speed

func _physics_process(delta):
    get_input()
    move_and_slide()</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Movement : CharacterBody2D
{
    [Export]
    public int Speed { get; set; } = 400;

    public void GetInput()
    {
        LookAt(GetGlobalMousePosition());
        Velocity = Transform.X * Input.GetAxis("down", "up") * Speed;
    }

    public override void _PhysicsProcess(double delta)
    {
        GetInput();
        MoveAndSlide();
    }
}</literal_block>
                </div>
            </container>
            <paragraph>这里我们用到 <reference internal="True" refuri="../../classes/class_node2d#class-node2d"><inline classes="std std-ref">Node2D</inline></reference> 中的 <literal>look_at()</literal> 方法，使玩家朝向鼠标的位置。如果没有此功能，可以通过如下设置角度以获得相同的效果：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">rotation = get_global_mouse_position().angle_to_point(position)</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var rotation = GetGlobalMousePosition().AngleToPoint(Position);</literal_block>
                </div>
            </container>
        </section>
        <section ids="click-and-move" names="click-and-move 点击并移动">
            <title>点击并移动</title>
            <paragraph>最后一个示例仅使用鼠标来控制角色. 单击屏幕将使游戏角色移动到目标位置.</paragraph>
            <image candidates="{'*': 'tutorials/2d/img/movement_click.gif'}" uri="tutorials/2d/img/movement_click.gif"></image>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

@export var speed = 400

var target = position

func _input(event):
    if event.is_action_pressed("click"):
        target = get_global_mouse_position()

func _physics_process(delta):
    velocity = position.direction_to(target) * speed
    # look_at(target)
    if position.distance_to(target) &gt; 10:
        move_and_slide()</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Movement : CharacterBody2D
{
    [Export]
    public int Speed { get; set; } = 400;

    private Vector2 _target;

    public override void _Input(InputEvent @event)
    {
        if (@event.IsActionPressed("click"))
        {
            _target = GetGlobalMousePosition();
        }
    }

    public override void _PhysicsProcess(double delta)
    {
        Velocity = Position.DirectionTo(_target) * Speed;
        // LookAt(_target);
        if (Position.DistanceTo(_target) &gt; 10)
        {
            MoveAndSlide();
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>注意我们在移动之前做的 <literal>distance_to()</literal> 检查. 如果没有这个检查, 物体在到达目标位置时会 "抖动", 因为它稍微移过该位置时就会试图向后移动, 只是每次移动步长都会有点远从而导致来回重复移动.</paragraph>
            <paragraph>如果你喜欢, 取消注释的 <literal>rotation</literal> 代码可以使物体转向其运动方向.</paragraph>
            <tip>
                <paragraph>该技术也可以用到“跟随”的游戏角色中。<literal>target</literal> 目标位置可以是任何你想移动到的对象的位置。</paragraph>
            </tip>
        </section>
        <section ids="summary" names="summary 总结">
            <title>总结</title>
            <paragraph>你可能觉得这些代码示例可以作为你自己的项目的一个有用的出发点. 请随意使用它们并试验它们, 看看你能做些什么.</paragraph>
            <paragraph>你可以在此处下载这个示例项目：<reference name="2d_movement_starter.zip" refuri="https://github.com/godotengine/godot-docs-project-starters/releases/download/latest-4.x/2d_movement_starter.zip">2d_movement_starter.zip</reference><target ids="d-movement-starter-zip" names="2d_movement_starter.zip" refuri="https://github.com/godotengine/godot-docs-project-starters/releases/download/latest-4.x/2d_movement_starter.zip"></target></paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
