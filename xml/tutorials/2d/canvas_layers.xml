<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/2d/canvas_layers.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-canvas-layers"></target>
    <section ids="canvas-layers doc-canvas-layers" names="canvas\ layers 画布层 doc_canvas_layers">
        <title>画布层</title>
        <section ids="viewport-and-canvas-items" names="viewport\ and\ canvas\ items viewport（视口）和\ canvas\ item（画布项）">
            <title>Viewport（视口）和 Canvas Item（画布项）</title>
            <paragraph><reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference> 是所有 2D 节点的基类，无论是 <reference internal="True" refuri="../../classes/class_node2d#class-node2d"><inline classes="std std-ref">Node2D</inline></reference> 等普通 2D 节点，还是 <reference internal="True" refuri="../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 控件节点。它们都继承自 <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference>。你可以把画布项组织成树。每个项目都会继承父节点的变换：父节点移动，子项也会移动。</paragraph>
            <paragraph>CanvasItem 节点和继承他们的节点都是 <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> 的直接或间接子节点，并将通过这个视口来显示。</paragraph>
            <paragraph>Viewport 的 <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-canvas-transform"><inline classes="std std-ref">Viewport.canvas_transform</inline></reference> 属性能够对它所包含的 CanvasItem 层级结构施加一个自定义的 <reference internal="True" refuri="../../classes/class_transform2d#class-transform2d"><inline classes="std std-ref">Transform2D</inline></reference> 变换。<reference internal="True" refuri="../../classes/class_camera2d#class-camera2d"><inline classes="std std-ref">Camera2D</inline></reference> 等节点的工作原理就是修改这个变换。</paragraph>
            <paragraph>像滚动这样的效果最好是通过操纵画布的变换（transform）属性来实现。这种方法比移动根画布项和整个场景更有效。</paragraph>
            <paragraph>通常情况下，我们并不希望游戏或应用程序中的<emphasis>所有东西</emphasis>都受到画布变换的约束。比如：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>视差背景</strong>：比场景其他部分移动得慢的背景。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>UI</strong>：想想看，用户界面（UI）或平视显示系统（HUD）叠加在我们游戏世界的视图上。我们希望生命计数器、分数显示和其他元素能够保持其屏幕位置，即使我们在游戏世界的视角发生变化。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>转场</strong>：我们应该希望用于转场的效果（淡入淡出、混合）也保持在固定的位置。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>如何在单个场景树中解决这些问题？</paragraph>
        </section>
        <section ids="canvaslayers" names="canvaslayers canvaslayer">
            <title>CanvasLayer</title>
            <paragraph>答案是画布层 <reference internal="True" refuri="../../classes/class_canvaslayer#class-canvaslayer"><inline classes="std std-ref">CanvasLayer</inline></reference>，它是一个节点，可以为所有子代和孙代添加一个单独的 2D 渲染层。Viewport 的子节点默认在图层“0”处绘制，而 CanvasLayer 将在任何数字层处绘制。数字较大的图层将绘制在数字较小的图层之上。CanvasLayer 也有自己的变换，不受其他层的影响。这使得当我们对游戏世界的观察发生变化时，UI 可以固定在屏幕空间中。</paragraph>
            <paragraph>一个例子是创建视差背景（Parallax Background）。这可以通过层为“-1”的 CanvasLayer 完成。带有分数、生命计数器和暂停按钮的屏幕也可以创建在编号为“1”的层中。</paragraph>
            <paragraph>下面是它的图示：</paragraph>
            <image candidates="{'*': 'tutorials/2d/img/canvaslayers.png'}" uri="tutorials/2d/img/canvaslayers.png"></image>
            <paragraph>CanvasLayer 独立于树顺序, 它们仅依赖于它们的层数, 因此可以只在需要时让它们实例化.</paragraph>
            <note>
                <paragraph>控制节点的绘制顺序并不一定要用 CanvasLayer。确保节点被正确绘制在“前面”或“后面”的标准方法是调整场景面板中节点的顺序。也许违反直觉，但在视口中，场景面板中较上面的节点会被画在较下面的节点的<emphasis>后面</emphasis>。2D 节点的 <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-property-z-index"><inline classes="std std-ref">CanvasItem.z_index</inline></reference> 属性也能够控制绘图顺序。</paragraph>
            </note>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
