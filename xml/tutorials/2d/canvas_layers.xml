<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/2d/canvas_layers.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-canvas-layers"></target>
    <section ids="canvas-layers doc-canvas-layers" names="canvas\ layers doc_canvas_layers">
        <title>Canvas layers</title>
        <section ids="viewport-and-canvas-items" names="viewport\ and\ canvas\ items">
            <title>Viewport and Canvas items</title>
            <paragraph><reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference> is the base for all 2D nodes, be it regular
                2D nodes, such as <reference internal="True" refuri="../../classes/class_node2d#class-node2d"><inline classes="std std-ref">Node2D</inline></reference>, or <reference internal="True" refuri="../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference>.
                Both inherit from <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference>.
                You can arrange canvas items in trees. Each item will inherit its parent's
                transform: when the parent moves, its children move too.</paragraph>
            <paragraph>CanvasItem nodes, and nodes inheriting from them, are direct or indirect children of a
                <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>, that displays them.</paragraph>
            <paragraph>The Viewport's property
                <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-canvas-transform"><inline classes="std std-ref">Viewport.canvas_transform</inline></reference>,
                allows to apply a custom <reference internal="True" refuri="../../classes/class_transform2d#class-transform2d"><inline classes="std std-ref">Transform2D</inline></reference>
                transform to the CanvasItem hierarchy it contains. Nodes such as
                <reference internal="True" refuri="../../classes/class_camera2d#class-camera2d"><inline classes="std std-ref">Camera2D</inline></reference> work by changing that transform.</paragraph>
            <paragraph>To achieve effects like scrolling, manipulating the canvas transform property is
                more efficient than moving the root canvas item and the entire scene with it.</paragraph>
            <paragraph>Usually though, we don't want <emphasis>everything</emphasis> in the game or app to be subject to the canvas
                transform. For example:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Parallax Backgrounds</strong>: Backgrounds that move slower than the rest
                        of the stage.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>UI</strong>: Think of a user interface (UI) or head-up display (HUD) superimposed on our view of the game world. We want a life counter, score display and other elements to retain their screen positions even when our view of the game world changes.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Transitions</strong>: We may want visual effects used for transitions (fades, blends) to remain at a fixed screen location.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>How to solve these problems in a single scene tree?</paragraph>
        </section>
        <section ids="canvaslayers" names="canvaslayers">
            <title>CanvasLayers</title>
            <paragraph>The answer is <reference internal="True" refuri="../../classes/class_canvaslayer#class-canvaslayer"><inline classes="std std-ref">CanvasLayer</inline></reference>,
                which is a node that adds a separate 2D rendering layer for all its
                children and grand-children. Viewport children will draw by default at
                layer "0", while a CanvasLayer will draw at any numeric layer. Layers
                with a greater number will be drawn above those with a smaller number.
                CanvasLayers also have their own transform and do not depend on the
                transform of other layers. This allows the UI to be fixed in screen-space
                while our view on the game world changes.</paragraph>
            <paragraph>An example of this is creating a parallax background. This can be done
                with a CanvasLayer at layer "-1". The screen with the points, life
                counter and pause button can also be created at layer "1".</paragraph>
            <paragraph>Here's a diagram of how it looks:</paragraph>
            <image candidates="{'*': 'tutorials/2d/img/canvaslayers.png'}" original_uri="img/canvaslayers.png" uri="tutorials/2d/img/canvaslayers.png"></image>
            <paragraph>CanvasLayers are independent of tree order, and they only depend on
                their layer number, so they can be instantiated when needed.</paragraph>
            <note>
                <paragraph>CanvasLayers aren't necessary to control the drawing order of nodes.
                    The standard way to ensuring that a node is correctly drawn 'in front' or 'behind' others is to manipulate the
                    order of the nodes in the scene panel. Perhaps counterintuitively, the topmost nodes in the scene panel are drawn
                    on <emphasis>behind</emphasis> lower ones in the viewport. 2D nodes also have the <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-property-z-index"><inline classes="std std-ref">CanvasItem.z_index</inline></reference>
                    property for controlling their drawing order.</paragraph>
            </note>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
