<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/io/background_loading.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-background-loading"></target>
    <section ids="background-loading doc-background-loading" names="background\ loading 后台加载 doc_background_loading">
        <title>后台加载</title>
        <paragraph>Commonly, games need to load resources asynchronously.
            When switching the main scene of your game (e.g. going to a new
            level), you might want to show a loading screen with some indication
            that progress is being made, or you may want to load additional resources
            during gameplay.</paragraph>
        <paragraph>The standard load method
            (<reference internal="True" refuri="../../classes/class_resourceloader#class-resourceloader-method-load"><inline classes="std std-ref">ResourceLoader.load</inline></reference> or GDScript's simpler
            <reference internal="True" refuri="../../classes/class_@gdscript#class-gdscript-method-load"><inline classes="std std-ref">load</inline></reference>) blocks your
            thread, making your game appear unresponsive while the resource is being loaded.</paragraph>
        <paragraph>One way around this is using <literal>ResourceLoader</literal> to load resources asynchronously
            in background threads.</paragraph>
        <section ids="using-resourceloader" names="using\ resourceloader 使用\ resourceloader">
            <title>使用 ResourceLoader</title>
            <paragraph>Generally, you queue requests to load resources for a path using
                <reference internal="True" refuri="../../classes/class_resourceloader#class-resourceloader-method-load-threaded-request"><inline classes="std std-ref">ResourceLoader.load_threaded_request</inline></reference>,
                which will then be loaded in threads in the background.</paragraph>
            <paragraph>You can check the status with
                <reference internal="True" refuri="../../classes/class_resourceloader#class-resourceloader-method-load-threaded-get-status"><inline classes="std std-ref">ResourceLoader.load_threaded_get_status</inline></reference>.
                Progress can be obtained by passing an array variable via progress which will return
                a one element array containing the percentage.</paragraph>
            <paragraph>Finally, you retrieve loaded resources by calling
                <reference internal="True" refuri="../../classes/class_resourceloader#class-resourceloader-method-load-threaded-get"><inline classes="std std-ref">ResourceLoader.load_threaded_get</inline></reference>.</paragraph>
            <paragraph>Once you call <literal>load_threaded_get()</literal>, either the resource finished loading in
                the background and will be returned instantly or the load will block at this point like
                <literal>load()</literal> would. If you want to guarantee this does not block,
                you either need to ensure there is enough time between requesting the load and
                retrieving the resource or you need to check the status manually.</paragraph>
        </section>
        <section ids="example" names="example 示例">
            <title>示例</title>
            <paragraph>This example demonstrates how to load a scene in the background.
                We will have a button spawn a enemy when pressed.
                The enemy will be <literal>Enemy.tscn</literal> which we will load on <literal>_ready</literal> and instantiate when pressed.
                The path will be <literal>"Enemy.tscn"</literal> which is located at <literal>res://Enemy.tscn</literal>.</paragraph>
            <paragraph>First, we will start a request to load the resource and connect the button:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">const ENEMY_SCENE_PATH : String = "Enemy.tscn"

func _ready():
    ResourceLoader.load_threaded_request(ENEMY_SCENE_PATH)
    self.pressed.connect(_on_button_pressed)</literal_block>
            <paragraph>Now <literal>_on_button_pressed</literal> will be called when the button is pressed.
                This method will be used to spawn an enemy.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_button_pressed(): # Button was pressed
    # Obtain the resource now that we need it
    var enemy_scene = ResourceLoader.load_threaded_get(ENEMY_SCENE_PATH)
    # Instantiate the enemy scene and add it to the current scene
    var enemy = enemy_scene.instantiate()
    add_child(enemy)</literal_block>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
