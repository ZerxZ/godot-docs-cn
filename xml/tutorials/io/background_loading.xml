<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/io/background_loading.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-background-loading"></target>
    <section ids="background-loading doc-background-loading" names="background\ loading doc_background_loading">
        <title>Background loading</title>
        <paragraph>Commonly, games need to load resources asynchronously.
            When switching the main scene of your game (e.g. going to a new
            level), you might want to show a loading screen with some indication
            that progress is being made, or you may want to load additional resources
            during gameplay.</paragraph>
        <paragraph>The standard load method
            (<reference internal="True" refuri="../../classes/class_resourceloader#class-resourceloader-method-load"><inline classes="std std-ref">ResourceLoader.load</inline></reference> or GDScript's simpler
            <reference internal="True" refuri="../../classes/class_@gdscript#class-gdscript-method-load"><inline classes="std std-ref">load</inline></reference>) blocks your
            thread, making your game appear unresponsive while the resource is being loaded.</paragraph>
        <paragraph>One way around this is using <literal>ResourceLoader</literal> to load resources asynchronously
            in background threads.</paragraph>
        <section ids="using-resourceloader" names="using\ resourceloader">
            <title>Using ResourceLoader</title>
            <paragraph>Generally, you queue requests to load resources for a path using
                <reference internal="True" refuri="../../classes/class_resourceloader#class-resourceloader-method-load-threaded-request"><inline classes="std std-ref">ResourceLoader.load_threaded_request</inline></reference>,
                which will then be loaded in threads in the background.</paragraph>
            <paragraph>You can check the status with
                <reference internal="True" refuri="../../classes/class_resourceloader#class-resourceloader-method-load-threaded-get-status"><inline classes="std std-ref">ResourceLoader.load_threaded_get_status</inline></reference>.
                Progress can be obtained by passing an array variable via progress which will return
                a one element array containing the percentage.</paragraph>
            <paragraph>Finally, you retrieve loaded resources by calling
                <reference internal="True" refuri="../../classes/class_resourceloader#class-resourceloader-method-load-threaded-get"><inline classes="std std-ref">ResourceLoader.load_threaded_get</inline></reference>.</paragraph>
            <paragraph>Once you call <literal>load_threaded_get()</literal>, either the resource finished loading in
                the background and will be returned instantly or the load will block at this point like
                <literal>load()</literal> would. If you want to guarantee this does not block,
                you either need to ensure there is enough time between requesting the load and
                retrieving the resource or you need to check the status manually.</paragraph>
        </section>
        <section ids="example" names="example">
            <title>Example</title>
            <paragraph>This example demonstrates how to load a scene in the background.
                We will have a button spawn an enemy when pressed.
                The enemy will be <literal>Enemy.tscn</literal> which we will load on <literal>_ready</literal> and instantiate when pressed.
                The path will be <literal>"Enemy.tscn"</literal> which is located at <literal>res://Enemy.tscn</literal>.</paragraph>
            <paragraph>First, we will start a request to load the resource and connect the button:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">const ENEMY_SCENE_PATH : String = "Enemy.tscn"

func _ready():
    ResourceLoader.load_threaded_request(ENEMY_SCENE_PATH)
    self.pressed.connect(_on_button_pressed)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyButton : Button
{
    private const string EnemyScenePath = "Enemy.tscn";

    public override void _Ready()
    {
        ResourceLoader.LoadThreadedRequest(EnemyScenePath);
        Pressed += OnButtonPressed;
    }
}</literal_block>
                </div>
            </container>
            <paragraph>Now <literal>_on_button_pressed</literal> will be called when the button is pressed.
                This method will be used to spawn an enemy.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_button_pressed(): # Button was pressed.
    # Obtain the resource now that we need it.
    var enemy_scene = ResourceLoader.load_threaded_get(ENEMY_SCENE_PATH)
    # Instantiate the enemy scene and add it to the current scene.
    var enemy = enemy_scene.instantiate()
    add_child(enemy)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private void OnButtonPressed() // Button was pressed.
{
    // Obtain the resource now that we need it.
    var enemyScene = (PackedScene)ResourceLoader.LoadThreadedGet(EnemyScenePath);
    // Instantiate the enemy scene and add it to the current scene.
    var enemy = enemyScene.Instantiate();
    AddChild(enemy);
}</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
