<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/io/runtime_file_loading_and_saving.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-runtime-loading-and-saving"></target>
    <section ids="runtime-file-loading-and-saving doc-runtime-loading-and-saving" names="runtime\ file\ loading\ and\ saving 运行时文件加载和保存 doc_runtime_loading_and_saving">
        <title>运行时文件加载和保存</title>
        <seealso>
            <paragraph>更多关于游戏进度的保存和读取的信息见 <reference internal="True" refuri="saving_games#doc-saving-games"><inline classes="std std-ref">保存游戏</inline></reference>。</paragraph>
        </seealso>
        <paragraph>有时，当你希望玩家能够在项目中加载用户生成的内容时，：ref:<title_reference>exporting packs, patches, and mods &lt;doc_exporting_pcks&gt;</title_reference> 并不理想。它要求用户通过Godot编辑器生成PCK或ZIP文件，其中包含Godot导入的资源。</paragraph>
        <paragraph>运行时文件加载和保存的示例用例包括：</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>加载为游戏设计的纹理包。</paragraph>
            </list_item>
            <list_item>
                <paragraph>加载用户提供的音轨，在游戏内的电台中播放。</paragraph>
            </list_item>
            <list_item>
                <paragraph>加载自定义关卡和 3D 模型，可以使用能够导出 glTF 的任意 3D DCC 设计（包括 Godot 在运行时保存的 glTF 场景）。</paragraph>
            </list_item>
            <list_item>
                <paragraph>为菜单和 HUD 使用用户提供的字体。</paragraph>
            </list_item>
            <list_item>
                <paragraph>Saving/loading 一种文件格式，该文件格式可以包含多个文件，但仍然可以被其他应用程序轻松读取(ZIP)。</paragraph>
            </list_item>
            <list_item>
                <paragraph>Loading 由另一个游戏或程序创建的文件，甚至是来自另一个非Godot游戏的游戏数据文件。</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>运行时文件加载可以和 <reference internal="True" refuri="../networking/http_request_class#doc-http-request-class"><inline classes="std std-ref">HTTP 请求</inline></reference>结合起来，直接加载互联网上的资源。</paragraph>
        <warning>
            <paragraph><strong>请勿</strong>用这种运行时加载的方法来加载属于项目本身的资源，这种做法的效率较低，无法利用 Godot 的资源处理功能（例如翻译重定向）。详见 <reference internal="True" refuri="../assets_pipeline/import_process#doc-import-process"><inline classes="std std-ref">导入流程</inline></reference>。</paragraph>
        </warning>
        <seealso>
            <paragraph>You can see how saving and loading works in action using the
                <reference name="Run-time File Saving and Loading (Serialization) demo project" refuri="https://github.com/godotengine/godot-demo-projects/blob/master/loading/runtime_save_load">Run-time File Saving and Loading (Serialization) demo project</reference>.</paragraph>
        </seealso>
        <section ids="plain-text-and-binary-files" names="plain\ text\ and\ binary\ files 纯文本文件和二进制文件">
            <title>纯文本文件和二进制文件</title>
            <paragraph>Godot 的 <reference internal="True" refuri="../../classes/class_fileaccess#class-fileaccess"><inline classes="std std-ref">FileAccess</inline></reference> 类提供了读写文件系统中文件的方法：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"> func save_file(content):
    var file = FileAccess.open("/path/to/file.txt", FileAccess.WRITE)
    file.store_string(content)

func load_file():
    var file = FileAccess.open("/path/to/file.txt", FileAccess.READ)
    var content = file.get_as_text()
    return content</literal_block>
            <paragraph>为了处理自定义二进制格式（例如加载 Godot 不支持的文件格式），<inline classes="xref std std-ref">class_FileAccess`提供了几种读写整数、浮点值、字符串等数据类型的方法。这些 FileAccess 方法的名称以 ``get_`</inline> 和 <literal>store_</literal> 开头。</paragraph>
            <paragraph>If you need more control over reading binary files or need to read binary
                streams that are not part of a file, <reference internal="True" refuri="../../classes/class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> provides
                several helper methods to decode/encode series of bytes to integers, floats,
                strings and more. These PackedByteArray methods have names that start with
                <literal>decode_</literal> and <literal>encode_</literal>. See also <reference internal="True" refuri="binary_serialization_api#doc-binary-serialization-api"><inline classes="std std-ref">二进制序列化 API</inline></reference>.</paragraph>
            <target refid="doc-runtime-file-loading-and-saving-images"></target>
        </section>
        <section ids="images doc-runtime-file-loading-and-saving-images" names="images 图像 doc_runtime_file_loading_and_saving_images">
            <title>图像</title>
            <paragraph>Image's <reference internal="True" refuri="../../classes/class_image#class-image-method-load-from-file"><inline classes="std std-ref">Image.load_from_file</inline></reference> static method
                handles everything, from format detection based on file extension to reading the
                file from disk.</paragraph>
            <paragraph>If you need error handling or more control (such as changing the scale an SVG is
                loaded at), use one of the following methods depending on the file format:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-jpg-from-buffer"><inline classes="std std-ref">Image.load_jpg_from_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-ktx-from-buffer"><inline classes="std std-ref">Image.load_ktx_from_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-png-from-buffer"><inline classes="std std-ref">Image.load_png_from_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-svg-from-buffer"><inline classes="std std-ref">Image.load_svg_from_buffer</inline></reference> 或 <reference internal="True" refuri="../../classes/class_image#class-image-method-load-svg-from-string"><inline classes="std std-ref">Image.load_svg_from_string</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-tga-from-buffer"><inline classes="std std-ref">Image.load_tga_from_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-webp-from-buffer"><inline classes="std std-ref">Image.load_webp_from_buffer</inline></reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Godot 还可以在运行时使用以下方法保存几种图像格式：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-save-png"><inline classes="std std-ref">Image.save_png</inline></reference> 或 <reference internal="True" refuri="../../classes/class_image#class-image-method-save-png-to-buffer"><inline classes="std std-ref">Image.save_png_to_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-save-webp"><inline classes="std std-ref">Image.save_webp</inline></reference> 或 <reference internal="True" refuri="../../classes/class_image#class-image-method-save-webp-to-buffer"><inline classes="std std-ref">Image.save_webp_to_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-save-jpg"><inline classes="std std-ref">Image.save_jpg</inline></reference> 或 <reference internal="True" refuri="../../classes/class_image#class-image-method-save-jpg-to-buffer"><inline classes="std std-ref">Image.save_jpg_to_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-save-exr"><inline classes="std std-ref">Image.save_exr</inline></reference> 或 <reference internal="True" refuri="../../classes/class_image#class-image-method-save-exr-to-buffer"><inline classes="std std-ref">Image.save_exr_to_buffer</inline></reference> <emphasis>（仅在编辑器版本中可用，无法在导出后的项目中使用）</emphasis></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>那些有着 <literal>to_buffer</literal> 前缀的方法将图片保存至 PackedByteArray 中，而不是文件系统。这对于通过网络发送图像或将图像发送到 ZIP 压缩包 中非常有用，而无需将其写入文件系统。它可以通过降低 I/O 利用率来提高性能。</paragraph>
            <note>
                <paragraph>如果在3D曲面上显示加载的图像，请确保调用：ref:<title_reference>image.generate_mipmaps&lt;class_image_method_generate_mip maps&gt;</title_reference> ，以便在远处观察时纹理看起来不会有颗粒感。在2D中，当遵循以下说明时，这也很有用：ref:<title_reference>reducing aliasing when downsampling &lt;doc_multiple_resolutions_reducing_aliasing_on_downsampling&gt;</title_reference> 。</paragraph>
            </note>
            <paragraph>加载图像并将其显示在:ref:<title_reference>class_TextureRect</title_reference> 节点中的示例(需要转换为:ref:<title_reference>class_ImageTexture</title_reference>):</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Load an image of any format supported by Godot from the filesystem.
var image = Image.load_from_file(path)
# Optionally, generate mipmaps if displaying the texture on a 3D surface
# so that the texture doesn't look grainy when viewed at a distance.
#image.generate_mipmaps()
$TextureRect.texture = ImageTexture.create_from_image(image)

# Save the loaded Image to a PNG image.
image.save_png("/path/to/file.png")

# Save the converted ImageTexture to a PNG image.
$TextureRect.texture.get_image().save_png("/path/to/file.png")</literal_block>
            <target refid="doc-runtime-file-loading-and-saving-audio-video-files"></target>
        </section>
        <section ids="audio-video-files doc-runtime-file-loading-and-saving-audio-video-files" names="audio/video\ files 音视频文件 doc_runtime_file_loading_and_saving_audio_video_files">
            <title>音视频文件</title>
            <paragraph>Godot支持在运行时加载Ogg Vorbis音频。请注意，并非*all* 扩展名为 <literal>.ogg</literal> 的文件都可以是ogg-Vorbis文件。有些可能是Ogg Theora视频，或者在Ogg容器中包含Opus音频。这些文件在Godot中将 <strong>not</strong> 作为音频文件正确加载。</paragraph>
            <paragraph>通过 <reference internal="True" refuri="../../classes/class_audiostreamplayer#class-audiostreamplayer"><inline classes="std std-ref">AudioStreamPlayer</inline></reference> 节点加载 Ogg Vorbis 音频文件的示例：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">$AudioStreamPlayer.stream = AudioStreamOggVorbis.load_from_file(path)</literal_block>
            <paragraph>通过 <reference internal="True" refuri="../../classes/class_videostreamplayer#class-videostreamplayer"><inline classes="std std-ref">VideoStreamPlayer</inline></reference> 节点加载 Ogg Theora 视频文件的示例：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var video_stream_theora = VideoStreamTheora.new()
# File extension is ignored, so it is possible to load Ogg Theora videos
# that have an `.ogg` extension this way.
video_stream_theora.file = "/path/to/file.ogv"
$VideoStreamPlayer.stream = video_stream_theora

# VideoStreamPlayer's Autoplay property won't work if the stream is empty
# before this property is set, so call `play()` after setting `stream`.
$VideoStreamPlayer.play()</literal_block>
            <note>
                <paragraph>Godot还不支持MP3或WAV文件的运行时加载。在实现之前，使用脚本实现运行时WAV加载是可行的，因为：ref:<title_reference>class_AudioStreamWAV</title_reference> 的`data`属性风险脚本。</paragraph>
                <paragraph>仍然可以使用: ref:<title_reference>AudioStreamWAV.save_to_wav &lt;class_AudioStreamWAV_method_save_to_wav&gt;</title_reference> ，这对于按程序生成的音频或麦克风录音非常有用。</paragraph>
            </note>
            <target refid="doc-runtime-file-loading-and-saving-3d-scenes"></target>
        </section>
        <section ids="d-scenes doc-runtime-file-loading-and-saving-3d-scenes" names="3d\ scenes 3d\ 场景 doc_runtime_file_loading_and_saving_3d_scenes">
            <title>3D 场景</title>
            <paragraph>Godot在编辑器和导出项目中都对glTF 2.0提供了一流的支持。同时使用：ref:<title_reference>class_gltfdocument</title_reference> 和ref:<title_reference>class_gltfstate</title_reference> ，Godot可以以文本 (<literal>.gltf</literal>) 和二进制 (<literal>.glb</literal>)格式加载和保存导出项目中的glTF文件。二进制格式应该是首选，因为它写得更快、更小，但文本格式更容易调试。</paragraph>
            <paragraph>加载glTF场景并将其根节点附加到场景的示例：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Load an existing glTF scene.
# GLTFState is used by GLTFDocument to store the loaded scene's state.
# GLTFDocument is the class that handles actually loading glTF data into a Godot node tree,
# which means it supports glTF features such as lights and cameras.
var gltf_document_load = GLTFDocument.new()
var gltf_state_load = GLTFState.new()
var error = gltf_document_load.append_from_file("/path/to/file.gltf", gltf_state_load)
if error == OK:
    var gltf_scene_root_node = gltf_document_load.generate_scene(gltf_state_load)
    add_child(gltf_scene_root_node)
else:
    show_error("Couldn't load glTF scene (error code: %s)." % error_string(error))

# Save a new glTF scene.
var gltf_document_save := GLTFDocument.new()
var gltf_state_save := GLTFState.new()
gltf_document_save.append_from_scene(gltf_scene_root_node, gltf_state_save)
# The file extension in the output `path` (`.gltf` or `.glb`) determines
# whether the output uses text or binary format.
# `GLTFDocument.generate_buffer()` is also available for saving to memory.
gltf_document_save.write_to_filesystem(gltf_state_save, path)</literal_block>
            <note>
                <paragraph>加载glTF场景时，必须设置*基本路径*，以便可以正确加载纹理等外部资源。从文件加载时，基本路径会自动设置为包含该文件的文件夹。从缓冲区加载时，必须手动设置此基本路径，因为Godot无法推断此路径。</paragraph>
                <paragraph>若要设置基本路径，请在你的GLTFState实例上设置:ref:<title_reference>GLTFState.base_path &lt;class_GLTFState_property_base_path&gt;</title_reference> ，然后*调用* :ref:` GLTFDocument.append_from_buffer&lt;class_GLTCDocument_method_append_from _buffer&gt;` 或 <reference internal="True" refuri="../../classes/class_gltfdocument#class-gltfdocument-method-append-from-file"><inline classes="std std-ref">GLTFDocument.append_from_file</inline></reference>。</paragraph>
            </note>
            <target refid="doc-runtime-file-loading-and-saving-fonts"></target>
        </section>
        <section ids="fonts doc-runtime-file-loading-and-saving-fonts" names="fonts 字体 doc_runtime_file_loading_and_saving_fonts">
            <title>字体</title>
            <paragraph><reference internal="True" refuri="../../classes/class_fontfile#class-fontfile-method-load-bitmap-font"><inline classes="std std-ref">FontFile.load_dynamic_font</inline></reference> 支持以下字体文件格式：TTF、OTF、WOFF、WOFF2、PFB、PFM</paragraph>
            <paragraph>另一方面，<reference internal="True" refuri="../../classes/class_fontfile#class-fontfile-method-load-bitmap-font"><inline classes="std std-ref">FontFile.load_bitmap_font</inline></reference> 支持`BMFont&lt;<reference refuri="https://www.angelcode.com/products/bmfont/">https://www.angelcode.com/products/bmfont/</reference>&gt;`__ format (<literal>.fnt</literal> or <literal>.font</literal>)。</paragraph>
            <paragraph>此外，可以使用Godot对 <reference internal="True" refuri="../ui/gui_using_fonts#doc-using-fonts-system-fonts"><inline classes="std std-ref">系统字体</inline></reference> 的支持加载系统上安装的任何字体。</paragraph>
            <paragraph>根据文件扩展名自动加载字体文件，然后将其作为主题覆盖添加到 <reference internal="True" refuri="../../classes/class_label#class-label"><inline classes="std std-ref">Label</inline></reference> 节点的示例：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var path = "/path/to/font.ttf"
var path_lower = path.to_lower()
var font_file = FontFile.new()
if (
        path_lower.ends_with(".ttf")
        or path_lower.ends_with(".otf")
        or path_lower.ends_with(".woff")
        or path_lower.ends_with(".woff2")
        or path_lower.ends_with(".pfb")
        or path_lower.ends_with(".pfm")
):
    font_file.load_dynamic_font(path)
elif path_lower.ends_with(".fnt") or path_lower.ends_with(".font"):
    font_file.load_bitmap_font(path)
else:
    push_error("Invalid font file format.")

if not font_file.data.is_empty():
    # If font was loaded successfully, add it as a theme override.
    $Label.add_theme_font_override("font", font_file)</literal_block>
        </section>
        <section ids="zip-archives" names="zip\ archives zip\ 压缩包">
            <title>ZIP 压缩包</title>
            <paragraph>Godot支持使用 <reference internal="True" refuri="../../classes/class_zipreader#class-zipreader"><inline classes="std std-ref">ZIPReader</inline></reference> 和 <reference internal="True" refuri="../../classes/class_zippacker#class-zippacker"><inline classes="std std-ref">ZIPPacker</inline></reference> 类读取和写入ZIP档案。这支持任何ZIP文件，包括Godot的 "Export PCK/ZIP"功能生成的文件（尽管这些文件将包含导入的Godot资源，而不是原始项目文件）。</paragraph>
            <note>
                <paragraph>使用 <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-method-load-resource-pack"><inline classes="std std-ref">ProjectSettings.load_resource_pack</inline></reference> 将Godot导出的PCK或ZIP文件加载为 <reference internal="True" refuri="../export/exporting_pcks#doc-exporting-pcks"><inline classes="std std-ref">additional data packs</inline></reference>。DLC更喜欢这种方法，因为它可以无缝地与其他数据包（虚拟文件系统）交互。</paragraph>
            </note>
            <paragraph>这种ZIP档案支持可以与运行时图像、3D场景和音频加载相结合，提供无缝的改装体验，而无需用户通过Godot编辑器生成PCK/ZIP文件。</paragraph>
            <paragraph>示例列出 <reference internal="True" refuri="../../classes/class_itemlist#class-itemlist"><inline classes="std std-ref">ItemList</inline></reference> 节点中ZIP存档中的文件，然后将从中读取的内容写入新的ZIP存档（本质上是复制存档）：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Load an existing ZIP archive.
var zip_reader = ZIPReader.new()
zip_reader.open(path)
var files = zip_reader.get_files()
# The list of files isn't sorted by default. Sort it for more consistent processing.
files.sort()
for file in files:
    $ItemList.add_item(file, null)
    # Make folders disabled in the list.
    $ItemList.set_item_disabled(-1, file.ends_with("/"))

# Save a new ZIP archive.
var zip_packer = ZIPPacker.new()
var error = zip_packer.open(path)
if error != OK:
    push_error("Couldn't open path for saving ZIP archive (error code: %s)." % error_string(error))
    return

# Reuse the above ZIPReader instance to read files from an existing ZIP archive.
for file in zip_reader.get_files():
    zip_packer.start_file(file)
    zip_packer.write_file(zip_reader.read_file(file))
    zip_packer.close_file()

zip_packer.close()</literal_block>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
