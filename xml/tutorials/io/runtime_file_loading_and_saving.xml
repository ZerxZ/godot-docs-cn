<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/io/runtime_file_loading_and_saving.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-runtime-loading-and-saving"></target>
    <section ids="runtime-file-loading-and-saving doc-runtime-loading-and-saving" names="runtime\ file\ loading\ and\ saving doc_runtime_loading_and_saving">
        <title>Runtime file loading and saving</title>
        <seealso>
            <paragraph>See <reference internal="True" refuri="saving_games#doc-saving-games"><inline classes="std std-ref">Saving games</inline></reference> for information on saving and loading game progression.</paragraph>
        </seealso>
        <paragraph>Sometimes, <reference internal="True" refuri="../export/exporting_pcks#doc-exporting-pcks"><inline classes="std std-ref">exporting packs, patches, and mods</inline></reference> is not
            ideal when you want players to be able to load user-generated content in your
            project. It requires users to generate a PCK or ZIP file through the Godot
            editor, which contains resources imported by Godot.</paragraph>
        <paragraph>Example use cases for runtime file loading and saving include:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>Loading texture packs designed for the game.</paragraph>
            </list_item>
            <list_item>
                <paragraph>Loading user-provided audio tracks and playing them back in an in-game radio station.</paragraph>
            </list_item>
            <list_item>
                <paragraph>Loading custom levels or 3D models that can be designed with any 3D DCC that
                    can export to glTF or FBX (including glTF scenes saved by Godot at runtime).</paragraph>
            </list_item>
            <list_item>
                <paragraph>Using user-provided fonts for menus and HUD.</paragraph>
            </list_item>
            <list_item>
                <paragraph>Saving/loading a file format that can contain multiple files but can still
                    easily be read by other applications (ZIP).</paragraph>
            </list_item>
            <list_item>
                <paragraph>Loading files created by another game or program, or even game data files from
                    another game not made with Godot.</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>Runtime file loading can be combined with <reference internal="True" refuri="../networking/http_request_class#doc-http-request-class"><inline classes="std std-ref">HTTP requests</inline></reference>
            to load resources from the Internet directly.</paragraph>
        <warning>
            <paragraph>Do <strong>not</strong> use this runtime loading approach to load resources that are part
                of the project, as it's less efficient and doesn't allow benefiting from
                Godot's resource handling functionality (such as translation remaps). See
                <reference internal="True" refuri="../assets_pipeline/import_process#doc-import-process"><inline classes="std std-ref">Import process</inline></reference> for details.</paragraph>
        </warning>
        <seealso>
            <paragraph>You can see how saving and loading works in action using the
                <reference name="Run-time File Saving and Loading (Serialization) demo project" refuri="https://github.com/godotengine/godot-demo-projects/blob/master/loading/runtime_save_load">Run-time File Saving and Loading (Serialization) demo project</reference>.</paragraph>
        </seealso>
        <section ids="plain-text-and-binary-files" names="plain\ text\ and\ binary\ files">
            <title>Plain text and binary files</title>
            <paragraph>Godot's <reference internal="True" refuri="../../classes/class_fileaccess#class-fileaccess"><inline classes="std std-ref">FileAccess</inline></reference> class provides methods to access files on the
                filesystem for reading and writing:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func save_file(content):
    var file = FileAccess.open("/path/to/file.txt", FileAccess.WRITE)
    file.store_string(content)

func load_file():
    var file = FileAccess.open("/path/to/file.txt", FileAccess.READ)
    var content = file.get_as_text()
    return content</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private void SaveFile(string content)
{
    using var file = FileAccess.Open("/Path/To/File.txt", FileAccess.ModeFlags.Write);
    file.StoreString(content);
}

private string LoadFile()
{
    using var file = FileAccess.Open("/Path/To/File.txt", FileAccess.ModeFlags.Read);
    string content = file.GetAsText();
    return content;
}</literal_block>
                </div>
            </container>
            <paragraph>To handle custom binary formats (such as loading file formats not supported by
                Godot), <reference internal="True" refuri="../../classes/class_fileaccess#class-fileaccess"><inline classes="std std-ref">FileAccess</inline></reference> provides several methods to read/write integers,
                floats, strings and more. These FileAccess methods have names that start with
                <literal>get_</literal> and <literal>store_</literal>.</paragraph>
            <paragraph>If you need more control over reading binary files or need to read binary
                streams that are not part of a file, <reference internal="True" refuri="../../classes/class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> provides
                several helper methods to decode/encode series of bytes to integers, floats,
                strings and more. These PackedByteArray methods have names that start with
                <literal>decode_</literal> and <literal>encode_</literal>. See also <reference internal="True" refuri="binary_serialization_api#doc-binary-serialization-api"><inline classes="std std-ref">Binary serialization API</inline></reference>.</paragraph>
            <target refid="doc-runtime-file-loading-and-saving-images"></target>
        </section>
        <section ids="images doc-runtime-file-loading-and-saving-images" names="images doc_runtime_file_loading_and_saving_images">
            <title>Images</title>
            <paragraph>Image's <reference internal="True" refuri="../../classes/class_image#class-image-method-load-from-file"><inline classes="std std-ref">Image.load_from_file</inline></reference> static method
                handles everything, from format detection based on file extension to reading the
                file from disk.</paragraph>
            <paragraph>If you need error handling or more control (such as changing the scale an SVG is
                loaded at), use one of the following methods depending on the file format:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-jpg-from-buffer"><inline classes="std std-ref">Image.load_jpg_from_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-ktx-from-buffer"><inline classes="std std-ref">Image.load_ktx_from_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-png-from-buffer"><inline classes="std std-ref">Image.load_png_from_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-svg-from-buffer"><inline classes="std std-ref">Image.load_svg_from_buffer</inline></reference>
                        or <reference internal="True" refuri="../../classes/class_image#class-image-method-load-svg-from-string"><inline classes="std std-ref">Image.load_svg_from_string</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-tga-from-buffer"><inline classes="std std-ref">Image.load_tga_from_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-webp-from-buffer"><inline classes="std std-ref">Image.load_webp_from_buffer</inline></reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Several image formats can also be saved by Godot at runtime using the following
                methods:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-save-png"><inline classes="std std-ref">Image.save_png</inline></reference>
                        or <reference internal="True" refuri="../../classes/class_image#class-image-method-save-png-to-buffer"><inline classes="std std-ref">Image.save_png_to_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-save-webp"><inline classes="std std-ref">Image.save_webp</inline></reference>
                        or <reference internal="True" refuri="../../classes/class_image#class-image-method-save-webp-to-buffer"><inline classes="std std-ref">Image.save_webp_to_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-save-jpg"><inline classes="std std-ref">Image.save_jpg</inline></reference>
                        or <reference internal="True" refuri="../../classes/class_image#class-image-method-save-jpg-to-buffer"><inline classes="std std-ref">Image.save_jpg_to_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-save-exr"><inline classes="std std-ref">Image.save_exr</inline></reference>
                        or <reference internal="True" refuri="../../classes/class_image#class-image-method-save-exr-to-buffer"><inline classes="std std-ref">Image.save_exr_to_buffer</inline></reference>
                        <emphasis>(only available in editor builds, cannot be used in exported projects)</emphasis></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The methods with the <literal>to_buffer</literal> suffix save the image to a PackedByteArray
                instead of the filesystem. This is useful to send the image over the network or
                into a ZIP archive without having to write it on the filesystem. This can
                increase performance by reducing I/O utilization.</paragraph>
            <note>
                <paragraph>If displaying the loaded image on a 3D surface, make sure to call
                    <reference internal="True" refuri="../../classes/class_image#class-image-method-generate-mipmaps"><inline classes="std std-ref">Image.generate_mipmaps</inline></reference>
                    so that the texture doesn't look grainy when viewed at a distance.
                    This is also useful in 2D when following instructions on
                    <reference internal="True" refuri="../rendering/multiple_resolutions#doc-multiple-resolutions-reducing-aliasing-on-downsampling"><inline classes="std std-ref">reducing aliasing when downsampling</inline></reference>.</paragraph>
            </note>
            <paragraph>Example of loading an image and displaying it in a <reference internal="True" refuri="../../classes/class_texturerect#class-texturerect"><inline classes="std std-ref">TextureRect</inline></reference> node
                (which requires conversion to <reference internal="True" refuri="../../classes/class_imagetexture#class-imagetexture"><inline classes="std std-ref">ImageTexture</inline></reference>):</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Load an image of any format supported by Godot from the filesystem.
var image = Image.load_from_file(path)
# Optionally, generate mipmaps if displaying the texture on a 3D surface
# so that the texture doesn't look grainy when viewed at a distance.
#image.generate_mipmaps()
$TextureRect.texture = ImageTexture.create_from_image(image)

# Save the loaded Image to a PNG image.
image.save_png("/path/to/file.png")

# Save the converted ImageTexture to a PNG image.
$TextureRect.texture.get_image().save_png("/path/to/file.png")</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Load an image of any format supported by Godot from the filesystem.
var image = Image.LoadFromFile(path);
// Optionally, generate mipmaps if displaying the texture on a 3D surface
// so that the texture doesn't look grainy when viewed at a distance.
// image.GenerateMipmaps();
GetNode&lt;TextureRect&gt;("TextureRect").Texture = ImageTexture.CreateFromImage(image);

// Save the loaded Image to a PNG image.
image.SavePng("/Path/To/File.png");

// Save the converted ImageTexture to a PNG image.
GetNode&lt;TextureRect&gt;("TextureRect").Texture.GetImage().SavePng("/Path/To/File.png");</literal_block>
                </div>
            </container>
            <target refid="doc-runtime-file-loading-and-saving-audio-video-files"></target>
        </section>
        <section ids="audio-video-files doc-runtime-file-loading-and-saving-audio-video-files" names="audio/video\ files doc_runtime_file_loading_and_saving_audio_video_files">
            <title>Audio/video files</title>
            <paragraph>Godot supports loading Ogg Vorbis, MP3, and WAV audio at runtime. Note that not <emphasis>all</emphasis>
                files with a <literal>.ogg</literal> extension are Ogg Vorbis files. Some may be Ogg Theora
                videos, or contain Opus audio within an Ogg container. These files will <strong>not</strong>
                load correctly as audio files in Godot.</paragraph>
            <paragraph>Example of loading an Ogg Vorbis audio file in an <reference internal="True" refuri="../../classes/class_audiostreamplayer#class-audiostreamplayer"><inline classes="std std-ref">AudioStreamPlayer</inline></reference> node:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">$AudioStreamPlayer.stream = AudioStreamOggVorbis.load_from_file(path)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GetNode&lt;AudioStreamPlayer&gt;("AudioStreamPlayer").Stream = AudioStreamOggVorbis.LoadFromFile(path);</literal_block>
                </div>
            </container>
            <paragraph>Example of loading an Ogg Theora video file in a <reference internal="True" refuri="../../classes/class_videostreamplayer#class-videostreamplayer"><inline classes="std std-ref">VideoStreamPlayer</inline></reference> node:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var video_stream_theora = VideoStreamTheora.new()
# File extension is ignored, so it is possible to load Ogg Theora videos
# that have a `.ogg` extension this way.
video_stream_theora.file = "/path/to/file.ogv"
$VideoStreamPlayer.stream = video_stream_theora

# VideoStreamPlayer's Autoplay property won't work if the stream is empty
# before this property is set, so call `play()` after setting `stream`.
$VideoStreamPlayer.play()</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var videoStreamTheora = new VideoStreamTheora();
// File extension is ignored, so it is possible to load Ogg Theora videos
// that have a `.ogg` extension this way.
videoStreamTheora.File = "/Path/To/File.ogv";
GetNode&lt;VideoStreamPlayer&gt;("VideoStreamPlayer").Stream = videoStreamTheora;

// VideoStreamPlayer's Autoplay property won't work if the stream is empty
// before this property is set, so call `Play()` after setting `Stream`.
GetNode&lt;VideoStreamPlayer&gt;("VideoStreamPlayer").Play();</literal_block>
                </div>
            </container>
            <target refid="doc-runtime-file-loading-and-saving-3d-scenes"></target>
        </section>
        <section ids="d-scenes doc-runtime-file-loading-and-saving-3d-scenes" names="3d\ scenes doc_runtime_file_loading_and_saving_3d_scenes">
            <title>3D scenes</title>
            <paragraph>Godot has first-class support for glTF 2.0, both in the editor and exported
                projects. Using <reference internal="True" refuri="../../classes/class_gltfdocument#class-gltfdocument"><inline classes="std std-ref">GLTFDocument</inline></reference> and <reference internal="True" refuri="../../classes/class_gltfstate#class-gltfstate"><inline classes="std std-ref">GLTFState</inline></reference> together,
                Godot can load and save glTF files in exported projects, in both text
                (<literal>.gltf</literal>) and binary (<literal>.glb</literal>) formats. The binary format should be preferred
                as it's faster to write and smaller, but the text format is easier to debug.</paragraph>
            <paragraph>Since Godot 4.3, FBX scenes can also be loaded (but not saved) at runtime using the
                <reference internal="True" refuri="../../classes/class_fbxdocument#class-fbxdocument"><inline classes="std std-ref">FBXDocument</inline></reference> and <reference internal="True" refuri="../../classes/class_fbxstate#class-fbxstate"><inline classes="std std-ref">FBXState</inline></reference> classes. The code to do so
                is the same as glTF, but you will need to replace all instances of
                <literal>GLTFDocument</literal> and <literal>GLTFState</literal> with <literal>FBXDocument</literal> and <literal>FBXState</literal> in the
                code samples below.</paragraph>
            <paragraph>Example of loading a glTF scene and appending its root node to the scene:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Load an existing glTF scene.
# GLTFState is used by GLTFDocument to store the loaded scene's state.
# GLTFDocument is the class that handles actually loading glTF data into a Godot node tree,
# which means it supports glTF features such as lights and cameras.
var gltf_document_load = GLTFDocument.new()
var gltf_state_load = GLTFState.new()
var error = gltf_document_load.append_from_file("/path/to/file.gltf", gltf_state_load)
if error == OK:
    var gltf_scene_root_node = gltf_document_load.generate_scene(gltf_state_load)
    add_child(gltf_scene_root_node)
else:
    show_error("Couldn't load glTF scene (error code: %s)." % error_string(error))

# Save a new glTF scene.
var gltf_document_save := GLTFDocument.new()
var gltf_state_save := GLTFState.new()
gltf_document_save.append_from_scene(gltf_scene_root_node, gltf_state_save)
# The file extension in the output `path` (`.gltf` or `.glb`) determines
# whether the output uses text or binary format.
# `GLTFDocument.generate_buffer()` is also available for saving to memory.
gltf_document_save.write_to_filesystem(gltf_state_save, path)</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Load an existing glTF scene.
// GLTFState is used by GLTFDocument to store the loaded scene's state.
// GLTFDocument is the class that handles actually loading glTF data into a Godot node tree,
// which means it supports glTF features such as lights and cameras.
var gltfDocumentLoad = new GltfDocument();
var gltfStateLoad = new GltfState();
var error = gltfDocumentLoad.AppendFromFile("/Path/To/File.gltf", gltfStateLoad);
if (error == Error.Ok)
{
    var gltfSceneRootNode = gltfDocumentLoad.GenerateScene(gltfStateLoad);
    AddChild(gltfSceneRootNode);
}
else
{
    GD.PrintErr($"Couldn't load glTF scene (error code: {error}).");
}

// Save a new glTF scene.
var gltfDocumentSave = new GltfDocument();
var gltfStateSave = new GltfState();
gltfDocumentSave.AppendFromScene(gltfSceneRootNode, gltfStateSave);
// The file extension in the output `path` (`.gltf` or `.glb`) determines
// whether the output uses text or binary format.
// `GltfDocument.GenerateBuffer()` is also available for saving to memory.
gltfDocumentSave.WriteToFilesystem(gltfStateSave, path);</literal_block>
                </div>
            </container>
            <note>
                <paragraph>When loading a glTF scene, a <emphasis>base path</emphasis> must be set so that external
                    resources like textures can be loaded correctly. When loading from a file,
                    the base path is automatically set to the folder containing the file. When
                    loading from a buffer, this base path must be manually set as there is no
                    way for Godot to infer this path.</paragraph>
                <paragraph>To set the base path, set
                    <reference internal="True" refuri="../../classes/class_gltfstate#class-gltfstate-property-base-path"><inline classes="std std-ref">GLTFState.base_path</inline></reference> on your
                    GLTFState instance <emphasis>before</emphasis> calling
                    <reference internal="True" refuri="../../classes/class_gltfdocument#class-gltfdocument-method-append-from-buffer"><inline classes="std std-ref">GLTFDocument.append_from_buffer</inline></reference>
                    or <reference internal="True" refuri="../../classes/class_gltfdocument#class-gltfdocument-method-append-from-file"><inline classes="std std-ref">GLTFDocument.append_from_file</inline></reference>.</paragraph>
            </note>
            <target refid="doc-runtime-file-loading-and-saving-fonts"></target>
        </section>
        <section ids="fonts doc-runtime-file-loading-and-saving-fonts" names="fonts doc_runtime_file_loading_and_saving_fonts">
            <title>Fonts</title>
            <paragraph><reference internal="True" refuri="../../classes/class_fontfile#class-fontfile-method-load-bitmap-font"><inline classes="std std-ref">FontFile.load_dynamic_font</inline></reference> supports the following
                font file formats: TTF, OTF, WOFF, WOFF2, PFB, PFM</paragraph>
            <paragraph>On the other hand, <reference internal="True" refuri="../../classes/class_fontfile#class-fontfile-method-load-bitmap-font"><inline classes="std std-ref">FontFile.load_bitmap_font</inline></reference> supports
                the <reference name="BMFont" refuri="https://www.angelcode.com/products/bmfont/">BMFont</reference> format (<literal>.fnt</literal> or <literal>.font</literal>).</paragraph>
            <paragraph>Additionally, it is possible to load any font that is installed on the system using
                Godot's support for <reference internal="True" refuri="../ui/gui_using_fonts#doc-using-fonts-system-fonts"><inline classes="std std-ref">System fonts</inline></reference>.</paragraph>
            <paragraph>Example of loading a font file automatically according to its file extension,
                then adding it as a theme override to a <reference internal="True" refuri="../../classes/class_label#class-label"><inline classes="std std-ref">Label</inline></reference> node:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var path = "/path/to/font.ttf"
var path_lower = path.to_lower()
var font_file = FontFile.new()
if (
        path_lower.ends_with(".ttf")
        or path_lower.ends_with(".otf")
        or path_lower.ends_with(".woff")
        or path_lower.ends_with(".woff2")
        or path_lower.ends_with(".pfb")
        or path_lower.ends_with(".pfm")
):
    font_file.load_dynamic_font(path)
elif path_lower.ends_with(".fnt") or path_lower.ends_with(".font"):
    font_file.load_bitmap_font(path)
else:
    push_error("Invalid font file format.")

if not font_file.data.is_empty():
    # If font was loaded successfully, add it as a theme override.
    $Label.add_theme_font_override("font", font_file)</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">string path = "/Path/To/Font.ttf";
var fontFile = new FontFile();

if (
    path.EndsWith(".ttf", StringComparison.OrdinalIgnoreCase)
    || path.EndsWith(".otf", StringComparison.OrdinalIgnoreCase)
    || path.EndsWith(".woff", StringComparison.OrdinalIgnoreCase)
    || path.EndsWith(".woff2", StringComparison.OrdinalIgnoreCase)
    || path.EndsWith(".pfb", StringComparison.OrdinalIgnoreCase)
    || path.EndsWith(".pfm", StringComparison.OrdinalIgnoreCase)
)
{
    fontFile.LoadDynamicFont(path);
}
else if (path.EndsWith(".fnt", StringComparison.OrdinalIgnoreCase) || path.EndsWith(".font", StringComparison.OrdinalIgnoreCase))
{
    fontFile.LoadBitmapFont(path);
}
else
{
    GD.PrintErr("Invalid font file format.");
}

if (!fontFile.Data.IsEmpty())
{
    // If font was loaded successfully, add it as a theme override.
    GetNode&lt;Label&gt;("Label").AddThemeFontOverride("font", fontFile);
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="zip-archives" names="zip\ archives">
            <title>ZIP archives</title>
            <paragraph>Godot supports reading and writing ZIP archives using the <reference internal="True" refuri="../../classes/class_zipreader#class-zipreader"><inline classes="std std-ref">ZIPReader</inline></reference>
                and <reference internal="True" refuri="../../classes/class_zippacker#class-zippacker"><inline classes="std std-ref">ZIPPacker</inline></reference> classes. This supports any ZIP file, including files
                generated by Godot's "Export PCK/ZIP" functionality (although these will contain
                imported Godot resources rather than the original project files).</paragraph>
            <note>
                <paragraph>Use <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-method-load-resource-pack"><inline classes="std std-ref">ProjectSettings.load_resource_pack</inline></reference>
                    to load PCK or ZIP files exported by Godot as
                    <reference internal="True" refuri="../export/exporting_pcks#doc-exporting-pcks"><inline classes="std std-ref">additional data packs</inline></reference>. That approach is preferred
                    for DLCs, as it makes interacting with additional data packs seamless (virtual filesystem).</paragraph>
            </note>
            <paragraph>This ZIP archive support can be combined with runtime image, 3D scene and audio
                loading to provide a seamless modding experience without requiring users to go
                through the Godot editor to generate PCK/ZIP files.</paragraph>
            <paragraph>Example that lists files in a ZIP archive in an <reference internal="True" refuri="../../classes/class_itemlist#class-itemlist"><inline classes="std std-ref">ItemList</inline></reference> node,
                then writes contents read from it to a new ZIP archive (essentially duplicating the archive):</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Load an existing ZIP archive.
var zip_reader = ZIPReader.new()
zip_reader.open(path)
var files = zip_reader.get_files()
# The list of files isn't sorted by default. Sort it for more consistent processing.
files.sort()
for file in files:
    $ItemList.add_item(file, null)
    # Make folders disabled in the list.
    $ItemList.set_item_disabled(-1, file.ends_with("/"))

# Save a new ZIP archive.
var zip_packer = ZIPPacker.new()
var error = zip_packer.open(path)
if error != OK:
    push_error("Couldn't open path for saving ZIP archive (error code: %s)." % error_string(error))
    return

# Reuse the above ZIPReader instance to read files from an existing ZIP archive.
for file in zip_reader.get_files():
    zip_packer.start_file(file)
    zip_packer.write_file(zip_reader.read_file(file))
    zip_packer.close_file()

zip_packer.close()</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Load an existing ZIP archive.
var zipReader = new ZipReader();
zipReader.Open(path);
string[] files = zipReader.GetFiles();
// The list of files isn't sorted by default. Sort it for more consistent processing.
Array.Sort(files);
foreach (string file in files)
{
    GetNode&lt;ItemList&gt;("ItemList").AddItem(file);
    // Make folders disabled in the list.
    GetNode&lt;ItemList&gt;("ItemList").SetItemDisabled(-1, file.EndsWith('/'));
}

// Save a new ZIP archive.
var zipPacker = new ZipPacker();
var error = zipPacker.Open(path);
if (error != Error.Ok)
{
    GD.PrintErr($"Couldn't open path for saving ZIP archive (error code: {error}).");
    return;
}

// Reuse the above ZIPReader instance to read files from an existing ZIP archive.
foreach (string file in zipReader.GetFiles())
{
    zipPacker.StartFile(file);
    zipPacker.WriteFile(zipReader.ReadFile(file));
    zipPacker.CloseFile();
}

zipPacker.Close();</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
