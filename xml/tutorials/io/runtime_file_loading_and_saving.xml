<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/io/runtime_file_loading_and_saving.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-runtime-loading-and-saving"></target>
    <section ids="runtime-file-loading-and-saving doc-runtime-loading-and-saving" names="runtime\ file\ loading\ and\ saving 运行时文件加载和保存 doc_runtime_loading_and_saving">
        <title>运行时文件加载和保存</title>
        <seealso>
            <paragraph>更多关于游戏进度的保存和读取的信息见 <reference internal="True" refuri="saving_games#doc-saving-games"><inline classes="std std-ref">保存游戏</inline></reference>。</paragraph>
        </seealso>
        <paragraph>Sometimes, <reference internal="True" refuri="../export/exporting_pcks#doc-exporting-pcks"><inline classes="std std-ref">exporting packs, patches, and mods</inline></reference> is not
            ideal when you want players to be able to load user-generated content in your
            project. It requires users to generate a PCK or ZIP file through the Godot
            editor, which contains resources imported by Godot.</paragraph>
        <paragraph>Example use cases for runtime file loading and saving include:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>加载为游戏设计的纹理包。</paragraph>
            </list_item>
            <list_item>
                <paragraph>加载用户提供的音轨，在游戏内的电台中播放。</paragraph>
            </list_item>
            <list_item>
                <paragraph>加载自定义关卡和 3D 模型，可以使用能够导出 glTF 的任意 3D DCC 设计（包括 Godot 在运行时保存的 glTF 场景）。</paragraph>
            </list_item>
            <list_item>
                <paragraph>为菜单和 HUD 使用用户提供的字体。</paragraph>
            </list_item>
            <list_item>
                <paragraph>Saving/loading a file format that can contain multiple files but can still
                    easily be read by other applications (ZIP).</paragraph>
            </list_item>
            <list_item>
                <paragraph>Loading files created by another game or program, or even game data files from
                    another game not made with Godot.</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>运行时文件加载可以和 <reference internal="True" refuri="../networking/http_request_class#doc-http-request-class"><inline classes="std std-ref">HTTP 请求</inline></reference>结合起来，直接加载互联网上的资源。</paragraph>
        <warning>
            <paragraph><strong>请勿</strong>用这种运行时加载的方法来加载属于项目本身的资源，这种做法的效率较低，无法利用 Godot 的资源处理功能（例如翻译重定向）。详见 <reference internal="True" refuri="../assets_pipeline/import_process#doc-import-process"><inline classes="std std-ref">导入流程</inline></reference>。</paragraph>
        </warning>
        <seealso>
            <paragraph>You can see how saving and loading works in action using the
                <reference name="Run-time File Saving and Loading (Serialization) demo project" refuri="https://github.com/godotengine/godot-demo-projects/blob/master/loading/runtime_save_load">Run-time File Saving and Loading (Serialization) demo project</reference>.</paragraph>
        </seealso>
        <section ids="plain-text-and-binary-files" names="plain\ text\ and\ binary\ files 纯文本文件和二进制文件">
            <title>纯文本文件和二进制文件</title>
            <paragraph>Godot 的 <reference internal="True" refuri="../../classes/class_fileaccess#class-fileaccess"><inline classes="std std-ref">FileAccess</inline></reference> 类提供了读写文件系统中文件的方法：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func save_file(content):
    var file = FileAccess.open("/path/to/file.txt", FileAccess.WRITE)
    file.store_string(content)

func load_file():
    var file = FileAccess.open("/path/to/file.txt", FileAccess.READ)
    var content = file.get_as_text()
    return content</literal_block>
            <paragraph>为了处理自定义二进制格式（例如加载 Godot 不支持的文件格式），<inline classes="xref std std-ref">class_FileAccess`提供了几种读写整数、浮点值、字符串等数据类型的方法。这些 FileAccess 方法的名称以 ``get_`</inline> 和 <literal>store_</literal> 开头。</paragraph>
            <paragraph>If you need more control over reading binary files or need to read binary
                streams that are not part of a file, <reference internal="True" refuri="../../classes/class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> provides
                several helper methods to decode/encode series of bytes to integers, floats,
                strings and more. These PackedByteArray methods have names that start with
                <literal>decode_</literal> and <literal>encode_</literal>. See also <reference internal="True" refuri="binary_serialization_api#doc-binary-serialization-api"><inline classes="std std-ref">二进制序列化 API</inline></reference>.</paragraph>
            <target refid="doc-runtime-file-loading-and-saving-images"></target>
        </section>
        <section ids="images doc-runtime-file-loading-and-saving-images" names="images 图像 doc_runtime_file_loading_and_saving_images">
            <title>图像</title>
            <paragraph>Image's <reference internal="True" refuri="../../classes/class_image#class-image-method-load-from-file"><inline classes="std std-ref">Image.load_from_file</inline></reference> static method
                handles everything, from format detection based on file extension to reading the
                file from disk.</paragraph>
            <paragraph>如果你需要错误处理或者更多的控制（例如更改加载SVG的比例）， 请使用下列一个依赖文件格式的方法：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-jpg-from-buffer"><inline classes="std std-ref">Image.load_jpg_from_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-ktx-from-buffer"><inline classes="std std-ref">Image.load_ktx_from_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-png-from-buffer"><inline classes="std std-ref">Image.load_png_from_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-svg-from-buffer"><inline classes="std std-ref">Image.load_svg_from_buffer</inline></reference> 或 <reference internal="True" refuri="../../classes/class_image#class-image-method-load-svg-from-string"><inline classes="std std-ref">Image.load_svg_from_string</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-tga-from-buffer"><inline classes="std std-ref">Image.load_tga_from_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-load-webp-from-buffer"><inline classes="std std-ref">Image.load_webp_from_buffer</inline></reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Godot 还可以在运行时使用以下方法保存几种图像格式：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-save-png"><inline classes="std std-ref">Image.save_png</inline></reference> 或 <reference internal="True" refuri="../../classes/class_image#class-image-method-save-png-to-buffer"><inline classes="std std-ref">Image.save_png_to_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-save-webp"><inline classes="std std-ref">Image.save_webp</inline></reference> 或 <reference internal="True" refuri="../../classes/class_image#class-image-method-save-webp-to-buffer"><inline classes="std std-ref">Image.save_webp_to_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-save-jpg"><inline classes="std std-ref">Image.save_jpg</inline></reference> 或 <reference internal="True" refuri="../../classes/class_image#class-image-method-save-jpg-to-buffer"><inline classes="std std-ref">Image.save_jpg_to_buffer</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_image#class-image-method-save-exr"><inline classes="std std-ref">Image.save_exr</inline></reference> 或 <reference internal="True" refuri="../../classes/class_image#class-image-method-save-exr-to-buffer"><inline classes="std std-ref">Image.save_exr_to_buffer</inline></reference> <emphasis>（仅在编辑器版本中可用，无法在导出后的项目中使用）</emphasis></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>那些有着 <literal>to_buffer</literal> 前缀的方法将图片保存至 PackedByteArray 中，而不是文件系统。这对于通过网络发送图像或将图像发送到 ZIP 压缩包 中非常有用，而无需将其写入文件系统。它可以通过降低 I/O 利用率来提高性能。</paragraph>
            <note>
                <paragraph>If displaying the loaded image on a 3D surface, make sure to call
                    <reference internal="True" refuri="../../classes/class_image#class-image-method-generate-mipmaps"><inline classes="std std-ref">Image.generate_mipmaps</inline></reference>
                    so that the texture doesn't look grainy when viewed at a distance.
                    This is also useful in 2D when following instructions on
                    <reference internal="True" refuri="../rendering/multiple_resolutions#doc-multiple-resolutions-reducing-aliasing-on-downsampling"><inline classes="std std-ref">reducing aliasing when downsampling</inline></reference>.</paragraph>
            </note>
            <paragraph>Example of loading an image and displaying it in a <reference internal="True" refuri="../../classes/class_texturerect#class-texturerect"><inline classes="std std-ref">TextureRect</inline></reference> node
                (which requires conversion to <reference internal="True" refuri="../../classes/class_imagetexture#class-imagetexture"><inline classes="std std-ref">ImageTexture</inline></reference>):</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Load an image of any format supported by Godot from the filesystem.
var image = Image.load_from_file(path)
# Optionally, generate mipmaps if displaying the texture on a 3D surface
# so that the texture doesn't look grainy when viewed at a distance.
#image.generate_mipmaps()
$TextureRect.texture = ImageTexture.create_from_image(image)

# Save the loaded Image to a PNG image.
image.save_png("/path/to/file.png")

# Save the converted ImageTexture to a PNG image.
$TextureRect.texture.get_image().save_png("/path/to/file.png")</literal_block>
            <target refid="doc-runtime-file-loading-and-saving-audio-video-files"></target>
        </section>
        <section ids="audio-video-files doc-runtime-file-loading-and-saving-audio-video-files" names="audio/video\ files 音视频文件 doc_runtime_file_loading_and_saving_audio_video_files">
            <title>音视频文件</title>
            <paragraph>Godot supports loading Ogg Vorbis audio at runtime. Note that not <emphasis>all</emphasis> files
                with an <literal>.ogg</literal> extension may be Ogg Vorbis files. Some may be Ogg Theora
                videos, or contain Opus audio within an Ogg container. These files will <strong>not</strong>
                load correctly as audio files in Godot.</paragraph>
            <paragraph>通过 <reference internal="True" refuri="../../classes/class_audiostreamplayer#class-audiostreamplayer"><inline classes="std std-ref">AudioStreamPlayer</inline></reference> 节点加载 Ogg Vorbis 音频文件的示例：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">$AudioStreamPlayer.stream = AudioStreamOggVorbis.load_from_file(path)</literal_block>
            <paragraph>通过 <reference internal="True" refuri="../../classes/class_videostreamplayer#class-videostreamplayer"><inline classes="std std-ref">VideoStreamPlayer</inline></reference> 节点加载 Ogg Theora 视频文件的示例：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var video_stream_theora = VideoStreamTheora.new()
# File extension is ignored, so it is possible to load Ogg Theora videos
# that have an `.ogg` extension this way.
video_stream_theora.file = "/path/to/file.ogv"
$VideoStreamPlayer.stream = video_stream_theora

# VideoStreamPlayer's Autoplay property won't work if the stream is empty
# before this property is set, so call `play()` after setting `stream`.
$VideoStreamPlayer.play()</literal_block>
            <note>
                <paragraph>Godot doesn't support runtime loading of MP3 or WAV files yet. Until this is
                    implemented, it's feasible to implement runtime WAV loading using a script
                    since <reference internal="True" refuri="../../classes/class_audiostreamwav#class-audiostreamwav"><inline classes="std std-ref">AudioStreamWAV</inline></reference>'s <literal>data</literal> property is exposed to
                    scripting.</paragraph>
                <paragraph>It's still possible to <emphasis>save</emphasis> WAV files using
                    <reference internal="True" refuri="../../classes/class_audiostreamwav#class-audiostreamwav-method-save-to-wav"><inline classes="std std-ref">AudioStreamWAV.save_to_wav</inline></reference>, which is useful
                    for procedurally generated audio or microphone recordings.</paragraph>
            </note>
            <target refid="doc-runtime-file-loading-and-saving-3d-scenes"></target>
        </section>
        <section ids="d-scenes doc-runtime-file-loading-and-saving-3d-scenes" names="3d\ scenes 3d\ 场景 doc_runtime_file_loading_and_saving_3d_scenes">
            <title>3D 场景</title>
            <paragraph>Godot has first-class support for glTF 2.0, both in the editor and exported
                projects. Using <reference internal="True" refuri="../../classes/class_gltfdocument#class-gltfdocument"><inline classes="std std-ref">GLTFDocument</inline></reference> and <reference internal="True" refuri="../../classes/class_gltfstate#class-gltfstate"><inline classes="std std-ref">GLTFState</inline></reference> together,
                Godot can load and save glTF files in exported projects, in both text
                (<literal>.gltf</literal>) and binary (<literal>.glb</literal>) formats. The binary format should be preferred
                as it's faster to write and smaller, but the text format is easier to debug.</paragraph>
            <paragraph>Example of loading a glTF scene and appending its root node to the scene:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Load an existing glTF scene.
# GLTFState is used by GLTFDocument to store the loaded scene's state.
# GLTFDocument is the class that handles actually loading glTF data into a Godot node tree,
# which means it supports glTF features such as lights and cameras.
var gltf_document_load = GLTFDocument.new()
var gltf_state_load = GLTFState.new()
var error = gltf_document_load.append_from_file("/path/to/file.gltf", gltf_state_load)
if error == OK:
    var gltf_scene_root_node = gltf_document_load.generate_scene(gltf_state_load)
    add_child(gltf_scene_root_node)
else:
    show_error("Couldn't load glTF scene (error code: %s)." % error_string(error))

# Save a new glTF scene.
var gltf_document_save := GLTFDocument.new()
var gltf_state_save := GLTFState.new()
gltf_document_save.append_from_scene(gltf_scene_root_node, gltf_state_save)
# The file extension in the output `path` (`.gltf` or `.glb`) determines
# whether the output uses text or binary format.
# `GLTFDocument.generate_buffer()` is also available for saving to memory.
gltf_document_save.write_to_filesystem(gltf_state_save, path)</literal_block>
            <note>
                <paragraph>When loading a glTF scene, a <emphasis>base path</emphasis> must be set so that external
                    resources like textures can be loaded correctly. When loading from a file,
                    the base path is automatically set to the folder containing the file. When
                    loading from a buffer, this base path must be manually set as there is no
                    way for Godot to infer this path.</paragraph>
                <paragraph>To set the base path, set
                    <reference internal="True" refuri="../../classes/class_gltfstate#class-gltfstate-property-base-path"><inline classes="std std-ref">GLTFState.base_path</inline></reference> on your
                    GLTFState instance <emphasis>before</emphasis> calling
                    <reference internal="True" refuri="../../classes/class_gltfdocument#class-gltfdocument-method-append-from-buffer"><inline classes="std std-ref">GLTFDocument.append_from_buffer</inline></reference>
                    or <reference internal="True" refuri="../../classes/class_gltfdocument#class-gltfdocument-method-append-from-file"><inline classes="std std-ref">GLTFDocument.append_from_file</inline></reference>.</paragraph>
            </note>
            <target refid="doc-runtime-file-loading-and-saving-fonts"></target>
        </section>
        <section ids="fonts doc-runtime-file-loading-and-saving-fonts" names="fonts 字体 doc_runtime_file_loading_and_saving_fonts">
            <title>字体</title>
            <paragraph><reference internal="True" refuri="../../classes/class_fontfile#class-fontfile-method-load-bitmap-font"><inline classes="std std-ref">FontFile.load_dynamic_font</inline></reference> 支持以下字体文件格式：TTF、OTF、WOFF、WOFF2、PFB、PFM</paragraph>
            <paragraph>On the other hand, <reference internal="True" refuri="../../classes/class_fontfile#class-fontfile-method-load-bitmap-font"><inline classes="std std-ref">FontFile.load_bitmap_font</inline></reference> supports
                the <reference name="BMFont" refuri="https://www.angelcode.com/products/bmfont/">BMFont</reference> format (<literal>.fnt</literal> or <literal>.font</literal>).</paragraph>
            <paragraph>Additionally, it is possible to load any font that is installed on the system using
                Godot's support for <reference internal="True" refuri="../ui/gui_using_fonts#doc-using-fonts-system-fonts"><inline classes="std std-ref">系统字体</inline></reference>.</paragraph>
            <paragraph>Example of loading a font file automatically according to its file extension,
                then adding it as a theme override to a <reference internal="True" refuri="../../classes/class_label#class-label"><inline classes="std std-ref">Label</inline></reference> node:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var path = "/path/to/font.ttf"
var path_lower = path.to_lower()
var font_file = FontFile.new()
if (
        path_lower.ends_with(".ttf")
        or path_lower.ends_with(".otf")
        or path_lower.ends_with(".woff")
        or path_lower.ends_with(".woff2")
        or path_lower.ends_with(".pfb")
        or path_lower.ends_with(".pfm")
):
    font_file.load_dynamic_font(path)
elif path_lower.ends_with(".fnt") or path_lower.ends_with(".font"):
    font_file.load_bitmap_font(path)
else:
    push_error("Invalid font file format.")

if not font_file.data.is_empty():
    # If font was loaded successfully, add it as a theme override.
    $Label.add_theme_font_override("font", font_file)</literal_block>
        </section>
        <section ids="zip-archives" names="zip\ archives zip\ 压缩包">
            <title>ZIP 压缩包</title>
            <paragraph>Godot supports reading and writing ZIP archives using the <reference internal="True" refuri="../../classes/class_zipreader#class-zipreader"><inline classes="std std-ref">ZIPReader</inline></reference>
                and <reference internal="True" refuri="../../classes/class_zippacker#class-zippacker"><inline classes="std std-ref">ZIPPacker</inline></reference> classes. This supports any ZIP file, including files
                generated by Godot's "Export PCK/ZIP" functionality (although these will contain
                imported Godot resources rather than the original project files).</paragraph>
            <note>
                <paragraph>Use <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-method-load-resource-pack"><inline classes="std std-ref">ProjectSettings.load_resource_pack</inline></reference>
                    to load PCK or ZIP files exported by Godot as
                    <reference internal="True" refuri="../export/exporting_pcks#doc-exporting-pcks"><inline classes="std std-ref">additional data packs</inline></reference>. That approach is preferred
                    for DLCs, as it makes interacting with additional data packs seamless (virtual filesystem).</paragraph>
            </note>
            <paragraph>This ZIP archive support can be combined with runtime image, 3D scene and audio
                loading to provide a seamless modding experience without requiring users to go
                through the Godot editor to generate PCK/ZIP files.</paragraph>
            <paragraph>Example that lists files in a ZIP archive in an <reference internal="True" refuri="../../classes/class_itemlist#class-itemlist"><inline classes="std std-ref">ItemList</inline></reference> node,
                then writes contents read from it to a new ZIP archive (essentially duplicating the archive):</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Load an existing ZIP archive.
var zip_reader = ZIPReader.new()
zip_reader.open(path)
var files = zip_reader.get_files()
# The list of files isn't sorted by default. Sort it for more consistent processing.
files.sort()
for file in files:
    $ItemList.add_item(file, null)
    # Make folders disabled in the list.
    $ItemList.set_item_disabled(-1, file.ends_with("/"))

# Save a new ZIP archive.
var zip_packer = ZIPPacker.new()
var error = zip_packer.open(path)
if error != OK:
    push_error("Couldn't open path for saving ZIP archive (error code: %s)." % error_string(error))
    return

# Reuse the above ZIPReader instance to read files from an existing ZIP archive.
for file in zip_reader.get_files():
    zip_packer.start_file(file)
    zip_packer.write_file(zip_reader.read_file(file))
    zip_packer.close_file()

zip_packer.close()</literal_block>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
