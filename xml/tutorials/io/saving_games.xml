<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/io/saving_games.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-saving-games"></target>
    <section ids="saving-games doc-saving-games" names="saving\ games doc_saving_games">
        <title>Saving games</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>Save games can be complicated. For example, it may be desirable
                to store information from multiple objects across multiple levels.
                Advanced save game systems should allow for additional information about
                an arbitrary number of objects. This will allow the save function to
                scale as the game grows more complex.</paragraph>
            <note>
                <paragraph>If you're looking to save user configuration, you can use the
                    <reference internal="True" refuri="../../classes/class_configfile#class-configfile"><inline classes="std std-ref">ConfigFile</inline></reference> class for this purpose.</paragraph>
            </note>
            <seealso>
                <paragraph>You can see how saving and loading works in action using the
                    <reference name="Saving and Loading (Serialization) demo project" refuri="https://github.com/godotengine/godot-demo-projects/blob/master/loading/serialization">Saving and Loading (Serialization) demo project</reference>.</paragraph>
            </seealso>
        </section>
        <section ids="identify-persistent-objects" names="identify\ persistent\ objects">
            <title>Identify persistent objects</title>
            <paragraph>Firstly, we should identify what objects we want to keep between game
                sessions and what information we want to keep from those objects. For
                this tutorial, we will use groups to mark and handle objects to be saved,
                but other methods are certainly possible.</paragraph>
            <paragraph>We will start by adding objects we wish to save to the "Persist" group. We can
                do this through either the GUI or script. Let's add the relevant nodes using the
                GUI:</paragraph>
            <image candidates="{'*': 'tutorials/io/img/groups.webp'}" original_uri="img/groups.webp" uri="tutorials/io/img/groups.webp"></image>
            <paragraph>Once this is done, when we need to save the game, we can get all objects
                to save them and then tell them all to save with this script:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var save_nodes = get_tree().get_nodes_in_group("Persist")
for node in save_nodes:
    # Now, we can call our save function on each node.</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var saveNodes = GetTree().GetNodesInGroup("Persist");
foreach (Node saveNode in saveNodes)
{
    // Now, we can call our save function on each node.
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="serializing" names="serializing">
            <title>Serializing</title>
            <paragraph>The next step is to serialize the data. This makes it much easier to
                read from and store to disk. In this case, we're assuming each member of
                group Persist is an instanced node and thus has a path. GDScript
                has the helper class <reference internal="True" refuri="../../classes/class_json#class-json"><inline classes="std std-ref">JSON</inline></reference> to convert between dictionary and string.
                Our node needs to contain a save function that returns this data.
                The save function will look like this:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func save():
    var save_dict = {
        "filename" : get_scene_file_path(),
        "parent" : get_parent().get_path(),
        "pos_x" : position.x, # Vector2 is not supported by JSON
        "pos_y" : position.y,
        "attack" : attack,
        "defense" : defense,
        "current_health" : current_health,
        "max_health" : max_health,
        "damage" : damage,
        "regen" : regen,
        "experience" : experience,
        "tnl" : tnl,
        "level" : level,
        "attack_growth" : attack_growth,
        "defense_growth" : defense_growth,
        "health_growth" : health_growth,
        "is_alive" : is_alive,
        "last_attack" : last_attack
    }
    return save_dict</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public Godot.Collections.Dictionary&lt;string, Variant&gt; Save()
{
    return new Godot.Collections.Dictionary&lt;string, Variant&gt;()
    {
        { "Filename", SceneFilePath },
        { "Parent", GetParent().GetPath() },
        { "PosX", Position.X }, // Vector2 is not supported by JSON
        { "PosY", Position.Y },
        { "Attack", Attack },
        { "Defense", Defense },
        { "CurrentHealth", CurrentHealth },
        { "MaxHealth", MaxHealth },
        { "Damage", Damage },
        { "Regen", Regen },
        { "Experience", Experience },
        { "Tnl", Tnl },
        { "Level", Level },
        { "AttackGrowth", AttackGrowth },
        { "DefenseGrowth", DefenseGrowth },
        { "HealthGrowth", HealthGrowth },
        { "IsAlive", IsAlive },
        { "LastAttack", LastAttack }
    };
}</literal_block>
                </div>
            </container>
            <paragraph>This gives us a dictionary with the style
                <literal>{ "variable_name":value_of_variable }</literal>, which will be useful when
                loading.</paragraph>
        </section>
        <section ids="saving-and-reading-data" names="saving\ and\ reading\ data">
            <title>Saving and reading data</title>
            <paragraph>As covered in the <reference internal="True" refuri="../scripting/filesystem#doc-filesystem"><inline classes="std std-ref">File system</inline></reference> tutorial, we'll need to open a file
                so we can write to it or read from it. Now that we have a way to
                call our groups and get their relevant data, let's use the class <reference internal="True" refuri="../../classes/class_json#class-json"><inline classes="std std-ref">JSON</inline></reference> to
                convert it into an easily stored string and store them in a file. Doing
                it this way ensures that each line is its own object, so we have an easy
                way to pull the data out of the file as well.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Note: This can be called from anywhere inside the tree. This function is
# path independent.
# Go through everything in the persist category and ask them to return a
# dict of relevant variables.
func save_game():
    var save_file = FileAccess.open("user://savegame.save", FileAccess.WRITE)
    var save_nodes = get_tree().get_nodes_in_group("Persist")
    for node in save_nodes:
        # Check the node is an instanced scene so it can be instanced again during load.
        if node.scene_file_path.is_empty():
            print("persistent node '%s' is not an instanced scene, skipped" % node.name)
            continue

        # Check the node has a save function.
        if !node.has_method("save"):
            print("persistent node '%s' is missing a save() function, skipped" % node.name)
            continue

        # Call the node's save function.
        var node_data = node.call("save")

        # JSON provides a static method to serialized JSON string.
        var json_string = JSON.stringify(node_data)

        # Store the save dictionary as a new line in the save file.
        save_file.store_line(json_string)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Note: This can be called from anywhere inside the tree. This function is
// path independent.
// Go through everything in the persist category and ask them to return a
// dict of relevant variables.
public void SaveGame()
{
    using var saveFile = FileAccess.Open("user://savegame.save", FileAccess.ModeFlags.Write);

    var saveNodes = GetTree().GetNodesInGroup("Persist");
    foreach (Node saveNode in saveNodes)
    {
        // Check the node is an instanced scene so it can be instanced again during load.
        if (string.IsNullOrEmpty(saveNode.SceneFilePath))
        {
            GD.Print($"persistent node '{saveNode.Name}' is not an instanced scene, skipped");
            continue;
        }

        // Check the node has a save function.
        if (!saveNode.HasMethod("Save"))
        {
            GD.Print($"persistent node '{saveNode.Name}' is missing a Save() function, skipped");
            continue;
        }

        // Call the node's save function.
        var nodeData = saveNode.Call("Save");

        // Json provides a static method to serialized JSON string.
        var jsonString = Json.Stringify(nodeData);

        // Store the save dictionary as a new line in the save file.
        saveFile.StoreLine(jsonString);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>Game saved! Now, to load, we'll read each
                line. Use the <reference internal="True" refuri="../../classes/class_json#class-json-method-parse"><inline classes="std std-ref">parse</inline></reference> method to read the
                JSON string back to a dictionary, and then iterate over
                the dict to read our values. But we'll need to first create the object
                and we can use the filename and parent values to achieve that. Here is our
                load function:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Note: This can be called from anywhere inside the tree. This function
# is path independent.
func load_game():
    if not FileAccess.file_exists("user://savegame.save"):
        return # Error! We don't have a save to load.

    # We need to revert the game state so we're not cloning objects
    # during loading. This will vary wildly depending on the needs of a
    # project, so take care with this step.
    # For our example, we will accomplish this by deleting saveable objects.
    var save_nodes = get_tree().get_nodes_in_group("Persist")
    for i in save_nodes:
        i.queue_free()

    # Load the file line by line and process that dictionary to restore
    # the object it represents.
    var save_file = FileAccess.open("user://savegame.save", FileAccess.READ)
    while save_file.get_position() &lt; save_file.get_length():
        var json_string = save_file.get_line()

        # Creates the helper class to interact with JSON.
        var json = JSON.new()

        # Check if there is any error while parsing the JSON string, skip in case of failure.
        var parse_result = json.parse(json_string)
        if not parse_result == OK:
            print("JSON Parse Error: ", json.get_error_message(), " in ", json_string, " at line ", json.get_error_line())
            continue

        # Get the data from the JSON object.
        var node_data = json.data

        # Firstly, we need to create the object and add it to the tree and set its position.
        var new_object = load(node_data["filename"]).instantiate()
        get_node(node_data["parent"]).add_child(new_object)
        new_object.position = Vector2(node_data["pos_x"], node_data["pos_y"])

        # Now we set the remaining variables.
        for i in node_data.keys():
            if i == "filename" or i == "parent" or i == "pos_x" or i == "pos_y":
                continue
            new_object.set(i, node_data[i])</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Note: This can be called from anywhere inside the tree. This function is
// path independent.
public void LoadGame()
{
    if (!FileAccess.FileExists("user://savegame.save"))
    {
        return; // Error! We don't have a save to load.
    }

    // We need to revert the game state so we're not cloning objects during loading.
    // This will vary wildly depending on the needs of a project, so take care with
    // this step.
    // For our example, we will accomplish this by deleting saveable objects.
    var saveNodes = GetTree().GetNodesInGroup("Persist");
    foreach (Node saveNode in saveNodes)
    {
        saveNode.QueueFree();
    }

    // Load the file line by line and process that dictionary to restore the object
    // it represents.
    using var saveFile = FileAccess.Open("user://savegame.save", FileAccess.ModeFlags.Read);

    while (saveFile.GetPosition() &lt; saveFile.GetLength())
    {
        var jsonString = saveFile.GetLine();

        // Creates the helper class to interact with JSON.
        var json = new Json();
        var parseResult = json.Parse(jsonString);
        if (parseResult != Error.Ok)
        {
            GD.Print($"JSON Parse Error: {json.GetErrorMessage()} in {jsonString} at line {json.GetErrorLine()}");
            continue;
        }

        // Get the data from the JSON object.
        var nodeData = new Godot.Collections.Dictionary&lt;string, Variant&gt;((Godot.Collections.Dictionary)json.Data);

        // Firstly, we need to create the object and add it to the tree and set its position.
        var newObjectScene = GD.Load&lt;PackedScene&gt;(nodeData["Filename"].ToString());
        var newObject = newObjectScene.Instantiate&lt;Node&gt;();
        GetNode(nodeData["Parent"].ToString()).AddChild(newObject);
        newObject.Set(Node2D.PropertyName.Position, new Vector2((float)nodeData["PosX"], (float)nodeData["PosY"]));

        // Now we set the remaining variables.
        foreach (var (key, value) in nodeData)
        {
            if (key == "Filename" || key == "Parent" || key == "PosX" || key == "PosY")
            {
                continue;
            }
            newObject.Set(key, value);
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>Now we can save and load an arbitrary number of objects laid out
                almost anywhere across the scene tree! Each object can store different
                data depending on what it needs to save.</paragraph>
        </section>
        <section ids="some-notes" names="some\ notes">
            <title>Some notes</title>
            <paragraph>We have glossed over setting up the game state for loading. It's ultimately up
                to the project creator where much of this logic goes.
                This is often complicated and will need to be heavily
                customized based on the needs of the individual project.</paragraph>
            <paragraph>Additionally, our implementation assumes no Persist objects are children of other
                Persist objects. Otherwise, invalid paths would be created. To
                accommodate nested Persist objects, consider saving objects in stages.
                Load parent objects first so they are available for the <reference internal="True" refuri="../../classes/class_node#class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference>
                call when child objects are loaded. You will also need a way to link
                children to parents as the <reference internal="True" refuri="../../classes/class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> will likely be invalid.</paragraph>
        </section>
        <section ids="json-vs-binary-serialization" names="json\ vs\ binary\ serialization">
            <title>JSON vs binary serialization</title>
            <paragraph>For simple game state, JSON may work and it generates human-readable files that are easy to debug.</paragraph>
            <paragraph>But JSON has many limitations. If you need to store more complex game state or
                a lot of it, <reference internal="True" refuri="binary_serialization_api#doc-binary-serialization-api"><inline classes="std std-ref">binary serialization</inline></reference>
                may be a better approach.</paragraph>
            <section ids="json-limitations" names="json\ limitations">
                <title>JSON limitations</title>
                <paragraph>Here are some important gotchas to know about when using JSON.</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><strong>Filesize:</strong>
                            JSON stores data in text format, which is much larger than binary formats.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Data types:</strong>
                            JSON only offers a limited set of data types. If you have data types
                            that JSON doesn't have, you will need to translate your data to and
                            from types that JSON can handle. For example, some important types that JSON
                            can't parse are: <literal>Vector2</literal>, <literal>Vector3</literal>, <literal>Color</literal>, <literal>Rect2</literal>, and <literal>Quaternion</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Custom logic needed for encoding/decoding:</strong>
                            If you have any custom classes that you want to store with JSON, you will
                            need to write your own logic for encoding and decoding those classes.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="binary-serialization" names="binary\ serialization">
                <title>Binary serialization</title>
                <paragraph><reference internal="True" refuri="binary_serialization_api#doc-binary-serialization-api"><inline classes="std std-ref">Binary serialization</inline></reference> is an alternative
                    approach for storing game state, and you can use it with the functions
                    <literal>get_var</literal> and <literal>store_var</literal> of <reference internal="True" refuri="../../classes/class_fileaccess#class-fileaccess"><inline classes="std std-ref">FileAccess</inline></reference>.</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>Binary serialization should produce smaller files than JSON.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Binary serialization can handle most common data types.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Binary serialization requires less custom logic for encoding and decoding
                            custom classes.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Note that not all properties are included. Only properties that are configured
                    with the <reference internal="True" refuri="../../classes/class_@globalscope#class-globalscope-constant-property-usage-storage"><inline classes="std std-ref">PROPERTY_USAGE_STORAGE</inline></reference>
                    flag set will be serialized. You can add a new usage flag to a property by overriding the
                    <reference internal="True" refuri="../../classes/class_object#class-object-private-method-get-property-list"><inline classes="std std-ref">_get_property_list</inline></reference>
                    method in your class. You can also check how property usage is configured by
                    calling <literal>Object._get_property_list</literal>.
                    See <reference internal="True" refuri="../../classes/class_@globalscope#enum-globalscope-propertyusageflags"><inline classes="std std-ref">PropertyUsageFlags</inline></reference> for the
                    possible usage flags.</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
