<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/platform/web/customizing_html5_shell.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-customizing-html5-shell"></target>
    <section ids="custom-html-page-for-web-export doc-customizing-html5-shell" names="custom\ html\ page\ for\ web\ export 导出自定义\ html\ 页面 doc_customizing_html5_shell">
        <title>导出自定义 HTML 页面</title>
        <paragraph>虽然 Web 导出模板提供了一个默认的 HTML 页面，完全能够在没有任何进一步定制的情况下启动项目，但创建自定义 HTML 页面可能是有益的。虽然游戏本身还不能轻易地从外部直接控制，但这样的页面允许自定义引擎的初始化过程。</paragraph>
        <paragraph>自定义默认页面在某些情况下非常有用，包括：</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>读取与该页面不同目录下的文件;</paragraph>
            </list_item>
            <list_item>
                <paragraph>加载 <literal>.zip</literal> 文件而不是 <literal>.pck</literal> 文件作为主资源包;</paragraph>
            </list_item>
            <list_item>
                <paragraph>从主资源包文件以外的目录中加载引擎文件;</paragraph>
            </list_item>
            <list_item>
                <paragraph>添加“点击开始”按钮，使游戏可以在全屏模式下启动；</paragraph>
            </list_item>
            <list_item>
                <paragraph>在引擎启动之前加载一些额外的文件，以便稍后在文件系统中可用；</paragraph>
            </list_item>
            <list_item>
                <paragraph>传递自定义 "命令行" 参数, 例如 <literal>-s</literal> 启动 <literal>MainLoop</literal> 脚本.</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>默认的HTML页面可在Godot引擎仓库 <reference name="/misc/dist/html/full-size.html" refuri="https://github.com/godotengine/godot/blob/master/misc/dist/html/full-size.html">/misc/dist/html/full-size.html</reference> 中找到, 但以下模板可作为一个更简单的例子:</paragraph>
        <literal_block force="False" highlight_args="{}" language="html" linenos="False" xml:space="preserve">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;My Template&lt;/title&gt;
        &lt;meta charset="UTF-8"&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;canvas id="canvas"&gt;&lt;/canvas&gt;
        &lt;script src="$GODOT_URL"&gt;&lt;/script&gt;
        &lt;script&gt;
            var engine = new Engine($GODOT_CONFIG);
            engine.startGame();
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</literal_block>
        <section ids="setup" names="setup 场景布置">
            <title>场景布置</title>
            <paragraph>如上面的例子所示，它主要是一个普通的HTML文档，有几个占位符需要在导出时替换，一个html <literal>&lt;canvas&gt;</literal> 元素，和一些简单的JavaScript代码，调用 <reference internal="True" reftitle="Engine" refuri="html5_shell_classref#Engine"><literal classes="xref js js-class">Engine()</literal></reference> 类。</paragraph>
            <paragraph>唯一需要的占位符是:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>$GODOT_URL</literal> : 主JavaScript文件的名称，它提供了启动引擎所需的 <reference internal="True" reftitle="Engine" refuri="html5_shell_classref#Engine"><literal classes="xref js js-class">Engine()</literal></reference> 类，必须作为 <literal>&lt;script&gt;</literal> 包含在HTML中。这个名字是在导出过程中从*导出路径Export Path* 生成的。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>$GODOT_CONFIG</literal> : 一个JavaScript对象，包含导出选项，以后可以被重写。参见 <reference internal="True" reftitle="EngineConfig" refuri="html5_shell_classref#EngineConfig"><literal classes="xref js js-attr">EngineConfig</literal></reference> 获取完整的重写列表。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>以下可选的占位符将在你的自定义 HTML 模板中实现一些额外的功能。</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>$GODOT_PROJECT_NAME</literal>: 在项目设置中定义的项目名称。在你的模板中使用它作为 <literal>&lt;title&gt;</literal> 是一个好主意。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>$GODOT_HEAD_INCLUDE</literal>. 在HTML文件中, 在 <literal>&lt;head&gt;</literal> 标签结尾前包含的一个自定义字符串. 它是在*Html / Head Include*部分的导出选项中自定义的. 虽然你可以完全控制你所创建的HTML页面, 但这个变量对于从Godot Editor中配置HTML``head`` 元素的部分内容很有用, 例如, 对于不同的Web导出预设.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>当自定义页面准备好后, 可以在 <emphasis>Html / Custom Html Shell</emphasis> 部分的导出选项中选择.</paragraph>
            <image candidates="{'*': 'tutorials/platform/web/img/html5_export_options.png'}" uri="tutorials/platform/web/img/html5_export_options.png"></image>
        </section>
        <section ids="starting-the-project" names="starting\ the\ project 启动项目">
            <title>启动项目</title>
            <paragraph>To be able to start the game, you need to write a script that initializes the engine — the control
                code. This process consists of three steps, but as shown here, most of them can be skipped depending on
                how much customization is needed.</paragraph>
            <paragraph>参见 <reference internal="True" refuri="html5_shell_classref#doc-html5-shell-classref"><inline classes="std std-ref">HTML5 shell 类参考</inline></reference>，以获得可用方法和选项的完整列表。</paragraph>
            <paragraph>首先，引擎必须被加载，然后需要被初始化，在这之后，项目最终可以被启动。你可以手动执行这些步骤中的每一步，而且控制得很好。然而，在最简单的情况下，你需要做的是用导出的配置创建一个 <reference internal="True" reftitle="Engine" refuri="html5_shell_classref#Engine"><literal classes="xref js js-class">Engine()</literal></reference> 类的实例，然后调用 <reference internal="True" reftitle="Engine.prototype.startGame" refuri="html5_shell_classref#Engine.prototype.startGame"><literal classes="xref js js-meth">engine.startGame</literal></reference> 方法，可选择重写任何 <reference internal="True" reftitle="EngineConfig" refuri="html5_shell_classref#EngineConfig"><literal classes="xref js js-attr">EngineConfig</literal></reference> 参数。</paragraph>
            <literal_block force="False" highlight_args="{}" language="js" linenos="False" xml:space="preserve">const engine = new Engine($GODOT_CONFIG);
engine.startGame({
    /* optional override configuration, eg. */
    // unloadAfterInit: false,
    // canvasResizePolicy: 0,
    // ...
});</literal_block>
            <paragraph>This snippet of code automatically loads and initializes the engine before starting the game.
                It uses the given configuration to load the engine. The <reference internal="True" reftitle="Engine.prototype.startGame" refuri="html5_shell_classref#Engine.prototype.startGame"><literal classes="xref js js-meth">engine.startGame</literal></reference>
                method is asynchronous and returns a <literal>Promise</literal>. This allows your control code to track if
                the game was loaded correctly without blocking execution or relying on polling.</paragraph>
            <paragraph>如果你的项目需要对启动参数和依赖文件进行特别控制，可以使用 <reference internal="True" reftitle="Engine.prototype.start" refuri="html5_shell_classref#Engine.prototype.start"><literal classes="xref js js-meth">engine.start</literal></reference> 方法来代替。注意，这个方法不会自动预加载 <literal>pck</literal> 文件，所以你可能要通过 <reference internal="True" reftitle="Engine.prototype.preloadFile" refuri="html5_shell_classref#Engine.prototype.preloadFile"><literal classes="xref js js-meth">engine.preloadFile</literal></reference> 方法手动预加载它和任何其他额外的文件。</paragraph>
            <paragraph>另外，你也可以手动 <reference internal="True" reftitle="Engine.prototype.init" refuri="html5_shell_classref#Engine.prototype.init"><literal classes="xref js js-meth">engine.init</literal></reference> 在模块初始化之后，但在引擎启动之前，执行特定的动作。</paragraph>
            <paragraph>这个过程有点复杂，但可以让你完全控制引擎的启动过程。</paragraph>
            <literal_block force="False" highlight_args="{}" language="js" linenos="False" xml:space="preserve">const myWasm = 'mygame.wasm';
const myPck = 'mygame.pck';
const engine = new Engine();
Promise.all([
    // Load and init the engine
    engine.init(myWasm),
    // And the pck concurrently
    engine.preloadFile(myPck),
]).then(() =&gt; {
    // Now start the engine.
    return engine.start({ args: ['--main-pack', myPck] });
}).then(() =&gt; {
    console.log('Engine has started!');
});</literal_block>
            <paragraph>要手动加载引擎，必须调用 <reference internal="True" reftitle="Engine.load" refuri="html5_shell_classref#Engine.load"><literal classes="xref js js-meth">Engine.load()</literal></reference> 静态方法。由于这个方法是静态的，如果多个引擎实例共享相同的 <literal>wasm</literal> ，就可以产生多个引擎实例。</paragraph>
            <note>
                <paragraph>默认情况下不能生成多个实例，因为引擎被初始化后会立即卸载。为了防止这种情况发生，请看 <reference internal="True" reftitle="unloadAfterInit" refuri="html5_shell_classref#unloadAfterInit"><literal classes="xref js js-attr">unloadAfterInit</literal></reference> 覆盖选项。之后仍然可以通过调用 <reference internal="True" reftitle="Engine.unload" refuri="html5_shell_classref#Engine.unload"><literal classes="xref js js-meth">Engine.unload()</literal></reference> 静态方法来手动卸载引擎。卸载引擎可以通过卸载实例初始化后不再需要的文件来释放浏览器内存。</paragraph>
            </note>
        </section>
        <section ids="customizing-the-behavior" names="customizing\ the\ behavior 自定义行为">
            <title>自定义行为</title>
            <paragraph>在 Web 环境下，可以使用几种方法来保证游戏能够按照预期的方式运行。</paragraph>
            <paragraph>如果你的目标是 WebGL 的特定版本，或者只是想检查 WebGL 是否可用，你可以调用 <reference internal="True" reftitle="Engine.isWebGLAvailable" refuri="html5_shell_classref#Engine.isWebGLAvailable"><literal classes="xref js js-meth">Engine.isWebGLAvailable()</literal></reference> 方法。它可以选择接受一个参数，允许测试 WebGL 的特定主要版本。</paragraph>
            <paragraph>由于真正的可执行文件不存在于 Web 环境中，引擎只存储一个由加载的引擎文件的基本名称形成的虚拟文件名。这个值会影响 <reference internal="True" refuri="../../../classes/class_os#class-os-method-get-executable-path"><inline classes="std std-ref">OS.get_executable_path()</inline></reference> 方法的输出，并定义自动启动的主包的名称。<reference internal="True" reftitle="executable" refuri="html5_shell_classref#executable"><literal classes="xref js js-attr">executable</literal></reference> 选项可以用来重写这个值。</paragraph>
        </section>
        <section ids="customizing-the-presentation" names="customizing\ the\ presentation 自定义展现形式">
            <title>自定义展现形式</title>
            <paragraph>有几个配置选项可以用来进一步定制你页面上游戏的外观和行为。</paragraph>
            <paragraph>默认情况下会使用页面上的第一个 canvas 元素来渲染。要使用其他 canvas 元素，可以使用 <reference internal="True" reftitle="canvas" refuri="html5_shell_classref#canvas"><literal classes="xref js js-attr">canvas</literal></reference> 选项重写。它需要一个对 DOM 元素本身的引用。</paragraph>
            <literal_block force="False" highlight_args="{}" language="js" linenos="False" xml:space="preserve">const canvasElement = document.querySelector("#my-canvas-element");
engine.startGame({ canvas: canvasElement });</literal_block>
            <paragraph>引擎调整画布大小的方式可以通过 <reference internal="True" reftitle="canvasResizePolicy" refuri="html5_shell_classref#canvasResizePolicy"><literal classes="xref js js-attr">canvasResizePolicy</literal></reference> 覆盖选项进行配置。</paragraph>
            <paragraph>如果你的游戏需要一些时间来加载，显示一个跟踪进度的自定义加载UI可能是有用的。这可以通过 <reference internal="True" reftitle="onProgress" refuri="html5_shell_classref#onProgress"><literal classes="xref js js-attr">onProgress</literal></reference> 回调选项来实现，它允许设置一个回调函数，当引擎加载新字节时，该函数将被定期调用。</paragraph>
            <literal_block force="False" highlight_args="{}" language="js" linenos="False" xml:space="preserve">function printProgress(current, total) {
    console.log("Loaded " + current + " of " + total + " bytes");
}
engine.startGame({ onProgress: printProgress });</literal_block>
            <paragraph>请注意，在某些情况下 <literal>total</literal> 可能是 <literal>0</literal>。这意味着无法计算。</paragraph>
            <paragraph>如果你的游戏支持多种语言， <reference internal="True" reftitle="locale" refuri="html5_shell_classref#locale"><literal classes="xref js js-attr">locale</literal></reference> 覆盖选项可以用来强制使用一个特定的语言，只要你有一个有效的语言代码字符串。使用服务器端的逻辑来确定用户可能喜欢哪种语言可能较好。这样，语言代码可以从 <literal>Accept-Language</literal> HTTP头中获取，或者由GeoIP服务决定。</paragraph>
        </section>
        <section ids="debugging" names="debugging 调试">
            <title>调试</title>
            <paragraph>要调试导出的项目, 可能需要读取引擎生成的标准输出和错误流. 这与编辑器控制台窗口中显示的输出类似. 默认情况下, 标准的 <literal>console.log</literal> 和 <literal>console.warning</literal> 分别用于输出和错误流. 这种行为可以通过设置自己的函数来处理消息来定制.</paragraph>
            <paragraph>使用 <reference internal="True" reftitle="onPrint" refuri="html5_shell_classref#onPrint"><literal classes="xref js js-attr">onPrint</literal></reference> 覆盖选项为输出流设置一个回调函数，以及 <reference internal="True" reftitle="onPrintError" refuri="html5_shell_classref#onPrintError"><literal classes="xref js js-attr">onPrintError</literal></reference> 覆盖选项为错误流设置一个回调函数。</paragraph>
            <literal_block force="False" highlight_args="{}" language="js" linenos="False" xml:space="preserve">function print(text) {
    console.log(text);
}
function printError(text) {
    console.warn(text);
}
engine.startGame({ onPrint: print, onPrintError: printError });</literal_block>
            <paragraph>When handling the engine output, keep in mind that it may not be desirable to print it out in the
                finished product.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
