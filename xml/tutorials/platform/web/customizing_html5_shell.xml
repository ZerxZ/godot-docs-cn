<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/platform/web/customizing_html5_shell.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-customizing-html5-shell"></target>
    <section ids="custom-html-page-for-web-export doc-customizing-html5-shell" names="custom\ html\ page\ for\ web\ export doc_customizing_html5_shell">
        <title>Custom HTML page for Web export</title>
        <paragraph>While Web export templates provide a default HTML page fully capable of launching
            the project without any further customization, it may be beneficial to create a custom
            HTML page. While the game itself cannot easily be directly controlled from the outside yet,
            such page allows to customize the initialization process for the engine.</paragraph>
        <paragraph>Some use-cases where customizing the default page is useful include:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>Loading files from a different directory than the page;</paragraph>
            </list_item>
            <list_item>
                <paragraph>Loading a <literal>.zip</literal> file instead of a <literal>.pck</literal> file as the main pack;</paragraph>
            </list_item>
            <list_item>
                <paragraph>Loading the engine from a different directory than the main pack file;</paragraph>
            </list_item>
            <list_item>
                <paragraph>Adding a click-to-play button so that games can be started in the fullscreen mode;</paragraph>
            </list_item>
            <list_item>
                <paragraph>Loading some extra files before the engine starts, making them available in
                    the project file system as soon as possible;</paragraph>
            </list_item>
            <list_item>
                <paragraph>Passing custom command line arguments, e.g. <literal>-s</literal> to start a <literal>MainLoop</literal> script.</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>The default HTML page is available in the Godot Engine repository at
            <reference name="/misc/dist/html/full-size.html" refuri="https://github.com/godotengine/godot/blob/master/misc/dist/html/full-size.html">/misc/dist/html/full-size.html</reference>
            but the following template can be used as a much simpler example:</paragraph>
        <literal_block force="False" highlight_args="{}" language="html" linenos="False" xml:space="preserve">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;My Template&lt;/title&gt;
        &lt;meta charset="UTF-8"&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;canvas id="canvas"&gt;&lt;/canvas&gt;
        &lt;script src="$GODOT_URL"&gt;&lt;/script&gt;
        &lt;script&gt;
            var engine = new Engine($GODOT_CONFIG);
            engine.startGame();
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</literal_block>
        <section ids="setup" names="setup">
            <title>Setup</title>
            <paragraph>As shown by the example above, it is mostly a regular HTML document, with few placeholders
                which needs to be replaced during export, an html <literal>&lt;canvas&gt;</literal> element, and some simple
                JavaScript code that calls the <reference internal="True" reftitle="Engine" refuri="html5_shell_classref#Engine"><literal classes="xref js js-class">Engine()</literal></reference> class.</paragraph>
            <paragraph>The only required placeholders are:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>$GODOT_URL</literal>:
                        The name of the main JavaScript file, which provides the <reference internal="True" reftitle="Engine" refuri="html5_shell_classref#Engine"><literal classes="xref js js-class">Engine()</literal></reference> class required
                        to start the engine and that must be included in the HTML as a <literal>&lt;script&gt;</literal>.
                        The name is generated from the <emphasis>Export Path</emphasis> during the export process.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>$GODOT_CONFIG</literal>:
                        A JavaScript object, containing the export options and can be later overridden.
                        See <reference internal="True" reftitle="EngineConfig" refuri="html5_shell_classref#EngineConfig"><literal classes="xref js js-attr">EngineConfig</literal></reference> for the full list of overrides.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The following optional placeholders will enable some extra features in your custom HTML template.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>$GODOT_PROJECT_NAME</literal>:
                        The project name as defined in the
                        <reference internal="True" refuri="../../../classes/class_projectsettings#class-projectsettings-property-application-config-name"><inline classes="std std-ref">Name</inline></reference> setting
                        in <strong>Project Settings &gt; Application &gt; Config</strong>.
                        It is a good idea to use it as a <literal>&lt;title&gt;</literal> in your template.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>$GODOT_HEAD_INCLUDE</literal>:
                        A custom string to include in the HTML document just before the end of the <literal>&lt;head&gt;</literal> tag. It
                        is customized in the export options under the <emphasis>Html / Head Include</emphasis> section. While you fully
                        control the HTML page you create, this variable can be useful for configuring parts of the
                        HTML <literal>head</literal> element from the Godot Editor, e.g. for different Web export presets.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>$GODOT_SPLASH</literal>:
                        The path to the image used as the boot splash as defined in the
                        <reference internal="True" refuri="../../../classes/class_projectsettings#class-projectsettings-property-application-boot-splash-image"><inline classes="std std-ref">Image</inline></reference> setting
                        in <strong>Project Settings &gt; Application &gt; Boot Splash</strong>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>$GODOT_SPLASH_COLOR</literal>
                        The splash screen background color as defined in the
                        <reference internal="True" refuri="../../../classes/class_projectsettings#class-projectsettings-property-application-boot-splash-bg-color"><inline classes="std std-ref">BG Color</inline></reference> setting
                        in <strong>Project Settings &gt; Application &gt; Boot Splash</strong>, converted to a hex color code.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>$GODOT_SPLASH_CLASSES</literal>:
                        This placeholder provides a string of setting names and their values, which affect the splash screen.
                        This string is meant to be used as a set of CSS class names, which allows styling the splash image
                        based on the splash project settings.
                        The following settings from <strong>Project Settings &gt; Application &gt; Boot Splash</strong> are provided,
                        represented by the class names shown below depending on the setting's boolean value:</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><reference internal="True" refuri="../../../classes/class_projectsettings#class-projectsettings-property-application-boot-splash-show-image"><inline classes="std std-ref">Show Image</inline></reference>:
                                <literal>show-image--true</literal>, <literal>show-image--false</literal></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference internal="True" refuri="../../../classes/class_projectsettings#class-projectsettings-property-application-boot-splash-stretch-mode"><inline classes="std std-ref">Stretch Mode</inline></reference>:
                                <literal>fullsize--true</literal> (if <strong>not</strong> Disabled), <literal>fullsize--false</literal></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference internal="True" refuri="../../../classes/class_projectsettings#class-projectsettings-property-application-boot-splash-use-filter"><inline classes="std std-ref">Use Filter</inline></reference>:
                                <literal>use-filter--true</literal>, <literal>use-filter--false</literal></paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
            </bullet_list>
            <paragraph>When the custom page is ready, it can be selected in the export options under the <emphasis>Html / Custom Html Shell</emphasis>
                section.</paragraph>
            <image candidates="{'*': 'tutorials/platform/web/img/html5_export_options.png'}" original_uri="img/html5_export_options.png" uri="tutorials/platform/web/img/html5_export_options.png"></image>
        </section>
        <section ids="starting-the-project" names="starting\ the\ project">
            <title>Starting the project</title>
            <paragraph>To be able to start the game, you need to write a script that initializes the engine â€” the control
                code. This process consists of three steps, but as shown here, most of them can be skipped depending on
                how much customization is needed.</paragraph>
            <paragraph>See the <reference internal="True" refuri="html5_shell_classref#doc-html5-shell-classref"><inline classes="std std-ref">HTML5 shell class reference</inline></reference>, for the full list of methods and options available.</paragraph>
            <paragraph>First, the engine must be loaded, then it needs to be initialized, and after this the project
                can finally be started. You can perform every of these steps manually and with great control.
                However, in the simplest case all you need to do is to create an instance of the <reference internal="True" reftitle="Engine" refuri="html5_shell_classref#Engine"><literal classes="xref js js-class">Engine()</literal></reference>
                class with the exported configuration, and then call the <reference internal="True" reftitle="Engine.prototype.startGame" refuri="html5_shell_classref#Engine.prototype.startGame"><literal classes="xref js js-meth">engine.startGame</literal></reference> method
                optionally overriding any <reference internal="True" reftitle="EngineConfig" refuri="html5_shell_classref#EngineConfig"><literal classes="xref js js-attr">EngineConfig</literal></reference> parameters.</paragraph>
            <literal_block force="False" highlight_args="{}" language="js" linenos="False" xml:space="preserve">const engine = new Engine($GODOT_CONFIG);
engine.startGame({
    /* optional override configuration, eg. */
    // unloadAfterInit: false,
    // canvasResizePolicy: 0,
    // ...
});</literal_block>
            <paragraph>This snippet of code automatically loads and initializes the engine before starting the game.
                It uses the given configuration to load the engine. The <reference internal="True" reftitle="Engine.prototype.startGame" refuri="html5_shell_classref#Engine.prototype.startGame"><literal classes="xref js js-meth">engine.startGame</literal></reference>
                method is asynchronous and returns a <literal>Promise</literal>. This allows your control code to track if
                the game was loaded correctly without blocking execution or relying on polling.</paragraph>
            <paragraph>In case your project needs to have special control over the start arguments and dependency files,
                the <reference internal="True" reftitle="Engine.prototype.start" refuri="html5_shell_classref#Engine.prototype.start"><literal classes="xref js js-meth">engine.start</literal></reference> method can be used instead. Note, that this method do not
                automatically preload the <literal>pck</literal> file, so you will probably want to manually preload it
                (and any other extra file) via the <reference internal="True" reftitle="Engine.prototype.preloadFile" refuri="html5_shell_classref#Engine.prototype.preloadFile"><literal classes="xref js js-meth">engine.preloadFile</literal></reference> method.</paragraph>
            <paragraph>Optionally, you can also manually <reference internal="True" reftitle="Engine.prototype.init" refuri="html5_shell_classref#Engine.prototype.init"><literal classes="xref js js-meth">engine.init</literal></reference> to perform specific actions after
                the module initialization, but before the engine starts.</paragraph>
            <paragraph>This process is a bit more complex, but gives you full control over the engine startup process.</paragraph>
            <literal_block force="False" highlight_args="{}" language="js" linenos="False" xml:space="preserve">const myWasm = 'mygame.wasm';
const myPck = 'mygame.pck';
const engine = new Engine();
Promise.all([
    // Load and init the engine
    engine.init(myWasm),
    // And the pck concurrently
    engine.preloadFile(myPck),
]).then(() =&gt; {
    // Now start the engine.
    return engine.start({ args: ['--main-pack', myPck] });
}).then(() =&gt; {
    console.log('Engine has started!');
});</literal_block>
            <paragraph>To load the engine manually the <reference internal="True" reftitle="Engine.load" refuri="html5_shell_classref#Engine.load"><literal classes="xref js js-meth">Engine.load()</literal></reference> static method must be called. As
                this method is static, multiple engine instances can be spawned if the share the same <literal>wasm</literal>.</paragraph>
            <note>
                <paragraph>Multiple instances cannot be spawned by default, as the engine is immediately unloaded after it is initialized.
                    To prevent this from happening see the <reference internal="True" reftitle="unloadAfterInit" refuri="html5_shell_classref#unloadAfterInit"><literal classes="xref js js-attr">unloadAfterInit</literal></reference> override option. It is still possible
                    to unload the engine manually afterwards by calling the <reference internal="True" reftitle="Engine.unload" refuri="html5_shell_classref#Engine.unload"><literal classes="xref js js-meth">Engine.unload()</literal></reference> static method. Unloading the engine
                    frees browser memory by unloading files that are no longer needed once the instance is initialized.</paragraph>
            </note>
        </section>
        <section ids="customizing-the-behavior" names="customizing\ the\ behavior">
            <title>Customizing the behavior</title>
            <paragraph>In the Web environment several methods can be used to guarantee that the game will work as intended.</paragraph>
            <paragraph>If you target a specific version of WebGL, or just want to check if WebGL is available at all,
                you can call the <reference internal="True" reftitle="Engine.isWebGLAvailable" refuri="html5_shell_classref#Engine.isWebGLAvailable"><literal classes="xref js js-meth">Engine.isWebGLAvailable()</literal></reference> method. It optionally takes an argument that
                allows to test for a specific major version of WebGL.</paragraph>
            <paragraph>As the real executable file does not exist in the Web environment, the engine only stores a virtual
                filename formed from the base name of loaded engine files. This value affects the output of the
                <reference internal="True" refuri="../../../classes/class_os#class-os-method-get-executable-path"><inline classes="std std-ref">OS.get_executable_path()</inline></reference> method and defines the name of
                the automatically started main pack. The <reference internal="True" reftitle="executable" refuri="html5_shell_classref#executable"><literal classes="xref js js-attr">executable</literal></reference> override option can be
                used to override this value.</paragraph>
        </section>
        <section ids="customizing-the-presentation" names="customizing\ the\ presentation">
            <title>Customizing the presentation</title>
            <paragraph>Several configuration options can be used to further customize the look and behavior of the game on your page.</paragraph>
            <paragraph>By default, the first canvas element on the page is used for rendering. To use a different canvas
                element the <reference internal="True" reftitle="canvas" refuri="html5_shell_classref#canvas"><literal classes="xref js js-attr">canvas</literal></reference> override option can be used. It requires a reference to the DOM
                element itself.</paragraph>
            <literal_block force="False" highlight_args="{}" language="js" linenos="False" xml:space="preserve">const canvasElement = document.querySelector("#my-canvas-element");
engine.startGame({ canvas: canvasElement });</literal_block>
            <paragraph>The way the engine resize the canvas can be configured via the <reference internal="True" reftitle="canvasResizePolicy" refuri="html5_shell_classref#canvasResizePolicy"><literal classes="xref js js-attr">canvasResizePolicy</literal></reference>
                override option.</paragraph>
            <paragraph>If your game takes some time to load, it may be useful to display a custom loading UI which tracks
                the progress. This can be achieved with the <reference internal="True" reftitle="onProgress" refuri="html5_shell_classref#onProgress"><literal classes="xref js js-attr">onProgress</literal></reference> callback option, which
                allows to set up a callback function that will be called regularly as the engine loads new bytes.</paragraph>
            <literal_block force="False" highlight_args="{}" language="js" linenos="False" xml:space="preserve">function printProgress(current, total) {
    console.log("Loaded " + current + " of " + total + " bytes");
}
engine.startGame({ onProgress: printProgress });</literal_block>
            <paragraph>Be aware that in some cases <literal>total</literal> can be <literal>0</literal>. This means that it cannot be calculated.</paragraph>
            <paragraph>If your game supports multiple languages, the <reference internal="True" reftitle="locale" refuri="html5_shell_classref#locale"><literal classes="xref js js-attr">locale</literal></reference> override option can be used to
                force a specific locale, provided you have a valid language code string. It may be good to use server-side
                logic to determine which languages a user may prefer. This way the language code can be taken from the
                <literal>Accept-Language</literal> HTTP header, or determined by a GeoIP service.</paragraph>
        </section>
        <section ids="debugging" names="debugging">
            <title>Debugging</title>
            <paragraph>To debug exported projects, it may be useful to read the standard output and error streams generated
                by the engine. This is similar to the output shown in the editor console window. By default, standard
                <literal>console.log</literal> and <literal>console.warn</literal> are used for the output and error streams respectively. This
                behavior can be customized by setting your own functions to handle messages.</paragraph>
            <paragraph>Use the <reference internal="True" reftitle="onPrint" refuri="html5_shell_classref#onPrint"><literal classes="xref js js-attr">onPrint</literal></reference> override option to set a callback function for the output stream,
                and the <reference internal="True" reftitle="onPrintError" refuri="html5_shell_classref#onPrintError"><literal classes="xref js js-attr">onPrintError</literal></reference> override option to set a callback function for the error stream.</paragraph>
            <literal_block force="False" highlight_args="{}" language="js" linenos="False" xml:space="preserve">function print(text) {
    console.log(text);
}
function printError(text) {
    console.warn(text);
}
engine.startGame({ onPrint: print, onPrintError: printError });</literal_block>
            <paragraph>When handling the engine output, keep in mind that it may not be desirable to print it out in the
                finished product.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
