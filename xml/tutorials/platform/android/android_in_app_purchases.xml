<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/platform/android/android_in_app_purchases.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-android-in-app-purchases"></target>
    <section ids="android-in-app-purchases doc-android-in-app-purchases" names="android\ in-app\ purchases android\ 应用内购买 doc_android_in_app_purchases">
        <title>Android 应用内购买</title>
        <paragraph>Godot offers a first-party <literal>GodotGooglePlayBilling</literal> Android plugin compatible with Godot 4 which uses the <reference name="Google Play Billing library" refuri="https://developer.android.com/google/play/billing">Google Play Billing library</reference><target ids="google-play-billing-library" names="google\ play\ billing\ library" refuri="https://developer.android.com/google/play/billing"></target>.</paragraph>
        <section ids="usage" names="usage 用法">
            <title>用法</title>
            <section ids="getting-started" names="getting\ started 入门">
                <title>入门</title>
                <paragraph>Make sure you have enabled and successfully set up <reference internal="True" refuri="../../export/android_gradle_build#doc-android-gradle-build"><inline classes="std std-ref">Android Gradle Builds</inline></reference>.
                    Follow the compiling instructions on the <literal>GodotGooglePlayBilling</literal> <reference name="github page" refuri="https://github.com/godotengine/godot-google-play-billing">github page</reference>.</paragraph>
                <paragraph>Then put the files <title_reference>./godot-google-play-billing/build/outputs/aar/GodotGooglePlayBilling.***.release.aar</title_reference> and <title_reference>./GodotGooglePlayBilling.gdap</title_reference> into your project in the <title_reference>res://android/plugins</title_reference> folder.</paragraph>
                <paragraph>The plugin should now show up in the Android export settings, where you can enable it.</paragraph>
            </section>
            <section ids="initialize-the-plugin" names="initialize\ the\ plugin">
                <title>Initialize the plugin</title>
                <paragraph>To use the <literal>GodotGooglePlayBilling</literal> API:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>Obtain a reference to the <literal>GodotGooglePlayBilling</literal> singleton</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Connect handlers for the plugin signals</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Call <literal>startConnection</literal></paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>最小连接示例：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var payment

func _ready():
    if Engine.has_singleton("GodotGooglePlayBilling"):
        payment = Engine.get_singleton("GodotGooglePlayBilling")

        # These are all signals supported by the API
        # You can drop some of these based on your needs
        payment.billing_resume.connect(_on_billing_resume) # No params
        payment.connected.connect(_on_connected) # No params
        payment.disconnected.connect(_on_disconnected) # No params
        payment.connect_error.connect(_on_connect_error) # Response ID (int), Debug message (string)
        payment.price_change_acknowledged.connect(_on_price_acknowledged) # Response ID (int)
        payment.purchases_updated.connect(_on_purchases_updated) # Purchases (Dictionary[])
        payment.purchase_error.connect(_on_purchase_error) # Response ID (int), Debug message (string)
        payment.sku_details_query_completed.connect(_on_product_details_query_completed) # Products (Dictionary[])
        payment.sku_details_query_error.connect(_on_product_details_query_error) # Response ID (int), Debug message (string), Queried SKUs (string[])
        payment.purchase_acknowledged.connect(_on_purchase_acknowledged) # Purchase token (string)
        payment.purchase_acknowledgement_error.connect(_on_purchase_acknowledgement_error) # Response ID (int), Debug message (string), Purchase token (string)
        payment.purchase_consumed.connect(_on_purchase_consumed) # Purchase token (string)
        payment.purchase_consumption_error.connect(_on_purchase_consumption_error) # Response ID (int), Debug message (string), Purchase token (string)
        payment.query_purchases_response.connect(_on_query_purchases_response) # Purchases (Dictionary[])

        payment.startConnection()
    else:
        print("Android IAP support is not enabled. Make sure you have enabled 'Gradle Build' and the GodotGooglePlayBilling plugin in your Android export settings! IAP will not work.")</literal_block>
                <paragraph>The API must be in a connected state prior to use. The <literal>connected</literal> signal is sent
                    when the connection process succeeds. You can also use <literal>isReady()</literal> to determine if the plugin
                    is ready for use. The <literal>getConnectionState()</literal> function returns the current connection state
                    of the plugin.</paragraph>
                <paragraph>Return values for <literal>getConnectionState()</literal>:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Matches BillingClient.ConnectionState in the Play Billing Library
enum ConnectionState {
    DISCONNECTED, # not yet connected to billing service or was already closed
    CONNECTING, # currently in process of connecting to billing service
    CONNECTED, # currently connected to billing service
    CLOSED, # already closed and shouldn't be used again
}</literal_block>
            </section>
            <section ids="query-available-items" names="query\ available\ items">
                <title>Query available items</title>
                <paragraph>Once the API has connected, query SKUs using <literal>querySkuDetails()</literal>. You must successfully complete
                    an SKU query before calling the <literal>purchase()</literal> or <literal>queryPurchases()</literal> functions,
                    or they will return an error. <literal>querySkuDetails()</literal> takes two parameters: an array
                    of SKU name strings, and a string specifying the type of SKU being queried.
                    The SKU type string should be <literal>"inapp"</literal> for normal in-app purchases or <literal>"subs"</literal> for subscriptions.
                    The name strings in the array should match the SKU product ids defined in the Google Play Console entry
                    for your app.</paragraph>
                <paragraph><literal>querySkuDetails()</literal> 的示例用法：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_connected():
  payment.querySkuDetails(["my_iap_item"], "inapp") # "subs" for subscriptions

func _on_product_details_query_completed(product_details):
  for available_product in product_details:
    print(available_product)

func _on_product_details_query_error(response_id, error_message, products_queried):
    print("on_product_details_query_error id:", response_id, " message: ",
            error_message, " products: ", products_queried)</literal_block>
            </section>
            <section ids="query-user-purchases" names="query\ user\ purchases 查询用户购买记录">
                <title>查询用户购买记录</title>
                <paragraph>To retrieve a user's purchases, call the <literal>queryPurchases()</literal> function passing
                    a string with the type of SKU to query. The SKU type string should be
                    <literal>"inapp"</literal> for normal in-app purchases or <literal>"subs"</literal> for subscriptions.
                    The <literal>query_purchases_response</literal> signal is sent with the result.
                    The signal has a single parameter: a <reference internal="True" refuri="../../../classes/class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> with
                    a status code and either an array of purchases or an error message.
                    Only active subscriptions and non-consumed one-time purchases are
                    included in the purchase array.</paragraph>
                <paragraph><literal>queryPurchases()</literal> 的示例用法：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _query_purchases():
    payment.queryPurchases("inapp") # Or "subs" for subscriptions

func _on_query_purchases_response(query_result):
    if query_result.status == OK:
        for purchase in query_result.purchases:
            _process_purchase(purchase)
    else:
        print("queryPurchases failed, response code: ",
                query_result.response_code,
                " debug message: ", query_result.debug_message)</literal_block>
                <paragraph>You should query purchases during startup after successfully retrieving SKU details.
                    Since the user may make a purchase or resolve a pending transaction from
                    outside your app, you should recheck for purchases when resuming from the
                    background. To accomplish this, you can use the <literal>billing_resume</literal> signal.</paragraph>
                <paragraph><literal>billing_resume</literal> 的示例用法：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_billing_resume():
    if payment.getConnectionState() == ConnectionState.CONNECTED:
        _query_purchases()</literal_block>
                <paragraph>For more information on processing the purchase items returned by
                    <literal>queryPurchases()</literal>, see <reference name="Processing a purchase item" refid="processing-a-purchase-item">Processing a purchase item</reference></paragraph>
            </section>
            <section ids="purchase-an-item" names="purchase\ an\ item 购买项目">
                <title>购买项目</title>
                <paragraph>To initiate the purchase flow for an item, call <literal>purchase()</literal> passing the
                    product id string of the SKU you wish to purchase.
                    Reminder: you <strong>must</strong> query the SKU details for an item before you can
                    pass it to <literal>purchase()</literal>.</paragraph>
                <paragraph><literal>purchase()</literal> 的示例用法：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">payment.purchase("my_iap_item")</literal_block>
                <paragraph>The payment flow will send a <literal>purchases_updated</literal> signal on success or a
                    <literal>purchase_error</literal> signal on failure.</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_purchases_updated(purchases):
    for purchase in purchases:
        _process_purchase(purchase)

func _on_purchase_error(response_id, error_message):
    print("purchase_error id:", response_id, " message: ", error_message)</literal_block>
            </section>
            <section ids="processing-a-purchase-item" names="processing\ a\ purchase\ item 处理购买项目">
                <title>处理购买项目</title>
                <paragraph>The <literal>query_purchases_response</literal> and <literal>purchases_updated</literal> signals provide an array
                    of purchases in <reference internal="True" refuri="../../../classes/class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> format. The purchase Dictionary
                    includes keys that map to values of the Google Play Billing
                    <reference name="Purchase" refuri="https://developer.android.com/reference/com/android/billingclient/api/Purchase">Purchase</reference><target ids="purchase" names="purchase" refuri="https://developer.android.com/reference/com/android/billingclient/api/Purchase"></target> class.</paragraph>
                <paragraph>购买项目：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">dictionary.put("order_id", purchase.getOrderId());
dictionary.put("package_name", purchase.getPackageName());
dictionary.put("purchase_state", purchase.getPurchaseState());
dictionary.put("purchase_time", purchase.getPurchaseTime());
dictionary.put("purchase_token", purchase.getPurchaseToken());
dictionary.put("quantity", purchase.getQuantity());
dictionary.put("signature", purchase.getSignature());
// PBL V4 replaced getSku with getSkus to support multi-sku purchases,
// use the first entry for "sku" and generate an array for "skus"
ArrayList&lt;String&gt; skus = purchase.getSkus();
dictionary.put("sku", skus.get(0)); # Not available in plugin
String[] skusArray = skus.toArray(new String[0]);
dictionary.put("products", productsArray);
dictionary.put("is_acknowledged", purchase.isAcknowledged());
dictionary.put("is_auto_renewing", purchase.isAutoRenewing());</literal_block>
            </section>
            <section ids="check-purchase-state" names="check\ purchase\ state 检查购买状态">
                <title>检查购买状态</title>
                <paragraph>Check the <literal>purchase_state</literal> value of a purchase to determine if a
                    purchase was completed or is still pending.</paragraph>
                <paragraph>PurchaseState 取值：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Matches Purchase.PurchaseState in the Play Billing Library
enum PurchaseState {
    UNSPECIFIED,
    PURCHASED,
    PENDING,
}</literal_block>
                <paragraph>If a purchase is in a <literal>PENDING</literal> state, you should not award the contents of the
                    purchase or do any further processing of the purchase until it reaches the
                    <literal>PURCHASED</literal> state. If you have a store interface, you may wish to display
                    information about pending purchases needing to be completed in the Google Play Store.
                    For more details on pending purchases, see
                    <reference name="Handling pending transactions" refuri="https://developer.android.com/google/play/billing/integrate#pending">Handling pending transactions</reference><target ids="handling-pending-transactions" names="handling\ pending\ transactions" refuri="https://developer.android.com/google/play/billing/integrate#pending"></target>
                    in the Google Play Billing Library documentation.</paragraph>
            </section>
            <section ids="consumables" names="consumables 消耗品">
                <title>消耗品</title>
                <paragraph>If your in-app item is not a one-time purchase but a consumable item (e.g. coins) which can be purchased
                    multiple times, you can consume an item by calling <literal>consumePurchase()</literal> passing
                    the <literal>purchase_token</literal> value from the purchase dictionary.
                    Calling <literal>consumePurchase()</literal> automatically acknowledges a purchase.
                    Consuming a product allows the user to purchase it again, it will no longer appear
                    in subsequent <literal>queryPurchases()</literal> calls unless it is repurchased.</paragraph>
                <paragraph><literal>consumePurchase()</literal> 的示例用法：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _process_purchase(purchase):
    if "my_consumable_iap_item" in purchase.products and purchase.purchase_state == PurchaseState.PURCHASED:
        # Add code to store payment so we can reconcile the purchase token
        # in the completion callback against the original purchase
        payment.consumePurchase(purchase.purchase_token)

func _on_purchase_consumed(purchase_token):
    _handle_purchase_token(purchase_token, true)

func _on_purchase_consumption_error(response_id, error_message, purchase_token):
    print("_on_purchase_consumption_error id:", response_id,
            " message: ", error_message)
    _handle_purchase_token(purchase_token, false)

# Find the sku associated with the purchase token and award the
# product if successful
func _handle_purchase_token(purchase_token, purchase_successful):
    # check/award logic, remove purchase from tracking list</literal_block>
            </section>
            <section ids="acknowledging-purchases" names="acknowledging\ purchases 确认购买">
                <title>确认购买</title>
                <paragraph>If your in-app item is a one-time purchase, you must acknowledge the purchase by
                    calling the <literal>acknowledgePurchase()</literal> function, passing the <literal>purchase_token</literal>
                    value from the purchase dictionary. If you do not acknowledge a purchase within
                    three days, the user automatically receives a refund, and Google Play revokes the purchase.
                    If you are calling <literal>comsumePurchase()</literal> it automatically acknowledges the purchase and
                    you do not need to call <literal>acknowledgePurchase()</literal>.</paragraph>
                <paragraph><literal>acknowledgePurchase()</literal> 的示例用法：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _process_purchase(purchase):
    if "my_one_time_iap_item" in purchase.products and \
            purchase.purchase_state == PurchaseState.PURCHASED and \
            not purchase.is_acknowledged:
        # Add code to store payment so we can reconcile the purchase token
        # in the completion callback against the original purchase
        payment.acknowledgePurchase(purchase.purchase_token)

func _on_purchase_acknowledged(purchase_token):
    _handle_purchase_token(purchase_token, true)

func _on_purchase_acknowledgement_error(response_id, error_message, purchase_token):
    print("_on_purchase_acknowledgement_error id: ", response_id,
            " message: ", error_message)
    _handle_purchase_token(purchase_token, false)

# Find the sku associated with the purchase token and award the
# product if successful
func _handle_purchase_token(purchase_token, purchase_successful):
    # check/award logic, remove purchase from tracking list</literal_block>
            </section>
            <section ids="subscriptions" names="subscriptions 订阅">
                <title>订阅</title>
                <paragraph>订阅的工作原理和普通的应用内项目没有太大区别. 只要使用 <literal>"subs"</literal> 作为 <literal>querySkuDetails()</literal> 的第二个参数, 就可以得到订阅的详细信息. 在 <literal>queryPurchases()</literal> 的结果中检查 <literal>is_auto_renewing</literal> 来查看用户是否取消了自动更新的订阅。</paragraph>
                <paragraph>You can check <literal>is_auto_renewing</literal> in the a subscription purchase
                    returned from <literal>queryPurchases()</literal> to see if a user has cancelled an
                    auto-renewing subscription.</paragraph>
                <paragraph>You need to acknowledge new subscription purchases, but not automatic
                    subscription renewals.</paragraph>
                <paragraph>If you support upgrading or downgrading between different subscription levels,
                    you should use <literal>updateSubscription()</literal> to use the subscription update flow to
                    change an active subscription. Like <literal>purchase()</literal>, results are returned by the
                    <literal>purchases_updated</literal> and <literal>purchase_error</literal> signals.
                    There are three parameters to <literal>updateSubscription()</literal>:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>The purchase token of the currently active subscription</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The product id string of the subscription SKU to change to</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The proration mode to apply to the subscription.</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>The proration values are defined as:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">enum SubscriptionProrationMode {
    # Replacement takes effect immediately, and the remaining time
    # will be prorated and credited to the user.
    IMMEDIATE_WITH_TIME_PRORATION = 1,
    # Replacement takes effect immediately, and the billing cycle remains the same.
    # The price for the remaining period will be charged.
    # This option is only available for subscription upgrade.
    IMMEDIATE_AND_CHARGE_PRORATED_PRICE,
    # Replacement takes effect immediately, and the new price will be charged on
    # next recurrence time. The billing cycle stays the same.
    IMMEDIATE_WITHOUT_PRORATION,
    # Replacement takes effect when the old plan expires, and the new price
    # will be charged at the same time.
    DEFERRED,
    # Replacement takes effect immediately, and the user is charged full price
    # of new plan and is given a full billing cycle of subscription,
    # plus remaining prorated time from the old plan.
    IMMEDIATE_AND_CHARGE_FULL_PRICE,
}</literal_block>
                <paragraph>Default behavior is <literal>IMMEDIATE_WITH_TIME_PRORATION</literal>.</paragraph>
                <paragraph>Example use of <literal>updateSubscription</literal>:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">payment.updateSubscription(_active_subscription_purchase.purchase_token, \
                    "new_sub_sku", SubscriptionProrationMode.IMMEDIATE_WITH_TIME_PRORATION)</literal_block>
                <paragraph>The <literal>confirmPriceChange()</literal> function can be used to launch price change confirmation flow
                    for a subscription. Pass the product id of the subscription SKU subject to the price change.
                    The result will be sent by the <literal>price_change_acknowledged</literal> signal.</paragraph>
                <paragraph>Example use of <literal>confirmPriceChange()</literal>:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">enum BillingResponse {SUCCESS = 0, CANCELLED = 1}

func confirm_price_change(product_id):
    payment.confirmPriceChange(product_id)

func _on_price_acknowledged(response_id):
    if response_id == BillingResponse.SUCCESS:
        print("price_change_accepted")
    elif response_id == BillingResponse.CANCELED:
        print("price_change_canceled")</literal_block>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
