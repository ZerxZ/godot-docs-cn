<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/platform/android/android_in_app_purchases.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-android-in-app-purchases"></target>
    <section ids="android-in-app-purchases doc-android-in-app-purchases" names="android\ in-app\ purchases doc_android_in_app_purchases">
        <title>Android in-app purchases</title>
        <paragraph>Godot offers a first-party <literal>GodotGooglePlayBilling</literal> Android plugin compatible with Godot 4.2+ which uses the <reference name="Google Play Billing library" refuri="https://developer.android.com/google/play/billing">Google Play Billing library</reference><target ids="google-play-billing-library" names="google\ play\ billing\ library" refuri="https://developer.android.com/google/play/billing"></target>.</paragraph>
        <section ids="usage" names="usage">
            <title>Usage</title>
            <section ids="getting-started" names="getting\ started">
                <title>Getting started</title>
                <paragraph>Make sure you have enabled and successfully set up <reference internal="True" refuri="../../export/android_gradle_build#doc-android-gradle-build"><inline classes="std std-ref">Android Gradle Builds</inline></reference>.
                    Follow the installation instructions on the <literal>GodotGooglePlayBilling</literal> <reference name="github page" refuri="https://github.com/godotengine/godot-google-play-billing">github page</reference>.</paragraph>
            </section>
            <section ids="initialize-the-plugin" names="initialize\ the\ plugin">
                <title>Initialize the plugin</title>
                <paragraph>To use the <literal>GodotGooglePlayBilling</literal> API:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>Access the <literal>BillingClient</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Connect to its signals to receive billing results.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Call <literal>start_connection</literal>.</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>Initialization example:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var billing_client: BillingClient
func _ready():
    billing_client = BillingClient.new()
    billing_client.connected.connect(_on_connected) # No params
    billing_client.disconnected.connect(_on_disconnected) # No params
    billing_client.connect_error.connect(_on_connect_error) # response_code: int, debug_message: String
    billing_client.query_product_details_response.connect(_on_query_product_details_response) # response: Dictionary
    billing_client.query_purchases_response.connect(_on_query_purchases_response) # response: Dictionary
    billing_client.on_purchase_updated.connect(_on_purchase_updated) # response: Dictionary
    billing_client.consume_purchase_response.connect(_on_consume_purchase_response) # response: Dictionary
    billing_client.acknowledge_purchase_response.connect(_on_acknowledge_purchase_response) # response: Dictionary

    billing_client.start_connection()</literal_block>
                <paragraph>The API must be in a connected state prior to use. The <literal>connected</literal> signal is sent
                    when the connection process succeeds. You can also use <literal>is_ready()</literal> to determine if the plugin
                    is ready for use. The <literal>get_connection_state()</literal> function returns the current connection state
                    of the plugin.</paragraph>
                <paragraph>Return values for <literal>get_connection_state()</literal>:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Matches BillingClient.ConnectionState in the Play Billing Library.
# Access in your script as: BillingClient.ConnectionState.CONNECTED
enum ConnectionState {
    DISCONNECTED, # This client was not yet connected to billing service or was already closed.
    CONNECTING, # This client is currently in process of connecting to billing service.
    CONNECTED, # This client is currently connected to billing service.
    CLOSED, # This client was already closed and shouldn't be used again.
}</literal_block>
            </section>
            <section ids="query-available-items" names="query\ available\ items">
                <title>Query available items</title>
                <paragraph>Once the API has connected, query product IDs using <title_reference>query_product_details()</title_reference>. You must successfully complete
                    a product details query before calling the <literal>purchase()</literal>, <literal>purchase_subscription()</literal>, or <literal>update_subscription()</literal> functions,
                    or they will return an error. <literal>query_product_details()</literal> takes two parameters: an array
                    of product ID strings and the type of product being queried.
                    The product type should be <literal>BillingClient.ProductType.INAPP</literal> for normal in-app purchases or <literal>BillingClient.ProductType.SUBS</literal> for subscriptions.
                    The ID strings in the array should match the product IDs defined in the Google Play Console entry
                    for your app.</paragraph>
                <paragraph>Example use of <literal>query_product_details()</literal>:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_connected():
  billing_client.query_product_details(["my_iap_item"], BillingClient.ProductType.INAPP) # BillingClient.ProductType.SUBS for subscriptions.

func _on_query_product_details_response(query_result: Dictionary):
    if query_result.response_code == BillingClient.BillingResponseCode.OK:
        print("Product details query success")
        for available_product in query_result.product_details:
            print(available_product)
    else:
        print("Product details query failed")
        print("response_code: ", query_result.response_code, "debug_message: ", query_result.debug_message)</literal_block>
            </section>
            <section ids="query-user-purchases" names="query\ user\ purchases">
                <title>Query user purchases</title>
                <paragraph>To retrieve a user's purchases, call the <literal>query_purchases()</literal> function passing
                    a product type to query. The product type should be
                    <literal>BillingClient.ProductType.INAPP</literal> for normal in-app purchases or <literal>BillingClient.ProductType.SUBS</literal> for subscriptions.
                    The <literal>query_purchases_response</literal> signal is sent with the result.
                    The signal has a single parameter: a <reference internal="True" refuri="../../../classes/class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> with
                    a response code and either an array of purchases or a debug message.
                    Only active subscriptions and non-consumed one-time purchases are
                    included in the purchase array.</paragraph>
                <paragraph>Example use of <literal>query_purchases()</literal>:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _query_purchases():
    billing_client.query_purchases(BillingClient.ProductType.INAPP) # Or BillingClient.ProductType.SUBS for subscriptions.

func _on_query_purchases_response(query_result: Dictionary):
    if query_result.response_code == BillingClient.BillingResponseCode.OK:
        print("Purchase query success")
        for purchase in query_result.purchases:
            _process_purchase(purchase)
    else:
        print("Purchase query failed")
        print("response_code: ", query_result.response_code, "debug_message: ", query_result.debug_message)</literal_block>
            </section>
            <section ids="purchase-an-item" names="purchase\ an\ item">
                <title>Purchase an item</title>
                <paragraph>To launch the billing flow for an item: Use <literal>purchase()</literal> for in-app products, passing the product ID string.
                    Use <literal>purchase_subscription()</literal> for subscriptions, passing the product ID and base plan ID. You may also optionally provide an offer ID.</paragraph>
                <paragraph>For both <literal>purchase()</literal> and <literal>purchase_subscription()</literal>, you can optionally pass a boolean to indicate whether
                    offers are <reference name="personallised" refuri="https://developer.android.com/google/play/billing/integrate#personalized-price">personallised</reference><target ids="personallised" names="personallised" refuri="https://developer.android.com/google/play/billing/integrate#personalized-price"></target></paragraph>
                <paragraph>Reminder: you <strong>must</strong> query the product details for an item before you can
                    pass it to <literal>purchase()</literal>.
                    This method returns a dictionary indicating whether the billing flow was successfully launched.
                    It includes a response code and either an array of purchases or a debug message.</paragraph>
                <paragraph>Example use of <literal>purchase()</literal>:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var result = billing_client.purchase("my_iap_item")
if result.response_code == BillingClient.BillingResponseCode.OK:
    print("Billing flow launch success")
else:
    print("Billing flow launch failed")
    print("response_code: ", result.response_code, "debug_message: ", result.debug_message)</literal_block>
                <paragraph>The result of the purchase will be sent through the <literal>on_purchases_updated</literal> signal.</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_purchases_updated(result: Dictionary):
    if result.response_code == BillingClient.BillingResponseCode.OK:
        print("Purchase update received")
        for purchase in result.purchases:
            _process_purchase(purchase)
    else:
        print("Purchase update error")
        print("response_code: ", result.response_code, "debug_message: ", result.debug_message)</literal_block>
            </section>
            <section ids="processing-a-purchase-item" names="processing\ a\ purchase\ item">
                <title>Processing a purchase item</title>
                <paragraph>The <literal>query_purchases_response</literal> and <literal>on_purchases_updated</literal> signals provide an array
                    of purchases in <reference internal="True" refuri="../../../classes/class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> format. The purchase Dictionary
                    includes keys that map to values of the Google Play Billing
                    <reference name="Purchase" refuri="https://developer.android.com/reference/com/android/billingclient/api/Purchase">Purchase</reference><target ids="purchase" names="purchase" refuri="https://developer.android.com/reference/com/android/billingclient/api/Purchase"></target> class.</paragraph>
                <paragraph>Purchase fields:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">order_id: String
purchase_token: String
package_name: String
purchase_state: int
purchase_time: int (milliseconds since the epoch (Jan 1, 1970))
original_json: String
is_acknowledged: bool
is_auto_renewing: bool
quantity: int
signature: String
product_ids: PackedStringArray</literal_block>
            </section>
            <section ids="check-purchase-state" names="check\ purchase\ state">
                <title>Check purchase state</title>
                <paragraph>Check the <literal>purchase_state</literal> value of a purchase to determine if a
                    purchase was completed or is still pending.</paragraph>
                <paragraph>PurchaseState values:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Matches Purchase.PurchaseState in the Play Billing Library
# Access in your script as: BillingClient.PurchaseState.PURCHASED
enum PurchaseState {
    UNSPECIFIED,
    PURCHASED,
    PENDING,
}</literal_block>
                <paragraph>If a purchase is in a <literal>PENDING</literal> state, you should not award the contents of the
                    purchase or do any further processing of the purchase until it reaches the
                    <literal>PURCHASED</literal> state. If you have a store interface, you may wish to display
                    information about pending purchases needing to be completed in the Google Play Store.
                    For more details on pending purchases, see
                    <reference name="Handling pending transactions" refuri="https://developer.android.com/google/play/billing/integrate#pending">Handling pending transactions</reference><target ids="handling-pending-transactions" names="handling\ pending\ transactions" refuri="https://developer.android.com/google/play/billing/integrate#pending"></target>
                    in the Google Play Billing Library documentation.</paragraph>
            </section>
            <section ids="consumables" names="consumables">
                <title>Consumables</title>
                <paragraph>If your in-app item is not a one-time purchase but a consumable item (e.g. coins) which can be purchased
                    multiple times, you can consume an item by calling <literal>consume_purchase()</literal> passing
                    the <literal>purchase_token</literal> value from the purchase dictionary.
                    Calling <literal>consume_purchase()</literal> automatically acknowledges a purchase.
                    Consuming a product allows the user to purchase it again, it will no longer appear
                    in subsequent <literal>query_purchases()</literal> calls unless it is repurchased.</paragraph>
                <paragraph>Example use of <literal>consume_purchase()</literal>:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _process_purchase(purchase):
    if "my_consumable_iap_item" in purchase.product_ids and purchase.purchase_state == BillingClient.PurchaseState.PURCHASED:
        # Add code to store payment so we can reconcile the purchase token
        # in the completion callback against the original purchase
        billing_client.consume_purchase(purchase.purchase_token)

func _on_consume_purchase_response(result: Dictionary):
    if result.response_code == BillingClient.BillingResponseCode.OK:
        print("Consume purchase success")
        _handle_purchase_token(result.token, true)
    else:
        print("Consume purchase failed")
        print("response_code: ", result.response_code, "debug_message: ", result.debug_message, "purchase_token: ", result.token)

# Find the product associated with the purchase token and award the
# product if successful
func _handle_purchase_token(purchase_token, purchase_successful):
    # check/award logic, remove purchase from tracking list</literal_block>
            </section>
            <section ids="acknowledging-purchases" names="acknowledging\ purchases">
                <title>Acknowledging purchases</title>
                <paragraph>If your in-app item is a one-time purchase, you must acknowledge the purchase by
                    calling the <literal>acknowledge_purchase()</literal> function, passing the <literal>purchase_token</literal>
                    value from the purchase dictionary. If you do not acknowledge a purchase within
                    three days, the user automatically receives a refund, and Google Play revokes the purchase.
                    If you are calling <literal>comsume_purchase()</literal> it automatically acknowledges the purchase and
                    you do not need to call <literal>acknowledge_purchase()</literal>.</paragraph>
                <paragraph>Example use of <literal>acknowledge_purchase()</literal>:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _process_purchase(purchase):
    if "my_one_time_iap_item" in purchase.product_ids and \
            purchase.purchase_state == BillingClient.PurchaseState.PURCHASED and \
            not purchase.is_acknowledged:
        # Add code to store payment so we can reconcile the purchase token
        # in the completion callback against the original purchase
        billing_client.acknowledge_purchase(purchase.purchase_token)

func _on_acknowledge_purchase_response(result: Dictionary):
    if result.response_code == BillingClient.BillingResponseCode.OK:
        print("Acknowledge purchase success")
        _handle_purchase_token(result.token, true)
    else:
        print("Acknowledge purchase failed")
        print("response_code: ", result.response_code, "debug_message: ", result.debug_message, "purchase_token: ", result.token)

# Find the product associated with the purchase token and award the
# product if successful
func _handle_purchase_token(purchase_token, purchase_successful):
    # check/award logic, remove purchase from tracking list</literal_block>
            </section>
            <section ids="subscriptions" names="subscriptions">
                <title>Subscriptions</title>
                <paragraph>Subscriptions work mostly like regular in-app items. Use <literal>BillingClient.ProductType.SUBS</literal> as the second
                    argument to <literal>query_product_details()</literal> to get subscription details. Pass <literal>BillingClient.ProductType.SUBS</literal>
                    to <literal>query_purchases()</literal> to get subscription purchase details.</paragraph>
                <paragraph>You can check <literal>is_auto_renewing</literal> in the a subscription purchase
                    returned from <literal>query_purchases()</literal> to see if a user has cancelled an
                    auto-renewing subscription.</paragraph>
                <paragraph>You need to acknowledge new subscription purchases, but not automatic
                    subscription renewals.</paragraph>
                <paragraph>If you support upgrading or downgrading between different subscription levels,
                    you should use <literal>update_subscription()</literal> to use the subscription update flow to
                    change an active subscription. Like <literal>purchase()</literal>, results are returned by the
                    <literal>on_purchases_updated</literal> signal.
                    These are the parameters of <literal>update_subscription()</literal>:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>old_purchase_token: The purchase token of the currently active subscription</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>replacement_mode: The replacement mode to apply to the subscription</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>product_id: The product ID of the new subscription to switch to</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>base_plan_id: The base plan ID of the target subscription</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>offer_id: The offer ID under the base plan (optional)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>is_offer_personalized: Whether to enable personalized pricing (optional)</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>The replacement modes values are defined as:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Access in your script as: BillingClient.ReplacementMode.WITH_TIME_PRORATION
enum ReplacementMode {
    # Unknown...
    UNKNOWN_REPLACEMENT_MODE = 0,

    # The new plan takes effect immediately, and the remaining time will be prorated and credited to the user.
    # Note: This is the default behavior.
    WITH_TIME_PRORATION = 1,

    # The new plan takes effect immediately, and the billing cycle remains the same.
    CHARGE_PRORATED_PRICE = 2,

    # The new plan takes effect immediately, and the new price will be charged on next recurrence time.
    WITHOUT_PRORATION = 3,

    # Replacement takes effect immediately, and the user is charged full price of new plan and
    # is given a full billing cycle of subscription, plus remaining prorated time from the old plan.
    CHARGE_FULL_PRICE = 5,

    # The new purchase takes effect immediately, the new plan will take effect when the old item expires.
    DEFERRED = 6,
}</literal_block>
                <paragraph>Default behavior is <literal>WITH_TIME_PRORATION</literal>.</paragraph>
                <paragraph>Example use of <literal>update_subscription</literal>:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">billing_client.update_subscription(_active_subscription_purchase.purchase_token, \
                    BillingClient.ReplacementMode.WITH_TIME_PRORATION, "new_sub_product_id", "base_plan_id")</literal_block>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
