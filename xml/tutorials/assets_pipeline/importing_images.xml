<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/assets_pipeline/importing_images.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-importing-images"></target>
    <section ids="importing-images doc-importing-images" names="importing\ images 导入图像 doc_importing_images">
        <title>导入图像</title>
        <section ids="supported-image-formats" names="supported\ image\ formats 支持的图像格式">
            <title>支持的图像格式</title>
            <paragraph>Godot 可以导入以下图像格式：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>BMP（<literal>.bmp</literal>）——不支持每像素 16 位的图像。只支持每像素 1 位、4 位、8 位、24 位和 32 位的图像。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>DirectDraw Surface（<literal>.dds</literal>）——如果纹理中存在 mipmap，则直接加载。可以使用自定义 mipmap 制作特效。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Khronos 纹理 (<literal>.ktx</literal>) —— 使用 <reference name="libktx" refuri="https://github.com/KhronosGroup/KTX-Software">libktx</reference> 解码。仅支持 2D 图像。不支持立方体贴图、纹理数组和去填充（de-padding）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>OpenEXR（<literal>.exr</literal>）——支持 HDR（强烈推荐使用在全景天空上）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Radiance HDR（<literal>.hdr</literal>）——支持 HDR（强烈推荐使用在全景天空上）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>JPEG（<literal>.jpg</literal>、<literal>.jpeg</literal>）——由于该格式的限制，不支持透明度。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>PNG（<literal>.png</literal>）——导入时精度限制为每个通道 8 位（无 HDR 图像）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Truevision Targa（<literal>.tga</literal>）</paragraph>
                </list_item>
                <list_item>
                    <paragraph>SVG (<literal>.svg</literal>)
                        - SVGs are rasterized using <reference name="ThorVG" refuri="https://www.thorvg.org/">ThorVG</reference>
                        when importing them. <reference name="Support is limited" refuri="https://www.thorvg.org/about#:~:text=among%20the%20svg%20tiny%20specs%2C%20yet%20unsupported%20features%20in%20the%20thorvg%20are%20the%20following">Support is limited</reference>;
                        complex vectors may not render correctly. <reference internal="True" refid="doc-importing-images-svg-text"><inline classes="std std-ref">Text must be converted to paths</inline></reference>;
                        otherwise, it won't appear in the rasterized image.
                        You can check whether ThorVG can render a certain vector correctly using its
                        <reference name="web-based viewer" refuri="https://www.thorvg.org/viewer">web-based viewer</reference>.
                        For complex vectors, rendering them to PNGs using <reference name="Inkscape" refuri="https://inkscape.org/">Inkscape</reference>
                        is often a better solution. This can be automated thanks to its
                        <reference name="command-line interface" refuri="https://wiki.inkscape.org/wiki/index.php/Using_the_Command_Line#Export_files">command-line interface</reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>WebP（<literal>.webp</literal>）——WebP 文件支持透明，也支持有损和无损压缩。精度限制是每通道 8 位。</paragraph>
                </list_item>
            </bullet_list>
            <note>
                <paragraph>如果你从源代码编译 Godot 编辑器时禁用了特定的模块，某些格式可能无法使用。</paragraph>
            </note>
        </section>
        <section ids="importing-textures" names="importing\ textures 导入纹理">
            <title>导入纹理</title>
            <paragraph>Godot 中的默认操作是将图像导入为纹理。纹理存储在显存中。纹理的像素数据无法直接从 CPU 访问，除非在脚本中将它们转换回 <reference internal="True" refuri="../../classes/class_image#class-image"><inline classes="std std-ref">Image</inline></reference>。这就是使绘制纹理变得高效的原因。</paragraph>
            <paragraph>在文件系统面板中选择图像后，可以调整十多个导入选项：</paragraph>
            <figure align="center" ids="id1">
                <image alt="在文件系统面板中选择图像后，导入面板中的导入选项" candidates="{'*': 'tutorials/assets_pipeline/img/importing_images_import_dock.webp'}" uri="tutorials/assets_pipeline/img/importing_images_import_dock.webp"></image>
                <caption>在文件系统面板中选择图像后，导入扩展面板中的导入选项。其中一些选项仅在某些压缩模式下可见。</caption>
            </figure>
            <target refid="doc-importing-images-changing-import-type"></target>
            <section ids="changing-import-type doc-importing-images-changing-import-type" names="changing\ import\ type 更改导入类型 doc_importing_images_changing_import_type">
                <title>更改导入类型</title>
                <paragraph>可以在“导入”面板中选择其他导入资源的类型：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>BitMap：</strong> 1 位单色纹理（旨在用作 <reference internal="True" refuri="../../classes/class_texturebutton#class-texturebutton"><inline classes="std std-ref">TextureButton</inline></reference> 和 <reference internal="True" refuri="../../classes/class_touchscreenbutton#class-touchscreenbutton"><inline classes="std std-ref">TouchScreenButton</inline></reference> 中的点击遮罩）。此资源类型无法直接显示在 2D 或 3D 节点上，但可以使用 <reference internal="True" refuri="../../classes/class_bitmap#class-bitmap-method-get-bit"><inline classes="std std-ref">get_bit</inline></reference> 从脚本中查询像素值。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Cubemap：</strong> 将纹理导入为 6 面的立方体贴图，并在立方体贴图的侧面（无缝立方体贴图）之间进行插值，可以在自定义着色器中进行采样。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>CubemapArray：</strong> 将纹理导入为 6 面立方体贴图的集合，可以在自定义着色器中进行采样。此资源类型仅在使用 Forward+ 或 Forward 移动渲染方法时才能显示，而在兼容渲染方法是不能显示。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Font Data (Monospace Image Font)：</strong> （字体数据，等宽图像字体）将图像导入为位图字体，其中所有字符都具有相同的宽度。请参阅 <reference internal="True" refuri="../ui/gui_using_fonts#doc-gui-using-fonts"><inline classes="std std-ref">使用字体</inline></reference>。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Image：</strong> 按原样导入图像。此资源类型无法直接显示在 2D 或 3D 节点上，但可以使用 <reference internal="True" refuri="../../classes/class_image#class-image-method-get-pixel"><inline classes="std std-ref">get_pixel</inline></reference> 从脚本中查询像素值。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Texture2D：</strong> 将图像导入为 2 维纹理，适合在 2D 和 3D 表面上显示。这是默认的导入模式。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Texture2DArray：</strong> 将图像导入为二维纹理的集合。 Texture2DArray 类似于 3 维纹理，但层之间没有插值。内置 2D 和 3D 着色器无法显示纹理数组，因此必须在 <reference internal="True" refuri="../shaders/shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">2D</inline></reference> 或 <reference internal="True" refuri="../shaders/shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">3D</inline></reference> 中创建自定义着色器，以显示纹理数组中的纹理。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Texture3D：</strong> 将图像导入为 3 维纹理。这 <emphasis>不是</emphasis> 应用到 3D 表面上的 2D 纹理。 Texture3D 类似于纹理数组，但在层之间进行插值。 Texture3D 通常用于 <reference internal="True" refuri="../3d/volumetric_fog#doc-volumetric-fog"><inline classes="std std-ref">体积雾</inline></reference> 、 <reference internal="True" refuri="../../classes/class_environment#class-environment"><inline classes="std std-ref">Environment</inline></reference> 3D LUT 颜色校正和自定义着色器中的 <reference internal="True" refuri="../../classes/class_fogmaterial#class-fogmaterial"><inline classes="std std-ref">FogMaterial</inline></reference> 密度图。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>TextureAtlas：</strong> 将图像导入为不同纹理的 <emphasis>图集</emphasis> 。可用于减少动画 2D 精灵的内存使用量。由于缺少内置 3D 着色器的支持，仅支持 2D。</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="detect-3d" names="detect\ 3d 检测\ 3d">
                <title>检测 3D</title>
                <paragraph>默认的导入选项（不带 mipmap 并且使用 <strong>Lossless</strong> 压缩）适合 2D，对于大多数 3D 项目而言并不理想。<strong>检测 3D</strong>能够让 Godot 关注纹理在 3D 场景中的使用（例如用作 <reference internal="True" refuri="../../classes/class_basematerial3d#class-basematerial3d"><inline classes="std std-ref">BaseMaterial3D</inline></reference> 的纹理）。一旦使用，就会将部分导入选项进行修改，这样纹理标志就对 3D 更友好。除非修改了 <reference internal="True" refid="doc-importing-images-detect-3d-compress-to"><inline classes="std std-ref">检查 3D &gt; 压缩至</inline></reference>，否则此时就会启用 mipmap 并将压缩模式修改为 <strong>VRAM Compressed</strong>。纹理会自动进行重新导入。</paragraph>
                <paragraph>检测到纹理在 3D 中使用时会在“输出”面板中打印一个消息。</paragraph>
                <paragraph>如果纹理检测到在 3D 中使用后遇到了质量问题（例如像素风纹理），请在用于 3D 之前修改 <reference internal="True" refid="doc-importing-images-detect-3d-compress-to"><inline classes="std std-ref">检查 3D &gt; 压缩至</inline></reference> 选项，或者在用于 3D 之后将 <reference internal="True" refid="doc-importing-images-compress-mode"><inline classes="std std-ref">压缩 &gt; 模式</inline></reference> 修改为 <strong>Lossless</strong>。这样比禁用<strong>检测 3D</strong> 更好，因为仍然会启用 mipmap 生成，从远处观察纹理就不会感觉模糊。</paragraph>
            </section>
        </section>
        <section ids="import-options" names="import\ options 导入选项">
            <title>导入选项</title>
            <seealso>
                <paragraph>在 Godot 4.0 中，对纹理过滤模式以及重复模式的修改不再位于导入选项中。</paragraph>
                <paragraph>现在，2D 中需要在 CanvasItem 的属性中对纹理过滤模式和重复模式进行修改（项目设置中可以设置默认值），3D 中则是<reference internal="True" refuri="../3d/standard_material_3d#doc-standard-material-3d-sampling"><inline classes="std std-ref">针对材质进行配置</inline></reference>。在自定义着色器中，<literal>sampler2D</literal> uniform 的过滤和重复模式使用提示修改，见 <reference internal="True" refuri="../shaders/shader_reference/shading_language#doc-shading-language"><inline classes="std std-ref">着色语言</inline></reference> 文档。</paragraph>
            </seealso>
            <target refid="doc-importing-images-compress-mode"></target>
            <section ids="compress-mode doc-importing-images-compress-mode" names="compress\ &gt;\ mode 压缩\ &gt;\ 模式 doc_importing_images_compress_mode">
                <title>压缩 &gt; 模式</title>
                <paragraph>图像是游戏中最大的资产之一。要实现高效的处理，就需要进行压缩。Godot 提供了很多压缩方法，可以根据实际情况选用。</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Lossless：</strong>无损压缩。这是 2D 资产的默认压缩模式，也是最常用的压缩模式。显示资产时不会有任何失真，磁盘压缩也比较合适。但如果与 VRAM 压缩相比，使用的显存就明显要更多。这也是像素画的推荐设置。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Lossy：</strong>有损压缩。适合较大的 2D 资产。会有一些失真，但是比 VRAM 压缩要少，文件大小比无损压缩以及 VRAM 未压缩要小好几倍。这个模式不会降低显存占用；与无损压缩和 VRAM 未压缩相同。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>VRAM Compressed：</strong>VRAM 压缩。这是 3D 资产的默认压缩模式，也是最常用的压缩模式。会降低磁盘上的大小，显存占用也会显著降低（通常是 4 到 6 倍）。应该避免在 2D 中使用这个模式，因为会有明显的失真，在低分辨率纹理上尤为明显。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>VRAM Uncompressed：</strong>VRAM 未压缩。仅适用于不能压缩的格式，例如原始浮点数图像。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Basis Universal：</strong>这也是一种 VRAM 压缩模式，编码后的纹理格式为能够在加载时转码为大多数 GPU 压缩格式。这样得到的文件就很小，能够利用 VRAM 压缩，但相对于 VRAM 压缩而言质量较差，压缩耗时也更长。显存占用通常和 VRAM 压缩相同。Basis Universal 不支持浮点数图像格式（引擎会在内部回退至 VRAM 压缩）。</paragraph>
                    </list_item>
                </bullet_list>
                <note>
                    <paragraph>即便在 3D 中，“像素画”纹理也应该禁用 VRAM 压缩，因为压缩会对外观产生负面影响，较低的分辨率也无法得到显著的性能提升。</paragraph>
                </note>
                <paragraph>这张表对这五个选项进行了横向比较，列出了各自的优缺点（<image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> = 最好、<image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> = 最差）：</paragraph>
                <table>
                    <tgroup cols="6">
                        <colspec colwidth="18"></colspec>
                        <colspec colwidth="31"></colspec>
                        <colspec colwidth="22"></colspec>
                        <colspec colwidth="54"></colspec>
                        <colspec colwidth="24"></colspec>
                        <colspec colwidth="38"></colspec>
                        <thead>
                            <row>
                                <entry>
                                    <paragraph>压缩模式</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Lossless</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Lossy</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>VRAM Compressed</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>VRAM Uncompressed</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Basis Universal</paragraph>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph><strong>描述</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>存储为无损 WebP / PNG</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>存储为有损 WebP</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>根据平台不同，存储为 S3TC、BPTC 或 ETC2</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>存储为原始像素</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>转码至 VRAM Compressed 格式</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>磁盘占用</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" uri="tutorials/assets_pipeline/img/regular.png"></image> 小</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 非常小</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" uri="tutorials/assets_pipeline/img/regular.png"></image> 小</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 大</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 非常小</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>内存占用</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 大</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 大</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 小</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 大</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 小</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>性能</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" uri="tutorials/assets_pipeline/img/regular.png"></image> 普通</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" uri="tutorials/assets_pipeline/img/regular.png"></image> 普通</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 快</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" uri="tutorials/assets_pipeline/img/regular.png"></image> 普通</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 快</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>质量损失</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 无</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" uri="tutorials/assets_pipeline/img/regular.png"></image> 轻微</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 中等</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 无</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 中等</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>加载时间</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 慢</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 慢</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 快</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" uri="tutorials/assets_pipeline/img/regular.png"></image> 普通</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" uri="tutorials/assets_pipeline/img/regular.png"></image> 普通</paragraph>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <substitution_definition names="bad"><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image></substitution_definition>
                <substitution_definition names="good"><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image></substitution_definition>
                <substitution_definition names="regular"><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" uri="tutorials/assets_pipeline/img/regular.png"></image></substitution_definition>
                <paragraph>单张 RGBA8 纹理启用 mipmap 后的预估内存占用：</paragraph>
                <table>
                    <tgroup cols="6">
                        <colspec colwidth="15"></colspec>
                        <colspec colwidth="21"></colspec>
                        <colspec colwidth="21"></colspec>
                        <colspec colwidth="21"></colspec>
                        <colspec colwidth="21"></colspec>
                        <colspec colwidth="21"></colspec>
                        <thead>
                            <row>
                                <entry>
                                    <paragraph>纹理大小</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Lossless</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Lossy</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>VRAM Compressed</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>VRAM Uncompressed</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Basis Universal</paragraph>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph><strong>128×128</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 85 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 85 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 21 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 85 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 21 KiB</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>256×256</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 341 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 341 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 85 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 341 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 85 KiB</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>512×512</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 1.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 1.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 341 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 1.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 341 KiB</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>1024×1024</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" uri="tutorials/assets_pipeline/img/regular.png"></image> 5.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" uri="tutorials/assets_pipeline/img/regular.png"></image> 5.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 1.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" uri="tutorials/assets_pipeline/img/regular.png"></image> 5.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" uri="tutorials/assets_pipeline/img/good.png"></image> 1.33 MiB</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>2048×2048</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 21.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 21.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" uri="tutorials/assets_pipeline/img/regular.png"></image> 5.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 21.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" uri="tutorials/assets_pipeline/img/regular.png"></image> 5.33 MiB</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>4096×4096</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 85.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 85.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 21.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 85.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" uri="tutorials/assets_pipeline/img/bad.png"></image> 21.33 MiB</paragraph>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <note>
                    <paragraph>在上表中，没有 Alpha 通道 (RGB8) 的图像，内存使用量将减少 25%。禁用了 mipmap 的图像，内存使用量将进一步减少 25%。</paragraph>
                </note>
                <paragraph>请注意，在分辨率较高的情况下，VRAM 压缩的影响要大得多。 当 VRAM 压缩采用 4:1 的压缩比（对于 S3TC 的不透明纹理为 6:1）时，可以在 GPU 上使用相同数量显存的同时，有效地使纹理在每个轴上增大两倍。</paragraph>
                <paragraph>VRAM 压缩还减少了采样纹理所需的内存带宽，这可以加快在内存带宽受限场景中（集成显卡和移动设备上常见）的渲染速度。综合这些因素，对于具有高分辨率纹理的 3D 游戏来说，VRAM 压缩技术是必备条件之一。</paragraph>
                <paragraph>可以在文件系统停靠栏中双击纹理，然后查看检查器，来预览纹理占用的内存量：</paragraph>
                <figure align="center" ids="id2">
                    <image alt="在检查器中预览纹理" candidates="{'*': 'tutorials/assets_pipeline/img/importing_images_inspector_preview.webp'}" uri="tutorials/assets_pipeline/img/importing_images_inspector_preview.webp"></image>
                    <caption>在检查器中预览纹理。图片来源：<reference name="Red Brick 03 - Poly Haven" refuri="https://polyhaven.com/a/red_brick_03">Red Brick 03 - Poly Haven</reference></caption>
                </figure>
            </section>
            <section ids="compress-high-quality" names="compress\ &gt;\ high\ quality 压缩\ &gt;\ 高质量">
                <title>压缩 &gt; 高质量</title>
                <note>
                    <paragraph>高质量 VRAM 纹理压缩仅在 Forward+ 和 Forward 移动渲染方法中受支持。</paragraph>
                    <paragraph>使用兼容渲染方法时，此选项始终被视为禁用。</paragraph>
                </note>
                <paragraph>如果启用，则会在桌面平台上使用 BPTC 压缩，而在移动平台上使用 <abbreviation explanation="Adaptive Scalable Texture Compression, 自适应可扩展纹理压缩">ASTC</abbreviation> 来进行压缩。使用BPTC 时，BC7 用于 SDR 纹理，BC6H 用于 HDR 纹理。</paragraph>
                <paragraph>如果禁用（默认），则在桌面平台上使用速度更快但质量较低的 S3TC 压缩，在移动/Web 平台上使用 ETC2。使用 S3TC 时，DXT1 (BC1) 用于不透明纹理，DXT5 (BC3) 用于透明或法线贴图（ <abbreviation explanation="Red-Green Texture Compression">RGTC</abbreviation>）纹理。</paragraph>
                <paragraph>BPTC 和 ASTC 支持 HDR 纹理的 VRAM 压缩，但 S3TC 和 ETC2 不支持（请参阅下面的 <strong>HDR 压缩</strong> ）。</paragraph>
            </section>
            <section ids="compress-hdr-compression" names="compress\ &gt;\ hdr\ compression 压缩\ &gt;\ hdr\ 压缩">
                <title>压缩 &gt; HDR 压缩</title>
                <note>
                    <paragraph>此选项仅对在 Godot 中以 HDR 格式导入的纹理（ <literal>.hdr</literal> 和 <literal>.exr</literal> 文件）有影响。</paragraph>
                </note>
                <paragraph>如果设置为 <strong>禁用</strong>，则无论 HDR 纹理是否透明，都不会使用 VRAM 压缩。相反，纹理会被转换为 RGBE9995（每个通道 9 位 + 5 位指数 = 每个像素 32 位），以减少内存使用量（与半浮点或单精度浮点图像格式相比）。</paragraph>
                <paragraph>如果设置为 <strong>Opaque Only</strong>（默认），则只对不透明的 HDR 纹理使用 VRAM 压缩。这是由于 HDR 格式的限制，因为没有同时支持透明度的 VRAM 压缩 HDR 格式。</paragraph>
                <paragraph>如果设置为 <strong>Always</strong> ，即使是带有 alpha 通道的 HDR 纹理也会强制压缩 VRAM。为此，在导入时会丢弃 alpha 通道。</paragraph>
            </section>
            <section ids="compress-normal-map" names="compress\ &gt;\ normal\ map 压缩\ &gt;\ 法线贴图">
                <title>压缩 &gt; 法线贴图</title>
                <paragraph>将纹理用作法线贴图时，仅需要红色和绿色通道。鉴于常规纹理压缩算法产生的伪影在法线贴图中看起来不太好， <abbreviation explanation="Red-Green Texture Compression">RGTC</abbreviation> 压缩格式最适合这种数据。将此选项强制设置为 <strong>Enabled</strong> 将使 Godot 导入 <abbreviation explanation="Red-Green Texture Compression">RGTC</abbreviation> 压缩的图像。默认情况下，它被设置为 <strong>Detect</strong> ，这意味着如果纹理一旦被用作法线贴图，则会将其更改为 <strong>Enabled</strong> 并自动重新导入。</paragraph>
                <paragraph>请注意， <abbreviation explanation="Red-Green Texture Compression">RGTC</abbreviation> 压缩会影响生成的法线贴图图像。你必须调整使用法线贴图蓝色通道的自定义着色器，以便将此考虑在内。内置材质着色器已经忽略了法线贴图中的蓝色通道（与实际法线贴图的内容无关）。</paragraph>
                <paragraph>在下面的示例中，采用 <abbreviation explanation="Red-Green Texture Compression">RGTC</abbreviation> 压缩技术的法线贴图能够更好地保留细节，同时使用与标准 RGBA VRAM 压缩贴图相同的内存量：</paragraph>
                <figure align="center" ids="id3">
                    <image alt="使用标准 VRAM 压缩的正常贴图（左）和使用 RGTC VRAM 压缩的正常贴图（右）" candidates="{'*': 'tutorials/assets_pipeline/img/importing_images_normal_map_rgtc.webp'}" uri="tutorials/assets_pipeline/img/importing_images_normal_map_rgtc.webp"></image>
                    <caption>使用标准 VRAM 压缩的正常贴图（左）和使用 RGTC VRAM 压缩的正常贴图（右）</caption>
                </figure>
                <note>
                    <paragraph>Godot 需要法线贴图使用 X+、Y+、Z+ 坐标，即 OpenGL 风格的法线贴图。如果你导入了用于其他引擎的材质，它可能使用的是 DirectX 风格。在这种情况下，就需要通过启用 <strong>法线贴图反转 Y</strong> 导入选项来转换法线贴图。</paragraph>
                    <paragraph>可以在 <reference name="这里" refuri="http://wiki.polycount.com/wiki/Normal_Map_Technical_Details">这里</reference> 找到关于法线贴图(包括常见引擎的坐标顺序表)的更多信息.</paragraph>
                </note>
            </section>
            <section ids="compress-channel-pack" names="compress\ &gt;\ channel\ pack 压缩\ &gt;\ 通道打包">
                <title>压缩 &gt; 通道打包</title>
                <paragraph>如果设置为 <strong>sRGB Friendly</strong>（默认），则会阻止使用 RG 颜色格式，因为它不支持 sRGB 颜色。</paragraph>
                <paragraph>如果设置为**Optimized**，则在纹理不使用蓝色通道的情况下允许使用 RG 颜色格式。</paragraph>
                <paragraph>第三个选项 <strong>Normal Map (RG Channels)</strong> <emphasis>仅</emphasis>适用于分层纹理（<reference internal="True" refuri="../../classes/class_cubemap#class-cubemap"><inline classes="std std-ref">Cubemap</inline></reference>、<reference internal="True" refuri="../../classes/class_cubemaparray#class-cubemaparray"><inline classes="std std-ref">CubemapArray</inline></reference>、<reference internal="True" refuri="../../classes/class_texture2darray#class-texture2darray"><inline classes="std std-ref">Texture2DArray</inline></reference> 和 <reference internal="True" refuri="../../classes/class_texture3d#class-texture3d"><inline classes="std std-ref">Texture3D</inline></reference>）。这将强制以 RG 颜色格式导入纹理的所有图层，以减少内存使用，只保留红色和绿色通道。这只会对使用 <strong>VRAM Compressed</strong> 或 <strong>Basis Universal</strong> 压缩模式的纹理产生影响。</paragraph>
                <target refid="doc-importing-images-mipmaps"></target>
            </section>
            <section ids="mipmaps-generate doc-importing-images-mipmaps" names="mipmaps\ &gt;\ generate mipmap\ &gt;\ 生成 doc_importing_images_mipmaps">
                <title>Mipmap &gt; 生成</title>
                <paragraph>如果启用，则会在导入时生成较小版本的纹理。例如，一个 64×64 的纹理会生成 6 个 mipmap（32×32、16×16、8×8、4×4、2×2、1×1）。这样做有几个好处：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>纹理在远处（三维）或因相机缩放或 CanvasItem 缩放而缩小（二维）时不会变得粗糙。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>如果纹理在远处显示，性能会有所提高，因为对原始纹理的较小版本进行采样速度更快，所需的内存带宽也更少。</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Mipmap 的缺点是会增加大约 33% 的内存使用量。</paragraph>
                <paragraph>建议在 3D 中启用多级渐进纹理（Mipmap）。但在 2D 中，只有在项目明显受益于启用多级渐进纹理时才应启用。如果摄像机从未大幅缩放，则启用 Mipmap 不会带来任何好处，反而会增加内存使用量。</paragraph>
            </section>
            <section ids="mipmaps-limit" names="mipmaps\ &gt;\ limit mipmap\ &gt;\ 限制">
                <title>Mipmap &gt; 限制</title>
                <warning>
                    <paragraph><strong>Mipmap &gt; 限制</strong> 当前未实现，更改该设置也无效。</paragraph>
                </warning>
                <paragraph>如果设置的值大于 <literal>-1</literal> ，则会限制可生成的 mipmap 的最大数量。如果不希望纹理在极远距离上变得分辨率过低，可以减少该值，但代价是会产生一些颗粒感。</paragraph>
            </section>
            <section ids="roughness-mode" names="roughness\ &gt;\ mode 粗糙度\ &gt;\ 模式">
                <title>粗糙度 &gt; 模式</title>
                <paragraph>将此纹理视为粗糙度贴图的颜色通道。仅当 <strong>粗糙度 &gt; 原法线</strong> 不为空时才有效。</paragraph>
            </section>
            <section ids="roughness-src-normal" names="roughness\ &gt;\ src\ normal">
                <title>Roughness &gt; Src Normal</title>
                <paragraph>纹理的路径被视为导入时粗糙度过滤（roughness filtering）的法线贴图。指定此项有助于略微减少 3D 中的镜面反射锯齿。</paragraph>
                <paragraph>导入时的粗糙度过滤仅用于 3D 渲染，不适用于 2D。</paragraph>
            </section>
            <section ids="process-fix-alpha-border" names="process\ &gt;\ fix\ alpha\ border 处理\ &gt;\ 修复\ alpha\ 边框">
                <title>处理 &gt; 修复 Alpha 边框</title>
                <paragraph>这样会使周围颜色相同的像素从透明过渡到非透明。对于使用双线性过滤显示的纹理，这有助于减轻从图像编辑器导出图像时的轮廓效果。</paragraph>
                <image candidates="{'*': 'tutorials/assets_pipeline/img/fixedborder.png'}" uri="tutorials/assets_pipeline/img/fixedborder.png"></image>
                <paragraph>建议启用此功能（默认情况下），除非这会导致特定图像出现问题。</paragraph>
            </section>
            <section ids="process-premult-alpha" names="process\ &gt;\ premult\ alpha 处理\ &gt;\ 预乘\ alpha">
                <title>处理 &gt; 预乘 Alpha</title>
                <paragraph>使用 <strong>修复 Alpha 边框</strong> 修复变暗边框的另一种方法是使用预乘 Alpha。通过启用此选项，纹理将转换为此格式。预乘 Alpha 纹理需要特定材质才能正确显示：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>在 2D 中，需要创建并配置 <reference internal="True" refuri="../../classes/class_canvasitemmaterial#class-canvasitemmaterial"><inline classes="std std-ref">CanvasItemMaterial</inline></reference>，以便在使用此纹理的 CanvasItem 上使用 <strong>预乘 Alpha</strong> 混合模式。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>在 3D 中，尚且不支持预乘 alpha 混合模式，因此，这个选项仅适用于 2D。</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="process-normal-map-invert-y" names="process\ &gt;\ normal\ map\ invert\ y 处理\ &gt;\ 法线贴图翻转\ y">
                <title>处理 &gt; 法线贴图翻转 Y</title>
                <paragraph>Godot 需要法线贴图使用 X+、Y+、Z+ 坐标，即 OpenGL 风格的法线贴图。如果你导入了用于其他引擎的材质，它可能使用的是 DirectX 风格。在这种情况下，就需要通过启用 <strong>法线贴图反转 Y</strong> 导入选项来转换法线贴图。</paragraph>
                <paragraph>可以在 <reference name="这里" refuri="http://wiki.polycount.com/wiki/Normal_Map_Technical_Details">这里</reference> 找到关于法线贴图(包括常见引擎的坐标顺序表)的更多信息.</paragraph>
            </section>
            <section ids="process-hdr-as-srgb" names="process\ &gt;\ hdr\ as\ srgb 处理\ &gt;\ hdr\ 作为\ srgb">
                <title>处理 &gt; HDR 作为 sRGB</title>
                <paragraph>你能在网上找到的一些 HDR 图像可能已损坏，并包含 sRGB 颜色数据（而不是线性颜色数据）。建议不要使用这些文件。如果你绝对必须需要这样做，启用此选项将使这些文件看起来是正常的。</paragraph>
                <warning>
                    <paragraph>在格式良好的 HDR 图像上启用 <strong>HDR 作为 sRGB</strong> 会导致生成的图像看起来太暗。因此，如果你不确定，请将此选项禁用。</paragraph>
                </warning>
            </section>
            <section ids="process-hdr-clamp-exposure" names="process\ &gt;\ hdr\ clamp\ exposure 处理\ &gt;\ hdr\ 限制曝光">
                <title>处理 &gt; HDR 限制曝光</title>
                <paragraph>你能在网上找到的一些 HDR 全景图像中可能包含非常明亮的像素，因为这些图像直接取自于现实生活，没有经过任何裁剪处理。</paragraph>
                <paragraph>虽然这些 HDR 全景图像与现实生活非常接近，但在用作天空背景时，这可能会导致 Godot 生成的辐射度贴图包含闪烁。这可以在材质反射中看到（在极端情况下甚至可以在粗糙的材质上看到）。启用 <strong>HDR Clamp Exposure</strong> 可以解决这个问题，它使用的是一种智能钳制公式，不会引入 <emphasis>可见的</emphasis> 裁剪 -- 当观察背景天空时，辉光将继续发挥作用。</paragraph>
            </section>
            <section ids="process-size-limit" names="process\ &gt;\ size\ limit 处理\ &gt;\ 大小限制">
                <title>处理 &gt; 大小限制</title>
                <paragraph>如果设置为大于“0”的值，则纹理的大小会在导入时被限制至小于等于该值。对于非正方形纹理，尺寸限制会影响较长边，并且会缩放较短边以保持纵横比。调整大小使用三次插值法。</paragraph>
                <paragraph>这可以用于在不影响源图像的情况下减少内存使用，或避免在移动/网络平台上纹理无法显示的问题（因为这些平台通常无法显示大于4096×4096的纹理）。</paragraph>
                <target refid="doc-importing-images-detect-3d-compress-to"></target>
            </section>
            <section ids="detect-3d-compress-to doc-importing-images-detect-3d-compress-to" names="detect\ 3d\ &gt;\ compress\ to 检查\ 3d\ &gt;\ 压缩至 doc_importing_images_detect_3d_compress_to">
                <title>检查 3D &gt; 压缩至</title>
                <paragraph>这会改变当检测到纹理被用于 3D 时使用的 <reference internal="True" refid="doc-importing-images-compress-mode"><inline classes="std std-ref">压缩 &gt; 模式</inline></reference> 选项。</paragraph>
                <paragraph>只有当检测到纹理被用于 3D 时，更改这个导入选项才会生效。将其更改为**禁用**然后重新导入不会改变纹理上已有压缩模式（如果它被检测到用于3D），但选择 <strong>VRAM压缩**或 **Basis Universal</strong> 则会改变。</paragraph>
            </section>
            <section ids="svg-scale" names="svg\ &gt;\ scale svg\ &gt;\ 缩放">
                <title>SVG &gt; 缩放</title>
                <paragraph><emphasis>这仅适用于 SVG 图像。</emphasis></paragraph>
                <paragraph>SVG 应呈现的比例，其中 <literal>1.0</literal> 为原始设计尺寸。数值越大，图像越大。请注意，与字体过采样不同，这会影响 SVG 在 2D 中呈现的物理尺寸。另请参阅下面的 <strong>编辑器 &gt; 使用编辑器缩放比例</strong> 。</paragraph>
                <target refid="doc-importing-images-editor-import-options"></target>
            </section>
            <section ids="editor-scale-with-editor-scale doc-importing-images-editor-import-options" names="editor\ &gt;\ scale\ with\ editor\ scale 编辑器\ &gt;\ 使用编辑器缩放 doc_importing_images_editor_import_options">
                <title>编辑器 &gt; 使用编辑器缩放</title>
                <paragraph><emphasis>这仅适用于 SVG 图像。</emphasis></paragraph>
                <paragraph>如果为 true，则会缩放导入的图像以匹配编辑器的显示比例因子。应该为编辑器插件图标和自定义类图标启用此功能，否则这个功能应保持禁用状态。</paragraph>
            </section>
            <section ids="editor-convert-colors-with-editor-theme" names="editor\ &gt;\ convert\ colors\ with\ editor\ theme">
                <title>Editor &gt; Convert Colors With Editor Theme</title>
                <paragraph><emphasis>这仅适用于 SVG 图像。</emphasis></paragraph>
                <paragraph>如果选中，则会转换导入图像的颜色以匹配编辑器的图标和字体调色板。这假设图像使用与 ref:' Godot 自己的编辑器图标： &lt;doc_editor_icons&gt;' 调色板完全相同的颜色，源文件是为深色编辑器主题设计的。这应该先启用编辑器插件图标和自定义类图标，否则应保持禁用状态。</paragraph>
                <target refid="doc-importing-images-svg-text"></target>
            </section>
        </section>
        <section ids="importing-svg-images-with-text doc-importing-images-svg-text" names="importing\ svg\ images\ with\ text doc_importing_images_svg_text">
            <title>Importing SVG images with text</title>
            <paragraph>由于 Godot 中使用的 SVG 库不支持对 SVG 图像中的文本进行光栅化，因此必须首先将文本转换为路径。否则，文本将不会出现在光栅化图像中。</paragraph>
            <paragraph>有两种方法可以无损地实现这一点，因此你可以在之后继续编辑原始文本：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Select your text object in Inkscape, then duplicate it in place by pressing
                        <literal classes="kbd">Ctrl + D</literal> and use <strong>Path &gt; Object to Path</strong>. Hide the original text
                        object afterwards using the <strong>Layers and Objects</strong> dock.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>使用 Inkscape 命令行从另一个 SVG 文件导出 SVG，并将文本转换为路径：</paragraph>
                </list_item>
            </bullet_list>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">inkscape --export-text-to-path --export-filename svg_with_text_converted_to_path.svg svg_with_text.svg</literal_block>
        </section>
        <section ids="best-practices" names="best\ practices 最佳实践">
            <title>最佳实践</title>
            <section ids="supporting-high-resolution-texture-sizes-in-2d-without-artifacts" names="supporting\ high-resolution\ texture\ sizes\ in\ 2d\ without\ artifacts 在2d中支持没有伪影的高分辨率纹理">
                <title>在2D中支持没有伪影的高分辨率纹理</title>
                <paragraph>为了在高分辨率下支持<reference internal="True" refuri="../rendering/multiple_resolutions#doc-multiple-resolutions"><inline classes="std std-ref">多种分辨率</inline></reference>并保持清晰的视觉效果，你需要使用高分辨率的源图像（适用于你希望支持的最高分辨率而不失真，通常在现代电脑桌面游戏中是 4K）。</paragraph>
                <paragraph>有两种方法可以做到这一点:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>在项目设置中使用较高基础分辨率（例如4K），然后以原始比例使用纹理。这是一种更简单的方法。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>在项目设置中使用较低基础分辨率（例如1080p），然后在使用纹理时进行缩小。这通常更加困难，并且可能使脚本中的各种计算变得繁琐，因此推荐使用上面介绍的方法。</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>在这样做之后，你可能会注意到在较低视口分辨率下纹理变得颗粒状。若要解决这个问题，在导入停靠面板中启用用于 2D 的纹理上的 <strong>Mipmaps</strong>。这将会增加内存使用。</paragraph>
                <paragraph>启用 mipmaps 也可能使纹理看起来更模糊，但你可以通过选择将**渲染 &gt; 纹理 &gt; 默认过滤器 &gt; 纹理 Mipmap 偏差**设置为负值来使纹理更清晰（代价是牺牲一些颗粒感）。</paragraph>
            </section>
            <section ids="use-appropriate-texture-sizes-in-3d" names="use\ appropriate\ texture\ sizes\ in\ 3d 在3d中使用适当的纹理大小">
                <title>在3D中使用适当的纹理大小</title>
                <paragraph>虽然没有“以不变应万变”的建议，但以下是一些在3D中选择纹理大小的一般建议：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>纹理的大小应该被调整为和周围物体相比具有一致的纹素密度。虽然在坚持使用 2 的幂的纹理大小时无法确保这一点，但通常可以在整个 3D 场景中保持相对一致的纹理细节。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>屏幕上出现的对象越小，其纹理就应该越小。例如，仅出现在背景中的树不需要玩家可能会走近的其他物体那样高的纹理分辨率。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>推荐但不必需使用 2 的幂的纹理大小。纹理不必是正方形——像 1024×512 这样的大小也是可以接受的。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>尽管使用较大纹理大小会增加内存使用和加载时间，但其带来的收益是递减的。大多数不使用像素艺术风格的现代 3D 游戏平均使用 2048×2048 的纹理，而对于覆盖较小表面的纹理则使用 1024×1024 和 512×512 。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>在 3D 中使用基于物理的材质时，你可以通过为某些纹理贴图使用较低的分辨率来减少内存使用和文件大小而不会过于影响质量。这对于仅包含低频细节特征的纹理（例如雪质地的法线贴图）特别有效。</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>如果你可以控制 3D 模型的建立过程，以下这些技巧也值得探索：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>在处理大部分对称的 3D 模型时，你能够使用镜像 UV 来使有效的纹素密度加倍。然而，在人脸上使用这种方法可能看起来不自然。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>在使用低多边形风格和纯色处理3D模型时，你可以依赖顶点颜色而非纹理来表示模型表面的颜色。</paragraph>
                    </list_item>
                </bullet_list>
                <seealso>
                    <paragraph>可以使用<reference internal="True" refuri="../io/runtime_file_loading_and_saving#doc-runtime-file-loading-and-saving-images"><inline classes="std std-ref">运行时文件加载和保存</inline></reference>在运行时加载和保存图像，包括从导出的项目中。</paragraph>
                </seealso>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
