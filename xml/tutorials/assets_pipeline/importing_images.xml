<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/assets_pipeline/importing_images.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-importing-images"></target>
    <section ids="importing-images doc-importing-images" names="importing\ images doc_importing_images">
        <title>Importing images</title>
        <section ids="supported-image-formats" names="supported\ image\ formats">
            <title>Supported image formats</title>
            <paragraph>Godot can import the following image formats:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>BMP (<literal>.bmp</literal>)
                        - No support for 16-bit per pixel images. Only 1-bit, 4-bit, 8-bit, 24-bit, and 32-bit per pixel images are supported.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>DirectDraw Surface (<literal>.dds</literal>)
                        - If mipmaps are present in the texture, they will be loaded directly.
                        This can be used to achieve effects using custom mipmaps.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Khronos Texture (<literal>.ktx</literal>)
                        - Decoding is done using <reference name="libktx" refuri="https://github.com/KhronosGroup/KTX-Software">libktx</reference>.
                        Only supports 2D images. Cubemaps, texture arrays and de-padding are not supported.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>OpenEXR (<literal>.exr</literal>)
                        - Supports HDR (highly recommended for panorama skies).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Radiance HDR (<literal>.hdr</literal>)
                        - Supports HDR (highly recommended for panorama skies).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>JPEG (<literal>.jpg</literal>, <literal>.jpeg</literal>)
                        - Doesn't support transparency per the format's limitations.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>PNG (<literal>.png</literal>)
                        - Precision is limited to 8 bits per channel upon importing (no HDR images).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Truevision Targa (<literal>.tga</literal>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph>SVG (<literal>.svg</literal>)
                        - SVGs are rasterized using <reference name="ThorVG" refuri="https://www.thorvg.org/">ThorVG</reference>
                        when importing them. <reference name="Support is limited" refuri="https://www.thorvg.org/about#:~:text=certain%20features%20remain%20unsupported%20within%20the%20current%20framework">Support is limited</reference>;
                        complex vectors may not render correctly. <reference internal="True" refid="doc-importing-images-svg-text"><inline classes="std std-ref">Text must be converted to paths</inline></reference>;
                        otherwise, it won't appear in the rasterized image.
                        You can check whether ThorVG can render a certain vector correctly using its
                        <reference name="web-based viewer" refuri="https://www.thorvg.org/viewer">web-based viewer</reference>.
                        For complex vectors, rendering them to PNGs using <reference name="Inkscape" refuri="https://inkscape.org/">Inkscape</reference>
                        is often a better solution. This can be automated thanks to its
                        <reference name="command-line interface" refuri="https://wiki.inkscape.org/wiki/index.php/Using_the_Command_Line#Export_files">command-line interface</reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>WebP (<literal>.webp</literal>)
                        - WebP files support transparency and can be compressed lossily or losslessly.
                        The precision is limited to 8 bits per channel.</paragraph>
                </list_item>
            </bullet_list>
            <note>
                <paragraph>If you've compiled the Godot editor from source with specific modules disabled,
                    some formats may not be available.</paragraph>
            </note>
        </section>
        <section ids="importing-textures" names="importing\ textures">
            <title>Importing textures</title>
            <paragraph>The default action in Godot is to import images as textures. Textures are stored
                in video memory. Their pixel data can't be accessed directly from the CPU
                without converting them back to an <reference internal="True" refuri="../../classes/class_image#class-image"><inline classes="std std-ref">Image</inline></reference> in a script. This is what
                makes drawing them efficient.</paragraph>
            <paragraph>There are over a dozen import options that can be adjusted after selecting an
                image in the FileSystem dock:</paragraph>
            <figure align="center" ids="id1">
                <image alt="Import options in the Import dock after selecting an image in the FileSystem dock" candidates="{'*': 'tutorials/assets_pipeline/img/importing_images_import_dock.webp'}" original_uri="img/importing_images_import_dock.webp" uri="tutorials/assets_pipeline/img/importing_images_import_dock.webp"></image>
                <caption>Import options in the Import dock after selecting an image in the FileSystem dock.
                    Some of these options are only visible with certain compression modes.</caption>
            </figure>
            <target refid="doc-importing-images-changing-import-type"></target>
            <section ids="changing-import-type doc-importing-images-changing-import-type" names="changing\ import\ type doc_importing_images_changing_import_type">
                <title>Changing import type</title>
                <paragraph>It is possible to choose other types of imported resources in the Import dock:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>BitMap:</strong> 1-bit monochrome texture (intended to be used as a click mask in
                            <reference internal="True" refuri="../../classes/class_texturebutton#class-texturebutton"><inline classes="std std-ref">TextureButton</inline></reference> and <reference internal="True" refuri="../../classes/class_touchscreenbutton#class-touchscreenbutton"><inline classes="std std-ref">TouchScreenButton</inline></reference>). This resource
                            type cannot be displayed directly onto 2D or 3D nodes, but the pixel values
                            can be queried from a script using <reference internal="True" refuri="../../classes/class_bitmap#class-bitmap-method-get-bit"><inline classes="std std-ref">get_bit</inline></reference>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Cubemap:</strong> Import the texture as a 6-sided cubemap, with interpolation
                            between the cubemap's sides (seamless cubemaps), which can be sampled in
                            custom shaders.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>CubemapArray:</strong> Import the texture as a collection of 6-sided cubemaps,
                            which can be sampled in custom shaders. This resource type can only be
                            displayed when using the Forward+ or Mobile renderers, not the Compatibility
                            renderer.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Font Data (Monospace Image Font):</strong> Import the image as a bitmap font where
                            all characters have the same width. See <reference internal="True" refuri="../ui/gui_using_fonts#doc-gui-using-fonts"><inline classes="std std-ref">Using Fonts</inline></reference>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Image:</strong> Import the image as-is. This resource type cannot be displayed
                            directly onto 2D or 3D nodes, but the pixel values can be queried from a
                            script using <reference internal="True" refuri="../../classes/class_image#class-image-method-get-pixel"><inline classes="std std-ref">get_pixel</inline></reference>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Texture2D:</strong> Import the image as a 2-dimensional texture, suited for display
                            on 2D and 3D surfaces. This is the default import mode.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Texture2DArray:</strong> Import the image as a collection of 2-dimensional textures.
                            Texture2DArray is similar to a 3-dimensional texture, but without
                            interpolation between layers. Built-in 2D and 3D shaders cannot display
                            texture arrays, so you must create a custom shader in <reference internal="True" refuri="../shaders/shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">2D</inline></reference>
                            or <reference internal="True" refuri="../shaders/shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">3D</inline></reference> to display a texture from a texture array.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Texture3D:</strong> Import the image as a 3-dimensional texture. This is <emphasis>not</emphasis> a 2D
                            texture applied onto a 3D surface. Texture3D is similar to a texture array, but
                            with interpolation between layers. Texture3D is typically used for
                            <reference internal="True" refuri="../../classes/class_fogmaterial#class-fogmaterial"><inline classes="std std-ref">FogMaterial</inline></reference> density maps in <reference internal="True" refuri="../3d/volumetric_fog#doc-volumetric-fog"><inline classes="std std-ref">volumetric fog</inline></reference>, <reference internal="True" refuri="../3d/particles/attractors#doc-3d-particles-attractors"><inline classes="std std-ref">particle attractor</inline></reference>
                            vector fields, <reference internal="True" refuri="../../classes/class_environment#class-environment"><inline classes="std std-ref">Environment</inline></reference> 3D LUT color correction, and custom shaders.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>TextureAtlas:</strong> Import the image as an <emphasis>atlas</emphasis> of different textures. Can be
                            used to reduce memory usage for animated 2D sprites. Only supported in 2D due
                            to missing support in built-in 3D shaders.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>For <strong>Cubemap</strong>, the expected image order is X+, X-, Y+, Y-, Z+, Z-
                    (in Godot's coordinate system, so Y+ is "up" and Z- is "forward").
                    Here are templates you can use for cubemap images (right-click &gt; <strong>Save Link As…</strong>):</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><download_reference filename="c0abe94f20d1dd05d3a4d6343466b3db/cubemap_template_2x3.webp" refdoc="tutorials/assets_pipeline/importing_images" refdomain="" refexplicit="True" reftarget="img/cubemap_template_2x3.webp" reftype="download" refwarn="False"><literal classes="xref download">2×3 cubemap template (default layout option)</literal></download_reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="7ec9284a00a66408afa1e87ddbb86442/cubemap_template_3x2.webp" refdoc="tutorials/assets_pipeline/importing_images" refdomain="" refexplicit="True" reftarget="img/cubemap_template_3x2.webp" reftype="download" refwarn="False"><literal classes="xref download">3×2 cubemap template</literal></download_reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="ae0f94ce8a4c8ad79521f629758ae1ae/cubemap_template_1x6.webp" refdoc="tutorials/assets_pipeline/importing_images" refdomain="" refexplicit="True" reftarget="img/cubemap_template_1x6.webp" reftype="download" refwarn="False"><literal classes="xref download">1×6 cubemap template</literal></download_reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><download_reference filename="9800947477fb114dec818d324bd3ba64/cubemap_template_6x1.webp" refdoc="tutorials/assets_pipeline/importing_images" refdomain="" refexplicit="True" reftarget="img/cubemap_template_6x1.webp" reftype="download" refwarn="False"><literal classes="xref download">6×1 cubemap template</literal></download_reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="detect-3d" names="detect\ 3d">
                <title>Detect 3D</title>
                <paragraph>The default import options (no mipmaps and <strong>Lossless</strong> compression) are suited
                    for 2D, but are not ideal for most 3D projects. <strong>Detect 3D</strong> makes Godot aware
                    of when a texture is used in a 3D scene (such as a texture in a
                    <reference internal="True" refuri="../../classes/class_basematerial3d#class-basematerial3d"><inline classes="std std-ref">BaseMaterial3D</inline></reference>). If this happens, several import options are
                    changed so the texture flags are friendlier to 3D. Mipmaps are enabled and the
                    compression mode is changed to <strong>VRAM Compressed</strong> unless
                    <reference internal="True" refid="doc-importing-images-detect-3d-compress-to"><inline classes="std std-ref">Detect 3D &gt; Compress To</inline></reference> is changed. The texture is
                    also reimported automatically.</paragraph>
                <paragraph>A message is printed to the Output panel when a texture is detected to be used in 3D.</paragraph>
                <paragraph>If you run into quality issues when a texture is detected to be used in 3D (e.g.
                    for pixel art textures), change the
                    <reference internal="True" refid="doc-importing-images-detect-3d-compress-to"><inline classes="std std-ref">Detect 3D &gt; Compress To</inline></reference> option before using the
                    texture in 3D, or change <reference internal="True" refid="doc-importing-images-compress-mode"><inline classes="std std-ref">Compress &gt; Mode</inline></reference> to
                    <strong>Lossless</strong> after using the texture in 3D. This is preferable to disabling
                    <strong>Detect 3D</strong>, as mipmap generation remains enabled to prevent textures from
                    looking grainy at a distance.</paragraph>
            </section>
        </section>
        <section ids="import-options" names="import\ options">
            <title>Import options</title>
            <seealso>
                <paragraph>Since Godot 4.0, texture filter and repeat modes are set in the CanvasItem
                    properties in 2D (with a project setting acting as a default), and in a
                    <reference internal="True" refuri="../3d/standard_material_3d#doc-standard-material-3d-sampling"><inline classes="std std-ref">per-material configuration in 3D</inline></reference>.
                    In custom shaders, filter and repeat mode is changed on the <literal>sampler2D</literal>
                    uniform using hints described in the <reference internal="True" refuri="../shaders/shader_reference/shading_language#doc-shading-language"><inline classes="std std-ref">Shading language</inline></reference>
                    documentation.</paragraph>
            </seealso>
            <target refid="doc-importing-images-compress-mode"></target>
            <section ids="compress-mode doc-importing-images-compress-mode" names="compress\ &gt;\ mode doc_importing_images_compress_mode">
                <title>Compress &gt; Mode</title>
                <paragraph>Images are one of the largest assets in a game. To handle them efficiently, they
                    need to be compressed. Godot offers several compression methods, depending on
                    the use case.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Lossless:</strong> This is the default and most common compression mode for 2D assets.
                            It shows assets without any kind of artifacting, and disk compression is
                            decent. It will use considerably more amount of video memory than
                            VRAM Compression, though. This is also the recommended setting for pixel art.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Lossy:</strong> This is a good choice for large 2D assets. It has some artifacts,
                            but less than VRAM compression and the file size is several times lower
                            compared to Lossless or VRAM Uncompressed. Video memory usage isn't decreased
                            by this mode; it's the same as with Lossless or VRAM Uncompressed.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>VRAM Compressed:</strong> This is the default and most common compression mode for
                            3D assets. Size on disk is reduced and video memory usage is also decreased
                            considerably (usually by a factor between 4 and 6). This mode should be
                            avoided for 2D as it exhibits noticeable artifacts, especially for
                            lower-resolution textures.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>VRAM Uncompressed:</strong> Only useful for formats that can't be compressed, such
                            as raw floating-point images.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Basis Universal:</strong> This alternative VRAM compression mode encodes the
                            texture to a format that can be transcoded to most GPU-compressed formats at
                            load-time. This provides very small files that make use of VRAM compression,
                            at the cost of lower quality compared to VRAM Compressed and slow compression
                            times. VRAM usage is usually the same as VRAM Compressed. Basis Universal does
                            not support floating-point image formats (the engine will internally fall back
                            to VRAM Compressed instead).</paragraph>
                    </list_item>
                </bullet_list>
                <note>
                    <paragraph>Even in 3D, "pixel art" textures should have VRAM compression disabled as it
                        will negatively affect their appearance, without improving performance
                        significantly due to their low resolution.</paragraph>
                </note>
                <paragraph>In this table, each of the 5 options are described together with their
                    advantages and disadvantages (<image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> = best, <image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> = worst):</paragraph>
                <table>
                    <tgroup cols="6">
                        <colspec colwidth="18"></colspec>
                        <colspec colwidth="31"></colspec>
                        <colspec colwidth="22"></colspec>
                        <colspec colwidth="54"></colspec>
                        <colspec colwidth="24"></colspec>
                        <colspec colwidth="38"></colspec>
                        <thead>
                            <row>
                                <entry>
                                    <paragraph>Compress mode</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Lossless</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Lossy</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>VRAM Compressed</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>VRAM Uncompressed</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Basis Universal</paragraph>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph><strong>Description</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Stored as Lossless WebP / PNG</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Stored as Lossy WebP</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Stored as S3TC, BPTC or ETC2 depending on platform</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Stored as raw pixels</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Transcoded to VRAM Compressed format</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>Size on disk</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" original_uri="img/regular.png" uri="tutorials/assets_pipeline/img/regular.png"></image> Small</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> Very small</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" original_uri="img/regular.png" uri="tutorials/assets_pipeline/img/regular.png"></image> Small</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> Large</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> Very small</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>Memory usage</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> Large</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> Large</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> Small</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> Large</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> Small</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>Performance</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" original_uri="img/regular.png" uri="tutorials/assets_pipeline/img/regular.png"></image> Normal</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" original_uri="img/regular.png" uri="tutorials/assets_pipeline/img/regular.png"></image> Normal</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> Fast</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" original_uri="img/regular.png" uri="tutorials/assets_pipeline/img/regular.png"></image> Normal</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> Fast</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>Quality loss</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> None</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" original_uri="img/regular.png" uri="tutorials/assets_pipeline/img/regular.png"></image> Slight</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> Moderate</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> None</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> Moderate</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>Load time</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> Slow</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> Slow</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> Fast</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" original_uri="img/regular.png" uri="tutorials/assets_pipeline/img/regular.png"></image> Normal</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" original_uri="img/regular.png" uri="tutorials/assets_pipeline/img/regular.png"></image> Normal</paragraph>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <substitution_definition names="bad"><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image></substitution_definition>
                <substitution_definition names="good"><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image></substitution_definition>
                <substitution_definition names="regular"><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" original_uri="img/regular.png" uri="tutorials/assets_pipeline/img/regular.png"></image></substitution_definition>
                <paragraph>Estimated memory usage for a single RGBA8 texture with mipmaps enabled:</paragraph>
                <table>
                    <tgroup cols="6">
                        <colspec colwidth="15"></colspec>
                        <colspec colwidth="21"></colspec>
                        <colspec colwidth="21"></colspec>
                        <colspec colwidth="21"></colspec>
                        <colspec colwidth="21"></colspec>
                        <colspec colwidth="21"></colspec>
                        <thead>
                            <row>
                                <entry>
                                    <paragraph>Texture size</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Lossless</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Lossy</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>VRAM Compressed</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>VRAM Uncompressed</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Basis Universal</paragraph>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph><strong>128×128</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 85 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 85 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 21 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 85 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 21 KiB</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>256×256</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 341 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 341 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 85 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 341 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 85 KiB</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>512×512</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 1.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 1.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 341 KiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 1.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 341 KiB</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>1024×1024</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" original_uri="img/regular.png" uri="tutorials/assets_pipeline/img/regular.png"></image> 5.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" original_uri="img/regular.png" uri="tutorials/assets_pipeline/img/regular.png"></image> 5.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 1.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" original_uri="img/regular.png" uri="tutorials/assets_pipeline/img/regular.png"></image> 5.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="good" candidates="{'*': 'tutorials/assets_pipeline/img/good.png'}" original_uri="img/good.png" uri="tutorials/assets_pipeline/img/good.png"></image> 1.33 MiB</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>2048×2048</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> 21.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> 21.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" original_uri="img/regular.png" uri="tutorials/assets_pipeline/img/regular.png"></image> 5.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> 21.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="regular" candidates="{'*': 'tutorials/assets_pipeline/img/regular.png'}" original_uri="img/regular.png" uri="tutorials/assets_pipeline/img/regular.png"></image> 5.33 MiB</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><strong>4096×4096</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> 85.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> 85.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> 21.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> 85.33 MiB</paragraph>
                                </entry>
                                <entry>
                                    <paragraph><image alt="bad" candidates="{'*': 'tutorials/assets_pipeline/img/bad.png'}" original_uri="img/bad.png" uri="tutorials/assets_pipeline/img/bad.png"></image> 21.33 MiB</paragraph>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <note>
                    <paragraph>In the above table, memory usage will be reduced by 25% for images that do
                        not have an alpha channel (RGB8). Memory usage will be further decreased by
                        25% for images that have mipmaps disabled.</paragraph>
                </note>
                <paragraph>Notice how at larger resolutions, the impact of VRAM compression is much
                    greater. With a 4:1 compression ratio (6:1 for opaque textures with S3TC), VRAM
                    compression effectively allows a texture to be twice as large on each axis,
                    while using the same amount of memory on the GPU.</paragraph>
                <paragraph>VRAM compression also reduces the memory bandwidth required to sample the
                    texture, which can speed up rendering in memory bandwidth-constrained scenarios
                    (which are frequent on integrated graphics and mobile). These factors combined
                    make VRAM compression a must-have for 3D games with high-resolution textures.</paragraph>
                <paragraph>You can preview how much memory a texture takes by double-clicking it in the
                    FileSystem dock, then looking at the Inspector:</paragraph>
                <figure align="center" ids="id2">
                    <image alt="Previewing a texture in the Inspector" candidates="{'*': 'tutorials/assets_pipeline/img/importing_images_inspector_preview.webp'}" original_uri="img/importing_images_inspector_preview.webp" uri="tutorials/assets_pipeline/img/importing_images_inspector_preview.webp"></image>
                    <caption>Previewing a texture in the Inspector. Credit: <reference name="Red Brick 03 - Poly Haven" refuri="https://polyhaven.com/a/red_brick_03">Red Brick 03 - Poly Haven</reference></caption>
                </figure>
            </section>
            <section ids="compress-high-quality" names="compress\ &gt;\ high\ quality">
                <title>Compress &gt; High Quality</title>
                <note>
                    <paragraph>High-quality VRAM texture compression is only supported in the Forward+ and
                        Mobile renderers.</paragraph>
                    <paragraph>When using the Compatibility renderer, this option is always considered
                        disabled.</paragraph>
                </note>
                <paragraph>If enabled, uses BPTC compression on desktop platforms and <abbreviation explanation="Adaptive&#10;Scalable Texture Compression">ASTC</abbreviation> compression on mobile platforms. When using BPTC,
                    BC7 is used for SDR textures and BC6H is used for HDR textures.</paragraph>
                <paragraph>If disabled (default), uses the faster but lower-quality S3TC compression on
                    desktop platforms and ETC2 on mobile/web platforms. When using S3TC, DXT1 (BC1)
                    is used for opaque textures and DXT5 (BC3) is used for transparent or normal map
                    (<abbreviation explanation="Red-Green Texture Compression">RGTC</abbreviation>) textures.</paragraph>
                <paragraph>BPTC and ASTC support VRAM compression for HDR textures, but S3TC and ETC2 do
                    not (see <strong>HDR Compression</strong> below).</paragraph>
            </section>
            <section ids="compress-hdr-compression" names="compress\ &gt;\ hdr\ compression">
                <title>Compress &gt; HDR Compression</title>
                <note>
                    <paragraph>This option only has an effect on textures that are imported as HDR formats in Godot
                        (<literal>.hdr</literal> and <literal>.exr</literal> files).</paragraph>
                </note>
                <paragraph>If set to <strong>Disabled</strong>, never uses VRAM compression for HDR textures, regardless
                    of whether they're opaque or transparent. Instead, the texture is converted to
                    RGBE9995 (9-bits per channel + 5-bit exponent = 32 bits per pixel) to reduce
                    memory usage compared to a half-float or single-precision float image format.</paragraph>
                <paragraph>If set to <strong>Opaque Only</strong> (default), only uses VRAM compression for opaque HDR
                    textures. This is due to a limitation of HDR formats, as there is no
                    VRAM-compressed HDR format that supports transparency at the same time.</paragraph>
                <paragraph>If set to <strong>Always</strong>, will force VRAM compression even for HDR textures with an
                    alpha channel. To perform this, the alpha channel is discarded on import.</paragraph>
            </section>
            <section ids="compress-normal-map" names="compress\ &gt;\ normal\ map">
                <title>Compress &gt; Normal Map</title>
                <paragraph>When using a texture as normal map, only the red and green channels are
                    required. Given regular texture compression algorithms produce artifacts that
                    don't look that nice in normal maps, the <abbreviation explanation="Red-Green Texture Compression">RGTC</abbreviation>
                    compression format is the best fit for this data. Forcing this option to <strong>Enable</strong>
                    will make Godot import the image as <abbreviation explanation="Red-Green Texture Compression">RGTC</abbreviation> compressed.
                    By default, it's set to <strong>Detect</strong>. This means that if the texture is ever detected to
                    be used as a normal map, it will be changed to <strong>Enable</strong> and reimported automatically.</paragraph>
                <paragraph>Note that <abbreviation explanation="Red-Green Texture Compression">RGTC</abbreviation> compression affects the
                    resulting normal map image. You will have to adjust custom shaders that use the
                    normal map's blue channel to take this into account. Built-in material shaders
                    already ignore the blue channel in a normal map (regardless of the actual normal
                    map's contents).</paragraph>
                <paragraph>In the example below, the normal map with <abbreviation explanation="Red-Green Texture Compression">RGTC</abbreviation>
                    compression is able to preserve its detail much better, while
                    using the same amount of memory as a standard RGBA VRAM-compressed texture:</paragraph>
                <figure align="center" ids="id3">
                    <image alt="Normal map with standard VRAM compression (left) and with RGTC VRAM compression (right)" candidates="{'*': 'tutorials/assets_pipeline/img/importing_images_normal_map_rgtc.webp'}" original_uri="img/importing_images_normal_map_rgtc.webp" uri="tutorials/assets_pipeline/img/importing_images_normal_map_rgtc.webp"></image>
                    <caption>Normal map with standard VRAM compression (left) and with RGTC VRAM compression (right)</caption>
                </figure>
                <note>
                    <paragraph>Godot requires the normal map to use the X+, Y+ and Z+ coordinates, which is
                        known as an OpenGL-style normal map. If you've imported a material made to be
                        used with another engine, it may be DirectX-style. In this case, the normal map
                        needs to be converted by enabling the <strong>Normal Map Invert Y</strong> import option.</paragraph>
                    <paragraph>More information about normal maps (including a coordinate order table for
                        popular engines) can be found
                        <reference name="here" refuri="http://wiki.polycount.com/wiki/Normal_Map_Technical_Details">here</reference>.</paragraph>
                </note>
            </section>
            <section ids="compress-channel-pack" names="compress\ &gt;\ channel\ pack">
                <title>Compress &gt; Channel Pack</title>
                <paragraph>If set to <strong>sRGB Friendly</strong> (default), prevents the RG color format from being
                    used as it does not support sRGB color.</paragraph>
                <paragraph>If set to <strong>Optimized</strong>, allows the RG color format to be used if the texture
                    does not use the blue channel.</paragraph>
                <paragraph>A third option <strong>Normal Map (RG Channels)</strong> is <emphasis>only</emphasis> available in layered
                    textures (<reference internal="True" refuri="../../classes/class_cubemap#class-cubemap"><inline classes="std std-ref">Cubemap</inline></reference>, <reference internal="True" refuri="../../classes/class_cubemaparray#class-cubemaparray"><inline classes="std std-ref">CubemapArray</inline></reference>, <reference internal="True" refuri="../../classes/class_texture2darray#class-texture2darray"><inline classes="std std-ref">Texture2DArray</inline></reference>
                    and <reference internal="True" refuri="../../classes/class_texture3d#class-texture3d"><inline classes="std std-ref">Texture3D</inline></reference>). This forces all layers from the texture to be imported
                    with the RG color format, with only the red and green
                    channels preserved. <abbreviation explanation="Red-Green Texture Compression">RGTC</abbreviation> compression is able to
                    preserve its detail much better, while using the same amount of memory as a standard
                    RGBA VRAM-compressed texture. This only has an effect on textures with the <strong>VRAM Compressed</strong>
                    or <strong>Basis Universal</strong> compression modes.</paragraph>
                <target refid="doc-importing-images-mipmaps"></target>
            </section>
            <section ids="mipmaps-generate doc-importing-images-mipmaps" names="mipmaps\ &gt;\ generate doc_importing_images_mipmaps">
                <title>Mipmaps &gt; Generate</title>
                <paragraph>If enabled, smaller versions of the texture are generated on import. For
                    example, a 64×64 texture will generate 6 mipmaps (32×32, 16×16, 8×8, 4×4, 2×2,
                    1×1). This has several benefits:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Textures will not become grainy in the distance (in 3D), or if scaled down due
                            to camera zoom or CanvasItem scale (in 2D).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Performance will improve if the texture is displayed in the distance, since
                            sampling smaller versions of the original texture is faster and requires less
                            memory bandwidth.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>The downside of mipmaps is that they increase memory usage by roughly 33%.</paragraph>
                <paragraph>It's recommended to enable mipmaps in 3D. However, in 2D, this should only be
                    enabled if your project visibly benefits from having mipmaps enabled. If the
                    camera never zooms out significantly, there won't be a benefit to enabling
                    mipmaps but memory usage will increase.</paragraph>
            </section>
            <section ids="mipmaps-limit" names="mipmaps\ &gt;\ limit">
                <title>Mipmaps &gt; Limit</title>
                <comment xml:space="preserve">UPDATE: Not implemented. When Mipmaps &gt; Limit is implemented, remove this</comment>
                <comment xml:space="preserve">warning and remove this comment.</comment>
                <warning>
                    <paragraph><strong>Mipmaps &gt; Limit</strong> is currently not implemented and has no effect when changed.</paragraph>
                </warning>
                <paragraph>If set to a value greater than <literal>-1</literal>, limits the maximum number of mipmaps that
                    can be generated. This can be decreased if you don't want textures to become too
                    low-resolution at extreme distances, at the cost of some graininess.</paragraph>
            </section>
            <section ids="roughness-mode" names="roughness\ &gt;\ mode">
                <title>Roughness &gt; Mode</title>
                <paragraph>The color channel to consider as a roughness map in this texture. Only effective if
                    <strong>Roughness &gt; Src Normal</strong> is not empty.</paragraph>
            </section>
            <section ids="roughness-src-normal" names="roughness\ &gt;\ src\ normal">
                <title>Roughness &gt; Src Normal</title>
                <paragraph>The path to the texture to consider as a normal map for roughness filtering on
                    import. Specifying this can help decrease specular aliasing slightly in 3D.</paragraph>
                <paragraph>Roughness filtering on import is only used in 3D rendering, not 2D.</paragraph>
            </section>
            <section ids="process-fix-alpha-border" names="process\ &gt;\ fix\ alpha\ border">
                <title>Process &gt; Fix Alpha Border</title>
                <paragraph>This puts pixels of the same surrounding color in transition from transparent to
                    opaque areas. For textures displayed with bilinear filtering, this helps
                    mitigate the outline effect when exporting images from an image editor.</paragraph>
                <image candidates="{'*': 'tutorials/assets_pipeline/img/fixedborder.png'}" original_uri="img/fixedborder.png" uri="tutorials/assets_pipeline/img/fixedborder.png"></image>
                <paragraph>It's recommended to leave this enabled (as it is by default), unless this causes
                    issues for a particular image.</paragraph>
            </section>
            <section ids="process-premult-alpha" names="process\ &gt;\ premult\ alpha">
                <title>Process &gt; Premult Alpha</title>
                <paragraph>An alternative to fixing darkened borders with <strong>Fix Alpha Border</strong> is to use
                    premultiplied alpha. By enabling this option, the texture will be converted to
                    this format. A premultiplied alpha texture requires specific materials to be
                    displayed correctly:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>In 2D, a <reference internal="True" refuri="../../classes/class_canvasitemmaterial#class-canvasitemmaterial"><inline classes="std std-ref">CanvasItemMaterial</inline></reference> will need to be created and
                            configured to use the <strong>Premul Alpha</strong> blend mode on CanvasItems that use this
                            texture. In <reference internal="True" refuri="../shaders/shader_reference/canvas_item_shader#doc-canvas-item-shader"><inline classes="std std-ref">custom canvas item shaders</inline></reference>,
                            <literal>render_mode blend_premul_alpha;</literal> should be used.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>In 3D, a <reference internal="True" refuri="../../classes/class_basematerial3d#class-basematerial3d"><inline classes="std std-ref">BaseMaterial3D</inline></reference> will need to be created and configured
                            to use the <strong>Premul Alpha</strong> blend mode on materials that use this texture.
                            In <reference internal="True" refuri="../shaders/shader_reference/spatial_shader#doc-spatial-shader"><inline classes="std std-ref">custom spatial shaders</inline></reference>,
                            <literal>render_mode blend_premul_alpha;</literal> should be used.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="process-normal-map-invert-y" names="process\ &gt;\ normal\ map\ invert\ y">
                <title>Process &gt; Normal Map Invert Y</title>
                <paragraph>Godot requires the normal map to use the X+, Y+ and Z+ coordinates, which is
                    known as an OpenGL-style normal map. If you've imported a material made to be
                    used with another engine, it may be DirectX-style. In this case, the normal map
                    needs to be converted by enabling the <strong>Normal Map Invert Y</strong> import option.</paragraph>
                <paragraph>More information about normal maps (including a coordinate order table for
                    popular engines) can be found
                    <reference name="here" refuri="http://wiki.polycount.com/wiki/Normal_Map_Technical_Details">here</reference>.</paragraph>
            </section>
            <section ids="process-hdr-as-srgb" names="process\ &gt;\ hdr\ as\ srgb">
                <title>Process &gt; HDR as sRGB</title>
                <paragraph>Some HDR images you can find online may be broken and contain sRGB color data
                    (instead of linear color data). It is advised not to use those files. If you
                    absolutely have to, enabling this option on will make them look correct.</paragraph>
                <warning>
                    <paragraph>Enabling <strong>HDR as sRGB</strong> on well-formatted HDR images will cause the
                        resulting image to look too dark, so leave this disabled if unsure.</paragraph>
                </warning>
            </section>
            <section ids="process-hdr-clamp-exposure" names="process\ &gt;\ hdr\ clamp\ exposure">
                <title>Process &gt; HDR Clamp Exposure</title>
                <paragraph>Some HDR panorama images you can find online may contain extremely bright
                    pixels, due to being taken from real life sources without any clipping.</paragraph>
                <paragraph>While these HDR panorama images are accurate to real life, this can cause the
                    radiance map generated by Godot to contain sparkles when used as a background
                    sky. This can be seen in material reflections (even on rough materials in
                    extreme cases). Enabling <strong>HDR Clamp Exposure</strong> can resolve this using a smart
                    clamping formula that does not introduce <emphasis>visible</emphasis> clipping – glow will keep
                    working when looking at the background sky.</paragraph>
            </section>
            <section ids="process-size-limit" names="process\ &gt;\ size\ limit">
                <title>Process &gt; Size Limit</title>
                <paragraph>If set to a value greater than <literal>0</literal>, the size of the texture is limited on
                    import to a value smaller than or equal to the value specified here. For
                    non-square textures, the size limit affects the longer dimension, with the
                    shorter dimension scaled to preserve aspect ratio. Resizing is performed using
                    cubic interpolation.</paragraph>
                <paragraph>This can be used to reduce memory usage without affecting the source images, or
                    avoid issues with textures not displaying on mobile/web platforms (as these
                    usually can't display textures larger than 4096×4096).</paragraph>
                <target refid="doc-importing-images-detect-3d-compress-to"></target>
            </section>
            <section ids="detect-3d-compress-to doc-importing-images-detect-3d-compress-to" names="detect\ 3d\ &gt;\ compress\ to doc_importing_images_detect_3d_compress_to">
                <title>Detect 3D &gt; Compress To</title>
                <paragraph>This changes the <reference internal="True" refid="doc-importing-images-compress-mode"><inline classes="std std-ref">Compress &gt; Mode</inline></reference> option that is used
                    when a texture is detected as being used in 3D.</paragraph>
                <paragraph>Changing this import option only has an effect if a texture is detected as being
                    used in 3D. Changing this to <strong>Disabled</strong> then reimporting will not change the
                    existing compress mode on a texture (if it's detected to be used in 3D), but
                    choosing <strong>VRAM Compressed</strong> or <strong>Basis Universal</strong> will.</paragraph>
            </section>
            <section ids="svg-scale" names="svg\ &gt;\ scale">
                <title>SVG &gt; Scale</title>
                <paragraph><emphasis>This is only available for SVG images.</emphasis></paragraph>
                <paragraph>The scale the SVG should be rendered at, with <literal>1.0</literal> being the original design
                    size. Higher values result in a larger image. Note that unlike font
                    oversampling, this affects the physical size the SVG is rendered at in 2D. See
                    also <strong>Editor &gt; Scale With Editor Scale</strong> below.</paragraph>
                <target refid="doc-importing-images-editor-import-options"></target>
            </section>
            <section ids="editor-scale-with-editor-scale doc-importing-images-editor-import-options" names="editor\ &gt;\ scale\ with\ editor\ scale doc_importing_images_editor_import_options">
                <title>Editor &gt; Scale With Editor Scale</title>
                <paragraph><emphasis>This is only available for SVG images.</emphasis></paragraph>
                <paragraph>If true, scales the imported image to match the editor's display scale factor.
                    This should be enabled for editor plugin icons and custom class icons, but
                    should be left disabled otherwise.</paragraph>
            </section>
            <section ids="editor-convert-colors-with-editor-theme" names="editor\ &gt;\ convert\ colors\ with\ editor\ theme">
                <title>Editor &gt; Convert Colors With Editor Theme</title>
                <paragraph><emphasis>This is only available for SVG images.</emphasis></paragraph>
                <paragraph>If checked, converts the imported image's colors to match the editor's icon and
                    font color palette. This assumes the image uses the exact same colors as
                    <reference internal="True" refuri="../../engine_details/editor/creating_icons#doc-editor-icons"><inline classes="std std-ref">Godot's own color palette for editor icons</inline></reference>, with the
                    source file designed for a dark editor theme. This should be enabled for editor
                    plugin icons and custom class icons, but should be left disabled otherwise.</paragraph>
                <target refid="doc-importing-images-svg-text"></target>
            </section>
        </section>
        <section ids="importing-svg-images-with-text doc-importing-images-svg-text" names="importing\ svg\ images\ with\ text doc_importing_images_svg_text">
            <title>Importing SVG images with text</title>
            <paragraph>As the SVG library used in Godot doesn't support rasterizing text found in SVG
                images, text must be converted to a path first. Otherwise, text won't appear in
                the rasterized image.</paragraph>
            <paragraph>There are two ways to achieve this in a non-destructive manner, so you can keep
                editing the original text afterwards:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Select your text object in Inkscape, then duplicate it in place by pressing
                        <literal classes="kbd">Ctrl + D</literal> and use <strong>Path &gt; Object to Path</strong>. Hide the original text
                        object afterwards using the <strong>Layers and Objects</strong> dock.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Use the Inkscape command line to export an SVG from another SVG file with text
                        converted to paths:</paragraph>
                </list_item>
            </bullet_list>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">inkscape --export-text-to-path --export-filename svg_with_text_converted_to_path.svg svg_with_text.svg</literal_block>
        </section>
        <section ids="best-practices" names="best\ practices">
            <title>Best practices</title>
            <section ids="supporting-high-resolution-texture-sizes-in-2d-without-artifacts" names="supporting\ high-resolution\ texture\ sizes\ in\ 2d\ without\ artifacts">
                <title>Supporting high-resolution texture sizes in 2D without artifacts</title>
                <paragraph>To support <reference internal="True" refuri="../rendering/multiple_resolutions#doc-multiple-resolutions"><inline classes="std std-ref">multiple resolutions</inline></reference> with crisp
                    visuals at high resolutions, you will need to use high-resolution source images
                    (suited for the highest resolution you wish to support without blurriness, which
                    is typically 4K in modern desktop games).</paragraph>
                <paragraph>There are 2 ways to proceed:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Use a high base resolution in the project settings (such as 4K), then use the
                            textures at original scale. This is an easier approach.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Use a low base resolution in the project settings (such as 1080p), then
                            downscale textures when using them. This is often more difficult and can make
                            various calculations in script tedious, so the approach described above is
                            recommended instead.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>After doing this, you may notice that textures become grainy at lower viewport
                    resolutions. To resolve this, enable <strong>Mipmaps</strong> on textures used in 2D in the
                    Import dock. This will increase memory usage.</paragraph>
                <paragraph>Enabling mipmaps can also make textures appear blurrier, but you can choose
                    to make textures sharper (at the cost of some graininess) by setting
                    <strong>Rendering &gt; Textures &gt; Default Filters &gt; Texture Mipmap Bias</strong> to a
                    negative value.</paragraph>
            </section>
            <section ids="use-appropriate-texture-sizes-in-3d" names="use\ appropriate\ texture\ sizes\ in\ 3d">
                <title>Use appropriate texture sizes in 3D</title>
                <paragraph>While there's no "one size fits all" recommendation, here are some general
                    recommendations for choosing texture sizes in 3D:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>The size of a texture should be adjusted to have a consistent texel density
                            compared to surrounding objects. While this cannot be ensured perfectly when
                            sticking to power-of-two texture sizes, it's usually possible to keep texture
                            detail fairly consistent throughout a 3D scene.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The smaller the object appears on screen, the smaller its texture should be.
                            For example, a tree that only appears in the background doesn't need a texture
                            resolution as high as other objects the player may be able to walk close to.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Using power-of-two texture sizes is recommended, but is not required. Textures
                            don't have to be square – sizes such as 1024×512 are acceptable.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>There are diminishing returns to using large texture sizes, despite the
                            increased memory usage and loading times. Most modern 3D games not using a
                            pixel art style stick to 2048×2048 textures on average, with 1024×1024 and
                            512×512 for textures spanning smaller surfaces.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>When working with physically-based materials in 3D, you can reduce memory
                            usage and file size without affecting quality too much by using a lower
                            resolution for certain texture maps. This works especially well for textures
                            that only feature low-frequency detail (such as a normal map for a snow
                            texture).</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>If you have control over how the 3D models are created, these tips are also
                    worth exploring:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>When working with 3D models that are mostly symmetrical, you may be able to
                            use mirrored UVs to double the effective texel density. This may look
                            unnatural when used on human faces though.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>When working with 3D models using a low-poly style and plain colors, you can
                            rely on vertex colors instead of textures to represent colors on the model's
                            surfaces.</paragraph>
                    </list_item>
                </bullet_list>
                <seealso>
                    <paragraph>Images can be loaded and saved at runtime using
                        <reference internal="True" refuri="../io/runtime_file_loading_and_saving#doc-runtime-file-loading-and-saving-images"><inline classes="std std-ref">runtime file loading and saving</inline></reference>,
                        including from an exported project.</paragraph>
                </seealso>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
