<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/navigation/navigation_using_navigationpaths.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-navigation-using-navigationpaths"></target>
    <section ids="using-navigationpaths doc-navigation-using-navigationpaths" names="using\ navigationpaths 使用\ navigationpath doc_navigation_using_navigationpaths">
        <title>使用 NavigationPath</title>
        <section ids="obtaining-a-navigationpath" names="obtaining\ a\ navigationpath 获取\ navigationpath">
            <title>获取 NavigationPath</title>
            <paragraph>Navigation paths can be directly queried from the NavigationServer and do not require any
                additional nodes or objects as long as the navigation map has a navigation mesh to work with.</paragraph>
            <paragraph>要获取 2D 路径，请使用 <literal>NavigationServer2D.map_get_path(地图, 起点, 终点, 优化, 导航层)</literal>。</paragraph>
            <paragraph>要获取 3D 路径，请使用 <literal>NavigationServer3D.map_get_path(地图, 起点, 终点, 优化, 导航层)</literal>。</paragraph>
            <paragraph>For more customizable navigation path queries that require additional setup see <reference internal="True" refuri="navigation_using_navigationpathqueryobjects#doc-navigation-using-navigationpathqueryobjects"><inline classes="std std-ref">使用 NavigationPathQueryObject</inline></reference>.</paragraph>
            <paragraph>One of the required parameters for the query is the RID of the navigation map.
                Each game world has a default navigation map automatically created.
                The default navigation maps can be retrieved with <literal>get_world_2d().get_navigation_map()</literal> from
                any Node2D inheriting node or <literal>get_world_3d().get_navigation_map()</literal> from any Node3D inheriting node.
                The second and third parameters are the starting position and the target position as Vector2 for 2D or Vector3 for 3D.</paragraph>
            <paragraph>If the <literal>optimized</literal> parameter is <literal>true</literal>, path positions will be shortened along polygon
                corners with an additional funnel algorithm pass. This works well for free movement
                on navigation meshes with unequally sized polygons as the path will hug around corners
                along the polygon corridor found by the A* algorithm. With small cells the A* algorithm
                creates a very narrow funnel corridor that can create ugly corner paths when used with grids.</paragraph>
            <paragraph>If the <literal>optimized</literal> parameter is <literal>false</literal>, path positions will be placed at the center of each polygon edge.
                This works well for pure grid movement on navigation meshes with equally sized polygons as the path will go through the center of the grid cells.
                Outside of grids due to polygons often covering large open areas with a single, long edge this can create paths with unnecessary long detours.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D
 # basic query for a navigation path in 2D using the default navigation map
var default_2d_map_rid: RID = get_world_2d().get_navigation_map()
var start_position: Vector2 = Vector2(0.0, 0.0)
var target_position: Vector2 = Vector2(5.0, 0.0)
var path: PackedVector2Array = NavigationServer2D.map_get_path(
    default_2d_map_rid,
    start_position,
    target_position,
    true
)</literal_block>
                </div>
            </container>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node3D
# basic query for a navigation path in 3D using the default navigation map
var default_3d_map_rid: RID = get_world_3d().get_navigation_map()
var start_position: Vector3 = Vector3(0.0, 0.0, 0.0)
var target_position: Vector3 = Vector3(5.0, 0.0, 3.0)
var path: PackedVector3Array = NavigationServer3D.map_get_path(
    default_3d_map_rid,
    start_position,
    target_position,
    true
)</literal_block>
                </div>
            </container>
            <paragraph>A returned <literal>path</literal> by the NavigationServer will be a <literal>PackedVector2Array</literal> for 2D or a <literal>PackedVector3Array</literal> for 3D.
                These are just a memory-optimized <literal>Array</literal> of vector positions.
                All position vectors inside the array are guaranteed to be inside a NavigationPolygon or NavigationMesh.
                The path array, if not empty, has the navigation mesh position closest to the starting position at the first index <literal>path[0]</literal> position.
                The closest available navigation mesh position to the target position is the last index <literal>path[path.size()-1]</literal> position.
                All indexes between are the path points that an actor should follow to reach the target without leaving the navigation mesh.</paragraph>
            <note>
                <paragraph>If the target position is on a different navigation mesh that is not merged or connected
                    the navigation path will lead to the closest possible position on the starting position navigation mesh.</paragraph>
            </note>
            <paragraph>The following script moves a Node3D inheriting node along a navigation path using
                the default navigation map by setting the target position with <literal>set_movement_target()</literal>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@onready var default_3d_map_rid: RID = get_world_3d().get_navigation_map()

var movement_speed: float = 4.0
var movement_delta: float
var path_point_margin: float = 0.5

var current_path_index: int = 0
var current_path_point: Vector3
var current_path: PackedVector3Array

func set_movement_target(target_position: Vector3):

    var start_position: Vector3 = global_transform.origin

    current_path = NavigationServer3D.map_get_path(
        default_3d_map_rid,
        start_position,
        target_position,
        true
    )

    if not current_path.is_empty():
        current_path_index = 0
        current_path_point = current_path[0]

func _physics_process(delta):

    if current_path.is_empty():
        return

    movement_delta = movement_speed * delta

    if global_transform.origin.distance_to(current_path_point) &lt;= path_point_margin:
        current_path_index += 1
        if current_path_index &gt;= current_path.size():
            current_path = []
            current_path_index = 0
            current_path_point = global_transform.origin
            return

    current_path_point = current_path[current_path_index]

    var new_velocity: Vector3 = global_transform.origin.direction_to(current_path_point) * movement_delta

    global_transform.origin = global_transform.origin.move_toward(global_transform.origin + new_velocity, movement_delta)</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
