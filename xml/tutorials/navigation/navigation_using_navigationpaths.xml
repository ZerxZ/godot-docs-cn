<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/navigation/navigation_using_navigationpaths.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-navigation-using-navigationpaths"></target>
    <section ids="using-navigationpaths doc-navigation-using-navigationpaths" names="using\ navigationpaths doc_navigation_using_navigationpaths">
        <title>Using NavigationPaths</title>
        <section ids="obtaining-a-navigationpath" names="obtaining\ a\ navigationpath">
            <title>Obtaining a NavigationPath</title>
            <paragraph>Navigation paths can be directly queried from the NavigationServer and do not require any
                additional nodes or objects as long as the navigation map has a navigation mesh to work with.</paragraph>
            <paragraph>To obtain a 2D path, use <literal>NavigationServer2D.map_get_path(map, from, to, optimize, navigation_layers)</literal>.</paragraph>
            <paragraph>To obtain a 3D path, use <literal>NavigationServer3D.map_get_path(map, from, to, optimize, navigation_layers)</literal>.</paragraph>
            <paragraph>For more customizable navigation path queries that require additional setup see <reference internal="True" refuri="navigation_using_navigationpathqueryobjects#doc-navigation-using-navigationpathqueryobjects"><inline classes="std std-ref">Using NavigationPathQueryObjects</inline></reference>.</paragraph>
            <paragraph>One of the required parameters for the query is the RID of the navigation map.
                Each game world has a default navigation map automatically created.
                The default navigation maps can be retrieved with <literal>get_world_2d().get_navigation_map()</literal> from
                any Node2D inheriting node or <literal>get_world_3d().get_navigation_map()</literal> from any Node3D inheriting node.
                The second and third parameters are the starting position and the target position as Vector2 for 2D or Vector3 for 3D.</paragraph>
            <paragraph>If the <literal>optimized</literal> parameter is <literal>true</literal>, path positions will be shortened along polygon
                corners with an additional funnel algorithm pass. This works well for free movement
                on navigation meshes with unequally sized polygons as the path will hug around corners
                along the polygon corridor found by the A* algorithm. With small cells the A* algorithm
                creates a very narrow funnel corridor that can create ugly corner paths when used with grids.</paragraph>
            <paragraph>If the <literal>optimized</literal> parameter is <literal>false</literal>, path positions will be placed at the center of each polygon edge.
                This works well for pure grid movement on navigation meshes with equally sized polygons as the path will go through the center of the grid cells.
                Outside of grids due to polygons often covering large open areas with a single, long edge this can create paths with unnecessary long detours.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-MkQgR0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-MkQgR0RTY3JpcHQ=" name="MkQgR0RTY3JpcHQ=" role="tab" tabindex="0">2D GDScript</button>
                    <button aria-controls="panel-0-MkQgQyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-MkQgQyM=" name="MkQgQyM=" role="tab" tabindex="-1">2D C#</button>
                    <button aria-controls="panel-0-M0QgR0RTY3JpcHQ=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-M0QgR0RTY3JpcHQ=" name="M0QgR0RTY3JpcHQ=" role="tab" tabindex="-1">3D GDScript</button>
                    <button aria-controls="panel-0-M0QgQyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-M0QgQyM=" name="M0QgQyM=" role="tab" tabindex="-1">3D C#</button>
                </div>
                <div aria-labelledby="tab-0-MkQgR0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-MkQgR0RTY3JpcHQ=" name="MkQgR0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

# Basic query for a navigation path using the default navigation map.

func get_navigation_path(p_start_position: Vector2, p_target_position: Vector2) -&gt; PackedVector2Array:
    if not is_inside_tree():
        return PackedVector2Array()

    var default_map_rid: RID = get_world_2d().get_navigation_map()
    var path: PackedVector2Array = NavigationServer2D.map_get_path(
        default_map_rid,
        p_start_position,
        p_target_position,
        true
    )
    return path</literal_block>
                </div>
                <div aria-labelledby="tab-0-MkQgQyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-MkQgQyM=" name="MkQgQyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;
using System;

public partial class MyNode2D : Node2D
{
    // Basic query for a navigation path using the default navigation map.

    private Vector2[] GetNavigationPath(Vector2 startPosition, Vector2 targetPosition)
    {
        if (!IsInsideTree())
        {
            return Array.Empty&lt;Vector2&gt;();
        }

        Rid defaultMapRid = GetWorld2D().NavigationMap;
        Vector2[] path = NavigationServer2D.MapGetPath(
            defaultMapRid,
            startPosition,
            targetPosition,
            true
        );
        return path;
    }
}</literal_block>
                </div>
                <div aria-labelledby="tab-0-M0QgR0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-M0QgR0RTY3JpcHQ=" name="M0QgR0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node3D

# Basic query for a navigation path using the default navigation map.

func get_navigation_path(p_start_position: Vector3, p_target_position: Vector3) -&gt; PackedVector3Array:
    if not is_inside_tree():
        return PackedVector3Array()

    var default_map_rid: RID = get_world_3d().get_navigation_map()
    var path: PackedVector3Array = NavigationServer3D.map_get_path(
        default_map_rid,
        p_start_position,
        p_target_position,
        true
    )
    return path</literal_block>
                </div>
                <div aria-labelledby="tab-0-M0QgQyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-M0QgQyM=" name="M0QgQyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;
using System;

public partial class MyNode3D : Node3D
{
    // Basic query for a navigation path using the default navigation map.

    private Vector3[] GetNavigationPath(Vector3 startPosition, Vector3 targetPosition)
    {
        if (!IsInsideTree())
        {
            return Array.Empty&lt;Vector3&gt;();
        }

        Rid defaultMapRid = GetWorld3D().NavigationMap;
        Vector3[] path = NavigationServer3D.MapGetPath(
            defaultMapRid,
            startPosition,
            targetPosition,
            true
        );
        return path;
    }
}</literal_block>
                </div>
            </container>
            <paragraph>A returned <literal>path</literal> by the NavigationServer will be a <literal>PackedVector2Array</literal> for 2D or a <literal>PackedVector3Array</literal> for 3D.
                These are just a memory-optimized <literal>Array</literal> of vector positions.
                All position vectors inside the array are guaranteed to be inside a NavigationPolygon or NavigationMesh.
                The path array, if not empty, has the navigation mesh position closest to the starting position at the first index <literal>path[0]</literal> position.
                The closest available navigation mesh position to the target position is the last index <literal>path[path.size()-1]</literal> position.
                All indexes between are the path points that an actor should follow to reach the target without leaving the navigation mesh.</paragraph>
            <note>
                <paragraph>If the target position is on a different navigation mesh that is not merged or connected
                    the navigation path will lead to the closest possible position on the starting position navigation mesh.</paragraph>
            </note>
            <paragraph>The following script moves a Node3D inheriting node along a navigation path using
                the default navigation map by setting the target position with <literal>set_movement_target()</literal>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@onready var default_3d_map_rid: RID = get_world_3d().get_navigation_map()

var movement_speed: float = 4.0
var movement_delta: float
var path_point_margin: float = 0.5

var current_path_index: int = 0
var current_path_point: Vector3
var current_path: PackedVector3Array

func set_movement_target(target_position: Vector3):

    var start_position: Vector3 = global_transform.origin

    current_path = NavigationServer3D.map_get_path(
        default_3d_map_rid,
        start_position,
        target_position,
        true
    )

    if not current_path.is_empty():
        current_path_index = 0
        current_path_point = current_path[0]

func _physics_process(delta):

    if current_path.is_empty():
        return

    movement_delta = movement_speed * delta

    if global_transform.origin.distance_to(current_path_point) &lt;= path_point_margin:
        current_path_index += 1
        if current_path_index &gt;= current_path.size():
            current_path = []
            current_path_index = 0
            current_path_point = global_transform.origin
            return

    current_path_point = current_path[current_path_index]

    var new_velocity: Vector3 = global_transform.origin.direction_to(current_path_point) * movement_delta

    global_transform.origin = global_transform.origin.move_toward(global_transform.origin + new_velocity, movement_delta)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode3D : Node3D
{
    private Rid _default3DMapRid;

    private float _movementSpeed = 4.0f;
    private float _movementDelta;
    private float _pathPointMargin = 0.5f;

    private int _currentPathIndex = 0;
    private Vector3 _currentPathPoint;
    private Vector3[] _currentPath;

    public override void _Ready()
    {
        _default3DMapRid = GetWorld3D().NavigationMap;
    }

    private void SetMovementTarget(Vector3 targetPosition)
    {
        Vector3 startPosition = GlobalTransform.Origin;

        _currentPath = NavigationServer3D.MapGetPath(_default3DMapRid, startPosition, targetPosition, true);

        if (!_currentPath.IsEmpty())
        {
            _currentPathIndex = 0;
            _currentPathPoint = _currentPath[0];
        }
    }

    public override void _PhysicsProcess(double delta)
    {
        if (_currentPath.IsEmpty())
        {
            return;
        }

        _movementDelta = _movementSpeed * (float)delta;

        if (GlobalTransform.Origin.DistanceTo(_currentPathPoint) &lt;= _pathPointMargin)
        {
            _currentPathIndex += 1;
            if (_currentPathIndex &gt;= _currentPath.Length)
            {
                _currentPath = Array.Empty&lt;Vector3&gt;();
                _currentPathIndex = 0;
                _currentPathPoint = GlobalTransform.Origin;
                return;
            }
        }

        _currentPathPoint = _currentPath[_currentPathIndex];

        Vector3 newVelocity = GlobalTransform.Origin.DirectionTo(_currentPathPoint) * _movementDelta;
        var globalTransform = GlobalTransform;
        globalTransform.Origin = globalTransform.Origin.MoveToward(globalTransform.Origin + newVelocity, _movementDelta);
        GlobalTransform = globalTransform;
    }
}</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
