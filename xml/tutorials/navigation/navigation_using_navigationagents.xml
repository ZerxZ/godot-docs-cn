<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/navigation/navigation_using_navigationagents.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-navigation-using-navigationagents"></target>
    <section ids="using-navigationagents doc-navigation-using-navigationagents" names="using\ navigationagents 使用\ navigationagent doc_navigation_using_navigationagents">
        <title>使用 NavigationAgent</title>
        <paragraph>NavigationAgent 即导航代理，是一种辅助节点，能够为继承自 Node2D/3D 的父节点提供寻路、路径跟随、代理躲避等功能。这类节点会代替父级角色节点对 NavigationServer API 进行常见的调用，针对初学者进行了优化。</paragraph>
        <paragraph>2D 和 3D 版本的 NavigationAgent 分别是 <reference internal="True" refuri="../../classes/class_navigationagent2d#class-navigationagent2d"><inline classes="std std-ref">NavigationAgent2D</inline></reference> 和 <reference internal="True" refuri="../../classes/class_navigationagent3d#class-navigationagent3d"><inline classes="std std-ref">NavigationAgent3D</inline></reference>。</paragraph>
        <paragraph>新建的 NavigationAgent 节点会自动加入 <reference internal="True" refuri="../../classes/class_world2d#class-world2d"><inline classes="std std-ref">World2D</inline></reference>/<reference internal="True" refuri="../../classes/class_world3d#class-world3d"><inline classes="std std-ref">World3D</inline></reference> 的默认导航地图。</paragraph>
        <paragraph>NavigationsAgent 节点是可选的，不是使用导航系统的硬性要求。对应的功能都可以用脚本代替，替换为对 NavigationServer API 的直接调用。</paragraph>
        <section ids="navigationagent-pathfinding" names="navigationagent\ pathfinding navigationagent\ 寻路">
            <title>NavigationAgent 寻路</title>
            <paragraph>NavigationAgents query a new navigation path on their current navigation map when their <literal>target_position</literal> is set with a global position.</paragraph>
            <paragraph>匀速遍历, 然后, 可以用下面的伪代码。</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The <literal>navigation_layers</literal> bitmask can be used to limit the navigation meshes that the agent can use.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal>pathfinding_algorithm</literal> controls how the pathfinding travels through the navigation mesh polygons in the path search.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal>path_postprocessing</literal> sets if or how the raw path corridor found by the pathfinding is altered before it is returned.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal>path_metadata_flags</literal> enable the collection of additional path point meta data returned by the path.</paragraph>
                </list_item>
            </bullet_list>
            <warning>
                <paragraph>Disabling path meta flags will disable related signal emissions on the agent.</paragraph>
            </warning>
        </section>
        <section ids="navigationagent-pathfollowing" names="navigationagent\ pathfollowing navigationagent\ 路径跟随">
            <title>NavigationAgent 路径跟随</title>
            <paragraph>After a <literal>target_position</literal> has been set for the agent, the next position to follow in the path
                can be retrieved with the <literal>get_next_path_position()</literal> function.</paragraph>
            <paragraph>Once the next path position is received move the parent actor node of the agent
                towards this path position with your own movement code.</paragraph>
            <note>
                <paragraph>The navigation system never moves the parent node of a NavigationAgent.
                    The movement is entirely in the hands of users and their custom scripts.</paragraph>
            </note>
            <paragraph>NavigationAgents have their own internal logic to proceed with the current path and call for updates.</paragraph>
            <paragraph>The <literal>get_next_path_position()</literal> function is responsible for updating many of the agent's internal states and properties.
                The function should be repeatedly called <emphasis>once</emphasis> every <literal>physics_process</literal> until <literal>is_navigation_finished()</literal> tells that the path is finished.
                The function should not be called after the target position or path end has been reached
                as it can make the agent jitter in place due to the repeated path updates.
                Always check very early in script with <literal>is_navigation_finished()</literal> if the path is already finished.</paragraph>
            <paragraph>这个节点有如下属性可供设置。</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The <literal>path_desired_distance</literal> defines the distance at which the agent advances its internal path index to the next path position.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal>target_desired_distance</literal> defines the distance at which the agent considers the target position to be reached and the path at its end.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <literal>path_max_distance</literal> defines when an agent requests a new path cause it was moved too far away from the current path point segment.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The important updates are all triggered with the <literal>get_next_path_position()</literal> function
                when called in <literal>_physics_process()</literal>.</paragraph>
            <paragraph>NavigationAgents can be used with <literal>process</literal> but are still limited to a single update that happens in <literal>physics_process</literal>.</paragraph>
            <paragraph>Script examples for various nodes commonly used with NavigationAgents can be found further below.</paragraph>
            <section ids="pathfollowing-common-problems" names="pathfollowing\ common\ problems 运行以下命令">
                <title>运行以下命令</title>
                <paragraph>There are some common user problems and important caveats to consider when writing agent movement scripts.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <definition_list>
                            <definition_list_item>
                                <term>The path is returned empty</term>
                                <definition>
                                    <paragraph>If an agent queries a path before the navigation map synchronisation, e.g. in a <literal>_ready()</literal> function, the path might return empty. In this case the <literal>get_next_path_position()</literal> function will return the same position as the agent parent node and the agent will consider the path end reached. This is fixed by making a deferred call or using a callback e.g. waiting for the navigation map changed signal.</paragraph>
                                </definition>
                            </definition_list_item>
                        </definition_list>
                    </list_item>
                    <list_item>
                        <definition_list>
                            <definition_list_item>
                                <term>The agent is stuck dancing between two positions</term>
                                <definition>
                                    <paragraph>This is usually caused by very frequent path updates every single frame, either deliberate or by accident (e.g. max path distance set too short). The pathfinding needs to find the closest position that are valid on navigation mesh. If a new path is requested every single frame the first path positions might end up switching constantly in front and behind the agent's current position, causing it to dance between the two positions.</paragraph>
                                </definition>
                            </definition_list_item>
                        </definition_list>
                    </list_item>
                    <list_item>
                        <definition_list>
                            <definition_list_item>
                                <term>The agent is backtracking sometimes</term>
                                <definition>
                                    <paragraph>If an agent moves very fast it might overshoot the path_desired_distance check without ever advancing the path index. This can lead to the agent backtracking to the path point now behind it until it passes the distance check to increase the path index. Increase the desired distances accordingly for your agent speed and update rate usually fixes this as well as a more balanced navigation mesh polygon layout with not too many polygon edges cramped together in small spaces.</paragraph>
                                </definition>
                            </definition_list_item>
                        </definition_list>
                    </list_item>
                    <list_item>
                        <definition_list>
                            <definition_list_item>
                                <term>The agent is sometimes looking backwards for a frame</term>
                                <definition>
                                    <paragraph>Same as with stuck dancing agents between two positions, this is usually caused by very frequent path updates every single frame. Depending on your navigation mesh layout, and especially when an agent is directly placed over a navigation mesh edge or edge connection, expect path positions to be sometimes slightly "behind" your actors current orientation. This happens due to precision issues and can not always be avoided. This is usually only a visible problem if actors are instantly rotated to face the current path position.</paragraph>
                                </definition>
                            </definition_list_item>
                        </definition_list>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="navigationagent-avoidance" names="navigationagent\ avoidance navigationagent\ 避障">
            <title>NavigationAgent 避障</title>
            <paragraph>本节解释了如何使用 NavigationAgent 的导航避障功能。</paragraph>
            <paragraph>要让 NavigationAgent 使用避障功能，必须将 <literal>enable_avoidance</literal> 属性设置为 <literal>true</literal>。</paragraph>
            <image candidates="{'*': 'tutorials/navigation/img/agent_avoidance_enabled.png'}" uri="tutorials/navigation/img/agent_avoidance_enabled.png"></image>
            <paragraph>必须连接 NavigationAgent 节点的 <literal>velocity_computed</literal> 信号，接收安全速度的计算结果。</paragraph>
            <image candidates="{'*': 'tutorials/navigation/img/agent_safevelocity_signal.png'}" uri="tutorials/navigation/img/agent_safevelocity_signal.png"></image>
            <paragraph>请在 <literal>_physics_process()</literal> 中使用 NavigationAgent 节点的 <literal>set_velocity()</literal>，利用代理父节点的当前速度来更新代理。</paragraph>
            <paragraph>只要代理开启了避障，就可以在每个物理帧通过 velocity_computed 信号收到 <literal>safe_velocity</literal> 向量。应该使用这个速度向量来移动 NavigationAgent 的父节点，这样就能够避免撞到其他使用了避障的代理以及避障障碍物。</paragraph>
            <note>
                <paragraph>计算避障时只会考虑位于同一张地图中其他注册了避障的代理。</paragraph>
            </note>
            <paragraph>NavigationAgent 中与避障相关的属性如下：</paragraph>
            <block_quote>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>The property <literal>height</literal> is available in 3D only. The height together with the current global y-axis position of the agent determines the vertical placement of the agent in the avoidance simulation. Agents using the 2D avoidance will automatically ignore other agents or obstacles that are below or above them.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The property <literal>radius</literal> controls the size of the avoidance circle, or in case of 3D sphere, around the agent. This area describes the agents body and not the avoidance maneuver distance.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The property <literal>neighbor_distance</literal> controls the search radius of the agent when searching for other agents that should be avoided. A lower value reduces processing cost.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The property <literal>max_neighbors</literal> controls how many other agents are considered in the avoidance calculation if they all have overlapping radius.
                            A lower value reduces processing cost but a too low value may result in agents ignoring the avoidance.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The properties <literal>time_horizon_agents</literal> and <literal>time_horizon_obstacles</literal> control the avoidance prediction time for other agents or obstacles in seconds. When agents calculate their safe velocities they choose velocities that can be kept for this amount of seconds without colliding with another avoidance object. The prediction time should be kept as low as possible as agents will slow down their velocities to avoid collision in that timeframe.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The property <literal>max_speed</literal> controls the maximum velocity allowed for the agents avoidance calculation.
                            If the agents parents moves faster than this value the avoidance <literal>safe_velocity</literal> might not be accurate enough to avoid collision.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The property <literal>use_3d_avoidance</literal> switches the agent between the 2D avoidance (xz axis) and the 3D avoidance (xyz axis) on the next update.
                            Note that 2D avoidance and 3D avoidance run in separate avoidance simulations so agents split between them do not affect each other.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The properties <literal>avoidance_layers</literal> and <literal>avoidance_mask</literal> are bitmasks similar to e.g. physics layers. Agents will only avoid other avoidance objects that are on an avoidance layer that matches at least one of their own avoidance mask bits.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The <literal>avoidance_priority</literal> makes agents with a higher priority ignore agents with a lower priority. This can be used to give certain agents more importance in the avoidance simulation, e.g. important npcs characters, without constantly changing their entire avoidance layers or mask.</paragraph>
                    </list_item>
                </bullet_list>
            </block_quote>
            <paragraph>Avoidance exists in its own space and has no information from navigation meshes or physics collision.
                Behind the scene avoidance agents are just circles with different radius on a flat 2D plane or spheres in an otherwise empty 3D space.
                NavigationObstacles can be used to add some environment constrains to the avoidance simulation, see <reference internal="True" refuri="navigation_using_navigationobstacles#doc-navigation-using-navigationobstacles"><inline classes="std std-ref">使用 NavigationObstacle</inline></reference>.</paragraph>
            <note>
                <paragraph>Avoidance does not affect the pathfinding. It should be seen as an additional option for constantly moving objects that cannot be (re)baked to a navigation mesh efficiently in order to move around them.</paragraph>
            </note>
            <paragraph>Using the NavigationAgent <literal>enable_avoidance</literal> property is the preferred option
                to toggle avoidance. The following code snippets can be used to
                toggle avoidance on agents, create or delete avoidance callbacks or switch avoidance modes.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends NavigationAgent2D

var agent: RID = get_rid()
# Enable avoidance
NavigationServer2D.agent_set_avoidance_enabled(agent, true)
# Create avoidance callback
NavigationServer2D.agent_set_avoidance_callback(agent, Callable(self, "_avoidance_done"))

# Disable avoidance
NavigationServer2D.agent_set_avoidance_enabled(agent, false)
# Delete avoidance callback
NavigationServer2D.agent_set_avoidance_callback(agent, Callable())</literal_block>
                </div>
            </container>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends NavigationAgent3D

var agent: RID = get_rid()
# Enable avoidance
NavigationServer3D.agent_set_avoidance_enabled(agent, true)
# Create avoidance callback
NavigationServer3D.agent_set_avoidance_callback(agent, Callable(self, "_avoidance_done"))
# Switch to 3D avoidance
NavigationServer3D.agent_set_use_3d_avoidance(agent, true)

# Disable avoidance
NavigationServer3D.agent_set_avoidance_enabled(agent, false)
# Delete avoidance callback
NavigationServer3D.agent_set_avoidance_callback(agent, Callable())
# Switch to 2D avoidance
NavigationServer3D.agent_set_use_3d_avoidance(agent, false)</literal_block>
                </div>
            </container>
        </section>
        <section ids="navigationagent-script-templates" names="navigationagent\ script\ templates navigationagent\ 脚本模板">
            <title>NavigationAgent 脚本模板</title>
            <paragraph>The following sections provides script templates for nodes commonly used with NavigationAgents.</paragraph>
            <section ids="actor-as-node3d" names="actor\ as\ node3d 角色为\ node3d">
                <title>角色为 Node3D</title>
                <paragraph>This script adds basic navigation movement to a <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> with a <reference internal="True" refuri="../../classes/class_navigationagent3d#class-navigationagent3d"><inline classes="std std-ref">NavigationAgent3D</inline></reference> child node.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node3D

@export var movement_speed: float = 4.0
@onready var navigation_agent: NavigationAgent3D = get_node("NavigationAgent3D")
var movement_delta: float

func _ready() -&gt; void:
    navigation_agent.velocity_computed.connect(Callable(_on_velocity_computed))

func set_movement_target(movement_target: Vector3):
    navigation_agent.set_target_position(movement_target)

func _physics_process(delta):
    if navigation_agent.is_navigation_finished():
        return

    movement_delta = movement_speed * delta
    var next_path_position: Vector3 = navigation_agent.get_next_path_position()
    var new_velocity: Vector3 = global_position.direction_to(next_path_position) * movement_delta
    if navigation_agent.avoidance_enabled:
        navigation_agent.set_velocity(new_velocity)
    else:
        _on_velocity_computed(new_velocity)

func _on_velocity_computed(safe_velocity: Vector3) -&gt; void:
    global_position = global_position.move_toward(global_position + safe_velocity, movement_delta)</literal_block>
                    </div>
                </container>
            </section>
            <section ids="actor-as-characterbody3d" names="actor\ as\ characterbody3d 角色为\ characterbody3d">
                <title>角色为 CharacterBody3D</title>
                <paragraph>This script adds basic navigation movement to a <reference internal="True" refuri="../../classes/class_characterbody3d#class-characterbody3d"><inline classes="std std-ref">CharacterBody3D</inline></reference> with a <reference internal="True" refuri="../../classes/class_navigationagent3d#class-navigationagent3d"><inline classes="std std-ref">NavigationAgent3D</inline></reference> child node.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

@export var movement_speed: float = 4.0
@onready var navigation_agent: NavigationAgent3D = get_node("NavigationAgent3D")

func _ready() -&gt; void:
    navigation_agent.velocity_computed.connect(Callable(_on_velocity_computed))

func set_movement_target(movement_target: Vector3):
    navigation_agent.set_target_position(movement_target)

func _physics_process(delta):
    if navigation_agent.is_navigation_finished():
        return

    var next_path_position: Vector3 = navigation_agent.get_next_path_position()
    var new_velocity: Vector3 = global_position.direction_to(next_path_position) * movement_speed
    if navigation_agent.avoidance_enabled:
        navigation_agent.set_velocity(new_velocity)
    else:
        _on_velocity_computed(new_velocity)

func _on_velocity_computed(safe_velocity: Vector3):
    velocity = safe_velocity
    move_and_slide()</literal_block>
                    </div>
                </container>
            </section>
            <section ids="actor-as-rigidbody3d" names="actor\ as\ rigidbody3d 角色为\ rigidbody3d">
                <title>角色为 RigidBody3D</title>
                <paragraph>This script adds basic navigation movement to a <reference internal="True" refuri="../../classes/class_rigidbody3d#class-rigidbody3d"><inline classes="std std-ref">RigidBody3D</inline></reference> with a <reference internal="True" refuri="../../classes/class_navigationagent3d#class-navigationagent3d"><inline classes="std std-ref">NavigationAgent3D</inline></reference> child node.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends RigidBody3D

@export var movement_speed: float = 4.0
@onready var navigation_agent: NavigationAgent3D = get_node("NavigationAgent3D")

func _ready() -&gt; void:
    navigation_agent.velocity_computed.connect(Callable(_on_velocity_computed))

func set_movement_target(movement_target: Vector3):
    navigation_agent.set_target_position(movement_target)

func _physics_process(delta):
    if navigation_agent.is_navigation_finished():
        return

    var next_path_position: Vector3 = navigation_agent.get_next_path_position()
    var new_velocity: Vector3 = global_position.direction_to(next_path_position) * movement_speed
    if navigation_agent.avoidance_enabled:
        navigation_agent.set_velocity(new_velocity)
    else:
        _on_velocity_computed(new_velocity)

func _on_velocity_computed(safe_velocity: Vector3):
    linear_velocity = safe_velocity</literal_block>
                    </div>
                </container>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
