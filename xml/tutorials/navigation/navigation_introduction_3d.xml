<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/navigation/navigation_introduction_3d.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-navigation-overview-3d"></target>
    <section ids="d-navigation-overview doc-navigation-overview-3d" names="3d\ navigation\ overview doc_navigation_overview_3d">
        <title>3D navigation overview</title>
        <paragraph>Godot provides multiple objects, classes and servers to facilitate grid-based or mesh-based navigation and pathfinding for 2D and 3D games.
            The following section provides a quick overview over all available navigation related objects in Godot for 3D scenes and their primary use.</paragraph>
        <paragraph>Godot provides the following objects and classes for 3D navigation:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <definition_list>
                    <definition_list_item>
                        <term><reference internal="True" refuri="../../classes/class_astar3d#class-astar3d"><inline classes="std std-ref">Astar3D</inline></reference></term>
                        <definition>
                            <paragraph><literal>Astar3D</literal> objects provide an option to find the shortest path in a graph of weighted <strong>points</strong>.</paragraph>
                            <paragraph>The AStar3D class is best suited for cell-based 3D gameplay that does not require actors to reach any possible position within an area but only predefined, distinct positions.</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
            <list_item>
                <definition_list>
                    <definition_list_item>
                        <term><reference internal="True" refuri="../../classes/class_navigationserver3d#class-navigationserver3d"><inline classes="std std-ref">NavigationServer3D</inline></reference></term>
                        <definition>
                            <paragraph><literal>NavigationServer3D</literal> provides a powerful server API to find the shortest path between two positions on an area defined by a navigation mesh.</paragraph>
                            <paragraph>The NavigationServer is best suited for 3D realtime gameplay that does require actors to reach any possible position within a navigation mesh defined area.
                                Mesh-based navigation scales well with large game worlds as a large area can often be defined with a single polygon when it would require many, many grid cells.</paragraph>
                            <paragraph>The NavigationServer holds different navigation maps that each consist of regions that hold navigation mesh data.
                                Agents can be placed on a map for avoidance calculation.
                                RIDs are used to reference internal maps, regions, and agents when communicating with the server.</paragraph>
                            <definition_list>
                                <definition_list_item>
                                    <term>The following NavigationServer RID types are available.</term>
                                    <definition>
                                        <bullet_list bullet="-">
                                            <list_item>
                                                <definition_list>
                                                    <definition_list_item>
                                                        <term>NavMap RID</term>
                                                        <definition>
                                                            <paragraph>Reference to a specific navigation map that holds regions and agents.
                                                                The map will attempt to join the navigation meshes of the regions by proximity.
                                                                The map will synchronize regions and agents each physics frame.</paragraph>
                                                        </definition>
                                                    </definition_list_item>
                                                </definition_list>
                                            </list_item>
                                            <list_item>
                                                <definition_list>
                                                    <definition_list_item>
                                                        <term>NavRegion RID</term>
                                                        <definition>
                                                            <paragraph>Reference to a specific navigation region that can hold navigation mesh data.
                                                                The region can be enabled / disabled or the use restricted with a navigation layer bitmask.</paragraph>
                                                        </definition>
                                                    </definition_list_item>
                                                </definition_list>
                                            </list_item>
                                            <list_item>
                                                <definition_list>
                                                    <definition_list_item>
                                                        <term>NavLink RID</term>
                                                        <definition>
                                                            <paragraph>Reference to a specific navigation link that connects two navigation mesh positions over arbitrary distances.</paragraph>
                                                        </definition>
                                                    </definition_list_item>
                                                </definition_list>
                                            </list_item>
                                            <list_item>
                                                <definition_list>
                                                    <definition_list_item>
                                                        <term>NavAgent RID</term>
                                                        <definition>
                                                            <paragraph>Reference to a specific avoidance agent.
                                                                The avoidance is defined by a radius value.</paragraph>
                                                        </definition>
                                                    </definition_list_item>
                                                </definition_list>
                                            </list_item>
                                            <list_item>
                                                <definition_list>
                                                    <definition_list_item>
                                                        <term>NavObstacle RID</term>
                                                        <definition>
                                                            <paragraph>Reference to a specific avoidance obstacle used to affect and constrain the avoidance velocity of agents.</paragraph>
                                                        </definition>
                                                    </definition_list_item>
                                                </definition_list>
                                            </list_item>
                                        </bullet_list>
                                    </definition>
                                </definition_list_item>
                            </definition_list>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
        </bullet_list>
        <paragraph>The following scene tree nodes are available as helpers to work with the NavigationServer3D API.</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <definition_list>
                    <definition_list_item>
                        <term><reference internal="True" refuri="../../classes/class_navigationregion3d#class-navigationregion3d"><inline classes="std std-ref">NavigationRegion3D</inline></reference> Node</term>
                        <definition>
                            <paragraph>A Node that holds a Navigation Mesh resource that defines a navigation mesh for the NavigationServer3D.</paragraph>
                            <bullet_list bullet="-">
                                <list_item>
                                    <paragraph>The region can be enabled / disabled.</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>The use in pathfinding can be further restricted through the <literal>navigation_layers</literal> bitmask.</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>The NavigationServer3D will join the navigation meshes of regions by proximity for a combined navigation mesh.</paragraph>
                                </list_item>
                            </bullet_list>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
            <list_item>
                <definition_list>
                    <definition_list_item>
                        <term><reference internal="True" refuri="../../classes/class_navigationlink3d#class-navigationlink3d"><inline classes="std std-ref">NavigationLink3D</inline></reference> Node</term>
                        <definition>
                            <paragraph>A Node that connects two positions on navigation meshes over arbitrary distances for pathfinding.</paragraph>
                            <bullet_list bullet="-">
                                <list_item>
                                    <paragraph>The link can be enabled / disabled.</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>The link can be made one-way or bidirectional.</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>The use in pathfinding can be further restricted through the <literal>navigation_layers</literal> bitmask.</paragraph>
                                </list_item>
                            </bullet_list>
                            <paragraph>Links tell the pathfinding that a connection exists and at what cost. The actual agent handling and movement needs to happen in custom scripts.</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
            <list_item>
                <definition_list>
                    <definition_list_item>
                        <term><reference internal="True" refuri="../../classes/class_navigationagent3d#class-navigationagent3d"><inline classes="std std-ref">NavigationAgent3D</inline></reference> Node</term>
                        <definition>
                            <paragraph>A helper Node used to facilitate common NavigationServer3D API calls for pathfinding and avoidance.
                                Use this Node with a Node3D inheriting parent Node.</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
            <list_item>
                <definition_list>
                    <definition_list_item>
                        <term><reference internal="True" refuri="../../classes/class_navigationobstacle3d#class-navigationobstacle3d"><inline classes="std std-ref">NavigationObstacle3D</inline></reference> Node</term>
                        <definition>
                            <paragraph>A Node that can be used to affect and constrain the avoidance velocity of avoidance enabled agents.
                                This Node does NOT affect the pathfinding of agents. You need to change the navigation meshes for that instead.</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
        </bullet_list>
        <paragraph>The 3D navigation meshes are defined with the following resources:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <definition_list>
                    <definition_list_item>
                        <term><reference internal="True" refuri="../../classes/class_navigationmesh#class-navigationmesh"><inline classes="std std-ref">NavigationMesh</inline></reference> Resource</term>
                        <definition>
                            <paragraph>A resource that holds 3D navigation mesh data.
                                It provides 3D geometry baking options to define navigation areas inside the Editor as well as at runtime.</paragraph>
                            <bullet_list bullet="-">
                                <list_item>
                                    <paragraph>The NavigationRegion3D Node uses this resource to define its navigation area.</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>The NavigationServer3D uses this resource to update the navigation mesh of individual regions.</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>The GridMap Editor uses this resource when specific navigation meshes are defined for each grid cell.</paragraph>
                                </list_item>
                            </bullet_list>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
        </bullet_list>
        <seealso>
            <paragraph>You can see how 3D navigation works in action using the
                <reference name="3D Navigation demo project" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/3d/navigation">3D Navigation demo project</reference>.</paragraph>
        </seealso>
        <section ids="setup-for-3d-scene" names="setup\ for\ 3d\ scene">
            <title>Setup for 3D scene</title>
            <paragraph>The following steps show a basic setup for minimal viable navigation in 3D.
                It uses the NavigationServer3D and a NavigationAgent3D for path movement.</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Add a NavigationRegion3D Node to the scene.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Click on the region node and add a new <reference internal="True" refuri="../../classes/class_navigationmesh#class-navigationmesh"><inline classes="std std-ref">NavigationMesh</inline></reference> Resource to
                        the region node.</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_3d_min_setup_step1.png'}" original_uri="img/nav_3d_min_setup_step1.png" uri="tutorials/navigation/img/nav_3d_min_setup_step1.png"></image>
                </list_item>
                <list_item>
                    <paragraph>Add a new MeshInstance3D node as a child of the region node.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Select the MeshInstance3D node and add a new PlaneMesh and increase the xy size to 10.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Select the region node again and press the "Bake Navmesh" button on the top bar.</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_3d_min_setup_step2.png'}" original_uri="img/nav_3d_min_setup_step2.png" uri="tutorials/navigation/img/nav_3d_min_setup_step2.png"></image>
                </list_item>
                <list_item>
                    <paragraph>Now a transparent navigation mesh appears that hovers some distance on top of the PlaneMesh.</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_3d_min_setup_step3.png'}" original_uri="img/nav_3d_min_setup_step3.png" uri="tutorials/navigation/img/nav_3d_min_setup_step3.png"></image>
                </list_item>
                <list_item>
                    <paragraph>Add a CharacterBody3D node in the scene with a basic collision shape and some mesh for visuals.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Add a NavigationAgent3D node below the character node.</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_3d_min_setup_step4.webp'}" original_uri="img/nav_3d_min_setup_step4.webp" uri="tutorials/navigation/img/nav_3d_min_setup_step4.webp"></image>
                </list_item>
                <list_item>
                    <paragraph>Add a script to the CharacterBody3D node with the following content. We make sure to set a
                        movement target after the scene has fully loaded and the NavigationServer had time to sync.
                        Also, add a Camera3D and some light and environment to see something.</paragraph>
                </list_item>
            </enumerated_list>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

var movement_speed: float = 2.0
var movement_target_position: Vector3 = Vector3(-3.0,0.0,2.0)

@onready var navigation_agent: NavigationAgent3D = $NavigationAgent3D

func _ready():
    # These values need to be adjusted for the actor's speed
    # and the navigation layout.
    navigation_agent.path_desired_distance = 0.5
    navigation_agent.target_desired_distance = 0.5

    # Make sure to not await during _ready.
    actor_setup.call_deferred()

func actor_setup():
    # Wait for the first physics frame so the NavigationServer can sync.
    await get_tree().physics_frame

    # Now that the navigation map is no longer empty, set the movement target.
    set_movement_target(movement_target_position)

func set_movement_target(movement_target: Vector3):
    navigation_agent.set_target_position(movement_target)

func _physics_process(delta):
    if navigation_agent.is_navigation_finished():
        return

    var current_agent_position: Vector3 = global_position
    var next_path_position: Vector3 = navigation_agent.get_next_path_position()

    velocity = current_agent_position.direction_to(next_path_position) * movement_speed
    move_and_slide()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody3D : CharacterBody3D
{
    private NavigationAgent3D _navigationAgent;

    private float _movementSpeed = 2.0f;
    private Vector3 _movementTargetPosition = new Vector3(-3.0f, 0.0f, 2.0f);

    public Vector3 MovementTarget
    {
        get { return _navigationAgent.TargetPosition; }
        set { _navigationAgent.TargetPosition = value; }
    }

    public override void _Ready()
    {
        base._Ready();

        _navigationAgent = GetNode&lt;NavigationAgent3D&gt;("NavigationAgent3D");

        // These values need to be adjusted for the actor's speed
        // and the navigation layout.
        _navigationAgent.PathDesiredDistance = 0.5f;
        _navigationAgent.TargetDesiredDistance = 0.5f;

        // Make sure to not await during _Ready.
        Callable.From(ActorSetup).CallDeferred();
    }

    public override void _PhysicsProcess(double delta)
    {
        base._PhysicsProcess(delta);

        if (_navigationAgent.IsNavigationFinished())
        {
            return;
        }

        Vector3 currentAgentPosition = GlobalTransform.Origin;
        Vector3 nextPathPosition = _navigationAgent.GetNextPathPosition();

        Velocity = currentAgentPosition.DirectionTo(nextPathPosition) * _movementSpeed;
        MoveAndSlide();
    }

    private async void ActorSetup()
    {
        // Wait for the first physics frame so the NavigationServer can sync.
        await ToSignal(GetTree(), SceneTree.SignalName.PhysicsFrame);

        // Now that the navigation map is no longer empty, set the movement target.
        MovementTarget = _movementTargetPosition;
    }
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph>On the first frame the NavigationServer map has not synchronized region data and any path query will return empty. Wait for the NavigationServer synchronization by awaiting one frame in the script.</paragraph>
            </note>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
