<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/navigation/navigation_using_navigationmeshes.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-navigation-using-navigationmeshes"></target>
    <section ids="using-navigation-meshes doc-navigation-using-navigationmeshes" names="using\ navigation\ meshes 使用导航网格 doc_navigation_using_navigationmeshes">
        <title>使用导航网格</title>
        <image candidates="{'*': 'tutorials/navigation/img/nav_meshes.webp'}" uri="tutorials/navigation/img/nav_meshes.webp"></image>
        <paragraph>2D 和 3D 版本的导航网格分别为 <reference internal="True" refuri="../../classes/class_navigationpolygon#class-navigationpolygon"><inline classes="std std-ref">NavigationPolygon</inline></reference> 和 <reference internal="True" refuri="../../classes/class_navigationmesh#class-navigationmesh"><inline classes="std std-ref">NavigationMesh</inline></reference>。</paragraph>
        <note>
            <paragraph>导航网格描述的只是代理中心位置的可达区域，会忽略代理可能存在的半径值。如果你想要让寻路考虑代理的（碰撞）尺寸，就需要让导航网格收缩对应的量。</paragraph>
        </note>
        <paragraph>导航系统的工作独立于渲染或物理等其他引擎部分。导航系统在寻路时只考虑导航网格，视觉效果和碰撞形状等会被导航系统完全忽略。如果在寻路时需要考虑其他数据（例如视觉效果），则需要对导航网格进行相应调整。在导航网格中考虑导航限制的过程通常称为导航网格烘焙。</paragraph>
        <figure align="center" ids="id1">
            <image alt="导航网格凸多边形与凹多边形的比较" candidates="{'*': 'tutorials/navigation/img/nav_mesh_vs_physics.webp'}" uri="tutorials/navigation/img/nav_mesh_vs_physics.webp"></image>
            <caption>导航网格描述的是代理的中心点能够安全站立的表面，而物理形状描述的则是外部的碰撞范围。</caption>
        </figure>
        <paragraph>如果你在遵循导航路径时遇到剪切或碰撞问题，请务必记住，你需要通过合适的导航网格告诉导航系统你的意图。导航系统本身永远不会知道 "这是树木/岩石/墙壁碰撞形状或可视化网格"，因为它只知道 "我被告知在这里可以安全通过，因为它在导航网格上"。</paragraph>
        <target refid="doc-navigation-navmesh-baking"></target>
        <paragraph ids="doc-navigation-navmesh-baking" names="doc_navigation_navmesh_baking">导航网格的烘焙可以使用 <reference internal="True" refuri="../../classes/class_navigationregion2d#class-navigationregion2d"><inline classes="std std-ref">NavigationRegion2D</inline></reference> 或 <reference internal="True" refuri="../../classes/class_navigationregion3d#class-navigationregion3d"><inline classes="std std-ref">NavigationRegion3D</inline></reference> 实现，也可以直接使用 <reference internal="True" refuri="../../classes/class_navigationserver2d#class-navigationserver2d"><inline classes="std std-ref">NavigationServer2D</inline></reference> 和 <reference internal="True" refuri="../../classes/class_navigationserver3d#class-navigationserver3d"><inline classes="std std-ref">NavigationServer3D</inline></reference> 的 API。</paragraph>
        <target refid="doc-navigation-using-navigationmeshes-baking-navigation-mesh-with-navigationregion"></target>
        <section ids="baking-a-navigation-mesh-with-a-navigationregion doc-navigation-using-navigationmeshes-baking-navigation-mesh-with-navigationregion" names="baking\ a\ navigation\ mesh\ with\ a\ navigationregion 使用导航区块\ navigationregion\ 烘焙导航网格 doc_navigation_using_navigationmeshes_baking_navigation_mesh_with_navigationregion">
            <title>使用导航区块 NavigationRegion 烘焙导航网格</title>
            <figure align="center" ids="id2">
                <image alt="烘焙导航网格的步骤" candidates="{'*': 'tutorials/navigation/img/nav_mesh_baking_steps.gif'}" uri="tutorials/navigation/img/nav_mesh_baking_steps.gif"></image>
                <caption>根据代理半径和几何体之间的偏移量烘焙导航网格。</caption>
            </figure>
            <paragraph>使用导航区块节点可以更方便地进行导航网格烘焙。使用导航区域节点进行烘焙时，所有解析、烘焙和区块更新步骤都会合并到一个函数中。</paragraph>
            <paragraph>The nodes are available in 2D and 3D as <reference internal="True" refuri="../../classes/class_navigationregion2d#class-navigationregion2d"><inline classes="std std-ref">NavigationRegion2D</inline></reference> and <reference internal="True" refuri="../../classes/class_navigationregion3d#class-navigationregion3d"><inline classes="std std-ref">NavigationRegion3D</inline></reference> respectively.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-0-0" aria-selected="true" classes="sphinx-tabs-tab" ids="tab-0-0-0" name="0-0" role="tab" tabindex="0">Baking with a NavigationRegion2D</button>
                    <button aria-controls="panel-0-0-1" aria-selected="false" classes="sphinx-tabs-tab" ids="tab-0-0-1" name="0-1" role="tab" tabindex="-1">Baking with a NavigationRegion3D</button>
                </div>
                <div aria-labelledby="tab-0-0-0" classes="sphinx-tabs-panel" ids="panel-0-0-0" name="0-0" role="tabpanel" tabindex="0">
                    <paragraph>在编辑器中选择导航区块2D节点时，编辑器顶部栏会显示烘焙选项和多边形绘制工具。</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_region_baking_01.webp'}" uri="tutorials/navigation/img/nav_region_baking_01.webp"></image>
                    <paragraph>为了使区块工作，需要添加一个 <reference internal="True" refuri="../../classes/class_navigationpolygon#class-navigationpolygon"><inline classes="std std-ref">NavigationPolygon</inline></reference> 资源。</paragraph>
                    <paragraph>The properties to parse and bake a navigation mesh are then part of the used resource and can be found in the resource Inspector.</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_region_baking_02.webp'}" uri="tutorials/navigation/img/nav_region_baking_02.webp"></image>
                    <paragraph>The result of the source geometry parsing can be influenced with the following properties.</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>The <literal>parsed_geometry_type</literal> that filters if visual objects or physics objects or both should be parsed from the <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.
                                For more details on what objects are parsed and how, see the section about parsing source geometry below.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The <literal>collision_mask</literal> filters which physics collision objects are included when the <literal>parsed_geometry_type</literal> includes static colliders.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The <literal>source_geometry_mode</literal> that defines on which node(s) to start the parsing, and how to traverse the <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The <literal>source_geometry_group_name</literal> is used when only a certain node group should be parsed. Depends on the selected <literal>source_geometry_mode</literal>.</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>With the source geometry added, the result of the baking can be controlled with the following properties.</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>The <literal>cell_size</literal> sets the rasterization grid size and should match the navigation map size.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The <literal>agent_radius</literal> shrinks the baked navigation mesh to have enough margin for the agent (collision) size.</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>The NavigationRegion2D baking can also be used at runtime with scripts.</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        </div>
                        <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var on_thread: bool = true
bake_navigation_polygon(on_thread)</literal_block>
                        </div>
                    </container>
                    <paragraph>要使用默认设置快速测试 2D 烘焙：</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>添加一个 <reference internal="True" refuri="../../classes/class_navigationregion2d#class-navigationregion2d"><inline classes="std std-ref">NavigationRegion2D</inline></reference>。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>为 NavigationRegion2D 添加一个 <reference internal="True" refuri="../../classes/class_navigationpolygon#class-navigationpolygon"><inline classes="std std-ref">NavigationPolygon</inline></reference> 资源。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>在 NavigationRegion2D 下面添加一个 <reference internal="True" refuri="../../classes/class_polygon2d#class-polygon2d"><inline classes="std std-ref">Polygon2D</inline></reference>。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>使用选中的 NavigationRegion2D 绘制工具绘制一个 NavigationPolygon 轮廓。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>使用选中的 Polygon2D 绘制工具在 NavigationPolygon 轮廓中绘制一个 Polygon2D 轮廓。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>点击编辑器的烘焙按钮，就会出现导航网格。</paragraph>
                        </list_item>
                    </bullet_list>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_region_baking_01.webp'}" uri="tutorials/navigation/img/nav_region_baking_01.webp"></image>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_mesh_mini_2d.webp'}" uri="tutorials/navigation/img/nav_mesh_mini_2d.webp"></image>
                </div>
                <div aria-labelledby="tab-0-0-1" classes="sphinx-tabs-panel" hidden="true" ids="panel-0-0-1" name="0-1" role="tabpanel" tabindex="0">
                    <paragraph>When a NavigationRegion3D node is selected in the Editor, bake options appear in the top bar of the Editor.</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_mesh_bake_toolbar.webp'}" uri="tutorials/navigation/img/nav_mesh_bake_toolbar.webp"></image>
                    <paragraph>In order for the region to work a <reference internal="True" refuri="../../classes/class_navigationmesh#class-navigationmesh"><inline classes="std std-ref">NavigationMesh</inline></reference> resource needs to be added.</paragraph>
                    <paragraph>The properties to parse and bake a navigation mesh are then part of the used resource and can be found in the resource Inspector.</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_region3d_baking_01.webp'}" uri="tutorials/navigation/img/nav_region3d_baking_01.webp"></image>
                    <paragraph>The result of the source geometry parsing can be influenced with the following properties.</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>The <literal>parsed_geometry_type</literal> that filters if visual objects or physics objects or both should be parsed from the <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.
                                For more details on what objects are parsed and how, see the section about parsing source geometry below.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The <literal>collision_mask</literal> filters which physics collision objects are included when the <literal>parsed_geometry_type</literal> includes static colliders.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The <literal>source_geometry_mode</literal> that defines on which node(s) to start the parsing, and how to traverse the <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The <literal>source_geometry_group_name</literal> is used when only a certain node group should be parsed. Depends on the selected <literal>source_geometry_mode</literal>.</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>With the source geometry added, the result of the baking can be controlled with the following properties.</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>The <literal>cell_size</literal> and <literal>cell_height</literal> sets the rasterization voxel grid size and should match the navigation map size.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The <literal>agent_radius</literal> shrinks the baked navigation mesh to have enough margin for the agent (collision) size.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The <literal>agent_height</literal> excludes areas from the navigation mesh where the agent is too tall to fit in.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>The <literal>agent_max_climb</literal> and <literal>agent_max_slope</literal> removes areas where the height difference between neighboring voxels is too large, or where their surface is too steep.</paragraph>
                        </list_item>
                    </bullet_list>
                    <warning>
                        <paragraph>A too small <literal>cell_size</literal> or <literal>cell_height</literal> can create so many voxels that it has the potential to freeze the game or even crash.</paragraph>
                    </warning>
                    <paragraph>The NavigationRegion3D baking can also be used at runtime with scripts.</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        </div>
                        <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var on_thread: bool = true
bake_navigation_mesh(on_thread)</literal_block>
                        </div>
                    </container>
                    <paragraph>要使用默认设置快速测试 3D 烘焙：</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>添加一个 <reference internal="True" refuri="../../classes/class_navigationregion3d#class-navigationregion3d"><inline classes="std std-ref">NavigationRegion3D</inline></reference>。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>为 NavigationRegion3D 添加一个 <reference internal="True" refuri="../../classes/class_navigationmesh#class-navigationmesh"><inline classes="std std-ref">NavigationMesh</inline></reference> 资源。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>在 NavigationRegion3D 下面添加一个 <reference internal="True" refuri="../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference>。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>为 MeshInstance3D 添加一个 <reference internal="True" refuri="../../classes/class_planemesh#class-planemesh"><inline classes="std std-ref">PlaneMesh</inline></reference>。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>点击编辑器的烘焙按钮，就会出现导航网格。</paragraph>
                        </list_item>
                    </bullet_list>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_mesh_bake_toolbar.webp'}" uri="tutorials/navigation/img/nav_mesh_bake_toolbar.webp"></image>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_mesh_mini_3d.webp'}" uri="tutorials/navigation/img/nav_mesh_mini_3d.webp"></image>
                </div>
            </container>
            <target refid="doc-navigation-using-navigationmeshes-baking-navigation-mesh-with-navigationserver"></target>
        </section>
        <section ids="baking-a-navigation-mesh-with-the-navigationserver doc-navigation-using-navigationmeshes-baking-navigation-mesh-with-navigationserver" names="baking\ a\ navigation\ mesh\ with\ the\ navigationserver 使用\ navigationserver\ 烘焙导航网格 doc_navigation_using_navigationmeshes_baking_navigation_mesh_with_navigationserver">
            <title>使用 NavigationServer 烘焙导航网格</title>
            <paragraph>The <reference internal="True" refuri="../../classes/class_navigationserver2d#class-navigationserver2d"><inline classes="std std-ref">NavigationServer2D</inline></reference> and <reference internal="True" refuri="../../classes/class_navigationserver3d#class-navigationserver3d"><inline classes="std std-ref">NavigationServer3D</inline></reference> have API functions to call each step of the navigation mesh baking process individually.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>parse_source_geometry_data()</literal> can be used to parse source geometry to a reusable and serializable resource.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>bake_from_source_geometry_data()</literal> can be used to bake a navigation mesh from already parsed data e.g. to avoid runtime performance issues with (redundant) parsing.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>bake_from_source_geometry_data_async()</literal> is the same but bakes the navigation mesh deferred with threads, not blocking the main thread.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Compared to a NavigationRegion, the NavigationServer offers finer control over the navigation mesh baking process.
                In turn it is more complex to use but also provides more advanced options.</paragraph>
            <paragraph>Some other advantages of the NavigationServer over a NavigationRegion are:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The server can parse source geometry without baking, e.g. to cache it for later use.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The server allows selecting the root node at which to start the source geometry parsing manually.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The server can accept and bake from procedurally generated source geometry data.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The server can bake multiple navigation meshes in sequence while (re)using the same source geometry data.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>To bake navigation meshes with the NavigationServer, source geometry is required.
                Source geometry is geometry data that should be considered in a navigation mesh baking process.
                Both navigation meshes for 2D and 3D are created by baking them from source geometry.</paragraph>
            <paragraph>2D and 3D versions of the source geometry resources are available as
                <reference internal="True" refuri="../../classes/class_navigationmeshsourcegeometrydata2d#class-navigationmeshsourcegeometrydata2d"><inline classes="std std-ref">NavigationMeshSourceGeometryData2D</inline></reference> and
                <reference internal="True" refuri="../../classes/class_navigationmeshsourcegeometrydata3d#class-navigationmeshsourcegeometrydata3d"><inline classes="std std-ref">NavigationMeshSourceGeometryData3D</inline></reference>  respectively.</paragraph>
            <paragraph>Source geometry can be geometry parsed from visual meshes, from physics collision,
                or procedural created arrays of data, like outlines (2D) and triangle faces (3D).
                For convenience, source geometry is commonly parsed directly from node setups in the SceneTree.
                For runtime navigation mesh (re)bakes, be aware that the geometry parsing always happens on the main thread.</paragraph>
            <note>
                <paragraph>The SceneTree is not thread-safe. Parsing source geometry from the SceneTree can only be done on the main thread.</paragraph>
            </note>
            <warning>
                <paragraph>The data from visual meshes and polygons needs to be received from the GPU, stalling the RenderingServer in the process.
                    For runtime (re)baking prefer using physics shapes as parsed source geometry.</paragraph>
            </warning>
            <paragraph>Source geometry is stored inside resources so the created geometry can be reused for multiple bakes.
                E.g. baking multiple navigation meshes for different agent sizes from the same source geometry.
                This also allows to save source geometry to disk so it can be loaded later, e.g. to avoid the overhead of parsing it again at runtime.</paragraph>
            <paragraph>The geometry data should be in general kept very simple. As many edges as are required but as few as possible.
                Especially in 2D duplicated and nested geometry should be avoided as it forces polygon hole calculation that can result in flipped polygons.
                An example for nested geometry would be a smaller StaticBody2D shape placed completely inside the bounds of another StaticBody2D shape.</paragraph>
        </section>
        <section ids="navigation-mesh-baking-common-problems" names="navigation\ mesh\ baking\ common\ problems">
            <title>Navigation mesh baking common problems</title>
            <paragraph>There are some common user problems and important caveats to consider when creating or baking navigation meshes.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term>Navigation mesh baking creates frame rate problems at runtime</term>
                            <definition>
                                <paragraph>The navigation mesh baking is by default done on a background thread, so as long as the platform supports threads, the actual baking is
                                    rarely the source of any performance issues (assuming a reasonably sized and complex geometry for runtime rebakes).</paragraph>
                                <paragraph>The common source for performance issues at runtime is the parsing step for source geometry that involves nodes and the SceneTree.
                                    The SceneTree is not thread-safe so all the nodes need to be parsed on the main thread.
                                    Some nodes with a lot of data can be very heavy and slow to parse at runtime, e.g. a TileMap has one or more polygons for every single used cell and TileMapLayer to parse.
                                    Nodes that hold meshes need to request the data from the RenderingServer stalling the rendering in the process.</paragraph>
                                <paragraph>To improve performance, use more optimized shapes, e.g. collision shapes over detailed visual meshes, and merge and simplify as much geometry as possible upfront.
                                    If nothing helps, don't parse the SceneTree and add the source geometry procedural with scripts. If only pure data arrays are used as source geometry, the entire baking process can be done on a background thread.</paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term>Navigation mesh creates unintended holes in 2D.</term>
                            <definition>
                                <paragraph>The navigation mesh baking in 2D is done by doing polygon clipping operations based on outline paths.
                                    Polygons with "holes" are a necessary evil to create more complex 2D polygons but can become unpredictable for users with many complex shapes involved.</paragraph>
                                <paragraph>To avoid any unexpected problems with polygon hole calculations, avoid nesting any outlines inside other outlines of the same type (traversable / obstruction).
                                    This includes the parsed shapes from nodes. E.g. placing a smaller StaticBody2D shape inside a larger StaticBody2D shape can result in the resulting polygon being flipped.</paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term>Navigation mesh appears inside geometry in 3D.</term>
                            <definition>
                                <paragraph>The navigation mesh baking in 3D has no concept of "inside". The voxel cells used to rasterize the geometry are either occupied or not.
                                    Remove the geometry that is on the ground inside the other geometry. If that is not possible, add smaller "dummy" geometry inside with as few triangles as possible so the cells
                                    are occupied with something.</paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
            </bullet_list>
        </section>
        <section ids="navigation-mesh-script-templates" names="navigation\ mesh\ script\ templates">
            <title>Navigation mesh script templates</title>
            <paragraph>The following script uses the NavigationServer to parse source geometry from the scene tree, bakes a navigation mesh, and updates a navigation region with the updated navigation mesh.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-MkQgR0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-MkQgR0RTY3JpcHQ=" name="MkQgR0RTY3JpcHQ=" role="tab" tabindex="0">2D GDScript</button>
                    <button aria-controls="panel-3-M0QgR0RTY3JpcHQ=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-M0QgR0RTY3JpcHQ=" name="M0QgR0RTY3JpcHQ=" role="tab" tabindex="-1">3D GDScript</button>
                </div>
                <div aria-labelledby="tab-3-MkQgR0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-MkQgR0RTY3JpcHQ=" name="MkQgR0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

var navigation_mesh: NavigationPolygon
var source_geometry : NavigationMeshSourceGeometryData2D
var callback_parsing : Callable
var callback_baking : Callable
var region_rid: RID

func _ready() -&gt; void:
    navigation_mesh = NavigationPolygon.new()
    navigation_mesh.agent_radius = 10.0
    source_geometry = NavigationMeshSourceGeometryData2D.new()
    callback_parsing = on_parsing_done
    callback_baking = on_baking_done
    region_rid = NavigationServer2D.region_create()

    # Enable the region and set it to the default navigation map.
    NavigationServer2D.region_set_enabled(region_rid, true)
    NavigationServer2D.region_set_map(region_rid, get_world_2d().get_navigation_map())

    # Some mega-nodes like TileMap are often not ready on the first frame.
    # Also the parsing needs to happen on the main-thread.
    # So do a deferred call to avoid common parsing issues.
    parse_source_geometry.call_deferred()

func parse_source_geometry() -&gt; void:
    source_geometry.clear()
    var root_node: Node2D = self

    # Parse the obstruction outlines from all child nodes of the root node by default.
    NavigationServer2D.parse_source_geometry_data(
        navigation_mesh,
        source_geometry,
        root_node,
        callback_parsing
    )

func on_parsing_done() -&gt; void:
    # If we did not parse a TileMap with navigation mesh cells we may now only
    # have obstruction outlines so add at least one traversable outline
    # so the obstructions outlines have something to "cut" into.
    source_geometry.add_traversable_outline(PackedVector2Array([
        Vector2(0.0, 0.0),
        Vector2(500.0, 0.0),
        Vector2(500.0, 500.0),
        Vector2(0.0, 500.0)
    ]))

    # Bake the navigation mesh on a thread with the source geometry data.
    NavigationServer2D.bake_from_source_geometry_data_async(
        navigation_mesh,
        source_geometry,
        callback_baking
    )

func on_baking_done() -&gt; void:
    # Update the region with the updated navigation mesh.
    NavigationServer2D.region_set_navigation_polygon(region_rid, navigation_mesh)</literal_block>
                </div>
                <div aria-labelledby="tab-3-M0QgR0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-M0QgR0RTY3JpcHQ=" name="M0QgR0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node3D

var navigation_mesh: NavigationMesh
var source_geometry : NavigationMeshSourceGeometryData3D
var callback_parsing : Callable
var callback_baking : Callable
var region_rid: RID

func _ready() -&gt; void:
    navigation_mesh = NavigationMesh.new()
    navigation_mesh.agent_radius = 0.5
    source_geometry = NavigationMeshSourceGeometryData3D.new()
    callback_parsing = on_parsing_done
    callback_baking = on_baking_done
    region_rid = NavigationServer3D.region_create()

    # Enable the region and set it to the default navigation map.
    NavigationServer3D.region_set_enabled(region_rid, true)
    NavigationServer3D.region_set_map(region_rid, get_world_3d().get_navigation_map())

    # Some mega-nodes like GridMap are often not ready on the first frame.
    # Also the parsing needs to happen on the main-thread.
    # So do a deferred call to avoid common parsing issues.
    parse_source_geometry.call_deferred()

func parse_source_geometry() -&gt; void:
    source_geometry.clear()
    var root_node: Node3D = self

    # Parse the geometry from all mesh child nodes of the root node by default.
    NavigationServer3D.parse_source_geometry_data(
        navigation_mesh,
        source_geometry,
        root_node,
        callback_parsing
    )

func on_parsing_done() -&gt; void:
    # Bake the navigation mesh on a thread with the source geometry data.
    NavigationServer3D.bake_from_source_geometry_data_async(
        navigation_mesh,
        source_geometry,
        callback_baking
    )

func on_baking_done() -&gt; void:
    # Update the region with the updated navigation mesh.
    NavigationServer3D.region_set_navigation_mesh(region_rid, navigation_mesh)</literal_block>
                </div>
            </container>
            <paragraph>The following script uses the NavigationServer to update a navigation region with procedurally generated navigation mesh data.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-MkQgR0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-MkQgR0RTY3JpcHQ=" name="MkQgR0RTY3JpcHQ=" role="tab" tabindex="0">2D GDScript</button>
                    <button aria-controls="panel-4-M0QgR0RTY3JpcHQ=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-M0QgR0RTY3JpcHQ=" name="M0QgR0RTY3JpcHQ=" role="tab" tabindex="-1">3D GDScript</button>
                </div>
                <div aria-labelledby="tab-4-MkQgR0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-MkQgR0RTY3JpcHQ=" name="MkQgR0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

var navigation_mesh: NavigationPolygon
var region_rid: RID

func _ready() -&gt; void:
    navigation_mesh = NavigationPolygon.new()
    region_rid = NavigationServer2D.region_create()

    # Enable the region and set it to the default navigation map.
    NavigationServer2D.region_set_enabled(region_rid, true)
    NavigationServer2D.region_set_map(region_rid, get_world_2d().get_navigation_map())

    # Add vertices for a convex polygon.
    navigation_mesh.vertices = PackedVector2Array([
        Vector2(0.0, 0.0),
        Vector2(100.0, 0.0),
        Vector2(100.0, 100.0),
        Vector2(0.0, 100.0)
    ])

    # Add indices for the polygon.
    navigation_mesh.add_polygon(
        PackedInt32Array([0, 1, 2, 3])
    )

    NavigationServer2D.region_set_navigation_polygon(region_rid, navigation_mesh)</literal_block>
                </div>
                <div aria-labelledby="tab-4-M0QgR0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-M0QgR0RTY3JpcHQ=" name="M0QgR0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node3D

var navigation_mesh: NavigationMesh
var region_rid: RID

func _ready() -&gt; void:
    navigation_mesh = NavigationMesh.new()
    region_rid = NavigationServer3D.region_create()

    # Enable the region and set it to the default navigation map.
    NavigationServer3D.region_set_enabled(region_rid, true)
    NavigationServer3D.region_set_map(region_rid, get_world_3d().get_navigation_map())

    # Add vertices for a convex polygon.
    navigation_mesh.vertices = PackedVector3Array([
        Vector3(-1.0, 0.0, 1.0),
        Vector3(1.0, 0.0, 1.0),
        Vector3(1.0, 0.0, -1.0),
        Vector3(-1.0, 0.0, -1.0),
    ])

    # Add indices for the polygon.
    navigation_mesh.add_polygon(
        PackedInt32Array([0, 1, 2, 3])
    )

    NavigationServer3D.region_set_navigation_mesh(region_rid, navigation_mesh)</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
