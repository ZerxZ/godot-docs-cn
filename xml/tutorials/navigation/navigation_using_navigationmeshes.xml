<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/navigation/navigation_using_navigationmeshes.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-navigation-using-navigationmeshes"></target>
    <section ids="using-navigation-meshes doc-navigation-using-navigationmeshes" names="using\ navigation\ meshes 使用导航网格 doc_navigation_using_navigationmeshes">
        <title>使用导航网格</title>
        <image candidates="{'*': 'tutorials/navigation/img/nav_meshes.webp'}" uri="tutorials/navigation/img/nav_meshes.webp"></image>
        <paragraph>2D 和 3D 版本的导航网格分别为 <reference internal="True" refuri="../../classes/class_navigationpolygon#class-navigationpolygon"><inline classes="std std-ref">NavigationPolygon</inline></reference> 和 <reference internal="True" refuri="../../classes/class_navigationmesh#class-navigationmesh"><inline classes="std std-ref">NavigationMesh</inline></reference>。</paragraph>
        <note>
            <paragraph>导航网格描述的只是代理中心位置的可达区域，会忽略代理可能存在的半径值。如果你想要让寻路考虑代理的（碰撞）尺寸，就需要让导航网格收缩对应的量。</paragraph>
        </note>
        <paragraph>导航系统的工作独立于渲染或物理等其他引擎部分。导航系统在寻路时只考虑导航网格，视觉效果和碰撞形状等会被导航系统完全忽略。如果在寻路时需要考虑其他数据（例如视觉效果），则需要对导航网格进行相应调整。在导航网格中考虑导航限制的过程通常称为导航网格烘焙。</paragraph>
        <figure align="center" ids="id1">
            <image alt="导航网格凸多边形与凹多边形的比较" candidates="{'*': 'tutorials/navigation/img/nav_mesh_vs_physics.webp'}" uri="tutorials/navigation/img/nav_mesh_vs_physics.webp"></image>
            <caption>导航网格描述的是代理的中心点能够安全站立的表面，而物理形状描述的则是外部的碰撞范围。</caption>
        </figure>
        <paragraph>如果你在遵循导航路径时遇到剪切或碰撞问题，请务必记住，你需要通过合适的导航网格告诉导航系统你的意图。导航系统本身永远不会知道 "这是树木/岩石/墙壁碰撞形状或可视化网格"，因为它只知道 "我被告知在这里可以安全通过，因为它在导航网格上"。</paragraph>
        <target refid="doc-navigation-navmesh-baking"></target>
        <paragraph ids="doc-navigation-navmesh-baking" names="doc_navigation_navmesh_baking">导航网格的烘焙可以使用 <reference internal="True" refuri="../../classes/class_navigationregion2d#class-navigationregion2d"><inline classes="std std-ref">NavigationRegion2D</inline></reference> 或 <reference internal="True" refuri="../../classes/class_navigationregion3d#class-navigationregion3d"><inline classes="std std-ref">NavigationRegion3D</inline></reference> 实现，也可以直接使用 <reference internal="True" refuri="../../classes/class_navigationserver2d#class-navigationserver2d"><inline classes="std std-ref">NavigationServer2D</inline></reference> 和 <reference internal="True" refuri="../../classes/class_navigationserver3d#class-navigationserver3d"><inline classes="std std-ref">NavigationServer3D</inline></reference> 的 API。</paragraph>
        <target refid="doc-navigation-using-navigationmeshes-baking-navigation-mesh-with-navigationregion"></target>
        <section ids="baking-a-navigation-mesh-with-a-navigationregion doc-navigation-using-navigationmeshes-baking-navigation-mesh-with-navigationregion" names="baking\ a\ navigation\ mesh\ with\ a\ navigationregion 使用导航区块\ navigationregion\ 烘焙导航网格 doc_navigation_using_navigationmeshes_baking_navigation_mesh_with_navigationregion">
            <title>使用导航区块 NavigationRegion 烘焙导航网格</title>
            <figure align="center" ids="id2">
                <image alt="烘焙导航网格的步骤" candidates="{'*': 'tutorials/navigation/img/nav_mesh_baking_steps.gif'}" uri="tutorials/navigation/img/nav_mesh_baking_steps.gif"></image>
                <caption>根据代理半径和几何体之间的偏移量烘焙导航网格。</caption>
            </figure>
            <paragraph>使用导航区块节点可以更方便地进行导航网格烘焙。使用导航区域节点进行烘焙时，所有解析、烘焙和区块更新步骤都会合并到一个函数中。</paragraph>
            <paragraph>The nodes are available in 2D and 3D as <reference internal="True" refuri="../../classes/class_navigationregion2d#class-navigationregion2d"><inline classes="std std-ref">NavigationRegion2D</inline></reference> and <reference internal="True" refuri="../../classes/class_navigationregion3d#class-navigationregion3d"><inline classes="std std-ref">NavigationRegion3D</inline></reference> respectively.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-0-0" aria-selected="true" classes="sphinx-tabs-tab" ids="tab-0-0-0" name="0-0" role="tab" tabindex="0">Baking with a NavigationRegion2D</button>
                    <button aria-controls="panel-0-0-1" aria-selected="false" classes="sphinx-tabs-tab" ids="tab-0-0-1" name="0-1" role="tab" tabindex="-1">Baking with a NavigationRegion3D</button>
                </div>
                <div aria-labelledby="tab-0-0-0" classes="sphinx-tabs-panel" ids="panel-0-0-0" name="0-0" role="tabpanel" tabindex="0">
                    <paragraph>在编辑器中选择导航区块2D节点时，编辑器顶部栏会显示烘焙选项和多边形绘制工具。</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_region_baking_01.webp'}" uri="tutorials/navigation/img/nav_region_baking_01.webp"></image>
                    <paragraph>为了使区块工作，需要添加一个 <reference internal="True" refuri="../../classes/class_navigationpolygon#class-navigationpolygon"><inline classes="std std-ref">NavigationPolygon</inline></reference> 资源。</paragraph>
                    <paragraph>解析和烘焙导航网格的属性是所用资源的一部分，可以在资源检查器中找到。</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_region_baking_02.webp'}" uri="tutorials/navigation/img/nav_region_baking_02.webp"></image>
                    <paragraph>The result of the source geometry parsing can be influenced with the following properties.</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>“parsed_geometry_type”用于筛选是否应从 :ref:<problematic ids="id2" refid="id1">`</problematic>SceneTree&lt;class_SceneTree&gt;`解析视觉对象或物理对象或两者。有关解析哪些对象以及如何解析的更多详细信息，请参阅下面关于解析源几何体的部分。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>当 <literal>parsed_geometry_type</literal> 包括物理碰撞时， <literal>collision_mask</literal> 过滤哪些物理碰撞对象被包括在内。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>source_geometry_mode</literal> 定义在哪个节点上开始解析，以及如何遍历 <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>source_geometry_group_name</literal> 在只应解析某个节点组时使用。取决于所选的 <literal>source_geometry_mode</literal> 。</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>With the source geometry added, the result of the baking can be controlled with the following properties.</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><literal>cell_size</literal> 设置栅格网格大小，并且应与导航地图大小相匹配。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>agent_radius</literal> 收缩烘焙的导航网格，以便为代理（碰撞）大小提供足够的边距。</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>NavigationRegion2D烘焙也可以在运行时与脚本一起使用。</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        </div>
                        <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var on_thread: bool = true
bake_navigation_polygon(on_thread)</literal_block>
                        </div>
                    </container>
                    <paragraph>要使用默认设置快速测试 2D 烘焙：</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>添加一个 <reference internal="True" refuri="../../classes/class_navigationregion2d#class-navigationregion2d"><inline classes="std std-ref">NavigationRegion2D</inline></reference>。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>为 NavigationRegion2D 添加一个 <reference internal="True" refuri="../../classes/class_navigationpolygon#class-navigationpolygon"><inline classes="std std-ref">NavigationPolygon</inline></reference> 资源。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>在 NavigationRegion2D 下面添加一个 <reference internal="True" refuri="../../classes/class_polygon2d#class-polygon2d"><inline classes="std std-ref">Polygon2D</inline></reference>。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>使用选中的 NavigationRegion2D 绘制工具绘制一个 NavigationPolygon 轮廓。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>使用选中的 Polygon2D 绘制工具在 NavigationPolygon 轮廓中绘制一个 Polygon2D 轮廓。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>点击编辑器的烘焙按钮，就会出现导航网格。</paragraph>
                        </list_item>
                    </bullet_list>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_region_baking_01.webp'}" uri="tutorials/navigation/img/nav_region_baking_01.webp"></image>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_mesh_mini_2d.webp'}" uri="tutorials/navigation/img/nav_mesh_mini_2d.webp"></image>
                </div>
                <div aria-labelledby="tab-0-0-1" classes="sphinx-tabs-panel" hidden="true" ids="panel-0-0-1" name="0-1" role="tabpanel" tabindex="0">
                    <paragraph>在编辑器中选择NavigationRegion3D节点后，烘焙选项将显示在编辑器的顶部栏中。</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_mesh_bake_toolbar.webp'}" uri="tutorials/navigation/img/nav_mesh_bake_toolbar.webp"></image>
                    <paragraph>In order for the region to work a <reference internal="True" refuri="../../classes/class_navigationmesh#class-navigationmesh"><inline classes="std std-ref">NavigationMesh</inline></reference> resource needs to be added.</paragraph>
                    <paragraph>解析和烘焙导航网格的属性是所用资源的一部分，可以在资源检查器中找到。</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_region3d_baking_01.webp'}" uri="tutorials/navigation/img/nav_region3d_baking_01.webp"></image>
                    <paragraph>The result of the source geometry parsing can be influenced with the following properties.</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>“parsed_geometry_type”用于筛选是否应从 :ref:<problematic ids="id2" refid="id1">`</problematic>SceneTree&lt;class_SceneTree&gt;`解析视觉对象或物理对象或两者。有关解析哪些对象以及如何解析的更多详细信息，请参阅下面关于解析源几何体的部分。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>当 <literal>parsed_geometry_type</literal> 包括物理碰撞时， <literal>collision_mask</literal> 过滤哪些物理碰撞对象被包括在内。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>source_geometry_mode</literal> 定义在哪个节点上开始解析，以及如何遍历 <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>source_geometry_group_name</literal> 在只应解析某个节点组时使用。取决于所选的 <literal>source_geometry_mode</literal> 。</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>With the source geometry added, the result of the baking can be controlled with the following properties.</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><literal>cell_size</literal> 和``cell_height`` 设置光栅栅格大小，并且应与导航地图大小相匹配。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>agent_radius</literal> 收缩烘焙的导航网格，以便为代理（碰撞）大小提供足够的边距。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>agent_height</literal> 从导航网格中排除代理太高而无法容纳的区域。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>agent_max_climb</literal> 和 <literal>agent_max_slope</literal> 可移除相邻体素之间高度差过大或其表面过陡的区域。</paragraph>
                        </list_item>
                    </bullet_list>
                    <warning>
                        <paragraph>太小的 <literal>cell_size</literal> 或 <literal>cell_height</literal> 可能会创建太多的体素，从而有可能冻结游戏甚至崩溃。</paragraph>
                    </warning>
                    <paragraph>NavigationRegion3D烘焙也可以在运行时与脚本一起使用。</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        </div>
                        <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var on_thread: bool = true
bake_navigation_mesh(on_thread)</literal_block>
                        </div>
                    </container>
                    <paragraph>要使用默认设置快速测试 3D 烘焙：</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>添加一个 <reference internal="True" refuri="../../classes/class_navigationregion3d#class-navigationregion3d"><inline classes="std std-ref">NavigationRegion3D</inline></reference>。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>为 NavigationRegion3D 添加一个 <reference internal="True" refuri="../../classes/class_navigationmesh#class-navigationmesh"><inline classes="std std-ref">NavigationMesh</inline></reference> 资源。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>在 NavigationRegion3D 下面添加一个 <reference internal="True" refuri="../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference>。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>为 MeshInstance3D 添加一个 <reference internal="True" refuri="../../classes/class_planemesh#class-planemesh"><inline classes="std std-ref">PlaneMesh</inline></reference>。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>点击编辑器的烘焙按钮，就会出现导航网格。</paragraph>
                        </list_item>
                    </bullet_list>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_mesh_bake_toolbar.webp'}" uri="tutorials/navigation/img/nav_mesh_bake_toolbar.webp"></image>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_mesh_mini_3d.webp'}" uri="tutorials/navigation/img/nav_mesh_mini_3d.webp"></image>
                </div>
            </container>
            <target refid="doc-navigation-using-navigationmeshes-baking-navigation-mesh-with-navigationserver"></target>
        </section>
        <section ids="baking-a-navigation-mesh-with-the-navigationserver doc-navigation-using-navigationmeshes-baking-navigation-mesh-with-navigationserver" names="baking\ a\ navigation\ mesh\ with\ the\ navigationserver 使用\ navigationserver\ 烘焙导航网格 doc_navigation_using_navigationmeshes_baking_navigation_mesh_with_navigationserver">
            <title>使用 NavigationServer 烘焙导航网格</title>
            <paragraph>The <reference internal="True" refuri="../../classes/class_navigationserver2d#class-navigationserver2d"><inline classes="std std-ref">NavigationServer2D</inline></reference> and <reference internal="True" refuri="../../classes/class_navigationserver3d#class-navigationserver3d"><inline classes="std std-ref">NavigationServer3D</inline></reference> have API functions to call each step of the navigation mesh baking process individually.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>parse_source_geometry_data()</literal> 可用于将源几何体解析为可重用和可序列化的资源。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>bake_from_source_geometry_data()</literal> 可用于根据已解析的数据烘焙导航网格，例如避免（冗余）解析的运行时性能问题。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>bake_from_source_geometry_data_async()</literal> 是相同的，但烘焙用线程延迟的导航网格，而不是阻塞主线程。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>与NavigationRegion相比，NavigationServer对导航网格烘焙过程提供了更精细的控制。反过来，它的使用更加复杂，但也提供了更高级的选项。</paragraph>
            <paragraph>NavigationServer相对于NavigationRegion的其他一些优点是：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>服务器可以在不烘焙的情况下解析源几何体，例如缓存以供以后使用。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>服务器允许选择根节点，以便手动启动源几何体解析。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>服务器可以接受程序生成的源几何图形数据并从中烘焙。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>服务器可以按顺序烘焙多个导航网格，同时（重新）使用相同的源几何体数据。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>若要使用NavigationServer烘焙导航网格，则需要源几何体。源几何体是导航网格烘焙过程中应考虑的几何体数据。二维和三维导航网格都是通过从源几何体烘焙来创建的。</paragraph>
            <paragraph>2D and 3D versions of the source geometry resources are available as
                <reference internal="True" refuri="../../classes/class_navigationmeshsourcegeometrydata2d#class-navigationmeshsourcegeometrydata2d"><inline classes="std std-ref">NavigationMeshSourceGeometryData2D</inline></reference> and
                <reference internal="True" refuri="../../classes/class_navigationmeshsourcegeometrydata3d#class-navigationmeshsourcegeometrydata3d"><inline classes="std std-ref">NavigationMeshSourceGeometryData3D</inline></reference>  respectively.</paragraph>
            <paragraph>源几何体可以是从视觉网格、物理碰撞或程序创建的数据阵列（如轮廓（2D）和三角面（3D））解析的几何体。为方便起见，通常直接从场景树中的节点设置解析源几何体。对于运行时导航网格（重新）烘焙，请注意几何体解析始终发生在主线程上。</paragraph>
            <note>
                <paragraph>SceneTree不是线程安全的。从SceneTree解析源几何体只能在主线程上完成。</paragraph>
            </note>
            <warning>
                <paragraph>需要从GPU接收来自视觉网格和多边形的数据，从而在此过程中停止RenderingServer。对于运行时（重新）烘焙，更喜欢使用物理形状作为解析的源几何体。</paragraph>
            </warning>
            <paragraph>源几何图形存储在资源中，因此创建的几何图形可以重复用于多次烘焙。例如，为来自同一源几何体的不同代理大小烘焙多个导航网格。这也允许将源几何体保存到磁盘，以便稍后加载，例如避免在运行时再次解析的开销。</paragraph>
            <paragraph>几何数据通常应保持非常简单。需要尽可能多的边缘，但尽可能少。尤其是在2D中，应避免重复和嵌套几何体，因为它会强制计算多边形孔，从而导致翻转多边形。嵌套几何体的示例是完全放置在另一个StaticBody2D形状的边界内的较小StaticBody2D形状。</paragraph>
        </section>
        <section ids="baking-navigation-mesh-chunks-for-large-worlds" names="baking\ navigation\ mesh\ chunks\ for\ large\ worlds">
            <title>Baking navigation mesh chunks for large worlds</title>
            <figure align="center" ids="id3">
                <image alt="Building navigation mesh chunks" candidates="{'*': 'tutorials/navigation/img/navmesh_chunk_build.gif'}" uri="tutorials/navigation/img/navmesh_chunk_build.gif"></image>
                <caption>Building and updating individual navigation mesh chunks at runtime.</caption>
            </figure>
            <paragraph>To avoid misaligned edges between different region chunks the navigation meshes have two important properties
                for the navigation mesh baking process. The baking bound and the border size.
                Together they can be used to ensure perfectly aligned edges between region chunks.</paragraph>
            <figure align="center" ids="id4">
                <image alt="Navigation mesh chunk with bake bound and border size" candidates="{'*': 'tutorials/navigation/img/navmesh_bound_bordersize.webp'}" uri="tutorials/navigation/img/navmesh_bound_bordersize.webp"></image>
                <caption>Navigation mesh chunk baked with bake bound or baked with additional border size.</caption>
            </figure>
            <paragraph>The baking bound, which is an axis-aligned <reference internal="True" refuri="../../classes/class_rect2#class-rect2"><inline classes="std std-ref">Rect2</inline></reference> for 2D and <reference internal="True" refuri="../../classes/class_aabb#class-aabb"><inline classes="std std-ref">AABB</inline></reference> for 3D,
                limits the used source geometry by discarding all the geometry that is outside of the bounds.</paragraph>
            <paragraph>The <reference internal="True" refuri="../../classes/class_navigationpolygon#class-navigationpolygon"><inline classes="std std-ref">NavigationPolygon</inline></reference> properties <literal>baking_rect</literal> and <literal>baking_rect_offset</literal>
                can be used to create and place the 2D baking bound.</paragraph>
            <paragraph>The <reference internal="True" refuri="../../classes/class_navigationmesh#class-navigationmesh"><inline classes="std std-ref">NavigationMesh</inline></reference> properties <literal>filter_baking_aabb</literal> and <literal>filter_baking_aabb_offset</literal>
                can be used to create and place the 3D baking bound.</paragraph>
            <paragraph>With only the baking bound set another problem still exists. The resulting navigation mesh will
                inevitably be affected by necessary offsets like the <literal>agent_radius</literal> which makes the edges not align properly.</paragraph>
            <figure align="center" ids="id5">
                <image alt="Navigation mesh chunks with gaps" candidates="{'*': 'tutorials/navigation/img/navmesh_chunk_gaps.webp'}" uri="tutorials/navigation/img/navmesh_chunk_gaps.webp"></image>
                <caption>Navigation mesh chunks with noticeable gaps due to baked agent radius offset.</caption>
            </figure>
            <paragraph>This is where the <literal>border_size</literal> property for navigation mesh comes in. The border size is an inward margin
                from the baking bound. The important characteristic of the border size is that it is unaffected by most
                offsets and postprocessing like the <literal>agent_radius</literal>.</paragraph>
            <paragraph>Instead of discarding source geometry, the border size discards parts of the final surface of the baked navigation mesh.
                If the baking bound is large enough the border size can remove the problematic surface
                parts so that only the intended chunk size is left.</paragraph>
            <figure align="center" ids="id6">
                <image alt="Navigation mesh chunks without gaps" candidates="{'*': 'tutorials/navigation/img/navmesh_chunks.webp'}" uri="tutorials/navigation/img/navmesh_chunks.webp"></image>
                <caption>Navigation mesh chunks with aligned edges and without gaps.</caption>
            </figure>
            <note>
                <paragraph>The baking bounds need to be large enough to include a reasonable amount of source geometry from all the neighboring chunks.</paragraph>
            </note>
        </section>
        <section ids="navigation-mesh-baking-common-problems" names="navigation\ mesh\ baking\ common\ problems">
            <title>Navigation mesh baking common problems</title>
            <paragraph>在创建或烘焙导航网格时，需要考虑一些常见的用户问题和重要的注意事项。</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term>Navigation mesh baking creates frame rate problems at runtime</term>
                            <definition>
                                <paragraph>默认情况下，导航网格烘焙是在后台线程上完成的，因此只要平台支持线程，实际烘焙就很少是任何性能问题的根源（假设运行时重新烘焙的几何体大小合理且复杂）。</paragraph>
                                <paragraph>运行时性能问题的常见来源是涉及节点和场景树的源几何体的解析步骤。SceneTree不是线程安全的，因此所有节点都需要在主线程上解析。一些具有大量数据的节点在运行时可能非常重且解析缓慢，例如，TileMap为每个使用的单元和TileMapLayer都有一个或多个多边形要解析。持有网格的节点需要从RenderingServer请求数据，从而在此过程中停止渲染。</paragraph>
                                <paragraph>为了提高性能，请使用更优化的形状，例如在详细的视觉网格上使用碰撞形状，并提前合并和简化尽可能多的几何体。如果没有任何帮助，请不要解析SceneTree并使用脚本添加源几何体过程。如果仅使用纯数据数组作为源几何体，则可以在后台线程上完成整个烘焙过程。</paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term>Navigation mesh 在 2D 创建 unintended holes。</term>
                            <definition>
                                <paragraph>The navigation mesh baking in 2D is done by doing polygon clipping operations based on outline paths.
                                    Polygons with "holes" are a necessary evil to create more complex 2D polygons but can become unpredictable for users with many complex shapes involved.</paragraph>
                                <paragraph>为避免多边形孔计算出现任何意外问题，请避免将任何轮廓嵌套在同一类型的其他轮廓内（可遍历/障碍物）。这包括来自节点的已解析形状。例如，将较小的StaticBody2D形状放置在较大的StaticBody2D形状内可能会导致所生成的多边形翻转。</paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
                <list_item>
                    <definition_list>
                        <definition_list_item>
                            <term>导航网格显示在三维几何体内部。</term>
                            <definition>
                                <paragraph>3D中的导航网格烘焙没有“内部”的概念。用于光栅化几何体的体素单元被占用或未被占用。删除其他几何图形中位于地面上的几何图形。如果无法做到这一点，请在内部添加较小的“虚拟”几何体，并尽可能少地添加三角形，这样单元就会被一些东西占据。</paragraph>
                            </definition>
                        </definition_list_item>
                    </definition_list>
                </list_item>
            </bullet_list>
        </section>
        <section ids="navigation-mesh-script-templates" names="navigation\ mesh\ script\ templates">
            <title>Navigation mesh script templates</title>
            <paragraph>以下脚本使用NavigationServer解析场景树中的源几何体，烘焙导航网格，并使用更新的导航网格更新导航区域。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-MkQgR0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-MkQgR0RTY3JpcHQ=" name="MkQgR0RTY3JpcHQ=" role="tab" tabindex="0">2D GDScript</button>
                    <button aria-controls="panel-3-M0QgR0RTY3JpcHQ=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-M0QgR0RTY3JpcHQ=" name="M0QgR0RTY3JpcHQ=" role="tab" tabindex="-1">3D GDScript</button>
                </div>
                <div aria-labelledby="tab-3-MkQgR0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-MkQgR0RTY3JpcHQ=" name="MkQgR0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

var navigation_mesh: NavigationPolygon
var source_geometry : NavigationMeshSourceGeometryData2D
var callback_parsing : Callable
var callback_baking : Callable
var region_rid: RID

func _ready() -&gt; void:
    navigation_mesh = NavigationPolygon.new()
    navigation_mesh.agent_radius = 10.0
    source_geometry = NavigationMeshSourceGeometryData2D.new()
    callback_parsing = on_parsing_done
    callback_baking = on_baking_done
    region_rid = NavigationServer2D.region_create()

    # Enable the region and set it to the default navigation map.
    NavigationServer2D.region_set_enabled(region_rid, true)
    NavigationServer2D.region_set_map(region_rid, get_world_2d().get_navigation_map())

    # Some mega-nodes like TileMap are often not ready on the first frame.
    # Also the parsing needs to happen on the main-thread.
    # So do a deferred call to avoid common parsing issues.
    parse_source_geometry.call_deferred()

func parse_source_geometry() -&gt; void:
    source_geometry.clear()
    var root_node: Node2D = self

    # Parse the obstruction outlines from all child nodes of the root node by default.
    NavigationServer2D.parse_source_geometry_data(
        navigation_mesh,
        source_geometry,
        root_node,
        callback_parsing
    )

func on_parsing_done() -&gt; void:
    # If we did not parse a TileMap with navigation mesh cells we may now only
    # have obstruction outlines so add at least one traversable outline
    # so the obstructions outlines have something to "cut" into.
    source_geometry.add_traversable_outline(PackedVector2Array([
        Vector2(0.0, 0.0),
        Vector2(500.0, 0.0),
        Vector2(500.0, 500.0),
        Vector2(0.0, 500.0)
    ]))

    # Bake the navigation mesh on a thread with the source geometry data.
    NavigationServer2D.bake_from_source_geometry_data_async(
        navigation_mesh,
        source_geometry,
        callback_baking
    )

func on_baking_done() -&gt; void:
    # Update the region with the updated navigation mesh.
    NavigationServer2D.region_set_navigation_polygon(region_rid, navigation_mesh)</literal_block>
                </div>
                <div aria-labelledby="tab-3-M0QgR0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-M0QgR0RTY3JpcHQ=" name="M0QgR0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node3D

var navigation_mesh: NavigationMesh
var source_geometry : NavigationMeshSourceGeometryData3D
var callback_parsing : Callable
var callback_baking : Callable
var region_rid: RID

func _ready() -&gt; void:
    navigation_mesh = NavigationMesh.new()
    navigation_mesh.agent_radius = 0.5
    source_geometry = NavigationMeshSourceGeometryData3D.new()
    callback_parsing = on_parsing_done
    callback_baking = on_baking_done
    region_rid = NavigationServer3D.region_create()

    # Enable the region and set it to the default navigation map.
    NavigationServer3D.region_set_enabled(region_rid, true)
    NavigationServer3D.region_set_map(region_rid, get_world_3d().get_navigation_map())

    # Some mega-nodes like GridMap are often not ready on the first frame.
    # Also the parsing needs to happen on the main-thread.
    # So do a deferred call to avoid common parsing issues.
    parse_source_geometry.call_deferred()

func parse_source_geometry() -&gt; void:
    source_geometry.clear()
    var root_node: Node3D = self

    # Parse the geometry from all mesh child nodes of the root node by default.
    NavigationServer3D.parse_source_geometry_data(
        navigation_mesh,
        source_geometry,
        root_node,
        callback_parsing
    )

func on_parsing_done() -&gt; void:
    # Bake the navigation mesh on a thread with the source geometry data.
    NavigationServer3D.bake_from_source_geometry_data_async(
        navigation_mesh,
        source_geometry,
        callback_baking
    )

func on_baking_done() -&gt; void:
    # Update the region with the updated navigation mesh.
    NavigationServer3D.region_set_navigation_mesh(region_rid, navigation_mesh)</literal_block>
                </div>
            </container>
            <paragraph>The following script uses the NavigationServer to update a navigation region with procedurally generated navigation mesh data.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-MkQgR0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-MkQgR0RTY3JpcHQ=" name="MkQgR0RTY3JpcHQ=" role="tab" tabindex="0">2D GDScript</button>
                    <button aria-controls="panel-4-M0QgR0RTY3JpcHQ=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-M0QgR0RTY3JpcHQ=" name="M0QgR0RTY3JpcHQ=" role="tab" tabindex="-1">3D GDScript</button>
                </div>
                <div aria-labelledby="tab-4-MkQgR0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-MkQgR0RTY3JpcHQ=" name="MkQgR0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

var navigation_mesh: NavigationPolygon
var region_rid: RID

func _ready() -&gt; void:
    navigation_mesh = NavigationPolygon.new()
    region_rid = NavigationServer2D.region_create()

    # Enable the region and set it to the default navigation map.
    NavigationServer2D.region_set_enabled(region_rid, true)
    NavigationServer2D.region_set_map(region_rid, get_world_2d().get_navigation_map())

    # Add vertices for a convex polygon.
    navigation_mesh.vertices = PackedVector2Array([
        Vector2(0.0, 0.0),
        Vector2(100.0, 0.0),
        Vector2(100.0, 100.0),
        Vector2(0.0, 100.0)
    ])

    # Add indices for the polygon.
    navigation_mesh.add_polygon(
        PackedInt32Array([0, 1, 2, 3])
    )

    NavigationServer2D.region_set_navigation_polygon(region_rid, navigation_mesh)</literal_block>
                </div>
                <div aria-labelledby="tab-4-M0QgR0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-M0QgR0RTY3JpcHQ=" name="M0QgR0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node3D

var navigation_mesh: NavigationMesh
var region_rid: RID

func _ready() -&gt; void:
    navigation_mesh = NavigationMesh.new()
    region_rid = NavigationServer3D.region_create()

    # Enable the region and set it to the default navigation map.
    NavigationServer3D.region_set_enabled(region_rid, true)
    NavigationServer3D.region_set_map(region_rid, get_world_3d().get_navigation_map())

    # Add vertices for a convex polygon.
    navigation_mesh.vertices = PackedVector3Array([
        Vector3(-1.0, 0.0, 1.0),
        Vector3(1.0, 0.0, 1.0),
        Vector3(1.0, 0.0, -1.0),
        Vector3(-1.0, 0.0, -1.0),
    ])

    # Add indices for the polygon.
    navigation_mesh.add_polygon(
        PackedInt32Array([0, 1, 2, 3])
    )

    NavigationServer3D.region_set_navigation_mesh(region_rid, navigation_mesh)</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
