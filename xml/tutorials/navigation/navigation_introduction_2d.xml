<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/navigation/navigation_introduction_2d.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-navigation-overview-2d"></target>
    <section ids="d-navigation-overview doc-navigation-overview-2d" names="2d\ navigation\ overview 2d\ 导航概述 doc_navigation_overview_2d">
        <title>2D 导航概述</title>
        <paragraph>Godot 提供了多种对象、类和服务器，可帮助 2D 和 3D 游戏实现基于栅格（Grid）或网格（Mesh）的导航和寻路。下文将对 Godot 中与 2D 场景导航相关的对象及其主要用途进行概述。</paragraph>
        <paragraph>Godot 为 2D 导航提供了如下对象和类：</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <definition_list>
                    <definition_list_item>
                        <term><reference internal="True" refuri="../../classes/class_astar2d#class-astar2d"><inline classes="std std-ref">Astar2D</inline></reference></term>
                        <definition>
                            <paragraph><literal>Astar2D</literal> 对象能够在由具有权重的<strong>点</strong>构成的图中查找最短路径。</paragraph>
                            <paragraph>AStar2D 类最适合的是基于单元格的 2D 游戏，角色不需要到达区域中的任意位置，只需要能够到达一些预先指定的独立位置。</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
            <list_item>
                <definition_list>
                    <definition_list_item>
                        <term><reference internal="True" refuri="../../classes/class_navigationserver2d#class-navigationserver2d"><inline classes="std std-ref">NavigationServer2D</inline></reference></term>
                        <definition>
                            <paragraph><literal>NavigationServer2D</literal> 提供了强大的服务器 API，能够在区域中查找两个位置之间的最短路径，区域由导航网格定义。</paragraph>
                            <paragraph>NavigationServer 最适合的是要求角色能够到达区域中任意位置的 2D 实时游戏，区域由导航网格定义。基于网格的导航能够轻松扩展到大型游戏世界，因为大型区域通常能够使用单一多边形定义，如果换成栅格则会需要定义许许多多的单元格。</paragraph>
                            <paragraph>NavigationServer 中存放了不同的导航地图，每一张地图都由若干区块组成，区块中存放的是导航网格数据。在地图上放置代理就能够进行避障计算。与服务器通信时，使用 RID 来引用内部的地图、区块和代理。</paragraph>
                            <definition_list>
                                <definition_list_item>
                                    <term>NavigationServer 中可用的 RID 类型如下。</term>
                                    <definition>
                                        <bullet_list bullet="-">
                                            <list_item>
                                                <definition_list>
                                                    <definition_list_item>
                                                        <term>导航地图 RID</term>
                                                        <definition>
                                                            <paragraph>引用指定的导航地图，地图中存放的是区块和代理。地图会尝试将区块中的导航网格根据距离进行合并。每一个物理帧，地图都会同步区块和代理。</paragraph>
                                                        </definition>
                                                    </definition_list_item>
                                                </definition_list>
                                            </list_item>
                                            <list_item>
                                                <definition_list>
                                                    <definition_list_item>
                                                        <term>导航区块 RID</term>
                                                        <definition>
                                                            <paragraph>引用指定的导航区块，区块中存放的是导航网格数据。使用导航层位掩码可以对区块进行启用/禁用，限制其使用。</paragraph>
                                                        </definition>
                                                    </definition_list_item>
                                                </definition_list>
                                            </list_item>
                                            <list_item>
                                                <definition_list>
                                                    <definition_list_item>
                                                        <term>导航链接 RID</term>
                                                        <definition>
                                                            <paragraph>引用指定的导航链接，能够将两个导航网格上的位置进行连接，无视距离。</paragraph>
                                                        </definition>
                                                    </definition_list_item>
                                                </definition_list>
                                            </list_item>
                                            <list_item>
                                                <definition_list>
                                                    <definition_list_item>
                                                        <term>导航代理 RID</term>
                                                        <definition>
                                                            <paragraph>引用指定的避障代理。避障使用半径值指定。</paragraph>
                                                        </definition>
                                                    </definition_list_item>
                                                </definition_list>
                                            </list_item>
                                            <list_item>
                                                <definition_list>
                                                    <definition_list_item>
                                                        <term>导航障碍物 RID</term>
                                                        <definition>
                                                            <paragraph>引用指定的避障障碍物，会对代理的避障速度产生影响和约束。</paragraph>
                                                        </definition>
                                                    </definition_list_item>
                                                </definition_list>
                                            </list_item>
                                        </bullet_list>
                                    </definition>
                                </definition_list_item>
                            </definition_list>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
        </bullet_list>
        <paragraph>下列场景树节点可以辅助对 NavigationServer2D API 的使用。</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <definition_list>
                    <definition_list_item>
                        <term><reference internal="True" refuri="../../classes/class_navigationregion2d#class-navigationregion2d"><inline classes="std std-ref">NavigationRegion2D</inline></reference> 节点</term>
                        <definition>
                            <paragraph>存放 NavigationPolygon 资源的节点，该资源定义的是 NavigationServer2D 中的导航网格。</paragraph>
                            <bullet_list bullet="-">
                                <list_item>
                                    <paragraph>区块可以启用/禁用。</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>通过 <literal>navigation_layers</literal> 掩码，可以对其在寻路中的使用做进一步的限制。</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>NavigationServer2D 会根据距离将不同区块中的导航网格合并成一个导航网格。</paragraph>
                                </list_item>
                            </bullet_list>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
            <list_item>
                <definition_list>
                    <definition_list_item>
                        <term><reference internal="True" refuri="../../classes/class_navigationlink2d#class-navigationlink2d"><inline classes="std std-ref">NavigationLink2D</inline></reference> 节点</term>
                        <definition>
                            <paragraph>将两个导航网格上的位置进行连接的节点，无视距离，可用于寻路。</paragraph>
                            <bullet_list bullet="-">
                                <list_item>
                                    <paragraph>链接可以启用/禁用。</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>链接可以设为单向或双向。</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>通过 <literal>navigation_layers</literal> 掩码，可以对其在寻路中的使用做进一步的限制。</paragraph>
                                </list_item>
                            </bullet_list>
                            <paragraph>链接会告诉寻路存在这样的连接、相关的消耗如何。实际的代理处理以及移动需要在自定义脚本中实现。</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
            <list_item>
                <definition_list>
                    <definition_list_item>
                        <term><reference internal="True" refuri="../../classes/class_navigationagent2d#class-navigationagent2d"><inline classes="std std-ref">NavigationAgent2D</inline></reference> 节点</term>
                        <definition>
                            <paragraph>可选的辅助节点，用于为继承自 Node2D 的父节点提供寻路和避障所需的常规 NavigationServer2D API 调用。请将这个节点放在继承自 Node2D 的父节点下。</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
            <list_item>
                <definition_list>
                    <definition_list_item>
                        <term><reference internal="True" refuri="../../classes/class_navigationobstacle2d#class-navigationobstacle2d"><inline classes="std std-ref">NavigationObstacle2D</inline></reference> 节点</term>
                        <definition>
                            <paragraph>A Node that can be used to affect and constrain the avoidance velocity of avoidance enabled agents.
                                This Node does NOT affect the pathfinding of agents. You need to change the navigation meshes for that instead.</paragraph>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
        </bullet_list>
        <paragraph>2D 导航网格由以下资源定义：</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <definition_list>
                    <definition_list_item>
                        <term><reference internal="True" refuri="../../classes/class_navigationpolygon#class-navigationpolygon"><inline classes="std std-ref">NavigationPolygon</inline></reference> 资源</term>
                        <definition>
                            <paragraph>A resource that holds 2D navigation mesh data.
                                It provides polygon drawing tools to allow defining navigation areas inside the Editor as well as at runtime.</paragraph>
                            <bullet_list bullet="-">
                                <list_item>
                                    <paragraph>NavigationRegion2D 节点使用该资源定义其导航区域。</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>NavigationServer2D 使用该资源更新各个区块的导航网格。</paragraph>
                                </list_item>
                                <list_item>
                                    <paragraph>TileSet 编辑器会定义图块的导航区域时在内部创建并使用该资源。</paragraph>
                                </list_item>
                            </bullet_list>
                        </definition>
                    </definition_list_item>
                </definition_list>
            </list_item>
        </bullet_list>
        <seealso>
            <paragraph>可以使用 <reference name="2D 导航演示项目" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/2d/navigation">2D 导航演示项目</reference>和<reference name="使用 AStarGrid2D 进行基于栅格的导航" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/2d/navigation_astar">使用 AStarGrid2D 进行基于栅格的导航</reference> 演示项目了解 2D 导航如何运作。</paragraph>
        </seealso>
        <section ids="setup-for-2d-scene" names="setup\ for\ 2d\ scene 2d\ 场景的设置">
            <title>2D 场景的设置</title>
            <paragraph>下列步骤演示的是最小可行的 2D 导航的基础设置，使用 NavigationServer2D 和 NavigationAgent2D 进行路径移动。</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>在场景中添加一个 NavigationRegion2D 节点。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>单击该区块节点，向该节点添加一个新的 NavigationPolygon 资源。</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_2d_min_setup_step1.png'}" uri="tutorials/navigation/img/nav_2d_min_setup_step1.png"></image>
                </list_item>
                <list_item>
                    <paragraph>Define the movable navigation area with the NavigationPolygon draw tool. Then click
                        the <title_reference>Bake NavigationPolygon`</title_reference> button on the toolbar.</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_2d_min_setup_step2.png'}" uri="tutorials/navigation/img/nav_2d_min_setup_step2.png"></image>
                    <note>
                        <paragraph>导航网格定义的是角色的中心点所能够站立和移动的区域。请在导航多边形的边缘和碰撞对象之间留下足够的边距，这样角色跟随路径移动时就不会因为碰撞而卡住。</paragraph>
                    </note>
                </list_item>
                <list_item>
                    <paragraph>在场景中添加一个 CharacterBody2D 节点，设置基础的碰撞形状，添加一个精灵或网格方便观察。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>在该角色节点下添加一个 NavigationAgent2D 节点。</paragraph>
                    <image candidates="{'*': 'tutorials/navigation/img/nav_2d_min_setup_step3.webp'}" uri="tutorials/navigation/img/nav_2d_min_setup_step3.webp"></image>
                </list_item>
                <list_item>
                    <paragraph>为 CharacterBody3D 节点添加下面的脚本。场景完全加载后，我们确保设置移动目标，NavigationServer 有时间进行同步。</paragraph>
                </list_item>
            </enumerated_list>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody2D

var movement_speed: float = 200.0
var movement_target_position: Vector2 = Vector2(60.0,180.0)

@onready var navigation_agent: NavigationAgent2D = $NavigationAgent2D

func _ready():
    # These values need to be adjusted for the actor's speed
    # and the navigation layout.
    navigation_agent.path_desired_distance = 4.0
    navigation_agent.target_desired_distance = 4.0

    # Make sure to not await during _ready.
    call_deferred("actor_setup")

func actor_setup():
    # Wait for the first physics frame so the NavigationServer can sync.
    await get_tree().physics_frame

    # Now that the navigation map is no longer empty, set the movement target.
    set_movement_target(movement_target_position)

func set_movement_target(movement_target: Vector2):
    navigation_agent.target_position = movement_target

func _physics_process(delta):
    if navigation_agent.is_navigation_finished():
        return

    var current_agent_position: Vector2 = global_position
    var next_path_position: Vector2 = navigation_agent.get_next_path_position()

    velocity = current_agent_position.direction_to(next_path_position) * movement_speed
    move_and_slide()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCharacterBody2D : CharacterBody2D
{
    private NavigationAgent2D _navigationAgent;

    private float _movementSpeed = 200.0f;
    private Vector2 _movementTargetPosition = new Vector2(70.0f, 226.0f);

    public Vector2 MovementTarget
    {
        get { return _navigationAgent.TargetPosition; }
        set { _navigationAgent.TargetPosition = value; }
    }

    public override void _Ready()
    {
        base._Ready();

        _navigationAgent = GetNode&lt;NavigationAgent2D&gt;("NavigationAgent2D");

        // These values need to be adjusted for the actor's speed
        // and the navigation layout.
        _navigationAgent.PathDesiredDistance = 4.0f;
        _navigationAgent.TargetDesiredDistance = 4.0f;

        // Make sure to not await during _Ready.
        Callable.From(ActorSetup).CallDeferred();
    }

    public override void _PhysicsProcess(double delta)
    {
        base._PhysicsProcess(delta);

        if (_navigationAgent.IsNavigationFinished())
        {
            return;
        }

        Vector2 currentAgentPosition = GlobalTransform.Origin;
        Vector2 nextPathPosition = _navigationAgent.GetNextPathPosition();

        Velocity = currentAgentPosition.DirectionTo(nextPathPosition) * _movementSpeed;
        MoveAndSlide();
    }

    private async void ActorSetup()
    {
        // Wait for the first physics frame so the NavigationServer can sync.
        await ToSignal(GetTree(), SceneTree.SignalName.PhysicsFrame);

        // Now that the navigation map is no longer empty, set the movement target.
        MovementTarget = _movementTargetPosition;
    }
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph>第一帧的时候，NavigationServer 上的地图还没有同步区块数据，请求路径时都会返回空。在脚本中等待一帧就可以让 NavigationServer 进行同步。</paragraph>
            </note>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
