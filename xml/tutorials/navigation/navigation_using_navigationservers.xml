<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/navigation/navigation_using_navigationservers.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-navigation-using-navigationservers"></target>
    <section ids="using-navigationserver doc-navigation-using-navigationservers" names="using\ navigationserver 使用\ navigationserver doc_navigation_using_navigationservers">
        <title>使用 NavigationServer</title>
        <paragraph>NavigationServer 即导航服务器。2D 和 3D 版本的 NavigationServer 分别为 <reference internal="True" refuri="../../classes/class_navigationserver2d#class-navigationserver2d"><inline classes="std std-ref">NavigationServer2D</inline></reference> 和 <reference internal="True" refuri="../../classes/class_navigationserver3d#class-navigationserver3d"><inline classes="std std-ref">NavigationServer3D</inline></reference>。</paragraph>
        <paragraph>2D 和 3D 使用的 NavigationServer 是一样的，NavigationServer3D 是主要服务器。NavigationServer2D 只是一个前端，会进行 2D 位置和 3D 位置的相互转换。因此，完全可以只用 NavigationServer3D 的 API 来实现 2D 导航（就是会有点繁琐）。</paragraph>
        <section ids="communicating-with-the-navigationserver" names="communicating\ with\ the\ navigationserver 与\ navigationserver\ 通信">
            <title>与 NavigationServer 通信</title>
            <paragraph>To work with the NavigationServer means to prepare parameters for a <strong>query</strong> that can be sent to the NavigationServer for updates or requesting data.</paragraph>
            <paragraph>To reference the internal NavigationServer objects like maps, regions and agents RIDs are used as identification numbers.
                Every navigation related node in the scene tree has a function that returns the RID for this node.</paragraph>
        </section>
        <section ids="threading-and-synchronization" names="threading\ and\ synchronization 线程与同步">
            <title>线程与同步</title>
            <paragraph>The NavigationServer does not update every change immediately but waits until
                the end of the <strong>physics frame</strong> to synchronize all the changes together.</paragraph>
            <paragraph>Waiting for synchronization is required to apply changes to all maps, regions and agents.
                Synchronization is done because some updates like a recalculation of the entire navigation map are very expensive and require updated data from all other objects.
                Also the NavigationServer uses a <strong>threadpool</strong> by default for some functionality like avoidance calculation between agents.</paragraph>
            <paragraph>Waiting is not required for most <literal>get()</literal> functions that only request data from the NavigationServer without making changes.
                Note that not all data will account for changes made in the same frame.
                E.g. if an avoidance agent changed the navigation map this frame the <literal>agent_get_map()</literal> function will still return the old map before the synchronization.
                The exception to this are nodes that store their values internally before sending the update to the NavigationServer.
                When a getter on a node is used for a value that was updated in the same frame it will return the already updated value stored on the node.</paragraph>
            <paragraph>The NavigationServer is <strong>thread-safe</strong> as it places all API calls that want to make changes in a queue to be executed in the synchronization phase.
                Synchronization for the NavigationServer happens in the middle of the physics frame after scene input from scripts and nodes are all done.</paragraph>
            <note>
                <paragraph>The important takeaway is that most NavigationServer changes take effect after the next physics frame and not immediately.
                    This includes all changes made by navigation related nodes in the scene tree or through scripts.</paragraph>
            </note>
            <note>
                <paragraph>All setters and delete functions require synchronization.</paragraph>
            </note>
        </section>
        <section ids="d-and-3d-navigationserver-differences" names="2d\ and\ 3d\ navigationserver\ differences 2d\ 和\ 3d\ navigationserver\ 的区别">
            <title>2D 和 3D NavigationServer 的区别</title>
            <paragraph>NavigationServer2D 和 NavigationServer3D 在各自维度中的功能是等价的，底层使用的相同的 NavigationServer。</paragraph>
            <paragraph>严格来说，NavigationServer2D在技术上是一个神话。NavigationServer2D是一个前端，用于帮助NavigationServer3D API将``Vector2(x, y)`` 转换为 <literal>Vector3(x, 0.0, z)``并返回。2D使用平面三维网格路径查找，NavigationServer2D便于转换。当指南只使用NavigationServer而不使用2D或3D后缀时，它通常通过将 ``Vector2(x, y)</literal> 与 <literal>Vector3(x, 0.0, z)</literal> 交换或反向来对两个服务器都有效。</paragraph>
            <paragraph>从技术上讲，可以使用工具在一个维度上为另一个维度创建导航网格，例如，当使用平面三维源几何体时，使用3D NavigationMesh烘焙二维导航网格，或者使用NavigationRegion2D和NavigationPolygons的多边形轮廓绘制工具创建三维平面导航网格。</paragraph>
            <paragraph>使用NavigationServer2D API创建的任何RID也适用于NavigationServer3D API，2D和3D回避代理都可以存在于同一地图上。</paragraph>
            <note>
                <paragraph>在二维和三维中创建的区域将在放置在同一地图上时合并其导航网格，并应用合并条件。NavigationServer不会区分NavigationRegion2D和NavigationRegion3D节点，因为这两个节点都是服务器上的区域。默认情况下，这些节点注册在不同的导航地图上，因此只有在手动更改地图（例如使用脚本）时才能进行合并。</paragraph>
                <paragraph>启用回避的Actor在放置在同一张地图上时将同时回避2D和3D回避代理。</paragraph>
            </note>
            <warning>
                <paragraph>自定义的 Godot 构建如果禁用了 3D，则无法使用 NavigationServer2D。</paragraph>
            </warning>
        </section>
        <section ids="waiting-for-synchronization" names="waiting\ for\ synchronization 等待同步">
            <title>等待同步</title>
            <paragraph>在游戏开始时，新场景或程序导览发生变化，对导览服务器的任何路径查询都将传回空或错误。</paragraph>
            <paragraph>此时导航地图仍然为空或未更新。场景树中的所有节点都需要首先将其导航相关数据上传到NavigationServer。每个添加或更改的地图、区域或代理都需要在NavigationServer中注册。之后，NavigationServer需要**物理帧**进行同步，以更新地图、区域和代理。</paragraph>
            <paragraph>一种解决方法是延迟调用自定义设置函数（这样所有节点都准备好了）。设置功能进行所有导航更改，例如添加程序性内容。之后，函数在继续路径查询之前等待下一个物理帧。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node3D

func _ready():
    # Use call deferred to make sure the entire scene tree nodes are setup
    # else await on 'physics_frame' in a _ready() might get stuck.
    call_deferred("custom_setup")

func custom_setup():

    # Create a new navigation map.
    var map: RID = NavigationServer3D.map_create()
    NavigationServer3D.map_set_up(map, Vector3.UP)
    NavigationServer3D.map_set_active(map, true)

    # Create a new navigation region and add it to the map.
    var region: RID = NavigationServer3D.region_create()
    NavigationServer3D.region_set_transform(region, Transform3D())
    NavigationServer3D.region_set_map(region, map)

    # Create a procedural navigation mesh for the region.
    var new_navigation_mesh: NavigationMesh = NavigationMesh.new()
    var vertices: PackedVector3Array = PackedVector3Array([
        Vector3(0, 0, 0),
        Vector3(9.0, 0, 0),
        Vector3(0, 0, 9.0)
    ])
    new_navigation_mesh.set_vertices(vertices)
    var polygon: PackedInt32Array = PackedInt32Array([0, 1, 2])
    new_navigation_mesh.add_polygon(polygon)
    NavigationServer3D.region_set_navigation_mesh(region, new_navigation_mesh)

    # Wait for NavigationServer sync to adapt to made changes.
    await get_tree().physics_frame

    # Query the path from the navigation server.
    var start_position: Vector3 = Vector3(0.1, 0.0, 0.1)
    var target_position: Vector3 = Vector3(1.0, 0.0, 1.0)
    var optimize_path: bool = true

    var path: PackedVector3Array = NavigationServer3D.map_get_path(
        map,
        start_position,
        target_position,
        optimize_path
    )

    print("Found a path!")
    print(path)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode3D : Node3D
{
    public override void _Ready()
    {
        // Use call deferred to make sure the entire scene tree nodes are setup
        // else await on 'physics_frame' in a _Ready() might get stuck.
        CallDeferred(MethodName.CustomSetup);
    }

    private async void CustomSetup()
    {
        // Create a new navigation map.
        Rid map = NavigationServer3D.MapCreate();
        NavigationServer3D.MapSetUp(map, Vector3.Up);
        NavigationServer3D.MapSetActive(map, true);

        // Create a new navigation region and add it to the map.
        Rid region = NavigationServer3D.RegionCreate();
        NavigationServer3D.RegionSetTransform(region, Transform3D.Identity);
        NavigationServer3D.RegionSetMap(region, map);

        // Create a procedural navigation mesh for the region.
        var newNavigationMesh = new NavigationMesh()
        {
            Vertices = new[]
            {
                new Vector3(0.0f, 0.0f, 0.0f),
                new Vector3(9.0f, 0.0f, 0.0f),
                new Vector3(0.0f, 0.0f, 9.0f),
            },
        };
        int[] polygon = new[] { 0, 1, 2 };
        newNavigationMesh.AddPolygon(polygon);
        NavigationServer3D.RegionSetNavigationMesh(region, newNavigationMesh);

        // Wait for NavigationServer sync to adapt to made changes.
        await ToSignal(GetTree(), SceneTree.SignalName.PhysicsFrame);

        // Query the path from the navigation server.
        var startPosition = new Vector3(0.1f, 0.0f, 0.1f);
        var targetPosition = new Vector3(1.0f, 0.0f, 1.0f);

        Vector3[] path = NavigationServer3D.MapGetPath(map, startPosition, targetPosition, optimize: true);

        GD.Print("Found a path!");
        GD.Print((Variant)path);
    }
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="server-avoidance-callbacks" names="server\ avoidance\ callbacks 服务器避障回调">
            <title>服务器避障回调</title>
            <paragraph>如果 RVO 避障代理注册了避障回调，NavigationServer 会在 PhysicsServer 同步前发送对应的 <literal>velocity_computed</literal> 信号。</paragraph>
            <paragraph>更多 NavigationAgent 相关的信息见 <reference internal="True" refuri="navigation_using_navigationagents#doc-navigation-using-navigationagents"><inline classes="std std-ref">使用 NavigationAgent</inline></reference>。</paragraph>
            <paragraph>使用避障的 NavigationAgent 的简化执行顺序如下：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>物理帧开始。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>_physics_process(delta)</literal>。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>velocity</literal> property is set on NavigationAgent Node.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>代理向 NavigationServer 发送速度和位置。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>NavigationServer 等待同步。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>NavigationServer 同步并为所有注册的避障代理计算避障速度。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>NavigationServer 通过信号为每个注册的避障代理发送安全速度向量。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>代理收到信号并移动父节点，例如通过 <literal>move_and_slide</literal> 或 <literal>linear_velocity</literal> 移动。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>PhysicsServer 同步。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>物理帧结束。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>因此，在回调函数中使用安全速度来移动角色物理体无论从线程还是物理的角度看都是安全的，因为相关的操作都在同一个物理帧中进行，之后 PhysicsServer 才会提交更改并进行计算。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
