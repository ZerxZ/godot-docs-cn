<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/global_illumination/using_lightmap_gi.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-lightmap-gi"></target>
    <section ids="using-lightmap-global-illumination doc-using-lightmap-gi" names="using\ lightmap\ global\ illumination doc_using_lightmap_gi">
        <title>Using Lightmap global illumination</title>
        <paragraph>Baked lightmaps are a workflow for adding indirect (or fully baked)
            lighting to a scene. Unlike the <reference internal="True" refuri="using_voxel_gi#doc-using-voxel-gi"><inline classes="std std-ref">VoxelGI</inline></reference> and
            <reference internal="True" refuri="using_sdfgi#doc-using-sdfgi"><inline classes="std std-ref">SDFGI</inline></reference> approaches, baked lightmaps work fine on low-end PCs
            and mobile devices, as they consume almost no resources at runtime. Also unlike
            VoxelGI and SDFGI, baked lightmaps can optionally be used to store direct
            lighting, which provides even further performance gains.</paragraph>
        <paragraph>Unlike VoxelGI and SDFGI, baked lightmaps are completely static. Once baked, they
            can't be modified at all. They also don't provide the scene with reflections, so
            using <reference internal="True" refuri="reflection_probes#doc-reflection-probes"><inline classes="std std-ref">Reflection probes</inline></reference> together with it on interiors (or using a Sky
            on exteriors) is a requirement to get good quality.</paragraph>
        <paragraph>As they are baked, they have fewer problems than VoxelGI and SDFGI regarding
            light bleeding, and indirect light will often look better. The downside is that
            baking lightmaps takes longer compared to baking VoxelGI. While baking VoxelGI
            can be done in a matter of seconds, baking lightmaps can take several minutes if
            not more. This can slow down iteration speed significantly, so it is recommended
            to bake lightmaps only when you actually need to see changes in lighting.
            Lightmaps are baked on the GPU, making light baking faster if you have a
            mid-range or high-end dedicated GPU.</paragraph>
        <paragraph>Baking lightmaps will also reserve baked materials' UV2 slot, which means you can
            no longer use it for other purposes in materials (either in the built-in
            <reference internal="True" refuri="../standard_material_3d#doc-standard-material-3d"><inline classes="std std-ref">Standard Material 3D and ORM Material 3D</inline></reference> or in custom shaders).</paragraph>
        <paragraph>Despite their lack of flexibility, baked lightmaps typically offer both the best
            quality <emphasis>and</emphasis> performance at the same time in (mostly) static scenes. This makes
            lightmaps still popular in game development, despite lightmaps being the
            oldest technique for global illumination in video games.</paragraph>
        <seealso>
            <paragraph>Not sure if LightmapGI is suited to your needs?
                See <reference internal="True" refuri="introduction_to_global_illumination#doc-introduction-to-global-illumination-comparison"><inline classes="std std-ref">Which global illumination technique should I use?</inline></reference>
                for a comparison of GI techniques available in Godot 4.</paragraph>
        </seealso>
        <section ids="visual-comparison" names="visual\ comparison">
            <title>Visual comparison</title>
            <figure ids="id1">
                <image alt="LightmapGI disabled." candidates="{'*': 'tutorials/3d/global_illumination/img/gi_none.webp'}" original_uri="img/gi_none.webp" uri="tutorials/3d/global_illumination/img/gi_none.webp"></image>
                <caption>LightmapGI disabled.</caption>
            </figure>
            <figure ids="id2">
                <image alt="LightmapGI enabled (with indirect light baked only)." candidates="{'*': 'tutorials/3d/global_illumination/img/gi_lightmap_gi_indirect_only.webp'}" original_uri="img/gi_lightmap_gi_indirect_only.webp" uri="tutorials/3d/global_illumination/img/gi_lightmap_gi_indirect_only.webp"></image>
                <caption>LightmapGI enabled (with indirect light baked only). Direct light is still
                    real-time, allowing for subtle changes during gameplay.</caption>
            </figure>
            <figure ids="id3">
                <image alt="LightmapGI enabled (with direct and indirect light baked)." candidates="{'*': 'tutorials/3d/global_illumination/img/gi_lightmap_gi_direct_and_indirect.webp'}" original_uri="img/gi_lightmap_gi_direct_and_indirect.webp" uri="tutorials/3d/global_illumination/img/gi_lightmap_gi_direct_and_indirect.webp"></image>
                <caption>LightmapGI enabled (with direct and indirect light baked). Best performance,
                    but lower quality visuals. Notice the blurrier sun shadow in the top-right
                    corner.</caption>
            </figure>
            <paragraph>Here are some comparisons of how LightmapGI vs. VoxelGI look. Notice that
                lightmaps are more accurate, but also suffer from the fact
                that lighting is on an unwrapped texture, so transitions and resolution may not
                be that good. VoxelGI looks less accurate (as it's an approximation), but
                smoother overall.</paragraph>
            <image candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_comparison.png'}" original_uri="img/lightmap_gi_comparison.png" uri="tutorials/3d/global_illumination/img/lightmap_gi_comparison.png"></image>
            <paragraph>SDFGI is also less accurate compared to LightmapGI. However, SDFGI can support
                large open worlds without any need for baking.</paragraph>
        </section>
        <section ids="setting-up" names="setting\ up">
            <title>Setting up</title>
            <warning>
                <paragraph>Baking lightmaps in the web editors is not supported due to
                    graphics API limitations. On the web platform, only <emphasis>rendering</emphasis> lightmaps
                    that were baked on a different platform is supported.</paragraph>
            </warning>
            <note>
                <paragraph>The LightmapGI node only bakes nodes that are on the same level as the
                    LightmapGI node (siblings), or nodes that are children of the
                    LightmapGI node. This allows you to use several LightmapGI nodes to bake
                    different parts of the scene, independently from each other.</paragraph>
            </note>
            <paragraph>First of all, before the lightmapper can do anything, the objects to be baked need
                a UV2 layer and a texture size. A UV2 layer is a set of secondary texture coordinates
                that ensures any face in the object has its own place in the UV map. Faces must
                not share pixels in the texture.</paragraph>
            <paragraph>There are a few ways to ensure your object has a unique UV2 layer and texture size:</paragraph>
            <section ids="unwrap-on-scene-import-recommended" names="unwrap\ on\ scene\ import\ (recommended)">
                <title>Unwrap on scene import (recommended)</title>
                <paragraph>In most scenarios, this is the best approach to use. The only downside is that,
                    on large models, unwrapping can take a while on import. Nonetheless, Godot will
                    cache the UV2 across reimports, so it will only be regenerated when needed.</paragraph>
                <paragraph>Select the imported scene in the filesystem dock, then go to the <strong>Import</strong> dock.
                    There, the following option can be modified:</paragraph>
                <image candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_import.webp'}" original_uri="img/lightmap_gi_import.webp" uri="tutorials/3d/global_illumination/img/lightmap_gi_import.webp"></image>
                <paragraph>The <strong>Meshes &gt; Light Baking</strong> option must be set to <strong>Static Lightmaps (VoxelGI/SDFGI/LightmapGI)</strong>:</paragraph>
                <image candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_mesh_import_meshes.webp'}" original_uri="img/lightmap_gi_mesh_import_meshes.webp" uri="tutorials/3d/global_illumination/img/lightmap_gi_mesh_import_meshes.webp"></image>
                <paragraph>When unwrapping on import, you can adjust the texture size using the <strong>Meshes &gt; Lightmap
                        Texel Size</strong> option. <emphasis>Lower</emphasis> values will result in more detailed lightmaps,
                    possibly resulting in higher visual quality at the cost of longer bake times and
                    larger lightmap file sizes. The default value of <literal>0.2</literal> is suited for
                    small/medium-sized scenes, but you may want to increase it to <literal>0.5</literal> or even
                    more for larger scenes. This is especially the case if you're baking indirect
                    lighting only, as indirect light is low-frequency data (which means it doesn't
                    need high-resolution textures to be accurately represented).</paragraph>
                <paragraph>The effect of setting this option is that all meshes within the scene will have
                    their UV2 maps properly generated.</paragraph>
                <warning>
                    <paragraph>When reusing a mesh within a scene, keep in mind that UVs will be generated
                        for the first instance found. If the mesh is re-used with different scales
                        (and the scales are wildly different, more than half or twice), this will
                        result in inefficient lightmaps. To avoid this, adjust the <strong>Lightmap
                            Scale</strong> property in the GeometryInstance3D section of a MeshInstance3D node.
                        This lets you <emphasis>increase</emphasis> the level of lightmap detail for specific
                        MeshInstance3D nodes (but not decrease it).</paragraph>
                    <paragraph>Also, the <literal>*.unwrap_cache</literal> files should <emphasis>not</emphasis> be ignored in version control
                        as these files guarantee that UV2 reimports are consistent across platforms
                        and engine versions.</paragraph>
                </warning>
            </section>
            <section ids="unwrap-from-within-godot" names="unwrap\ from\ within\ godot">
                <title>Unwrap from within Godot</title>
                <warning>
                    <paragraph>If this Mesh menu operation is used on an imported 3D scene, the generated
                        UV2 will be lost when the scene is reloaded.</paragraph>
                </warning>
                <paragraph>Godot has an option to unwrap meshes and visualize the UV channels. After
                    selecting a MeshInstance3D node, it can be found in the <strong>Mesh</strong> menu at the top
                    of the 3D editor viewport:</paragraph>
                <image candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_mesh_menu.webp'}" original_uri="img/lightmap_gi_mesh_menu.webp" uri="tutorials/3d/global_illumination/img/lightmap_gi_mesh_menu.webp"></image>
                <paragraph>This will generate a second set of UV2 coordinates which can be used for baking.
                    It will also set the texture size automatically.</paragraph>
            </section>
            <section ids="unwrap-from-your-3d-modeling-software" names="unwrap\ from\ your\ 3d\ modeling\ software">
                <title>Unwrap from your 3D modeling software</title>
                <paragraph>The last option is to do it from your favorite 3D app. This approach is
                    generally <strong>not recommended</strong>, but it's explained so that you know it exists.
                    The main advantage is that, on complex objects that you may want to re-import a
                    lot, the texture generation process can be quite costly within Godot, so having
                    it unwrapped before import can be faster.</paragraph>
                <paragraph>Simply do an unwrap on the second UV2 layer.</paragraph>
                <image candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_blender.webp'}" original_uri="img/lightmap_gi_blender.webp" uri="tutorials/3d/global_illumination/img/lightmap_gi_blender.webp"></image>
                <paragraph>Then import the 3D scene normally. Remember you will need to set the texture
                    size on the mesh after import.</paragraph>
                <image candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_lmsize.webp'}" original_uri="img/lightmap_gi_lmsize.webp" uri="tutorials/3d/global_illumination/img/lightmap_gi_lmsize.webp"></image>
                <paragraph>If you use external meshes on import, the size will be kept. Be wary that most
                    unwrappers in 3D modeling software are not quality-oriented, as they are meant
                    to work quickly. You will mostly need to use seams or other techniques to create
                    better unwrapping.</paragraph>
            </section>
            <section ids="generating-uv2-for-primitive-meshes" names="generating\ uv2\ for\ primitive\ meshes">
                <title>Generating UV2 for primitive meshes</title>
                <note>
                    <paragraph>This option is only available for primitive meshes such as <reference internal="True" refuri="../../../classes/class_boxmesh#class-boxmesh"><inline classes="std std-ref">BoxMesh</inline></reference>,
                        <reference internal="True" refuri="../../../classes/class_cylindermesh#class-cylindermesh"><inline classes="std std-ref">CylinderMesh</inline></reference>, <reference internal="True" refuri="../../../classes/class_planemesh#class-planemesh"><inline classes="std std-ref">PlaneMesh</inline></reference>, etc.</paragraph>
                </note>
                <paragraph>Enabling UV2 on primitive meshes allows you to make them receive and contribute
                    to baked lighting. This can be used in certain lighting setups. For instance,
                    you could hide a torus that has an emissive material after baking lightmaps to
                    create an area light that follows the shape of a torus.</paragraph>
                <paragraph>By default, primitive meshes do not have UV2 generated to save resources (as
                    these meshes may be created during gameplay). You can edit a primitive mesh in
                    the inspector and enable <strong>Add UV2</strong> to make the engine procedurally generate
                    UV2 for a primitive mesh. The default <strong>UV2 Padding</strong> value is tuned to avoid
                    most lightmap bleeding, without wasting too much space on the edges. If you
                    notice lightmap bleeding on a specific primitive mesh only, you may have to
                    increase <strong>UV2 Padding</strong>.</paragraph>
                <paragraph><strong>Lightmap Size Hint</strong> represents the size taken by a single mesh on the
                    lightmap texture, which varies depending on the mesh's size properties and the
                    <strong>UV2 Padding</strong> value. <strong>Lightmap Size Hint</strong> should not be manually changed, as
                    any modifications will be lost when the scene is reloaded.</paragraph>
            </section>
            <section ids="generating-uv2-for-csg-nodes" names="generating\ uv2\ for\ csg\ nodes">
                <title>Generating UV2 for CSG nodes</title>
                <paragraph>Since Godot 4.4, you can
                    <reference internal="True" refuri="../csg_tools#doc-csg-tools-converting-to-mesh-instance-3d"><inline classes="std std-ref">convert a CSG node and its children to a MeshInstance3D</inline></reference>.
                    This can be used to bake lightmaps on a CSG node by following these steps:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Select the root CSG node and choose <strong>CSG &gt; Bake Mesh Instance</strong> at the top of the 3D editor viewport.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Hide the root CSG node that was just baked (it is not hidden automatically).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Select the newly created MeshInstance3D node and choose <strong>Mesh &gt; Unwrap UV2 for Lightmap/AO</strong>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Bake lightmaps.</paragraph>
                    </list_item>
                </bullet_list>
                <tip>
                    <paragraph>Remember to keep the original CSG node in the scene tree, so that you can
                        perform changes to the geometry later if needed. To make changes to the
                        geometry, remove the MeshInstance3D node and make the root CSG node visible
                        again.</paragraph>
                </tip>
            </section>
            <section ids="checking-uv2" names="checking\ uv2">
                <title>Checking UV2</title>
                <paragraph>In the <strong>Mesh</strong> menu mentioned before, the UV2 texture coordinates can be visualized.
                    If something is failing, double-check that the meshes have these UV2 coordinates:</paragraph>
                <image candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_uvchannel.webp'}" original_uri="img/lightmap_gi_uvchannel.webp" uri="tutorials/3d/global_illumination/img/lightmap_gi_uvchannel.webp"></image>
            </section>
        </section>
        <section ids="setting-up-the-scene" names="setting\ up\ the\ scene">
            <title>Setting up the scene</title>
            <paragraph>Before anything is done, a <strong>LightmapGI</strong> node needs to be added to a scene.
                This will enable light baking on all nodes (and sub-nodes) in that scene, even
                on instanced scenes.</paragraph>
            <image candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_scene.webp'}" original_uri="img/lightmap_gi_scene.webp" uri="tutorials/3d/global_illumination/img/lightmap_gi_scene.webp"></image>
            <paragraph>A sub-scene can be instanced several times, as this is supported by the baker.
                Each instance will be assigned a lightmap of its own. To avoid issues with
                inconsistent lightmap texel scaling, make sure to respect the rule about mesh
                scaling mentioned before.</paragraph>
            <section ids="setting-up-meshes" names="setting\ up\ meshes">
                <title>Setting up meshes</title>
                <paragraph>For a <strong>MeshInstance3D</strong> node to take part in the baking process, it needs to have
                    its bake mode set to <strong>Static</strong>. Meshes that have their bake mode set to <strong>Disabled</strong>
                    or <strong>Dynamic</strong> will be ignored by the lightmapper.</paragraph>
                <image candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_use.webp'}" original_uri="img/lightmap_gi_use.webp" uri="tutorials/3d/global_illumination/img/lightmap_gi_use.webp"></image>
                <paragraph>When auto-generating lightmaps on scene import, this is enabled automatically.</paragraph>
            </section>
            <section ids="setting-up-lights" names="setting\ up\ lights">
                <title>Setting up lights</title>
                <paragraph>Lights are baked with indirect light only by default. This means that shadowmapping
                    and lighting are still dynamic and affect moving objects, but light bounces from
                    that light will be baked.</paragraph>
                <paragraph>Lights can be disabled (no bake) or be fully baked (direct and indirect). This
                    can be controlled from the <strong>Bake Mode</strong> menu in lights:</paragraph>
                <image candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_bake_mode.webp'}" original_uri="img/lightmap_gi_bake_mode.webp" uri="tutorials/3d/global_illumination/img/lightmap_gi_bake_mode.webp"></image>
                <paragraph>The modes are:</paragraph>
            </section>
            <section ids="disabled" names="disabled">
                <title>Disabled</title>
                <paragraph>The light is ignored when baking lightmaps. This is the mode to use for dynamic
                    lighting effects such as explosions and weapon effects.</paragraph>
                <warning>
                    <paragraph>Hiding a light has no effect on the resulting lightmap bake. This means
                        you must use the Disabled bake mode instead of hiding the Light node by
                        disabling its <strong>Visible</strong> property.</paragraph>
                </warning>
            </section>
            <section ids="dynamic" names="dynamic">
                <title>Dynamic</title>
                <paragraph>This is the default mode, and is a compromise between performance and real-time
                    friendliness. Only indirect lighting will be baked. Direct light and shadows are
                    still real-time, as they would be without LightmapGI.</paragraph>
                <paragraph>This mode allows performing <emphasis>subtle</emphasis> changes to a light's color, energy and
                    position while still looking fairly correct. For example, you can use this
                    to create flickering static torches that have their indirect light baked.</paragraph>
                <paragraph>Depending on the value of <strong>Shadowmask Mode</strong>, it is possible to still get
                    distant baked shadows for DirectionalLight3D. This allows shadows up close to be
                    real-time and show dynamic objects, while allowing static objects in the
                    distance to still cast shadows.</paragraph>
            </section>
            <section ids="static" names="static">
                <title>Static</title>
                <paragraph>Both indirect and direct lighting will be baked. Since static surfaces can skip
                    lighting and shadow computations entirely, this mode provides the best
                    performance along with smooth shadows that never fade based on distance. The
                    real-time light will not affect baked surfaces anymore, but it will still affect
                    dynamic objects. When using the <strong>All</strong> bake mode on a light, dynamic objects
                    will not cast real-time shadows onto baked surfaces, so you need to use a
                    different approach such as blob shadows instead. Blob shadows can be implemented
                    with a Decal node.</paragraph>
                <paragraph>The light will not be adjustable at all during gameplay. Moving the light or
                    changing its color (or energy) will not have any effect on static surfaces.</paragraph>
                <paragraph>Since bake modes can be adjusted on a per-light basis, it is possible to create
                    hybrid baked light setups. One popular option is to use a real-time
                    DirectionalLight with its bake mode set to <strong>Dynamic</strong>, and use the <strong>Static</strong>
                    bake mode for OmniLights and SpotLights. This provides good performance while
                    still allowing dynamic objects to cast real-time shadows in outdoor areas.</paragraph>
                <paragraph>Fully baked lights can also make use of light nodes' <strong>Size</strong> (omni/spot) or
                    <strong>Angular Distance</strong> (directional) properties. This allows for shadows with
                    realistic penumbra that increases in size as the distance between the caster and
                    the shadow increases. This also has a lower performance cost compared to
                    real-time PCSS shadows, as only dynamic objects have real-time shadows rendered
                    on them.</paragraph>
                <image candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_omnilight_size.png'}" original_uri="img/lightmap_gi_omnilight_size.png" uri="tutorials/3d/global_illumination/img/lightmap_gi_omnilight_size.png"></image>
            </section>
        </section>
        <section ids="baking" names="baking">
            <title>Baking</title>
            <paragraph>To begin the bake process, click the <strong>Bake Lightmaps</strong> button at the top of the
                3D editor viewport when selecting the LightmapGI node:</paragraph>
            <image candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_bake.webp'}" original_uri="img/lightmap_gi_bake.webp" uri="tutorials/3d/global_illumination/img/lightmap_gi_bake.webp"></image>
            <paragraph>This can take from seconds to minutes (or hours) depending on scene size, bake
                method and quality selected.</paragraph>
            <warning>
                <paragraph>Baking lightmaps is a process that can require a lot of video memory,
                    especially if the resulting texture is large. Due to internal limitations,
                    the engine may also crash if the generated texture size is too large (even
                    on systems with a lot of video memory).</paragraph>
                <paragraph>To avoid crashes, make sure the lightmap texel size in the Import dock is
                    set to a high enough value.</paragraph>
            </warning>
            <section ids="tweaks" names="tweaks">
                <title>Tweaks</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Quality:</strong> Four bake quality modes are provided: Low, Medium, High, and
                            Ultra. Higher quality takes more time, but result in a better-looking lightmap
                            with less noise. The difference is especially noticeable with emissive
                            materials or areas that get little to no direct lighting. Each bake quality
                            mode can be further adjusted in the Project Settings.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Supersampling:</strong> This creates the lightmap at a higher resolution and then
                            downsamples it. This reduces noise and light leaking, and produces better
                            shadows with small scale details. However, using it will increase bake times and
                            memory usage during lightmap baking. The <strong>Supersampling Factor</strong> changes the size
                            the lightmap is rendered at before downsampling.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Bounces:</strong> The number of bounces to use for indirect lighting. The default
                            value (<literal>3</literal>) is a good compromise between bake times and quality. Higher
                            values will make light bounce around more times before it stops, which makes
                            indirect lighting look smoother (but also possibly brighter depending on
                            materials and geometry).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Bounce Indirect Energy:</strong> The global multiplier to use when baking lights'
                            indirect energy. This multiplies each light's own <strong>Indirect Energy</strong> value.
                            Values different from <literal>1.0</literal> are not physically accurate, but can be used for
                            artistic effect.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Directional:</strong> If enabled, stores directional information for lightmaps.
                            This improves normal mapped materials' appearance for baked surfaces,
                            especially with fully baked lights (since they also have direct light baked).
                            The downside is that directional lightmaps are slightly more expensive to render.
                            They also require more time to bake and result in larger file sizes.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Shadowmask Mode:</strong> If set to a mode other than <strong>None</strong>, the first DirectionalLight3D
                            in the scene with the <strong>Dynamic</strong> global illumination mode will have its static shadows
                            baked to a separate texture called a <emphasis>shadowmask</emphasis>. This can be used to allow distant
                            static objects to cast shadows onto other static objects regardless of the distance
                            from the camera. See the <reference internal="True" refid="doc-using-lightmap-gi-shadowmask"><inline classes="std std-ref">section on shadowmasking</inline></reference>
                            for further details.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Interior:</strong> If enabled, environment lighting will not be sourced. Use this
                            for purely indoor scenes to avoid light leaks.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Use Texture for Bounces:</strong> If enabled, a texture with the lighting
                            information will be generated to speed up the generation of indirect lighting
                            at the cost of some accuracy. The geometry might exhibit extra light leak
                            artifacts when using low resolution lightmaps or UVs that stretch the lightmap
                            significantly across surfaces. Leave this enabled if unsure.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Use Denoiser:</strong> If enabled, uses a denoising algorithm to make the lightmap
                            significantly less noisy. This increases bake times and can occasionally
                            introduce artifacts, but the result is often worth it. See
                            <reference internal="True" refid="doc-using-lightmap-gi-denoising"><inline classes="std std-ref">Denoising</inline></reference> for more information.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Denoiser Strength:</strong> The strength of denoising step applied to the generated
                            lightmaps. Higher values are more effective at removing noise, but can reduce
                            shadow detail for static shadows. Only effective if denoising is enabled and
                            the denoising method is <abbreviation explanation="Non-Local Means with Joint Filtering">JNLM</abbreviation>
                            (<abbreviation explanation="Open Image Denoise">OIDN</abbreviation> does not have a denoiser strength setting).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Bias:</strong> The offset value to use for shadows in 3D units. You generally don't
                            need to change this value, except if you run into issues with light bleeding or
                            dark spots in your lightmap after baking. This setting does not affect real-time
                            shadows casted on baked surfaces (for lights with <strong>Dynamic</strong> bake mode).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Max Texture Size:</strong> The maximum texture size for the generated texture
                            atlas. Higher values will result in fewer slices being generated, but may not
                            work on all hardware as a result of hardware limitations on texture sizes.
                            Leave this at its default value of <literal>16384</literal> if unsure.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Environment &gt; Mode:</strong> Controls how environment lighting is sourced when
                            baking lightmaps. The default value of <strong>Scene</strong> is suited for levels with
                            visible exterior parts. For purely indoor scenes, set this to <strong>Disabled</strong> to
                            avoid light leaks and speed up baking. This can also be set to <strong>Custom Sky</strong>
                            or <strong>Custom Color</strong> to use environment lighting that differs from the actual
                            scene's environment sky.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Gen Probes &gt; Subdiv:</strong> See <reference internal="True" refid="doc-using-lightmap-gi-dynamic-objects"><inline classes="std std-ref">Dynamic objects</inline></reference>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Data &gt; Light Data:</strong> See <reference internal="True" refid="doc-using-lightmap-gi-data"><inline classes="std std-ref">Lightmap data</inline></reference>.</paragraph>
                    </list_item>
                </bullet_list>
                <target refid="doc-using-lightmap-gi-shadowmask"></target>
            </section>
        </section>
        <section ids="using-shadowmasking-for-distant-directional-shadows doc-using-lightmap-gi-shadowmask" names="using\ shadowmasking\ for\ distant\ directional\ shadows doc_using_lightmap_gi_shadowmask">
            <title>Using shadowmasking for distant directional shadows</title>
            <paragraph>When using a DirectionalLight3D, the maximum distance at which it can draw
                real-time shadows is limited by its <strong>Shadow Max Distance</strong> property. This can
                be an issue in large scenes, as distant objects won't appear to have any shadows
                from the DirectionalLight3D. While this can be resolved by using the <strong>Static</strong>
                global illumination mode on the DirectionalLight3D, this has several downsides:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Since both direct and indirect light are baked, there is no way for dynamic
                        objects to cast shadows onto static surfaces in a realistic manner. Godot skips
                        shadow sampling entirely in this case to avoid "double lighting" artifacts.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Static shadows up close lack in detail, as they only rely on the lightmap texture
                        and not on real-time shadow cascades.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>We can avoid these downsides while still benefiting from distant shadows by
                using <emphasis>shadowmasking</emphasis>. While dynamic objects won't receive shadows from the
                shadowmask, it still greatly improves visuals since most scenes are primarily
                comprised of static objects.</paragraph>
            <paragraph>Since the lightmap texture alone doesn't contain shadow information, we can bake
                this shadow information to a separate texture called a <emphasis>shadowmask</emphasis>.</paragraph>
            <paragraph>Shadowmasking only affects the first DirectionalLight3D in the scene (determined
                by tree order) that has the <strong>Dynamic</strong> global illumination mode. It is not
                possible to use shadowmasking with the <strong>Static</strong> global illumination mode, as
                this mode skips shadow sampling on static objects entirely. This is because the
                Static global illumination mode bakes both direct and indirect light.</paragraph>
            <paragraph>Three shadowmasking modes are available:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>None (default):</strong> Don't bake a shadowmask texture. Directional shadows will
                        not be visible outside the range specified by the DirectionalLight3D's
                        <strong>Shadow Max Distance</strong> property.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Replace:</strong> Bakes a shadowmask texture, and uses it to draw directional
                        shadows when outside the range specified by the DirectionalLight3D's <strong>Shadow
                            Max Distance</strong> property. Shadows within this range remain fully real-time.
                        This option generally makes the most sense for most scenes, as it can deal
                        well with static objects that exhibit subtle motion (e.g. foliage shadows).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Overlay:</strong> Bakes a shadowmask texture, and uses it to draw directional
                        shadows regardless of the distance from the camera. Shadows within the range
                        of the DirectionalLight3D's <strong>Shadow Max Distance</strong> property will be overlaid
                        with real-time shadows. This can make the transition between real-time and
                        baked shadows less jarring, at the cost of a "smearing" effect present on
                        static object shadows depending on lightmap texel density. Also, this mode
                        can't deal as well with static objects that exhibit subtle motion (such as
                        foliage), as the baked shadows can't be animated over time. Still, for scenes
                        where the camera moves quickly, this may be a better choice than <strong>Replace</strong>.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Here's a visual comparison of the shadowmask modes with a scene where the
                <strong>Shadow Max Distance</strong> was set very low for comparison purposes. The blue boxes
                are dynamic objects, while the rest of the scene is a static object. There is
                only a single DirectionalLight3D in the scene with the Dynamic global
                illumination mode:</paragraph>
            <figure align="center" ids="id4">
                <image alt="Comparison between shadowmask modes" candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_shadowmask.webp'}" original_uri="img/lightmap_gi_shadowmask.webp" uri="tutorials/3d/global_illumination/img/lightmap_gi_shadowmask.webp"></image>
                <caption>Comparison between shadowmask modes</caption>
            </figure>
            <note>
                <paragraph>It is possible to switch between the <strong>Replace</strong> and <strong>Overlay</strong> shadowmask
                    modes without having to bake lightmaps again.</paragraph>
            </note>
        </section>
        <section ids="balancing-bake-times-with-quality" names="balancing\ bake\ times\ with\ quality">
            <title>Balancing bake times with quality</title>
            <paragraph>Since high-quality bakes can take very long (up to dozens of minutes for large
                complex scenes), it is recommended to use lower quality settings at first. Then,
                once you are confident with your scene's lighting setup, raise the quality
                settings and perform a "final" bake before exporting your project.</paragraph>
            <paragraph>Reducing the lightmap resolution by increasing <strong>Lightmap Texel Size</strong> on the
                imported 3D scenes will also speed up baking significantly. However, this will
                require you to reimport all lightmapped 3D scenes before you can bake lightmaps
                again.</paragraph>
            <target refid="doc-using-lightmap-gi-denoising"></target>
        </section>
        <section ids="denoising doc-using-lightmap-gi-denoising" names="denoising doc_using_lightmap_gi_denoising">
            <title>Denoising</title>
            <paragraph>Since baking lightmaps relies on raytracing, there will always be visible noise
                in the "raw" baked lightmap. Noise is especially visible in areas that are
                difficult to reach by bounced light, such as indoor areas with small openings
                where the sunlight can enter. Noise can be reduced by increasing bake quality,
                but doing so will increase bake times significantly.</paragraph>
            <figure align="center" ids="id5">
                <image alt="Comparison between denoising disabled and enabled" candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_denoiser_comparison.webp'}" original_uri="img/lightmap_gi_denoiser_comparison.webp" uri="tutorials/3d/global_illumination/img/lightmap_gi_denoiser_comparison.webp"></image>
                <caption>Comparison between denoising disabled and enabled (with the default JNLM denoiser).</caption>
            </figure>
            <paragraph>To combat noise without increasing bake times too much, a denoiser can be used.
                A denoiser is an algorithm that runs on the final baked lightmap, detects patterns of
                noise and softens them while attempting to best preserve detail.
                Godot offers two denoising algorithms:</paragraph>
            <section ids="jnlm-non-local-means-with-joint-filtering" names="jnlm\ (non-local\ means\ with\ joint\ filtering)">
                <title>JNLM (Non-Local Means with Joint Filtering)</title>
                <paragraph>JNLM is the default denoising method and is included in Godot. It uses a simple
                    but efficient denoising algorithm known as <emphasis>non-local means</emphasis>. JNLM runs on the
                    GPU using a compute shader, and is compatible with any GPU that can run Godot
                    4's RenderingDevice-based renderers. No additional setup is required.</paragraph>
                <paragraph>JNLM's denoising can be adjusted using the <strong>Denoiser Strength</strong> property that
                    is visible when <strong>Use Denoiser</strong> enabled. Higher values can be more effective at
                    removing noise, at the cost of suppressing shadow detail for static shadows.</paragraph>
                <figure align="center" ids="id6">
                    <image alt="Comparison between JNLM denoiser strength values" candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_denoiser_jnlm_strength.webp'}" original_uri="img/lightmap_gi_denoiser_jnlm_strength.webp" uri="tutorials/3d/global_illumination/img/lightmap_gi_denoiser_jnlm_strength.webp"></image>
                    <caption>Comparison between JNLM denoiser strength values. Higher values can reduce detail.</caption>
                </figure>
            </section>
            <section ids="oidn-open-image-denoise" names="oidn\ (open\ image\ denoise)">
                <title>OIDN (Open Image Denoise)</title>
                <paragraph>Unlike JNLM, OIDN uses a machine learning approach to denoising lightmaps. It
                    features a model specifically trained to remove noise from lightmaps while
                    preserving more shadow detail in most scenes compared to JNLM.</paragraph>
                <paragraph>OIDN can run on the GPU if hardware acceleration is configured. With a modern
                    high-end GPU, this can provide a speedup of over 50Ã— over CPU-based denoising:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>On AMD GPUs, HIP must be installed and configured.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>On NVIDIA GPUs, CUDA must be installed and configured. This may automatically
                            be done by the NVIDIA installer, but on Linux, CUDA libraries may not be
                            installed by default. Double-check that the CUDA packages from your Linux
                            distribution are installed.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>On Intel GPUs, SYCL must be installed and configured.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>If hardware acceleration is not available, OIDN will fall back to multithreaded
                    CPU-based denoising. To confirm whether GPU-based denoising is working, use a
                    GPU utilization monitor while baking lightmaps and look at the GPU utilization
                    percentage and VRAM utilization while the denoising step is shown in the Godot
                    editor. The <literal>nvidia-smi</literal> command line tool can be useful for this.</paragraph>
                <paragraph>OIDN is not included with Godot due to its relatively large download size. You
                    can download precompiled OIDN binary packages from its
                    <reference name="website" refuri="https://www.openimagedenoise.org/downloads.html">website</reference>.
                    Extract the package to a location on your PC, then specify the path to the
                    <literal>oidnDenoise</literal> executable in the Editor Settings (<strong>FileSystem &gt; Tools &gt; OIDN &gt;
                        OIDN Denoise Path</strong>). This executable is located within the <literal>bin</literal> folder of
                    the binary package you extracted.</paragraph>
                <paragraph>After specifying the path to the OIDN denoising executable, change the denoising
                    method in the project settings by setting <strong>Rendering &gt; Lightmapping &gt;
                        Denoiser</strong> to <strong>OIDN</strong>. This will affect all lightmap bakes on this project
                    after the setting is changed.</paragraph>
                <note>
                    <paragraph>The denoising method is configured in the project settings instead of the
                        editor settings. This is done so that different team members working on the
                        same project are assured to be using the same denoising method for
                        consistent results.</paragraph>
                </note>
                <figure align="center" ids="id7">
                    <image alt="Comparison between JNLM and OIDN denoisers" candidates="{'*': 'tutorials/3d/global_illumination/img/lightmap_gi_denoiser_jnlm_vs_oidn.webp'}" original_uri="img/lightmap_gi_denoiser_jnlm_vs_oidn.webp" uri="tutorials/3d/global_illumination/img/lightmap_gi_denoiser_jnlm_vs_oidn.webp"></image>
                    <caption>Comparison between JNLM and OIDN denoisers.
                        Notice how OIDN better preserves detail and reduces seams across different objects.</caption>
                </figure>
                <target refid="doc-using-lightmap-gi-dynamic-objects"></target>
            </section>
        </section>
        <section ids="dynamic-objects doc-using-lightmap-gi-dynamic-objects" names="dynamic\ objects doc_using_lightmap_gi_dynamic_objects">
            <title>Dynamic objects</title>
            <paragraph>Unlike VoxelGI and SDFGI, dynamic objects receive indirect lighting differently
                compared to static objects. This is because lightmapping is only performed on
                static objects.</paragraph>
            <paragraph>To display indirect lighting on dynamic objects, a 3D probe system is used, with
                light probes being spread throughout the scene. When baking lightmaps, the
                lightmapper will calculate the amount of <emphasis>indirect</emphasis> light received by the probe.
                Direct light is not stored within light probes, even for lights that have their
                bake mode set to <strong>Static</strong> (as dynamic objects continue to be lit in
                real-time).</paragraph>
            <paragraph>There are 2 ways to add light probes to a scene:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Automatic:</strong> Set <strong>Gen Probes &gt; Subdiv</strong> to a value other than <strong>Disabled</strong>,
                        then bake lightmaps. The default is <literal>8</literal>, but you can choose a greater value
                        to improve precision at the cost of longer bake times and larger output file
                        size.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Manual:</strong> In addition or as an alternative to generating probes
                        automatically, you can add light probes manually by adding <reference internal="True" refuri="../../../classes/class_lightmapprobe#class-lightmapprobe"><inline classes="std std-ref">LightmapProbe</inline></reference>
                        nodes to the scene. This can be used to improve lighting detail in areas frequently
                        travelled by dynamic objects. After placing LightmapProbe nodes in the scene,
                        you must bake lightmaps again for them to be effective.</paragraph>
                </list_item>
            </bullet_list>
            <note>
                <paragraph>After baking lightmaps, you will notice white spheres in the 3D scene that
                    represent how baked lighting will affect dynamic objects. These spheres do
                    <strong>not</strong> appear in the running project.</paragraph>
                <paragraph>If you want to hide these spheres in the editor, toggle <strong>View &gt; Gizmos &gt;
                        LightmapGI</strong> at the top of the 3D editor (a "closed eye" icon indicates the
                    gizmo is hidden).</paragraph>
            </note>
            <target refid="doc-using-lightmap-gi-data"></target>
        </section>
        <section ids="lightmap-data doc-using-lightmap-gi-data" names="lightmap\ data doc_using_lightmap_gi_data">
            <title>Lightmap data</title>
            <paragraph>The <strong>Data &gt; Light Data</strong> property in the LightmapGI node contains the lightmap
                data after baking. Textures are saved to disk, but this also contains the
                capture data for dynamic objects, which can be heavy. If you are using a scene
                in <literal>.tscn</literal> format, you should save this resource to an external binary
                <literal>.lmbake</literal> file to avoid bloating the <literal>.tscn</literal> scene with binary data encoded
                in Base64.</paragraph>
            <tip>
                <paragraph>The generated EXR file can be viewed and even edited using an image editor
                    to perform post-processing if needed. However, keep in mind that changes to
                    the EXR file will be lost when baking lightmaps again.</paragraph>
            </tip>
        </section>
        <section ids="reducing-lightmapgi-artifacts" names="reducing\ lightmapgi\ artifacts">
            <title>Reducing LightmapGI artifacts</title>
            <paragraph>If you notice LightmapGI nodes popping in and out of existence as the camera
                moves, this is most likely because the engine is rendering too many LightmapGI
                instances at once. Godot is limited to rendering 8 LightmapGI nodes at once,
                which means up to 8 instances can be in the camera view before some of them will
                start flickering.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
