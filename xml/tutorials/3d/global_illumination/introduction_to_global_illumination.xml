<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/global_illumination/introduction_to_global_illumination.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-introduction-to-global-illumination"></target>
    <section ids="introduction-to-global-illumination doc-introduction-to-global-illumination" names="introduction\ to\ global\ illumination doc_introduction_to_global_illumination">
        <title>Introduction to global illumination</title>
        <section ids="what-is-global-illumination" names="what\ is\ global\ illumination?">
            <title>What is global illumination?</title>
            <paragraph><emphasis>Global illumination</emphasis> is a catch-all term used to describe a system of lighting
                that uses both direct light (light that comes directly from a light source) and
                indirect light (light that bounces from a surface). In a 3D rendering engine,
                global illumination is one of the most important elements to achieving
                realistic lighting. Global illumination aims to mimic how light behaves
                in real life, such as light bouncing on surfaces and light being emitted
                from emissive materials.</paragraph>
            <paragraph>In the example below, the entire scene is illuminated by an emissive material
                (the white square at the top). The white wall and ceiling on the back is tinted
                red and green close to the walls, as the light bouncing on the colored walls is
                being reflected back onto the rest of the scene.</paragraph>
            <image candidates="{'*': 'tutorials/3d/global_illumination/img/global_illumination_example.webp'}" original_uri="img/global_illumination_example.webp" uri="tutorials/3d/global_illumination/img/global_illumination_example.webp"></image>
            <paragraph>Global illumination is composed of several key concepts:</paragraph>
            <section ids="indirect-diffuse-lighting" names="indirect\ diffuse\ lighting">
                <title>Indirect diffuse lighting</title>
                <paragraph>This is the lighting that does not change depending on the camera's angle.
                    There are two main sources of indirect diffuse lighting:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Light <emphasis>bouncing</emphasis> on surfaces. This bounced lighting is multiplied with the
                            material's albedo color. The bounced lighting can then be reflected by other
                            surfaces, with decreasing impact due to light attenuation. In real life,
                            light bounces an infinite number of times. However, for performance
                            reasons, this can't be simulated in a game engine. Instead, the number of
                            bounces is typically limited to 1 or 2 (or up to 16 when baking lightmaps). A
                            greater number of bounces will lead to more realistic light falloff in shaded
                            areas, at the cost of lower performance or greater bake times.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Emissive materials can also emit light that can be bounced on surfaces.
                            This acts as a form of <emphasis>area lighting</emphasis>. Instead of having an infinitely
                            small point emit light using an OmniLight3D or SpotLight3D node,
                            an area of a determined size will emit light using its own surface.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Direct diffuse lighting is already handled by the light nodes themselves, which
                    means that global illumination algorithms only try to represent indirect
                    lighting.</paragraph>
                <paragraph>Different global illumination techniques offer varying levels of accuracy
                    to represent indirect diffuse lighting. See the comparison table at the bottom
                    of this page for more information.</paragraph>
                <paragraph>To provide more accurate ambient occlusion for small objects, screen-space ambient occlusion
                    (SSAO) can be enabled in the <reference internal="True" refuri="../environment_and_post_processing#doc-environment-and-post-processing"><inline classes="std std-ref">environment</inline></reference>
                    settings. SSAO has a significant performance cost, so make sure to disable
                    it when targeting low-end hardware.</paragraph>
                <note>
                    <paragraph>Indirect diffuse lighting may be a source of color banding in scenes with no
                        detailed textures. This results in light gradients not being smooth, but
                        having a visible "stepping" effect instead. See the
                        <reference internal="True" refuri="../3d_rendering_limitations#doc-3d-rendering-limitations-color-banding"><inline classes="std std-ref">Color banding</inline></reference> section in the 3D rendering
                        limitations documentation for ways to reduce this effect.</paragraph>
                </note>
            </section>
            <section ids="specular-lighting" names="specular\ lighting">
                <title>Specular lighting</title>
                <paragraph>Specular lighting is also referred to as <emphasis>reflections</emphasis>.
                    This is the lighting that changes in intensity depending on the camera's angle.
                    This specular lighting can be <emphasis>direct</emphasis> or <emphasis>indirect</emphasis>.</paragraph>
                <paragraph>Most global illumination techniques offer a way to render specular lighting.
                    However, the degree of accuracy at which specular lighting is rendered varies
                    greatly from technique to technique. See the comparison table at the bottom
                    of this page for more information.</paragraph>
                <paragraph>To provide more accurate reflections for small objects, screen-space reflections (SSR)
                    can be enabled in the <reference internal="True" refuri="../environment_and_post_processing#doc-environment-and-post-processing"><inline classes="std std-ref">environment</inline></reference> settings.
                    SSR has a significant performance cost (even more so than SSAO), so make sure to disable
                    it when targeting low-end hardware.</paragraph>
                <target refid="doc-introduction-to-global-illumination-comparison"></target>
            </section>
        </section>
        <section ids="which-global-illumination-technique-should-i-use doc-introduction-to-global-illumination-comparison" names="which\ global\ illumination\ technique\ should\ i\ use? doc_introduction_to_global_illumination_comparison">
            <title>Which global illumination technique should I use?</title>
            <paragraph>When determining a global illumination (GI) technique to use,
                there are several criteria to keep in mind:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Performance.</strong> Real-time GI techniques are usually more expensive
                        compared to semi-real-time or baked techniques. Note that most of the cost in
                        GI rendering is spent on the GPU, rather than the CPU.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Visuals.</strong> On top of not performing the best, real-time GI techniques
                        generally don't provide the best visual output. This is especially the case in
                        a mostly static scene where the dynamic nature of real-time GI is not easily
                        noticeable. If maximizing visual quality is your goal, baked techniques will
                        often look better and will result in fewer light leaks.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Real-time ability.</strong> Some GI techniques are fully real-time,
                        whereas others are only semi-real-time or aren't real-time at all.
                        Semi-real-time techniques have restrictions that fully real-time techniques don't.
                        For instance, dynamic objects may not contribute emissive lighting to the scene.
                        Non-real-time techniques do not support <emphasis>any</emphasis> form of dynamic GI,
                        so it must be faked using other techniques if needed (such as placing positional lights
                        near emissive surfaces).
                        Real-time ability also affects the GI technique's viability in procedurally
                        generated levels.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>User work needed.</strong> Some GI techniques are fully automatic, whereas others
                        require careful planning and manual work on the user's side. Depending on your
                        time budget, some GI techniques may be preferable to others.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Here's a comparison of all the global illumination techniques available in Godot:</paragraph>
            <section ids="performance" names="performance">
                <title>Performance</title>
                <paragraph>In order of performance from fastest to slowest:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>ReflectionProbe:</strong></paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>ReflectionProbes with their update mode set to <strong>Always</strong> are much more
                                    expensive than probes with their update mode set to <strong>Once</strong> (the default).
                                    Suited for integrated graphics when using the <strong>Once</strong> update mode.
                                    <emphasis>Available in all renderers.</emphasis></paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>LightmapGI:</strong></paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Lights can be baked with indirect lighting only, or fully baked on a
                                    per-light basis to further improve performance. Hybrid setups can be used
                                    (such as having a real-time directional light and fully baked positional lights).
                                    Directional information can be enabled before baking to improve visuals at
                                    a small performance cost (and at the cost of larger file sizes).
                                    Suited for integrated graphics.
                                    <emphasis>Available in all renderers. However, baking lightmaps requires hardware
                                        with RenderingDevice support.</emphasis></paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>VoxelGI:</strong></paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>The bake's number of subdivisions can be adjusted to balance between performance and quality.
                                    The VoxelGI rendering quality can be adjusted in the Project Settings.
                                    The rendering can optionally be performed at half resolution
                                    (and then linearly scaled) to improve performance significantly.
                                    <strong>Not available</strong> <emphasis>when using the Mobile or Compatibility renderers.</emphasis></paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Screen-space indirect lighting (SSIL):</strong></paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>The SSIL quality and number of blur passes can be adjusted in the Project Settings.
                                    By default, SSIL rendering is performed at half resolution (and then linearly scaled)
                                    to ensure a reasonable performance level.
                                    <strong>Not available</strong> <emphasis>when using the Mobile or Compatibility renderers.</emphasis></paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>SDFGI:</strong></paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>The number of cascades can be adjusted to balance performance and quality.
                                    The number of rays thrown per frame can be adjusted in the Project Settings.
                                    The rendering can optionally be performed at half resolution
                                    (and then linearly scaled) to improve performance significantly.
                                    <strong>Not available</strong> <emphasis>when using the Mobile or Compatibility renderers.</emphasis></paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="visuals" names="visuals">
                <title>Visuals</title>
                <paragraph>For comparison, here's a 3D scene with no global illumination options used:</paragraph>
                <figure ids="id1">
                    <image alt="A 3D scene without any form of global illumination (only constant environment lighting). The box and sphere near the camera are both dynamic objects." candidates="{'*': 'tutorials/3d/global_illumination/img/gi_none.webp'}" original_uri="img/gi_none.webp" uri="tutorials/3d/global_illumination/img/gi_none.webp"></image>
                    <caption>A 3D scene without any form of global illumination (only constant environment lighting). The box and sphere near the camera are both dynamic objects.</caption>
                </figure>
                <paragraph>Here's how Godot's various global illumination techniques compare:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>VoxelGI:</strong> <image alt="average" candidates="{'*': 'tutorials/3d/global_illumination/img/score_average.webp'}" original_uri="img/score_average.webp" uri="tutorials/3d/global_illumination/img/score_average.webp"></image> Good reflections and indirect lighting, but beware of leaks.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Due to its voxel-based nature, VoxelGI will exhibit light leaks if walls and floors are too thin.
                                    It's recommended to make sure all solid surfaces are at least as thick as one voxel.</paragraph>
                                <paragraph>Streaking artifacts may also be visible on sloped surfaces. In this case,
                                    tweaking the bias properties or rotating the VoxelGI node can help combat
                                    this.</paragraph>
                                <figure ids="id2">
                                    <image alt="VoxelGI in action." candidates="{'*': 'tutorials/3d/global_illumination/img/gi_voxel_gi.webp'}" original_uri="img/gi_voxel_gi.webp" uri="tutorials/3d/global_illumination/img/gi_voxel_gi.webp"></image>
                                    <caption>VoxelGI in action.</caption>
                                </figure>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>SDFGI:</strong> <image alt="average" candidates="{'*': 'tutorials/3d/global_illumination/img/score_average.webp'}" original_uri="img/score_average.webp" uri="tutorials/3d/global_illumination/img/score_average.webp"></image> Good reflections and indirect lighting, but beware of leaks and visible cascade shifts.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>GI level of detail varies depending on the distance
                                    between the camera and surface.</paragraph>
                                <paragraph>Leaks can be reduced significantly by enabling the <strong>Use Occlusion</strong>
                                    property. This has a small performance cost, but it often results in fewer
                                    leaks compared to VoxelGI.</paragraph>
                                <paragraph>Cascade shifts may be visible when the camera moves fast. This can be made
                                    less noticeable by adjusting the cascade sizes or using fog.</paragraph>
                                <figure ids="id3">
                                    <image alt="SDFGI in action." candidates="{'*': 'tutorials/3d/global_illumination/img/gi_sdfgi.webp'}" original_uri="img/gi_sdfgi.webp" uri="tutorials/3d/global_illumination/img/gi_sdfgi.webp"></image>
                                    <caption>SDFGI in action.</caption>
                                </figure>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Screen-space indirect lighting (SSIL):</strong> <image alt="average" candidates="{'*': 'tutorials/3d/global_illumination/img/score_average.webp'}" original_uri="img/score_average.webp" uri="tutorials/3d/global_illumination/img/score_average.webp"></image> Good <emphasis>secondary</emphasis> source of indirect lighting, but no reflections.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>SSIL is designed to be used as a complement to another GI technique such as
                                    VoxelGI, SDFGI or LightmapGI. SSIL works best for small-scale details, as it
                                    cannot provide accurate indirect lighting for large structures on its own.
                                    SSIL can provide real-time indirect lighting in situations where other GI
                                    techniques fail to capture small-scale details or dynamic objects. Its
                                    screen-space nature will result in some artifacts, especially when objects
                                    enter and leave the screen. SSIL works using the last frame's color (before
                                    post-processing) which means that emissive decals and custom shaders are
                                    included (as long as they're present on screen).</paragraph>
                                <figure ids="id4">
                                    <image alt="SSIL in action (without any other GI technique). Notice the emissive lighting around the yellow box." candidates="{'*': 'tutorials/3d/global_illumination/img/gi_ssil_only.webp'}" original_uri="img/gi_ssil_only.webp" uri="tutorials/3d/global_illumination/img/gi_ssil_only.webp"></image>
                                    <caption>SSIL in action (without any other GI technique). Notice the emissive lighting around the yellow box.</caption>
                                </figure>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>LightmapGI:</strong> <image alt="good" candidates="{'*': 'tutorials/3d/global_illumination/img/score_good.webp'}" original_uri="img/score_good.webp" uri="tutorials/3d/global_illumination/img/score_good.webp"></image> Excellent indirect lighting, decent reflections (optional).</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>This is the only technique where the number of light bounces
                                    can be pushed above 2 (up to 16). When directional information
                                    is enabled, spherical harmonics (SH) are used
                                    to provide blurry reflections.</paragraph>
                                <figure ids="id5">
                                    <image alt="LightmapGI in action. Only indirect lighting is baked here, but direct light can also be baked." candidates="{'*': 'tutorials/3d/global_illumination/img/gi_lightmap_gi_indirect_only.webp'}" original_uri="img/gi_lightmap_gi_indirect_only.webp" uri="tutorials/3d/global_illumination/img/gi_lightmap_gi_indirect_only.webp"></image>
                                    <caption>LightmapGI in action. Only indirect lighting is baked here, but direct light can also be baked.</caption>
                                </figure>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>ReflectionProbe:</strong> <image alt="average" candidates="{'*': 'tutorials/3d/global_illumination/img/score_average.webp'}" original_uri="img/score_average.webp" uri="tutorials/3d/global_illumination/img/score_average.webp"></image> Good reflections, but poor indirect lighting.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Indirect lighting can be disabled, set to a constant color spread throughout
                                    the probe, or automatically read from the probe's environment (and applied
                                    as a cubemap). This essentially acts as local ambient lighting. Reflections
                                    and indirect lighting are blended with other nearby probes.</paragraph>
                                <figure ids="id6">
                                    <image alt="ReflectionProbe in action (without any other GI technique). Notice the reflective sphere." candidates="{'*': 'tutorials/3d/global_illumination/img/gi_none_reflection_probe.webp'}" original_uri="img/gi_none_reflection_probe.webp" uri="tutorials/3d/global_illumination/img/gi_none_reflection_probe.webp"></image>
                                    <caption>ReflectionProbe in action (without any other GI technique). Notice the reflective sphere.</caption>
                                </figure>
                            </list_item>
                        </bullet_list>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="real-time-ability" names="real-time\ ability">
                <title>Real-time ability</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>VoxelGI:</strong> <image alt="good" candidates="{'*': 'tutorials/3d/global_illumination/img/score_good.webp'}" original_uri="img/score_good.webp" uri="tutorials/3d/global_illumination/img/score_good.webp"></image> Fully real-time.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Indirect lighting and reflections are fully real-time. Dynamic objects can
                                    receive GI <emphasis>and</emphasis> contribute to it with their emissive surfaces. Custom
                                    shaders can also emit their own light, which will be emitted accurately.</paragraph>
                                <paragraph>Viable for procedurally generated levels <emphasis>if they are generated in advance</emphasis>
                                    (and not during gameplay). Baking requires several seconds or more to complete,
                                    but it can be done from both the editor and an exported project.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>SDFGI:</strong> <image alt="average" candidates="{'*': 'tutorials/3d/global_illumination/img/score_average.webp'}" original_uri="img/score_average.webp" uri="tutorials/3d/global_illumination/img/score_average.webp"></image> Semi-real-time.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Cascades are generated in real-time, making SDFGI
                                    viable for procedurally generated levels (including when structures are generated
                                    during gameplay).</paragraph>
                                <paragraph>Dynamic objects can <emphasis>receive</emphasis> GI, but not <emphasis>contribute</emphasis> to it. Emissive lighting
                                    will only update when an object enters a cascade, so it may still work for
                                    slow-moving objects.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Screen-space indirect lighting (SSIL):</strong> <image alt="good" candidates="{'*': 'tutorials/3d/global_illumination/img/score_good.webp'}" original_uri="img/score_good.webp" uri="tutorials/3d/global_illumination/img/score_good.webp"></image> Fully real-time.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>SSIL works with both static and dynamic lights. It also works with both
                                    static and dynamic occluders (including emissive materials).</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>LightmapGI:</strong> <image alt="bad" candidates="{'*': 'tutorials/3d/global_illumination/img/score_bad.webp'}" original_uri="img/score_bad.webp" uri="tutorials/3d/global_illumination/img/score_bad.webp"></image> Baked, and therefore not real-time.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Both indirect lighting and SH reflections are baked and can't be changed at
                                    runtime. Real-time GI must be
                                    <reference internal="True" refuri="faking_global_illumination#doc-faking-global-illumination"><inline classes="std std-ref">simulated via other means</inline></reference>,
                                    such as real-time positional lights. Dynamic objects receive indirect lighting
                                    via light probes, which can be placed automatically or manually by the user
                                    (LightmapProbe node). Not viable for procedurally generated levels,
                                    as baking lightmaps is only possible from the editor.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>ReflectionProbe:</strong> <image alt="average" candidates="{'*': 'tutorials/3d/global_illumination/img/score_average.webp'}" original_uri="img/score_average.webp" uri="tutorials/3d/global_illumination/img/score_average.webp"></image> Optionally real-time.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>By default, reflections update when the probe is moved.
                                    They update as often as possible if the update mode
                                    is set to <strong>Always</strong> (which is expensive).</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>Indirect lighting must be configured manually by the user, but can be changed
                                    at runtime without causing an expensive computation to happen behind the scenes.
                                    This makes ReflectionProbes viable for procedurally generated levels.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="user-work-needed" names="user\ work\ needed">
                <title>User work needed</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>VoxelGI:</strong> One or more VoxelGI nodes need to be created and baked.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Adjusting extents correctly is required to get good results. Additionally
                                    rotating the node and baking again can help combat leaks or streaking
                                    artifacts in certain situations. Bake times are fast – usually below
                                    10 seconds for a scene of medium complexity.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>SDFGI:</strong> Very little.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>SDFGI is fully automatic; it only needs to be enabled in the Environment resource.
                                    The only manual work required is to set MeshInstances' bake mode property correctly.
                                    No node needs to be created, and no baking is required.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Screen-space indirect lighting (SSIL):</strong> Very little.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>SSIL is fully automatic; it only needs to be enabled in the Environment resource.
                                    No node needs to be created, and no baking is required.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>LightmapGI:</strong> Requires UV2 setup and baking.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Static meshes must be reimported with UV2 and lightmap generation enabled.
                                    On a dedicated GPU, bake times are relatively fast thanks to the GPU-based
                                    lightmap baking – usually below 1 minute for a scene of medium complexity.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>ReflectionProbe:</strong> Placed manually by the user.</paragraph>
                    </list_item>
                </bullet_list>
                <substitution_definition names="good"><image alt="good" candidates="{'*': 'tutorials/3d/global_illumination/img/score_good.webp'}" original_uri="img/score_good.webp" uri="tutorials/3d/global_illumination/img/score_good.webp"></image></substitution_definition>
                <substitution_definition names="average"><image alt="average" candidates="{'*': 'tutorials/3d/global_illumination/img/score_average.webp'}" original_uri="img/score_average.webp" uri="tutorials/3d/global_illumination/img/score_average.webp"></image></substitution_definition>
                <substitution_definition names="bad"><image alt="bad" candidates="{'*': 'tutorials/3d/global_illumination/img/score_bad.webp'}" original_uri="img/score_bad.webp" uri="tutorials/3d/global_illumination/img/score_bad.webp"></image></substitution_definition>
            </section>
            <section ids="summary" names="summary">
                <title>Summary</title>
                <paragraph>If you are unsure about which GI technique to use:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>For desktop games, it's a good idea to start with <reference internal="True" refuri="using_sdfgi#doc-using-sdfgi"><inline classes="std std-ref">SDFGI</inline></reference>
                            first as it requires the least amount of setup. Move to other GI techniques
                            later if needed. To improve performance on low-end GPUs and integrated
                            graphics, consider adding an option to disable SDFGI or <reference internal="True" refuri="using_voxel_gi#doc-using-voxel-gi"><inline classes="std std-ref">VoxelGI</inline></reference> in your game's settings. SDFGI can be disabled in the
                            Environment resource, and VoxelGI can be disabled by hiding the VoxelGI
                            node(s). To further improve visuals on high-end setups, add an option to
                            enable SSIL in your game's settings.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>For mobile games, <reference internal="True" refuri="using_lightmap_gi#doc-using-lightmap-gi"><inline classes="std std-ref">LightmapGI</inline></reference> and
                            <reference internal="True" refuri="reflection_probes#doc-reflection-probes"><inline classes="std std-ref">ReflectionProbes</inline></reference> are the only supported options.
                            See also <reference internal="True" refid="doc-introduction-to-global-illumination-alternatives"><inline classes="std std-ref">Alternatives to GI techniques</inline></reference>.</paragraph>
                    </list_item>
                </bullet_list>
                <seealso>
                    <paragraph>You can compare global illumination techniques in action using the
                        <reference name="Global Illumination demo project" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/3d/global_illumination">Global Illumination demo project</reference>.</paragraph>
                </seealso>
                <target refid="doc-introduction-to-global-illumination-gi-mode-recommendations"></target>
            </section>
            <section ids="which-global-illumination-mode-should-i-use-on-meshes-and-lights doc-introduction-to-global-illumination-gi-mode-recommendations" names="which\ global\ illumination\ mode\ should\ i\ use\ on\ meshes\ and\ lights? doc_introduction_to_global_illumination_gi_mode_recommendations">
                <title>Which global illumination mode should I use on meshes and lights?</title>
                <paragraph>Regardless of which global illumination technique you use, there is no
                    universally "better" global illumination mode. Still, here are some
                    recommendations for meshes:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>For static level geometry, use the <strong>Static</strong> global illumination mode <emphasis>(default)</emphasis>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>For small dynamic geometry and players/enemies, use the <strong>Disabled</strong> global
                            illumination mode. Small dynamic geometry will not be able to contribute a significant
                            amount of indirect lighting, due to the geometry being smaller than a voxel.
                            If you need indirect lighting for small dynamic objects, it can be simulated
                            using an OmniLight3D or SpotLight3D node parented to the object.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>For <emphasis>large</emphasis> dynamic level geometry (such as a moving train), use the
                            <strong>Dynamic</strong> global illumination mode. Note that this only has an effect with
                            VoxelGI, as SDFGI and LightmapGI do not support global illumination with
                            dynamic objects.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Here are some recommendations for light bake modes:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>For static level lighting, use the <strong>Static</strong> bake mode.
                            The <strong>Static</strong> mode is also suitable for dynamic lights that don't change
                            much during gameplay, such as a flickering torch.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>For short-lived dynamic effects (such as a weapon), use the <strong>Disabled</strong>
                            bake mode to improve performance.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>For long-lived dynamic effects (such as a rotating alarm light), use the
                            <strong>Dynamic</strong> bake mode to improve quality <emphasis>(default)</emphasis>. Note that this only has
                            an effect with VoxelGI and SDFGI, as LightmapGI does not support global
                            illumination with dynamic lights.</paragraph>
                    </list_item>
                </bullet_list>
                <target refid="doc-introduction-to-global-illumination-alternatives"></target>
            </section>
        </section>
        <section ids="alternatives-to-gi-techniques doc-introduction-to-global-illumination-alternatives" names="alternatives\ to\ gi\ techniques doc_introduction_to_global_illumination_alternatives">
            <title>Alternatives to GI techniques</title>
            <paragraph>If none of the GI techniques mentioned above fits, it's still possible to
                <reference internal="True" refuri="faking_global_illumination#doc-faking-global-illumination"><inline classes="std std-ref">simulate GI by placing additional lights manually</inline></reference>.
                This requires more manual work, but it can offer good performance <emphasis>and</emphasis> good
                visuals if done right. This approach is still used in many modern games to this
                day.</paragraph>
            <paragraph>When targeting low-end hardware in situations where using LightmapGI is not
                viable (such as procedurally generated levels), relying on environment lighting
                alone or a constant ambient light factor may be a necessity. This may result in
                flatter visuals, but adjusting the ambient light color and sky contribution
                still makes it possible to achieve acceptable results in most cases.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
