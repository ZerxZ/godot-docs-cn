<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/global_illumination/introduction_to_global_illumination.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-introduction-to-global-illumination"></target>
    <section ids="introduction-to-global-illumination doc-introduction-to-global-illumination" names="introduction\ to\ global\ illumination 全局光照简介 doc_introduction_to_global_illumination">
        <title>全局光照简介</title>
        <section ids="what-is-global-illumination" names="what\ is\ global\ illumination? 什么是全局光照？">
            <title>什么是全局光照？</title>
            <paragraph><emphasis>全局光照</emphasis> 是一个综合性术语，用于描述一种使用直接光（直接来自光源的光线）和间接光（从表面反射的光线）的照明系统。在3D渲染引擎中，全局光照是实现逼真照明的最重要要素之一。全局光照旨在模拟现实生活中光线的行为，例如光线在表面上反射以及从自发光材料中发出的光线。</paragraph>
            <paragraph>在下面的示例中，整个场景由自发光材质（顶部的白色方块）照亮。背面的白色墙壁和天花板在靠近墙壁的地方被染成红色和绿色，因为彩色墙壁上反射的光线正在反射回场景的其余部分。</paragraph>
            <image candidates="{'*': 'tutorials/3d/global_illumination/img/global_illumination_example.webp'}" uri="tutorials/3d/global_illumination/img/global_illumination_example.webp"></image>
            <paragraph>全局光照由以下几个关键概念组成：</paragraph>
            <section ids="indirect-diffuse-lighting" names="indirect\ diffuse\ lighting 间接漫反射光照">
                <title>间接漫反射光照</title>
                <paragraph>这种光照不会因为相机的角度而改变。间接漫反射光照有两个主要来源：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>光*弹跳*在表面上。这种反射光照会与材质的反照率颜色相乘。然后，反射的照明可以被其他表面反射，由于光衰减，影响会减小。在现实生活中，光线会反射无数次。但是出于性能原因，无法在游戏引擎中模拟。相反，退回次数通常限制为 1 或 2（烘焙光照贴图时最多限制为 16）。更多的反弹将导致阴影区域更真实的光线衰减，而代价是导致性能较低或烘烤时间更长。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>自发光材质还可以发出可以在表面上反弹的光。这充当 <emphasis>区域照明</emphasis> 的一种形式。与使用 OmniLight3D 或 SpotLight3D 节点发光不同，确定大小的区域将使用自己的表面发光。</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>直接漫反射光照已经由灯光节点本身处理，这意味着全局光照算法只尝试表示间接光照。</paragraph>
                <paragraph>不同的全局光照技术提供不同级别的精度来表示间接漫反射光照。有关详细信息请参阅本页底部的比较表。</paragraph>
                <paragraph>为较小的对象提供更精确的环境光遮蔽，屏幕空间环境光遮蔽（SSAO）可以在<reference internal="True" refuri="../environment_and_post_processing#doc-environment-and-post-processing"><inline classes="std std-ref">环境</inline></reference>设置中启用。SSAO 具有较大的性能开销，因此在针对低端硬件时请确保禁用它。</paragraph>
                <note>
                    <paragraph>间接漫反射照明可能是没有细节纹理的场景中色带的来源。这导致光线梯度不平滑，而是具有可见的“步进”效果。减少这种效果的方法见 <reference internal="True" refuri="../3d_rendering_limitations#doc-3d-rendering-limitations-color-banding"><inline classes="std std-ref">带状颜色</inline></reference> 部分。</paragraph>
                </note>
            </section>
            <section ids="specular-lighting" names="specular\ lighting 镜面反射光效果">
                <title>镜面反射光效果</title>
                <paragraph>镜面反射照明也被称为 <emphasis>反射</emphasis> 。这是根据摄像机角度而变化强度的照明。这种镜面照明可以是 <emphasis>直接</emphasis> 或 <emphasis>间接</emphasis> 。</paragraph>
                <paragraph>大多数全局光照技术都提供了一种渲染镜面反射光照的方法。然而，不同技术渲染镜面反射光照的精度差异很大。有关详细信息，请参阅本页底部的比较表。</paragraph>
                <paragraph>为了给较小的对象提供更准确的反射，可以在<reference internal="True" refuri="../environment_and_post_processing#doc-environment-and-post-processing"><inline classes="std std-ref">环境</inline></reference>设置中启用屏幕空间反射（SSR）。SSR 的性能开销很大（甚至比 SSAO 更高），因此在针对低端硬件时一定要禁用它。</paragraph>
                <target refid="doc-introduction-to-global-illumination-comparison"></target>
            </section>
        </section>
        <section ids="which-global-illumination-technique-should-i-use doc-introduction-to-global-illumination-comparison" names="which\ global\ illumination\ technique\ should\ i\ use? 我应该使用哪种全局光照技术？ doc_introduction_to_global_illumination_comparison">
            <title>我应该使用哪种全局光照技术？</title>
            <paragraph>在确定要使用全局光照（GI）技术时，需要记住以下几个准则：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>性能。</strong> 与半实时或烘焙技术相比，实时 GI 技术通常开销更大。请注意，GI 渲染的大部分开销都花在了 GPU 上，而非 CPU 上。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>视觉效果。</strong> 除了不能达到最佳效果外，实时 GI 技术通常不能提供最佳的视觉输出。尤其是在大多数静态场景中，其中实时 GI 的动态特性不容易被注意到。如果你的目标是最大限度地提高视觉质量，那么烘焙技术通常会看起来更好，并且会减少漏光。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>实时能力。</strong> 一些 GI 技术是完全实时的，而其他技术只是半实时的或根本不是实时的。半实时技术有完全实时技术没有的限制。例如，动态对象可能不会为场景提供自发光照明。非实时技术不支持任何形式的动态 GI ，因此如果需要，必须使用其他技术进行伪造（例如在发射表面附近放置定位灯）。实时能力也会影响 GI 技术在程序化生成关卡上的可行性。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>需要用户工作。</strong> 一些 GI 技术是完全自动的，而另一些则需要用户仔细规划和手动操作。根据你的时间预算，某些 GI 技术可能比其他技术更可取。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>以下是 Godot 中可用的所有全局光照技术的比较：</paragraph>
            <section ids="performance" names="performance 性能">
                <title>性能</title>
                <paragraph>按照性能从最快到最慢的顺序：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>反射探针：</strong></paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>更新模式设置为 <strong>总是</strong> 的反射探针比更新模式设置为 <strong>一次**（默认值）的探针贵得多。适用于使用 **一次</strong> 更新模式时的集成图形。<emphasis>使用转发移动后端时可用。将在更高版本的兼容性后端中提供。</emphasis></paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>LightmapGI:</strong></paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>灯光可以仅使用间接照明进行烘焙，也可以基于每个灯光进行完全烘焙，以进一步提高性能。 也可以使用混合设置（例如具有实时平行光和完全烘焙的位置光）。 可以在烘焙之前启用方向信息，以较小的性能成本（并且以较大的文件大小为代价）改善视觉效果。 适合集成显卡。 <emphasis>使用 Forward Mobile 后端时可用。 将在以后版本的兼容性后端中提供。</emphasis></paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>VoxelGI:</strong></paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>可以调整烘焙的细分数量以平衡性能和质量。 VoxelGI 渲染质量可以在项目设置中调整。 渲染可以选择以半分辨率执行（然后线性缩放）以显着提高性能。 <strong>不可用于</strong> <emphasis>使用 Forward Mobile 或兼容性后端时。</emphasis></paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>屏幕空间间接照明（Screen-space indirect lighting, SSIL）：</strong></paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>以在项目设置中调整 SSIL 质量和模糊通道数量。 默认情况下，SSIL 渲染以一半分辨率执行（然后线性缩放）以确保合理的性能水平。 <strong>不可用于</strong> <emphasis>使用 Forward Mobile 或兼容性后端时。</emphasis></paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>SDFGI:</strong></paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>可以调整级联的数量以平衡性能和质量。 每帧投射的光线数量可以在“项目设置”中调整。 渲染可以选择以半分辨率执行（然后线性缩放）以显着提高性能。 <strong>不可用于</strong> <emphasis>使用 Forward Mobile 或兼容性后端时。</emphasis></paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="visuals" names="visuals">
                <title>Visuals</title>
                <paragraph>为了进行比较，这里有一个未使用全局照明选项的 3D 场景：</paragraph>
                <figure ids="id1">
                    <image alt="没有使用任何形式的全局照明的 3D 场景（只有恒定的环境照明）。 相机附近的盒子和球体都是动态对象。" candidates="{'*': 'tutorials/3d/global_illumination/img/gi_none.webp'}" uri="tutorials/3d/global_illumination/img/gi_none.webp"></image>
                    <caption>没有使用任何形式的全局照明的 3D 场景（只有恒定的环境照明）。 相机附近的盒子和球体都是动态对象。</caption>
                </figure>
                <paragraph>以下是 Godot 的各种全局照明技术的比较：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>VoxelGI：</strong> <image alt="average" candidates="{'*': 'tutorials/3d/global_illumination/img/score_average.webp'}" uri="tutorials/3d/global_illumination/img/score_average.webp"></image> 良好的反射和间接照明，但要小心泄漏。</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>由于其基于体素的性质，如果墙壁和地板太薄，VoxelGI 将出现漏光。 建议确保所有实体表面至少与一个体素一样厚。</paragraph>
                                <paragraph>在倾斜的表面上也可能会看到条纹伪影（streaking artifacts）。 在这种情况下，调整偏置属性或旋转 VoxelGI 节点可以对解决这个问题有帮助。</paragraph>
                                <figure ids="id2">
                                    <image alt="VoxelGI 的实际应用。" candidates="{'*': 'tutorials/3d/global_illumination/img/gi_voxel_gi.webp'}" uri="tutorials/3d/global_illumination/img/gi_voxel_gi.webp"></image>
                                    <caption>VoxelGI 的实际应用。</caption>
                                </figure>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>SDFGI：</strong> <image alt="average" candidates="{'*': 'tutorials/3d/global_illumination/img/score_average.webp'}" uri="tutorials/3d/global_illumination/img/score_average.webp"></image> 良好的反射和间接照明，但要注意泄漏和可见的级联偏移。</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>GI 细节层次（LOD）根据相机与表面之间的距离而变化。</paragraph>
                                <paragraph>通过启用 <strong>使用遮挡（Use Occlusion）</strong> 属性可以显着减少泄漏。 这具有较小的性能成本，但与 VoxelGI 相比，它通常会导致更少的泄漏。</paragraph>
                                <paragraph>当相机快速移动时，可能会看到级联移位（cascade shifts）。 通过调整级联大小或使用雾可以使这种情况变得不那么明显。</paragraph>
                                <figure ids="id3">
                                    <image alt="SDFGI 的实际应用。" candidates="{'*': 'tutorials/3d/global_illumination/img/gi_sdfgi.webp'}" uri="tutorials/3d/global_illumination/img/gi_sdfgi.webp"></image>
                                    <caption>SDFGI 的实际应用。</caption>
                                </figure>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>屏幕空间间接照明 (SSIL)：</strong> <image alt="average" candidates="{'*': 'tutorials/3d/global_illumination/img/score_average.webp'}" uri="tutorials/3d/global_illumination/img/score_average.webp"></image> 良好的 <emphasis>次要</emphasis> 间接照明源，但没有反射。</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>SSIL 旨在用作另一种 GI 技术（例如 VoxelGI、SDFGI 或 LightmapGI）的补充。 SSIL 最适合小规模细节，因为它本身无法为大型结构提供准确的间接照明。 在其他 GI 技术无法捕捉小尺度细节或动态对象的情况下，SSIL 可以提供实时间接照明。 其屏幕空间性质会导致一些伪像，尤其是当对象进入和离开屏幕时。 SSIL 使用最后一帧的颜色（在后期处理之前）工作，这意味着包含自发光贴花和自定义着色器（只要它们出现在屏幕上）。</paragraph>
                                <figure ids="id4">
                                    <image alt="SSIL 的实际应用（没有任何其他 GI 技术）。 注意黄色盒子周围的自发光。" candidates="{'*': 'tutorials/3d/global_illumination/img/gi_ssil_only.webp'}" uri="tutorials/3d/global_illumination/img/gi_ssil_only.webp"></image>
                                    <caption>SSIL 的实际应用（没有任何其他 GI 技术）。 注意黄色盒子周围的自发光。</caption>
                                </figure>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>LightmapGI：</strong> <image alt="good" candidates="{'*': 'tutorials/3d/global_illumination/img/score_good.webp'}" uri="tutorials/3d/global_illumination/img/score_good.webp"></image> 出色的间接照明，良好的反射（可选）。</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>这是唯一可以将光反射次数提高到 2 以上（最多 16 个）的技术。 启用方向信息后，球谐函数 (spherical harmonics, SH) 用于提供模糊反射。</paragraph>
                                <figure ids="id5">
                                    <image alt="LightmapGI 的实际应用。 这里只烘焙间接光照，但也可以烘焙直接光照。" candidates="{'*': 'tutorials/3d/global_illumination/img/gi_lightmap_gi_indirect_only.webp'}" uri="tutorials/3d/global_illumination/img/gi_lightmap_gi_indirect_only.webp"></image>
                                    <caption>LightmapGI 的实际应用。 这里只烘焙间接光照，但也可以烘焙直接光照。</caption>
                                </figure>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>ReflectionProbe：</strong> <image alt="average" candidates="{'*': 'tutorials/3d/global_illumination/img/score_average.webp'}" uri="tutorials/3d/global_illumination/img/score_average.webp"></image> 反射良好，但间接照明较差。</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>可以禁用间接照明，将其设置为整个探针的恒定颜色分布，或者自动从探针的环境中读取（并作为立方体贴图应用）。 这本质上在充当局部环境照明。 反射和间接照明与其他附近的探针混合。</paragraph>
                                <figure ids="id6">
                                    <image alt="ReflectionProbe 的实际应用（没有任何其他 GI 技术）。 注意有反射效果球体。" candidates="{'*': 'tutorials/3d/global_illumination/img/gi_none_reflection_probe.webp'}" uri="tutorials/3d/global_illumination/img/gi_none_reflection_probe.webp"></image>
                                    <caption>ReflectionProbe 的实际应用（没有任何其他 GI 技术）。 注意有反射效果球体。</caption>
                                </figure>
                            </list_item>
                        </bullet_list>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="real-time-ability" names="real-time\ ability 实时能力">
                <title>实时能力</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>VoxelGI：</strong> <image alt="good" candidates="{'*': 'tutorials/3d/global_illumination/img/score_good.webp'}" uri="tutorials/3d/global_illumination/img/score_good.webp"></image> 完全实时。</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>间接关照和反射是完全实时的。动态物体可以接收 GI， <emphasis>并</emphasis> 通过其自发光表面对 GI 做出贡献。自定义着色器也可以准确地发出自己的光。</paragraph>
                                <paragraph>适用于程序生成的关卡 <emphasis>如果它们是提前生成的</emphasis> （而不是在游戏过程中）。 烘焙需要几秒钟或更长时间才能完成，但可以从编辑器和导出的项目中完成。</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>SDFGI：</strong><image alt="average" candidates="{'*': 'tutorials/3d/global_illumination/img/score_average.webp'}" uri="tutorials/3d/global_illumination/img/score_average.webp"></image> 半实时。</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>级联（Cascade）是实时生成的，使得 SDFGI 适用于程序生成的关卡（包括在游戏过程中生成结构时）。</paragraph>
                                <paragraph>动态对象可以 <emphasis>接收</emphasis> GI，但不能 <emphasis>贡献</emphasis> 它。 自发光光线仅在对象进入级联时才会更新，因此它可能仍然适用于缓慢移动的对象。</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>屏幕空间间接光照（SSIL）：</strong><image alt="good" candidates="{'*': 'tutorials/3d/global_illumination/img/score_good.webp'}" uri="tutorials/3d/global_illumination/img/score_good.webp"></image> 完全实时。</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>SSIL 适用于静态和动态灯光。 它还适用于静态和动态遮挡器（包括自发光材质）。</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>LightmapGI：</strong><image alt="bad" candidates="{'*': 'tutorials/3d/global_illumination/img/score_bad.webp'}" uri="tutorials/3d/global_illumination/img/score_bad.webp"></image> 进行了烘焙，因此非实时。</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>间接光照和 SH 反射都是烘焙的，无法在运行时更改。 实时 GI 必须通过 <reference internal="True" refuri="faking_global_illumination#doc-faking-global-illumination"><inline classes="std std-ref">其他方式模拟</inline></reference>，例如实时位置灯光。 动态对象通过光探针接收间接光照，光探针可以自动或由用户手动放置（LightmapProbe 节点）。 对于程序生成的关卡则不可行，因为只能从编辑器中烘焙光照贴图。</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>ReflectionProbe：</strong><image alt="average" candidates="{'*': 'tutorials/3d/global_illumination/img/score_average.webp'}" uri="tutorials/3d/global_illumination/img/score_average.webp"></image> 可选实时。</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>默认情况下，反射会在移动探针时更新。如果更新模式设置为 <strong>始终</strong> （这开销很大），则它们会尽可能频繁地更新。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>间接光照必须由用户手动配置，但它可以在运行时以一个不会导致后台进行大开销计算的方式更改。这使得 ReflectionProbes 可以用于程序化生成的级别。</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="user-work-needed" names="user\ work\ needed 用户干预">
                <title>用户干预</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>VoxelGI：</strong>需要创建若干 VoxelGI 节点并烘焙。</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>为了获得良好的结果，需要正确调整范围。此外，在某些情况下，旋转节点并再次烘焙可以帮助对抗泄漏或条纹伪影。烘焙时间很快——对于中等复杂度的场景，通常低于10秒。</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>SDFGI：</strong>非常少。</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>SDFGI 是全自动的；它只需要在环境资源中启用。所需的唯一手动操作是正确设置 MeshInstances 的烘焙模式属性。不需要创建节点，也不必须烘焙。</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>屏幕空间间接光照（SSIL）：</strong>非常少。</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>SSIL 是全自动的；它只需要在环境资源中启用。不需要创建节点，也不必须烘焙。</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>LightmapGI：</strong>需要设置 UV2 并烘焙。</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>静态网格必须在启用 UV2 和光照贴图生成的情况下重新导入。在专用 GPU 上，由于基于 GPU 的光照贴图烘焙，烘焙时间相对较快——对于中等复杂度的场景，通常低于1分钟。</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>ReflectionProbe：</strong>用户手动放置。</paragraph>
                    </list_item>
                </bullet_list>
                <substitution_definition names="good"><image alt="good" candidates="{'*': 'tutorials/3d/global_illumination/img/score_good.webp'}" uri="tutorials/3d/global_illumination/img/score_good.webp"></image></substitution_definition>
                <substitution_definition names="average"><image alt="average" candidates="{'*': 'tutorials/3d/global_illumination/img/score_average.webp'}" uri="tutorials/3d/global_illumination/img/score_average.webp"></image></substitution_definition>
                <substitution_definition names="bad"><image alt="bad" candidates="{'*': 'tutorials/3d/global_illumination/img/score_bad.webp'}" uri="tutorials/3d/global_illumination/img/score_bad.webp"></image></substitution_definition>
            </section>
            <section ids="summary" names="summary 总结">
                <title>总结</title>
                <paragraph>如果你不确定使用哪种 GI 技术：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>对于桌面游戏，最好先从 <reference internal="True" refuri="using_sdfgi#doc-using-sdfgi"><inline classes="std std-ref">SDFGI</inline></reference> 开始，因为它需要的设置最少。如果需要，稍后转到其他 GI 技术。要提高低端 GPU 和集成图形的性能，请考虑在游戏设置中添加禁用 SDFGI 或 <reference internal="True" refuri="using_voxel_gi#doc-using-voxel-gi"><inline classes="std std-ref">VoxelGI</inline></reference> 的选项。SDFGI 可以在环境资源中禁用，VoxelGI 可以通过隐藏 VoxelGI 节点来禁用。要进一步改善高端设置的视觉效果，请在游戏设置中添加一个启用 SSIL 的选项。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>对于移动游戏，<reference internal="True" refuri="using_lightmap_gi#doc-using-lightmap-gi"><inline classes="std std-ref">LightmapGI</inline></reference> 和 <reference internal="True" refuri="reflection_probes#doc-reflection-probes"><inline classes="std std-ref">ReflectionProbe</inline></reference> 是唯一受支持的选项。另见 <reference internal="True" refid="doc-introduction-to-global-illumination-alternatives"><inline classes="std std-ref">GI 技术的替代方案</inline></reference>。</paragraph>
                    </list_item>
                </bullet_list>
                <seealso>
                    <paragraph>你可以使用 <reference name="全局照明演示项目" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/3d/global_illumination">全局照明演示项目</reference> 比较实际的全局照明技术。</paragraph>
                </seealso>
                <target refid="doc-introduction-to-global-illumination-gi-mode-recommendations"></target>
            </section>
            <section ids="which-global-illumination-mode-should-i-use-on-meshes-and-lights doc-introduction-to-global-illumination-gi-mode-recommendations" names="which\ global\ illumination\ mode\ should\ i\ use\ on\ meshes\ and\ lights? 我应该在网格和灯光上使用哪种全局光照模式？ doc_introduction_to_global_illumination_gi_mode_recommendations">
                <title>我应该在网格和灯光上使用哪种全局光照模式？</title>
                <paragraph>无论使用哪种全局光照技术，都没有普遍 “更好” 的全局光照模式。不过，这里有一些关于网格的建议：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>对于静态级别的几何体，请使用 <strong>静态</strong> 全局光照模式 <emphasis>（默认）</emphasis> 。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>对于小型动态几何体和玩家/敌人，请使用 <strong>禁用</strong> 全局光照模式。由于几何体小于体素 ( voxel) ，小的动态几何体将无法提供大量的间接照明。如果小型动态对象需要间接光照，则可以使用对象的父级 OmniLight3D 或 SpotLight3D 节点对其进行模拟。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>对于 <emphasis>大</emphasis> 动态级别的几何体（例如移动的火车），请使用 <strong>动态</strong> 全局光照模式。请注意，这只对 VoxelGI 有影响，因为 SDFGI 和 LightmapGI 不支持动态对象的全局光照。</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>以下是一些关于光照烘焙模式的建议：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>对于静态级别的光照，请使用 <strong>静态</strong> 烘焙模式。 <strong>静态</strong> 模式也适用于在游戏过程中变化不大的动态灯光，例如闪烁的手电筒。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>对于短暂的动态效果（如武器），请使用 <strong>禁用</strong> 烘焙模式来提高性能。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>对于长期动态效果（如旋转报警灯），请使用 <strong>动态</strong> 烘焙模式来提高质量 <emphasis>（默认值）</emphasis> 。请注意，这只对 VoxelGI 和 SDFGI 有影响，因为 LightmapGI 不支持动态灯光的全局光照。</paragraph>
                    </list_item>
                </bullet_list>
                <target refid="doc-introduction-to-global-illumination-alternatives"></target>
            </section>
        </section>
        <section ids="alternatives-to-gi-techniques doc-introduction-to-global-illumination-alternatives" names="alternatives\ to\ gi\ techniques gi\ 技术的替代方案 doc_introduction_to_global_illumination_alternatives">
            <title>GI 技术的替代方案</title>
            <paragraph>如果上面提到的 GI 技术都不适用，仍然可以<reference internal="True" refuri="faking_global_illumination#doc-faking-global-illumination"><inline classes="std std-ref">通过手动放置附加灯光来模拟 GI</inline></reference>。这需要更多的手动操作，但如果做得好，就可以提供良好的性能和视觉效果。这种方法至今仍在许多现代游戏中使用。</paragraph>
            <paragraph>当在使用LightmapGI无效的情况下（例如程序生成的表面）或者配置的硬件较低，可能需要单独依靠环境照明或稳定的环境光。这可能会导致没有凹凸感的视觉效果，但调整环境光的颜色和天空贴图后仍然可以在大多数情况下能接受的效果。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
