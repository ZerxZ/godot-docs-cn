<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/csg_tools.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-csg-tools"></target>
    <section ids="prototyping-levels-with-csg doc-csg-tools" names="prototyping\ levels\ with\ csg 使用\ csg\ 设计关卡原型 doc_csg_tools">
        <title>使用 CSG 设计关卡原型</title>
        <paragraph>CSG 是 <strong>Constructive Solid Geometry</strong>（构造实体几何）的缩写，是一种将基本形状或自定义网格组合起来以创建更复杂形状的工具。在三维建模软件中，CSG 多被称为“布尔运算符”。</paragraph>
        <paragraph>关卡原型是 Godot 中 CSG 的主要用途之一。该技术允许用户通过组合图元来创建最常见形状的简单版本。可以使用反转图元创建内部环境。</paragraph>
        <note>
            <paragraph>Godot 中的 CSG 节点主要用于原型设计。没有内置的对 UV 贴图或编辑 3D 多边形的支持（尽管拉伸 2D 多边形可以与 CSGPolygon3D 节点一起使用）。</paragraph>
            <paragraph>If you're looking for an easy to use level design tool for a project,
                you may want to use <reference name="Qodot" refuri="https://github.com/QodotPlugin/Qodot">Qodot</reference>
                instead. It lets you design levels using
                <reference name="TrenchBroom" refuri="https://kristianduske.com/trenchbroom/">TrenchBroom</reference> and import
                them in Godot.</paragraph>
        </note>
        <image candidates="{'*': 'tutorials/3d/img/csg.gif'}" uri="tutorials/3d/img/csg.gif"></image>
        <seealso>
            <paragraph>你可以通过 <reference name="CSG 演示项目" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/3d/csg">CSG 演示项目</reference> 来学习如何使用 CSG 节点构建各种形状（例如楼梯或道路）。</paragraph>
        </seealso>
        <section ids="introduction-to-csg-nodes" names="introduction\ to\ csg\ nodes csg\ 节点简介">
            <title>CSG 节点简介</title>
            <paragraph>与 Godot 的其他功能一样，CSG 以节点的形式存在。这些是 CSG 节点：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgbox3d#class-csgbox3d"><inline classes="std std-ref">CSGBox3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgcylinder3d#class-csgcylinder3d"><inline classes="std std-ref">CSGCylinder3D</inline></reference> (也支持锥体)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgsphere3d#class-csgsphere3d"><inline classes="std std-ref">CSGSphere3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgtorus3d#class-csgtorus3d"><inline classes="std std-ref">CSGTorus3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgpolygon3d#class-csgpolygon3d"><inline classes="std std-ref">CSGPolygon3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgmesh3d#class-csgmesh3d"><inline classes="std std-ref">CSGMesh3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgcombiner3d#class-csgcombiner3d"><inline classes="std std-ref">CSGCombiner3D</inline></reference></paragraph>
                </list_item>
            </bullet_list>
            <image candidates="{'*': 'tutorials/3d/img/csg_nodes.png'}" uri="tutorials/3d/img/csg_nodes.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_mesh.png'}" uri="tutorials/3d/img/csg_mesh.png"></image>
            <section ids="csg-tools-features" names="csg\ tools\ features csg\ 工具功能">
                <title>CSG 工具功能</title>
                <paragraph>每个 CSG 节点都支持 3 种布尔运算：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>并集（Union）：</strong>合并两个图元的几何体，删除交叉的几何体。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>交集（Intersection）：</strong>只保留相交的几何体，其余的被删除。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>差集（Subtraction）：</strong>从第一种形状中减去第二种形状，留下一个凹陷的形状。</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/csg_operation_menu.png'}" uri="tutorials/3d/img/csg_operation_menu.png"></image>
                <image candidates="{'*': 'tutorials/3d/img/csg_operation.png'}" uri="tutorials/3d/img/csg_operation.png"></image>
            </section>
            <section ids="csgpolygon" names="csgpolygon">
                <title>CSGPolygon</title>
                <paragraph><reference internal="True" refuri="../../classes/class_csgpolygon3d#class-csgpolygon3d"><inline classes="std std-ref">CSGPolygon3D</inline></reference> 节点通过下列方式沿着以 2D（X、Y 坐标）绘制的多边形挤出：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Depth：</strong>（深度）挤出一定量。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Spin：</strong>（旋转）围绕原点旋转时挤出。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>路径(Path):</strong> 沿路径节点挤出. 此操作通常称为放样.</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/csg_poly_mode.png'}" uri="tutorials/3d/img/csg_poly_mode.png"></image>
                <image candidates="{'*': 'tutorials/3d/img/csg_poly.png'}" uri="tutorials/3d/img/csg_poly.png"></image>
                <note>
                    <paragraph><strong>Path</strong> 模式必须需要一个 <reference internal="True" refuri="../../classes/class_path3d#class-path3d"><inline classes="std std-ref">Path3D</inline></reference> 节点来运行。在 Path 节点中绘制路径，CSGPolygon3D 中的多边形将沿给定路径挤出。</paragraph>
                </note>
            </section>
            <section ids="custom-meshes" names="custom\ meshes 自定义网格">
                <title>自定义网格</title>
                <paragraph>任何网格都可以用于 <reference internal="True" refuri="../../classes/class_csgmesh3d#class-csgmesh3d"><inline classes="std std-ref">CSGMesh3D</inline></reference>，网格可以在其他软件中建模并导入Godot。支持多种材质。对几何体有一些限制：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>它必须被关闭,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>它不能自我相交,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>它不能包含内部面,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>每条边都必须连接到另外两个面.</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/csg_custom_mesh.png'}" uri="tutorials/3d/img/csg_custom_mesh.png"></image>
            </section>
            <section ids="csgcombiner3d" names="csgcombiner3d">
                <title>CSGCombiner3D</title>
                <paragraph><reference internal="True" refuri="../../classes/class_csgcombiner3d#class-csgcombiner3d"><inline classes="std std-ref">CSGCombiner3D</inline></reference> 节点是一个用于组织的空形状，它只会合并子节点。</paragraph>
            </section>
            <section ids="processing-order" names="processing\ order 处理顺序">
                <title>处理顺序</title>
                <paragraph>每个CSG节点将首先按树顺序处理其子节点及其操作：并集、交集或减，并将它们逐一应用于自身。</paragraph>
                <note>
                    <paragraph>为了保证性能, 确保CSG几何体保持相对简单, 因为复杂的网格可能需要一段时间来处理. 如果将对象添加在一起(如桌子和房间对象), 请将它们创建为单独的CSG树. 强制在一棵树中添加太多对象最终会影响性能. 仅在实际需要的地方使用二进制操作.</paragraph>
                </note>
            </section>
        </section>
        <section ids="prototyping-a-level" names="prototyping\ a\ level 原型设计">
            <title>原型设计</title>
            <paragraph>我们将对房间进行原型设计以练习使用CSG工具.</paragraph>
            <tip>
                <paragraph>在<strong>正交</strong>视角下工作，在组合 CSG 形状时可以得到更好的视图。</paragraph>
            </tip>
            <paragraph>我们的关卡将包含以下对象:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>一个房间,</paragraph>
                </list_item>
                <list_item>
                    <paragraph>一张床,</paragraph>
                </list_item>
                <list_item>
                    <paragraph>一盏灯,</paragraph>
                </list_item>
                <list_item>
                    <paragraph>一张桌子,</paragraph>
                </list_item>
                <list_item>
                    <paragraph>一个书架.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>创建一个以 Node3D 节点作为根节点的场景。</paragraph>
            <tip>
                <paragraph>环境的默认光照在某些角度不能提供清晰的阴影。使用 3D 视图菜单中的<strong>显示重复绘制</strong>改变显示模式，或者添加一个 DirectionalLight 节点来帮助你清楚看到。</paragraph>
            </tip>
            <image candidates="{'*': 'tutorials/3d/img/csg_overdraw.png'}" uri="tutorials/3d/img/csg_overdraw.png"></image>
            <paragraph>创建一个 CSGBox3D 并将其命名为 <literal>room</literal>，启用 <strong>Invert Faces</strong>（反转面）并改变你的房间的大小。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_room.png'}" uri="tutorials/3d/img/csg_room.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_room_invert.png'}" uri="tutorials/3d/img/csg_room_invert.png"></image>
            <paragraph>接下来，创建一个 CSGCombiner3D 并将其命名为 <literal>desk</literal> 。</paragraph>
            <paragraph>桌子有一个表面和四条腿:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>在 <strong>Union</strong> 模式下为曲面创建1个 CSGBox3D 子节点，并调整尺寸。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>在 <strong>Union</strong> 模式下为腿部创建4个 CSGBox3D 子节点并调整尺寸。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>调整它们的摆放位置, 就像一张办公桌.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_desk.png'}" uri="tutorials/3d/img/csg_desk.png"></image>
            <note>
                <paragraph>CSGCombiner3D 内的 CSG 节点只会在组合内处理它们的操作。因此，CSGCombiner3D（CSG 组合器）是用来组织 CSG 节点的。</paragraph>
            </note>
            <paragraph>创建一个 CSGCombiner3D，并将其命名为 <literal>bed</literal> 。</paragraph>
            <paragraph>我们的床由三部分组成：床，床垫和枕头。创建一个 CSGBox3D 并调整床的尺寸。再创建一个CSGBox3D，并调整床垫的尺寸。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_bed_mat.png'}" uri="tutorials/3d/img/csg_bed_mat.png"></image>
            <paragraph>我们将创建另一个名为 <literal>pillow</literal> 的 CSGCombiner3D 作为 <literal>bed</literal> 的子节点。场景树应如下所示：</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_bed_tree.png'}" uri="tutorials/3d/img/csg_bed_tree.png"></image>
            <paragraph>我们将在 <strong>Union</strong> 模式下组合 3 个 CSGSphere3D 节点，形成一个枕头。缩放球体的 Y 轴并启用 <strong>Smooth Faces</strong>（平滑面）。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_pillow_smooth.png'}" uri="tutorials/3d/img/csg_pillow_smooth.png"></image>
            <paragraph>选择 <literal>pillow</literal> 节点，并将模式切换到 <strong>Subtraction</strong>；组合后的球体将在床垫上开一个洞。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_pillow_hole.png'}" uri="tutorials/3d/img/csg_pillow_hole.png"></image>
            <paragraph>试着将 <literal>pillow</literal> 节点重新设置为根 <literal>Node3D</literal> 节点的父节点；这个洞会消失。</paragraph>
            <note>
                <paragraph>这是为了说明CSG处理顺序的效果。由于根节点不是CSG节点，因此CSGCombiner3D节点是操作的结束；这展示了使用CSGCombiner3D来组织CSG场景。</paragraph>
            </note>
            <paragraph>观察效果后，撤消重新选择父节点。你搭建的床应如下所示：</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_bed.png'}" uri="tutorials/3d/img/csg_bed.png"></image>
            <paragraph>创建一个CSGCombiner3D，并将其命名为 <literal>lamp</literal> 。</paragraph>
            <paragraph>一盏灯由三部分组成：灯座、灯杆和灯罩。创建一个 CSGCylinder3D，启用 <strong>Cone</strong> 选项并使其成为支架。创建另一个 CSGCylinder3D 并调整尺寸，将其用作灯杆使用。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp_pole_stand.png'}" uri="tutorials/3d/img/csg_lamp_pole_stand.png"></image>
            <paragraph>我们将使用 CSGPolygon3D 来制作灯罩。使用CSGPolygon3D 的 <strong>Spin</strong> 模式，在<strong>前视图</strong>（小键盘 1）下绘制一个<reference name="梯形" refuri="https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BD%A2">梯形</reference><target ids="id1" names="梯形" refuri="https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BD%A2"></target>，这个形状将围绕原点挤出，形成灯罩。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp_spin.png'}" uri="tutorials/3d/img/csg_lamp_spin.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp_polygon.png'}" uri="tutorials/3d/img/csg_lamp_polygon.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp_extrude.png'}" uri="tutorials/3d/img/csg_lamp_extrude.png"></image>
            <paragraph>调整3个部分的位置，使其看起来像一盏灯。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp.png'}" uri="tutorials/3d/img/csg_lamp.png"></image>
            <paragraph>创建一个CSGCombiner3D，并将其命名为 <literal>bookshelf</literal> 。</paragraph>
            <paragraph>我们将为书架使用3个 CSGBox3D 节点。创建一个 CSGBox3D 并调整其大小，这将是书架的尺寸。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_shelf_big.png'}" uri="tutorials/3d/img/csg_shelf_big.png"></image>
            <paragraph>复制 CSGBox3D 并缩短每个轴的尺寸，并将模式改为 <strong>Subtraction</strong>（减去）。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_shelf_subtract.png'}" uri="tutorials/3d/img/csg_shelf_subtract.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_shelf_subtract_menu.png'}" uri="tutorials/3d/img/csg_shelf_subtract_menu.png"></image>
            <paragraph>你几乎已经建立了一个架子。再创建一个 CSGBox3D，把架子分成两层。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_shelf.png'}" uri="tutorials/3d/img/csg_shelf.png"></image>
            <paragraph>根据你的喜好将你的家具放在房间里，你的场景应该是这样的：</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_room_result.png'}" uri="tutorials/3d/img/csg_room_result.png"></image>
            <paragraph>你已经成功地用 Godot 中的 CSG 工具制作了一个房间关卡的原型。CSG工具可以用于设计各种类型的关卡，如迷宫或城市；在设计游戏时探究它的局限性。</paragraph>
        </section>
        <section ids="using-prototype-textures" names="using\ prototype\ textures 使用原型纹理">
            <title>使用原型纹理</title>
            <paragraph>Godot的 <reference internal="True" refuri="standard_material_3d#doc-standard-material-3d"><inline classes="std std-ref">标准 3D 材质与 ORM 3D 材质</inline></reference> 支持 <emphasis>triplanar mapping</emphasis> （三平面映射）, 可用于自动将纹理应用到任意对象而不失真。使用 CSG 时这很方便，因为 Godot 尚不支持在 CSG 节点上编辑 UV 贴图。三平面映射相对较慢，这通常限制其在地形等有机表面上的使用。尽管如此，在制作原型时，它仍可用于快速将纹理应用到基于 CSG 的关卡。</paragraph>
            <note>
                <paragraph>如果你需要一些原型的图片,Kenney做了一套 <reference name="CC0授权的原型图片" refuri="https://kenney.nl/assets/prototype-textures">CC0授权的原型图片</reference>.</paragraph>
            </note>
            <paragraph>有两种方法可以将材质应用到CSG节点:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>将其作为材质覆盖应用到 CSGCombiner3D 节点上（在检查器中的 <strong>Geometry &gt; Material Override</strong> ），这将自动影响它的子节点，但能改变单个子节点的材质。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>将材质应用于单个节点( <strong>材质</strong> 在(属性)检查器中). 这样, 每个CSG节点都可以有自己的外观. 减去CSG节点将把它们的材质应用到 "digging" 到的节点上.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>要将三平面映射应用到 CSG 节点，请选中它，转到“检查器”，单击 <strong>Material Override</strong>（材质覆盖）旁的 <strong>[空]</strong> 字样（如果是单独的 CSG 节点则为 <strong>Material</strong>）。选择<strong>新建 SpatialMaterial3D</strong>。点击刚创建出来的材质图标来进行编辑。展开 <strong>Albedo</strong> 部分，为 <strong>Texture</strong> 属性加载一张纹理。现在再展开 <strong>Uv1</strong> 部分，勾选 <strong>Triplanar</strong>。可以用上面的 <strong>Scale</strong> 和 <strong>Offset</strong> 属性来调整纹理在各个方向上的缩放和偏移量。<strong>Scale</strong> 属性越大，纹理重复得越多。</paragraph>
            <tip>
                <paragraph>你可以复制一个 SpatialMaterial3D，以便在 CSG 节点中重复使用它。要做到这一点，在（属性）检查器中点击材质属性旁边的下拉箭头，然后选择 <strong>复制</strong> 。 要粘贴它，请选择要应用该材质的节点，单击其材质属性旁边的下拉箭头，然后选择 <strong>粘贴</strong> 。</paragraph>
            </tip>
        </section>
        <section ids="exporting-as-gltf" names="exporting\ as\ gltf 导出为\ gltf">
            <title>导出为 glTF</title>
            <paragraph>使用 CSG 绘制关卡，然后将其导出为 3D 模型，以导入到 3D 建模软件中，这是非常有用的工作流程。你可以通过选择 <strong>场景 &gt; 导出为...&gt; glTF 2.0 场景</strong> 来执行此操作。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/export_as_gltf.webp'}" uri="tutorials/3d/img/export_as_gltf.webp"></image>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
