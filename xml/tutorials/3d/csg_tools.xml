<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/csg_tools.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-csg-tools"></target>
    <section ids="prototyping-levels-with-csg doc-csg-tools" names="prototyping\ levels\ with\ csg doc_csg_tools">
        <title>Prototyping levels with CSG</title>
        <paragraph>CSG stands for <strong>Constructive Solid Geometry</strong>, and is a tool to combine basic
            shapes or custom meshes to create more complex shapes. In 3D modeling software,
            CSG is mostly known as "Boolean Operators".</paragraph>
        <paragraph>Level prototyping is one of the main uses of CSG in Godot. This technique allows
            users to create the most common shapes by combining primitives.
            Interior environments can be created by using inverted primitives.</paragraph>
        <note>
            <paragraph>The CSG nodes in Godot are mainly intended for prototyping. There is
                no built-in support for UV mapping or editing 3D polygons (though
                extruded 2D polygons can be used with the CSGPolygon3D node).</paragraph>
            <paragraph>If you're looking for an easy to use level design tool for a project,
                you may want to use <reference name="FuncGodot" refuri="https://github.com/func-godot/func_godot_plugin">FuncGodot</reference>
                or <reference name="Cyclops Level Builder" refuri="https://github.com/blackears/cyclopsLevelBuilder">Cyclops Level Builder</reference>
                instead.</paragraph>
        </note>
        <video_node align="default" alt="CSG being used to subtract a torus shape from a box" autoplay="True" caption="" controls="True" controlslist="" figwidth="" height="" klass="" loop="True" muted="True" playsinline="False" poster="" preload="auto" sources="['tutorials/3d/video/csg_tools.webm',\ 'video/webm',\ False]" width="">
        </video_node>
        <seealso>
            <paragraph>You can check how to use CSG nodes to build various shapes (such as stairs or roads) using the
                <reference name="Constructive Solid Geometry demo project" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/3d/csg">Constructive Solid Geometry demo project</reference>.</paragraph>
        </seealso>
        <section ids="introduction-to-csg-nodes" names="introduction\ to\ csg\ nodes">
            <title>Introduction to CSG nodes</title>
            <paragraph>Like other features of Godot, CSG is supported in the form of nodes. These are
                the CSG nodes:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgbox3d#class-csgbox3d"><inline classes="std std-ref">CSGBox3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgcylinder3d#class-csgcylinder3d"><inline classes="std std-ref">CSGCylinder3D</inline></reference> (also supports cone)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgsphere3d#class-csgsphere3d"><inline classes="std std-ref">CSGSphere3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgtorus3d#class-csgtorus3d"><inline classes="std std-ref">CSGTorus3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgpolygon3d#class-csgpolygon3d"><inline classes="std std-ref">CSGPolygon3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgmesh3d#class-csgmesh3d"><inline classes="std std-ref">CSGMesh3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgcombiner3d#class-csgcombiner3d"><inline classes="std std-ref">CSGCombiner3D</inline></reference></paragraph>
                </list_item>
            </bullet_list>
            <image candidates="{'*': 'tutorials/3d/img/csg_nodes.png'}" original_uri="img/csg_nodes.png" uri="tutorials/3d/img/csg_nodes.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_mesh.png'}" original_uri="img/csg_mesh.png" uri="tutorials/3d/img/csg_mesh.png"></image>
            <section ids="csg-tools-features" names="csg\ tools\ features">
                <title>CSG tools features</title>
                <paragraph>Every CSG node supports 3 kinds of boolean operations:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Union:</strong> Geometry of both primitives is merged, intersecting geometry
                            is removed.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Intersection:</strong> Only intersecting geometry remains, the rest is removed.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Subtraction:</strong> The second shape is subtracted from the first, leaving a dent
                            with its shape.</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/csg_operation_menu.png'}" original_uri="img/csg_operation_menu.png" uri="tutorials/3d/img/csg_operation_menu.png"></image>
                <image candidates="{'*': 'tutorials/3d/img/csg_operation.png'}" original_uri="img/csg_operation.png" uri="tutorials/3d/img/csg_operation.png"></image>
            </section>
            <section ids="csgpolygon" names="csgpolygon">
                <title>CSGPolygon</title>
                <paragraph>The <reference internal="True" refuri="../../classes/class_csgpolygon3d#class-csgpolygon3d"><inline classes="std std-ref">CSGPolygon3D</inline></reference> node extrude along a Polygon drawn in
                    2D (in X, Y coordinates) in the following ways:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Depth:</strong> Extruded back a given amount.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Spin:</strong> Extruded while spinning around its origin.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Path:</strong> Extruded along a Path node. This operation is commonly called
                            lofting.</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/csg_poly_mode.png'}" original_uri="img/csg_poly_mode.png" uri="tutorials/3d/img/csg_poly_mode.png"></image>
                <image candidates="{'*': 'tutorials/3d/img/csg_poly.png'}" original_uri="img/csg_poly.png" uri="tutorials/3d/img/csg_poly.png"></image>
                <note>
                    <paragraph>The <strong>Path</strong> mode must be provided with a <reference internal="True" refuri="../../classes/class_path3d#class-path3d"><inline classes="std std-ref">Path3D</inline></reference>
                        node to work. In the Path node, draw the path and the polygon in
                        CSGPolygon3D will extrude along the given path.</paragraph>
                </note>
            </section>
            <section ids="custom-meshes" names="custom\ meshes">
                <title>Custom meshes</title>
                <paragraph>Custom meshes can be used for <reference internal="True" refuri="../../classes/class_csgmesh3d#class-csgmesh3d"><inline classes="std std-ref">CSGMesh3D</inline></reference> as long as the
                    mesh is <emphasis>manifold</emphasis>. The mesh can be modeled in other software and imported into
                    Godot. Multiple materials are supported.</paragraph>
                <paragraph>For a mesh to be used as a CSG mesh, it is required to:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>be closed</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>have each edge connect to only two faces</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>have volume</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>And it is recommended to avoid:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>negative volume</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>self-intersection</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>interior faces</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Godot uses the <reference name="manifold" refuri="https://github.com/elalish/manifold">manifold</reference> library to
                    implement CSG meshes. The technical definition of "manifold" used by Godot is
                    the following, adapted from that library's <reference name='definition of "manifold"' refuri="https://github.com/elalish/manifold/wiki/Manifold-Library#manifoldness-definition">definition of "manifold"</reference>:</paragraph>
                <block_quote>
                    <paragraph>Every edge of every triangle must contain the same two vertices (by index) as
                        exactly one other triangle edge, and the start and end vertices must switch
                        places between these two edges. The triangle vertices must appear in clockwise
                        order when viewed from the outside of the Godot Engine manifold mesh.</paragraph>
                </block_quote>
                <image candidates="{'*': 'tutorials/3d/img/csg_custom_mesh.png'}" original_uri="img/csg_custom_mesh.png" uri="tutorials/3d/img/csg_custom_mesh.png"></image>
                <section ids="making-an-existing-mesh-manifold-with-blender" names="making\ an\ existing\ mesh\ manifold\ with\ blender">
                    <title>Making an existing mesh manifold with Blender</title>
                    <comment xml:space="preserve">UPDATE: This relies on a specific Blender addon. If it becomes unsupported,</comment>
                    <comment xml:space="preserve">we can remove this section.</comment>
                    <paragraph>If you have an existing mesh that is not already manifold, you can make it
                        manifold using Blender.</paragraph>
                    <paragraph>In Blender, install and enable the
                        <reference name="3D Print Toolbox" refuri="https://extensions.blender.org/add-ons/print3d-toolbox/">3D Print Toolbox</reference><target ids="d-print-toolbox" names="3d\ print\ toolbox" refuri="https://extensions.blender.org/add-ons/print3d-toolbox/"></target>
                        addon.</paragraph>
                    <paragraph>Select the mesh you want to make manifold. Open the sidebar by clicking on the arrow:</paragraph>
                    <image candidates="{'*': 'tutorials/3d/img/csg_manifold_step_1.webp'}" original_uri="img/csg_manifold_step_1.webp" uri="tutorials/3d/img/csg_manifold_step_1.webp"></image>
                    <paragraph>In the <strong>3D Print</strong> tab, under <strong>Clean Up</strong>, click the <strong>Make Manifold</strong> button:</paragraph>
                    <image candidates="{'*': 'tutorials/3d/img/csg_manifold_step_2.webp'}" original_uri="img/csg_manifold_step_2.webp" uri="tutorials/3d/img/csg_manifold_step_2.webp"></image>
                    <paragraph>The mesh should now be manifold, and can be used as a custom mesh.</paragraph>
                </section>
            </section>
            <section ids="csgcombiner3d" names="csgcombiner3d">
                <title>CSGCombiner3D</title>
                <paragraph>The <reference internal="True" refuri="../../classes/class_csgcombiner3d#class-csgcombiner3d"><inline classes="std std-ref">CSGCombiner3D</inline></reference> node is an empty shape used for
                    organization. It will only combine children nodes.</paragraph>
            </section>
            <section ids="processing-order" names="processing\ order">
                <title>Processing order</title>
                <paragraph>Every CSG node will first process its children nodes and their operations:
                    union, intersection, or subtraction, in tree order, and apply them to itself one
                    after the other.</paragraph>
                <note>
                    <paragraph>In the interest of performance, make sure CSG geometry remains
                        relatively simple, as complex meshes can take a while to process.
                        If adding objects together (such as table and room objects), create
                        them as separate CSG trees. Forcing too many objects in a single tree
                        will eventually start affecting performance.
                        Only use binary operations where you actually need them.</paragraph>
                </note>
            </section>
        </section>
        <section ids="prototyping-a-level" names="prototyping\ a\ level">
            <title>Prototyping a level</title>
            <paragraph>We will prototype a room to practice the use of CSG tools.</paragraph>
            <tip>
                <paragraph>Working in <strong>Orthogonal</strong> projection gives a better view when combining
                    the CSG shapes.</paragraph>
            </tip>
            <paragraph>Our level will contain these objects:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>a room,</paragraph>
                </list_item>
                <list_item>
                    <paragraph>a bed,</paragraph>
                </list_item>
                <list_item>
                    <paragraph>a lamp,</paragraph>
                </list_item>
                <list_item>
                    <paragraph>a desk,</paragraph>
                </list_item>
                <list_item>
                    <paragraph>a bookshelf.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Create a scene with a Node3D node as root node.</paragraph>
            <tip>
                <paragraph>The default lighting of the environment doesn't provide clear shading
                    at some angles. Change the display mode using <strong>Display Overdraw</strong> in
                    the 3D viewport menu, or add a DirectionalLight node to help you see
                    clearly.</paragraph>
            </tip>
            <image candidates="{'*': 'tutorials/3d/img/csg_overdraw.png'}" original_uri="img/csg_overdraw.png" uri="tutorials/3d/img/csg_overdraw.png"></image>
            <paragraph>Create a CSGBox3D and name it <literal>room</literal>, enable <strong>Invert Faces</strong> and change the
                dimensions of your room.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_room.png'}" original_uri="img/csg_room.png" uri="tutorials/3d/img/csg_room.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_room_invert.png'}" original_uri="img/csg_room_invert.png" uri="tutorials/3d/img/csg_room_invert.png"></image>
            <paragraph>Next, create a CSGCombiner3D and name it <literal>desk</literal>.</paragraph>
            <paragraph>A desk has one surface and 4 legs:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Create 1 CSGBox3D children node in <strong>Union</strong> mode for the surface
                        and adjust the dimensions.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Create 4 CSGBox3D children nodes in <strong>Union</strong> mode for the legs
                        and adjust the dimensions.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Adjust their placement to resemble a desk.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_desk.png'}" original_uri="img/csg_desk.png" uri="tutorials/3d/img/csg_desk.png"></image>
            <note>
                <paragraph>CSG nodes inside a CSGCombiner3D will only process their operation
                    within the combiner. Therefore, CSGCombiner3Ds are used to organize
                    CSG nodes.</paragraph>
            </note>
            <paragraph>Create a CSGCombiner3D and name it <literal>bed</literal>.</paragraph>
            <paragraph>Our bed consists of 3 parts: the bed, the mattress and a pillow. Create a CSGBox3D
                and adjust its dimension for the bed. Create another CSGBox3D and adjust its
                dimension for the mattress.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_bed_mat.png'}" original_uri="img/csg_bed_mat.png" uri="tutorials/3d/img/csg_bed_mat.png"></image>
            <paragraph>We will create another CSGCombiner3D named <literal>pillow</literal> as the child of  <literal>bed</literal>.
                The scene tree should look like this:</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_bed_tree.png'}" original_uri="img/csg_bed_tree.png" uri="tutorials/3d/img/csg_bed_tree.png"></image>
            <paragraph>We will combine 3 CSGSphere3D nodes in <strong>Union</strong> mode to form a pillow. Scale the
                Y axis of the spheres and enable <strong>Smooth Faces</strong>.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_pillow_smooth.png'}" original_uri="img/csg_pillow_smooth.png" uri="tutorials/3d/img/csg_pillow_smooth.png"></image>
            <paragraph>Select the <literal>pillow</literal> node and switch the mode to <strong>Subtraction</strong>; the combined
                spheres will cut a hole into the mattress.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_pillow_hole.png'}" original_uri="img/csg_pillow_hole.png" uri="tutorials/3d/img/csg_pillow_hole.png"></image>
            <paragraph>Try to re-parent the <literal>pillow</literal> node to the root <literal>Node3D</literal> node; the hole will
                disappear.</paragraph>
            <note>
                <paragraph>This is to illustrate the effect of CSG processing order.
                    Since the root node is not a CSG node, the CSGCombiner3D nodes are
                    the end of the operations; this shows the use of CSGCombiner3D to
                    organize the CSG scene.</paragraph>
            </note>
            <paragraph>Undo the re-parent after observing the effect. The bed you've built should look
                like this:</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_bed.png'}" original_uri="img/csg_bed.png" uri="tutorials/3d/img/csg_bed.png"></image>
            <paragraph>Create a CSGCombiner3D and name it <literal>lamp</literal>.</paragraph>
            <paragraph>A lamp consists of 3 parts: the stand, the pole and the lampshade.
                Create a CSGCylinder3D, enable the <strong>Cone</strong> option and make it the stand. Create
                another CSGCylinder3D and adjust the dimensions to use it as a pole.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp_pole_stand.png'}" original_uri="img/csg_lamp_pole_stand.png" uri="tutorials/3d/img/csg_lamp_pole_stand.png"></image>
            <paragraph>We will use a CSGPolygon3D for the lampshade. Use the <strong>Spin</strong> mode for the
                CSGPolygon3D and draw a <reference name="trapezoid" refuri="https://en.wikipedia.org/wiki/Trapezoid">trapezoid</reference><target ids="trapezoid" names="trapezoid" refuri="https://en.wikipedia.org/wiki/Trapezoid"></target>
                while in <strong>Front View</strong> (numeric keypad 1); this shape will extrude around the
                origin and form the lampshade.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp_spin.png'}" original_uri="img/csg_lamp_spin.png" uri="tutorials/3d/img/csg_lamp_spin.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp_polygon.png'}" original_uri="img/csg_lamp_polygon.png" uri="tutorials/3d/img/csg_lamp_polygon.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp_extrude.png'}" original_uri="img/csg_lamp_extrude.png" uri="tutorials/3d/img/csg_lamp_extrude.png"></image>
            <paragraph>Adjust the placement of the 3 parts to make it look like a lamp.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp.png'}" original_uri="img/csg_lamp.png" uri="tutorials/3d/img/csg_lamp.png"></image>
            <paragraph>Create a CSGCombiner3D and name it <literal>bookshelf</literal>.</paragraph>
            <paragraph>We will use 3 CSGBox3D nodes for the bookshelf. Create a CSGBox3D and adjust its
                dimensions; this will be the size of the bookshelf.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_shelf_big.png'}" original_uri="img/csg_shelf_big.png" uri="tutorials/3d/img/csg_shelf_big.png"></image>
            <paragraph>Duplicate the CSGBox3D and shorten the dimensions of each axis and change the mode
                to <strong>Subtraction</strong>.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_shelf_subtract.png'}" original_uri="img/csg_shelf_subtract.png" uri="tutorials/3d/img/csg_shelf_subtract.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_shelf_subtract_menu.png'}" original_uri="img/csg_shelf_subtract_menu.png" uri="tutorials/3d/img/csg_shelf_subtract_menu.png"></image>
            <paragraph>You've almost built a shelf. Create one more CSGBox3D for dividing the shelf into
                two levels.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_shelf.png'}" original_uri="img/csg_shelf.png" uri="tutorials/3d/img/csg_shelf.png"></image>
            <paragraph>Position your furniture in your room as you like and your scene should look
                this:</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_room_result.png'}" original_uri="img/csg_room_result.png" uri="tutorials/3d/img/csg_room_result.png"></image>
            <paragraph>You've successfully prototyped a room level with the CSG tools in Godot.
                CSG tools can be used for designing all kinds of levels, such as a maze
                or a city; explore its limitations when designing your game.</paragraph>
        </section>
        <section ids="using-prototype-textures" names="using\ prototype\ textures">
            <title>Using prototype textures</title>
            <paragraph>Godot's <reference internal="True" refuri="standard_material_3d#doc-standard-material-3d"><inline classes="std std-ref">Standard Material 3D and ORM Material 3D</inline></reference> supports <emphasis>triplanar mapping</emphasis>, which can be
                used to automatically apply a texture to arbitrary objects without distortion.
                This is handy when using CSG as Godot doesn't support editing UV maps on CSG
                nodes yet. Triplanar mapping is relatively slow, which usually restricts its
                usage to organic surfaces like terrain. Still, when prototyping, it can be used
                to quickly apply textures to CSG-based levels.</paragraph>
            <note>
                <paragraph>If you need some textures for prototyping, Kenney made a
                    <reference name="set of CC0-licensed prototype textures" refuri="https://kenney.nl/assets/prototype-textures">set of CC0-licensed prototype textures</reference>.</paragraph>
            </note>
            <paragraph>There are two ways to apply a material to a CSG node:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Applying it to a CSGCombiner3D node as a material override
                        (<strong>Geometry &gt; Material Override</strong> in the Inspector). This will affect its
                        children automatically, but will make it impossible to change the material in
                        individual children.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Applying a material to individual nodes (<strong>Material</strong> in the Inspector). This
                        way, each CSG node can have its own appearance. Subtractive CSG nodes will
                        apply their material to the nodes they're "digging" into.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>To apply triplanar mapping to a CSG node, select it, go to the Inspector, click
                the <strong>[empty]</strong> text next to <strong>Material Override</strong> (or <strong>Material</strong> for
                individual CSG nodes). Choose <strong>New StandardMaterial3D</strong>. Click the newly created
                material's icon to edit it. Unfold the <strong>Albedo</strong> section and load a texture
                into the <strong>Texture</strong> property. Now, unfold the <strong>Uv1</strong> section and check
                <strong>Triplanar</strong>. You can change the texture offset and scale on each axis by
                playing with the <strong>Scale</strong> and <strong>Offset</strong> properties just above. Higher values
                in the <strong>Scale</strong> property will cause the texture to repeat more often.</paragraph>
            <tip>
                <paragraph>You can copy a StandardMaterial3D to reuse it across CSG nodes. To do so,
                    click the dropdown arrow next to a material property in the Inspector
                    and choose <strong>Copy</strong>. To paste it, select the node you'd like to apply
                    the material onto, click the dropdown arrow next to its material
                    property then choose <strong>Paste</strong>.</paragraph>
            </tip>
            <target refid="doc-csg-tools-converting-to-mesh-instance-3d"></target>
        </section>
        <section ids="converting-to-meshinstance3d doc-csg-tools-converting-to-mesh-instance-3d" names="converting\ to\ meshinstance3d doc_csg_tools_converting_to_mesh_instance_3d">
            <title>Converting to MeshInstance3D</title>
            <paragraph>Since Godot 4.4, you can convert a CSG node and its children to a <reference internal="True" refuri="../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> node.</paragraph>
            <paragraph>This has several benefits:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Bake lightmaps, since UV2 can be generated on a MeshInstance3D.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Bake occlusion culling, since the occlusion culling bake process only takes MeshInstance3D into account.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Faster loading times, since the CSG mesh no longer needs to be rebuilt when the scene loads.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Better performance when updating the node's transform if using the mesh within another CSG node.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>To convert a CSG node to a MeshInstance3D node, select it, then choose
                <strong>CSG &gt; Bake Mesh Instance</strong> in the toolbar. The MeshInstance3D node
                will be created as a sibling. Note that the CSG node that was used for baking is <strong>not</strong> hidden
                automatically, so remember to hide it to prevent its geometry from overlapping with the newly created
                MeshInstance3D.</paragraph>
            <paragraph>You can also create a trimesh collision shape using <strong>CSG &gt; Bake Collision Shape</strong>.
                The generated <reference internal="True" refuri="../../classes/class_collisionshape3d#class-collisionshape3d"><inline classes="std std-ref">CollisionShape3D</inline></reference> node must be a child of a <reference internal="True" refuri="../../classes/class_staticbody3d#class-staticbody3d"><inline classes="std std-ref">StaticBody3D</inline></reference>
                or <reference internal="True" refuri="../../classes/class_animatablebody3d#class-animatablebody3d"><inline classes="std std-ref">AnimatableBody3D</inline></reference> node to be effective.</paragraph>
            <tip>
                <paragraph>Remember to keep the original CSG node in the scene tree, so that you can
                    perform changes to the geometry later if needed. To make changes to the
                    geometry, remove the MeshInstance3D node and make the root CSG node visible
                    again.</paragraph>
            </tip>
        </section>
        <section ids="exporting-as-gltf" names="exporting\ as\ gltf">
            <title>Exporting as glTF</title>
            <paragraph>It can be useful to block out a level using CSG, then export it as a 3d model, to
                import into 3D modeling software. You can do this by selecting <strong>Scene &gt; Export As... &gt;
                    glTF 2.0 Scene</strong>.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/export_as_gltf.webp'}" original_uri="img/export_as_gltf.webp" uri="tutorials/3d/img/export_as_gltf.webp"></image>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
