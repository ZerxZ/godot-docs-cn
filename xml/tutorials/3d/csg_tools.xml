<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/csg_tools.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-csg-tools"></target>
    <section ids="prototyping-levels-with-csg doc-csg-tools" names="prototyping\ levels\ with\ csg 使用\ csg\ 设计关卡原型 doc_csg_tools">
        <title>使用 CSG 设计关卡原型</title>
        <paragraph>CSG 是 <strong>Constructive Solid Geometry</strong>（构造实体几何）的缩写，是一种将基本形状或自定义网格组合起来以创建更复杂形状的工具。在三维建模软件中，CSG 多被称为“布尔运算符”。</paragraph>
        <paragraph>关卡原型是 Godot 中 CSG 的主要用途之一。该技术允许用户通过组合图元来创建最常见形状的简单版本。可以使用反转图元创建内部环境。</paragraph>
        <note>
            <paragraph>The CSG nodes in Godot are mainly intended for prototyping. There is
                no built-in support for UV mapping or editing 3D polygons (though
                extruded 2D polygons can be used with the CSGPolygon3D node). In
                addition CSG can't reliably create meshes made up of multiple nodes
                without holes.</paragraph>
            <paragraph>If you're looking for an easy to use level design tool for a project,
                you may want to use <reference name="FuncGodot" refuri="https://github.com/func-godot/func_godot_plugin">FuncGodot</reference>
                or <reference name="Cyclops Level Builder" refuri="https://github.com/blackears/cyclopsLevelBuilder">Cyclops Level Builder</reference>
                instead.</paragraph>
        </note>
        <video_node alt="CSG being used to subtract a torus shape from a box" autoplay="True" controls="True" height="" klass="" loop="True" muted="True" poster="" preload="auto" sources="['tutorials/3d/video/csg_tools.webm',\ 'video/webm',\ False]" width="">
        </video_node>
        <seealso>
            <paragraph>你可以通过 <reference name="CSG 演示项目" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/3d/csg">CSG 演示项目</reference> 来学习如何使用 CSG 节点构建各种形状（例如楼梯或道路）。</paragraph>
        </seealso>
        <section ids="introduction-to-csg-nodes" names="introduction\ to\ csg\ nodes csg\ 节点简介">
            <title>CSG 节点简介</title>
            <paragraph>与 Godot 的其他功能一样，CSG 以节点的形式存在。这些是 CSG 节点：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgbox3d#class-csgbox3d"><inline classes="std std-ref">CSGBox3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgcylinder3d#class-csgcylinder3d"><inline classes="std std-ref">CSGCylinder3D</inline></reference> (也支持锥体)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgsphere3d#class-csgsphere3d"><inline classes="std std-ref">CSGSphere3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgtorus3d#class-csgtorus3d"><inline classes="std std-ref">CSGTorus3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgpolygon3d#class-csgpolygon3d"><inline classes="std std-ref">CSGPolygon3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgmesh3d#class-csgmesh3d"><inline classes="std std-ref">CSGMesh3D</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_csgcombiner3d#class-csgcombiner3d"><inline classes="std std-ref">CSGCombiner3D</inline></reference></paragraph>
                </list_item>
            </bullet_list>
            <image candidates="{'*': 'tutorials/3d/img/csg_nodes.png'}" uri="tutorials/3d/img/csg_nodes.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_mesh.png'}" uri="tutorials/3d/img/csg_mesh.png"></image>
            <section ids="csg-tools-features" names="csg\ tools\ features csg\ 工具功能">
                <title>CSG 工具功能</title>
                <paragraph>每个 CSG 节点都支持 3 种布尔运算：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>并集（Union）：</strong>合并两个图元的几何体，删除交叉的几何体。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>交集（Intersection）：</strong>只保留相交的几何体，其余的被删除。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>差集（Subtraction）：</strong>从第一种形状中减去第二种形状，留下一个凹陷的形状。</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/csg_operation_menu.png'}" uri="tutorials/3d/img/csg_operation_menu.png"></image>
                <image candidates="{'*': 'tutorials/3d/img/csg_operation.png'}" uri="tutorials/3d/img/csg_operation.png"></image>
            </section>
            <section ids="csgpolygon" names="csgpolygon">
                <title>CSGPolygon</title>
                <paragraph><reference internal="True" refuri="../../classes/class_csgpolygon3d#class-csgpolygon3d"><inline classes="std std-ref">CSGPolygon3D</inline></reference> 节点通过下列方式沿着以 2D（X、Y 坐标）绘制的多边形挤出：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Depth：</strong>（深度）挤出一定量。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Spin：</strong>（旋转）围绕原点旋转时挤出。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>路径(Path):</strong> 沿路径节点挤出. 此操作通常称为放样.</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/csg_poly_mode.png'}" uri="tutorials/3d/img/csg_poly_mode.png"></image>
                <image candidates="{'*': 'tutorials/3d/img/csg_poly.png'}" uri="tutorials/3d/img/csg_poly.png"></image>
                <note>
                    <paragraph><strong>Path</strong> 模式必须需要一个 <reference internal="True" refuri="../../classes/class_path3d#class-path3d"><inline classes="std std-ref">Path3D</inline></reference> 节点来运行。在 Path 节点中绘制路径，CSGPolygon3D 中的多边形将沿给定路径挤出。</paragraph>
                </note>
            </section>
            <section ids="custom-meshes" names="custom\ meshes 自定义网格">
                <title>自定义网格</title>
                <paragraph>任何网格都可以用于 <reference internal="True" refuri="../../classes/class_csgmesh3d#class-csgmesh3d"><inline classes="std std-ref">CSGMesh3D</inline></reference>，网格可以在其他软件中建模并导入Godot。支持多种材质。对几何体有一些限制：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>它必须被关闭,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>它不能自我相交,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>它不能包含内部面,</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>每条边都必须连接到另外两个面.</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/csg_custom_mesh.png'}" uri="tutorials/3d/img/csg_custom_mesh.png"></image>
            </section>
            <section ids="csgcombiner3d" names="csgcombiner3d">
                <title>CSGCombiner3D</title>
                <paragraph><reference internal="True" refuri="../../classes/class_csgcombiner3d#class-csgcombiner3d"><inline classes="std std-ref">CSGCombiner3D</inline></reference> 节点是一个用于组织的空形状，它只会合并子节点。</paragraph>
            </section>
            <section ids="processing-order" names="processing\ order 处理顺序">
                <title>处理顺序</title>
                <paragraph>每个CSG节点将首先按树顺序处理其子节点及其操作：并集、交集或减，并将它们逐一应用于自身。</paragraph>
                <note>
                    <paragraph>为了保证性能, 确保CSG几何体保持相对简单, 因为复杂的网格可能需要一段时间来处理. 如果将对象添加在一起(如桌子和房间对象), 请将它们创建为单独的CSG树. 强制在一棵树中添加太多对象最终会影响性能. 仅在实际需要的地方使用二进制操作.</paragraph>
                </note>
            </section>
        </section>
        <section ids="prototyping-a-level" names="prototyping\ a\ level 原型设计">
            <title>原型设计</title>
            <paragraph>我们将对房间进行原型设计以练习使用CSG工具.</paragraph>
            <tip>
                <paragraph>在<strong>正交</strong>视角下工作，在组合 CSG 形状时可以得到更好的视图。</paragraph>
            </tip>
            <paragraph>我们的关卡将包含以下对象:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>一个房间,</paragraph>
                </list_item>
                <list_item>
                    <paragraph>一张床,</paragraph>
                </list_item>
                <list_item>
                    <paragraph>一盏灯,</paragraph>
                </list_item>
                <list_item>
                    <paragraph>一张桌子,</paragraph>
                </list_item>
                <list_item>
                    <paragraph>一个书架.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>创建一个以 Node3D 节点作为根节点的场景。</paragraph>
            <tip>
                <paragraph>环境的默认光照在某些角度不能提供清晰的阴影。使用 3D 视图菜单中的<strong>显示重复绘制</strong>改变显示模式，或者添加一个 DirectionalLight 节点来帮助你清楚看到。</paragraph>
            </tip>
            <image candidates="{'*': 'tutorials/3d/img/csg_overdraw.png'}" uri="tutorials/3d/img/csg_overdraw.png"></image>
            <paragraph>创建一个 CSGBox3D 并将其命名为 <literal>room</literal>，启用 <strong>Invert Faces</strong>（反转面）并改变你的房间的大小。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_room.png'}" uri="tutorials/3d/img/csg_room.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_room_invert.png'}" uri="tutorials/3d/img/csg_room_invert.png"></image>
            <paragraph>接下来，创建一个 CSGCombiner3D 并将其命名为 <literal>desk</literal> 。</paragraph>
            <paragraph>桌子有一个表面和四条腿:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>在 <strong>Union</strong> 模式下为曲面创建1个 CSGBox3D 子节点，并调整尺寸。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>在 <strong>Union</strong> 模式下为腿部创建4个 CSGBox3D 子节点并调整尺寸。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>调整它们的摆放位置, 就像一张办公桌.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_desk.png'}" uri="tutorials/3d/img/csg_desk.png"></image>
            <note>
                <paragraph>CSGCombiner3D 内的 CSG 节点只会在组合内处理它们的操作。因此，CSGCombiner3D（CSG 组合器）是用来组织 CSG 节点的。</paragraph>
            </note>
            <paragraph>创建一个 CSGCombiner3D，并将其命名为 <literal>bed</literal> 。</paragraph>
            <paragraph>我们的床由三部分组成：床，床垫和枕头。创建一个 CSGBox3D 并调整床的尺寸。再创建一个CSGBox3D，并调整床垫的尺寸。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_bed_mat.png'}" uri="tutorials/3d/img/csg_bed_mat.png"></image>
            <paragraph>我们将创建另一个名为 <literal>pillow</literal> 的 CSGCombiner3D 作为 <literal>bed</literal> 的子节点。场景树应如下所示：</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_bed_tree.png'}" uri="tutorials/3d/img/csg_bed_tree.png"></image>
            <paragraph>我们将在 <strong>Union</strong> 模式下组合 3 个 CSGSphere3D 节点，形成一个枕头。缩放球体的 Y 轴并启用 <strong>Smooth Faces</strong>（平滑面）。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_pillow_smooth.png'}" uri="tutorials/3d/img/csg_pillow_smooth.png"></image>
            <paragraph>选择 <literal>pillow</literal> 节点，并将模式切换到 <strong>Subtraction</strong>；组合后的球体将在床垫上开一个洞。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_pillow_hole.png'}" uri="tutorials/3d/img/csg_pillow_hole.png"></image>
            <paragraph>试着将 <literal>pillow</literal> 节点重新设置为根 <literal>Node3D</literal> 节点的父节点；这个洞会消失。</paragraph>
            <note>
                <paragraph>这是为了说明CSG处理顺序的效果。由于根节点不是CSG节点，因此CSGCombiner3D节点是操作的结束；这展示了使用CSGCombiner3D来组织CSG场景。</paragraph>
            </note>
            <paragraph>观察效果后，撤消重新选择父节点。你搭建的床应如下所示：</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_bed.png'}" uri="tutorials/3d/img/csg_bed.png"></image>
            <paragraph>创建一个CSGCombiner3D，并将其命名为 <literal>lamp</literal> 。</paragraph>
            <paragraph>一盏灯由三部分组成：灯座、灯杆和灯罩。创建一个 CSGCylinder3D，启用 <strong>Cone</strong> 选项并使其成为支架。创建另一个 CSGCylinder3D 并调整尺寸，将其用作灯杆使用。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp_pole_stand.png'}" uri="tutorials/3d/img/csg_lamp_pole_stand.png"></image>
            <paragraph>我们将使用 CSGPolygon3D 来制作灯罩。使用CSGPolygon3D 的 <strong>Spin</strong> 模式，在<strong>前视图</strong>（小键盘 1）下绘制一个<reference name="梯形" refuri="https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BD%A2">梯形</reference><target ids="id1" names="梯形" refuri="https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BD%A2"></target>，这个形状将围绕原点挤出，形成灯罩。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp_spin.png'}" uri="tutorials/3d/img/csg_lamp_spin.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp_polygon.png'}" uri="tutorials/3d/img/csg_lamp_polygon.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp_extrude.png'}" uri="tutorials/3d/img/csg_lamp_extrude.png"></image>
            <paragraph>调整3个部分的位置，使其看起来像一盏灯。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_lamp.png'}" uri="tutorials/3d/img/csg_lamp.png"></image>
            <paragraph>创建一个CSGCombiner3D，并将其命名为 <literal>bookshelf</literal> 。</paragraph>
            <paragraph>我们将为书架使用3个 CSGBox3D 节点。创建一个 CSGBox3D 并调整其大小，这将是书架的尺寸。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_shelf_big.png'}" uri="tutorials/3d/img/csg_shelf_big.png"></image>
            <paragraph>复制 CSGBox3D 并缩短每个轴的尺寸，并将模式改为 <strong>Subtraction</strong>（减去）。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_shelf_subtract.png'}" uri="tutorials/3d/img/csg_shelf_subtract.png"></image>
            <image candidates="{'*': 'tutorials/3d/img/csg_shelf_subtract_menu.png'}" uri="tutorials/3d/img/csg_shelf_subtract_menu.png"></image>
            <paragraph>你几乎已经建立了一个架子。再创建一个 CSGBox3D，把架子分成两层。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_shelf.png'}" uri="tutorials/3d/img/csg_shelf.png"></image>
            <paragraph>根据你的喜好将你的家具放在房间里，你的场景应该是这样的：</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/csg_room_result.png'}" uri="tutorials/3d/img/csg_room_result.png"></image>
            <paragraph>你已经成功地用 Godot 中的 CSG 工具制作了一个房间关卡的原型。CSG工具可以用于设计各种类型的关卡，如迷宫或城市；在设计游戏时探究它的局限性。</paragraph>
        </section>
        <section ids="using-prototype-textures" names="using\ prototype\ textures 使用原型纹理">
            <title>使用原型纹理</title>
            <paragraph>Godot的 <reference internal="True" refuri="standard_material_3d#doc-standard-material-3d"><inline classes="std std-ref">标准 3D 材质与 ORM 3D 材质</inline></reference> 支持 <emphasis>triplanar mapping</emphasis> （三平面映射）, 可用于自动将纹理应用到任意对象而不失真。使用 CSG 时这很方便，因为 Godot 尚不支持在 CSG 节点上编辑 UV 贴图。三平面映射相对较慢，这通常限制其在地形等有机表面上的使用。尽管如此，在制作原型时，它仍可用于快速将纹理应用到基于 CSG 的关卡。</paragraph>
            <note>
                <paragraph>如果你需要一些原型的图片,Kenney做了一套 <reference name="CC0授权的原型图片" refuri="https://kenney.nl/assets/prototype-textures">CC0授权的原型图片</reference>.</paragraph>
            </note>
            <paragraph>有两种方法可以将材质应用到CSG节点:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>将其作为材质覆盖应用到 CSGCombiner3D 节点上（在检查器中的 <strong>Geometry &gt; Material Override</strong> ），这将自动影响它的子节点，但能改变单个子节点的材质。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>将材质应用于单个节点( <strong>材质</strong> 在(属性)检查器中). 这样, 每个CSG节点都可以有自己的外观. 减去CSG节点将把它们的材质应用到 "digging" 到的节点上.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>要将三平面映射应用到 CSG 节点，请选中它，转到“检查器”，单击 <strong>Material Override</strong>（材质覆盖）旁的 <strong>[空]</strong> 字样（如果是单独的 CSG 节点则为 <strong>Material</strong>）。选择<strong>新建 SpatialMaterial3D</strong>。点击刚创建出来的材质图标来进行编辑。展开 <strong>Albedo</strong> 部分，为 <strong>Texture</strong> 属性加载一张纹理。现在再展开 <strong>Uv1</strong> 部分，勾选 <strong>Triplanar</strong>。可以用上面的 <strong>Scale</strong> 和 <strong>Offset</strong> 属性来调整纹理在各个方向上的缩放和偏移量。<strong>Scale</strong> 属性越大，纹理重复得越多。</paragraph>
            <tip>
                <paragraph>你可以复制一个 SpatialMaterial3D，以便在 CSG 节点中重复使用它。要做到这一点，在（属性）检查器中点击材质属性旁边的下拉箭头，然后选择 <strong>复制</strong> 。 要粘贴它，请选择要应用该材质的节点，单击其材质属性旁边的下拉箭头，然后选择 <strong>粘贴</strong> 。</paragraph>
            </tip>
        </section>
        <section ids="exporting-as-gltf" names="exporting\ as\ gltf 导出为\ gltf">
            <title>导出为 glTF</title>
            <paragraph>使用 CSG 绘制关卡，然后将其导出为 3D 模型，以导入到 3D 建模软件中，这是非常有用的工作流程。你可以通过选择 <strong>场景 &gt; 导出为...&gt; glTF 2.0 场景</strong> 来执行此操作。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/export_as_gltf.webp'}" uri="tutorials/3d/img/export_as_gltf.webp"></image>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
