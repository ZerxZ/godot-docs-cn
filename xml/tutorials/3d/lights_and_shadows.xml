<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/lights_and_shadows.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-lights-and-shadows"></target>
    <section ids="d-lights-and-shadows doc-lights-and-shadows" names="3d\ lights\ and\ shadows doc_lights_and_shadows">
        <title>3D lights and shadows</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>Light sources emit light that mixes with the materials and produces a visible
                result. Light can come from several types of sources in a scene:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>From the material itself, in the form of the emission color (though it does
                        not affect nearby objects unless baked or screen-space indirect lighting is enabled).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Light nodes: DirectionalLight3D, OmniLight3D and SpotLight3D.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Ambient light in the <reference internal="True" refuri="../../classes/class_environment#class-environment"><inline classes="std std-ref">Environment</inline></reference> or
                        <reference internal="True" refuri="global_illumination/reflection_probes#doc-reflection-probes"><inline classes="std std-ref">Reflection probes</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Global illumination (<reference internal="True" refuri="global_illumination/using_lightmap_gi#doc-using-lightmap-gi"><inline classes="std std-ref">LightmapGI</inline></reference>,
                        <reference internal="True" refuri="global_illumination/using_voxel_gi#doc-using-voxel-gi"><inline classes="std std-ref">VoxelGI</inline></reference> or <reference internal="True" refuri="global_illumination/using_sdfgi#doc-using-sdfgi"><inline classes="std std-ref">SDFGI</inline></reference>).</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The emission color is a material property. You can read more about it
                in the <reference internal="True" refuri="standard_material_3d#doc-standard-material-3d"><inline classes="std std-ref">Standard Material 3D and ORM Material 3D</inline></reference> tutorial.</paragraph>
            <seealso>
                <paragraph>You can compare various types of lights in action using the
                    <reference name="3D Lights and Shadows demo project" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/3d/lights_and_shadows">3D Lights and Shadows demo project</reference>.</paragraph>
            </seealso>
        </section>
        <section ids="light-nodes" names="light\ nodes">
            <title>Light nodes</title>
            <paragraph>There are three types of light nodes: <reference internal="True" refuri="../../classes/class_directionallight3d#class-directionallight3d"><inline classes="std std-ref">DirectionalLight3D</inline></reference>,
                <reference internal="True" refuri="../../classes/class_omnilight3d#class-omnilight3d"><inline classes="std std-ref">OmniLight3D</inline></reference> and <reference internal="True" refuri="../../classes/class_spotlight3d#class-spotlight3d"><inline classes="std std-ref">SpotLight3D</inline></reference>. Let's take a look at the common
                parameters for lights:</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/light_params.png'}" original_uri="img/light_params.png" uri="tutorials/3d/img/light_params.png"></image>
            <paragraph>Each property has a specific function:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Color:</strong> Base color for emitted light.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Energy:</strong> Energy multiplier. This is useful for saturating lights or working with <reference internal="True" refuri="high_dynamic_range#doc-high-dynamic-range"><inline classes="std std-ref">High dynamic range lighting</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Indirect Energy:</strong> Secondary multiplier used with indirect light (light bounces). This works with <reference internal="True" refuri="global_illumination/using_lightmap_gi#doc-using-lightmap-gi"><inline classes="std std-ref">Using Lightmap global illumination</inline></reference>, VoxelGI or SDFGI.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Volumetric Fog Energy:</strong> Secondary multiplier used with volumetric fog. This only has an effect when volumetric fog is enabled.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Negative:</strong> Light becomes subtractive instead of additive. It's sometimes useful to manually compensate some dark corners.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Specular:</strong> Affects the intensity of the specular blob in objects affected by this light. At zero, this light becomes a pure diffuse light.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Bake Mode:</strong> Sets the bake mode for the light. See <reference internal="True" refuri="global_illumination/using_lightmap_gi#doc-using-lightmap-gi"><inline classes="std std-ref">Using Lightmap global illumination</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Cull Mask:</strong> Objects that are in the selected layers below will be affected by this light.
                        Note that objects disabled via this cull mask will still cast shadows.
                        If you don't want disabled objects to cast shadows, adjust the <strong>Cast Shadow</strong>
                        property on the GeometryInstance3D to the desired value.</paragraph>
                </list_item>
            </bullet_list>
            <seealso>
                <paragraph>See <reference internal="True" refuri="physical_light_and_camera_units#doc-physical-light-and-camera-units"><inline classes="std std-ref">Physical light and camera units</inline></reference> if you wish to use real world
                    units to configure your lights' intensity and color temperature.</paragraph>
            </seealso>
        </section>
        <section ids="light-number-limits" names="light\ number\ limits">
            <title>Light number limits</title>
            <paragraph>When using the Forward+ renderer, Godot uses a <emphasis>clustering</emphasis> approach for
                real-time lighting. As many lights as desired can be added (as long as
                performance allows). However, there's still a default limit of 512 <emphasis>clustered
                    elements</emphasis> that can be present in the current camera view. A clustered element is
                an omni light, a spot light, a <reference internal="True" refuri="using_decals#doc-using-decals"><inline classes="std std-ref">decal</inline></reference> or a
                <reference internal="True" refuri="global_illumination/reflection_probes#doc-reflection-probes"><inline classes="std std-ref">reflection probe</inline></reference>. This limit can be increased by adjusting
                <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-rendering-limits-cluster-builder-max-clustered-elements"><inline classes="std std-ref">Max Clustered Elements</inline></reference>
                in <strong>Project Settings &gt; Rendering &gt; Limits &gt; Cluster Builder</strong>.</paragraph>
            <paragraph>When using the Mobile renderer, there is a limitation of 8 OmniLights + 8 SpotLights
                per mesh resource. There is also a limit of 256 OmniLights + 256 SpotLights that
                can be rendered in the current camera view. These limits currently cannot be changed.</paragraph>
            <paragraph>When using the Compatibility renderer, up to 8 OmniLights + 8 SpotLights can be
                rendered per mesh resource. This limit can be increased in the advanced Project
                Settings by adjusting
                <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-rendering-limits-opengl-max-renderable-elements"><inline classes="std std-ref">Max Renderable Elements</inline></reference>
                and/or <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-rendering-limits-opengl-max-lights-per-object"><inline classes="std std-ref">Max Lights per Object</inline></reference>
                in <strong>Rendering &gt; Limits &gt; OpenGL</strong>, at the cost of performance and longer shader
                compilation times. The limit can also be decreased to reduce shader compilation
                times and improve performance slightly.</paragraph>
            <paragraph>With all rendering methods, up to 8 DirectionalLights can be visible at a time.
                However, each additional DirectionalLight with shadows enabled will reduce the
                effective shadow resolution of each DirectionalLight. This is because
                directional shadow atlas is shared between all lights.</paragraph>
            <paragraph>If the rendering limit is exceeded, lights will start popping in and out during
                camera movement, which can be distracting. Enabling <strong>Distance Fade</strong> on light
                nodes can help reduce this issue while also improving performance. Splitting
                your meshes into smaller portions can also help, especially for level geometry
                (which also improves culling efficiency).</paragraph>
            <paragraph>If you need to render more lights than possible in a given renderer,
                consider using <reference internal="True" refuri="global_illumination/using_lightmap_gi#doc-using-lightmap-gi"><inline classes="std std-ref">baked lightmaps</inline></reference> with lights' bake
                mode set to <strong>Static</strong>. This allows lights to be fully baked, which also makes
                them much faster to render. You can also use emissive materials with any
                <reference internal="True" refuri="global_illumination/introduction_to_global_illumination#doc-introduction-to-global-illumination"><inline classes="std std-ref">global illumination</inline></reference> technique
                as a replacement for light nodes that emit light over a large area.</paragraph>
        </section>
        <section ids="shadow-mapping" names="shadow\ mapping">
            <title>Shadow mapping</title>
            <paragraph>Lights can optionally cast shadows. This gives them greater realism (light does
                not reach occluded areas), but it can incur a bigger performance cost.
                There is a list of generic shadow parameters, each also has a specific function:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Enabled:</strong> Check to enable shadow mapping in this light.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Opacity:</strong> Areas occluded are darkened by this opacity factor. Shadows are
                        fully opaque by default, but this can be changed to make shadows translucent
                        for a given light.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Bias:</strong> When this parameter is too low, self-shadowing occurs. When too
                        high, shadows separate from the casters. Tweak to what works best for you.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Normal Bias:</strong> When this parameter is too low, self-shadowing occurs. When too
                        high, shadows appear misaligned from the casters. Tweak to what works best for you.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Transmittance Bias:</strong> When this parameter is too low, self-shadowing
                        occurs on materials that have transmittance enabled. When too high, shadows
                        will not affect materials that have transmittance enabled consistently. Tweak
                        to what works best for you.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Reverse Cull Face:</strong> Some scenes work better when shadow mapping is rendered
                        with face-culling inverted.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Blur:</strong> Multiplies the shadow blur radius for this light. This works with
                        both traditional shadow mapping and contact-hardening shadows (lights with
                        <strong>Angular Distance</strong> or <strong>Size</strong> greater than <literal>0.0</literal>). Higher values result
                        in softer shadows, which will also appear to be more temporally stable for
                        moving objects. The downside of increasing shadow blur is that it will make
                        the grainy pattern used for filtering more noticeable.
                        See also <reference internal="True" refid="doc-lights-and-shadows-shadow-filter-mode"><inline classes="std std-ref">Shadow filter mode</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Caster Mask:</strong> Shadows are only cast by objects in these layers. Note that
                        this mask does not affect which objects shadows are cast <emphasis>onto</emphasis>.</paragraph>
                </list_item>
            </bullet_list>
            <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_blur.webp'}" original_uri="img/lights_and_shadows_blur.webp" uri="tutorials/3d/img/lights_and_shadows_blur.webp"></image>
            <section ids="tweaking-shadow-bias" names="tweaking\ shadow\ bias">
                <title>Tweaking shadow bias</title>
                <paragraph>Below is an image of what tweaking bias looks like. Default values work for most
                    cases, but in general, it depends on the size and complexity of geometry.</paragraph>
                <paragraph>If the <strong>Shadow Bias</strong> or <strong>Shadow Normal Bias</strong> is set too low for a given light,
                    the shadow will be "smeared" onto the objects. This will cause the light's
                    intended appearance to darken, and is called <emphasis>shadow acne</emphasis>:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_acne.webp'}" original_uri="img/lights_and_shadows_acne.webp" uri="tutorials/3d/img/lights_and_shadows_acne.webp"></image>
                <paragraph>On the other hand, if the <strong>Shadow Bias</strong> or <strong>Shadow Normal Bias</strong> is set too
                    high for a given light, the shadow may appear to be disconnected from the
                    object. This is called <emphasis>peter-panning</emphasis>:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_peter_panning.webp'}" original_uri="img/lights_and_shadows_peter_panning.webp" uri="tutorials/3d/img/lights_and_shadows_peter_panning.webp"></image>
                <paragraph>In general, increasing <strong>Shadow Normal Bias</strong> is preferred over increasing
                    <strong>Shadow Bias</strong>. Increasing <strong>Shadow Normal Bias</strong> does not cause as much
                    peter-panning as increasing <strong>Shadow Bias</strong>, but it can still resolve
                    most shadow acne issues efficiently. The downside of increasing <strong>Shadow Normal
                        Bias</strong> is that it can make shadows appear thinner for certain objects.</paragraph>
                <paragraph>Any sort of bias issues can be fixed by
                    <reference internal="True" refid="doc-lights-and-shadows-balancing-performance-and-quality"><inline classes="std std-ref">increasing the shadow map resolution</inline></reference>,
                    at the cost of decreased performance.</paragraph>
                <note>
                    <paragraph>Tweaking shadow mapping settings is an art – there are no "one size fits
                        all" settings. To achieve the best visuals, you may need to use different
                        shadow bias values on a per-light basis.</paragraph>
                </note>
                <paragraph><strong>Note on Appearance Changes</strong>: When enabling shadows on a light, be aware that the light's
                    appearance might change compared to when it's rendered without shadows in the compatibility
                    renderer. Due to limitations with older mobile devices, shadows are implemented using a multi-pass
                    rendering approach so lights with shadows are rendered in sRGB space instead of linear space.
                    This change in rendering space can sometimes drastically alter the light's appearance. To achieve a similar
                    appearance to an unshadowed light, you may need to adjust the light's energy setting.</paragraph>
            </section>
        </section>
        <section ids="directional-light" names="directional\ light">
            <title>Directional light</title>
            <paragraph>This is the most common type of light and represents a light source very far
                away (such as the sun). It is also the cheapest light to compute and should be
                used whenever possible (although it's not the cheapest shadow-map to compute,
                but more on that later).</paragraph>
            <paragraph>Directional light models an infinite number of parallel light rays
                covering the whole scene. The directional light node is represented by a big arrow which
                indicates the direction of the light rays. However, the position of the node
                does not affect the lighting at all and can be anywhere.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/light_directional.png'}" original_uri="img/light_directional.png" uri="tutorials/3d/img/light_directional.png"></image>
            <paragraph>Every face whose front-side is hit by the light rays is lit, while the others
                stay dark. Unlike most other light types, directional lights don't have specific
                parameters.</paragraph>
            <paragraph>The directional light also offers an <strong>Angular Distance</strong> property, which
                determines the light's angular size in degrees. Increasing this above <literal>0.0</literal>
                will make shadows softer at greater distances from the caster, while also
                affecting the sun's appearance in procedural sky materials. This is called a
                <emphasis>contact-hardening</emphasis> shadow (also known as PCSS).</paragraph>
            <paragraph>For reference, the angular distance of the Sun viewed from the Earth is
                approximately <literal>0.5</literal>. This kind of shadow is expensive, so check the
                recommendations in <reference internal="True" refid="doc-lights-and-shadows-pcss-recommendations"><inline classes="std std-ref">PCSS recommendations</inline></reference> if setting
                this value above <literal>0.0</literal> on lights with shadows enabled.</paragraph>
            <section ids="directional-shadow-mapping" names="directional\ shadow\ mapping">
                <title>Directional shadow mapping</title>
                <paragraph>To compute shadow maps, the scene is rendered (only depth) from an orthogonal
                    point of view that covers the whole scene (or up to the max distance). There is,
                    however, a problem with this approach because objects closer to the camera
                    receive low-resolution shadows that may appear blocky.</paragraph>
                <paragraph>To fix this, a technique named <emphasis>Parallel Split Shadow Maps</emphasis> (PSSM) is used.
                    This splits the view frustum in 2 or 4 areas. Each area gets its own shadow map.
                    This allows small areas close to the viewer to have the same shadow resolution
                    as a huge, far-away area. When shadows are enabled for DirectionalLight3D, the
                    default shadow mode is PSSM with 4 splits. In scenarios where an object is large
                    enough to appear in all four splits, it results in increased draw calls. Specifically,
                    such an object will be rendered five times in total: once for each of the four shadow
                    splits and once for the final scene rendering. This can impact performance, understanding
                    this behavior is important for optimizing your scene and managing performance expectations.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_pssm_explained.webp'}" original_uri="img/lights_and_shadows_pssm_explained.webp" uri="tutorials/3d/img/lights_and_shadows_pssm_explained.webp"></image>
                <paragraph>With this, shadows become more detailed:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_directional_mode.webp'}" original_uri="img/lights_and_shadows_directional_mode.webp" uri="tutorials/3d/img/lights_and_shadows_directional_mode.webp"></image>
                <paragraph>To control PSSM, a number of parameters are exposed:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_directional_shadow_params.webp'}" original_uri="img/lights_and_shadows_directional_shadow_params.webp" uri="tutorials/3d/img/lights_and_shadows_directional_shadow_params.webp"></image>
                <paragraph>Each split distance is controlled relative to the camera far (or shadow
                    <strong>Max Distance</strong> if greater than <literal>0.0</literal>). <literal>0.0</literal> is the eye position and
                    <literal>1.0</literal> is where the shadow ends at a distance. Splits are in-between.
                    Default values generally work well, but tweaking the first split a bit is common
                    to give more detail to close objects (like a character in a third-person game).</paragraph>
                <paragraph>Always make sure to set a shadow <strong>Max Distance</strong> according to what the scene
                    needs. A lower maximum distance will result in better-looking shadows and better
                    performance, as fewer objects will need to be included in shadow rendering. You
                    can also adjust <strong>Fade Start</strong> to control how aggressive the shadow fade-out
                    should be at a distance. For scenes where the <strong>Max Distance</strong> fully covers the
                    scene at any given camera position, you can increase <strong>Fade Start</strong> to <literal>1.0</literal>
                    to prevent the shadow from fading at a distance. This should not be done in
                    scenes where <strong>Max Distance</strong> doesn't fully cover the scene, as the shadow will
                    appear to be suddenly cut off at a distance.</paragraph>
                <paragraph>Sometimes, the transition between a split and the next can look bad. To fix
                    this, the <strong>Blend Splits</strong> option can be turned on, which sacrifices detail and
                    performance in exchange for smoother transitions:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/blend_splits.png'}" original_uri="img/blend_splits.png" uri="tutorials/3d/img/blend_splits.png"></image>
                <paragraph>The <strong>Shadow &gt; Normal Bias</strong> parameter can be used to fix special cases of
                    self-shadowing when objects are perpendicular to the light. The only downside is
                    that it makes the shadow a bit thinner. Consider increasing <strong>Shadow &gt; Normal
                        Bias</strong> before increasing <strong>Shadow &gt; Bias</strong> in most situations.</paragraph>
                <paragraph>Lastly, <strong>Pancake Size</strong> is a property that can be adjusted to fix missing
                    shadows when using large objects with unsubdivided meshes. Only change this
                    value if you notice missing shadows that are not related to shadow biasing
                    issues.</paragraph>
            </section>
        </section>
        <section ids="omni-light" names="omni\ light">
            <title>Omni light</title>
            <paragraph>Omni light is a point source that emits light spherically in all directions up to a given
                radius.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/light_omni.png'}" original_uri="img/light_omni.png" uri="tutorials/3d/img/light_omni.png"></image>
            <paragraph>In real life, light attenuation is an inverse function, which means omni lights don't have a radius.
                This is a problem because it means computing several omni lights would become demanding.</paragraph>
            <paragraph>To solve this, a <strong>Range</strong> parameter is introduced together with an attenuation function.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/light_omni_params.png'}" original_uri="img/light_omni_params.png" uri="tutorials/3d/img/light_omni_params.png"></image>
            <paragraph>These two parameters allow tweaking how this works visually in order to find aesthetically pleasing results.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/light_attenuation.png'}" original_uri="img/light_attenuation.png" uri="tutorials/3d/img/light_attenuation.png"></image>
            <paragraph>A <strong>Size</strong> parameter is also available in OmniLight3D. Increasing this value
                will make the light fade out slower and shadows appear blurrier when far away
                from the caster. This can be used to simulate area lights to an extent. This is
                called a <emphasis>contact-hardening</emphasis> shadow (also known as PCSS). This kind of shadow is
                expensive, so check the recommendations in
                <reference internal="True" refid="doc-lights-and-shadows-pcss-recommendations"><inline classes="std std-ref">PCSS recommendations</inline></reference> if setting this value above
                <literal>0.0</literal> on lights with shadows enabled.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_pcss.webp'}" original_uri="img/lights_and_shadows_pcss.webp" uri="tutorials/3d/img/lights_and_shadows_pcss.webp"></image>
            <section ids="omni-shadow-mapping" names="omni\ shadow\ mapping">
                <title>Omni shadow mapping</title>
                <paragraph>Omni light shadow mapping is relatively straightforward. The main issue that
                    needs to be considered is the algorithm used to render it.</paragraph>
                <paragraph>Omni Shadows can be rendered as either <strong>Dual Paraboloid</strong> or <strong>Cube</strong> mapped.
                    <strong>Dual Paraboloid</strong> renders quickly, but can cause deformations, while <strong>Cube</strong>
                    is more correct, but slower. The default is <strong>Cube</strong>, but consider changing it
                    to <strong>Dual Paraboloid</strong> for lights where it doesn't make much of a visual
                    difference.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_dual_parabolid_vs_cubemap.webp'}" original_uri="img/lights_and_shadows_dual_parabolid_vs_cubemap.webp" uri="tutorials/3d/img/lights_and_shadows_dual_parabolid_vs_cubemap.webp"></image>
                <paragraph>If the objects being rendered are mostly irregular and subdivided, Dual
                    Paraboloid is usually enough. In any case, as these shadows are cached in a
                    shadow atlas (more on that at the end), it may not make a difference in
                    performance for most scenes.</paragraph>
                <paragraph>Omni lights with shadows enabled can make use of projectors. The projector
                    texture will <emphasis>multiply</emphasis> the light's color by the color at a given point on the
                    texture. As a result, lights will usually appear to be darker once a projector
                    texture is assigned; you can increase <strong>Energy</strong> to compensate for this.</paragraph>
                <paragraph>Omni light projector textures require a special 360° panorama mapping, similar
                    to <reference internal="True" refuri="../../classes/class_panoramaskymaterial#class-panoramaskymaterial"><inline classes="std std-ref">PanoramaSkyMaterial</inline></reference> textures.</paragraph>
                <paragraph>With the projector texture below, the following result is obtained:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_omni_projector_example.webp'}" original_uri="img/lights_and_shadows_omni_projector_example.webp" uri="tutorials/3d/img/lights_and_shadows_omni_projector_example.webp"></image>
                <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_omni_projector.webp'}" original_uri="img/lights_and_shadows_omni_projector.webp" uri="tutorials/3d/img/lights_and_shadows_omni_projector.webp"></image>
                <tip>
                    <paragraph>If you've acquired omni projectors in the form of cubemap images, you can use
                        <reference name="this web-based conversion tool" refuri="https://danilw.github.io/GLSL-howto/cubemap_to_panorama_js/cubemap_to_panorama.html">this web-based conversion tool</reference>
                        to convert them to a single panorama image.</paragraph>
                </tip>
            </section>
        </section>
        <section ids="spot-light" names="spot\ light">
            <title>Spot light</title>
            <paragraph>Spot lights are similar to omni lights, except they emit light only into a cone
                (or "cutoff"). They are useful to simulate flashlights,
                car lights, reflectors, spots, etc. This type of light is also attenuated towards the
                opposite direction it points to.</paragraph>
            <paragraph>Spot lights share the same <strong>Range</strong>, <strong>Attenuation</strong> and <strong>Size</strong> as OmniLight3D,
                and add two extra parameters:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Angle:</strong> The aperture angle of the light.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Angle Attenuation:</strong> The cone attenuation, which helps soften the cone borders.</paragraph>
                </list_item>
            </bullet_list>
            <section ids="spot-shadow-mapping" names="spot\ shadow\ mapping">
                <title>Spot shadow mapping</title>
                <paragraph>Spots feature the same parameters as omni lights for shadow mapping. Rendering
                    spot shadow maps is significantly faster compared to omni lights, as only one
                    shadow texture needs to be rendered (instead of rendering 6 faces, or 2 in dual
                    paraboloid mode).</paragraph>
                <paragraph>Spot lights with shadows enabled can make use of projectors. The projector
                    texture will <emphasis>multiply</emphasis> the light's color by the color at a given point on the
                    texture. As a result, lights will usually appear to be darker once a projector
                    texture is assigned; you can increase <strong>Energy</strong> to compensate for this.</paragraph>
                <paragraph>Unlike omni light projectors, a spot light projector texture doesn't need to
                    follow a special format to look correct. It will be mapped in a way similar to a
                    <reference internal="True" refuri="using_decals#doc-using-decals"><inline classes="std std-ref">decal</inline></reference>.</paragraph>
                <paragraph>With the projector texture below, the following result is obtained:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_spot_projector_example.webp'}" original_uri="img/lights_and_shadows_spot_projector_example.webp" uri="tutorials/3d/img/lights_and_shadows_spot_projector_example.webp"></image>
                <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_spot_projector.webp'}" original_uri="img/lights_and_shadows_spot_projector.webp" uri="tutorials/3d/img/lights_and_shadows_spot_projector.webp"></image>
                <note>
                    <paragraph>Spot lights with wide angles will have lower-quality shadows than spot
                        lights with narrow angles, as the shadow map is spread over a larger
                        surface. At angles wider than 89 degrees, spot light shadows will stop
                        working entirely. If you need shadows for wider lights, use an omni light
                        instead.</paragraph>
                </note>
                <target refid="doc-lights-and-shadows-shadow-atlas"></target>
            </section>
        </section>
        <section ids="shadow-atlas doc-lights-and-shadows-shadow-atlas" names="shadow\ atlas doc_lights_and_shadows_shadow_atlas">
            <title>Shadow atlas</title>
            <paragraph>Unlike Directional lights, which have their own shadow texture, omni and spot
                lights are assigned to slots of a shadow atlas. This atlas can be configured in
                the advanced Project Settings (<strong>Rendering &gt; Lights And Shadows &gt; Positional Shadow</strong>).</paragraph>
            <paragraph>The resolution applies to the whole shadow atlas. This atlas is divided into four quadrants:</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_shadow_quadrants.webp'}" original_uri="img/lights_and_shadows_shadow_quadrants.webp" uri="tutorials/3d/img/lights_and_shadows_shadow_quadrants.webp"></image>
            <paragraph>Each quadrant can be subdivided to allocate any number of shadow maps; the following is the default subdivision:</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_shadow_quadrants2.webp'}" original_uri="img/lights_and_shadows_shadow_quadrants2.webp" uri="tutorials/3d/img/lights_and_shadows_shadow_quadrants2.webp"></image>
            <paragraph>The shadow atlas allocates space as follows:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The biggest shadow map size (when no subdivision is used) represents a light the size of the screen (or bigger).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Subdivisions (smaller maps) represent shadows for lights that are further away from view and proportionally smaller.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Every frame, the following procedure is performed for all lights:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Check if the light is on a slot of the right size. If not, re-render it and move it to a larger/smaller slot.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Check if any object affecting the shadow map has changed. If it did, re-render the light.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If neither of the above has happened, nothing is done, and the shadow is left untouched.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>If the slots in a quadrant are full, lights are pushed back to smaller slots,
                depending on size and distance. If all slots in all quadrants are full, some
                lights will not be able to render shadows even if shadows are enabled on them.</paragraph>
            <paragraph>The default shadow allocation strategy allows rendering up to 88 lights with
                shadows enabled in the camera frustum (4 + 4 + 16 + 64):</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>The first and most detailed quadrant can store 4 shadows.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The second quadrant can store 4 other shadows.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The third quadrant can store 16 shadows, with less detail.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The fourth and least detailed quadrant can store 64 shadows, with even less detail.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>Using a higher number of shadows per quadrant allows supporting a greater amount
                of total lights with shadows enabled, while also improving performance (as
                shadows will be rendered at a lower resolution for each light). However,
                increasing the number of shadows per quadrant comes at the cost of lower shadow
                quality.</paragraph>
            <paragraph>In some cases, you may want to use a different allocation strategy. For example,
                in a top-down game where all lights are around the same size, you may want to
                set all quadrants to have the same subdivision so that all lights have shadows
                of similar quality level.</paragraph>
            <target refid="doc-lights-and-shadows-balancing-performance-and-quality"></target>
        </section>
        <section ids="balancing-performance-and-quality doc-lights-and-shadows-balancing-performance-and-quality" names="balancing\ performance\ and\ quality doc_lights_and_shadows_balancing_performance_and_quality">
            <title>Balancing performance and quality</title>
            <paragraph>Shadow rendering is a critical topic in 3D rendering performance. It's important
                to make the right choices here to avoid creating bottlenecks.</paragraph>
            <paragraph>Directional shadow quality settings can be changed at runtime by calling the
                appropriate <reference internal="True" refuri="../../classes/class_renderingserver#class-renderingserver"><inline classes="std std-ref">RenderingServer</inline></reference> methods.</paragraph>
            <paragraph>Positional (omni/spot) shadow quality settings can be changed at runtime on the
                root <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>.</paragraph>
            <section ids="shadow-map-size" names="shadow\ map\ size">
                <title>Shadow map size</title>
                <paragraph>High shadow resolutions result in sharper shadows, but at a significant
                    performance cost. It should also be noted that <emphasis>sharper shadows are not always
                        more realistic</emphasis>. In most cases, this should be kept at its default value of
                    <literal>4096</literal> or decreased to <literal>2048</literal> for low-end GPUs.</paragraph>
                <paragraph>If positional shadows become too blurry after decreasing the shadow map size,
                    you can counteract this by adjusting the
                    <reference internal="True" refid="doc-lights-and-shadows-shadow-atlas"><inline classes="std std-ref">shadow atlas</inline></reference> quadrants to contain
                    fewer shadows. This will allow each shadow to be rendered at a higher resolution.</paragraph>
                <target refid="doc-lights-and-shadows-shadow-filter-mode"></target>
            </section>
            <section ids="shadow-filter-mode doc-lights-and-shadows-shadow-filter-mode" names="shadow\ filter\ mode doc_lights_and_shadows_shadow_filter_mode">
                <title>Shadow filter mode</title>
                <paragraph>Several shadow map quality settings can be chosen here. The default <strong>Soft Low</strong>
                    is a good balance between performance and quality for scenes with detailed
                    textures, as the texture detail will help make the dithering pattern less noticeable.</paragraph>
                <paragraph>However, in projects with less detailed textures, the shadow dithering pattern
                    may be more visible. To hide this pattern, you can either enable
                    <reference internal="True" refuri="3d_antialiasing#doc-3d-antialiasing-taa"><inline classes="std std-ref">Temporal antialiasing (TAA)</inline></reference>, <reference internal="True" refuri="3d_antialiasing#doc-3d-antialiasing-fsr2"><inline classes="std std-ref">AMD FidelityFX Super Resolution 2.2 (FSR2)</inline></reference>,
                    <reference internal="True" refuri="3d_antialiasing#doc-3d-antialiasing-fxaa"><inline classes="std std-ref">Fast approximate antialiasing (FXAA)</inline></reference>, or increase the shadow filter quality to
                    <strong>Soft Medium</strong> or higher.</paragraph>
                <paragraph>The <strong>Soft Very Low</strong> setting will automatically decrease shadow blur to make
                    artifacts from the low sample count less visible. Conversely, the <strong>Soft High</strong>
                    and <strong>Soft Ultra</strong> settings will automatically increase shadow blur to better
                    make use of the increased sample count.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/lights_and_shadows_filter_quality.webp'}" original_uri="img/lights_and_shadows_filter_quality.webp" uri="tutorials/3d/img/lights_and_shadows_filter_quality.webp"></image>
            </section>
            <section ids="bits-versus-32-bit" names="16-bits\ versus\ 32-bit">
                <title>16-bits versus 32-bit</title>
                <paragraph>By default, Godot uses 16-bit depth textures for shadow map rendering. This is
                    recommended in most cases as it performs better without a noticeable difference
                    in quality.</paragraph>
                <paragraph>If <strong>16 Bits</strong> is disabled, 32-bit depth textures will be used instead. This
                    can result in less artifacting in large scenes and large lights with shadows
                    enabled. However, the difference is often barely visible, yet this can have a
                    significant performance cost.</paragraph>
            </section>
            <section ids="light-shadow-distance-fade" names="light/shadow\ distance\ fade">
                <title>Light/shadow distance fade</title>
                <paragraph>OmniLight3D and SpotLight3D offer several properties to hide distant lights.
                    This can improve performance significantly in large scenes with dozens of lights
                    or more.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Enabled:</strong> Controls whether distance fade (a form of <abbreviation explanation="Level of Detail">LOD</abbreviation>)
                            is enabled. The light will fade out over <strong>Begin + Length</strong>, after which it
                            will be culled and not sent to the shader at all. Use this to reduce the number
                            of active lights in a scene and thus improve performance.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Begin:</strong> The distance from the camera at which the light begins to fade away
                            (in 3D units).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Shadow:</strong> The distance from the camera at which the shadow begins to fade away
                            (in 3D units). This can be used to fade out shadows sooner compared to the light,
                            further improving performance. Only available if shadows are enabled for the light.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Length:</strong> The distance over which the light and shadow fades (in 3D units).
                            The light becomes slowly more transparent over this distance and is completely
                            invisible at the end. Higher values result in a smoother fade-out transition,
                            which is more suited when the camera moves fast.</paragraph>
                    </list_item>
                </bullet_list>
                <target refid="doc-lights-and-shadows-pcss-recommendations"></target>
            </section>
            <section ids="pcss-recommendations doc-lights-and-shadows-pcss-recommendations" names="pcss\ recommendations doc_lights_and_shadows_pcss_recommendations">
                <title>PCSS recommendations</title>
                <paragraph>Percentage-closer soft shadows (PCSS) provide a more realistic shadow mapping
                    appearance, with the penumbra size varying depending on the distance between the
                    caster and the surface receiving the shadow. This comes at a high performance
                    cost, especially for directional lights.</paragraph>
                <paragraph>To avoid performance issues, it's recommended to:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Only use a handful of lights with PCSS shadows enabled at a given time. The
                            effect is generally most visible on large, bright lights. Secondary light
                            sources that are more faint usually don't benefit much from using PCSS
                            shadows.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Provide a setting for users to disable PCSS shadows. On directional lights,
                            this can be done by setting the DirectionalLight3D's
                            <literal>light_angular_distance</literal> property to <literal>0.0</literal> in a script. On positional
                            lights, this can be done by setting the OmniLight3D or SpotLight3D's
                            <literal>light_size</literal> property to <literal>0.0</literal> in a script.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="projector-filter-mode" names="projector\ filter\ mode">
                <title>Projector filter mode</title>
                <paragraph>The way projectors are rendered also has an impact on performance. The
                    <strong>Rendering &gt; Textures &gt; Light Projectors &gt; Filter</strong> advanced project setting
                    lets you control how projector textures should be filtered. <strong>Nearest/Linear</strong> do
                    not use mipmaps, which makes them faster to render. However, projectors will
                    look grainy at distance. <strong>Nearest/Linear Mipmaps</strong> will look smoother at a
                    distance, but projectors will look blurry when viewed from oblique angles. This
                    can be resolved by using <strong>Nearest/Linear Mipmaps Anisotropic</strong>, which is the
                    highest-quality mode, but also the most expensive.</paragraph>
                <paragraph>If your project has a pixel art style, consider setting the filter to one of the
                    <strong>Nearest</strong> values so that projectors use nearest-neighbor filtering. Otherwise,
                    stick to <strong>Linear</strong>.</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
