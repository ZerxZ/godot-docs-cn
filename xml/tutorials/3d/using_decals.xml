<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/using_decals.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-decals"></target>
    <section ids="using-decals doc-using-decals" names="using\ decals 使用贴花 doc_using_decals">
        <title>使用贴花</title>
        <note>
            <paragraph>贴花仅在集群Forward 和 Forward Mobile 渲染后端中受支持，在兼容性后端中则不受支持。</paragraph>
            <paragraph>如果使用兼容性后端，请考虑使用 Sprite3D 作为将贴花投影到（大部分）平坦表面的替代方案。</paragraph>
        </note>
        <paragraph>贴花是应用于 3D 不透明或透明表面的投影纹理。 该投影是实时生成的，不依赖于网格生成。 这允许你在每一帧移动贴花，即使在复杂的网格上应用时，也只会对性能产生很小的影响。</paragraph>
        <paragraph>虽然贴花无法将实际的几何细节添加到投影表面上，但贴花仍然可以利用基于物理的渲染来提供与完整的 <abbreviation explanation="Physically-Based Rendering">PBR</abbreviation> 材质类似的属性。</paragraph>
        <paragraph>你会在这个页面中学习到：</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>如何在 3D 编辑器中设置贴花。</paragraph>
            </list_item>
            <list_item>
                <paragraph>如何在游戏过程中为 3D 场景创建贴花（例如弹孔）。</paragraph>
            </list_item>
            <list_item>
                <paragraph>如何为贴花的配置进行性能和质量之间的平衡。</paragraph>
            </list_item>
        </bullet_list>
        <seealso>
            <paragraph>Godot 示例项目仓库包含一个 <reference name="3D 贴花演示" refuri="https://github.com/godotengine/godot-demo-projects/tree/4.0-dev/3d/decals">3D 贴花演示</reference> 。</paragraph>
            <paragraph>如果你想在表面上写入任意 3D 文本，请使用靠近表面放置的 <reference internal="True" refuri="3d_text#doc-3d-text"><inline classes="std std-ref">3D 文本</inline></reference> 而不是贴花节点。</paragraph>
        </seealso>
        <section ids="use-cases" names="use\ cases 使用案例">
            <title>使用案例</title>
            <section ids="static-decoration" names="static\ decoration 静态装饰">
                <title>静态装饰</title>
                <paragraph>有时，向场景添加纹理细节的最快方法是使用贴花。 对于有机细节（organic detail）尤其如此，例如散布在大表面上的污垢或沙子。 贴花可以帮助打破场景中的纹理重复，并使图案看起来更自然。 在较小的规模上，贴花也可用于创建对象的细节变化。 例如，贴花可用于在硬表面几何体（hard-surface geometry）顶部添加螺母和螺栓。</paragraph>
                <paragraph>由于贴花可以在投影表面上注入自己的 <abbreviation explanation="Physically-Based Rendering">PBR</abbreviation> 属性，因此它们也可以用于创建足迹或湿水坑。</paragraph>
                <figure align="center" ids="id1">
                    <image alt="使用贴花在关卡几何体（ level geometry ）顶部添加污垢" candidates="{'*': 'tutorials/3d/img/decals_dirt.webp'}" uri="tutorials/3d/img/decals_dirt.webp"></image>
                    <caption>使用贴花在关卡几何体（ level geometry ）顶部添加污垢</caption>
                </figure>
            </section>
            <section ids="dynamic-gameplay-elements" names="dynamic\ gameplay\ elements 动态游戏元素">
                <title>动态游戏元素</title>
                <paragraph>贴花可以展现暂时或持久的游戏特效，例如子弹撞击和爆炸烧焦。</paragraph>
                <paragraph>使用 AnimationPlayer 节点或脚本，可以使贴花随着时间的推移而褪色（然后使用 <literal>queue_free()</literal> 删除）以提高性能。</paragraph>
            </section>
            <section ids="blob-shadows" names="blob\ shadows 片面阴影">
                <title>片面阴影</title>
                <paragraph>斑点阴影经常用于移动项目（或遵循复古艺术风格），因为实时照明在低端移动设备上往往耗费过大。 但是，当依赖具有完全烘焙灯光的烘焙光照贴图时，动态对象不会从这些灯光投射 <emphasis>任何</emphasis> 阴影。 与实时光照相比，这使得光照贴图场景中的动态对象看起来很平坦，动态对象几乎看起来像是漂浮的。</paragraph>
                <paragraph>由于斑点阴影，动态对象仍然可以投射近似阴影。 这不仅有助于场景中的深度感知，而且还可以成为一种游戏元素，尤其是在 3D 平台游戏中。 斑点阴影的长度可以延长，让玩家知道如果他们垂直落下时自己会落在哪里。</paragraph>
                <paragraph>即使使用实时光照，斑点阴影仍然可以作为环境光遮挡的一种形式，适用于 SSAO 由于其屏幕空间性质而消耗过大或过于不稳定的情况。 例如，使用斑点阴影很好地表现了车辆的底部阴影。</paragraph>
                <figure align="center" ids="id2">
                    <image alt="对象比较下的斑点阴影" candidates="{'*': 'tutorials/3d/img/decals_blob_shadow.webp'}" uri="tutorials/3d/img/decals_blob_shadow.webp"></image>
                    <caption>对象比较下的斑点阴影</caption>
                </figure>
            </section>
        </section>
        <section ids="quick-start-guide" names="quick\ start\ guide 快速入门指南">
            <title>快速入门指南</title>
            <section ids="creating-decals-in-the-editor" names="creating\ decals\ in\ the\ editor 在编辑器中创建贴花">
                <title>在编辑器中创建贴花</title>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>在 3D 编辑器中创建贴花节点。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>在检查器中，展开 <strong>Textures</strong> 部分并在 <strong>Textures &gt; Albedo</strong> 中加载纹理。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>将贴花节点移向对象，然后旋转它以使贴花可见（并且方向正确）。 如果贴花看起来是镜像的，请尝试将其旋转 180 度。 你可以通过将 <strong>Parameters &gt; Normal Fade</strong> 增加到 0.5 来仔细检查其方向是否正确。 这将防止贴花投影到不面向贴花的表面上。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>如果你的贴花仅影响静态对象，请将其配置为防止影响动态对象（反之亦然）。 为此，请更改贴花的 <strong>Cull Mask</strong> （剔除蒙版）属性以排除某些图层。 执行此操作后，修改动态对象的 MeshInstance3D 节点以更改其可见性层。 例如，你可以将它们从第 1 层移动到第 2 层，然后在贴花的 <strong>Cull Mask</strong> 属性中禁用第 2 层。</paragraph>
                    </list_item>
                </enumerated_list>
            </section>
        </section>
        <section ids="decal-node-properties" names="decal\ node\ properties 贴花节点属性">
            <title>贴花节点属性</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Extents：</strong> （范围）贴花的大小。 Y 轴决定贴花投影的长度。 保持投影长度尽可能短，以增加剔除机会，从而提高性能。</paragraph>
                </list_item>
            </bullet_list>
            <section ids="textures" names="textures 纹理">
                <title>纹理</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Albedo：</strong> （反照率）用于贴花的反照率（漫反射/颜色）贴图。 在大多数情况下，这是你要首先设置的纹理。 如果使用法线或 ORM 贴图，则 <emphasis>必须</emphasis> 设置反照率贴图以提供 Alpha 通道。 该 Alpha 通道将用作遮罩，以确定法线/ORM 贴图对底层表面的影响程度。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Normal：</strong> （法线）用于贴花的法线贴图。 这可用于通过修改光对其的反应方式来增加贴花上的感知细节。 该纹理的影响会乘以反照率纹理的 Alpha 通道（但不是 <strong>Albedo Mix</strong> ）。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>ORM：</strong> 用于贴花的遮挡（Occlusion）/粗糙度（Roughness）/金属贴图（Metallic map）。 这是用于存储 PBR 材质贴图的优化格式。 环境光遮挡贴图存储在红色通道中，粗糙度贴图存储在绿色通道中，金属贴图存储在蓝色通道中。 该纹理的影响会乘以反照率纹理的 Alpha 通道（但不是 <strong>Albedo Mix</strong> ）。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Emission：</strong> （自发光）用于贴花的自发光纹理。与 <strong>Albedo</strong> 不同，此纹理看起来会在黑暗中发光。</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="parameters" names="parameters 参数">
                <title>参数</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Emission Energy：</strong> （自发光能量）自发光纹理的亮度。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Modulate：</strong> （调制）将反射率和自发光贴图的颜色相乘。通过这种方式对贴花进行着色（例如，对于绘画贴花）或通过随机化每个贴花的调制来增加多样性。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Albedo Mix：</strong> （反照率混合）反照率纹理的不透明度。与使用具有更透明 alpha 通道的反照率纹理不同，将该值降低到 <literal>1.0</literal> 以下 <emphasis>不会</emphasis> 减少法线/ORM 纹理对下表面的影响。在创建仅普通/ORM 贴花（如足迹或湿水坑）时，将此值设置为 <literal>0.0</literal> 。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Normal Fade：</strong> （法线衰减）当贴花的 <abbreviation>AABB (Axis-Aligned Bounding Box, 轴对齐边界框)`与目标表面之间的角度变得过大时，贴花将会淡出。值为 ``0.0`</abbreviation> 时，不管角度如何都会投影出贴花，而值为 <literal>0.999</literal> 时，贴花将仅限于几乎垂直的表面。由于额外的法线角度计算，将 <strong>Normal Fade</strong> 设置为大于 <literal>0.0</literal> 的值会带来一些性能损耗。</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="vertical-fade" names="vertical\ fade 垂直淡化（vertical\ fade）">
                <title>垂直淡化（Vertical Fade）</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Upper Fade：</strong>（上部淡化）随着表面远离 <abbreviation explanation="Axis-Aligned Bounding Box 轴对齐边界框">AABB</abbreviation> 中心（朝向贴花的投影角），贴花将逐渐淡出的曲线。 只有正值才有效。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Lower Fade：</strong>（下部淡化）随着表面远离 <abbreviation explanation="Axis-Aligned Bounding Box, 轴对齐边界框">AABB</abbreviation> 中心（远离贴花的投影角），贴花将逐渐淡出的曲线。 只有正值才有效。</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="distance-fade" names="distance\ fade 距离淡出">
                <title>距离淡出</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Enabled（启用）：</strong>控制是否启用距离淡出（<abbreviation explanation="Level of Detail">LOD</abbreviation> 的一种形式）。 贴花将在 <strong>Begin + Length</strong> 内淡出，之后它将被剔除并且根本不会发送到着色器。 使用它可以减少场景中活动贴花的数量，从而提高性能。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Begin：</strong> （开始）贴花开始淡出时距相机的距离（以 3D 单位表示）。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Length：</strong> （长度）贴花淡出的距离（以 3D 单位表示）。 贴花在这段距离内逐渐变得透明，最后完全不可见。 值越高，淡出过渡越平滑，这在相机快速移动时更适合。</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="cull-mask" names="cull\ mask cull\ mask（剔除遮罩）">
                <title>Cull Mask（剔除遮罩）</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Cull Mask：</strong> （剔除遮罩）指定此贴花将投影到哪些 VisualInstance3D 图层。 默认情况下，贴花会影响所有图层。 使用它可以指定哪些类型的对象接收贴花，哪些类型不接收贴花。 这个功能特别有用，你可以确保动态对象不会意外收到针对其下方地形的贴花。</paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="decal-rendering-order" names="decal\ rendering\ order">
            <title>Decal rendering order</title>
            <paragraph>默认情况下，贴花的渲染顺序是基于他们的:abbr:<title_reference>AABB (Axis-Aligned Bounding Box)</title_reference> 和相机的距离排序的。距离相机更近的AABB会优先被渲染，这意味着如果有些贴花处于相同的位置，那贴花的渲染顺序有时会随相机位置的变化而变化。</paragraph>
            <paragraph>为解决贴花重叠导致的闪烁问题，你可以调整贴花Node检查器下的VisualInstance3D中的**Sorting Offset**属性。这个offset不是一个严格的优先级排序，而是一个*准则*，虽然渲染器会依据该准则决定渲染顺序，但贴花排序方式仍会受到AABB大小的影响。因此，offset值更高的贴花*总是*会被绘制在offset值更低的贴花上。</paragraph>
            <paragraph>如果你想让某个贴花总是渲染在其他贴花上，你需要将该贴花的**Sorting Offset**属性设置成正值，该值要大于可能与其重叠的其他最大贴花的AABB长度。相反，如果想让该贴花绘制在其他贴花后，将**Sorting Offset**设置为负值即可。</paragraph>
            <figure align="center" ids="id3">
                <image alt="不同VisualInstance3D Sorting Offset的贴花相比较" candidates="{'*': 'tutorials/3d/img/decals_sorting_offset.webp'}" uri="tutorials/3d/img/decals_sorting_offset.webp"></image>
                <caption>不同VisualInstance3D Sorting Offset的贴花相比较</caption>
            </figure>
        </section>
        <section ids="tweaking-performance-and-quality" names="tweaking\ performance\ and\ quality 调整性能和质量">
            <title>调整性能和质量</title>
            <paragraph>贴花渲染性能主要取决于其屏幕覆盖范围及其数量。 一般来说，覆盖大部分屏幕的一些大贴花的渲染消耗，会比散布在各处的许多小贴花的渲染消耗更高。</paragraph>
            <paragraph>要提高渲染性能，你可以如上所述启用 <strong>Distance Fade</strong> 属性。 这将使远处的贴花在远离相机时淡出（并且可能对最终场景渲染几乎没有影响）。 使用节点组，你还可以根据用户配置防止生成非必要的装饰贴花。</paragraph>
            <paragraph>贴花的渲染方式也会对性能产生影响。 <strong>渲染 &gt; 纹理 &gt; 贴花 &gt; 过滤</strong> 高级项目设置可让你控制如何过滤贴花纹理。 <strong>Nearest/Linear</strong> 不使用 mipmap。 然而，贴花在远处看起来会有颗粒感。 <strong>Nearest/Linear Mipmaps</strong> 在远处看起来会更平滑，但从倾斜角度观看时贴花会看起来模糊。 这可以通过使用 <strong>Nearest/Linear Mipmaps Anisotropic</strong> 来解决，它提供最高的质量，但渲染速度也较慢。</paragraph>
            <paragraph>如果你的项目具有像素艺术风格，请考虑将过滤设置为 <strong>Nearest</strong> 值之一（即具有 Nearest 属性的任意一个过滤），以便贴花使用最近邻过滤（nearest-neighbor filtering）。 否则，请继续使用 <strong>Linear</strong> 。</paragraph>
        </section>
        <section ids="limitations" names="limitations 限制">
            <title>限制</title>
            <paragraph>贴图不能影响除上面列出的材质特性之外的材质特性，例如高度（用于视差贴图）。</paragraph>
            <paragraph>出于性能方面的考虑，贴花使用的是完全固定的渲染逻辑，也就是说贴花无法使用自定义着色器。然而，投影面上的自定义着色器能够读取被贴花覆盖的信息，例如表面的粗糙度和金属性。</paragraph>
            <paragraph>在使用 Forward+ 渲染器时，Godot 采用 <emphasis>集群</emphasis> 方法进行贴花渲染。只要性能允许，可以添加任意数量的贴花。不过，默认情况下，当前摄像机视图中的 <emphasis>集群元素</emphasis> 上限仍为 512 个。集群元素是指全向灯、聚光灯、 <reference internal="True" refid="doc-using-decals"><inline classes="std std-ref">贴花</inline></reference> 或 <reference internal="True" refuri="global_illumination/reflection_probes#doc-reflection-probes"><inline classes="std std-ref">反射探针</inline></reference>。可以通过调整 "<strong>渲染 &gt; 限制 &gt; 群集生成器 &gt; 最大群集元素</strong>"高级项目设置来增加此限制。</paragraph>
            <paragraph>在使用 Forward 移动后端时，每个单独的 Mesh <emphasis>资源</emphasis> 上只能应用 8 个贴花。如果有更多贴花影响单个网格，则并非所有贴花都会渲染在网格上。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
