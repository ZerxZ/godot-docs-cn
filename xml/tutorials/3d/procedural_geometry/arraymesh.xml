<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/procedural_geometry/arraymesh.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-arraymesh"></target>
    <section ids="using-the-arraymesh doc-arraymesh" names="using\ the\ arraymesh 使用\ arraymesh doc_arraymesh">
        <title>使用 ArrayMesh</title>
        <paragraph>本教程将介绍使用 <reference internal="True" refuri="../../../classes/class_arraymesh#class-arraymesh"><inline classes="std std-ref">ArrayMesh</inline></reference> 的基础知识。</paragraph>
        <paragraph>为此，我们将使用函数 <reference internal="True" refuri="../../../classes/class_arraymesh#class-arraymesh-method-add-surface-from-arrays"><inline classes="std std-ref">add_surface_from_arrays()</inline></reference> ，它最多需要五个参数。前两个参数是必须的，后三个参数是可选的。</paragraph>
        <paragraph>第一个参数是 <literal>PrimitiveType</literal>（图元类型），这是 OpenGL 中的概念，用于指示 GPU 如何根据给定的顶点来安排图元，即它们表示的是三角形、线、还是点等等。可选项见 <reference internal="True" refuri="../../../classes/class_mesh#enum-mesh-primitivetype"><inline classes="std std-ref">Mesh.PrimitiveType</inline></reference>。</paragraph>
        <paragraph>第二个参数 <literal>arrays</literal> 是存储网格信息的实际 Array。该数组是一个普通的 Godot 数组，用空括号 <literal>[]</literal> 构造。它为每一种类型的信息存储一个 <literal>Packed**Array</literal>（如 PackedVector3Array、PackedInt32Array等），用于构建表面。</paragraph>
        <paragraph><literal>arrays</literal> 可能包含下列元素，另外还必须在 <literal>arrays</literal> 中包含位置信息。有关完整列表，另请参阅 <reference internal="True" refuri="../../../classes/class_mesh#enum-mesh-arraytype"><inline classes="std std-ref">Mesh.ArrayType</inline></reference>。</paragraph>
        <table classes="colwidths-auto wrap-normal" width="100%">
            <tgroup cols="3">
                <colspec colwidth="33"></colspec>
                <colspec colwidth="33"></colspec>
                <colspec colwidth="33"></colspec>
                <thead>
                    <row>
                        <entry>
                            <paragraph>索引</paragraph>
                        </entry>
                        <entry>
                            <paragraph>Mesh.ArrayType 枚举</paragraph>
                        </entry>
                        <entry>
                            <paragraph>数组类型</paragraph>
                        </entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <paragraph>0</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_VERTEX</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference> 或 <reference internal="True" refuri="../../../classes/class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>1</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_NORMAL</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>2</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_TANGENT</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference> 或 <reference internal="True" refuri="../../../classes/class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference> 4 个浮点数组。 前 3 个浮点数确定切线，最后一个浮点数确定副法线方向，即 -1 或 1。</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>3</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_COLOR</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedcolorarray#class-packedcolorarray"><inline classes="std std-ref">PackedColorArray</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>4</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_TEX_UV</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference> 或 <reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>5</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_TEX_UV2</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference> 或 <reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>10</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_BONES</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph>4 个 float 一组的 <reference internal="True" refuri="../../../classes/class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference> 或 4 个 int 一组的 <reference internal="True" refuri="../../../classes/class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference>。每一组都列出了影响某个特定顶点的 4 根骨骼。</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>11</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_WEIGHTS</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph>4 个 float 一组的 <reference internal="True" refuri="../../../classes/class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference> 或 <reference internal="True" refuri="../../../classes/class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference>。每个 float 都列出了给定顶点对 <literal>ARRAY_BONES</literal> 中特定骨骼的权重。</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>12</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_INDEX</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference></paragraph>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
        <paragraph>In most cases when creating a mesh, we define it by its vertex positions. So usually, the array of vertices (at index 0) is required, while the index array (at index 12) is optional and
            will only be used if included. It is also possible to create a mesh with only the index array and no vertex array, but that's beyond the scope of this tutorial.</paragraph>
        <paragraph>其他所有数组包含的都是关于顶点的信息。它们也是可选的，只有在包含时才会用到。有些数组（例如 <title_reference>ARRAY_COLOR`</title_reference>）用每个顶点一个元素的形式来提供额外的顶点信息。它们的大小必须与顶点数组一致。另一些数组（例如 <literal>ARRAY_TANGENT</literal>）用四个元素来描述一个顶点。它们必须正好是顶点数组的四倍。</paragraph>
        <paragraph>正常的使用场景下，<reference internal="True" refuri="../../../classes/class_arraymesh#class-arraymesh-method-add-surface-from-arrays"><inline classes="std std-ref">add_surface_from_arrays()</inline></reference> 的最后三个参数通常都是留空的。</paragraph>
        <section ids="setting-up-the-arraymesh" names="setting\ up\ the\ arraymesh 设置\ arraymesh">
            <title>设置 ArrayMesh</title>
            <paragraph>在编辑器中，创建一个 <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> ，并在检查器中为其添加一个 <reference internal="True" refuri="../../../classes/class_arraymesh#class-arraymesh"><inline classes="std std-ref">ArrayMesh</inline></reference>。通常，在编辑器里添加 ArrayMesh 没什么用，但这里可以让我们免去用代码创建的麻烦，直接使用这个 ArrayMesh。</paragraph>
            <paragraph>接下来，在 MeshInstance3D 上添加一个脚本。</paragraph>
            <paragraph>在 <literal>_ready()</literal> 下创建一个新的数组。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var surface_array = []</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var surfaceArray = new Godot.Collections.Array();</literal_block>
                </div>
            </container>
            <paragraph>这将是保存表面信息的数组——将保存表面需要的所有数据数组。Godot 希望它的大小是 <literal>Mesh.ARRAY_MAX</literal>，所以要相应地调整。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var surface_array = []
surface_array.resize(Mesh.ARRAY_MAX)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var surfaceArray = new Godot.Collections.Array();
surfaceArray.Resize((int)Mesh.ArrayType.Max);</literal_block>
                </div>
            </container>
            <paragraph>接下来, 为你将使用的每种数据类型创建数组.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var verts = PackedVector3Array()
var uvs = PackedVector2Array()
var normals = PackedVector3Array()
var indices = PackedInt32Array()</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var verts = new List&lt;Vector3&gt;();
var uvs = new List&lt;Vector2&gt;();
var normals = new List&lt;Vector3&gt;();
var indices = new List&lt;int&gt;();</literal_block>
                </div>
            </container>
            <paragraph>一旦你用几何体填充了你的数据数组, 就可以通过将每个数组添加到 <literal>surface_array</literal> , 然后提交到网格中来创建网格.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">surface_array[Mesh.ARRAY_VERTEX] = verts
surface_array[Mesh.ARRAY_TEX_UV] = uvs
surface_array[Mesh.ARRAY_NORMAL] = normals
surface_array[Mesh.ARRAY_INDEX] = indices

# No blendshapes, lods, or compression used.
mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, surface_array)</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">surfaceArray[(int)Mesh.ArrayType.Vertex] = verts.ToArray();
surfaceArray[(int)Mesh.ArrayType.TexUV] = uvs.ToArray();
surfaceArray[(int)Mesh.ArrayType.Normal] = normals.ToArray();
surfaceArray[(int)Mesh.ArrayType.Index] = indices.ToArray();

var arrMesh = Mesh as ArrayMesh;
if (arrMesh != null)
{
    // No blendshapes, lods, or compression used.
    arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph>在这个例子中，使用了 <literal>Mesh.PRIMITIVE_TRIANGLES</literal>，但你也可以使用网格所提供的任何图元类型。</paragraph>
            </note>
            <paragraph>把这些放到一起，完整的代码是这样的：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends MeshInstance3D

func _ready():
    var surface_array = []
    surface_array.resize(Mesh.ARRAY_MAX)

    # PackedVector**Arrays for mesh construction.
    var verts = PackedVector3Array()
    var uvs = PackedVector2Array()
    var normals = PackedVector3Array()
    var indices = PackedInt32Array()

    #######################################
    ## Insert code here to generate mesh ##
    #######################################

    # Assign arrays to surface array.
    surface_array[Mesh.ARRAY_VERTEX] = verts
    surface_array[Mesh.ARRAY_TEX_UV] = uvs
    surface_array[Mesh.ARRAY_NORMAL] = normals
    surface_array[Mesh.ARRAY_INDEX] = indices

    # Create mesh surface from mesh array.
    # No blendshapes, lods, or compression used.
    mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, surface_array)</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public partial class MyMeshInstance3D : MeshInstance3D
{
    public override void _Ready()
    {
        var surfaceArray = new Godot.Collections.Array();
        surfaceArray.Resize((int)Mesh.ArrayType.Max);

        // C# arrays cannot be resized or expanded, so use Lists to create geometry.
        var verts = new List&lt;Vector3&gt;();
        var uvs = new List&lt;Vector2&gt;();
        var normals = new List&lt;Vector3&gt;();
        var indices = new List&lt;int&gt;();

        /***********************************
        * Insert code here to generate mesh.
        * *********************************/

        // Convert Lists to arrays and assign to surface array
        surfaceArray[(int)Mesh.ArrayType.Vertex] = verts.ToArray();
        surfaceArray[(int)Mesh.ArrayType.TexUV] = uvs.ToArray();
        surfaceArray[(int)Mesh.ArrayType.Normal] = normals.ToArray();
        surfaceArray[(int)Mesh.ArrayType.Index] = indices.ToArray();

        var arrMesh = Mesh as ArrayMesh;
        if (arrMesh != null)
        {
            // Create mesh surface from mesh array
            // No blendshapes, lods, or compression used.
            arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>中间可以放你想要的任何代码。下面我们会给出一些示例代码，用于生成球体。</paragraph>
        </section>
        <section ids="generating-geometry" names="generating\ geometry 生成几何体">
            <title>生成几何体</title>
            <paragraph>这是生成球体的示例代码。尽管代码是用 GDScript 编写的，但是 Godot 并没有指定用特定的方式来实现它。这种实现方式与 ArrayMesh 无关，仅仅是一种通用的生成球体的方式。如果你觉得这比较难以理解，或者想更全面地了解程序式几何体，可以在网上寻找相关的教程进行学习。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends MeshInstance3D

var rings = 50
var radial_segments = 50
var radius = 1

func _ready():

    # Insert setting up the PackedVector**Arrays here.

    # Vertex indices.
    var thisrow = 0
    var prevrow = 0
    var point = 0

    # Loop over rings.
    for i in range(rings + 1):
        var v = float(i) / rings
        var w = sin(PI * v)
        var y = cos(PI * v)

        # Loop over segments in ring.
        for j in range(radial_segments + 1):
            var u = float(j) / radial_segments
            var x = sin(u * PI * 2.0)
            var z = cos(u * PI * 2.0)
            var vert = Vector3(x * radius * w, y * radius, z * radius * w)
            verts.append(vert)
            normals.append(vert.normalized())
            uvs.append(Vector2(u, v))
            point += 1

            # Create triangles in ring using indices.
            if i &gt; 0 and j &gt; 0:
                indices.append(prevrow + j - 1)
                indices.append(prevrow + j)
                indices.append(thisrow + j - 1)

                indices.append(prevrow + j)
                indices.append(thisrow + j)
                indices.append(thisrow + j - 1)

        prevrow = thisrow
        thisrow = point

  # Insert committing to the ArrayMesh here.</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public partial class MyMeshInstance3D : MeshInstance3D
{
    private int _rings = 50;
    private int _radialSegments = 50;
    private float _radius = 1;

    public override void _Ready()
    {
        // Insert setting up the surface array and lists here.

        // Vertex indices.
        var thisRow = 0;
        var prevRow = 0;
        var point = 0;

        // Loop over rings.
        for (var i = 0; i &lt; _rings + 1; i++)
        {
            var v = ((float)i) / _rings;
            var w = Mathf.Sin(Mathf.Pi * v);
            var y = Mathf.Cos(Mathf.Pi * v);

            // Loop over segments in ring.
            for (var j = 0; j &lt; _radialSegments + 1; j++)
            {
                var u = ((float)j) / _radialSegments;
                var x = Mathf.Sin(u * Mathf.Pi * 2);
                var z = Mathf.Cos(u * Mathf.Pi * 2);
                var vert = new Vector3(x * _radius * w, y * _radius, z * _radius * w);
                verts.Add(vert);
                normals.Add(vert.Normalized());
                uvs.Add(new Vector2(u, v));
                point += 1;

                // Create triangles in ring using indices.
                if (i &gt; 0 &amp;&amp; j &gt; 0)
                {
                    indices.Add(prevRow + j - 1);
                    indices.Add(prevRow + j);
                    indices.Add(thisRow + j - 1);

                    indices.Add(prevRow + j);
                    indices.Add(thisRow + j);
                    indices.Add(thisRow + j - 1);
                }
            }

            prevRow = thisRow;
            thisRow = point;
        }

        // Insert committing to the ArrayMesh here.
    }
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="saving" names="saving 保存">
            <title>保存</title>
            <paragraph>最后，我们可以使用 <reference internal="True" refuri="../../../classes/class_resourcesaver#class-resourcesaver"><inline classes="std std-ref">ResourceSaver</inline></reference> 类来保存该 ArrayMesh。当你想生成一个网格，然后在以后使用它而不需要重新生成时，这个方法很有用。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Saves mesh to a .tres file with compression enabled.
ResourceSaver.save(mesh, "res://sphere.tres", ResourceSaver.FLAG_COMPRESS)</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Saves mesh to a .tres file with compression enabled.
ResourceSaver.Save(Mesh, "res://sphere.tres", ResourceSaver.SaverFlags.Compress);</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
