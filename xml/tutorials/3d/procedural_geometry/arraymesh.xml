<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/procedural_geometry/arraymesh.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-arraymesh"></target>
    <section ids="using-the-arraymesh doc-arraymesh" names="using\ the\ arraymesh doc_arraymesh">
        <title>Using the ArrayMesh</title>
        <paragraph>This tutorial will present the basics of using an <reference internal="True" refuri="../../../classes/class_arraymesh#class-arraymesh"><inline classes="std std-ref">ArrayMesh</inline></reference>.</paragraph>
        <paragraph>To do so, we will use the function <reference internal="True" refuri="../../../classes/class_arraymesh#class-arraymesh-method-add-surface-from-arrays"><inline classes="std std-ref">add_surface_from_arrays()</inline></reference>,
            which takes up to five parameters. The first two are required, while the last three are optional.</paragraph>
        <paragraph>The first parameter is the <literal>PrimitiveType</literal>, an OpenGL concept that instructs the GPU
            how to arrange the primitive based on the vertices given, i.e. whether they represent triangles,
            lines, points, etc. See <reference internal="True" refuri="../../../classes/class_mesh#enum-mesh-primitivetype"><inline classes="std std-ref">Mesh.PrimitiveType</inline></reference> for the options available.</paragraph>
        <paragraph>The second parameter, <literal>arrays</literal>, is the actual Array that stores the mesh information. The array is a normal Godot array that
            is constructed with empty brackets <literal>[]</literal>. It stores a <literal>Packed**Array</literal> (e.g. PackedVector3Array,
            PackedInt32Array, etc.) for each type of information that will be used to build the surface.</paragraph>
        <paragraph>Common elements of <literal>arrays</literal> are listed below, together with the position they must have within <literal>arrays</literal>.
            See <reference internal="True" refuri="../../../classes/class_mesh#enum-mesh-arraytype"><inline classes="std std-ref">Mesh.ArrayType</inline></reference> for a full list.</paragraph>
        <table classes="colwidths-auto wrap-normal" width="100%">
            <tgroup cols="3">
                <colspec colwidth="33"></colspec>
                <colspec colwidth="33"></colspec>
                <colspec colwidth="33"></colspec>
                <thead>
                    <row>
                        <entry>
                            <paragraph>Index</paragraph>
                        </entry>
                        <entry>
                            <paragraph>Mesh.ArrayType Enum</paragraph>
                        </entry>
                        <entry>
                            <paragraph>Array type</paragraph>
                        </entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <paragraph>0</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_VERTEX</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference> or <reference internal="True" refuri="../../../classes/class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>1</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_NORMAL</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>2</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_TANGENT</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference> or <reference internal="True" refuri="../../../classes/class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference> of groups of 4 floats. The first 3 floats determine the tangent, and the last float the binormal
                                direction as -1 or 1.</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>3</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_COLOR</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedcolorarray#class-packedcolorarray"><inline classes="std std-ref">PackedColorArray</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>4</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_TEX_UV</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference> or <reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>5</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_TEX_UV2</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference> or <reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>10</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_BONES</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference> of groups of 4 floats or <reference internal="True" refuri="../../../classes/class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference> of groups of 4 ints. Each group lists indexes of 4 bones that affects a given vertex.</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>11</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_WEIGHTS</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference> or <reference internal="True" refuri="../../../classes/class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference> of groups of 4 floats. Each float lists the amount of weight the corresponding bone in <literal>ARRAY_BONES</literal> has on a given vertex.</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>12</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_INDEX</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference></paragraph>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
        <paragraph>In most cases when creating a mesh, we define it by its vertex positions. So usually, the array of vertices (at index 0) is required, while the index array (at index 12) is optional and
            will only be used if included. It is also possible to create a mesh with only the index array and no vertex array, but that's beyond the scope of this tutorial.</paragraph>
        <paragraph>All the other arrays carry information about the vertices. They are optional and will only be used if included. Some of these arrays (e.g. <literal>ARRAY_COLOR</literal>)
            use one entry per vertex to provide extra information about vertices. They must have the same size as the vertex array. Other arrays (e.g. <literal>ARRAY_TANGENT</literal>) use
            four entries to describe a single vertex. These must be exactly four times larger than the vertex array.</paragraph>
        <paragraph>For normal usage, the last three parameters in <reference internal="True" refuri="../../../classes/class_arraymesh#class-arraymesh-method-add-surface-from-arrays"><inline classes="std std-ref">add_surface_from_arrays()</inline></reference> are typically left empty.</paragraph>
        <section ids="setting-up-the-arraymesh" names="setting\ up\ the\ arraymesh">
            <title>Setting up the ArrayMesh</title>
            <paragraph>In the editor, create a <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> and add an <reference internal="True" refuri="../../../classes/class_arraymesh#class-arraymesh"><inline classes="std std-ref">ArrayMesh</inline></reference> to it in the Inspector.
                Normally, adding an ArrayMesh in the editor is not useful, but in this case it allows us to access the ArrayMesh
                from code without creating one.</paragraph>
            <paragraph>Next, add a script to the MeshInstance3D.</paragraph>
            <paragraph>Under <literal>_ready()</literal>, create a new Array.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var surface_array = []</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Godot.Collections.Array surfaceArray = [];</literal_block>
                </div>
            </container>
            <paragraph>This will be the array that we keep our surface information in - it will hold
                all the arrays of data that the surface needs. Godot will expect it to be of
                size <literal>Mesh.ARRAY_MAX</literal>, so resize it accordingly.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var surface_array = []
surface_array.resize(Mesh.ARRAY_MAX)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Godot.Collections.Array surfaceArray = [];
surfaceArray.Resize((int)Mesh.ArrayType.Max);</literal_block>
                </div>
            </container>
            <paragraph>Next create the arrays for each data type you will use.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var verts = PackedVector3Array()
var uvs = PackedVector2Array()
var normals = PackedVector3Array()
var indices = PackedInt32Array()</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">List&lt;Vector3&gt; verts = [];
List&lt;Vector2&gt; uvs = [];
List&lt;Vector3&gt; normals = [];
List&lt;int&gt; indices = [];</literal_block>
                </div>
            </container>
            <paragraph>Once you have filled your data arrays with your geometry you can create a mesh
                by adding each array to <literal>surface_array</literal> and then committing to the mesh.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">surface_array[Mesh.ARRAY_VERTEX] = verts
surface_array[Mesh.ARRAY_TEX_UV] = uvs
surface_array[Mesh.ARRAY_NORMAL] = normals
surface_array[Mesh.ARRAY_INDEX] = indices

# No blendshapes, lods, or compression used.
mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, surface_array)</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">surfaceArray[(int)Mesh.ArrayType.Vertex] = verts.ToArray();
surfaceArray[(int)Mesh.ArrayType.TexUV] = uvs.ToArray();
surfaceArray[(int)Mesh.ArrayType.Normal] = normals.ToArray();
surfaceArray[(int)Mesh.ArrayType.Index] = indices.ToArray();

var arrMesh = Mesh as ArrayMesh;
if (arrMesh != null)
{
    // No blendshapes, lods, or compression used.
    arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph>In this example, we used <literal>Mesh.PRIMITIVE_TRIANGLES</literal>, but you can use any primitive type
                    available from mesh.</paragraph>
            </note>
            <paragraph>Put together, the full code looks like:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends MeshInstance3D

func _ready():
    var surface_array = []
    surface_array.resize(Mesh.ARRAY_MAX)

    # PackedVector**Arrays for mesh construction.
    var verts = PackedVector3Array()
    var uvs = PackedVector2Array()
    var normals = PackedVector3Array()
    var indices = PackedInt32Array()

    #######################################
    ## Insert code here to generate mesh ##
    #######################################

    # Assign arrays to surface array.
    surface_array[Mesh.ARRAY_VERTEX] = verts
    surface_array[Mesh.ARRAY_TEX_UV] = uvs
    surface_array[Mesh.ARRAY_NORMAL] = normals
    surface_array[Mesh.ARRAY_INDEX] = indices

    # Create mesh surface from mesh array.
    # No blendshapes, lods, or compression used.
    mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, surface_array)</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public partial class MyMeshInstance3D : MeshInstance3D
{
    public override void _Ready()
    {
        Godot.Collections.Array surfaceArray = [];
        surfaceArray.Resize((int)Mesh.ArrayType.Max);

        // C# arrays cannot be resized or expanded, so use Lists to create geometry.
        List&lt;Vector3&gt; verts = [];
        List&lt;Vector2&gt; uvs = [];
        List&lt;Vector3&gt; normals = [];
        List&lt;int&gt; indices = [];

        /***********************************
        * Insert code here to generate mesh.
        * *********************************/

        // Convert Lists to arrays and assign to surface array
        surfaceArray[(int)Mesh.ArrayType.Vertex] = verts.ToArray();
        surfaceArray[(int)Mesh.ArrayType.TexUV] = uvs.ToArray();
        surfaceArray[(int)Mesh.ArrayType.Normal] = normals.ToArray();
        surfaceArray[(int)Mesh.ArrayType.Index] = indices.ToArray();

        var arrMesh = Mesh as ArrayMesh;
        if (arrMesh != null)
        {
            // Create mesh surface from mesh array
            // No blendshapes, lods, or compression used.
            arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>The code that goes in the middle can be whatever you want. Below we will present some
                example code for generating shapes, starting with a rectangle.</paragraph>
        </section>
        <section ids="generating-a-rectangle" names="generating\ a\ rectangle">
            <title>Generating a rectangle</title>
            <paragraph>Since we are using <literal>Mesh.PRIMITIVE_TRIANGLES</literal> to render, we will construct a rectangle
                with triangles.</paragraph>
            <paragraph>A rectangle is formed by two triangles sharing four vertices. For our example, we will create
                a rectangle with its top left point at <literal>(0, 0, 0)</literal> with a width and length of one as shown below:</paragraph>
            <image alt="A rectangle made of two triangles sharing four vertices." candidates="{'*': 'tutorials/3d/procedural_geometry/img/array_mesh_rectangle_as_triangles.webp'}" original_uri="img/array_mesh_rectangle_as_triangles.webp" scale="33" uri="tutorials/3d/procedural_geometry/img/array_mesh_rectangle_as_triangles.webp"></image>
            <paragraph>To draw this rectangle, define the coordinates of each vertex in the <literal>verts</literal> array.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">verts = PackedVector3Array([
        Vector3(0, 0, 0),
        Vector3(0, 0, 1),
        Vector3(1, 0, 0),
        Vector3(1, 0, 1),
    ])</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">verts.AddRange(new Vector3[]
{
    new Vector3(0, 0, 0),
    new Vector3(0, 0, 1),
    new Vector3(1, 0, 0),
    new Vector3(1, 0, 1),
});</literal_block>
                </div>
            </container>
            <paragraph>The <literal>uvs</literal> array helps describe where parts of a texture should go onto the mesh. The values
                range from 0 to 1. Depending on your texture, you may want to change these values.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">uvs = PackedVector2Array([
        Vector2(0, 0),
        Vector2(1, 0),
        Vector2(0, 1),
        Vector2(1, 1),
    ])</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">uvs.AddRange(new Vector2[]
{
    new Vector2(0, 0),
    new Vector2(1, 0),
    new Vector2(0, 1),
    new Vector2(1, 1),
});</literal_block>
                </div>
            </container>
            <paragraph>The <literal>normals</literal> array is used to describe the direction the vertices face and is
                used in lighting calculations. For this example, we will default to the <literal>Vector3.UP</literal>
                direction.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">normals = PackedVector3Array([
        Vector3.UP,
        Vector3.UP,
        Vector3.UP,
        Vector3.UP,
    ])</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">normals.AddRange(new Vector3[]
{
    Vector3.Up,
    Vector3.Up,
    Vector3.Up,
    Vector3.Up,
});</literal_block>
                </div>
            </container>
            <paragraph>The <literal>indices</literal> array defines the order vertices are drawn. Godot
                renders in a <emphasis>clockwise</emphasis> direction, meaning that we must specify the vertices
                of a triangle we want to draw in clockwise order.</paragraph>
            <paragraph>For example, to draw the first triangle, we will want to draw the vertices <literal>(0, 0, 0)</literal>,
                <literal>(1, 0, 0)</literal>, and <literal>(0, 0, 1)</literal> in that order. This is the same as drawing <literal>vert[0]</literal>, <literal>vert[2]</literal>, and
                <literal>vert[1]</literal>, i.e., indices 0, 2, and 1, in the <literal>verts</literal> array. These index values are what the
                <literal>indices</literal> array defines.</paragraph>
            <table classes="colwidths-auto">
                <tgroup cols="4">
                    <colspec colwidth="25"></colspec>
                    <colspec colwidth="25"></colspec>
                    <colspec colwidth="25"></colspec>
                    <colspec colwidth="25"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Index</paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>verts[Index]</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>uvs[Index]</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>normals[Index]</literal></paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>0</paragraph>
                            </entry>
                            <entry>
                                <paragraph>(0, 0, 0)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>(0, 0)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Vector3.UP</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>1</paragraph>
                            </entry>
                            <entry>
                                <paragraph>(0, 0, 1)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>(1, 0)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Vector3.UP</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>2</paragraph>
                            </entry>
                            <entry>
                                <paragraph>(1, 0, 0)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>(0, 1)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Vector3.UP</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>3</paragraph>
                            </entry>
                            <entry>
                                <paragraph>(1, 0, 1)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>(1, 1)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Vector3.UP</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">indices = PackedInt32Array([
        0, 2, 1, # Draw the first triangle.
        2, 3, 1, # Draw the second triangle.
    ])</literal_block>
                </div>
                <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">indices.AddRange(new int[]
{
    0, 2, 1, // Draw the first triangle.
    2, 3, 1, // Draw the second triangle.
});</literal_block>
                </div>
            </container>
            <paragraph>Put together, the rectangle generation code looks like:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends MeshInstance3D

func _ready():

  # Insert setting up the PackedVector**Arrays here.

  verts = PackedVector3Array([
          Vector3(0, 0, 0),
          Vector3(0, 0, 1),
          Vector3(1, 0, 0),
          Vector3(1, 0, 1),
      ])

  uvs = PackedVector2Array([
          Vector2(0, 0),
          Vector2(1, 0),
          Vector2(0, 1),
          Vector2(1, 1),
      ])

  normals = PackedVector3Array([
          Vector3.UP,
          Vector3.UP,
          Vector3.UP,
          Vector3.UP,
      ])

  indices = PackedInt32Array([
          0, 2, 1,
          2, 3, 1,
      ])

  # Insert committing to the ArrayMesh here.</literal_block>
                </div>
                <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using System.Collections.Generic;

public partial class MeshInstance3d : MeshInstance3D
{
  public override void _Ready()
  {
      // Insert setting up the surface array and lists here.

      verts.AddRange(new Vector3[]
      {
          new Vector3(0, 0, 0),
          new Vector3(0, 0, 1),
          new Vector3(1, 0, 0),
          new Vector3(1, 0, 1),
      });

      uvs.AddRange(new Vector2[]
      {
          new Vector2(0, 0),
          new Vector2(1, 0),
          new Vector2(0, 1),
          new Vector2(1, 1),
      });

      normals.AddRange(new Vector3[]
      {
          Vector3.Up,
          Vector3.Up,
          Vector3.Up,
          Vector3.Up,
      });

      indices.AddRange(new int[]
      {
          0, 2, 1,
          2, 3, 1,
      });

      // Insert committing to the ArrayMesh here.
  }
}</literal_block>
                </div>
            </container>
            <paragraph>For a more complex example, see the sphere generation section below.</paragraph>
        </section>
        <section ids="generating-a-sphere" names="generating\ a\ sphere">
            <title>Generating a sphere</title>
            <paragraph>Here is sample code for generating a sphere. Although the code is presented in
                GDScript, there is nothing Godot specific about the approach to generating it.
                This implementation has nothing in particular to do with ArrayMeshes and is just a
                generic approach to generating a sphere. If you are having trouble understanding it
                or want to learn more about procedural geometry in general, you can use any tutorial
                that you find online.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-10-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-10-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-10-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends MeshInstance3D

var rings = 50
var radial_segments = 50
var radius = 1

func _ready():

    # Insert setting up the PackedVector**Arrays here.

    # Vertex indices.
    var thisrow = 0
    var prevrow = 0
    var point = 0

    # Loop over rings.
    for i in range(rings + 1):
        var v = float(i) / rings
        var w = sin(PI * v)
        var y = cos(PI * v)

        # Loop over segments in ring.
        for j in range(radial_segments + 1):
            var u = float(j) / radial_segments
            var x = sin(u * PI * 2.0)
            var z = cos(u * PI * 2.0)
            var vert = Vector3(x * radius * w, y * radius, z * radius * w)
            verts.append(vert)
            normals.append(vert.normalized())
            uvs.append(Vector2(u, v))
            point += 1

            # Create triangles in ring using indices.
            if i &gt; 0 and j &gt; 0:
                indices.append(prevrow + j - 1)
                indices.append(prevrow + j)
                indices.append(thisrow + j - 1)

                indices.append(prevrow + j)
                indices.append(thisrow + j)
                indices.append(thisrow + j - 1)

        prevrow = thisrow
        thisrow = point

  # Insert committing to the ArrayMesh here.</literal_block>
                </div>
                <div aria-labelledby="tab-10-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-10-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public partial class MyMeshInstance3D : MeshInstance3D
{
    private int _rings = 50;
    private int _radialSegments = 50;
    private float _radius = 1;

    public override void _Ready()
    {
        // Insert setting up the surface array and lists here.

        // Vertex indices.
        var thisRow = 0;
        var prevRow = 0;
        var point = 0;

        // Loop over rings.
        for (var i = 0; i &lt; _rings + 1; i++)
        {
            var v = ((float)i) / _rings;
            var w = Mathf.Sin(Mathf.Pi * v);
            var y = Mathf.Cos(Mathf.Pi * v);

            // Loop over segments in ring.
            for (var j = 0; j &lt; _radialSegments + 1; j++)
            {
                var u = ((float)j) / _radialSegments;
                var x = Mathf.Sin(u * Mathf.Pi * 2);
                var z = Mathf.Cos(u * Mathf.Pi * 2);
                var vert = new Vector3(x * _radius * w, y * _radius, z * _radius * w);
                verts.Add(vert);
                normals.Add(vert.Normalized());
                uvs.Add(new Vector2(u, v));
                point += 1;

                // Create triangles in ring using indices.
                if (i &gt; 0 &amp;&amp; j &gt; 0)
                {
                    indices.Add(prevRow + j - 1);
                    indices.Add(prevRow + j);
                    indices.Add(thisRow + j - 1);

                    indices.Add(prevRow + j);
                    indices.Add(thisRow + j);
                    indices.Add(thisRow + j - 1);
                }
            }

            prevRow = thisRow;
            thisRow = point;
        }

        // Insert committing to the ArrayMesh here.
    }
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="saving" names="saving">
            <title>Saving</title>
            <paragraph>Finally, we can use the <reference internal="True" refuri="../../../classes/class_resourcesaver#class-resourcesaver"><inline classes="std std-ref">ResourceSaver</inline></reference> class to save the ArrayMesh.
                This is useful when you want to generate a mesh and then use it later without having to re-generate it.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-11-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-11-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-11-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Saves mesh to a .tres file with compression enabled.
ResourceSaver.save(mesh, "res://sphere.tres", ResourceSaver.FLAG_COMPRESS)</literal_block>
                </div>
                <div aria-labelledby="tab-11-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-11-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Saves mesh to a .tres file with compression enabled.
ResourceSaver.Save(Mesh, "res://sphere.tres", ResourceSaver.SaverFlags.Compress);</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
