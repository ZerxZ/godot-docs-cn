<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/procedural_geometry/arraymesh.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-arraymesh"></target>
    <section ids="using-the-arraymesh doc-arraymesh" names="using\ the\ arraymesh 使用\ arraymesh doc_arraymesh">
        <title>使用 ArrayMesh</title>
        <paragraph>本教程将介绍使用 <reference internal="True" refuri="../../../classes/class_arraymesh#class-arraymesh"><inline classes="std std-ref">ArrayMesh</inline></reference> 的基础知识。</paragraph>
        <paragraph>为此，我们将使用函数 <reference internal="True" refuri="../../../classes/class_arraymesh#class-arraymesh-method-add-surface-from-arrays"><inline classes="std std-ref">add_surface_from_arrays()</inline></reference> ，它最多需要五个参数。前两个参数是必须的，后三个参数是可选的。</paragraph>
        <paragraph>第一个参数是 <literal>PrimitiveType</literal>（图元类型），这是 OpenGL 中的概念，用于指示 GPU 如何根据给定的顶点来安排图元，即它们表示的是三角形、线、还是点等等。可选项见 <reference internal="True" refuri="../../../classes/class_mesh#enum-mesh-primitivetype"><inline classes="std std-ref">Mesh.PrimitiveType</inline></reference>。</paragraph>
        <paragraph>第二个参数 <literal>arrays</literal> 是存储网格信息的实际 Array。该数组是一个普通的 Godot 数组，用空括号 <literal>[]</literal> 构造。它为每一种类型的信息存储一个 <literal>Packed**Array</literal>（如 PackedVector3Array、PackedInt32Array等），用于构建表面。</paragraph>
        <paragraph><literal>arrays</literal> 可能包含下列元素，另外还必须在 <literal>arrays</literal> 中包含位置信息。有关完整列表，另请参阅 <reference internal="True" refuri="../../../classes/class_mesh#enum-mesh-arraytype"><inline classes="std std-ref">Mesh.ArrayType</inline></reference>。</paragraph>
        <table classes="colwidths-auto wrap-normal" width="100%">
            <tgroup cols="3">
                <colspec colwidth="33"></colspec>
                <colspec colwidth="33"></colspec>
                <colspec colwidth="33"></colspec>
                <thead>
                    <row>
                        <entry>
                            <paragraph>索引</paragraph>
                        </entry>
                        <entry>
                            <paragraph>Mesh.ArrayType 枚举</paragraph>
                        </entry>
                        <entry>
                            <paragraph>数组类型</paragraph>
                        </entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>
                            <paragraph>0</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_VERTEX</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference> 或 <reference internal="True" refuri="../../../classes/class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>1</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_NORMAL</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>2</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_TANGENT</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference> 或 <reference internal="True" refuri="../../../classes/class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference> 4 个浮点数组。 前 3 个浮点数确定切线，最后一个浮点数确定副法线方向，即 -1 或 1。</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>3</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_COLOR</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedcolorarray#class-packedcolorarray"><inline classes="std std-ref">PackedColorArray</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>4</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_TEX_UV</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference> 或 <reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>5</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_TEX_UV2</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference> 或 <reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference></paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>10</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_BONES</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph>4 个 float 一组的 <reference internal="True" refuri="../../../classes/class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference> 或 4 个 int 一组的 <reference internal="True" refuri="../../../classes/class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference>。每一组都列出了影响某个特定顶点的 4 根骨骼。</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>11</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_WEIGHTS</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph>4 个 float 一组的 <reference internal="True" refuri="../../../classes/class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference> 或 <reference internal="True" refuri="../../../classes/class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference>。每个 float 都列出了给定顶点对 <literal>ARRAY_BONES</literal> 中特定骨骼的权重。</paragraph>
                        </entry>
                    </row>
                    <row>
                        <entry>
                            <paragraph>12</paragraph>
                        </entry>
                        <entry>
                            <paragraph><literal>ARRAY_INDEX</literal></paragraph>
                        </entry>
                        <entry>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference></paragraph>
                        </entry>
                    </row>
                </tbody>
            </tgroup>
        </table>
        <paragraph>在大多数情况下，创建网格时，我们通过顶点位置来定义网格。因此，顶点数组（位于索引 0 处）通常是必需的，而索引数组（位于索引 12 处）是可选的，只有在它被包含时才会使用。也可以只创建索引数组而不创建顶点数组，但这超出了本教程的范围。事实上，我们根本不会使用索引数组。</paragraph>
        <paragraph>其他所有数组包含的都是关于顶点的信息。它们也是可选的，只有在包含时才会用到。有些数组（例如 <title_reference>ARRAY_COLOR`</title_reference>）用每个顶点一个元素的形式来提供额外的顶点信息。它们的大小必须与顶点数组一致。另一些数组（例如 <literal>ARRAY_TANGENT</literal>）用四个元素来描述一个顶点。它们必须正好是顶点数组的四倍。</paragraph>
        <paragraph>正常的使用场景下，<reference internal="True" refuri="../../../classes/class_arraymesh#class-arraymesh-method-add-surface-from-arrays"><inline classes="std std-ref">add_surface_from_arrays()</inline></reference> 的最后三个参数通常都是留空的。</paragraph>
        <section ids="setting-up-the-arraymesh" names="setting\ up\ the\ arraymesh 设置\ arraymesh">
            <title>设置 ArrayMesh</title>
            <paragraph>在编辑器中，创建一个 <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> ，并在检查器中为其添加一个 <reference internal="True" refuri="../../../classes/class_arraymesh#class-arraymesh"><inline classes="std std-ref">ArrayMesh</inline></reference>。通常，在编辑器里添加 ArrayMesh 没什么用，但这里可以让我们免去用代码创建的麻烦，直接使用这个 ArrayMesh。</paragraph>
            <paragraph>接下来，在 MeshInstance3D 上添加一个脚本。</paragraph>
            <paragraph>在 <literal>_ready()</literal> 下创建一个新的数组。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var surface_array = []</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var surfaceArray = new Godot.Collections.Array();</literal_block>
                </div>
            </container>
            <paragraph>这将是保存表面信息的数组——将保存表面需要的所有数据数组。Godot 希望它的大小是 <literal>Mesh.ARRAY_MAX</literal>，所以要相应地调整。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var surface_array = []
surface_array.resize(Mesh.ARRAY_MAX)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var surfaceArray = new Godot.Collections.Array();
surfaceArray.Resize((int)Mesh.ArrayType.Max);</literal_block>
                </div>
            </container>
            <paragraph>接下来, 为你将使用的每种数据类型创建数组.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var verts = PackedVector3Array()
var uvs = PackedVector2Array()
var normals = PackedVector3Array()
var indices = PackedInt32Array()</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var verts = new List&lt;Vector3&gt;();
var uvs = new List&lt;Vector2&gt;();
var normals = new List&lt;Vector3&gt;();
var indices = new List&lt;int&gt;();</literal_block>
                </div>
            </container>
            <paragraph>一旦你用几何体填充了你的数据数组, 就可以通过将每个数组添加到 <literal>surface_array</literal> , 然后提交到网格中来创建网格.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">surface_array[Mesh.ARRAY_VERTEX] = verts
surface_array[Mesh.ARRAY_TEX_UV] = uvs
surface_array[Mesh.ARRAY_NORMAL] = normals
surface_array[Mesh.ARRAY_INDEX] = indices

# No blendshapes, lods, or compression used.
mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, surface_array)</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">surfaceArray[(int)Mesh.ArrayType.Vertex] = verts.ToArray();
surfaceArray[(int)Mesh.ArrayType.TexUV] = uvs.ToArray();
surfaceArray[(int)Mesh.ArrayType.Normal] = normals.ToArray();
surfaceArray[(int)Mesh.ArrayType.Index] = indices.ToArray();

var arrMesh = Mesh as ArrayMesh;
if (arrMesh != null)
{
    // No blendshapes, lods, or compression used.
    arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph>在这个例子中，使用了 <literal>Mesh.PRIMITIVE_TRIANGLES</literal>，但你也可以使用网格所提供的任何图元类型。</paragraph>
            </note>
            <paragraph>把这些放到一起，完整的代码是这样的：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends MeshInstance3D

func _ready():
    var surface_array = []
    surface_array.resize(Mesh.ARRAY_MAX)

    # PackedVector**Arrays for mesh construction.
    var verts = PackedVector3Array()
    var uvs = PackedVector2Array()
    var normals = PackedVector3Array()
    var indices = PackedInt32Array()

    #######################################
    ## Insert code here to generate mesh ##
    #######################################

    # Assign arrays to surface array.
    surface_array[Mesh.ARRAY_VERTEX] = verts
    surface_array[Mesh.ARRAY_TEX_UV] = uvs
    surface_array[Mesh.ARRAY_NORMAL] = normals
    surface_array[Mesh.ARRAY_INDEX] = indices

    # Create mesh surface from mesh array.
    # No blendshapes, lods, or compression used.
    mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, surface_array)</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public partial class MyMeshInstance3D : MeshInstance3D
{
    public override void _Ready()
    {
        var surfaceArray = new Godot.Collections.Array();
        surfaceArray.Resize((int)Mesh.ArrayType.Max);

        // C# arrays cannot be resized or expanded, so use Lists to create geometry.
        var verts = new List&lt;Vector3&gt;();
        var uvs = new List&lt;Vector2&gt;();
        var normals = new List&lt;Vector3&gt;();
        var indices = new List&lt;int&gt;();

        /***********************************
        * Insert code here to generate mesh.
        * *********************************/

        // Convert Lists to arrays and assign to surface array
        surfaceArray[(int)Mesh.ArrayType.Vertex] = verts.ToArray();
        surfaceArray[(int)Mesh.ArrayType.TexUV] = uvs.ToArray();
        surfaceArray[(int)Mesh.ArrayType.Normal] = normals.ToArray();
        surfaceArray[(int)Mesh.ArrayType.Index] = indices.ToArray();

        var arrMesh = Mesh as ArrayMesh;
        if (arrMesh != null)
        {
            // Create mesh surface from mesh array
            // No blendshapes, lods, or compression used.
            arrMesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, surfaceArray);
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>中间可以放你想要的任何代码。下面我们会给出一些示例代码，用于生成球体。</paragraph>
        </section>
        <section ids="generating-geometry" names="generating\ geometry 生成几何体">
            <title>生成几何体</title>
            <paragraph>这是生成球体的示例代码。尽管代码是用 GDScript 编写的，但是 Godot 并没有指定用特定的方式来实现它。这种实现方式与 ArrayMesh 无关，仅仅是一种通用的生成球体的方式。如果你觉得这比较难以理解，或者想更全面地了解程序式几何体，可以在网上寻找相关的教程进行学习。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends MeshInstance3D

var rings = 50
var radial_segments = 50
var radius = 1

func _ready():

    # Insert setting up the PackedVector**Arrays here.

    # Vertex indices.
    var thisrow = 0
    var prevrow = 0
    var point = 0

    # Loop over rings.
    for i in range(rings + 1):
        var v = float(i) / rings
        var w = sin(PI * v)
        var y = cos(PI * v)

        # Loop over segments in ring.
        for j in range(radial_segments + 1):
            var u = float(j) / radial_segments
            var x = sin(u * PI * 2.0)
            var z = cos(u * PI * 2.0)
            var vert = Vector3(x * radius * w, y * radius, z * radius * w)
            verts.append(vert)
            normals.append(vert.normalized())
            uvs.append(Vector2(u, v))
            point += 1

            # Create triangles in ring using indices.
            if i &gt; 0 and j &gt; 0:
                indices.append(prevrow + j - 1)
                indices.append(prevrow + j)
                indices.append(thisrow + j - 1)

                indices.append(prevrow + j)
                indices.append(thisrow + j)
                indices.append(thisrow + j - 1)

        prevrow = thisrow
        thisrow = point

  # Insert committing to the ArrayMesh here.</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public partial class MyMeshInstance3D : MeshInstance3D
{
    private int _rings = 50;
    private int _radialSegments = 50;
    private float _radius = 1;

    public override void _Ready()
    {
        // Insert setting up the surface array and lists here.

        // Vertex indices.
        var thisRow = 0;
        var prevRow = 0;
        var point = 0;

        // Loop over rings.
        for (var i = 0; i &lt; _rings + 1; i++)
        {
            var v = ((float)i) / _rings;
            var w = Mathf.Sin(Mathf.Pi * v);
            var y = Mathf.Cos(Mathf.Pi * v);

            // Loop over segments in ring.
            for (var j = 0; j &lt; _radialSegments + 1; j++)
            {
                var u = ((float)j) / _radialSegments;
                var x = Mathf.Sin(u * Mathf.Pi * 2);
                var z = Mathf.Cos(u * Mathf.Pi * 2);
                var vert = new Vector3(x * _radius * w, y * _radius, z * _radius * w);
                verts.Add(vert);
                normals.Add(vert.Normalized());
                uvs.Add(new Vector2(u, v));
                point += 1;

                // Create triangles in ring using indices.
                if (i &gt; 0 &amp;&amp; j &gt; 0)
                {
                    indices.Add(prevRow + j - 1);
                    indices.Add(prevRow + j);
                    indices.Add(thisRow + j - 1);

                    indices.Add(prevRow + j);
                    indices.Add(thisRow + j);
                    indices.Add(thisRow + j - 1);
                }
            }

            prevRow = thisRow;
            thisRow = point;
        }

        // Insert committing to the ArrayMesh here.
    }
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="saving" names="saving 保存">
            <title>保存</title>
            <paragraph>最后，我们可以使用 <reference internal="True" refuri="../../../classes/class_resourcesaver#class-resourcesaver"><inline classes="std std-ref">ResourceSaver</inline></reference> 类来保存该 ArrayMesh。当你想生成一个网格，然后在以后使用它而不需要重新生成时，这个方法很有用。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Saves mesh to a .tres file with compression enabled.
ResourceSaver.save(mesh, "res://sphere.tres", ResourceSaver.FLAG_COMPRESS)</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Saves mesh to a .tres file with compression enabled.
ResourceSaver.Save(Mesh, "res://sphere.tres", ResourceSaver.SaverFlags.Compress);</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
