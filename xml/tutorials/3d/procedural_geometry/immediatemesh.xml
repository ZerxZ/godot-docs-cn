<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/procedural_geometry/immediatemesh.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-immediatemesh"></target>
    <section ids="using-immediatemesh doc-immediatemesh" names="using\ immediatemesh 使用\ immediatemesh doc_immediatemesh">
        <title>使用 ImmediateMesh</title>
        <paragraph><reference internal="True" refuri="../../../classes/class_immediatemesh#class-immediatemesh"><inline classes="std std-ref">ImmediateMesh</inline></reference> 是一个使用 OpenGL 1.x 风格的 API 创建动态几何体的便捷工具。这使得它对于需要每帧更新的网格来说，既易于使用又高效。</paragraph>
        <paragraph>使用这个工具生成复杂的几何体（几千个顶点）效率很低，即使只做一次。相反，它的设计是为了生成每一帧变化的简单几何体。</paragraph>
        <paragraph>首先，你需要创建一个 <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> 并在检查其中向其添加一个 <reference internal="True" refuri="../../../classes/class_immediatemesh#class-immediatemesh"><inline classes="std std-ref">ImmediateMesh</inline></reference>。</paragraph>
        <paragraph>接下来，将脚本添加到 MeshInstance3D 上。如果你希望 ImmediateMesh 每帧都更新，则应该把 ImmediateMesh 的代码放在 <literal>_process()</literal> 函数中；如果你想创建一次网格体而后不再更新它，则代码应放在 <literal>_ready()</literal> 函数中。如果仅生成一次表面，则 ImmediateMesh 与任何其他类型的网格一样高效，因为生成的网格会被缓存并重用。</paragraph>
        <paragraph>必须调用 <literal>surface_begin()</literal> 才能开始生成几何体 。<literal>surface_begin()</literal> 将一个 <literal>PrimitiveType</literal> 作为参数。<literal>PrimitiveType</literal>（图元类型）指示 GPU 如何根据给定的顶点来安排图元，可以是三角形、线、点等。完整的列表可以在 <reference internal="True" refuri="../../../classes/class_mesh#class-mesh"><inline classes="std std-ref">Mesh</inline></reference> 的类参考页面中找到。</paragraph>
        <paragraph>一旦你调用了 <literal>surface_begin()</literal> ，就可以开始添加顶点了。每次添加一个顶点，首先使用 <literal>surface_set_****()</literal> （例如 <literal>surface_set_normal()</literal> ）添加顶点的特定属性，如法线或 UV。然后调用 <literal>surface_add_vertex()</literal> 来添加一个带有这些属性的顶点。例如：</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
            </div>
            <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Add a vertex with normal and uv.
surface_set_normal(Vector3(0, 1, 0))
surface_set_uv(Vector2(1, 1))
surface_add_vertex(Vector3(0, 0, 1))</literal_block>
            </div>
        </container>
        <paragraph>只有在调用 <literal>surface_add_vertex()</literal> 之前添加的属性才会被包含在该顶点中。如果在调用 <literal>surface_add_vertex()</literal> 之前添加属性两次，则仅第二次调用才会被使用。</paragraph>
        <paragraph>最后，当添加了所有的顶点后，调用 <literal>surface_end()</literal> 来表示已经完成了网格的生成。你可以多次调用 <literal>surface_begin()</literal> 和 <literal>surface_end()</literal> 来为网格生成多个表面。</paragraph>
        <paragraph>下面的示例代码在 <literal>_ready()</literal> 函数中绘制了一个三角形。</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
            </div>
            <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends MeshInstance3D

func _ready():
    # Begin draw.
    mesh.surface_begin(Mesh.PRIMITIVE_TRIANGLES)

    # Prepare attributes for add_vertex.
    mesh.surface_set_normal(Vector3(0, 0, 1))
    mesh.surface_set_uv(Vector2(0, 0))
    # Call last for each vertex, adds the above attributes.
    mesh.surface_add_vertex(Vector3(-1, -1, 0))

    mesh.surface_set_normal(Vector3(0, 0, 1))
    mesh.surface_set_uv(Vector2(0, 1))
    mesh.surface_add_vertex(Vector3(-1, 1, 0))

    mesh.surface_set_normal(Vector3(0, 0, 1))
    mesh.surface_set_uv(Vector2(1, 1))
    mesh.surface_add_vertex(Vector3(1, 1, 0))

    # End drawing.
    mesh.surface_end()</literal_block>
            </div>
        </container>
        <paragraph>The ImmediateMesh can also be used across frames. Each time you call
            <literal>surface_begin()</literal> and <literal>surface_end()</literal>, you are adding a new surface to the
            ImmediateMesh. If you want to recreate the mesh from scratch each frame, call
            <literal>clear_surfaces()</literal> before calling <literal>surface_begin()</literal>.</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
            </div>
            <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends MeshInstance3D

func _process(delta):

    # Clean up before drawing.
    mesh.clear_surfaces()

    # Begin draw.
    mesh.surface_begin(Mesh.PRIMITIVE_TRIANGLES)

    # Draw mesh.

    # End drawing.
    mesh.surface_end()</literal_block>
            </div>
        </container>
        <paragraph>上面的代码将在每个帧里动态地创建并绘制一个表面。</paragraph>
        <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
    </section>
</document>
