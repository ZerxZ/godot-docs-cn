<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/procedural_geometry/meshdatatool.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-meshdatatool"></target>
    <section ids="using-the-meshdatatool doc-meshdatatool" names="using\ the\ meshdatatool doc_meshdatatool">
        <title>Using the MeshDataTool</title>
        <paragraph>The <reference internal="True" refuri="../../../classes/class_meshdatatool#class-meshdatatool"><inline classes="std std-ref">MeshDataTool</inline></reference> is not used to generate geometry. But it is helpful for dynamically altering geometry, for example
            if you want to write a script to tessellate, simplify, or deform meshes.</paragraph>
        <paragraph>The MeshDataTool is not as fast as altering arrays directly using ArrayMesh. However, it provides more information
            and tools to work with meshes than the ArrayMesh does. When the MeshDataTool
            is used, it calculates mesh data that is not available in ArrayMeshes such as faces and edges, which are necessary
            for certain mesh algorithms. If you do not need this extra information then it may be better to use an ArrayMesh.</paragraph>
        <note>
            <paragraph>MeshDataTool can only be used on Meshes that use the PrimitiveType <literal>Mesh.PRIMITIVE_TRIANGLES</literal>.</paragraph>
        </note>
        <paragraph>We initialize the MeshDataTool from an ArrayMesh by calling <literal>create_from_surface()</literal>. If there is already data initialized in the MeshDataTool,
            calling <literal>create_from_surface()</literal> will clear it for you. Alternatively, you can call <literal>clear()</literal> yourself before re-using the MeshDataTool.</paragraph>
        <paragraph>In the examples below, assume an ArrayMesh called <literal>mesh</literal> has already been created. See <reference internal="True" refuri="arraymesh#doc-arraymesh"><inline classes="std std-ref">ArrayMesh tutorial</inline></reference> for an example of mesh generation.</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
            </div>
            <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var mdt = MeshDataTool.new()
mdt.create_from_surface(mesh, 0)</literal_block>
            </div>
        </container>
        <paragraph><literal>create_from_surface()</literal> uses the vertex arrays from the ArrayMesh to calculate two additional arrays,
            one for edges and one for faces, for a total of three arrays.</paragraph>
        <paragraph>An edge is a connection between any two vertices. Each edge in the edge array contains a reference to
            the two vertices it is composed of, and up to two faces that it is contained within.</paragraph>
        <paragraph>A face is a triangle made up of three vertices and three corresponding edges. Each face in the face array contains
            a reference to the three vertices and three edges it is composed of.</paragraph>
        <paragraph>The vertex array contains edge, face, normal, color, tangent, uv, uv2, bone, and weight information connected
            with each vertex.</paragraph>
        <paragraph>To access information from these arrays you use a function of the form <literal>get_****()</literal>:</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
            </div>
            <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">mdt.get_vertex_count() # Returns number of vertices in vertex array.
mdt.get_vertex_faces(0) # Returns array of faces that contain vertex[0].
mdt.get_face_normal(1) # Calculates and returns face normal of the second face.
mdt.get_edge_vertex(10, 1) # Returns the second vertex comprising the edge at index 10.</literal_block>
            </div>
        </container>
        <paragraph>What you choose to do with these functions is up to you. A common use case is to iterate over all vertices
            and transform them in some way:</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
            </div>
            <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">for i in range(get_vertex_count):
    var vert = mdt.get_vertex(i)
    vert *= 2.0 # Scales the vertex by doubling size.
    mdt.set_vertex(i, vert)</literal_block>
            </div>
        </container>
        <paragraph>These modifications are not done in place on the ArrayMesh. If you are dynamically updating an existing ArrayMesh,
            first delete the existing surface before adding a new one using <reference internal="True" refuri="../../../classes/class_meshdatatool#class-meshdatatool-method-commit-to-surface"><inline classes="std std-ref">commit_to_surface()</inline></reference>:</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
            </div>
            <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">mesh.clear_surfaces() # Deletes all of the mesh's surfaces.
mdt.commit_to_surface(mesh)</literal_block>
            </div>
        </container>
        <paragraph>Below is a complete example that turns a spherical mesh called <literal>mesh</literal> into a randomly deformed blob complete with updated normals and vertex colors.
            See <reference internal="True" refuri="arraymesh#doc-arraymesh"><inline classes="std std-ref">ArrayMesh tutorial</inline></reference> for how to generate the base mesh.</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
            </div>
            <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends MeshInstance3D

var fnl = FastNoiseLite.new()
var mdt = MeshDataTool.new()

func _ready():
    fnl.frequency = 0.7

    mdt.create_from_surface(mesh, 0)

    for i in range(mdt.get_vertex_count()):
        var vertex = mdt.get_vertex(i).normalized()
        # Push out vertex by noise.
        vertex = vertex * (fnl.get_noise_3dv(vertex) * 0.5 + 0.75)
        mdt.set_vertex(i, vertex)

    # Calculate vertex normals, face-by-face.
    for i in range(mdt.get_face_count()):
        # Get the index in the vertex array.
        var a = mdt.get_face_vertex(i, 0)
        var b = mdt.get_face_vertex(i, 1)
        var c = mdt.get_face_vertex(i, 2)
        # Get vertex position using vertex index.
        var ap = mdt.get_vertex(a)
        var bp = mdt.get_vertex(b)
        var cp = mdt.get_vertex(c)
        # Calculate face normal.
        var n = (bp - cp).cross(ap - bp).normalized()
        # Add face normal to current vertex normal.
        # This will not result in perfect normals, but it will be close.
        mdt.set_vertex_normal(a, n + mdt.get_vertex_normal(a))
        mdt.set_vertex_normal(b, n + mdt.get_vertex_normal(b))
        mdt.set_vertex_normal(c, n + mdt.get_vertex_normal(c))

    # Run through vertices one last time to normalize normals and
    # set color to normal.
    for i in range(mdt.get_vertex_count()):
        var v = mdt.get_vertex_normal(i).normalized()
        mdt.set_vertex_normal(i, v)
        mdt.set_vertex_color(i, Color(v.x, v.y, v.z))

    mesh.clear_surfaces()
    mdt.commit_to_surface(mesh)</literal_block>
            </div>
        </container>
        <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
    </section>
</document>
