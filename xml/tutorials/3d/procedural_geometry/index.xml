<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/procedural_geometry/index.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-procedural-geometry"></target>
    <section ids="procedural-geometry doc-procedural-geometry" names="procedural\ geometry 程序式几何体 doc_procedural_geometry">
        <title>程序式几何体</title>
        <paragraph>在 Godot 中，有许多方法可以通过程序生成几何体。在本系列教程中，我们将探讨其中的几种方法。每种技术都有自己的优点和缺点，所以最好了解每种技术，以及它在特定情况下如何发挥作用。</paragraph>
        <compound classes="toctree-wrapper" ids="toc-procedural-geometry" names="toc-procedural_geometry">
            <compact_paragraph toctree="True"><bullet_list><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="arraymesh">使用 ArrayMesh</reference></compact_paragraph></list_item><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="meshdatatool">使用 MeshDataTool</reference></compact_paragraph></list_item><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="surfacetool">使用 SurfaceTool</reference></compact_paragraph></list_item><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="immediatemesh">使用 ImmediateMesh</reference></compact_paragraph></list_item></bullet_list></compact_paragraph>
        </compound>
        <note>
            <paragraph>这里描述的所有程序几何生成（ procedural geometry generation ）方法都在 CPU 上运行。 Godot 尚不支持在 GPU 上生成几何体。</paragraph>
        </note>
        <section ids="what-is-geometry" names="what\ is\ geometry? 什么是几何体？">
            <title>什么是几何体？</title>
            <paragraph>几何体是形状的一种花式说法。在计算机图形学中，几何体通常由称为“顶点”的位置数组来表示。在 Godot 中，几何体用 Mesh（网格）来表示。</paragraph>
        </section>
        <section ids="what-is-a-mesh" names="what\ is\ a\ mesh? 什么是网格？">
            <title>什么是网格？</title>
            <paragraph>Godot 中的很多东西的名称中都有“Mesh”（网格）：<reference internal="True" refuri="../../../classes/class_mesh#class-mesh"><inline classes="std std-ref">Mesh</inline></reference>、<reference internal="True" refuri="../../../classes/class_arraymesh#class-arraymesh"><inline classes="std std-ref">ArrayMesh</inline></reference>、<reference internal="True" refuri="../../../classes/class_immediatemesh#class-immediatemesh"><inline classes="std std-ref">ImmediateMesh</inline></reference>、<reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference>、<inline classes="xref std std-ref">MultiMesh</inline>。虽然它们都是相关的，但它们的用途略有不同。</paragraph>
            <paragraph>Mesh 和 ArrayMesh 是使用 MeshInstance3D 节点绘制的资源。像 Mesh 和 ArrayMesh 这样的资源不能直接添加到场景中。MeshInstance3D 代表的是某个网格在场景中的实例。你可以在多个 MeshInstance3D 中重复使用同一个网格，用不同的材质或变换（缩放、旋转、位置等）在场景的不同部分绘制它。</paragraph>
            <paragraph>如果你要多次绘制同一个对象，那么将 MultiMesh 与 MultiMeshInstance3D 结合使用会很有帮助。MultiMeshInstance3D 可以以非常低的性能成本绘制数千次网格，利用的是硬件实例化的优势。使用 MultiMeshInstance3D 的缺点是所有网格的表面都只能使用同一种材质。它使用一个实例数组为每个实例存储不同的颜色和变换，但所有实例的表面使用的都是相同的材质。</paragraph>
        </section>
        <section ids="what-a-mesh-is" names="what\ a\ mesh\ is 什么是网格">
            <title>什么是网格</title>
            <paragraph>网格（Mesh）由一个或多个表面（Surface）组成。表面是由多个子数组组成的数组，包含顶点、法线、UV 等。通常情况下，构造表面和网格的过程对用户来说是隐藏在 <reference internal="True" refuri="../../../classes/class_renderingserver#class-renderingserver"><inline classes="std std-ref">RenderingServer</inline></reference> 中的，但是通过 ArrayMesh，用户可以通过传递一个包含表面信息的数组来手动构造网格。</paragraph>
            <section ids="surfaces" names="surfaces 表面">
                <title>表面</title>
                <paragraph>每个表面都有自己的材质。使用 MeshInstance3D 时，你也可以使用 <reference internal="True" refuri="../../../classes/class_geometryinstance3d#class-geometryinstance3d-property-material-override"><inline classes="std std-ref">material_override</inline></reference> 属性来覆盖 Mesh 中所有表面的材质。</paragraph>
            </section>
            <section ids="surface-array" names="surface\ array 表面数组">
                <title>表面数组</title>
                <paragraph>表面数组是一个长度为 <literal>ArrayMesh.ARRAY_MAX</literal> 的数组。数组中的每个位置都有一个子数组，包含每个顶点的信息。例如，位于 <literal>ArrayMesh.ARRAY_NORMAL</literal> 处的数组是顶点法线的 <reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference>。更多信息请参阅 <reference internal="True" refuri="../../../classes/class_mesh#enum-mesh-arraytype"><inline classes="std std-ref">Mesh.ArrayType</inline></reference>。</paragraph>
                <paragraph>表面数组可以是有索引的，也可以是非索引的。创建非索引数组就像在索引 <literal>ArrayMesh.ARRAY_INDEX</literal> 处不分配数组一样简单。非索引数组为每个三角形存储唯一的顶点信息，也就是说，当两个三角形共用一个顶点时，顶点在数组中是重复的。有索引的曲面数组只存储每个唯一顶点的顶点信息，然后还存储一个索引数组，它映射出如何从顶点数组构造三角形。一般来说，使用索引数组的速度更快，但这意味着你必须在三角形之间共享顶点数据，这并不总是需要的（例如，当你想要每面法线时）。</paragraph>
            </section>
        </section>
        <section ids="tools" names="tools 工具">
            <title>工具</title>
            <paragraph>Godot 提供了不同的访问和处理几何体的方法. 关于每种方法的更多信息将在下面的教程中提供.</paragraph>
            <section ids="arraymesh" names="arraymesh">
                <title>ArrayMesh</title>
                <paragraph>ArrayMesh 资源扩展了 Mesh，增加了一些不同的便捷函数，最重要的是，可以通过脚本构建 Mesh 表面。</paragraph>
                <paragraph>有关ArrayMesh的更多信息, 请参阅 <reference internal="True" refuri="arraymesh#doc-arraymesh"><inline classes="std std-ref">ArrayMesh tutorial</inline></reference>.</paragraph>
            </section>
            <section ids="meshdatatool" names="meshdatatool">
                <title>MeshDataTool</title>
                <paragraph>MeshDataTool是一个将Mesh数据转换为顶点, 面和边的数组的资源, 可以在运行时进行修改.</paragraph>
                <paragraph>有关 MeshDataTool 的完整列表, 请参见 <reference internal="True" refuri="meshdatatool#doc-meshdatatool"><inline classes="std std-ref">MeshDataTool tutorial</inline></reference>.</paragraph>
            </section>
            <section ids="surfacetool" names="surfacetool">
                <title>SurfaceTool</title>
                <paragraph>SurfaceTool允许使用OpenGL 1.x即时模式风格的接口创建网格.</paragraph>
                <paragraph>有关SurfaceTool的更多信息, 请阅读 <reference internal="True" refuri="surfacetool#doc-surfacetool"><inline classes="std std-ref">SurfaceTool tutorial</inline></reference>.</paragraph>
            </section>
            <section ids="immediatemesh" names="immediatemesh">
                <title>ImmediateMesh</title>
                <paragraph>ImmediateMesh 是使用立即模式风格的接口绘制对象的网格（像 SurfaceTool 一样）。ImmediateMesh 和 SurfaceTool 的区别在于，ImmediateMesh 是直接用代码动态绘制的，而 SurfaceTool 则是用来生成一个 Mesh，你可以用它做任何你想做的事。</paragraph>
                <paragraph>ImmediateMesh 因为其直接的 API 而对原型设计很有用，但它的速度很慢，因为每次进行修改时都要重建几何体。它最有用的是快速添加简单的几何体来进行可视化调试（例如，通过绘制线条来可视化物理光线投射等）。</paragraph>
                <paragraph>有关 ImmediateMesh的更多信息，请参见 <reference internal="True" refuri="immediatemesh#doc-immediatemesh"><inline classes="std std-ref">ImmediateMesh 教程</inline></reference>。</paragraph>
            </section>
        </section>
        <section ids="which-one-should-i-use" names="which\ one\ should\ i\ use? 我应该使用哪一个？">
            <title>我应该使用哪一个？</title>
            <paragraph>用哪种方法取决于你想做什么，以及你觉得什么样的做法用起来更舒服。</paragraph>
            <paragraph>SurfaceTool和ArrayMesh都是生成不随时间变化的静态几何体(网格)的绝佳工具.</paragraph>
            <paragraph>使用 ArrayMesh 比使用 SurfaceTool 稍快一些，但 API 的难度更大一些。另外，SurfaceTool 还有一些便捷的方法，比如 <literal>generate_normals()</literal> 和 <literal>index()</literal>。</paragraph>
            <paragraph>ImmediateMesh 比 ArrayMesh 和 SurfaceTool 受到更多限制。但是，如果你本来就需要每一帧都改变几何体，它提供的接口更简单，甚至可能比每一帧生成一个 ArrayMesh 更快。</paragraph>
            <paragraph>MeshDataTool 的速度并不快，但它可以让你访问网格的各种属性，而这些属性是其他工具无法获得的（边、面等）。当你需要根据这类数据来变换网格时，它是非常有用的，但如果不需要这些信息，就不适合使用。如果你要使用需要访问面数组或边数组的算法，最好使用 MeshDataTool。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
