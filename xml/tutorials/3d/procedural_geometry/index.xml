<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/procedural_geometry/index.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-procedural-geometry"></target>
    <section ids="procedural-geometry doc-procedural-geometry" names="procedural\ geometry doc_procedural_geometry">
        <title>Procedural geometry</title>
        <paragraph>There are many ways to procedurally generate geometry in Godot. In this tutorial series,
            we will explore a few of them. Each technique has its own benefits and drawbacks, so
            it is best to understand each one and how it can be useful in a given situation.</paragraph>
        <compound classes="toctree-wrapper" ids="toc-procedural-geometry" names="toc-procedural_geometry">
            <compact_paragraph toctree="True"><bullet_list><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="arraymesh">Using the ArrayMesh</reference></compact_paragraph></list_item><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="meshdatatool">Using the MeshDataTool</reference></compact_paragraph></list_item><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="surfacetool">Using the SurfaceTool</reference></compact_paragraph></list_item><list_item classes="toctree-l1"><compact_paragraph classes="toctree-l1"><reference anchorname="" internal="True" refuri="immediatemesh">Using ImmediateMesh</reference></compact_paragraph></list_item></bullet_list></compact_paragraph>
        </compound>
        <note>
            <paragraph>All the procedural geometry generation methods described here run on the
                CPU. Godot doesn't support generating geometry on the GPU yet.</paragraph>
        </note>
        <section ids="what-is-geometry" names="what\ is\ geometry?">
            <title>What is geometry?</title>
            <paragraph>Geometry is a fancy way of saying shape. In computer graphics, geometry is typically represented
                by an array of positions called "vertices". In Godot, geometry is represented by Meshes.</paragraph>
        </section>
        <section ids="what-is-a-mesh" names="what\ is\ a\ mesh?">
            <title>What is a Mesh?</title>
            <paragraph>Many things in Godot have mesh in their name: the <reference internal="True" refuri="../../../classes/class_mesh#class-mesh"><inline classes="std std-ref">Mesh</inline></reference>, the
                <reference internal="True" refuri="../../../classes/class_arraymesh#class-arraymesh"><inline classes="std std-ref">ArrayMesh</inline></reference>, the <reference internal="True" refuri="../../../classes/class_immediatemesh#class-immediatemesh"><inline classes="std std-ref">ImmediateMesh</inline></reference>, the <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference>, the
                <reference internal="True" refuri="../../../classes/class_multimesh#class-multimesh"><inline classes="std std-ref">MultiMesh</inline></reference>, and the <reference internal="True" refuri="../../../classes/class_multimeshinstance3d#class-multimeshinstance3d"><inline classes="std std-ref">MultiMeshInstance3D</inline></reference>. While they are all related, they have slightly
                different uses.</paragraph>
            <paragraph>Meshes and ArrayMeshes are resources that are drawn using a MeshInstance3D node. Resources like
                Meshes and ArrayMeshes cannot be added to the scene directly. A MeshInstance3D represents one
                instance of a mesh in your scene. You can reuse a single mesh in multiple MeshInstance3Ds
                to draw it in different parts of your scene with different materials or transformations (scale,
                rotation, position etc.).</paragraph>
            <paragraph>If you are going to draw the same object many times, it can be helpful to use a MultiMesh with
                a MultiMeshInstance3D. MultiMeshInstance3Ds draw meshes thousands of times very
                cheaply by taking advantage of hardware instancing. The drawback with
                using a MultiMeshInstance3D is that each of your mesh's surfaces are limited to one material for
                all instances. It uses an instance array to store different colors and transformations for each
                instance, but all the instances of each surface use the same material.</paragraph>
        </section>
        <section ids="what-a-mesh-is" names="what\ a\ mesh\ is">
            <title>What a Mesh is</title>
            <paragraph>A Mesh is composed of one or more surfaces. A surface is an array composed of multiple sub-arrays
                containing vertices, normals, UVs, etc. Normally the process of constructing surfaces and meshes is
                hidden from the user in the <reference internal="True" refuri="../../../classes/class_renderingserver#class-renderingserver"><inline classes="std std-ref">RenderingServer</inline></reference>, but with ArrayMeshes, the user can construct a Mesh
                manually by passing in an array containing the surface information.</paragraph>
            <section ids="surfaces" names="surfaces">
                <title>Surfaces</title>
                <paragraph>Each surface has its own material. Alternatively, you can override the material for all surfaces
                    in the Mesh when you use a MeshInstance3D using the <reference internal="True" refuri="../../../classes/class_geometryinstance3d#class-geometryinstance3d-property-material-override"><inline classes="std std-ref">material_override</inline></reference> property.</paragraph>
            </section>
            <section ids="surface-array" names="surface\ array">
                <title>Surface array</title>
                <paragraph>The surface array is an array of length <literal>ArrayMesh.ARRAY_MAX</literal>. Each position in the array is
                    filled with a sub-array containing per-vertex information. For example, the array located at
                    <literal>ArrayMesh.ARRAY_NORMAL</literal> is a <reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference> of vertex normals.
                    See <reference internal="True" refuri="../../../classes/class_mesh#enum-mesh-arraytype"><inline classes="std std-ref">Mesh.ArrayType</inline></reference> for more information.</paragraph>
                <paragraph>The surface array can be indexed or non-indexed. Creating a non-indexed array is as easy as not assigning
                    an array at the index <literal>ArrayMesh.ARRAY_INDEX</literal>. A non-indexed array stores unique vertex information for
                    every triangle, meaning that when two triangles share a vertex, the vertex is duplicated in the array. An
                    indexed surface array only stores vertex information for each unique vertex and then also stores an array
                    of indices which maps out how to construct the triangles from the vertex array. In general, using an indexed
                    array is faster, but it means you have to share vertex data between triangles, which is not always desired
                    (e.g. when you want per-face normals).</paragraph>
            </section>
        </section>
        <section ids="tools" names="tools">
            <title>Tools</title>
            <paragraph>Godot provides different ways of accessing and working with geometry. More information on each will
                be provided in the following tutorials.</paragraph>
            <section ids="arraymesh" names="arraymesh">
                <title>ArrayMesh</title>
                <paragraph>The ArrayMesh resource extends Mesh to add a few different quality of life functions and, most
                    importantly, the ability to construct a Mesh surface through scripting.</paragraph>
                <paragraph>For more information about the ArrayMesh, please see the <reference internal="True" refuri="arraymesh#doc-arraymesh"><inline classes="std std-ref">ArrayMesh tutorial</inline></reference>.</paragraph>
            </section>
            <section ids="meshdatatool" names="meshdatatool">
                <title>MeshDataTool</title>
                <paragraph>The MeshDataTool is a resource that converts Mesh data into arrays of vertices, faces, and edges that can
                    be modified at runtime.</paragraph>
                <paragraph>For more information about the MeshDataTool, please see the <reference internal="True" refuri="meshdatatool#doc-meshdatatool"><inline classes="std std-ref">MeshDataTool tutorial</inline></reference>.</paragraph>
            </section>
            <section ids="surfacetool" names="surfacetool">
                <title>SurfaceTool</title>
                <paragraph>The SurfaceTool allows the creation of Meshes using an OpenGL 1.x immediate mode style interface.</paragraph>
                <paragraph>For more information about the SurfaceTool, please see the <reference internal="True" refuri="surfacetool#doc-surfacetool"><inline classes="std std-ref">SurfaceTool tutorial</inline></reference>.</paragraph>
            </section>
            <section ids="immediatemesh" names="immediatemesh">
                <title>ImmediateMesh</title>
                <paragraph>ImmediateMesh is a mesh that uses an immediate mode style interface (like
                    SurfaceTool) to draw objects. The difference between ImmediateMesh and the
                    SurfaceTool is that ImmediateMesh is drawn directly with code dynamically, while
                    the SurfaceTool is used to generate a Mesh that you can do whatever you want
                    with.</paragraph>
                <paragraph>ImmediateMesh is useful for prototyping because of its straightforward API, but
                    it is slow because the geometry is rebuilt each time you make a change. It is
                    most useful for adding simple geometry for visual debugging (e.g. by drawing
                    lines to visualize physics raycasts etc.).</paragraph>
                <paragraph>For more information about ImmediateMesh, please see the <reference internal="True" refuri="immediatemesh#doc-immediatemesh"><inline classes="std std-ref">ImmediateMesh tutorial</inline></reference>.</paragraph>
            </section>
        </section>
        <section ids="which-one-should-i-use" names="which\ one\ should\ i\ use?">
            <title>Which one should I use?</title>
            <paragraph>Which approach you use depends on what you are trying to do and what kind of procedure you are comfortable with.</paragraph>
            <paragraph>Both SurfaceTool and ArrayMesh are excellent for generating static geometry (meshes) that don't change over time.</paragraph>
            <paragraph>Using an ArrayMesh is slightly faster than using a SurfaceTool, but the API is a little more challenging.
                Additionally, SurfaceTool has a few quality of life methods such as <literal>generate_normals()</literal> and <literal>index()</literal>.</paragraph>
            <paragraph>ImmediateMesh is more limited than both ArrayMesh and SurfaceTool. However, if
                you need the geometry to change every frame anyway, it provides a much easier
                interface that can be slightly faster than generating an ArrayMesh every frame.</paragraph>
            <paragraph>The MeshDataTool is not fast, but it gives you access to all kinds of properties of the mesh that you don't get with the others
                (edges, faces, etc.). It is incredibly useful when you need that sort of data to transform the mesh, but it is not a good idea
                to use it if that extra information is not needed. The MeshDataTool is best used if you are going to be using an algorithm that requires
                access to the face or edge array.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
