<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/using_transforms.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-transforms"></target>
    <section ids="using-3d-transforms doc-using-transforms" names="using\ 3d\ transforms doc_using_transforms">
        <title>Using 3D transforms</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>If you have never made 3D games before, working with rotations in three dimensions can be confusing at first.
                Coming from 2D, the natural way of thinking is along the lines of <emphasis>"Oh, it's just like rotating in 2D, except now rotations happen in X, Y and Z"</emphasis>.</paragraph>
            <paragraph>At first, this seems easy. For simple games, this way of thinking may even be enough. Unfortunately, it's often incorrect.</paragraph>
            <paragraph>Angles in three dimensions are most commonly referred to as "Euler Angles".</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/transforms_euler.webp'}" original_uri="img/transforms_euler.webp" uri="tutorials/3d/img/transforms_euler.webp"></image>
            <paragraph>Euler angles were introduced by mathematician Leonhard Euler in the early 1700s.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/transforms_euler_himself.png'}" original_uri="img/transforms_euler_himself.png" uri="tutorials/3d/img/transforms_euler_himself.png"></image>
            <paragraph>This way of representing 3D rotations was groundbreaking at the time, but it has several shortcomings when used in game development (which is to be expected from a guy with a funny
                hat).
                The idea of this document is to explain why, as well as outlining best practices for dealing with transforms when programming 3D games.</paragraph>
        </section>
        <section ids="problems-of-euler-angles" names="problems\ of\ euler\ angles">
            <title>Problems of Euler angles</title>
            <paragraph>While it may seem intuitive that each axis has a rotation, the truth is that it's just not practical.</paragraph>
            <section ids="axis-order" names="axis\ order">
                <title>Axis order</title>
                <paragraph>The main reason for this is that there isn't a <emphasis>unique</emphasis> way to construct an orientation from the angles. There isn't a standard mathematical function that
                    takes all the angles together and produces an actual 3D rotation. The only way an orientation can be produced from angles is to rotate the object angle
                    by angle, in an <emphasis>arbitrary order</emphasis>.</paragraph>
                <paragraph>This could be done by first rotating in <emphasis>X</emphasis>, then <emphasis>Y</emphasis> and then in <emphasis>Z</emphasis>. Alternatively, you could first rotate in <emphasis>Y</emphasis>, then in <emphasis>Z</emphasis> and finally in <emphasis>X</emphasis>. Anything works,
                    but depending on the order, the final orientation of the object will <emphasis>not necessarily be the same</emphasis>. Indeed, this means that there are several ways to construct an orientation
                    from 3 different angles, depending on <emphasis>the order of the rotations</emphasis>.</paragraph>
                <paragraph>Following is a visualization of rotation axes (in X, Y, Z order) in a gimbal (from Wikipedia). As you can see, the orientation of each axis depends on the rotation of the previous one:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/transforms_gimbal.gif'}" original_uri="img/transforms_gimbal.gif" uri="tutorials/3d/img/transforms_gimbal.gif"></image>
                <paragraph>You may be wondering how this affects you. Let's look at a practical example:</paragraph>
                <paragraph>Imagine you are working on a first-person controller (e.g. an FPS game). Moving the mouse left and right controls your view angle parallel to the ground, while moving it up and down moves the player's view up and down.</paragraph>
                <paragraph>In this case to achieve the desired effect, rotation must be applied first in the <emphasis>Y</emphasis> axis ("up" in this case, since Godot uses a "Y-Up" orientation), followed by rotation in the <emphasis>X</emphasis> axis.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/transforms_rotate1.gif'}" original_uri="img/transforms_rotate1.gif" uri="tutorials/3d/img/transforms_rotate1.gif"></image>
                <paragraph>If we were to apply rotation in the <emphasis>X</emphasis> axis first, and then in <emphasis>Y</emphasis>, the effect would be undesired:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/transforms_rotate2.gif'}" original_uri="img/transforms_rotate2.gif" uri="tutorials/3d/img/transforms_rotate2.gif"></image>
                <paragraph>Depending on the type of game or effect desired, the order in which you want axis rotations to be applied may differ. Therefore, applying rotations in X, Y, and Z is not enough: you also need a <emphasis>rotation order</emphasis>.</paragraph>
            </section>
            <section ids="interpolation" names="interpolation">
                <title>Interpolation</title>
                <paragraph>Another problem with using Euler angles is interpolation. Imagine you want to transition between two different camera or enemy positions (including rotations). One logical way to approach this is to interpolate the angles from one position to the next. One would expect it to look like this:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/transforms_interpolate1.gif'}" original_uri="img/transforms_interpolate1.gif" uri="tutorials/3d/img/transforms_interpolate1.gif"></image>
                <paragraph>But this does not always have the expected effect when using angles:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/transforms_interpolate2.gif'}" original_uri="img/transforms_interpolate2.gif" uri="tutorials/3d/img/transforms_interpolate2.gif"></image>
                <paragraph>The camera actually rotated the opposite direction!</paragraph>
                <paragraph>There are a few reasons this may happen:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>Rotations don't map linearly to orientation, so interpolating them does not always result in the shortest path (i.e., to go from <literal>270</literal> to <literal>0</literal> degrees is not the same as going from <literal>270</literal> to <literal>360</literal>, even though the angles are equivalent).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Gimbal lock is at play (first and last rotated axis align, so a degree of freedom is lost). See <reference name="Wikipedia's page on Gimbal Lock" refuri="https://en.wikipedia.org/wiki/Gimbal_lock">Wikipedia's page on Gimbal Lock</reference><target ids="wikipedia-s-page-on-gimbal-lock" names="wikipedia's\ page\ on\ gimbal\ lock" refuri="https://en.wikipedia.org/wiki/Gimbal_lock"></target> for a detailed explanation of this problem.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="say-no-to-euler-angles" names="say\ no\ to\ euler\ angles">
                <title>Say no to Euler angles</title>
                <paragraph>The result of all this is that you should <strong>not use</strong> the <literal>rotation</literal> property of <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> nodes in Godot for games. It's there to be used mainly in the editor, for coherence with the 2D engine, and for simple rotations (generally just one axis, or even two in limited cases). As much as you may be tempted, don't use it.</paragraph>
                <paragraph>Instead, there is a better way to solve your rotation problems.</paragraph>
            </section>
        </section>
        <section ids="introducing-transforms" names="introducing\ transforms">
            <title>Introducing transforms</title>
            <paragraph>Godot uses the <reference internal="True" refuri="../../classes/class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference> datatype for orientations. Each <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> node contains a <literal>transform</literal> property which is relative to the parent's transform, if the parent is a Node3D-derived type.</paragraph>
            <paragraph>It is also possible to access the world coordinate transform via the <literal>global_transform</literal> property.</paragraph>
            <paragraph>A transform has a <reference internal="True" refuri="../../classes/class_basis#class-basis"><inline classes="std std-ref">Basis</inline></reference> (transform.basis sub-property), which consists of three <reference internal="True" refuri="../../classes/class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> vectors. These are accessed via the <literal>transform.basis</literal> property and can be accessed directly by <literal>transform.basis.x</literal>, <literal>transform.basis.y</literal>, and <literal>transform.basis.z</literal>. Each vector points in the direction its axis has been rotated, so they effectively describe the node's total rotation. The scale (as long as it's uniform) can also be inferred from the length of the axes. A <emphasis>basis</emphasis> can also be interpreted as a 3x3 matrix and used as <literal>transform.basis[x][y]</literal>.</paragraph>
            <paragraph>A default basis (unmodified) is akin to:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var basis = Basis()
# Contains the following default values:
basis.x = Vector3(1, 0, 0) # Vector pointing along the X axis
basis.y = Vector3(0, 1, 0) # Vector pointing along the Y axis
basis.z = Vector3(0, 0, 1) # Vector pointing along the Z axis</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Due to technical limitations on structs in C# the default
// constructor will contain zero values for all fields.
var defaultBasis = new Basis();
GD.Print(defaultBasis); // prints: ((0, 0, 0), (0, 0, 0), (0, 0, 0))

// Instead we can use the Identity property.
var identityBasis = Basis.Identity;
GD.Print(identityBasis.X); // prints: (1, 0, 0)
GD.Print(identityBasis.Y); // prints: (0, 1, 0)
GD.Print(identityBasis.Z); // prints: (0, 0, 1)

// The Identity basis is equivalent to:
var basis = new Basis(Vector3.Right, Vector3.Up, Vector3.Back);
GD.Print(basis); // prints: ((1, 0, 0), (0, 1, 0), (0, 0, 1))</literal_block>
                </div>
            </container>
            <paragraph>This is also an analog of a 3x3 identity matrix.</paragraph>
            <paragraph>Following the OpenGL convention, <literal>X</literal> is the <emphasis>Right</emphasis> axis, <literal>Y</literal> is the <emphasis>Up</emphasis> axis and <literal>Z</literal> is the <emphasis>Forward</emphasis> axis.</paragraph>
            <paragraph>Together with the <emphasis>basis</emphasis>, a transform also has an <emphasis>origin</emphasis>. This is a <emphasis>Vector3</emphasis> specifying how far away from the actual origin <literal>(0, 0, 0)</literal> this transform is. Combining the <emphasis>basis</emphasis> with the <emphasis>origin</emphasis>, a <emphasis>transform</emphasis> efficiently represents a unique translation, rotation, and scale in space.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/transforms_camera.png'}" original_uri="img/transforms_camera.png" uri="tutorials/3d/img/transforms_camera.png"></image>
            <paragraph>One way to visualize a transform is to look at an object's 3D gizmo while in "local space" mode.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/transforms_local_space.png'}" original_uri="img/transforms_local_space.png" uri="tutorials/3d/img/transforms_local_space.png"></image>
            <paragraph>The gizmo's arrows show the <literal>X</literal>, <literal>Y</literal>, and <literal>Z</literal> axes (in red, green, and blue respectively) of the basis, while the gizmo's center is at the object's origin.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/transforms_gizmo.png'}" original_uri="img/transforms_gizmo.png" uri="tutorials/3d/img/transforms_gizmo.png"></image>
            <paragraph>For more information on the mathematics of vectors and transforms, please read the <reference internal="True" refuri="../math/vector_math#doc-vector-math"><inline classes="std std-ref">Vector math</inline></reference> tutorials.</paragraph>
            <section ids="manipulating-transforms" names="manipulating\ transforms">
                <title>Manipulating transforms</title>
                <paragraph>Of course, transforms are not as straightforward to manipulate as angles and have problems of their own.</paragraph>
                <paragraph>It is possible to rotate a transform, either by multiplying its basis by another (this is called accumulation), or by using the rotation methods.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var axis = Vector3(1, 0, 0) # Or Vector3.RIGHT
var rotation_amount = 0.1
# Rotate the transform around the X axis by 0.1 radians.
transform.basis = Basis(axis, rotation_amount) * transform.basis
# shortened
transform.basis = transform.basis.rotated(axis, rotation_amount)</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Transform3D transform = Transform;
Vector3 axis = new Vector3(1, 0, 0); // Or Vector3.Right
float rotationAmount = 0.1f;

// Rotate the transform around the X axis by 0.1 radians.
transform.Basis = new Basis(axis, rotationAmount) * transform.Basis;
// shortened
transform.Basis = transform.Basis.Rotated(axis, rotationAmount);

Transform = transform;</literal_block>
                    </div>
                </container>
                <paragraph>A method in Node3D simplifies this:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Rotate the transform around the X axis by 0.1 radians.
rotate(Vector3(1, 0, 0), 0.1)
# shortened
rotate_x(0.1)</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Rotate the transform around the X axis by 0.1 radians.
Rotate(new Vector3(1, 0, 0), 0.1f);
// shortened
RotateX(0.1f);</literal_block>
                    </div>
                </container>
                <paragraph>This rotates the node relative to the parent node.</paragraph>
                <paragraph>To rotate relative to object space (the node's own transform), use the following:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Rotate around the object's local X axis by 0.1 radians.
rotate_object_local(Vector3(1, 0, 0), 0.1)</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Rotate around the object's local X axis by 0.1 radians.
RotateObjectLocal(new Vector3(1, 0, 0), 0.1f);</literal_block>
                    </div>
                </container>
                <paragraph>The axis should be defined in the local coordinate system of the object. For example, to rotate around the object's local X, Y, or Z axes, use <literal>Vector3.RIGHT</literal> for the X-axis, <literal>Vector3.UP</literal> for the Y-axis, and <literal>Vector3.FORWARD</literal> for the Z-axis.</paragraph>
            </section>
            <section ids="precision-errors" names="precision\ errors">
                <title>Precision errors</title>
                <paragraph>Doing successive operations on transforms will result in a loss of precision due to floating-point error. This means the scale of each axis may no longer be exactly <literal>1.0</literal>, and they may not be exactly <literal>90</literal> degrees from each other.</paragraph>
                <paragraph>If a transform is rotated every frame, it will eventually start deforming over time. This is unavoidable.</paragraph>
                <paragraph>There are two different ways to handle this. The first is to <emphasis>orthonormalize</emphasis> the transform after some time (maybe once per frame if you modify it every frame):</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">transform = transform.orthonormalized()</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">transform = transform.Orthonormalized();</literal_block>
                    </div>
                </container>
                <paragraph>This will make all axes have <literal>1.0</literal> length again and be <literal>90</literal> degrees from each other. However, any scale applied to the transform will be lost.</paragraph>
                <paragraph>It is recommended you not scale nodes that are going to be manipulated; scale their children nodes instead (such as MeshInstance3D). If you absolutely must scale the node, then re-apply it at the end:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">transform = transform.orthonormalized()
transform = transform.scaled(scale)</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">transform = transform.Orthonormalized();
transform = transform.Scaled(scale);</literal_block>
                    </div>
                </container>
            </section>
            <section ids="obtaining-information" names="obtaining\ information">
                <title>Obtaining information</title>
                <paragraph>You might be thinking at this point: <strong>"Ok, but how do I get angles from a transform?"</strong>. The answer again is: you don't. You must do your best to stop thinking in angles.</paragraph>
                <paragraph>Imagine you need to shoot a bullet in the direction your player is facing. Just use the forward axis.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># On RigidBody3D.

# Keep in mind that -Z is forward.
bullet.transform = transform
bullet.linear_velocity = -transform.basis.z * BULLET_SPEED</literal_block>
                    </div>
                    <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// On RigidBody3D.

// Keep in mind that -Z is forward.
bullet.Transform = Transform;
bullet.LinearVelocity = -Transform.Basis.Z * BulletSpeed;</literal_block>
                    </div>
                </container>
                <paragraph>Is the enemy looking at the player? Use the dot product for this (see the <reference internal="True" refuri="../math/vector_math#doc-vector-math"><inline classes="std std-ref">Vector math</inline></reference> tutorial for an explanation of the dot product):</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Get the direction vector from player to enemy
var direction = enemy.transform.origin - player.transform.origin
if direction.dot(enemy.transform.basis.z) &gt; 0:
    enemy.im_watching_you(player)</literal_block>
                    </div>
                    <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Get the direction vector from player to enemy
Vector3 direction = enemy.Transform.Origin - player.Transform.Origin;
if (direction.Dot(enemy.Transform.Basis.Z) &gt; 0)
{
    enemy.ImWatchingYou(player);
}</literal_block>
                    </div>
                </container>
                <paragraph>Strafe left:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># On CharacterBody3D.

# Keep in mind that -X is left.
if Input.is_action_pressed("strafe_left"):
    velocity = -transform.basis.x * MOVE_SPEED

move_and_slide()</literal_block>
                    </div>
                    <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// On CharacterBody3D.

// Keep in mind that -X is left.
if (Input.IsActionPressed("strafe_left"))
{
    Velocity = -Transform.Basis.X * MoveSpeed;
}

MoveAndSlide();</literal_block>
                    </div>
                </container>
                <paragraph>Jump:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># On CharacterBody3D.

# Keep in mind that +Y is up.
if Input.is_action_just_pressed("jump"):
    velocity.y = JUMP_SPEED

move_and_slide()</literal_block>
                    </div>
                    <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// On CharacterBody3D.

// Keep in mind that +Y is up.
if (Input.IsActionJustPressed("jump"))
{
    Velocity = Vector3.Up * JumpSpeed;
}

MoveAndSlide();</literal_block>
                    </div>
                </container>
                <paragraph>All common behaviors and logic can be done with just vectors.</paragraph>
            </section>
            <section ids="setting-information" names="setting\ information">
                <title>Setting information</title>
                <paragraph>There are, of course, cases where you want to set information to a transform. Imagine a first person controller or orbiting camera. Those are definitely done using angles, because you <emphasis>do want</emphasis> the transforms to happen in a specific order.</paragraph>
                <paragraph>For such cases, keep the angles and rotations <emphasis>outside</emphasis> the transform and set them every frame. Don't try to retrieve and reuse them because the transform is not meant to be used this way.</paragraph>
                <paragraph>Example of looking around, FPS style:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-10-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-10-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-10-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># accumulators
var rot_x = 0
var rot_y = 0

func _input(event):
    if event is InputEventMouseMotion and event.button_mask &amp; 1:
        # modify accumulated mouse rotation
        rot_x -= event.relative.x * LOOKAROUND_SPEED
        rot_y -= event.relative.y * LOOKAROUND_SPEED
        transform.basis = Basis() # reset rotation
        rotate_object_local(Vector3(0, 1, 0), rot_x) # first rotate in Y
        rotate_object_local(Vector3(1, 0, 0), rot_y) # then rotate in X</literal_block>
                    </div>
                    <div aria-labelledby="tab-10-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-10-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// accumulators
private float _rotationX = 0f;
private float _rotationY = 0f;

public override void _Input(InputEvent @event)
{
    if (@event is InputEventMouseMotion mouseMotion)
    {
        // modify accumulated mouse rotation
        _rotationX -= mouseMotion.Relative.X * LookAroundSpeed;
        _rotationY -= mouseMotion.Relative.Y * LookAroundSpeed;

        // reset rotation
        Transform3D transform = Transform;
        transform.Basis = Basis.Identity;
        Transform = transform;

        RotateObjectLocal(Vector3.Up, _rotationX); // first rotate about Y
        RotateObjectLocal(Vector3.Right, _rotationY); // then rotate about X
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>As you can see, in such cases it's even simpler to keep the rotation outside, then use the transform as the <emphasis>final</emphasis> orientation.</paragraph>
            </section>
            <section ids="interpolating-with-quaternions" names="interpolating\ with\ quaternions">
                <title>Interpolating with quaternions</title>
                <paragraph>Interpolating between two transforms can efficiently be done with quaternions. More information about how quaternions work can be found in other places around the Internet. For practical use, it's enough to understand that pretty much their main use is doing a closest path interpolation. As in, if you have two rotations, a quaternion will smoothly allow interpolation between them using the closest axis.</paragraph>
                <paragraph>Converting a rotation to quaternion is straightforward.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-11-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-11-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-11-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Convert basis to quaternion, keep in mind scale is lost
var a = Quaternion(transform.basis)
var b = Quaternion(transform2.basis)
# Interpolate using spherical-linear interpolation (SLERP).
var c = a.slerp(b,0.5) # find halfway point between a and b
# Apply back
transform.basis = Basis(c)</literal_block>
                    </div>
                    <div aria-labelledby="tab-11-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-11-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Convert basis to quaternion, keep in mind scale is lost
var a = new Quaternion(transform.Basis);
var b = new Quaternion(transform2.Basis);
// Interpolate using spherical-linear interpolation (SLERP).
var c = a.Slerp(b, 0.5f); // find halfway point between a and b
// Apply back
transform.Basis = new Basis(c);</literal_block>
                    </div>
                </container>
                <paragraph>The <reference internal="True" refuri="../../classes/class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> type reference has more information on the datatype (it
                    can also do transform accumulation, transform points, etc., though this is used
                    less often). If you interpolate or apply operations to quaternions many times,
                    keep in mind they need to be eventually normalized. Otherwise, they will also
                    suffer from numerical precision errors.</paragraph>
                <paragraph>Quaternions are useful when doing camera/path/etc. interpolations, as the result will always be correct and smooth.</paragraph>
            </section>
        </section>
        <section ids="transforms-are-your-friend" names="transforms\ are\ your\ friend">
            <title>Transforms are your friend</title>
            <paragraph>For most beginners, getting used to working with transforms can take some time. However, once you get used to them, you will appreciate their simplicity and power.</paragraph>
            <paragraph>Don't hesitate to ask for help on this topic in any of Godot's <reference name="online communities" refuri="https://godotengine.org/community">online communities</reference><target ids="online-communities" names="online\ communities" refuri="https://godotengine.org/community"></target> and, once you become confident enough, please help others!</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
