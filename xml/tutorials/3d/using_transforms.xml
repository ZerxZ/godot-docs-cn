<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/using_transforms.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-transforms"></target>
    <section ids="using-3d-transforms doc-using-transforms" names="using\ 3d\ transforms 使用\ 3d\ 变换 doc_using_transforms">
        <title>使用 3D 变换</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>如果你以前从未制作过3D游戏, 那么一开始在三维环境中进行旋转可能会让人感到困惑. 从2D来的人, 自然的思维方式就是类似于 <emphasis>"噢, 它就像2D旋转一样, 只是现在旋转发生在X,Y和Z轴上"</emphasis> .</paragraph>
            <paragraph>起初这似乎很简单。对于简单的游戏，这种思维方式甚至可能足够了。不幸的是，这往往是不正确的。</paragraph>
            <paragraph>三维角度通常被称为“欧拉角”。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/transforms_euler.png'}" uri="tutorials/3d/img/transforms_euler.png"></image>
            <paragraph>欧拉角是由数学家莱昂哈德·欧拉在 1700 年代初引入的。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/transforms_euler_himself.png'}" uri="tutorials/3d/img/transforms_euler_himself.png"></image>
            <paragraph>这种代表三维旋转的方式在当时是开创性的, 但在游戏开发中使用时有一些缺点(这毕竟是一个戴着滑稽帽子的家伙想出来的). 本文的主旨是解释其原因, 并概述在编写3D游戏时处理变换的最佳做法.</paragraph>
        </section>
        <section ids="problems-of-euler-angles" names="problems\ of\ euler\ angles 欧拉角的问题">
            <title>欧拉角的问题</title>
            <paragraph>虽然看起来很直观, 每个轴都有一个旋转, 但事实是它就是不实用.</paragraph>
            <section ids="axis-order" names="axis\ order 轴顺序">
                <title>轴顺序</title>
                <paragraph>这样的主要原因是没有一种 <emphasis>单一</emphasis> 的从角度构建方向的方法. 没有一个标准的数学函数可以将所有角度放在一起并产生实际的3D旋转. 从角度产生方向的唯一方法是以 <emphasis>任意顺序</emphasis> 按角度旋转物体角度.</paragraph>
                <paragraph>这可以通过先旋转 <emphasis>X</emphasis> , 然后 <emphasis>Y</emphasis> , 然后旋转 <emphasis>Z</emphasis> 来完成. 或者, 你可以先以旋转 <emphasis>Y</emphasis> , 然后旋转 <emphasis>Z</emphasis> , 最后旋转 <emphasis>X</emphasis> . 怎样都行, 但根据顺序不同, 对象的最终方向 <emphasis>不一定是相同的</emphasis> . 事实上, 这意味着有多种方法可以从3个不同的角度构建方向, 具体取决于 <emphasis>旋转的顺序</emphasis> .</paragraph>
                <paragraph>下图是一个万向结(来自维基百科), 它有可视化的旋转轴(以XYZ顺序). 如你所见, 每个轴的方向取决于前一个轴的旋转方向:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/transforms_gimbal.gif'}" uri="tutorials/3d/img/transforms_gimbal.gif"></image>
                <paragraph>你可能想知道这是如何影响你的. 我们来看一个实际的示例:</paragraph>
                <paragraph>想象一下, 你正在做一个第一人称控制器(例如FPS游戏). 向左和向右移动鼠标可以控制与地面平行的视角, 同时上下移动可以调整游戏角色上下的视野.</paragraph>
                <paragraph>为了实现希望的效果, 必须先在 <emphasis>Y</emphasis> 轴上应用旋转(在这种情况下为 "up(向上)", 因为Godot中Y轴指向正上方(" Y-Up" 方向)), 然后在 <emphasis>X</emphasis> 轴上旋转.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/transforms_rotate1.gif'}" uri="tutorials/3d/img/transforms_rotate1.gif"></image>
                <paragraph>如果我们首先在 <emphasis>X</emphasis> 轴上应用旋转, 然后再在 <emphasis>Y</emphasis> 轴上应用旋转, 则效果会不理想:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/transforms_rotate2.gif'}" uri="tutorials/3d/img/transforms_rotate2.gif"></image>
                <paragraph>根据所需的游戏类型或效果, 你想要应用轴旋转的顺序可能会有所不同. 因此, 在X,Y和Z中应用旋转是不够的: 你还需要 <emphasis>旋转顺序</emphasis> .</paragraph>
            </section>
            <section ids="interpolation" names="interpolation 插值">
                <title>插值</title>
                <paragraph>使用欧拉角的另一个问题是插值. 设想你想在两个不同的相机或敌人位置(包括旋转)之间转换. 解决这个问题的一个合乎逻辑的方法是从一个位置插值到下一个位置. 人们会期望它看起来像这样:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/transforms_interpolate1.gif'}" uri="tutorials/3d/img/transforms_interpolate1.gif"></image>
                <paragraph>但是, 在使用角度时, 这并不总是有预期的效果:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/transforms_interpolate2.gif'}" uri="tutorials/3d/img/transforms_interpolate2.gif"></image>
                <paragraph>相机实际上旋转去了相反的方向！</paragraph>
                <paragraph>这可能有几个原因:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>旋转不会线性映射到方向, 因此它们插值并不总是会形成最短路径(即从 <literal>270</literal> 到 <literal>0</literal> 的度数与从 <literal>270</literal> 开始到 <literal>360</literal> 的度数不同, 即使角度是相同的).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>"万向节锁死" 正在发挥作用(第一个和最后一个旋转的轴对齐, 因此失去了一个自由度). 请参阅 <reference name="维基百科关于Gimbal Lock 的页面" refuri="https://en.wikipedia.org/wiki/Gimbal_lock">维基百科关于Gimbal Lock 的页面</reference><target ids="gimbal-lock" names="维基百科关于gimbal\ lock\ 的页面" refuri="https://en.wikipedia.org/wiki/Gimbal_lock"></target> 以了解这个问题的详细解释.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="say-no-to-euler-angles" names="say\ no\ to\ euler\ angles 对欧拉角说不">
                <title>对欧拉角说不</title>
                <paragraph>所有这些的结论是，你 <strong>不应该</strong> 在游戏中使用 Godot <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> 节点的 <literal>rotation</literal> 属性。它主要用在编辑器中，为了与2D引擎一致，并且用于简单的旋转（通常只有一个轴，或者，在有限的情况下，两个）。尽管你可能会受到诱惑，但不要使用它。</paragraph>
                <paragraph>相反, 有一个更好的方法来解决你的旋转问题.</paragraph>
            </section>
        </section>
        <section ids="introducing-transforms" names="introducing\ transforms 变换的介绍">
            <title>变换的介绍</title>
            <paragraph>Godot 里的方向使用 <reference internal="True" refuri="../../classes/class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference> 数据类型。每个 <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> 节点都包含一个与父级变换相关的 <literal>transform</literal> 属性（如果父级是 Node3D 派生类型）。</paragraph>
            <paragraph>也可以通过 <literal>global_transform</literal> 属性访问世界坐标变换.</paragraph>
            <paragraph>变换拥有一个基 <reference internal="True" refuri="../../classes/class_basis#class-basis"><inline classes="std std-ref">Basis</inline></reference>（transform.basis 子属性），它由三个 <reference internal="True" refuri="../../classes/class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> 向量组成。这些向量可以通过 <literal>transform.basis</literal> 属性访问，也可以使用 <literal>transform.basis.x</literal>、<literal>transform.basis.y</literal>、<literal>transform.basis.z</literal> 直接访问。每个向量指向它的轴被旋转的方向，因此它们可以有效地描述节点的总旋转。比例（只要它三个轴长度是一致的）也可以从轴的长度推断出来。一个<emphasis>基</emphasis>也可以被解释为一个 3x3 矩阵并像 <literal>transform.basis[x][y]</literal> 这样使用。</paragraph>
            <paragraph>默认的基（未经修改）类似于：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var basis = Basis()
# Contains the following default values:
basis.x = Vector3(1, 0, 0) # Vector pointing along the X axis
basis.y = Vector3(0, 1, 0) # Vector pointing along the Y axis
basis.z = Vector3(0, 0, 1) # Vector pointing along the Z axis</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Due to technical limitations on structs in C# the default
// constructor will contain zero values for all fields.
var defaultBasis = new Basis();
GD.Print(defaultBasis); // prints: ((0, 0, 0), (0, 0, 0), (0, 0, 0))

// Instead we can use the Identity property.
var identityBasis = Basis.Identity;
GD.Print(identityBasis.X); // prints: (1, 0, 0)
GD.Print(identityBasis.Y); // prints: (0, 1, 0)
GD.Print(identityBasis.Z); // prints: (0, 0, 1)

// The Identity basis is equivalent to:
var basis = new Basis(Vector3.Right, Vector3.Up, Vector3.Back);
GD.Print(basis); // prints: ((1, 0, 0), (0, 1, 0), (0, 0, 1))</literal_block>
                </div>
            </container>
            <paragraph>这也类似于一个 3x3 单位矩阵。</paragraph>
            <paragraph>遵循OpenGL惯例, <literal>X</literal> 是 <emphasis>右</emphasis> 轴, <literal>Y</literal> 是 <emphasis>上</emphasis> 轴, <literal>Z</literal> 是 <emphasis>前</emphasis> 轴.</paragraph>
            <paragraph>变换除了<emphasis>基</emphasis>以外还有一个<emphasis>原点</emphasis>。这是一个 <emphasis>Vector3</emphasis>，用于指定该变换距离实际原点 <literal>(0, 0, 0)</literal> 有多远。<emphasis>变换</emphasis>是<emphasis>基</emphasis>与<emphasis>原点</emphasis>的组合，可以有效地表示空间中特定的平移、旋转和缩放。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/transforms_camera.png'}" uri="tutorials/3d/img/transforms_camera.png"></image>
            <paragraph>可视化变换的一种方法是在“本地空间”模式下查看该对象的 3D 小工具。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/transforms_local_space.png'}" uri="tutorials/3d/img/transforms_local_space.png"></image>
            <paragraph>小工具的箭头显示的是基的 <literal>X</literal>、<literal>Y</literal>、<literal>Z</literal> 轴（分别为红色、绿色、蓝色），小工具的中心位于该对象的原点。</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/transforms_gizmo.png'}" uri="tutorials/3d/img/transforms_gizmo.png"></image>
            <paragraph>有关向量和变换在数学方面的更多信息, 请阅读 <reference internal="True" refuri="../math/vector_math#doc-vector-math"><inline classes="std std-ref">向量数学</inline></reference> 教程.</paragraph>
            <section ids="manipulating-transforms" names="manipulating\ transforms 操作变换">
                <title>操作变换</title>
                <paragraph>当然, 变换并不像角度那样容易控制, 并且有它自己的问题.</paragraph>
                <paragraph>可以对变换进行旋转，方法是将基与另一个基相乘（称作累加），或者使用其旋转方法。</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var axis = Vector3(1, 0, 0) # Or Vector3.RIGHT
var rotation_amount = 0.1
# Rotate the transform around the X axis by 0.1 radians.
transform.basis = Basis(axis, rotation_amount) * transform.basis
# shortened
transform.basis = transform.basis.rotated(axis, rotation_amount)</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Transform3D transform = Transform;
Vector3 axis = new Vector3(1, 0, 0); // Or Vector3.Right
float rotationAmount = 0.1f;

// Rotate the transform around the X axis by 0.1 radians.
transform.Basis = new Basis(axis, rotationAmount) * transform.Basis;
// shortened
transform.Basis = transform.Basis.Rotated(axis, rotationAmount);

Transform = transform;</literal_block>
                    </div>
                </container>
                <paragraph>Node3D 中的一种方法简化了这个操作：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Rotate the transform around the X axis by 0.1 radians.
rotate(Vector3(1, 0, 0), 0.1)
# shortened
rotate_x(0.1)</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Rotate the transform around the X axis by 0.1 radians.
Rotate(new Vector3(1, 0, 0), 0.1f);
// shortened
RotateX(0.1f);</literal_block>
                    </div>
                </container>
                <paragraph>这会相对于父节点来旋转节点.</paragraph>
                <paragraph>要相对于对象空间旋转(节点自己的变换), 请使用下面的方法:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Rotate around the object's local X axis by 0.1 radians.
rotate_object_local(Vector3(1, 0, 0), 0.1)</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Rotate around the object's local X axis by 0.1 radians.
RotateObjectLocal(new Vector3(1, 0, 0), 0.1f);</literal_block>
                    </div>
                </container>
            </section>
            <section ids="precision-errors" names="precision\ errors 精度误差">
                <title>精度误差</title>
                <paragraph>对变换执行连续的操作将导致由于浮点错误导致的精度损失. 这意味着每个轴的比例可能不再精确地为 <literal>1.0</literal> , 并且它们可能不完全相互为 <literal>90</literal> 度.</paragraph>
                <paragraph>如果一个变换每帧旋转一次, 它最终会随着时间的推移开始变形. 这是不可避免的.</paragraph>
                <paragraph>有两种不同的方法来处理这个问题. 首先是在一段时间后对变换进行 <emphasis>正交归一化(orthonormalize)</emphasis> 处理(如果每帧修改一次, 则可能每帧一次):</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">transform = transform.orthonormalized()</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">transform = transform.Orthonormalized();</literal_block>
                    </div>
                </container>
                <paragraph>这将使所有的轴再次拥有有 <literal>1.0</literal> 的长度并且彼此成 <literal>90</literal> 度角. 但是, 应用于变换的任何缩放都将丢失.</paragraph>
                <paragraph>建议你不要缩放将要操作的节点；而是缩放其子节点（例如 MeshInstance3D）。如果你绝对必须要缩放节点，请在最后重新应用它：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">transform = transform.orthonormalized()
transform = transform.scaled(scale)</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">transform = transform.Orthonormalized();
transform = transform.Scaled(scale);</literal_block>
                    </div>
                </container>
            </section>
            <section ids="obtaining-information" names="obtaining\ information 获取信息">
                <title>获取信息</title>
                <paragraph>现在你可能在想: <strong>"好吧, 但是我怎么从变换中获得角度？"</strong> . 答案又一次是: 没有必要. 你必须尽最大努力停止用角度思考.</paragraph>
                <paragraph>想象一下, 你需要朝你的游戏角色面对的方向射击子弹. 只需使用向前的轴(通常为 <literal>Z</literal> 或 <literal>-Z</literal> ).</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">bullet.transform = transform
bullet.speed = transform.basis.z * BULLET_SPEED</literal_block>
                    </div>
                    <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">bullet.Transform = transform;
bullet.LinearVelocity = transform.Basis.Z * BulletSpeed;</literal_block>
                    </div>
                </container>
                <paragraph>敌人在看着游戏角色吗？ 为此判断你可以使用点积（请参阅 <reference internal="True" refuri="../math/vector_math#doc-vector-math"><inline classes="std std-ref">向量数学</inline></reference> 教程以获取对点积的解释）：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Get the direction vector from player to enemy
var direction = enemy.transform.origin - player.transform.origin
if direction.dot(enemy.transform.basis.z) &gt; 0:
    enemy.im_watching_you(player)</literal_block>
                    </div>
                    <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Get the direction vector from player to enemy
Vector3 direction = enemy.Transform.Origin - player.Transform.Origin;
if (direction.Dot(enemy.Transform.Basis.Z) &gt; 0)
{
    enemy.ImWatchingYou(player);
}</literal_block>
                    </div>
                </container>
                <paragraph>向左平移:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Remember that +X is right
if Input.is_action_pressed("strafe_left"):
    translate_object_local(-transform.basis.x)</literal_block>
                    </div>
                    <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Remember that +X is right
if (Input.IsActionPressed("strafe_left"))
{
    TranslateObjectLocal(-Transform.Basis.X);
}</literal_block>
                    </div>
                </container>
                <paragraph>跳跃:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Keep in mind Y is up-axis
if Input.is_action_just_pressed("jump"):
    velocity.y = JUMP_SPEED

move_and_slide()</literal_block>
                    </div>
                    <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Keep in mind Y is up-axis
if (Input.IsActionJustPressed("jump"))
    velocity.Y = JumpSpeed;

MoveAndSlide();</literal_block>
                    </div>
                </container>
                <paragraph>所有常见的行为和逻辑都可以用向量来完成.</paragraph>
            </section>
            <section ids="setting-information" names="setting\ information 设置信息">
                <title>设置信息</title>
                <paragraph>当然, 有些情况下你想要将一些信息赋予到变换上. 想象一下第一人称控制器或环绕旋转的摄像机. 那些肯定是用角度来完成的, 因为你 <emphasis>确实希望</emphasis> 变换以特定的顺序进行.</paragraph>
                <paragraph>对于这种情况，请保证角度和旋转在变换 <emphasis>外部</emphasis> ，并在每帧设置他们。不要尝试获取并重新使用它们，因为变换是不应该以这种方式使用的。</paragraph>
                <paragraph>环顾四周,FPS风格的示例:</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-10-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-10-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-10-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># accumulators
var rot_x = 0
var rot_y = 0

func _input(event):
    if event is InputEventMouseMotion and event.button_mask &amp; 1:
        # modify accumulated mouse rotation
        rot_x += event.relative.x * LOOKAROUND_SPEED
        rot_y += event.relative.y * LOOKAROUND_SPEED
        transform.basis = Basis() # reset rotation
        rotate_object_local(Vector3(0, 1, 0), rot_x) # first rotate in Y
        rotate_object_local(Vector3(1, 0, 0), rot_y) # then rotate in X</literal_block>
                    </div>
                    <div aria-labelledby="tab-10-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-10-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// accumulators
private float _rotationX = 0f;
private float _rotationY = 0f;

public override void _Input(InputEvent @event)
{
    if (@event is InputEventMouseMotion mouseMotion)
    {
        // modify accumulated mouse rotation
        _rotationX += mouseMotion.Relative.X * LookAroundSpeed;
        _rotationY += mouseMotion.Relative.Y * LookAroundSpeed;

        // reset rotation
        Transform3D transform = Transform;
        transform.Basis = Basis.Identity;
        Transform = transform;

        RotateObjectLocal(Vector3.Up, _rotationX); // first rotate about Y
        RotateObjectLocal(Vector3.Right, _rotationY); // then rotate about X
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>如你所见, 在这种情况下, 保持外部旋转更为简单, 然后使用变换作为 <emphasis>最后的</emphasis> 方向.</paragraph>
            </section>
            <section ids="interpolating-with-quaternions" names="interpolating\ with\ quaternions 用四元数插值">
                <title>用四元数插值</title>
                <paragraph>用四元数能有效率地完成两个变换之间的插值. 有关四元数如何工作的更多信息可以在互联网上的其他地方找到. 在实际应用中, 了解它们的主要用途是做最短路插值就足够了. 同样, 如果你有两个旋转, 四元数将平滑地使用最近的轴在它们之间进行插值.</paragraph>
                <paragraph>将旋转转换为四元数很简单.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-11-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-11-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-11-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Convert basis to quaternion, keep in mind scale is lost
var a = Quaternion(transform.basis)
var b = Quaternion(transform2.basis)
# Interpolate using spherical-linear interpolation (SLERP).
var c = a.slerp(b,0.5) # find halfway point between a and b
# Apply back
transform.basis = Basis(c)</literal_block>
                    </div>
                    <div aria-labelledby="tab-11-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-11-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Convert basis to quaternion, keep in mind scale is lost
var a = transform.Basis.GetQuaternion();
var b = transform2.Basis.GetQuaternion();
// Interpolate using spherical-linear interpolation (SLERP).
var c = a.Slerp(b, 0.5f); // find halfway point between a and b
// Apply back
transform.Basis = new Basis(c);</literal_block>
                    </div>
                </container>
                <paragraph><reference internal="True" refuri="../../classes/class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> 类型参考包含有关数据类型的更多信息（它还可以进行变换累积、变换点等，尽管使用较少）。如果你多次对四元数进行插值或应用运算，请记住它们最终需要归一化。否则，会带来数值精度误差。</paragraph>
                <paragraph>四元数在处理相机/路径/等东西的移动轨迹时很有用. 插值的结果总会是正确且平滑的.</paragraph>
            </section>
        </section>
        <section ids="transforms-are-your-friend" names="transforms\ are\ your\ friend 变换是你的朋友">
            <title>变换是你的朋友</title>
            <paragraph>对于大多数初学者来说, 习惯于使用变换可能需要一些时间. 但是, 一旦你习惯了它们, 你会欣赏他们的简单而有力.</paragraph>
            <paragraph>不要犹豫, 在Godot的任何 <reference name="线上社区" refuri="https://godotengine.org/community">线上社区</reference><target ids="id1" names="线上社区" refuri="https://godotengine.org/community"></target> 网站上寻求帮助, 一旦你变得足够自信, 请帮助其他人！</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
