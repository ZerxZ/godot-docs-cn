<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/standard_material_3d.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-standard-material-3d"></target>
    <section ids="standard-material-3d-and-orm-material-3d doc-standard-material-3d" names="standard\ material\ 3d\ and\ orm\ material\ 3d doc_standard_material_3d">
        <title>Standard Material 3D and ORM Material 3D</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph><literal>StandardMaterial3D</literal> and <literal>ORMMaterial3D</literal> (Occlusion, Roughness, Metallic)
                are default 3D materials that aim to provide most of the features artists look
                for in a material, without the need for writing shader code. However, they can
                be converted to shader code if additional functionality is needed.</paragraph>
            <paragraph>This tutorial explains the parameters present in both materials.</paragraph>
            <paragraph>There are 4 ways to add these materials to an object. A material can be added in
                the <emphasis>Material</emphasis> property of the mesh. It can be added in the <emphasis>Material</emphasis> property of
                the node using the mesh (such as a MeshInstance3D node), the <emphasis>Material Override</emphasis> property
                of the node using the mesh, and the <emphasis>Material Overlay</emphasis>.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/add_material.webp'}" original_uri="img/add_material.webp" uri="tutorials/3d/img/add_material.webp"></image>
            <paragraph>If you add a material to the mesh itself, every time that mesh is used it will have that
                material. If you add a material to the node using the mesh, the material will only be used
                by that node, it will also override the material property of the mesh. If a material is
                added in the <emphasis>Material Override</emphasis> property of the node, it will only be used by that node.
                It will also override the regular material property of the node and the material property of
                the mesh.</paragraph>
            <paragraph>The <emphasis>Material Overlay</emphasis> property will render a material <strong>over</strong> the current one being used by
                the mesh. As an example, this can be used to put a transparent shield effect on a mesh.</paragraph>
        </section>
        <section ids="basematerial-3d-settings" names="basematerial\ 3d\ settings">
            <title>BaseMaterial 3D settings</title>
            <paragraph>StandardMaterial3D has many settings that determine the look of a material. All of these are
                under the BaseMaterial3D category</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material1.webp'}" original_uri="img/spatial_material1.webp" uri="tutorials/3d/img/spatial_material1.webp"></image>
            <paragraph>ORM materials are almost exactly the same with one difference. Instead of separate settings
                and textures for occlusion, roughness, and metallic, there is a single ORM texture. The different
                color channels of that texture are used for each parameter. Programs such as Substance Painter
                and Armor Paint will give you the option to export in this format, for these two programs it's
                with the export preset for unreal engine, which also uses ORM textures.</paragraph>
        </section>
        <section ids="transparency" names="transparency">
            <title>Transparency</title>
            <paragraph>By default, materials in Godot are opaque. This is fast to render, but it means
                the material can't be seen through even if you use a transparent texture in the
                <strong>Albedo &gt; Texture</strong> property (or set <strong>Albedo &gt; Color</strong> to a transparent color).</paragraph>
            <paragraph>To be able to see through a material, the material needs to be made <emphasis>transparent</emphasis>.
                Godot offers several transparency modes:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Disabled:</strong> Material is opaque. This is the fastest to render, with all
                        rendering features supported.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Alpha:</strong> Material is transparent. Semi-transparent areas are drawn with
                        blending. This is slow to render, but it allows for partial transparency (also
                        known as translucency). Materials using alpha blending also can't cast
                        shadows, and are not visible in screen-space reflections.</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><strong>Alpha</strong> is a good fit for particle effects and VFX.</paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><strong>Alpha Scissor:</strong> Material is transparent. Semi-transparent areas whose
                        opacity is below <strong>Alpha Scissor Threshold</strong> are not drawn (above this
                        opacity, these are drawn as opaque). This is faster to render than Alpha and
                        doesn't exhibit transparency sorting issues. The downside is that this results
                        in "all or nothing" transparency, with no intermediate values possible.
                        Materials using alpha scissor can cast shadows.</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><strong>Alpha Scissor</strong> is ideal for foliage and fences, since these have hard
                                edges and require correct sorting to look good.</paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><strong>Alpha Hash:</strong> Material is transparent. Semi-transparent areas are drawn
                        using dithering. This is also "all or nothing" transparency, but dithering
                        helps represent partially opaque areas with limited precision depending on
                        viewport resolution. Materials using alpha hash can cast shadows.</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><strong>Alpha Hash</strong> is suited for realistic-looking hair, although stylized hair
                                may work better with alpha scissor.</paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph><strong>Depth Pre-Pass:</strong> This renders the object's fully opaque pixels via the
                        opaque pipeline first, then renders the rest with alpha blending. This allows
                        transparency sorting to be <emphasis>mostly</emphasis> correct (albeit not fully so, as partially
                        transparent regions may still exhibit incorrect sorting). Materials using
                        depth prepass can cast shadows.</paragraph>
                </list_item>
            </bullet_list>
            <note>
                <paragraph>Godot will automatically force the material to be transparent with alpha
                    blending if <emphasis>any</emphasis> of these conditions is met:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Setting the transparency mode to <strong>Alpha</strong> (as described here).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Setting a blend mode other than the default <strong>Mix</strong></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Enabling <strong>Refraction</strong>, <strong>Proximity Fade</strong>, or <strong>Distance Fade</strong>.</paragraph>
                    </list_item>
                </bullet_list>
            </note>
            <paragraph>Comparison between alpha blending (left) and alpha scissor (right) transparency:</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material12.png'}" original_uri="img/spatial_material12.png" uri="tutorials/3d/img/spatial_material12.png"></image>
            <warning>
                <paragraph>Alpha-blended transparency has several
                    <reference internal="True" refuri="3d_rendering_limitations#doc-3d-rendering-limitations-transparency-sorting"><inline classes="std std-ref">limitations</inline></reference>:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Alpha-blended materials are significantly slower to render, especially if
                            they overlap.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Alpha-blended materials may exhibit sorting issues when transparent
                            surfaces overlap each other. This means that surfaces may render in the
                            incorrect order, with surfaces in the back appearing to be in front of
                            those which are actually closer to the camera.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Alpha-blended materials don't cast shadows, although they can receive shadows.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Alpha-blended materials don't appear in any reflections (other than
                            reflection probes).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Screen-space reflections and sharp SDFGI reflections don't appear on
                            alpha-blended materials. When SDFGI is enabled, rough reflections are used
                            as a fallback regardless of material roughness.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Before using the <strong>Alpha</strong> transparency mode, always consider whether
                    another transparency mode is more suited for your needs.</paragraph>
            </warning>
            <target refid="doc-standard-material-3d-alpha-antialiasing"></target>
            <section ids="alpha-antialiasing doc-standard-material-3d-alpha-antialiasing" names="alpha\ antialiasing doc_standard_material_3d_alpha_antialiasing">
                <title>Alpha Antialiasing</title>
                <note>
                    <paragraph>This property is only visible when the transparency mode is
                        <strong>Alpha Scissor</strong> or <strong>Alpha Hash</strong>.</paragraph>
                </note>
                <paragraph>While alpha scissor and alpha hash materials are faster to render than
                    alpha-blended materials, they exhibit hard edges between opaque and transparent
                    regions. While it's possible to use post-processing-based <reference internal="True" refuri="3d_antialiasing#doc-3d-antialiasing"><inline classes="std std-ref">antialiasing
                            techniques</inline></reference> such as FXAA and TAA, this is not always
                    desired as these techniques tend to make the final result look blurrier or
                    exhibit ghosting artifacts.</paragraph>
                <paragraph>There are 3 alpha antialiasing modes available:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Disabled:</strong> No alpha antialiasing. Edges of transparent materials will
                            appear aliased unless a post-processing-based antialiasing solution is used.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Alpha Edge Blend:</strong> Results in a smooth transition between opaque and
                            transparent areas. Also known as "alpha to coverage".</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Alpha Edge Clip:</strong> Results in a sharp, but still antialiased transition
                            between opaque and transparent areas. Also known as "alpha to coverage + alpha
                            to one".</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>When the alpha antialiasing mode is set to <strong>Alpha Edge Blend</strong> or <strong>Alpha Edge
                        Clip</strong>, a new <strong>Alpha Antialiasing Edge</strong> property becomes visible below in the
                    inspector. This property controls the threshold below which pixels should be
                    made transparent. While you've already defined an alpha scissor threshold (when
                    using <strong>Alpha Scissor</strong> only), this additional threshold is used to smoothly
                    transition between opaque and transparent pixels. <strong>Alpha Antialiasing Edge</strong>
                    must <emphasis>always</emphasis> be set to a value that is strictly below the alpha scissor
                    threshold. The default of <literal>0.3</literal> is a sensible value with an alpha scissor of
                    threshold of <literal>0.5</literal>, but remember to adjust this alpha antialiasing edge when
                    modifying the alpha scissor threshold.</paragraph>
                <paragraph>If you find the antialiasing effect not effective enough, try increasing <strong>Alpha
                        Antialiasing Edge</strong> while making sure it's below <strong>Alpha Scissor Threshold</strong> (if
                    the material uses alpha scissor). On the other hand, if you notice the texture's
                    appearance visibly changing as the camera moves closer to the material, try
                    decreasing <strong>Alpha Antialiasing Edge</strong>.</paragraph>
                <important>
                    <paragraph>For best results, MSAA 3D should be set to at least 2× in the Project
                        Settings when using alpha antialiasing. This is because this feature relies
                        on alpha to coverage, which is a feature provided by MSAA.</paragraph>
                    <paragraph>Without MSAA, a fixed dithering pattern is applied on the material's edges,
                        which isn't very effective at smoothing out edges (although it can still
                        help a little).</paragraph>
                </important>
            </section>
            <section ids="blend-mode" names="blend\ mode">
                <title>Blend Mode</title>
                <paragraph>Controls the blend mode for the material. Keep in mind that any mode
                    other than <emphasis>Mix</emphasis> forces the object to go through the transparent pipeline.</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><strong>Mix:</strong> Default blend mode, alpha controls how much the object is visible.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Add:</strong> The final color of the object is added to the color of the screen,
                            nice for flares or some fire-like effects.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Subtract:</strong> The final color of the object is subtracted from the color of the
                            screen.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Multiply:</strong> The final color of the object is multiplied with the color of the
                            screen.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Premultiplied Alpha:</strong> The color of the object is expected to have already been
                            multiplied by the alpha. This behaves like <strong>Add</strong> when the alpha is <literal>0.0</literal>
                            (fully transparent) and like <strong>Mix</strong> when the alpha is <literal>1.0</literal> (opaque).</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/spatial_material8.png'}" original_uri="img/spatial_material8.png" uri="tutorials/3d/img/spatial_material8.png"></image>
            </section>
            <section ids="cull-mode" names="cull\ mode">
                <title>Cull Mode</title>
                <paragraph>Determines which side of the object is not drawn when backfaces are rendered:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><strong>Back:</strong> The back of the object is culled when not visible (default).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Front:</strong> The front of the object is culled when not visible.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Disabled:</strong> Used for objects that are double-sided (no culling is performed).</paragraph>
                    </list_item>
                </bullet_list>
                <note>
                    <paragraph>By default, Blender has backface culling disabled on materials and will
                        export materials to match how they render in Blender. This means that
                        materials in Godot will have their cull mode set to <strong>Disabled</strong>. This can
                        decrease performance since backfaces will be rendered, even when they are
                        being culled by other faces. To resolve this, enable <strong>Backface Culling</strong> in
                        Blender's Materials tab, then export the scene to glTF again.</paragraph>
                </note>
            </section>
            <section ids="depth-draw-mode" names="depth\ draw\ mode">
                <title>Depth Draw Mode</title>
                <paragraph>Specifies when depth rendering must take place.</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><strong>Opaque Only (default):</strong> Depth is only drawn for opaque objects.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Always:</strong> Depth draw is drawn for both opaque and transparent objects.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Never:</strong> No depth draw takes place
                            (do not confuse this with the No Depth Test option below).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Depth Pre-Pass:</strong> For transparent objects, an opaque pass is made first
                            with the opaque parts, then transparency is drawn above.
                            Use this option with transparent grass or tree foliage.</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/material_depth_draw.png'}" original_uri="img/material_depth_draw.png" uri="tutorials/3d/img/material_depth_draw.png"></image>
            </section>
            <section ids="no-depth-test" names="no\ depth\ test">
                <title>No Depth Test</title>
                <paragraph>In order for close objects to appear over far away objects, depth testing
                    is performed. Disabling it has the result of objects appearing over
                    (or under) everything else.</paragraph>
                <paragraph>Disabling this makes the most sense for drawing indicators in world space,
                    and works very well with the <emphasis>Render Priority</emphasis> property of Material
                    (see the bottom of this page).</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/spatial_material3.png'}" original_uri="img/spatial_material3.png" uri="tutorials/3d/img/spatial_material3.png"></image>
            </section>
            <section ids="depth-test" names="depth\ test">
                <title>Depth Test</title>
                <paragraph>This can be used to invert the standard depth test. When set to <strong>Inverted</strong>,
                    the object will only appear when occluded, and will be hidden otherwise.</paragraph>
                <paragraph>This has no effect if <strong>No Depth Test</strong> is enabled.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/material_depth_test.webp'}" original_uri="img/material_depth_test.webp" uri="tutorials/3d/img/material_depth_test.webp"></image>
            </section>
        </section>
        <section ids="shading" names="shading">
            <title>Shading</title>
            <section ids="shading-mode" names="shading\ mode">
                <title>Shading mode</title>
                <paragraph>Materials support three shading modes: <strong>Per-Pixel</strong>, <strong>Per-Vertex</strong>, and
                    <strong>Unshaded</strong>.</paragraph>
                <figure align="center">
                    <image alt="Three spheres showing the Per-Pixel, Per-Vertex, and Unshaded modes." candidates="{'*': 'tutorials/3d/img/standard_material_shading_modes.webp'}" original_uri="img/standard_material_shading_modes.webp" uri="tutorials/3d/img/standard_material_shading_modes.webp"></image>
                </figure>
                <paragraph>The <strong>Per-Pixel</strong> shading mode calculates lighting for each pixel, and is a good
                    fit for most use cases. However, in some cases you may want to increase
                    performance by using another shading mode.</paragraph>
                <paragraph>The <strong>Per-Vertex</strong> shading mode, often called "vertex shading" or "vertex lighting",
                    instead calculates lighting once for each vertex, and interpolates the result
                    between each pixel.</paragraph>
                <paragraph>On low-end or mobile devices, using per-vertex lighting can considerably increase
                    rendering performance. When rendering several layers of transparency,
                    such as when using particle systems, using per-vertex shading can improve
                    performance, especially when the camera is close to particles.</paragraph>
                <paragraph>You can also use per-vertex lighting to achieve a retro look.</paragraph>
                <figure align="center" ids="id1">
                    <image alt="Two cubes with a brick texture, one shaded and one unshaded." candidates="{'*': 'tutorials/3d/img/standard_material_shading_modes_textured.webp'}" original_uri="img/standard_material_shading_modes_textured.webp" uri="tutorials/3d/img/standard_material_shading_modes_textured.webp"></image>
                    <caption>Texture from <reference name="AmbientCG" refuri="https://ambientcg.com/view?id=Bricks051">AmbientCG</reference></caption>
                </figure>
                <paragraph>The <strong>Unshaded</strong> shading mode does not calculate lighting at all. Instead, the
                    <strong>Albedo</strong> color is output directly. Lights will not affect the material at all,
                    and unshaded materials will tend to appear considerably brighter than shaded
                    materials.</paragraph>
                <paragraph>Rendering unshaded is useful for some specific visual effects. If maximum
                    performance is needed, it can also be used for particles, or low-end or
                    mobile devices.</paragraph>
            </section>
            <section ids="diffuse-mode" names="diffuse\ mode">
                <title>Diffuse Mode</title>
                <paragraph>Specifies the algorithm used by diffuse scattering of light when hitting
                    the object. The default is <strong>Burley</strong>. Other modes are also available:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><strong>Burley:</strong> Default mode, the original Disney Principled PBS diffuse algorithm.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Lambert:</strong> Is not affected by roughness.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Lambert Wrap:</strong> Extends Lambert to cover more than 90 degrees when
                            roughness increases. Works great for hair and simulating cheap
                            subsurface scattering. This implementation is energy conserving.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Toon:</strong> Provides a hard cut for lighting, with smoothing affected by roughness.
                            It is recommended you disable sky contribution from your environment's
                            ambient light settings or disable ambient light in the StandardMaterial3D
                            to achieve a better effect.</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/spatial_material6.webp'}" original_uri="img/spatial_material6.webp" uri="tutorials/3d/img/spatial_material6.webp"></image>
            </section>
            <section ids="specular-mode" names="specular\ mode">
                <title>Specular Mode</title>
                <paragraph>Specifies how the specular blob will be rendered. The specular blob
                    represents the shape of a light source reflected in the object.</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><strong>SchlickGGX:</strong> The most common blob used by PBR 3D engines nowadays.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Toon:</strong> Creates a toon blob, which changes size depending on roughness.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Disabled:</strong> Sometimes the blob gets in the way. Begone!</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/spatial_material7.webp'}" original_uri="img/spatial_material7.webp" uri="tutorials/3d/img/spatial_material7.webp"></image>
            </section>
            <section ids="disable-ambient-light" names="disable\ ambient\ light">
                <title>Disable Ambient Light</title>
                <paragraph>Makes the object not receive any kind of ambient lighting that would
                    otherwise light it.</paragraph>
            </section>
            <section ids="disable-fog" names="disable\ fog">
                <title>Disable Fog</title>
                <paragraph>Makes the object unaffected by depth-based or volumetric fog. This is useful for particles or other additively blended materials that would otherwise show the shape of the mesh (even in places where it would be invisible without the fog).</paragraph>
            </section>
            <section ids="disable-specular-occlusion" names="disable\ specular\ occlusion">
                <title>Disable Specular Occlusion</title>
                <paragraph>Makes the object not have its reflections reduced where they would usually be occluded.</paragraph>
            </section>
        </section>
        <section ids="vertex-color" names="vertex\ color">
            <title>Vertex Color</title>
            <paragraph>This setting allows choosing what is done by default to vertex colors that come
                from your 3D modeling application. By default, they are ignored.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material4.webp'}" original_uri="img/spatial_material4.webp" uri="tutorials/3d/img/spatial_material4.webp"></image>
            <section ids="use-as-albedo" names="use\ as\ albedo">
                <title>Use as Albedo</title>
                <paragraph>Choosing this option means vertex color is used as albedo color.</paragraph>
            </section>
            <section ids="is-srgb" names="is\ srgb">
                <title>Is sRGB</title>
                <paragraph>Most 3D modeling software will likely export vertex colors as sRGB, so toggling
                    this option on will help them look correct.</paragraph>
            </section>
        </section>
        <section ids="albedo" names="albedo">
            <title>Albedo</title>
            <paragraph><emphasis>Albedo</emphasis> is the base color for the material, on which all the other settings
                operate. When set to <emphasis>Unshaded</emphasis>, this is the only color that is visible. In
                previous versions of Godot, this channel was named <emphasis>Diffuse</emphasis>. The change
                of name mainly happened because, in PBR (Physically Based Rendering), this color affects many
                more calculations than just the diffuse lighting path.</paragraph>
            <paragraph>Albedo color and texture can be used together as they are multiplied.</paragraph>
            <paragraph><emphasis>Alpha channel</emphasis> in albedo color and texture is also used for the
                object transparency. If you use a color or texture with <emphasis>alpha channel</emphasis>,
                make sure to either enable transparency or <emphasis>alpha scissoring</emphasis> for it to work.</paragraph>
        </section>
        <section ids="metallic" names="metallic">
            <title>Metallic</title>
            <paragraph>Godot uses a metallic model over competing models due to its simplicity.
                This parameter defines how reflective the material is. The more reflective, the
                less diffuse/ambient light affects the material and the more light is reflected.
                This model is called "energy-conserving".</paragraph>
            <paragraph>The <emphasis>Specular</emphasis> parameter is a general amount for the reflectivity (unlike
                <emphasis>Metallic</emphasis>, this is not energy-conserving, so leave it at <literal>0.5</literal> and don't touch
                it unless you need to).</paragraph>
            <paragraph>The minimum internal reflectivity is <literal>0.04</literal>, so it's impossible to make a
                material completely unreflective, just like in real life.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material13.png'}" original_uri="img/spatial_material13.png" uri="tutorials/3d/img/spatial_material13.png"></image>
        </section>
        <section ids="roughness" names="roughness">
            <title>Roughness</title>
            <paragraph><emphasis>Roughness</emphasis> affects the way reflection happens. A value of <literal>0</literal> makes it a
                perfect mirror while a value of <literal>1</literal> completely blurs the reflection (simulating
                natural microsurfacing). Most common types of materials can be achieved with
                the right combination of <emphasis>Metallic</emphasis> and <emphasis>Roughness</emphasis>.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material14.png'}" original_uri="img/spatial_material14.png" uri="tutorials/3d/img/spatial_material14.png"></image>
        </section>
        <section ids="emission" names="emission">
            <title>Emission</title>
            <paragraph><emphasis>Emission</emphasis> specifies how much light is emitted by the material (keep in mind this
                does not include light surrounding geometry unless <reference internal="True" refuri="global_illumination/using_voxel_gi#doc-using-voxel-gi"><inline classes="std std-ref">VoxelGI</inline></reference>
                or <reference internal="True" refuri="global_illumination/using_sdfgi#doc-using-sdfgi"><inline classes="std std-ref">SDFGI</inline></reference> are used). This value is added to the resulting
                final image and is not affected by other lighting in the scene.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material15.png'}" original_uri="img/spatial_material15.png" uri="tutorials/3d/img/spatial_material15.png"></image>
        </section>
        <section ids="normal-map" names="normal\ map">
            <title>Normal map</title>
            <paragraph>Normal mapping allows you to set a texture that represents finer shape detail.
                This does not modify geometry, only the incident angle for light. In Godot,
                only the red and green channels of normal maps are used for better compression
                and wider compatibility.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material16.png'}" original_uri="img/spatial_material16.png" uri="tutorials/3d/img/spatial_material16.png"></image>
            <note>
                <paragraph>Godot requires the normal map to use the X+, Y+ and Z+ coordinates, this is
                    known as OpenGL style. If you've imported a material made to be used with
                    another engine it may be DirectX style, in which case the normal map needs to
                    be converted so its Y axis is flipped.</paragraph>
                <paragraph>More information about normal maps (including a coordinate order table for
                    popular engines) can be found
                    <reference name="here" refuri="http://wiki.polycount.com/wiki/Normal_Map_Technical_Details">here</reference>.</paragraph>
            </note>
        </section>
        <section ids="bent-normal-map" names="bent\ normal\ map">
            <title>Bent normal map</title>
            <paragraph><emphasis>This is only available in the Forward+ and Mobile renderers, not the Compatibility
                    renderer.</emphasis></paragraph>
            <paragraph>A bent normal map describes the average direction of ambient lighting. Unlike a
                regular normal map, this is used to improve how a material reacts to lighting
                rather than add surface detail.</paragraph>
            <paragraph>This is achieved in two ways:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Indirect diffuse lighting is made to match global illumination more closely.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If specular occlusion is enabled, it is calculated using the bent normals and
                        ambient occlusion instead of just from ambient light.
                        This includes screen-space ambient occlusion (SSAO) and other sources of
                        ambient occlusion.</paragraph>
                </list_item>
            </bullet_list>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material_bentnormals.webp'}" original_uri="img/spatial_material_bentnormals.webp" uri="tutorials/3d/img/spatial_material_bentnormals.webp"></image>
            <paragraph>Godot only uses the red and green channels of a bent normal map for better
                compression and wider compatibility.</paragraph>
            <paragraph>When creating a bent normal map, there are three things required for it to
                work correctly in Godot:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>A <strong>cosine distribution</strong> of rays has to be used when baking.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The texture must be created in <strong>tangent space</strong>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The bent normal map needs to use the X+, Y+, and Z+ coordinates, this is
                        known as OpenGL style. If you've imported a material made to be used with
                        another engine it may be DirectX style, in which case the bent normal map
                        needs to be converted so its Y axis is flipped. This can be achieved by
                        setting the green channel under the <strong>Channel Remap</strong> section to
                        <strong>Inverted Green</strong> in the import dock.</paragraph>
                </list_item>
            </bullet_list>
            <note>
                <paragraph>A bent normal map is different from a regular normal map. The two are not
                    interchangeable.</paragraph>
            </note>
        </section>
        <section ids="rim" names="rim">
            <title>Rim</title>
            <paragraph>Some fabrics have small micro-fur that causes light to scatter around it. Godot
                emulates this with the <emphasis>Rim</emphasis> parameter. Unlike other rim lighting implementations,
                which just use the emission channel, this one actually takes light into account
                (no light means no rim). This makes the effect considerably more believable.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material17.png'}" original_uri="img/spatial_material17.png" uri="tutorials/3d/img/spatial_material17.png"></image>
            <paragraph>Rim size depends on roughness, and there is a special parameter to specify how
                it must be colored. If <emphasis>Tint</emphasis> is <literal>0</literal>, the color of the light is used for the
                rim. If <emphasis>Tint</emphasis> is <literal>1</literal>, then the albedo of the material is used. Using
                intermediate values generally works best.</paragraph>
        </section>
        <section ids="clearcoat" names="clearcoat">
            <title>Clearcoat</title>
            <paragraph>The <emphasis>Clearcoat</emphasis> parameter is used to add a secondary pass of transparent coat
                to the material. This is common in car paint and toys. In practice, it's a
                smaller specular blob added on top of the existing material.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/clearcoat_comparison.png'}" original_uri="img/clearcoat_comparison.png" uri="tutorials/3d/img/clearcoat_comparison.png"></image>
        </section>
        <section ids="anisotropy" names="anisotropy">
            <title>Anisotropy</title>
            <paragraph>This changes the shape of the specular blob and aligns it to tangent space.
                Anisotropy is commonly used with hair, or to make materials such as brushed
                aluminum more realistic. It works especially well when combined with flowmaps.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material18.png'}" original_uri="img/spatial_material18.png" uri="tutorials/3d/img/spatial_material18.png"></image>
        </section>
        <section ids="ambient-occlusion" names="ambient\ occlusion">
            <title>Ambient Occlusion</title>
            <paragraph>It is possible to specify a baked ambient occlusion map. This map affects how
                much ambient light reaches each surface of the object (it does not affect direct
                light by default). While it is possible to use Screen-Space Ambient Occlusion
                (SSAO) to generate ambient occlusion, nothing beats the quality of a well-baked
                AO map. It is recommended to bake ambient occlusion whenever possible.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material19.png'}" original_uri="img/spatial_material19.png" uri="tutorials/3d/img/spatial_material19.png"></image>
        </section>
        <section ids="height" names="height">
            <title>Height</title>
            <paragraph>Setting a height map on a material produces a ray-marched search to emulate the
                proper displacement of cavities along the view direction. This only creates an
                illusion of depth, and does not add real geometry — for a height map shape used
                for physics collision (such as terrain), see <reference internal="True" refuri="../../classes/class_heightmapshape3d#class-heightmapshape3d"><inline classes="std std-ref">HeightMapShape3D</inline></reference>. It
                may not work for complex objects, but it produces a realistic depth effect for
                textures. For best results, <emphasis>Height</emphasis> should be used together with normal
                mapping.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material20.png'}" original_uri="img/spatial_material20.png" uri="tutorials/3d/img/spatial_material20.png"></image>
        </section>
        <section ids="subsurface-scattering" names="subsurface\ scattering">
            <title>Subsurface Scattering</title>
            <paragraph><emphasis>This is only available in the Forward+ renderer, not the Mobile or Compatibility
                    renderers.</emphasis></paragraph>
            <paragraph>This effect emulates light that penetrates an object's surface, is scattered,
                and then comes out. It is useful to create realistic skin, marble, colored
                liquids, etc.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material21.png'}" original_uri="img/spatial_material21.png" uri="tutorials/3d/img/spatial_material21.png"></image>
        </section>
        <section ids="back-lighting" names="back\ lighting">
            <title>Back Lighting</title>
            <paragraph>This controls how much light from the lit side (visible to light) is transferred
                to the dark side (opposite from the light). This works well for thin objects
                such as plant leaves, grass, human ears, etc.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material22.png'}" original_uri="img/spatial_material22.png" uri="tutorials/3d/img/spatial_material22.png"></image>
        </section>
        <section ids="refraction" names="refraction">
            <title>Refraction</title>
            <paragraph>When refraction is enabled, Godot attempts to fetch information from behind the
                object being rendered. This allows distorting the transparency in a way similar
                to refraction in real life.</paragraph>
            <paragraph>Remember to use a transparent albedo texture (or reduce the albedo color's alpha
                channel) to make refraction visible, as refraction relies on transparency to
                have a visible effect.</paragraph>
            <paragraph>Refraction also takes the material roughness into account. Higher roughness
                values will make the objects behind the refraction look blurrier, which
                simulates real life behavior. If you can't see behind the object when refraction
                is enabled and albedo transparency is reduced, decrease the material's
                <strong>Roughness</strong> value.</paragraph>
            <paragraph>A normal map can optionally be specified in the <strong>Refraction Texture</strong> property
                to allow distorting the refraction's direction on a per-pixel basis.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material23.png'}" original_uri="img/spatial_material23.png" uri="tutorials/3d/img/spatial_material23.png"></image>
            <note>
                <paragraph>Refraction is implemented as a screen-space effect and forces the material
                    to be transparent. This makes the effect relatively fast, but this results
                    in some limitations:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference internal="True" refuri="3d_rendering_limitations#doc-3d-rendering-limitations-transparency-sorting"><inline classes="std std-ref">Transparency sorting</inline></reference>
                            issues may occur.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The refractive material cannot refract onto itself, or onto other
                            transparent materials. A refractive material behind another transparent
                            material will be invisible.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Off-screen objects cannot appear in the refraction. This is most
                            noticeable with high refraction strength values.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Opaque materials in front of the refractive material will appear to have
                            "refracted" edges, even though they shouldn't.</paragraph>
                    </list_item>
                </bullet_list>
            </note>
        </section>
        <section ids="detail" names="detail">
            <title>Detail</title>
            <paragraph>Godot allows using secondary albedo and normal maps to generate a detail
                texture, which can be blended in many ways. By combining this with secondary
                UV or triplanar modes, many interesting textures can be achieved.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material24.png'}" original_uri="img/spatial_material24.png" uri="tutorials/3d/img/spatial_material24.png"></image>
            <paragraph>There are several settings that control how detail is used.</paragraph>
            <paragraph>Mask: The detail mask is a black and white image used to control where the
                blending takes place on a texture. White is for the detail textures, Black
                is for the regular material textures, different shades of gray are for
                partial blending of the material textures and detail textures.</paragraph>
            <paragraph>Blend Mode: These four modes control how the textures are blended together.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Mix: Combines pixel values of both textures. At black, only show the material texture,
                        at white, only show the detail texture. Values of gray create a smooth blend between
                        the two.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Add: Adds pixel values of one Texture with the other. Unlike mix mode
                        both textures are completely mixed at white parts of a mask and not at gray
                        parts. The original texture is mostly unchanged at black</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Sub: Subtracts pixel values of one texture with the other. The second
                        texture is completely subtracted at white parts of a mask with only a little
                        subtraction in black parts, gray parts being different levels of subtraction
                        based on the exact texture.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Mul: Multiplies the RGB channel numbers for each pixel from the top texture
                        with the values for the corresponding pixel from the bottom texture.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Albedo: This is where you put an albedo texture you want to blend. If nothing
                is in this slot it will be interpreted as white by default.</paragraph>
            <paragraph>Normal: This is where you put a normal texture you want to blend. If nothing is
                in this slot it will be interpreted as a flat normal map. This can still be used
                even if the material does not have normal map enabled.</paragraph>
        </section>
        <section ids="uv1-and-uv2" names="uv1\ and\ uv2">
            <title>UV1 and UV2</title>
            <paragraph>Godot supports two UV channels per material. Secondary UV is often useful for
                ambient occlusion or emission (baked light). UVs can be scaled and offset,
                which is useful when using repeating textures.</paragraph>
            <target refid="doc-standard-material-3d-triplanar-mapping"></target>
            <section ids="triplanar-mapping doc-standard-material-3d-triplanar-mapping" names="triplanar\ mapping doc_standard_material_3d_triplanar_mapping">
                <title>Triplanar Mapping</title>
                <paragraph>Triplanar mapping is supported for both UV1 and UV2. This is an alternative way
                    to obtain texture coordinates, sometimes called "Autotexture". Textures are
                    sampled in X, Y and Z and blended by the normal. Triplanar mapping can be
                    performed in either world space or object space.</paragraph>
                <paragraph>In the image below, you can see how all primitives share the same material with
                    world triplanar, so the brick texture continues smoothly between them.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/spatial_material25.png'}" original_uri="img/spatial_material25.png" uri="tutorials/3d/img/spatial_material25.png"></image>
            </section>
            <section ids="world-triplanar" names="world\ triplanar">
                <title>World Triplanar</title>
                <paragraph>When using triplanar mapping, it is computed in object local space. This
                    option makes it use world space instead.</paragraph>
                <target refid="doc-standard-material-3d-sampling"></target>
            </section>
        </section>
        <section ids="sampling doc-standard-material-3d-sampling" names="sampling doc_standard_material_3d_sampling">
            <title>Sampling</title>
            <section ids="filter" names="filter">
                <title>Filter</title>
                <paragraph>The filtering method for the textures used by the material. See <reference internal="True" refuri="../../classes/class_basematerial3d#class-basematerial3d-property-texture-filter"><inline classes="std std-ref">this page</inline></reference>
                    for a full list of options and their description.</paragraph>
            </section>
            <section ids="repeat" names="repeat">
                <title>Repeat</title>
                <paragraph>if the textures used by the material repeat, and how they repeat. See <reference internal="True" refuri="../../classes/class_basematerial3d#class-basematerial3d-property-texture-repeat"><inline classes="std std-ref">this page</inline></reference>
                    for a full list of options and their description.</paragraph>
            </section>
        </section>
        <section ids="shadows" names="shadows">
            <title>Shadows</title>
            <section ids="disable-receive-shadows" names="disable\ receive\ shadows">
                <title>Disable Receive Shadows</title>
                <paragraph>Makes the object not receive any kind of shadow that would otherwise
                    be cast onto it.</paragraph>
            </section>
            <section ids="shadow-to-opacity" names="shadow\ to\ opacity">
                <title>Shadow to Opacity</title>
                <paragraph>Lighting modifies the alpha so shadowed areas are opaque and non-shadowed
                    areas are transparent. Useful for overlaying shadows onto a camera feed in AR.</paragraph>
            </section>
        </section>
        <section ids="billboard" names="billboard">
            <title>Billboard</title>
            <section ids="billboard-mode" names="billboard\ mode">
                <title>Billboard Mode</title>
                <paragraph>Enables billboard mode for drawing materials. This controls how the object
                    faces the camera:</paragraph>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph><strong>Disabled:</strong> Billboard mode is disabled.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Enabled:</strong> Billboard mode is enabled. The object's -Z axis will always
                            face the camera's viewing plane.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Y-Billboard:</strong> The object's X axis will always be aligned with the camera's viewing plane.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Particle Billboard:</strong> Most suited for particle systems, because it allows
                            specifying <reference internal="True" refuri="particles/process_material_properties#doc-process-material-properties-animation"><inline classes="std std-ref">flipbook animation</inline></reference>.</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/spatial_material9.webp'}" original_uri="img/spatial_material9.webp" uri="tutorials/3d/img/spatial_material9.webp"></image>
                <paragraph>The <strong>Particles Anim</strong> section is only visible when the billboard mode is <strong>Particle Billboard</strong>.</paragraph>
            </section>
            <section ids="billboard-keep-scale" names="billboard\ keep\ scale">
                <title>Billboard Keep Scale</title>
                <paragraph>Enables scaling a mesh in billboard mode.</paragraph>
                <target refid="ref-standard-material-3d-grow"></target>
            </section>
        </section>
        <section ids="grow ref-standard-material-3d-grow" names="grow ref_standard_material_3d_grow">
            <title>Grow</title>
            <paragraph>Grows the object vertices in the direction pointed by their normals:</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material10.png'}" original_uri="img/spatial_material10.png" uri="tutorials/3d/img/spatial_material10.png"></image>
            <paragraph>This is commonly used to create cheap outlines. Add a second material pass,
                make it black and unshaded, reverse culling (Cull Front), and add some grow:</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material11.png'}" original_uri="img/spatial_material11.png" uri="tutorials/3d/img/spatial_material11.png"></image>
            <note>
                <paragraph>For Grow to work as expected, the mesh must have connected faces with shared
                    vertices, or "smooth shading". If the mesh has disconnected faces with unique
                    vertices, or "flat shading", the mesh will appear to have gaps when using Grow.</paragraph>
            </note>
            <paragraph>Note that in Godot 4.5 onwards, stencil buffer-based outlines are available
                using the <strong>Outline</strong> <reference internal="True" refid="doc-standard-material-3d-stencil"><inline classes="std std-ref">stencil mode</inline></reference>.
                This can be used as an alternative to Grow for outlines.</paragraph>
        </section>
        <section ids="transform" names="transform">
            <title>Transform</title>
            <section ids="fixed-size" names="fixed\ size">
                <title>Fixed Size</title>
                <paragraph>This causes the object to be rendered at the same size no matter the distance.
                    This is useful mostly for indicators (no depth test and high render priority)
                    and some types of billboards.</paragraph>
            </section>
            <section ids="use-point-size" names="use\ point\ size">
                <title>Use Point Size</title>
                <paragraph>This option is only effective when the geometry rendered is made of points
                    (generally it's made of triangles when imported from 3D modeling software). If
                    so, then those points can be resized (see below).</paragraph>
            </section>
            <section ids="point-size" names="point\ size">
                <title>Point Size</title>
                <paragraph>When drawing points, specify the point size in pixels.</paragraph>
            </section>
            <section ids="use-particle-trails" names="use\ particle\ trails">
                <title>Use Particle Trails</title>
                <paragraph>If true, enables parts of the shader required for GPUParticles3D trails to function.
                    This also requires using a mesh with appropriate skinning, such as RibbonTrailMesh
                    or TubeTrailMesh. Enabling this feature outside of materials used in GPUParticles3D
                    meshes will break material rendering.</paragraph>
            </section>
            <section ids="use-z-clip-scale" names="use\ z\ clip\ scale">
                <title>Use Z Clip Scale</title>
                <paragraph>Scales the object being rendered towards the camera to avoid clipping into things
                    like walls. This is intended to be used for objects that are fixed with respect to
                    the camera like player arms, tools, etc. Lighting and shadows will continue to work
                    correctly when this setting is adjusted, but screen-space effects like SSAO and SSR
                    may break with lower scales. Therefore, try to keep this setting as close to 1.0 as
                    possible.</paragraph>
            </section>
            <section ids="use-fov-override" names="use\ fov\ override">
                <title>Use FOV Override</title>
                <paragraph>Overrides the <literal>Camera3D</literal>'s field of view angle (in degrees).</paragraph>
                <note>
                    <paragraph>This behaves as if the field of view is set on a <literal>Camera3D</literal> with
                        <literal>Camera3D.keep_aspect</literal> set to <literal>Camera3D.KEEP_HEIGHT</literal>. Additionally, it may not
                        look correct on a non-perspective camera where the field of view setting is
                        ignored.</paragraph>
                </note>
            </section>
        </section>
        <section ids="proximity-and-distance-fade" names="proximity\ and\ distance\ fade">
            <title>Proximity and Distance Fade</title>
            <paragraph>Godot allows materials to fade by proximity to each other as well as depending
                on the distance from the viewer. Proximity fade is useful for effects such as
                soft particles or a mass of water with a smooth blending to the shores.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/spatial_material_proxfade.gif'}" original_uri="img/spatial_material_proxfade.gif" uri="tutorials/3d/img/spatial_material_proxfade.gif"></image>
            <paragraph>Distance fade is useful for light shafts or indicators that are only present
                after a given distance.</paragraph>
            <paragraph>Keep in mind enabling proximity fade or distance fade with <strong>Pixel Alpha</strong> mode
                enables alpha blending. Alpha blending is more GPU-intensive and can cause
                transparency sorting issues. Alpha blending also disables many material
                features such as the ability to cast shadows.</paragraph>
            <note>
                <paragraph>To hide a character when they get too close to the camera, consider using
                    <strong>Pixel Dither</strong> or better, <strong>Object Dither</strong> (which is even faster than
                    <strong>Pixel Dither</strong>).</paragraph>
            </note>
            <paragraph><strong>Pixel Alpha</strong> mode: The actual transparency of a pixel of the object changes
                with distance to the camera. This is the most effect, but forces the material
                into the transparency pipeline (which leads, for example, to no shadows).</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/standart_material_distance_fade_pixel_alpha_mode.webp'}" original_uri="img/standart_material_distance_fade_pixel_alpha_mode.webp" uri="tutorials/3d/img/standart_material_distance_fade_pixel_alpha_mode.webp"></image>
            <paragraph><strong>Pixel Dither</strong> mode: What this does is sort of approximate the transparency
                by only having a fraction of the pixels rendered.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/standart_material_distance_fade_pixel_dither_mode.webp'}" original_uri="img/standart_material_distance_fade_pixel_dither_mode.webp" uri="tutorials/3d/img/standart_material_distance_fade_pixel_dither_mode.webp"></image>
            <paragraph><strong>Object Dither</strong> mode: Like the previous mode, but the calculated transparency
                is the same across the entire object's surface.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/standart_material_distance_fade_object_dither_mode.webp'}" original_uri="img/standart_material_distance_fade_object_dither_mode.webp" uri="tutorials/3d/img/standart_material_distance_fade_object_dither_mode.webp"></image>
            <target refid="doc-standard-material-3d-stencil"></target>
        </section>
        <section ids="stencil doc-standard-material-3d-stencil" names="stencil doc_standard_material_3d_stencil">
            <title>Stencil</title>
            <paragraph>Since Godot 4.5, Godot allows materials to make use of the stencil buffer.
                This feature is commonly used to create outlines and X-ray effects,
                which can be useful to highlight objects, especially behind walls.</paragraph>
            <paragraph>The <strong>Outline</strong> and <strong>X-Ray</strong> modes assign a preconfigured stencil material
                in the material's <strong>Next Pass</strong> property. The <strong>Custom</strong> mode can be used for
                advanced effects.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/material_stencil.webp'}" original_uri="img/material_stencil.webp" uri="tutorials/3d/img/material_stencil.webp"></image>
            <paragraph>Materials that write to the stencil buffer are always drawn in the transparent pass,
                so they are subject to the usual
                <reference internal="True" refuri="3d_rendering_limitations#doc-3d-rendering-limitations-transparency-sorting"><inline classes="std std-ref">transparency limitations</inline></reference>.</paragraph>
            <note>
                <paragraph>Like with the <reference internal="True" refid="ref-standard-material-3d-grow"><inline classes="std std-ref">Grow property</inline></reference>, for the
                    stencil outline to work as expected, the mesh must have connected faces with
                    shared vertices, or "smooth shading". If the mesh has disconnected faces with
                    unique vertices, or "flat shading", the mesh will appear to have gaps when using
                    a stencil outline.</paragraph>
                <paragraph>Stencil outlines render similarly to the Grow property, but won't look identical
                    in every scenario, especially when intersections with opaque surfaces are involved.</paragraph>
            </note>
        </section>
        <section ids="material-settings" names="material\ settings">
            <title>Material Settings</title>
        </section>
        <section ids="render-priority" names="render\ priority">
            <title>Render priority</title>
            <paragraph>The rendering order of objects can be changed, although this is mostly
                useful for transparent objects (or opaque objects that perform depth draw
                but no color draw, such as cracks on the floor).</paragraph>
            <paragraph>Objects are sorted by an opaque/transparent queue, then <reference internal="True" refuri="../../classes/class_material#class-material-property-render-priority"><inline classes="std std-ref">render_priority</inline></reference>,
                with higher priority being drawn later. Transparent objects are also sorted by depth.</paragraph>
            <paragraph>Depth testing overrules priority. Priority alone cannot force opaque objects to be drawn over each other.</paragraph>
        </section>
        <section ids="next-pass" names="next\ pass">
            <title>Next Pass</title>
            <paragraph>Setting <reference internal="True" refuri="../../classes/class_material#class-material-property-next-pass"><inline classes="std std-ref">next_pass</inline></reference> on a material
                will cause an object to be rendered again with that next material.</paragraph>
            <paragraph>Materials are sorted by an opaque/transparent queue, then <reference internal="True" refuri="../../classes/class_material#class-material-property-render-priority"><inline classes="std std-ref">render_priority</inline></reference>,
                with higher priority being drawn later.</paragraph>
            <image candidates="{'*': 'tutorials/3d/img/next_pass.webp'}" original_uri="img/next_pass.webp" uri="tutorials/3d/img/next_pass.webp"></image>
            <paragraph>Depth will test equal between both materials unless the grow setting or other vertex transformations are used.
                Multiple transparent passes should use <reference internal="True" refuri="../../classes/class_material#class-material-property-render-priority"><inline classes="std std-ref">render_priority</inline></reference> to ensure correct ordering.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
