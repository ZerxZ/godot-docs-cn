<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/environment_and_post_processing.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-environment-and-post-processing"></target>
    <section ids="environment-and-post-processing doc-environment-and-post-processing" names="environment\ and\ post-processing doc_environment_and_post_processing">
        <title>Environment and post-processing</title>
        <paragraph>Godot 4 provides a redesigned Environment resource, as well as a new
            post-processing system with many available effects right out of the box.</paragraph>
        <note>
            <paragraph>As of Godot 4, Environment <emphasis>performance/quality</emphasis> settings are defined in the
                project settings instead of in the Environment resource. This makes global
                adjustments easier, as you no longer have to tweak Environment resources
                individually to suit various hardware configurations.</paragraph>
            <paragraph>Note that most Environment performance/quality settings are only visible
                after enabling the <strong>Advanced</strong> toggle in the Project Settings.</paragraph>
        </note>
        <section ids="environment" names="environment">
            <title>Environment</title>
            <paragraph>The <reference internal="True" refuri="../../classes/class_environment#class-environment"><inline classes="std std-ref">Environment</inline></reference> resource stores all the information required for
                controlling the 2D and 3D rendering environment. This includes the sky, ambient
                lighting, tone mapping, effects, and adjustments. By itself, it does nothing,
                but you can enable it by using it in one of the following locations, in order
                of priority:</paragraph>
            <section ids="camera3d-node-high-priority" names="camera3d\ node\ (high\ priority)">
                <title>Camera3D node (high priority)</title>
                <paragraph>An Environment can be set to a Camera3D node. It will have priority over any
                    other setting.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_camera.webp'}" original_uri="img/environment_camera.webp" uri="tutorials/3d/img/environment_camera.webp"></image>
                <paragraph>This is mostly useful when you want to override an existing environment,
                    but in general it's a better idea to use the option below.</paragraph>
            </section>
            <section ids="worldenvironment-node-medium-priority-recommended" names="worldenvironment\ node\ (medium\ priority,\ recommended)">
                <title>WorldEnvironment node (medium priority, recommended)</title>
                <paragraph>The WorldEnvironment node can be added to any scene, but only one can exist per
                    active scene tree. Adding more than one will result in a warning.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_world.webp'}" original_uri="img/environment_world.webp" uri="tutorials/3d/img/environment_world.webp"></image>
                <paragraph>Any Environment added has higher priority than the default Environment
                    (explained below). This means it can be overridden on a per-scene basis,
                    which makes it quite useful.</paragraph>
            </section>
            <section ids="preview-environment-and-sun-low-priority" names="preview\ environment\ and\ sun\ (low\ priority)">
                <title>Preview environment and sun (low priority)</title>
                <note>
                    <paragraph>Since Godot 4, the preview environment and sun system replace the
                        <literal>default_env.tres</literal> file that was used in Godot 3 projects.</paragraph>
                </note>
                <paragraph>If no WorldEnvironment node or DirectionalLight3D node is present in the current
                    scene, the editor will display a preview environment and sun instead. This can
                    be disabled using the buttons at the top of the 3D editor:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_preview_sun_sky_toggle.webp'}" original_uri="img/environment_preview_sun_sky_toggle.webp" uri="tutorials/3d/img/environment_preview_sun_sky_toggle.webp"></image>
                <paragraph>Clicking on the 3 vertical dots on the right will display a dialog which allows
                    you to customize the appearance of the preview environment:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_preview_sun_sky_dialog.webp'}" original_uri="img/environment_preview_sun_sky_dialog.webp" uri="tutorials/3d/img/environment_preview_sun_sky_dialog.webp"></image>
                <paragraph><strong>The preview sun and sky is only visible in the editor, not in the running
                        project.</strong> Using the buttons at the bottom of the dialog, you can add the
                    preview sun and sky into the scene as nodes.</paragraph>
                <tip>
                    <paragraph>If you hold <literal classes="kbd">Shift</literal> while clicking <strong>Add Sun to Scene</strong> or <strong>Add
                            Environment to Scene</strong> in the preview environment editor, this will add both
                        a preview sun and environment to the current scene (as if you clicked both
                        buttons separately). Use this to speed up project setup and prototyping.</paragraph>
                </tip>
            </section>
        </section>
        <section ids="camera-attributes" names="camera\ attributes">
            <title>Camera attributes</title>
            <note>
                <paragraph>In Godot 4, exposure and depth of field information was split from the
                    Environment resource into a separate CameraAttributes resource. This allows
                    adjusting those properties independently of other Environment settings more
                    easily.</paragraph>
            </note>
            <paragraph>The <reference internal="True" refuri="../../classes/class_cameraattributes#class-cameraattributes"><inline classes="std std-ref">CameraAttributes</inline></reference> resource stores exposure and depth of field
                information. It also allows enabling automatic exposure adjustments depending on
                scene brightness.</paragraph>
            <paragraph>There are two kinds of CameraAttribute resources available:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>CameraAttributesPractical:</strong> Features are exposed using arbitrary units,
                        which are easier to reason about for most game use cases.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>CameraAttributesPhysical:</strong> Features are exposed using real world units,
                        similar to a digital camera. For example, field of view is set using a focal
                        length in millimeters instead of a value in degrees. Recommended when physical
                        accuracy is important, such as for photorealistic rendering.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Both CameraAttribute resource types allow you to use the same features, but they
                are configured differently. If you don't know which one to choose, use
                <strong>CameraAttributesPractical</strong>.</paragraph>
            <note>
                <paragraph>Using a <reference internal="True" refuri="../../classes/class_cameraattributesphysical#class-cameraattributesphysical"><inline classes="std std-ref">CameraAttributesPhysical</inline></reference> on a Camera3D node will lock
                    out FOV and aspect adjustments in that Camera3D, as field of view is
                    adjusted in the CameraAttributesPhysical resource instead. If used in a
                    WorldEnvironment, the CameraAttributesPhysical will not override any
                    Camera3D in the scene.</paragraph>
            </note>
            <paragraph>A CameraAttributes resource can be added to a Camera3D or a WorldEnvironment
                node. When the current camera has a CameraAttributes set, it will <emphasis>override</emphasis> the
                one set in WorldEnvironment (if any).</paragraph>
            <paragraph>In most situations, setting the CameraAttributes resource on the Camera3D node
                instead of the WorldEnvironment is recommended. Unlike WorldEnvironment,
                assigning the CameraAttributes resource to the Camera3D node prevents depth of
                field from displaying in the 3D editor viewport, unless the camera is being
                previewed.</paragraph>
        </section>
        <section ids="environment-options" names="environment\ options">
            <title>Environment options</title>
            <paragraph>The following is a detailed description of all environment options and how
                they are intended to be used.</paragraph>
            <section ids="background" names="background">
                <title>Background</title>
                <paragraph>The Background section contains settings on how to fill the background (parts of
                    the screen where objects were not drawn). The background not only serves the
                    purpose of displaying an image or color. By default, it also affects how objects
                    are affected by ambient and reflected light. This is called image-based lighting
                    (IBL).</paragraph>
                <paragraph>As a result, the background sky may greatly impact your scene's overall
                    appearance, even if the sky is never directly visible on screen. This should be
                    taken into account when tweaking lighting in your scene.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_background1.webp'}" original_uri="img/environment_background1.webp" uri="tutorials/3d/img/environment_background1.webp"></image>
                <paragraph>There are several background modes available:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Clear Color</strong> uses the default clear color defined in the project settings.
                            The background will be a constant color.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Custom Color</strong> is like Clear Color, but with a custom color value.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Sky</strong> lets you define a background sky material (see below). By default,
                            objects in the scene will reflect this sky material and absorb ambient light
                            from it.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Canvas</strong> displays the 2D scene as a background to the 3D scene. This can be used
                            to make environment effects visible on 2D rendering, such as
                            <reference internal="True" refid="doc-environment-and-post-processing-using-glow-in-2d"><inline classes="std std-ref">glow in 2D</inline></reference>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Keep</strong> does not draw any sky, keeping what was present on previous frames
                            instead. This improves performance in purely indoor scenes, but creates a
                            "hall of mirrors" visual glitch if the sky is visible at any time.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="sky-materials" names="sky\ materials">
                <title>Sky materials</title>
                <paragraph>When using the <strong>Sky</strong> background mode (or the ambient/reflected light mode is
                    set to <strong>Sky</strong>), a Sky subresource becomes available to edit in the Environment
                    resource. Editing this subresource allows you to create a SkyMaterial resource
                    within the Sky.</paragraph>
                <paragraph>There are 3 built-in sky materials to choose from:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>PanoramaSkyMaterial:</strong> Use a 360 degree panorama sky image (2:1 aspect ratio
                            recommended). To benefit from high dynamic range, the panorama image must be
                            in an HDR-compatible format such as <literal>.hdr</literal> or <literal>.exr</literal> rather than a
                            standard dynamic range format like <literal>.png</literal> or <literal>.jpg</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>ProceduralSkyMaterial:</strong> Use a procedurally generated sky with adjustable
                            ground, sun, sky and horizon colors. This is the type of sky used in the
                            editor preview. The sun's position is automatically derived from the first 4
                            DirectionalLight3D nodes present in the scene. There can be up to 4 suns at a
                            given time.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>PhysicalSkyMaterial:</strong> Use a physically-based procedural sky with adjustable
                            scattering parameters. The sun's position is automatically derived from the
                            first DirectionalLight3D node present in the scene. PhysicalSkyMaterial is
                            slightly more expensive to render compared to ProceduralSkyMaterial. There can
                            be up to 1 sun at a given time.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Panorama sky images are sometimes called HDRIs (High Dynamic Range Images).
                    You can find freely licensed HDRIs on <reference name="Poly Haven" refuri="https://polyhaven.com/hdris">Poly Haven</reference>.</paragraph>
                <note>
                    <paragraph>HDR PanoramaSkyMaterial textures with very bright spots (such as real life
                        photos with the sun visible) may result in visible sparkles on ambient and
                        specular reflections. This is caused by the texture's peak exposure being
                        too high.</paragraph>
                    <paragraph>To resolve this, select the panorama texture in the FileSystem dock, go to
                        the Import dock, enable <strong>HDR Clamp Exposure</strong> then click <strong>Reimport</strong>.</paragraph>
                </note>
                <paragraph>If you need a custom sky material (e.g. for procedural clouds), you can
                    create a custom <reference internal="True" refuri="../shaders/shader_reference/sky_shader#doc-sky-shader"><inline classes="std std-ref">sky shader</inline></reference>.</paragraph>
            </section>
            <section ids="ambient-light" names="ambient\ light">
                <title>Ambient light</title>
                <paragraph>Ambient light (as defined here) is a type of light that affects every piece of
                    geometry with the same intensity. It is global and independent of lights that
                    might be added to the scene. Ambient light is one of the two components of
                    image-based lighting. Unlike reflected light, ambient light does not vary
                    depending on the camera's position and viewing angle.</paragraph>
                <paragraph>There are several types of ambient light to choose from:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Background:</strong> Source ambient light from the background, such as the sky,
                            custom color or clear color (default). Ambient light intensity will vary
                            depending on the sky image's contents, which can result in more visually
                            appealing ambient lighting. A sky must be set as background for this mode to
                            be visible.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Disabled:</strong> Do not use any ambient light. Useful for purely indoor scenes.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Color:</strong> Use a constant color for ambient light, ignoring the background
                            sky. Ambient light intensity will be the same on all sides, which may result
                            in the scene's lighting looking more flat. Useful for indoor scenes where
                            pitch black shadows may be too dark, or to maximize performance on low-end
                            devices.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Sky:</strong> Source ambient light from a specified sky, even if the background is
                            set to a mode other than <strong>Sky</strong>. If the background mode is already <strong>Sky</strong>,
                            this mode behaves identically to <strong>Background</strong>.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>When the ambient light mode is set to Sky or Background (and background is set
                    to Sky), it's possible to blend between the ambient color and sky using the
                    <strong>Sky Contribution</strong> property. This value is set to <literal>1.0</literal> by default, which
                    means that only the ambient sky is used. The ambient color is ignored unless
                    <strong>Sky Contribution</strong> is decreased below <literal>1.0</literal>.</paragraph>
                <paragraph>Here is a comparison of how different ambient light affects a scene:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_ambient2.webp'}" original_uri="img/environment_ambient2.webp" uri="tutorials/3d/img/environment_ambient2.webp"></image>
                <paragraph>Finally, there is an <strong>Energy</strong> setting which is a multiplier. It's useful when
                    working with HDR.</paragraph>
                <paragraph>In general, you should only rely on ambient light alone for simple scenes or
                    large exteriors. You may also do so to boost performance. Ambient light is fast
                    to render, but it doesn't provide the best lighting quality. It's better to
                    generate ambient light from <reference internal="True" refuri="global_illumination/reflection_probes#doc-reflection-probes"><inline classes="std std-ref">ReflectionProbe</inline></reference>,
                    <reference internal="True" refuri="global_illumination/using_voxel_gi#doc-using-voxel-gi"><inline classes="std std-ref">VoxelGI</inline></reference> or <reference internal="True" refuri="global_illumination/using_sdfgi#doc-using-sdfgi"><inline classes="std std-ref">SDFGI</inline></reference>, as these
                    will simulate how indirect light propagates more accurately. Below is a comparison,
                    in terms of quality, between using a flat ambient color and a VoxelGI:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_ambient_comparison.webp'}" original_uri="img/environment_ambient_comparison.webp" uri="tutorials/3d/img/environment_ambient_comparison.webp"></image>
                <paragraph>Using one of the methods described above will replace constant ambient
                    lighting with ambient lighting from the probes.</paragraph>
            </section>
            <section ids="reflected-light" names="reflected\ light">
                <title>Reflected light</title>
                <paragraph>Reflected light (also called specular light) is the other of the two components
                    of image-based lighting.</paragraph>
                <paragraph>Reflected light can be set to one of 3 modes:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Background:</strong> Reflect from the background, such as the sky, custom color or
                            clear color (default).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Disabled:</strong> Do not reflect any light from the environment. Useful for purely
                            indoor scenes, or to maximize performance on low-end devices.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Sky:</strong> Reflect from the background sky, even if the background is set to a
                            mode other than <strong>Sky</strong>. If the background mode is already <strong>Sky</strong>, this mode
                            behaves identically to <strong>Background</strong>.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="fog" names="fog">
                <title>Fog</title>
                <note>
                    <paragraph>This section refers to non-volumetric fog only.
                        It is possible to use both non-volumetric fog and <reference internal="True" refuri="volumetric_fog#doc-volumetric-fog"><inline classes="std std-ref">Volumetric fog and fog volumes</inline></reference>
                        at the same time.</paragraph>
                </note>
                <paragraph>Fog, as in real life, makes distant objects fade away into a uniform color.
                    There are two kinds of fog in Godot:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Depth Fog:</strong> This one is applied based on the distance from the camera.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Height Fog:</strong> This one is applied to any objects below (or above) a certain
                            height, regardless of the distance from the camera.</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/environment_fog_depth_height.webp'}" original_uri="img/environment_fog_depth_height.webp" uri="tutorials/3d/img/environment_fog_depth_height.webp"></image>
                <paragraph>Both of these fog types can have their curve tweaked, making their transition more or less sharp.</paragraph>
                <paragraph>Two properties can be tweaked to make the fog effect more interesting:</paragraph>
                <paragraph>The first is <strong>Sun Scatter</strong>, which makes use of the DirectionalLight3D's color
                    and energy in the current scene. When looking towards the directional light
                    (usually a sun), the fog will be tinted according to the light's color to
                    simulate the sunlight passing through the fog.</paragraph>
                <paragraph>The second is <strong>Aerial Perspective</strong>, which tints the fog color according to the
                    sky color to better blend the sky with the background. Higher values will result
                    in more tinting, with <literal>1.0</literal> fully replacing the regular fog color with aerial
                    perspective. This can be used in large open world levels to provide a better
                    sense of depth, or to avoid color discontinuities between the sky and fog colors.</paragraph>
                <paragraph>If both <strong>Sun Scatter</strong> and <strong>Aerial Perspective</strong> are greater than <literal>0.0</literal>, sun
                    scattering is applied on top of aerial perspective.</paragraph>
                <note>
                    <paragraph>Fog can cause banding to appear on the viewport, especially at
                        higher density levels. See <reference internal="True" refuri="3d_rendering_limitations#doc-3d-rendering-limitations-color-banding"><inline classes="std std-ref">Color banding</inline></reference>
                        for guidance on reducing banding.</paragraph>
                </note>
            </section>
            <section ids="volumetric-fog" names="volumetric\ fog">
                <title>Volumetric Fog</title>
                <paragraph>Volumetric fog provides a realistic fog effect to the scene, with fog color
                    being affected by the lights that traverse the fog.</paragraph>
                <seealso>
                    <paragraph>See <reference internal="True" refuri="volumetric_fog#doc-volumetric-fog"><inline classes="std std-ref">Volumetric fog and fog volumes</inline></reference> for documentation on setting up volumetric fog.</paragraph>
                </seealso>
            </section>
            <section ids="tonemap" names="tonemap">
                <title>Tonemap</title>
                <paragraph>Tonemap selects the tonemapping algorithm that will be applied to the scene, from a
                    list of standard algorithms used in the film and game industries. Tonemapping modes
                    other than <strong>Linear</strong> are used to make light and dark areas more homogeneous,
                    while also avoiding clipping of bright highlights. Each algorithm has a different
                    performance characteristic that should be considered when choosing your tonemapper.</paragraph>
                <paragraph>The tone mapping options are:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Mode:</strong> The tonemapping mode to use.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph><strong>Linear:</strong> Does not modify color data, resulting in a linear tonemapping
                                    curve which unnaturally clips bright values, causing bright lighting to
                                    look blown out. The simplest and fastest tonemapper.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><strong>Reinhard:</strong> A simple tonemapping curve that rolls off bright values to
                                    prevent clipping. This results in an image that can appear dull and low
                                    contrast. Slower than Linear. When <strong>White</strong> is left at the default
                                    value of <literal>1.0</literal>, Reinhard produces an identical image to Linear.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><strong>Filmic:</strong> Uses a film-like tonemapping curve to prevent clipping of
                                    bright values and provide better contrast than Reinhard. Slightly slower
                                    than Reinhard.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><strong>ACES:</strong> Uses a high-contrast film-like tonemapping curve and desaturates
                                    bright values for a more realistic appearance. Slightly slower than Filmic.</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph><strong>AgX:</strong> Uses a film-like tonemapping curve and desaturates bright values
                                    for a more realistic appearance. Better than other tonemappers at
                                    maintaining the hue of colors as they become brighter. The slowest
                                    tonemapping option. <strong>White</strong> is fixed at a value of <literal>16.29</literal>,
                                    which makes AgX unsuitable for use with the Mobile rendering method.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Exposure:</strong> Adjusts the brightness of values before they are provided to
                            the tonemapper. Higher <strong>Exposure</strong> values result in a brighter image.
                            Values provided to the tonemapper will also be multiplied by <literal>2.0</literal>
                            and <literal>1.8</literal> for <strong>Filmic</strong> and <strong>ACES</strong> respectively to produce a similar
                            apparent brightness as Linear.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>White:</strong> The white reference value for tonemapping, which indicates where
                            bright white is located in the scale of values provided to the tonemapper.
                            For photorealistic lighting, recommended values are between <literal>6.0</literal> and
                            <literal>8.0</literal>. Higher values result in less blown out highlights, but may make the
                            scene appear lower contrast. <strong>White</strong> is not available when using
                            <strong>Linear</strong> or <strong>AgX</strong>.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="mid-and-post-processing-effects" names="mid-\ and\ post-processing\ effects">
            <title>Mid- and post-processing effects</title>
            <paragraph>The Environment resource supports many popular mid- and post-processing effects.</paragraph>
            <note>
                <paragraph>Screen-space effects such as <abbreviation explanation="Screen-Space Reflections">SSR</abbreviation>,
                    <abbreviation explanation="Screen-Space Ambient Occlusion">SSAO</abbreviation>,
                    <abbreviation explanation="Screen-Space Indirect Lighting">SSIL</abbreviation> and glow do not operate on
                    geometry that is located outside the camera view or is occluded by other
                    opaque geometry. Consider this when tweaking their settings to avoid
                    distracting changes during gameplay.</paragraph>
            </note>
            <section ids="screen-space-reflections-ssr" names="screen-space\ reflections\ (ssr)">
                <title>Screen-Space Reflections (SSR)</title>
                <paragraph><emphasis>This feature is only available when using the Forward+ renderer, not
                        Mobile or Compatibility.</emphasis></paragraph>
                <paragraph>While Godot supports several sources of reflection data such as
                    <reference internal="True" refuri="global_illumination/reflection_probes#doc-reflection-probes"><inline classes="std std-ref">Reflection probes</inline></reference>, they may not provide enough detail for all
                    situations. Scenarios where screen-space reflections make the most sense are
                    when objects are in contact with each other (object over floor, over a table,
                    floating on water, etc).</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_ssr.webp'}" original_uri="img/environment_ssr.webp" uri="tutorials/3d/img/environment_ssr.webp"></image>
                <paragraph>On top of providing more detail, screen-space reflections also work in real-time
                    (while other types of reflections are usually precomputed). This can be used to
                    make characters, cars, etc. reflect on surrounding surfaces when moving around.</paragraph>
                <paragraph>Screen-space reflections can be used at the same time as other reflection
                    sources to benefit from detailed reflections when possible, while having a
                    fallback when screen-space reflections cannot be used (for example, to reflect
                    off-screen objects).</paragraph>
                <paragraph>A few user-controlled parameters are available to better tweak the technique:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Max Steps:</strong> Determines the length of the reflection. The bigger this
                            number, the more costly it is to compute.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Fade In:</strong> Allows adjusting the fade-in curve, which is useful to make the
                            contact area softer.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Fade Out:</strong> Allows adjusting the fade-out curve, so the step limit fades out
                            softly.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Depth Tolerance:</strong> Can be used to allow screen-space rays to pass behind
                            objects. The rays will treat each object as if it has this depth in
                            determining if it can pass behind the object. Higher values will make
                            screen-space reflections exhibit fewer "breakups", at the cost of some objects
                            creating physically incorrect reflections.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Keep in mind that screen-space-reflections only work for reflecting opaque
                    geometry. Transparent materials won't be reflected, as they don't write to the depth buffer.
                    This also applies to shaders that use <literal>hint_screen_texture</literal> or <literal>hint_depth_texture</literal>
                    uniforms.</paragraph>
            </section>
            <section ids="screen-space-ambient-occlusion-ssao" names="screen-space\ ambient\ occlusion\ (ssao)">
                <title>Screen-Space Ambient Occlusion (SSAO)</title>
                <paragraph><emphasis>This feature is only available when using the Forward+ and Compatibility renderers,
                        not Mobile.</emphasis></paragraph>
                <paragraph>As mentioned in the <strong>Ambient</strong> section, areas where light from light nodes
                    does not reach (either because it's outside the radius or shadowed) are lit
                    with ambient light. Godot can simulate this using VoxelGI, ReflectionProbe,
                    the Sky, or a constant ambient color. The problem, however, is that all the
                    methods proposed previously act more on a larger scale (large regions) than at the
                    smaller geometry level.</paragraph>
                <paragraph>Constant ambient color and Sky are the same everywhere, while GI and
                    Reflection probes have more local detail, but not enough to simulate situations
                    where light is not able to fill inside hollow or concave features.</paragraph>
                <paragraph>This can be simulated with Screen Space Ambient Occlusion. As you can see in the
                    image below, its purpose is to make sure concave areas are darker, simulating
                    a narrower path for the light to enter:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_ssao.webp'}" original_uri="img/environment_ssao.webp" uri="tutorials/3d/img/environment_ssao.webp"></image>
                <paragraph>It is a common mistake to enable this effect, turn on a light, and not be able to
                    appreciate it. This is because <abbreviation explanation="Screen-Space Ambient Occlusion">SSAO</abbreviation>
                    only acts on <emphasis>ambient</emphasis> light. It does not affect direct light.</paragraph>
                <paragraph>This is why, in the image above, the effect is less noticeable under the direct
                    light (on the left). If you want to force
                    <abbreviation explanation="Screen-Space Ambient Occlusion">SSAO</abbreviation> to work with direct light too,
                    use the <strong>Light Affect</strong> parameter. Even though this is not physically correct,
                    some artists like how it looks.</paragraph>
                <paragraph><abbreviation explanation="Screen-Space Ambient Occlusion">SSAO</abbreviation> looks best when combined with a
                    real source of indirect light, like VoxelGI:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_ssao2.webp'}" original_uri="img/environment_ssao2.webp" uri="tutorials/3d/img/environment_ssao2.webp"></image>
                <paragraph>Tweaking <abbreviation explanation="Screen-Space Ambient Occlusion">SSAO</abbreviation> is possible with several
                    parameters:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_ssao_parameters.webp'}" original_uri="img/environment_ssao_parameters.webp" uri="tutorials/3d/img/environment_ssao_parameters.webp"></image>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Radius:</strong> The distance at which objects can occlude each other when
                            calculating screen-space ambient occlusion. Higher values will result in
                            occlusion over a greater distance at the cost of performance and quality.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Intensity:</strong> The primary screen-space ambient occlusion intensity. Acts as a
                            multiplier for the screen-space ambient occlusion effect. A higher value
                            results in darker occlusion.
                            Since <abbreviation explanation="Screen-Space Ambient Occlusion">SSAO</abbreviation> is a screen-space effect,
                            it's recommended to remain conservative with this value.
                            <abbreviation explanation="Screen-Space Ambient Occlusion">SSAO</abbreviation> that is too strong can be
                            distracting during gameplay.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Power:</strong> The distribution of occlusion. A higher value results in darker
                            occlusion, similar to <strong>Intensity</strong>, but with a sharper falloff.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Detail:</strong> Sets the strength of the additional level of detail for the
                            screen-space ambient occlusion effect. A high value makes the detail pass more
                            prominent, but it may contribute to aliasing in your final image.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Horizon:</strong> The threshold for considering whether a given point on a surface
                            is occluded or not represented as an angle from the horizon mapped into the
                            0.0-1.0 range. A value of 1.0 results in no occlusion.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Sharpness:</strong> The amount that the screen-space ambient occlusion effect is
                            allowed to blur over the edges of objects. Setting too high will result in
                            aliasing around the edges of objects. Setting too low will make object edges
                            appear blurry.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Light Affect:</strong> The screen-space ambient occlusion intensity in direct
                            light. In real life, ambient occlusion only applies to indirect light, which
                            means its effects can't be seen in direct light. Values higher than 0 will
                            make the <abbreviation explanation="Screen-Space Ambient Occlusion">SSAO</abbreviation> effect visible in
                            direct light. Values above <literal>0.0</literal> are not physically accurate, but some
                            artists prefer this effect.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>AO Channel Affect</strong> The screen-space ambient occlusion intensity on
                            materials that have an AO texture defined. Values higher than <literal>0.0</literal> will
                            make the SSAO effect visible in areas darkened by AO textures.</paragraph>
                    </list_item>
                </bullet_list>
                <note>
                    <paragraph>Since Godot 4.6, a simplified version of SSAO is available in the Compatibility
                        renderer. This implementation has a different look, but should perform
                        significantly better on low-end devices compared to SSAO in Forward+.</paragraph>
                    <paragraph>When using the Compatibility renderer, only the <strong>Radius</strong> and <strong>Intensity</strong>
                        parameters can be adjusted.</paragraph>
                </note>
                <target refid="doc-environment-and-post-processing-ssil"></target>
            </section>
            <section ids="screen-space-indirect-lighting-ssil doc-environment-and-post-processing-ssil" names="screen-space\ indirect\ lighting\ (ssil) doc_environment_and_post_processing_ssil">
                <title>Screen-Space Indirect Lighting (SSIL)</title>
                <paragraph><emphasis>This feature is only available when using the Forward+ renderer, not
                        Mobile or Compatibility.</emphasis></paragraph>
                <paragraph><abbreviation explanation="Screen-Space Indirect Lighting">SSIL</abbreviation> provides indirect lighting for
                    small details or dynamic geometry that other global illumination techniques
                    cannot cover. This applies to bounced diffuse lighting, but also emissive
                    materials. When <abbreviation explanation="Screen-Space Indirect Lighting">SSIL</abbreviation> is enabled on its
                    own, the effect may not be that noticeable, which is intended.</paragraph>
                <paragraph>Instead, <abbreviation explanation="Screen-Space Indirect Lighting">SSIL</abbreviation> is meant to be used as a
                    <emphasis>complement</emphasis> to other global illumination techniques such as VoxelGI, SDFGI and
                    LightmapGI. <abbreviation explanation="Screen-Space Indirect Lighting">SSIL</abbreviation> also provides
                    a subtle ambient occlusion effect, similar to SSAO, but with less detail.</paragraph>
                <paragraph>This feature only provides indirect lighting. It is not a full global illumination
                    solution. This makes it different from screen-space global illumination (SSGI)
                    offered by other 3D engines. <abbreviation explanation="Screen-Space Indirect Lighting">SSIL</abbreviation>
                    can be combined with <abbreviation explanation="Screen-Space Reflections">SSR</abbreviation> and/or
                    <abbreviation explanation="Screen-Space Ambient Occlusion">SSAO</abbreviation> for greater visual quality
                    (at the cost of performance).</paragraph>
                <paragraph>Tweaking <abbreviation explanation="Screen-Space Indirect Lighting">SSIL</abbreviation> is possible with several parameters:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Radius:</strong> The distance that bounced lighting can travel when using the
                            screen space indirect lighting effect. A larger value will result in light
                            bouncing further in a scene, but may result in under-sampling artifacts which
                            look like long spikes surrounding light sources.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Intensity:</strong> The brightness multiplier for the screen-space indirect
                            lighting effect. A higher value will result in brighter light.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Sharpness:</strong> The amount that the screen-space indirect lighting effect is
                            allowed to blur over the edges of objects. Setting too high will result in
                            aliasing around the edges of objects. Setting too low will make object edges
                            appear blurry.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Normal Rejection:</strong> Amount of normal rejection used when calculating
                            screen-space indirect lighting. Normal rejection uses the normal of a given
                            sample point to reject samples that are facing away from the current pixel.
                            Normal rejection is necessary to avoid light leaking when only one side of an
                            object is illuminated. However, normal rejection can be disabled if light
                            leaking is desirable, such as when the scene mostly contains emissive objects
                            that emit light from faces that cannot be seen from the camera.</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/environment_ssil.webp'}" original_uri="img/environment_ssil.webp" uri="tutorials/3d/img/environment_ssil.webp"></image>
            </section>
            <section ids="signed-distance-field-global-illumination-sdfgi" names="signed\ distance\ field\ global\ illumination\ (sdfgi)">
                <title>Signed Distance Field Global Illumination (SDFGI)</title>
                <paragraph><emphasis>This feature is only available when using the Forward+ renderer, not
                        Mobile or Compatibility.</emphasis></paragraph>
                <paragraph>Signed distance field global illumination (SDFGI) is a form of real-time global
                    illumination. It is not a screen-space effect, which means it can provide global
                    illumination for off-screen elements (unlike <abbreviation explanation="Screen-Space Indirect Lighting">SSIL</abbreviation>).</paragraph>
                <seealso>
                    <paragraph>See <reference internal="True" refuri="global_illumination/using_sdfgi#doc-using-sdfgi"><inline classes="std std-ref">Signed distance field global illumination (SDFGI)</inline></reference> for instructions on setting up this global
                        illumination technique.</paragraph>
                </seealso>
                <image candidates="{'*': 'tutorials/3d/img/environment_sdfgi.webp'}" original_uri="img/environment_sdfgi.webp" uri="tutorials/3d/img/environment_sdfgi.webp"></image>
                <target refid="doc-environment-and-post-processing-glow"></target>
            </section>
            <section ids="glow doc-environment-and-post-processing-glow" names="glow doc_environment_and_post_processing_glow">
                <title>Glow</title>
                <note>
                    <paragraph>When using the Compatibility rendering method, glow uses a different
                        implementation with some properties being unavailable and hidden from the
                        inspector: <strong>Levels</strong>, <strong>Normalized</strong>, <strong>Strength</strong>, <strong>Blend Mode</strong>,
                        <strong>Mix</strong>, <strong>Map</strong>, and <strong>Map Strength</strong>.</paragraph>
                    <paragraph>This implementation is optimized to run on low-end devices and is less
                        flexible as a result.</paragraph>
                </note>
                <paragraph>In photography and film, when light amount exceeds the maximum <emphasis>luminance</emphasis>
                    (brightness) supported by the media, it generally bleeds outwards to darker
                    regions of the image. This is simulated in Godot with the <strong>Glow</strong> effect.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_glow1.webp'}" original_uri="img/environment_glow1.webp" uri="tutorials/3d/img/environment_glow1.webp"></image>
                <paragraph>By default, even if the effect is enabled, it will be weak or invisible. One of
                    two conditions need to happen for it to actually show:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <enumerated_list enumtype="arabic" prefix="" suffix=")">
                            <list_item>
                                <paragraph>The light in a pixel surpasses the <strong>HDR Threshold</strong> (where 0 is all light
                                    surpasses it, and 1.0 is light over the tonemapper <strong>White</strong> value).
                                    Normally, this value is expected to be at 1.0, but it can be lowered to
                                    allow more light to bleed. There is also an extra parameter, <strong>HDR Scale</strong>,
                                    that allows scaling (making brighter or darker) the light surpassing the
                                    threshold.</paragraph>
                            </list_item>
                        </enumerated_list>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/environment_glow_threshold.webp'}" original_uri="img/environment_glow_threshold.webp" uri="tutorials/3d/img/environment_glow_threshold.webp"></image>
                <bullet_list bullet="-">
                    <list_item>
                        <enumerated_list enumtype="arabic" prefix="" start="2" suffix=")">
                            <list_item>
                                <paragraph>The <strong>Bloom</strong> property has a value greater than <literal>0.0</literal>. As it increases,
                                    it sends the whole screen to the glow processor at higher amounts.</paragraph>
                            </list_item>
                        </enumerated_list>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/environment_glow_bloom.webp'}" original_uri="img/environment_glow_bloom.webp" uri="tutorials/3d/img/environment_glow_bloom.webp"></image>
                <paragraph>Both will cause the light to start bleeding out of the brighter areas.</paragraph>
                <paragraph>Once glow is visible, it can be controlled with a few extra parameters:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Intensity</strong> is an overall scale for the effect, it can be made stronger or
                            weaker (<literal>0.0</literal> removes it).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Strength</strong> is how strong the gaussian filter kernel is processed. Greater
                            values make the filter saturate and expand outwards. In general, changing this
                            is not needed, as the size can be adjusted more efficiently with the <strong>Levels</strong>.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>The <strong>Blend Mode</strong> of the effect can also be changed:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Additive</strong> is the strongest one, as it only adds the glow effect over the
                            image with no blending involved. In general, it's too strong to be used, but
                            can look good with low-intensity <strong>Bloom</strong> (produces a dream-like effect).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Screen</strong> ensures glow never brightens more than itself and it works great as
                            an all around.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Softlight</strong> is the default and weakest one, producing only a subtle color
                            disturbance around the objects. This mode works best on dark scenes.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Replace</strong> can be used to
                            <reference internal="True" refid="doc-environment-and-post-processing-using-glow-to-blur-the-screen"><inline classes="std std-ref">blur the whole screen</inline></reference>
                            or debug the effect. It only shows the glow effect without the image below.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Mix</strong> mixes the glow effect with the main image. This can be used for
                            greater artistic control. The mix factor is controlled by the <strong>Mix</strong> property
                            which appears above the blend mode (only when the blend mode is set to Mix).
                            High mix factor values will appear to darken the image unless <strong>Bloom</strong> is
                            increased.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>To change the glow effect size and shape, Godot provides <strong>Levels</strong>. Smaller
                    levels are strong glows that appear around objects, while large levels are hazy
                    glows covering the whole screen:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_glow_layers.webp'}" original_uri="img/environment_glow_layers.webp" uri="tutorials/3d/img/environment_glow_layers.webp"></image>
                <paragraph>The real strength of this system, though, is to combine levels to create more
                    interesting glow patterns:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_glow_layers2.webp'}" original_uri="img/environment_glow_layers2.webp" uri="tutorials/3d/img/environment_glow_layers2.webp"></image>
                <paragraph>Finally, the glow effect can be controlled using a <emphasis>glow map</emphasis>, which is a
                    texture that determines how bright glow should be on each part of the screen.
                    This texture can optionally be colored to tint the glow effect to the glow map's
                    color. The texture is stretched to fit the viewport, so using an aspect ratio
                    that matches your viewport's most common aspect ratio (such as 16:9) is recommended
                    to avoid visible distortion.</paragraph>
                <paragraph>There are 2 main use cases for a glow map texture:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Create a "lens dirt" effect using a dirt pattern texture.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Make glow less strong on specific parts of the screen by using a gradient texture.</paragraph>
                    </list_item>
                </bullet_list>
                <image candidates="{'*': 'tutorials/3d/img/environment_glow_map.webp'}" original_uri="img/environment_glow_map.webp" uri="tutorials/3d/img/environment_glow_map.webp"></image>
                <paragraph>By default, glow uses a bicubic scaling filter on desktop platforms and a
                    bilinear scaling filter on mobile platforms. The bicubic scaling filter results
                    in higher quality with a less blocky appearance, but it has a performance cost
                    on the GPU which can be significant on integrated graphics.
                    The scale mode can be controlled using the
                    <strong>Rendering &gt; Environment &gt; Glow &gt; Upscale Mode</strong> project setting.
                    This setting is only effective when using the Forward+ or Mobile renderers,
                    as Compatibility uses a different glow implementation.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_and_post_processing_glow_scale_mode.webp'}" original_uri="img/environment_and_post_processing_glow_scale_mode.webp" uri="tutorials/3d/img/environment_and_post_processing_glow_scale_mode.webp"></image>
                <target refid="doc-environment-and-post-processing-using-glow-in-2d"></target>
            </section>
            <section ids="using-glow-in-2d doc-environment-and-post-processing-using-glow-in-2d" names="using\ glow\ in\ 2d doc_environment_and_post_processing_using_glow_in_2d">
                <title>Using glow in 2D</title>
                <paragraph>There are 2 ways to use glow in 2D:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Since Godot 4.2, you can enable HDR for 2D rendering when using the Forward+
                            and Mobile rendering methods. This has a performance cost, but it allows for a
                            greater dynamic range. This also allows you to control which objects glow
                            using their individual <strong>Modulate</strong> or <strong>Self Modulate</strong> properties (use the
                            Intensity slider in the color picker). Enabling HDR can also reduce banding in the 2D
                            rendering output.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>To enable HDR in 2D, open the Project Settings, enable
                                    <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-rendering-viewport-hdr-2d"><inline classes="std std-ref">Rendering &gt; Viewport &gt; HDR 2D</inline></reference>
                                    then restart the editor.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph>If you want to maximize performance, you can leave HDR disabled for 2D
                            rendering. However, you will have less control on which objects glow.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Enable glow, set the environment background mode to <strong>Canvas</strong> then decrease
                                    <strong>Glow HDR Threshold</strong> so that pixels that are not overbright will still
                                    glow. To prevent UI elements from glowing, make them children of a
                                    <reference internal="True" refuri="../../classes/class_canvaslayer#class-canvaslayer"><inline classes="std std-ref">CanvasLayer</inline></reference> node. You can control which layers are affected by
                                    glow using the <strong>Background &gt; Canvas Max Layer</strong> property of the Environment
                                    resource.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                </bullet_list>
                <figure align="center" ids="id1">
                    <image alt="Example of using glow in a 2D scene" candidates="{'*': 'tutorials/3d/img/environment_and_post_processing_glow_in_2d.webp'}" original_uri="img/environment_and_post_processing_glow_in_2d.webp" uri="tutorials/3d/img/environment_and_post_processing_glow_in_2d.webp"></image>
                    <caption>Example of using glow in a 2D scene. HDR 2D is enabled, while coins and the
                        bullet have their <strong>Modulate</strong> property increased to overbright values using the
                        Intensity slider in the color picker.</caption>
                </figure>
                <warning>
                    <paragraph>The 2D renderer renders in linear color space if the
                        <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-rendering-viewport-hdr-2d"><inline classes="std std-ref">Rendering &gt; Viewport &gt; HDR 2D</inline></reference>
                        project setting is enabled, so the <literal>source_color</literal> hint must also be used
                        for uniform samplers that are used as color input in <literal>canvas_item</literal> shaders.
                        If this is not done, the texture will appear washed out.</paragraph>
                    <paragraph>If 2D HDR is disabled, <literal>source_color</literal> will keep working correctly in
                        <literal>canvas_item</literal> shaders, so it's recommend to use it when relevant either
                        way.</paragraph>
                    <paragraph>Using linear color space also means that alpha blending will change. Sprites
                        with low opacity values generally become more visible, and font rendering will
                        look bolder due to the low-opacity pixels from the font antialiasing becoming
                        more visible. This also affects the editor's own rendering.</paragraph>
                </warning>
                <target refid="doc-environment-and-post-processing-using-glow-to-blur-the-screen"></target>
            </section>
            <section ids="using-glow-to-blur-the-screen doc-environment-and-post-processing-using-glow-to-blur-the-screen" names="using\ glow\ to\ blur\ the\ screen doc_environment_and_post_processing_using_glow_to_blur_the_screen">
                <title>Using glow to blur the screen</title>
                <paragraph>Glow can be used to blur the whole viewport, which is useful for background blur
                    when a menu is open. Only 3D rendering will be affected unless the environment's
                    background mode is set to <strong>Canvas</strong>. To prevent UI elements from being blurred
                    when using the Canvas background mode, make them children of a <reference internal="True" refuri="../../classes/class_canvaslayer#class-canvaslayer"><inline classes="std std-ref">CanvasLayer</inline></reference>
                    node. You can control which layers are affected by this blurring effect using the
                    <strong>Background &gt; Canvas Max Layer</strong> property of the Environment resource.</paragraph>
                <paragraph>To use glow as a blurring solution:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Enable <strong>Normalized</strong> and adjust levels according to preference. Increasing
                            higher level indices will result in a more blurred image. It's recommended to
                            leave a single glow level at <literal>1.0</literal> and leave all other glow levels at
                            <literal>0.0</literal>, but this is not required. Note that the final appearance will vary
                            depending on viewport resolution.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Set <strong>Intensity</strong> to <literal>1.0</literal> and <strong>Bloom</strong> to <literal>1.0</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Set the blend mode to <strong>Replace</strong> and <strong>HDR Luminance Cap</strong> to <literal>1.0</literal>.</paragraph>
                    </list_item>
                </bullet_list>
                <figure align="center" ids="id2">
                    <image alt="Example of using glow to blur the 2D rendering in the menu's background" candidates="{'*': 'tutorials/3d/img/environment_and_post_processing_glow_blur.webp'}" original_uri="img/environment_and_post_processing_glow_blur.webp" uri="tutorials/3d/img/environment_and_post_processing_glow_blur.webp"></image>
                    <caption>Example of using glow to blur the 2D rendering in the menu's background</caption>
                </figure>
            </section>
            <section ids="adjustments" names="adjustments">
                <title>Adjustments</title>
                <paragraph>At the end of processing, Godot offers the possibility to do some standard
                    image adjustments.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_adjustments.webp'}" original_uri="img/environment_adjustments.webp" uri="tutorials/3d/img/environment_adjustments.webp"></image>
                <paragraph><strong>Basic BCS adjustments</strong></paragraph>
                <paragraph>The first adjustment is being able to change the typical <strong>Brightness</strong>, <strong>Contrast</strong>,
                    and <strong>Saturation</strong> properties:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_adjustments_bcs.webp'}" original_uri="img/environment_adjustments_bcs.webp" uri="tutorials/3d/img/environment_adjustments_bcs.webp"></image>
                <paragraph><strong>Color correction using a 1D gradient</strong></paragraph>
                <paragraph>The second adjustment is by supplying a color correction gradient. This can be
                    done by assigning a GradientTexture1D resource to the <strong>Color Correction</strong>
                    property, or by loading a texture containing a horizontal gradient. The leftmost
                    part of the gradient represents black in the source image, whereas the rightmost
                    part of the gradient represents white in the source image.</paragraph>
                <paragraph>A linear black-to-white gradient like the following one will produce no effect:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_adjustments_default_gradient.webp'}" original_uri="img/environment_adjustments_default_gradient.webp" uri="tutorials/3d/img/environment_adjustments_default_gradient.webp"></image>
                <paragraph>But creating custom ones will allow to map each channel to a different color:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_adjustments_custom_gradient.webp'}" original_uri="img/environment_adjustments_custom_gradient.webp" uri="tutorials/3d/img/environment_adjustments_custom_gradient.webp"></image>
                <paragraph><strong>Color correction using a 3D LUT</strong></paragraph>
                <paragraph>A 3D look-up-texture (LUT) can also be used for color correction. This is a
                    special texture used to modify each color channel separately from one another
                    (red, green, blue). This image can be of any resolution, but since color
                    correction is low-frequency data, sticking to low resolutions is recommended for
                    performance reasons. A LUT texture's resolution is typically 171717, 333333,
                    515151 or 656565 (the odd size allows for better interpolation).</paragraph>
                <paragraph>For this to work, the look-up texture's import mode must be set to Texture3D
                    in the Import dock (instead of being imported as a regular Texture2D):</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_adjustments_3d_lut_import.webp'}" original_uri="img/environment_adjustments_3d_lut_import.webp" uri="tutorials/3d/img/environment_adjustments_3d_lut_import.webp"></image>
                <paragraph>Make sure to configure the number of horizontal and vertical slices to import as
                    well. If you don't do this, the LUT texture will not affect the viewport
                    correctly when used. You can preview how the 3D texture was imported by
                    double-clicking it, in the FileSystem dock, then going to the inspector to flip
                    through the texture's layers.</paragraph>
                <paragraph>You can use this neutral 333333 LUT template as a base (right-click and choose
                    <strong>Save as</strong>):</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_adjustments_3d_lut_template.webp'}" original_uri="img/environment_adjustments_3d_lut_template.webp" uri="tutorials/3d/img/environment_adjustments_3d_lut_template.webp"></image>
                <paragraph>With the above LUT template, after changing its import mode to <strong>Texture3D</strong>,
                    set its number of <strong>Horizontal</strong> slices to <literal>33</literal> in the Import dock then click
                    <strong>Reimport</strong>. If you load this LUT into the <strong>Color Correction</strong> property, you
                    won't see any visible difference for now since this texture is designed to be a
                    neutral starting point.</paragraph>
                <paragraph>This LUT template can be modified in an image editor to provide a different
                    mood to the image. A common workflow is to place the LUT image next to a
                    screenshot of the project's 3D viewport, then use an image editor to modify both
                    the LUT image and the screenshot at the same time. The LUT can then be saved and
                    applied to the game engine to perform the same color correction in real-time.</paragraph>
                <paragraph>For example, modifying the LUT template in an image editor to give it a
                    "sepia" look results in the image on the right:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_adjustments_3d_lut_comparison.webp'}" original_uri="img/environment_adjustments_3d_lut_comparison.webp" uri="tutorials/3d/img/environment_adjustments_3d_lut_comparison.webp"></image>
                <note>
                    <paragraph>Adjustments and color correction are applied <emphasis>after</emphasis> tonemapping.
                        This means the tonemapping properties defined above still have an effect
                        when adjustments are enabled.</paragraph>
                </note>
            </section>
        </section>
        <section ids="camera-attribute-options" names="camera\ attribute\ options">
            <title>Camera attribute options</title>
            <section ids="depth-of-field-far-blur" names="depth\ of\ field\ /\ far\ blur">
                <title>Depth of Field / Far Blur</title>
                <paragraph>This effect simulates focal distance on cameras. It blurs objects behind
                    a given range. It has an initial <strong>Distance</strong> with a <strong>Transition</strong> region
                    (in world units):</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_dof_far.webp'}" original_uri="img/environment_dof_far.webp" uri="tutorials/3d/img/environment_dof_far.webp"></image>
                <paragraph>The <strong>Amount</strong> parameter controls the amount of blur. For larger blurs, tweaking
                    the depth of field quality in the advanced project settings may be needed to
                    avoid artifacts.</paragraph>
            </section>
            <section ids="depth-of-field-near-blur" names="depth\ of\ field\ /\ near\ blur">
                <title>Depth of Field / Near Blur</title>
                <paragraph>This effect simulates focal distance on cameras. It blurs objects close
                    to the camera (acts in the opposite direction as far blur).
                    It has an initial <strong>Distance</strong> with a <strong>Transition</strong> region (in world units):</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_dof_near.webp'}" original_uri="img/environment_dof_near.webp" uri="tutorials/3d/img/environment_dof_near.webp"></image>
                <paragraph>The <strong>Amount</strong> parameter controls the amount of blur. For larger blurs, tweaking
                    the <strong>Quality</strong> may be needed in order to avoid artifacts.</paragraph>
                <paragraph>It is common to use both blurs together to focus the viewer's attention on a
                    given object, or create a so-called
                    <reference name='"tilt shift" effect' refuri="https://en.wikipedia.org/wiki/Miniature_faking">"tilt shift" effect</reference>.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_mixed_blur.webp'}" original_uri="img/environment_mixed_blur.webp" uri="tutorials/3d/img/environment_mixed_blur.webp"></image>
                <note>
                    <paragraph>When using CameraAttributesPhysical instead of CameraAttributesPractical,
                        depth of field is automatically computed from the camera attributes' focus
                        distance, focal length, and aperture.</paragraph>
                </note>
            </section>
            <section ids="exposure" names="exposure">
                <title>Exposure</title>
                <paragraph>This multiplies the overall scene brightness visible from the camera. Higher
                    values result in a visually brighter scene.</paragraph>
            </section>
            <section ids="auto-exposure" names="auto\ exposure">
                <title>Auto Exposure</title>
                <paragraph><emphasis>This feature is only available when using the Forward+ renderer, not
                        Mobile or Compatibility.</emphasis></paragraph>
                <paragraph>Even though, in most cases, lighting and texturing are heavily artist controlled,
                    Godot supports a basic high dynamic range implementation with the auto exposure
                    mechanism. This is generally used to add realism when combining interior areas
                    with low light and bright outdoor areas. Auto exposure simulates the camera
                    (or eye) in an effort to adapt between light and dark locations and their
                    different amounts of light.</paragraph>
                <note>
                    <paragraph>Auto exposure needs to evaluate the scene's brightness every frame, which
                        has a moderate performance cost. Therefore, it's recommended to leave Auto
                        Exposure disabled if it doesn't make much of a difference in your scene.</paragraph>
                </note>
                <image candidates="{'*': 'tutorials/3d/img/environment_hdr_autoexp.webp'}" original_uri="img/environment_hdr_autoexp.webp" uri="tutorials/3d/img/environment_hdr_autoexp.webp"></image>
                <paragraph>The simplest way to use auto exposure is to make sure outdoor lights (or other
                    strong lights) have energy beyond 1.0. This is done by tweaking their <strong>Energy</strong>
                    multiplier (on the Light itself). To make it consistent, the <strong>Sky</strong> usually
                    needs to use the energy multiplier too, to match with the directional light.
                    Normally, values between 3.0 and 6.0 are enough to simulate indoor-outdoor conditions.</paragraph>
                <paragraph>By combining Auto Exposure with <reference internal="True" refid="doc-environment-and-post-processing-glow"><inline classes="std std-ref">Glow</inline></reference>
                    post-processing, pixels that go over the tonemap <strong>White</strong> will bleed to the
                    glow buffer, creating the typical bloom effect in photography.</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_hdr_bloom.webp'}" original_uri="img/environment_hdr_bloom.webp" uri="tutorials/3d/img/environment_hdr_bloom.webp"></image>
                <paragraph>The user-controllable values in the Auto Exposure section come with sensible
                    defaults, but you can still tweak them:</paragraph>
                <image candidates="{'*': 'tutorials/3d/img/environment_hdr.webp'}" original_uri="img/environment_hdr.webp" uri="tutorials/3d/img/environment_hdr.webp"></image>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Scale:</strong> Value to scale the lighting. Higher values produce brighter
                            images, and lower values produce darker ones.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Min Sensitivity / Min Exposure Value:</strong> Minimum luminance that auto exposure
                            will aim to adjust for (in ISO when using CameraAttributesPractical, or in
                            EV100 when using CameraAttributesPhysical). Luminance is the average of the
                            light in all the pixels of the screen.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Max Sensitivity / Max Exposure Value:</strong> Maximum luminance that auto exposure
                            will aim to adjust for (in ISO when using CameraAttributesPractical, or in
                            EV100 when using CameraAttributesPhysical).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Speed:</strong> Speed at which luminance corrects itself. The higher the value, the
                            faster luminance correction happens. High values may be more suited to
                            fast-paced games, but can be distracting in some scenarios.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>When using CameraAttributesPractical, exposure is set using <emphasis>sensitivity</emphasis>
                    defined in ISO instead of an exposure value in EV100. Typical ISO values are
                    between 50 and 3200, with higher values resulting in higher final exposure. In
                    real life, daytime photography generally uses ISO values between 100 and 800.</paragraph>
                <seealso>
                    <paragraph>See <reference internal="True" refuri="physical_light_and_camera_units#doc-physical-light-and-camera-units"><inline classes="std std-ref">Physical light and camera units</inline></reference> if you wish to use real world
                        units to configure your camera's exposure, field of view and depth of field.</paragraph>
                </seealso>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
