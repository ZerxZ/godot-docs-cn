<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/occlusion_culling.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-occlusion-culling"></target>
    <section ids="occlusion-culling doc-occlusion-culling" names="occlusion\ culling doc_occlusion_culling">
        <title>Occlusion culling</title>
        <paragraph>In a 3D rendering engine, <strong>occlusion culling</strong> is the process of performing
            hidden geometry removal.</paragraph>
        <paragraph>On this page, you'll learn:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>What are the advantages and pitfalls of occlusion culling.</paragraph>
            </list_item>
            <list_item>
                <paragraph>How to set up occlusion culling in Godot.</paragraph>
            </list_item>
            <list_item>
                <paragraph>Troubleshooting common issues with occlusion culling.</paragraph>
            </list_item>
        </bullet_list>
        <seealso>
            <paragraph>You can see how occlusion culling works in action using the
                <reference name="Occlusion Culling and Mesh LOD demo project" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/3d/occlusion_culling_mesh_lod">Occlusion Culling and Mesh LOD demo project</reference>.</paragraph>
        </seealso>
        <section ids="why-use-occlusion-culling" names="why\ use\ occlusion\ culling">
            <title>Why use occlusion culling</title>
            <paragraph>In this example scene with hundreds of rooms stacked next to each other, a
                dynamic object (red sphere) is hidden behind the wall in the lit room (on the
                left of the door):</paragraph>
            <figure align="center" ids="id1">
                <image alt="Example scene with an occlusion culling-friendly layout" candidates="{'*': 'tutorials/3d/img/occlusion_culling_scene_example.png'}" original_uri="img/occlusion_culling_scene_example.png" uri="tutorials/3d/img/occlusion_culling_scene_example.png"></image>
                <caption>Example scene with an occlusion culling-friendly layout</caption>
            </figure>
            <paragraph>With occlusion culling disabled, all the rooms behind the lit room have to be
                rendered. The dynamic object also has to be rendered:</paragraph>
            <figure align="center" ids="id2">
                <image alt="Example scene with occlusion culling disabled (wireframe)" candidates="{'*': 'tutorials/3d/img/occlusion_culling_disabled.png'}" original_uri="img/occlusion_culling_disabled.png" uri="tutorials/3d/img/occlusion_culling_disabled.png"></image>
                <caption>Example scene with occlusion culling <strong>disabled</strong> (wireframe)</caption>
            </figure>
            <paragraph>With occlusion culling enabled, only the rooms that are actually visible have to
                be rendered. The dynamic object is also occluded by the wall, and therefore no
                longer has to be rendered:</paragraph>
            <figure align="center" ids="id3">
                <image alt="Example scene with occlusion culling enabled (wireframe)" candidates="{'*': 'tutorials/3d/img/occlusion_culling_enabled.png'}" original_uri="img/occlusion_culling_enabled.png" uri="tutorials/3d/img/occlusion_culling_enabled.png"></image>
                <caption>Example scene with occlusion culling <strong>enabled</strong> (wireframe)</caption>
            </figure>
            <paragraph>Since the engine has less work to do (fewer vertices to render and fewer draw calls),
                performance will increase as long as there are enough occlusion culling opportunities
                in the scene. This means occlusion culling is most effective in indoor scenes,
                preferably with many smaller rooms instead of fewer larger rooms. Combine
                this with <reference internal="True" refuri="mesh_lod#doc-mesh-lod"><inline classes="std std-ref">Mesh level of detail (LOD)</inline></reference> and <reference internal="True" refuri="visibility_ranges#doc-visibility-ranges"><inline classes="std std-ref">Visibility ranges (HLOD)</inline></reference> to further improve
                performance gains.</paragraph>
            <note>
                <paragraph>When using the Forward+ renderer, the engine already
                    performs a <emphasis>depth prepass</emphasis>. This consists in rendering a depth-only version
                    of the scene before rendering the scene's actual materials. This is used to
                    ensure each opaque pixel is only shaded once, reducing the cost of overdraw
                    significantly.</paragraph>
                <paragraph>The greatest performance benefits can be observed when using the Mobile
                    renderer, as it does not feature a depth prepass for performance reasons. As
                    a result, occlusion culling will actively decrease shading overdraw with
                    that renderer.</paragraph>
                <paragraph>Nonetheless, even when using a depth prepass, there is still a noticeable
                    benefit to occlusion culling in complex 3D scenes. However, in scenes with
                    few occlusion culling opportunities, occlusion culling may not be worth the
                    added setup and CPU usage.</paragraph>
            </note>
        </section>
        <section ids="how-occlusion-culling-works-in-godot" names="how\ occlusion\ culling\ works\ in\ godot">
            <title>How occlusion culling works in Godot</title>
            <note>
                <paragraph>"occluder" refers to the shape blocking the view, while "occludee" refers to
                    the object being hidden.</paragraph>
            </note>
            <paragraph>In Godot, occlusion culling works by rasterizing the scene's occluder geometry
                to a low-resolution buffer on the CPU. This is done using
                the software raytracing library <reference name="Embree" refuri="https://github.com/embree/embree">Embree</reference>.</paragraph>
            <paragraph>The engine then uses this low-resolution buffer to test the occludee's
                <abbreviation explanation="Axis-Aligned Bounding Box">AABB</abbreviation> against the occluder shapes.
                The occludee's <abbreviation explanation="Axis-Aligned Bounding Box">AABB</abbreviation> must be <emphasis>fully occluded</emphasis>
                by the occluder shape to be culled.</paragraph>
            <paragraph>As a result, smaller objects are more likely to be effectively culled than
                larger objects. Larger occluders (such as walls) also tend to be much more
                effective than smaller ones (such as decoration props).</paragraph>
        </section>
        <section ids="setting-up-occlusion-culling" names="setting\ up\ occlusion\ culling">
            <title>Setting up occlusion culling</title>
            <paragraph>The first step to using occlusion culling is to enable the
                <strong>Rendering &gt; **Occlusion Culling &gt; Use Occlusion Culling</strong> project setting.
                (Make sure the <strong>Advanced</strong> toggle is enabled in the Project Settings dialog to
                be able to see it.)</paragraph>
            <paragraph>This project setting applies immediately, so you don't need to restart the editor.</paragraph>
            <paragraph>After enabling the project setting, you still need to create some occluders. For
                performance reasons, the engine doesn't automatically use all visible geometry
                as a basis for occlusion culling. Instead, the engine requires a simplified
                representation of the scene with only static objects to be baked.</paragraph>
            <paragraph>There are two ways to set up occluders in a scene:</paragraph>
            <target refid="doc-occlusion-culling-baking"></target>
            <section ids="automatically-baking-occluders-recommended doc-occlusion-culling-baking" names="automatically\ baking\ occluders\ (recommended) doc_occlusion_culling_baking">
                <title>Automatically baking occluders (recommended)</title>
                <note>
                    <paragraph>Only MeshInstance3D nodes are currently taken into account in the <emphasis>occluder</emphasis>
                        baking process. MultiMeshInstance3D, GPUParticles3D, CPUParticles3D and CSG
                        nodes are <strong>not</strong> taken into account when baking occluders. If you wish
                        those to be treated as occluders, you have to manually create occluder
                        shapes that (roughly) match their geometry.</paragraph>
                    <paragraph>Since Godot 4.4, CSG nodes can be taken into account in the baking process if they are
                        <reference internal="True" refuri="csg_tools#doc-csg-tools-converting-to-mesh-instance-3d"><inline classes="std std-ref">converted to a MeshInstance3D</inline></reference>
                        before baking occluders.</paragraph>
                    <paragraph>This restriction does not apply to <emphasis>occludees</emphasis>. Any node type that inherits
                        from GeometryInstance3D can be occluded.</paragraph>
                </note>
                <paragraph>After enabling the occlusion culling project setting mentioned above, add an
                    OccluderInstance3D node to the scene containing your 3D level.</paragraph>
                <paragraph>Select the OccluderInstance3D node, then click <strong>Bake Occluders</strong> at the top of
                    the 3D editor viewport. After baking, the OccluderInstance3D node will contain
                    an Occluder3D resource that stores a simplified version of your level's
                    geometry. This occluder geometry appears as purple wireframe lines in the 3D view
                    (as long as <strong>View Gizmos</strong> is enabled in the <strong>Perspective</strong> menu).
                    This geometry is then used to provide occlusion culling for both static and
                    dynamic occludees.</paragraph>
                <paragraph>After baking, you may notice that your dynamic objects (such as the player,
                    enemies, etc…) are included in the baked mesh. To prevent this, set the
                    <strong>Bake &gt; Cull Mask</strong> property on the OccluderInstance3D to exclude certain visual
                    layers from being baked.</paragraph>
                <paragraph>For example, you can disable layer 2 on the cull mask, then configure your
                    dynamic objects' MeshInstance3D nodes to be located on the visual layer 2
                    (instead of layer 1). To do so, select the MeshInstance3D node in question, then
                    on the <strong>VisualInstance3D &gt; Layers</strong> property, uncheck layer 1 then check layer
                    2. After configuring both cull mask and layers, bake occluders again by
                    following the above process.</paragraph>
            </section>
            <section ids="manually-placing-occluders" names="manually\ placing\ occluders">
                <title>Manually placing occluders</title>
                <paragraph>This approach is more suited for specialized use cases, such as creating occlusion
                    for MultiMeshInstance3D setups or CSG nodes (due to the aforementioned limitation).</paragraph>
                <paragraph>After enabling the occlusion culling project setting mentioned above, add an
                    OccluderInstance3D node to the scene containing your 3D level. Select the
                    OccluderInstance3D node, then choose an occluder type to add in the <strong>Occluder</strong>
                    property:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>QuadOccluder3D (a single plane)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>BoxOccluder3D (a cuboid)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>SphereOccluder3D (a sphere-shaped occluder)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>PolygonOccluder3D (a 2D polygon with as many points as you want)</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>There is also ArrayOccluder3D, whose points can't be modified in the editor but
                    can be useful for procedural generation from a script.</paragraph>
                <target refid="doc-occlusion-culling-preview"></target>
            </section>
        </section>
        <section ids="previewing-occlusion-culling doc-occlusion-culling-preview" names="previewing\ occlusion\ culling doc_occlusion_culling_preview">
            <title>Previewing occlusion culling</title>
            <paragraph>You can enable a debug draw mode to preview what the occlusion culling is
                actually "seeing". In the top-left corner of the 3D editor viewport, click the
                <strong>Perspective</strong> button (or <strong>Orthogonal</strong> depending on your current camera
                mode), then choose <strong>Display Advanced… &gt; Occlusion Culling Buffer</strong>. This will
                display the low-resolution buffer that is used by the engine for occlusion
                culling.</paragraph>
            <paragraph>In the same menu, you can also enable <strong>View Information</strong> and <strong>View Frame
                    Time</strong> to view the number of draw calls and rendered primitives (vertices +
                indices) in the bottom-right corner, along with the number of frames per second
                rendered in the top-right corner.</paragraph>
            <paragraph>If you toggle occlusion culling in the project settings while this information
                is displayed, you can see how much occlusion culling improves performance in
                your scene. Note that the performance benefit highly depends on the 3D editor
                camera's view angle, as occlusion culling is only effective if there are
                occluders in front of the camera.</paragraph>
            <paragraph>To toggle occlusion culling at runtime, set <literal>use_occlusion_culling</literal> on the
                root viewport as follows:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">get_tree().root.use_occlusion_culling = true</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GetTree().Root.UseOcclusionCulling = true;</literal_block>
                </div>
            </container>
            <paragraph>Toggling occlusion culling at runtime is useful to compare performance on a
                running project.</paragraph>
        </section>
        <section ids="performance-considerations" names="performance\ considerations">
            <title>Performance considerations</title>
            <section ids="design-your-levels-to-take-advantage-of-occlusion-culling" names="design\ your\ levels\ to\ take\ advantage\ of\ occlusion\ culling">
                <title>Design your levels to take advantage of occlusion culling</title>
                <paragraph><strong>This is the most important guideline.</strong> A good level design is not just about
                    what the gameplay demands; it should also be built with occlusion in mind.</paragraph>
                <paragraph>For indoor environments, add opaque walls to "break" the line of sight at
                    regular intervals and ensure not too much of the scene can be seen at once.</paragraph>
                <paragraph>For large open scenes, use a pyramid-like structure for the terrain's elevation
                    when possible. This provides the greatest culling opportunities compared to any
                    other terrain shape.</paragraph>
            </section>
            <section ids="avoid-moving-occluderinstance3d-nodes-during-gameplay" names="avoid\ moving\ occluderinstance3d\ nodes\ during\ gameplay">
                <title>Avoid moving OccluderInstance3D nodes during gameplay</title>
                <paragraph>This includes moving the parents of OccluderInstance3D nodes, as this will cause
                    the nodes themselves to move in global space, therefore requiring the <abbreviation explanation="Bounding Volume Hierarchy">BVH</abbreviation> to be rebuilt.</paragraph>
                <paragraph>Toggling an OccluderInstance3D's visibility (or one of its parents' visibility)
                    is not as expensive, as the update only needs to happen once (rather than
                    continuously).</paragraph>
                <paragraph>For example, if you have a sliding or rotating door, you can make the
                    OccluderInstance3D node not be a child of the door itself (so that the occluder
                    never moves), but you can hide the OccluderInstance3D visibility once the door
                    starts opening. You can then reshow the OccluderInstance3D once the door is
                    fully closed.</paragraph>
                <paragraph>If you absolutely have to move an OccluderInstance3D node during gameplay, use a
                    primitive Occluder3D shape for it instead of a complex baked shape.</paragraph>
            </section>
            <section ids="use-the-simplest-possible-occluder-shapes" names="use\ the\ simplest\ possible\ occluder\ shapes">
                <title>Use the simplest possible occluder shapes</title>
                <paragraph>If you notice low performance or stuttering in complex 3D scenes, it may mean
                    that the CPU is overloaded as a result of rendering detailed occluders.
                    Select the OccluderInstance3D node,
                    increase the <strong>Bake &gt; Simplification</strong> property then bake occluders again.</paragraph>
                <paragraph>Remember to keep the simplification value reasonable. Values that are too high
                    for the level's geometry may cause incorrect occlusion culling to occur, as in
                    <reference internal="True" refid="doc-occlusion-culling-troubleshooting-false-negative"><inline classes="std std-ref">My occludee is being culled when it shouldn't be</inline></reference>.</paragraph>
                <paragraph>If this still doesn't lead to low enough CPU usage,
                    you can try adjusting the <strong>Rendering &gt; Occlusion Culling &gt; BVH Build Quality</strong>
                    project setting and/or decreasing
                    <strong>Rendering &gt; Occlusion Culling &gt; Occlusion Rays Per Thread</strong>.
                    You'll need to enable the <strong>Advanced</strong> toggle in the Project Settings dialog to
                    see those settings.</paragraph>
            </section>
        </section>
        <section ids="troubleshooting" names="troubleshooting">
            <title>Troubleshooting</title>
            <section ids="my-occludee-isn-t-being-culled-when-it-should-be" names="my\ occludee\ isn't\ being\ culled\ when\ it\ should\ be">
                <title>My occludee isn't being culled when it should be</title>
                <paragraph><strong>On the occluder side:</strong></paragraph>
                <paragraph>First, double-check that the <strong>Bake &gt; Cull Mask</strong> property in the
                    OccluderInstance3D is set to allow baking the meshes you'd like. The visibility
                    layer of the MeshInstance3D nodes must be present within the cull mask for the
                    mesh to be included in the bake.</paragraph>
                <paragraph>Also note that occluder baking only takes meshes with <emphasis>opaque</emphasis> materials into
                    account. Surfaces will <emphasis>transparent</emphasis> materials will <strong>not</strong> be included in the
                    bake, even if the texture applied on them is fully opaque.</paragraph>
                <paragraph>Lastly, remember that MultiMeshInstance3D, GPUParticles3D, CPUParticles3D and CSG
                    nodes are <strong>not</strong> taken into account when baking occluders. As a workaround, you
                    can add OccluderInstance3D nodes for those manually.</paragraph>
                <paragraph><strong>On the occludee side:</strong></paragraph>
                <paragraph>Make sure <strong>Extra Cull Margin</strong> is set as low as possible (it should usually be
                    <literal>0.0</literal>), and that <strong>Ignore Occlusion Culling</strong> is disabled in the object's
                    GeometryInstance3D section.</paragraph>
                <paragraph>Also, check the AABB's size (which is represented by an orange box when
                    selecting the node). This axis-aligned bounding box must be <emphasis>fully</emphasis> occluded by
                    the occluder shapes for the occludee to be hidden.</paragraph>
                <target refid="doc-occlusion-culling-troubleshooting-false-negative"></target>
            </section>
            <section ids="my-occludee-is-being-culled-when-it-shouldn-t-be doc-occlusion-culling-troubleshooting-false-negative" names="my\ occludee\ is\ being\ culled\ when\ it\ shouldn't\ be doc_occlusion_culling_troubleshooting_false_negative">
                <title>My occludee is being culled when it shouldn't be</title>
                <paragraph>The most likely cause for this is that objects that were included in the
                    occluder bake have been moved after baking occluders. For instance, this can
                    occur when moving your level geometry around or rearranging its layout. To fix
                    this, select the OccluderInstance3D node and bake occluders again.</paragraph>
                <paragraph>This can also happen because dynamic objects were included in the bake, even
                    though they shouldn't be. Use the
                    <reference internal="True" refid="doc-occlusion-culling-preview"><inline classes="std std-ref">occlusion culling debug draw mode</inline></reference> to look
                    for occluder shapes that shouldn't be present, then
                    <reference internal="True" refid="doc-occlusion-culling-baking"><inline classes="std std-ref">adjust the bake cull mask accordingly</inline></reference>.</paragraph>
                <paragraph>The last possible cause for this is overly aggressive mesh simplification during
                    the occluder baking process. Select the OccluderInstance3D node,
                    decrease the <strong>Bake &gt; Simplification</strong> property then bake occluders again.</paragraph>
                <paragraph>As a last resort, you can enable the <strong>Ignore Occlusion Culling</strong> property on
                    the occludee. This will negate the performance improvements of occlusion culling
                    for that object, but it makes sense to do this for objects that will never be
                    culled (such as a first-person view model).</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
