<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/particles/collision.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-3d-particles-collision"></target>
    <section ids="d-particle-collisions doc-3d-particles-collision" names="3d\ particle\ collisions doc_3d_particles_collision">
        <title>3D Particle collisions</title>
        <figure>
            <image alt="Particle collisions" candidates="{'*': 'tutorials/3d/particles/img/particle_collision.webp'}" original_uri="img/particle_collision.webp" uri="tutorials/3d/particles/img/particle_collision.webp"></image>
        </figure>
        <paragraph>Since GPU particles are processed entirely on the GPU, they don't have access to the game's physical
            world. If you need particles to collide with the environment, you have to set up particle collision nodes.
            There are four of them: <reference internal="True" refuri="../../../classes/class_gpuparticlescollisionbox3d#class-gpuparticlescollisionbox3d"><inline classes="std std-ref">GPUParticlesCollisionBox3D</inline></reference>, <reference internal="True" refuri="../../../classes/class_gpuparticlescollisionsphere3d#class-gpuparticlescollisionsphere3d"><inline classes="std std-ref">GPUParticlesCollisionSphere3D</inline></reference>,
            <reference internal="True" refuri="../../../classes/class_gpuparticlescollisionsdf3d#class-gpuparticlescollisionsdf3d"><inline classes="std std-ref">GPUParticlesCollisionSDF3D</inline></reference>, and <reference internal="True" refuri="../../../classes/class_gpuparticlescollisionheightfield3d#class-gpuparticlescollisionheightfield3d"><inline classes="std std-ref">GPUParticlesCollisionHeightField3D</inline></reference>.</paragraph>
        <section ids="common-properties" names="common\ properties">
            <title>Common properties</title>
            <figure align="right" ids="id1">
                <image alt="Common particle collision properties" candidates="{'*': 'tutorials/3d/particles/img/particle_collision_common.webp'}" original_uri="img/particle_collision_common.webp" uri="tutorials/3d/particles/img/particle_collision_common.webp"></image>
                <caption>Common collision properties</caption>
            </figure>
            <paragraph>There are some properties that you can find on all collision nodes. They're located in the
                <literal>GPUParticlesCollision3D</literal> section in the inspector.</paragraph>
            <paragraph>The <literal>Cull Mask</literal> property controls which particle systems are affected by a collision node based
                on each system's <reference internal="True" refuri="../../../classes/class_visualinstance3d#class-visualinstance3d"><inline classes="std std-ref">visibility layers</inline></reference>. A particle system collides with a
                collision node only if at least one of the system's visibility layers is enabled in the
                collider's cull mask.</paragraph>
        </section>
        <section ids="box-collision" names="box\ collision">
            <title>Box collision</title>
            <figure align="right" ids="id2">
                <image alt="Particle collision box" candidates="{'*': 'tutorials/3d/particles/img/particle_collision_box_entry.webp'}" original_uri="img/particle_collision_box_entry.webp" uri="tutorials/3d/particles/img/particle_collision_box_entry.webp"></image>
                <caption>Box collision in the node list</caption>
            </figure>
            <paragraph>Box collision nodes are shaped like a solid, rectangular box. You control their size with the <literal>Extents</literal>
                property. Box extents always measure half of the sides of its bounds, so a value of <literal>(X=1.0,Y=1.0,Z=1.0)</literal>
                creates a box that is 2 meters wide on each side. Box collision nodes are useful for simulating floor
                and wall geometry that particles should collide against.</paragraph>
            <paragraph>To create a box collision node, add a new child node to your scene and select <literal>GPUParticlesCollisionBox3D</literal>
                from the list of available nodes. You can animate the box position or attach it to a
                moving node for more dynamic effects.</paragraph>
            <figure ids="id3">
                <image alt="Box collision with particle systems" candidates="{'*': 'tutorials/3d/particles/img/particle_collision_box.webp'}" original_uri="img/particle_collision_box.webp" uri="tutorials/3d/particles/img/particle_collision_box.webp"></image>
                <caption>Two particle systems collide with a box collision node</caption>
            </figure>
        </section>
        <section ids="sphere-collision" names="sphere\ collision">
            <title>Sphere collision</title>
            <figure align="right" ids="id4">
                <image alt="Particle collision sphere" candidates="{'*': 'tutorials/3d/particles/img/particle_collision_sphere_entry.webp'}" original_uri="img/particle_collision_sphere_entry.webp" uri="tutorials/3d/particles/img/particle_collision_sphere_entry.webp"></image>
                <caption>Sphere collision in the node list</caption>
            </figure>
            <paragraph>Sphere collision nodes are shaped like a solid sphere. The <literal>Radius</literal> property controls the size of the sphere.
                While box collision nodes don't have to be perfect cubes, sphere collision nodes will always be
                spheres. If you want to set width independently from height, you have to change the <literal>Scale</literal>
                property in the <literal>Node3D</literal> section.</paragraph>
            <paragraph>To create a sphere collision node, add a new child node to your scene and select <literal>GPUParticlesCollisionSphere3D</literal>
                from the list of available nodes. You can animate the sphere's position or attach it to a
                moving node for more dynamic effects.</paragraph>
            <figure ids="id5">
                <image alt="Sphere collision with particle systems" candidates="{'*': 'tutorials/3d/particles/img/particle_collision_sphere.webp'}" original_uri="img/particle_collision_sphere.webp" uri="tutorials/3d/particles/img/particle_collision_sphere.webp"></image>
                <caption>Two particle systems collide with a sphere collision node</caption>
            </figure>
        </section>
        <section ids="height-field-collision" names="height\ field\ collision">
            <title>Height field collision</title>
            <figure align="right" ids="id6">
                <image alt="Particle collision height field" candidates="{'*': 'tutorials/3d/particles/img/particle_collision_height.webp'}" original_uri="img/particle_collision_height.webp" uri="tutorials/3d/particles/img/particle_collision_height.webp"></image>
                <caption>Height field collision in the node list</caption>
            </figure>
            <paragraph>Height field particle collision is very useful for large outdoor areas that need to collide with particles.
                At runtime, the node creates a height field from all the meshes within its bounds that match its cull mask.
                Particles collide against the mesh that this height field represents. Since the height field generation is
                done dynamically, it can follow the player camera around and react to changes in the level. Different
                settings for the height field density offer a wide range of performance adjustments.</paragraph>
            <paragraph>To create a height field collision node, add a new child node to your scene and select <literal>GPUParticlesCollisionHeightField3D</literal>
                from the list of available nodes.</paragraph>
            <paragraph>A height field collision node is shaped like a box. The <literal>Extents</literal> property controls its size. Extents
                always measure half of the sides of its bounds, so a value of <literal>(X=1.0,Y=1.0,Z=1.0)</literal> creates a box that
                is 2 meters wide on each side. Anything outside of the node's extents is ignored for height field creation.</paragraph>
            <paragraph>The <literal>Resolution</literal> property controls how detailed the height field is. A lower resolution performs faster
                at the cost of accuracy. If the height field resolution is too low, it may look like particles penetrate level geometry
                or get stuck in the air during collision events. They might also ignore some smaller meshes completely.</paragraph>
            <figure ids="id7">
                <image alt="Height field resolutions" candidates="{'*': 'tutorials/3d/particles/img/particle_heightfield_res.webp'}" original_uri="img/particle_heightfield_res.webp" uri="tutorials/3d/particles/img/particle_heightfield_res.webp"></image>
                <caption>At low resolutions, height field collision misses some finer details (left)</caption>
            </figure>
            <paragraph>The <literal>Update Mode</literal> property controls when the height field is recreated from the meshes within its
                bounds. Set it to <literal>When Moved</literal> to make it refresh only when it moves. This performs well and is
                suited for static scenes that don't change very often. If you need particles to collide with dynamic objects
                that change position frequently, you can select <literal>Always</literal> to refresh every frame. This comes with a
                cost to performance and should only be used when necessary.</paragraph>
            <note>
                <paragraph>It's important to remember that when <literal>Update Mode</literal> is set to <literal>When Moved</literal>, it is the <emphasis>height field node</emphasis>
                    whose movement triggers an update. The height field is not updated when one of the meshes inside it moves.</paragraph>
            </note>
            <paragraph>The <literal>Follow Camera Enabled</literal> property makes the height field follow the current camera when enabled. It will
                update whenever the camera moves. This property can be used to make sure that there is always particle collision
                around the player while not wasting performance on regions that are out of sight or too far away.</paragraph>
        </section>
        <section ids="sdf-collision" names="sdf\ collision">
            <title>SDF collision</title>
            <figure align="right" ids="id8">
                <image alt="Particle collision SDF" candidates="{'*': 'tutorials/3d/particles/img/particle_collision_sdf_entry.webp'}" original_uri="img/particle_collision_sdf_entry.webp" uri="tutorials/3d/particles/img/particle_collision_sdf_entry.webp"></image>
                <caption>SDF collision in the node list</caption>
            </figure>
            <paragraph>SDF collision nodes create a <reference name="signed distance field" refuri="https://www.reddit.com/r/explainlikeimfive/comments/k2zbos/eli5_what_are_distance_fields_in_graphics">signed distance field</reference><target ids="signed-distance-field" names="signed\ distance\ field" refuri="https://www.reddit.com/r/explainlikeimfive/comments/k2zbos/eli5_what_are_distance_fields_in_graphics"></target>
                that particles can collide with. SDF collision is similar to height field collision in that it turns multiple
                meshes within its bounds into a single collision volume for particles. A major difference is that signed distance
                fields can represent holes, tunnels and overhangs, which is impossible to do with height fields alone. The
                performance overhead is larger compared to height fields, so they're best suited for small-to-medium-sized environments.</paragraph>
            <paragraph>To create an SDF collision node, add a new child node to your scene and select <literal>GPUParticlesCollisionSDF3D</literal>
                from the list of available nodes. SDF collision nodes have to be baked in order to have any effect on particles
                in the level. To do that, click the <inline classes="role-button role-ui">Bake SDF</inline> button in the viewport toolbar
                while the SDF collision node is selected and choose a directory to store the baked data. Since SDF collision needs
                to be baked in the editor, it's static and cannot change at runtime.</paragraph>
            <figure ids="id9">
                <image alt="SDF particle collision" candidates="{'*': 'tutorials/3d/particles/img/particle_collision_sdf.webp'}" original_uri="img/particle_collision_sdf.webp" uri="tutorials/3d/particles/img/particle_collision_sdf.webp"></image>
                <caption>SDF particle collision allows for very detailed 3-dimensional collision shapes</caption>
            </figure>
            <paragraph>An SDF collision node is shaped like a box. The <literal>Extents</literal> property controls its size. Extents
                always measure half of the sides of its bounds, so a value of <literal>(X=1.0,Y=1.0,Z=1.0)</literal> creates a box that
                is 2 meters wide on each side. Anything outside of the node's extents is ignored for collision.</paragraph>
            <paragraph>The <literal>Resolution</literal> property controls how detailed the distance field is. A lower resolution performs faster
                at the cost of accuracy. If the resolution is too low, it may look like particles penetrate level geometry
                or get stuck in the air during collision events. They might also ignore some smaller meshes completely.</paragraph>
            <figure ids="id10">
                <image alt="Resolution comparison" candidates="{'*': 'tutorials/3d/particles/img/particle_collision_sdf_res.webp'}" original_uri="img/particle_collision_sdf_res.webp" uri="tutorials/3d/particles/img/particle_collision_sdf_res.webp"></image>
                <caption>The same area covered by a signed distance field at different resolutions: 16 (left) and 256 (right)</caption>
            </figure>
            <paragraph>The <literal>Thickness</literal> property gives the distance field, which is usually hollow on the inside, a thickness to
                prevent particles from penetrating at high speeds. If you find that some particles don't collide with the
                level geometry and instead shoot right through it, try setting this property to a higher value.</paragraph>
            <paragraph>The <literal>Bake Mask</literal> property controls which meshes will be considered when the SDF is baked. Only meshes that
                render on the active layers in the bake mask contribute to particle collision.</paragraph>
        </section>
        <section ids="troubleshooting" names="troubleshooting">
            <title>Troubleshooting</title>
            <paragraph>For particle collision to work, the particle's <reference internal="True" refuri="properties#doc-3d-particles-properties-draw"><inline classes="std std-ref">visibility AABB</inline></reference>
                must overlap with the collider's AABB. If collisions appear to be not working
                despite colliders being set up, generate an updated visibility AABB by selecting
                the GPUParticles3D node and choosing <strong>GPUParticles3D &gt; Generate Visibility AABBâ€¦</strong>
                at the top of the 3D editor viewport.</paragraph>
            <paragraph>If the particles move fast and colliders are thin. There are two solutions for this:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Make the colliders thicker. For instance, if particles cannot get below a
                        solid floor, you could make the collider representing the floor thicker than
                        its actual visual representation. The heightfield collider automatically
                        handles this by design, as heightfields cannot represent "room over room"
                        collision.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Increased <literal>Fixed FPS</literal> in the GPUParticles3D node, which will perform collision
                        checks more often. This comes at a performance cost, so avoid setting this too high.</paragraph>
                </list_item>
            </bullet_list>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
