<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/3d/3d_rendering_limitations.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-3d-rendering-limitations"></target>
    <section ids="d-rendering-limitations doc-3d-rendering-limitations" names="3d\ rendering\ limitations doc_3d_rendering_limitations">
        <title>3D rendering limitations</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>Due to their focus on performance, real-time rendering engines have many
                limitations. Godot's renderer is no exception. To work effectively with those
                limitations, you need to understand them.</paragraph>
        </section>
        <section ids="texture-size-limits" names="texture\ size\ limits">
            <title>Texture size limits</title>
            <paragraph>On desktops and laptops, textures larger than 8192×8192 may not be supported on
                older devices. You can check your target GPU's limitations on
                <reference name="GPUinfo.org" refuri="https://www.gpuinfo.org/">GPUinfo.org</reference>.</paragraph>
            <paragraph>Mobile GPUs are typically limited to 4096×4096 textures. Also, some mobile GPUs
                don't support repeating non-power-of-two-sized textures. Therefore, if you want
                your texture to display correctly on all platforms, you should avoid using
                textures larger than 4096×4096 and use a power of two size if the texture needs
                to repeat.</paragraph>
            <paragraph>To limit the size of a specific texture that may be too large to render, you can
                set the <strong>Process &gt; Size Limit</strong> import option to a value greater than <literal>0</literal>.
                This will reduce the texture's dimensions on import (preserving aspect ratio)
                without affecting the source file.</paragraph>
            <target refid="doc-3d-rendering-limitations-color-banding"></target>
        </section>
        <section ids="color-banding doc-3d-rendering-limitations-color-banding" names="color\ banding doc_3d_rendering_limitations_color_banding">
            <title>Color banding</title>
            <paragraph>When using the Forward+ or Mobile rendering methods, Godot's 3D engine
                renders internally in HDR. However, the rendering output will be tonemapped to a
                low dynamic range so it can be displayed on the screen. This can result in
                visible banding, especially when using untextured materials. For performance
                reasons, color precision is also lower when using the Mobile rendering method
                compared to Forward+.</paragraph>
            <paragraph>When using the Compatibility rendering method, HDR is not used and the color
                precision is the lowest of all rendering methods. This also applies to 2D
                rendering, where banding may be visible when using smooth gradient textures.</paragraph>
            <paragraph>There are two main ways to alleviate banding:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>If using the Forward+ or Forward Mobile rendering methods, enable
                        <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-rendering-anti-aliasing-quality-use-debanding"><inline classes="std std-ref">Use Debanding</inline></reference>
                        in <strong>Project Settings &gt; Rendering &gt; Anti Aliasing</strong>. This applies a fullscreen debanding
                        shader as a post-processing effect and is very cheap.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Alternatively, bake some noise into your textures. This is mainly effective in
                        2D, e.g. for vignetting effects. In 3D, you can also use a <reference name="custom debanding shader" refuri="https://github.com/fractilegames/godot-gles2-debanding-material">custom debanding
                            shader</reference> to
                        be applied on your <emphasis>materials</emphasis>. This technique works even if your project is
                        rendered with low color precision, which means it will work when using the
                        Mobile and Compatibility rendering methods.</paragraph>
                </list_item>
            </bullet_list>
            <figure align="center" ids="id1">
                <image alt="Color banding comparison (contrast increased for more visibility)" candidates="{'*': 'tutorials/3d/img/3d_rendering_limitations_banding.webp'}" original_uri="img/3d_rendering_limitations_banding.webp" uri="tutorials/3d/img/3d_rendering_limitations_banding.webp"></image>
                <caption>Color banding comparison (contrast increased for more visibility)</caption>
            </figure>
            <seealso>
                <paragraph>See <reference name="Banding in Games: A Noisy Rant (PDF)" refuri="https://loopit.dk/banding_in_games.pdf">Banding in Games: A Noisy Rant (PDF)</reference>
                    for more details about banding and ways to combat it.</paragraph>
            </seealso>
        </section>
        <section ids="depth-buffer-precision" names="depth\ buffer\ precision">
            <title>Depth buffer precision</title>
            <paragraph>To sort objects in 3D space, rendering engines rely on a <emphasis>depth buffer</emphasis> (also
                called <emphasis>Z-buffer</emphasis>). This buffer has a finite precision: 24-bit on desktop
                platforms, sometimes 16-bit on mobile platforms (for performance reasons). If
                two different objects end up on the same buffer value, then Z-fighting will
                occur. This will materialize as textures flickering back and forth as the camera
                moves or rotates.</paragraph>
            <paragraph>To make the depth buffer more precise over the rendered area, you should
                <emphasis>increase</emphasis> the Camera node's <strong>Near</strong> property. However, be careful: if you set
                it too high, players will be able to see through nearby geometry. You should
                also <emphasis>decrease</emphasis> the Camera node's <strong>Far</strong> property to the lowest permissible value
                for your use case, though keep in mind it won't impact precision as much as the
                <strong>Near</strong> property.</paragraph>
            <paragraph>If you only need high precision when the player can see far away, you could
                change it dynamically based on the game conditions. For instance, if the player
                enters an airplane, the <strong>Near</strong> property can be temporarily increased to avoid
                Z-fighting in the distance. It can then be decreased once the player leaves the
                airplane.</paragraph>
            <paragraph>Depending on the scene and viewing conditions, you may also be able to move the
                Z-fighting objects further apart without the difference being visible to the
                player.</paragraph>
            <figure align="center" ids="id2">
                <image alt="Z-fighting comparison (before and after tweaking the scene by offsetting the Label3D away from the floor)" candidates="{'*': 'tutorials/3d/img/3d_rendering_limitations_z_fighting.webp'}" original_uri="img/3d_rendering_limitations_z_fighting.webp" uri="tutorials/3d/img/3d_rendering_limitations_z_fighting.webp"></image>
                <caption>Z-fighting comparison (before and after tweaking the scene by offsetting the Label3D away from the floor)</caption>
            </figure>
            <target refid="doc-3d-rendering-limitations-transparency-sorting"></target>
        </section>
        <section ids="transparency-sorting doc-3d-rendering-limitations-transparency-sorting" names="transparency\ sorting doc_3d_rendering_limitations_transparency_sorting">
            <title>Transparency sorting</title>
            <paragraph>In Godot, transparent materials are drawn after opaque materials. Transparent
                objects are sorted back to front before being drawn based on the Node3D's
                position, not the vertex position in world space. Due to this, overlapping
                objects may often be sorted out of order. To fix improperly sorted objects,
                tweak the material's
                <reference internal="True" refuri="../../classes/class_material#class-material-property-render-priority"><inline classes="std std-ref">Render Priority</inline></reference>
                property or the node's
                <reference internal="True" refuri="../../classes/class_visualinstance3d#class-visualinstance3d-property-sorting-offset"><inline classes="std std-ref">Sorting Offset</inline></reference>.
                Render Priority will force specific materials to appear in front of or behind
                other transparent materials, while Sorting Offset will move the object
                forward or backward for the purpose of sorting. Even then, these may not
                always be sufficient.</paragraph>
            <paragraph>Some rendering engines feature <emphasis>order-independent transparency</emphasis> techniques to
                alleviate this, but this is costly on the GPU. Godot currently doesn't provide
                this feature. There are still several ways to avoid this problem:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Only make materials transparent if you actually need it. If a material only
                        has a small transparent part, consider splitting it into a separate material.
                        This will allow the opaque part to cast shadows and will also improve performance.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If your texture mostly has fully opaque and fully transparent areas, you can
                        use alpha testing instead of alpha blending. This transparency mode is faster
                        to render and doesn't suffer from transparency issues. Enable <strong>Transparency &gt;
                            Transparency</strong> to <strong>Alpha Scissor</strong> in StandardMaterial3D, and adjust
                        <strong>Transparency &gt; Alpha Scissor Threshold</strong> accordingly if needed. Note that
                        MSAA will not antialias the texture's edges unless alpha antialiasing is
                        enabled in the material's properties. However, FXAA, TAA and supersampling
                        will be able to antialias the texture's edges regardless of whether alpha
                        antialiasing is enabled on the material.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If you need to render semi-transparent areas of the texture, alpha scissor
                        isn't suitable. Instead, setting the StandardMaterial3D's
                        <strong>Transparency &gt; Transparency</strong> property to <strong>Depth Pre-Pass</strong> can sometimes
                        work (at a performance cost). You can also try the <strong>Alpha Hash</strong> mode.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If you want a material to fade with distance, use the StandardMaterial3D
                        distance fade mode <strong>Pixel Dither</strong> or <strong>Object Dither</strong> instead of
                        <strong>Pixel Alpha</strong>. This will make the material opaque, which also speeds up rendering.</paragraph>
                </list_item>
            </bullet_list>
            <figure align="center" ids="id3">
                <image alt="Transparency sorting comparison (alpha-blended materials on the left, alpha scissor materials on the right)" candidates="{'*': 'tutorials/3d/img/3d_rendering_limitations_transparency_sorting.webp'}" original_uri="img/3d_rendering_limitations_transparency_sorting.webp" uri="tutorials/3d/img/3d_rendering_limitations_transparency_sorting.webp"></image>
                <caption>Transparency sorting comparison (alpha-blended materials on the left, alpha scissor materials on the right)</caption>
            </figure>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
