<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/using_multiple_threads.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-multiple-threads"></target>
    <section ids="using-multiple-threads doc-using-multiple-threads" names="using\ multiple\ threads 使用多线程 doc_using_multiple_threads">
        <title>使用多线程</title>
        <section ids="threads" names="threads 线程">
            <title>线程</title>
            <paragraph>线程允许同时执行代码。它允许从主线程卸载工作。</paragraph>
            <paragraph>Godot 支持线程，并提供了许多方便使用的功能。</paragraph>
            <note>
                <paragraph>如果使用其他语言（C#、C++），它们支持的线程类可能会更容易使用。</paragraph>
            </note>
            <warning>
                <paragraph>在线程中使用内置类之前，请先阅读 <reference internal="True" refuri="thread_safe_apis#doc-thread-safe-apis"><inline classes="std std-ref">线程安全的 API</inline></reference>，检查在线程中使用是否安全。</paragraph>
            </warning>
        </section>
        <section ids="creating-a-thread" names="creating\ a\ thread 创建线程">
            <title>创建线程</title>
            <paragraph>创建线程请使用如下代码：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var thread: Thread

# The thread will start here.
func _ready():
    thread = Thread.new()
    # You can bind multiple arguments to a function Callable.
    thread.start(_thread_function.bind("Wafflecopter"))


# Run here and exit.
# The argument is the bound data passed from start().
func _thread_function(userdata):
    # Print the userdata ("Wafflecopter")
    print("I'm a thread! Userdata is: ", userdata)


# Thread must be disposed (or "joined"), for portability.
func _exit_tree():
    thread.wait_to_finish()</literal_block>
                </div>
            </container>
            <paragraph>然后, 你的函数将在一个单独的线程中运行, 直到它返回. 即使函数已经返回, 线程也必须收集它, 所以调用 <reference internal="True" refuri="../../classes/class_thread#class-thread-method-wait-to-finish"><inline classes="std std-ref">Thread.wait_to_finish()</inline></reference> , 它将等待线程完成(如果还没有完成), 然后妥善处理它.</paragraph>
            <warning>
                <paragraph>在Windows上，在执行时间建立线程速度很慢，应该避免，以防止卡顿出现。应改用信号量（本页稍后将对此进行解释）。</paragraph>
            </warning>
        </section>
        <section ids="mutexes" names="mutexes mutex">
            <title>Mutex</title>
            <paragraph>并不总是支持从多个线程访问对象或数据(如果你这样做, 会导致意外行为或崩溃). 请阅读 <reference internal="True" refuri="thread_safe_apis#doc-thread-safe-apis"><inline classes="std std-ref">线程安全的 API</inline></reference> 文档, 了解哪些引擎API支持多线程访问.</paragraph>
            <paragraph>在处理自己的数据或调用自己的函数时, 通常情况下, 尽量避免从不同的线程直接访问相同的数据. 你可能会遇到同步问题, 因为数据被修改后,CPU核之间并不总是更新. 当从不同线程访问一个数据时, 一定要使用 <reference internal="True" refuri="../../classes/class_mutex#class-mutex"><inline classes="std std-ref">Mutex</inline></reference> .</paragraph>
            <paragraph>当调用 <reference internal="True" refuri="../../classes/class_mutex#class-mutex-method-lock"><inline classes="std std-ref">Mutex.lock()</inline></reference> 时, 一个线程确保所有其他线程如果试图 <emphasis>锁</emphasis> 同一个mutex, 就会被阻塞(进入暂停状态). 当通过调用 <reference internal="True" refuri="../../classes/class_mutex#class-mutex-method-unlock"><inline classes="std std-ref">Mutex.unlock()</inline></reference> 来解锁该mutex时, 其他线程将被允许继续锁定(但每次只能锁定一个).</paragraph>
            <paragraph>下面是一个使用 Mutex 的例子:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var counter := 0
var mutex: Mutex
var thread: Thread


# The thread will start here.
func _ready():
    mutex = Mutex.new()
    thread = Thread.new()
    thread.start(_thread_function)

    # Increase value, protect it with Mutex.
    mutex.lock()
    counter += 1
    mutex.unlock()


# Increment the value from the thread, too.
func _thread_function():
    mutex.lock()
    counter += 1
    mutex.unlock()


# Thread must be disposed (or "joined"), for portability.
func _exit_tree():
    thread.wait_to_finish()
    print("Counter is: ", counter) # Should be 2.</literal_block>
                </div>
            </container>
        </section>
        <section ids="semaphores" names="semaphores semaphore">
            <title>Semaphore</title>
            <paragraph>有时你希望你的线程能“按需”工作。换句话说，告诉它什么时候工作，让它在不工作的时候暂停。为此，可以使用信号量 <reference internal="True" refuri="../../classes/class_semaphore#class-semaphore"><inline classes="std std-ref">Semaphore</inline></reference>。线程中使用函数 <reference internal="True" refuri="../../classes/class_semaphore#class-semaphore-method-wait"><inline classes="std std-ref">Semaphore.wait()</inline></reference> 来暂停它的工作，直到有数据到达。</paragraph>
            <paragraph>而主线程则使用 <reference internal="True" refuri="../../classes/class_semaphore#class-semaphore-method-post"><inline classes="std std-ref">Semaphore.post()</inline></reference> 来表示数据已经准备好被处理:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var counter := 0
var mutex: Mutex
var semaphore: Semaphore
var thread: Thread
var exit_thread := false


# The thread will start here.
func _ready():
    mutex = Mutex.new()
    semaphore = Semaphore.new()
    exit_thread = false

    thread = Thread.new()
    thread.start(_thread_function)


func _thread_function():
    while true:
        semaphore.wait() # Wait until posted.

        mutex.lock()
        var should_exit = exit_thread # Protect with Mutex.
        mutex.unlock()

        if should_exit:
            break

        mutex.lock()
        counter += 1 # Increment counter, protect with Mutex.
        mutex.unlock()


func increment_counter():
    semaphore.post() # Make the thread process.


func get_counter():
    mutex.lock()
    # Copy counter, protect with Mutex.
    var counter_value = counter
    mutex.unlock()
    return counter_value


# Thread must be disposed (or "joined"), for portability.
func _exit_tree():
    # Set exit condition to true.
    mutex.lock()
    exit_thread = true # Protect with Mutex.
    mutex.unlock()

    # Unblock by posting.
    semaphore.post()

    # Wait until it exits.
    thread.wait_to_finish()

    # Print the counter.
    print("Counter is: ", counter)</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
