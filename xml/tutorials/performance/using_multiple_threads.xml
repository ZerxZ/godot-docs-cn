<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/using_multiple_threads.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-multiple-threads"></target>
    <section ids="using-multiple-threads doc-using-multiple-threads" names="using\ multiple\ threads doc_using_multiple_threads">
        <title>Using multiple threads</title>
        <seealso>
            <paragraph>For a list of multithreading primitives in C++, see <reference internal="True" refuri="../../engine_details/architecture/core_types#doc-core-concurrency-types"><inline classes="std std-ref">Multithreading / Concurrency</inline></reference>.</paragraph>
        </seealso>
        <section ids="threads" names="threads">
            <title>Threads</title>
            <paragraph>Threads allow simultaneous execution of code. It allows off-loading work
                from the main thread.</paragraph>
            <paragraph>Godot supports threads and provides many handy functions to use them.</paragraph>
            <note>
                <paragraph>If using other languages (C#, C++), it may be easier to use the
                    threading classes they support.</paragraph>
            </note>
            <warning>
                <paragraph>Before using a built-in class in a thread, read <reference internal="True" refuri="thread_safe_apis#doc-thread-safe-apis"><inline classes="std std-ref">Thread-safe APIs</inline></reference>
                    first to check whether it can be safely used in a thread.</paragraph>
            </warning>
        </section>
        <section ids="creating-a-thread" names="creating\ a\ thread">
            <title>Creating a Thread</title>
            <paragraph>To create a thread, use the following code:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QysrIC5IIEZpbGU=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QysrIC5IIEZpbGU=" name="QysrIC5IIEZpbGU=" role="tab" tabindex="-1">C++ .H File</button>
                    <button aria-controls="panel-0-QysrIC5DUFAgRmlsZQ==" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QysrIC5DUFAgRmlsZQ==" name="QysrIC5DUFAgRmlsZQ==" role="tab" tabindex="-1">C++ .CPP File</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var thread: Thread

# The thread will start here.
func _ready():
    thread = Thread.new()
    # You can bind multiple arguments to a function Callable.
    thread.start(_thread_function.bind("Wafflecopter"))


# Run here and exit.
# The argument is the bound data passed from start().
func _thread_function(userdata):
    # Print the userdata ("Wafflecopter")
    print("I'm a thread! Userdata is: ", userdata)


# Thread must be disposed (or "joined"), for portability.
func _exit_tree():
    thread.wait_to_finish()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QysrIC5IIEZpbGU=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QysrIC5IIEZpbGU=" name="QysrIC5IIEZpbGU=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#pragma once

#include &lt;godot_cpp/classes/node.hpp&gt;
#include &lt;godot_cpp/classes/thread.hpp&gt;

namespace godot {
    class MultithreadingDemo : public Node {
        GDCLASS(MultithreadingDemo, Node);

    private:
        Ref&lt;Thread&gt; worker;

    protected:
        static void _bind_methods();
        void _notification(int p_what);

    public:
        MultithreadingDemo();
        ~MultithreadingDemo();

        void demo_threaded_function();
    };
} // namespace godot</literal_block>
                </div>
                <div aria-labelledby="tab-0-QysrIC5DUFAgRmlsZQ==" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QysrIC5DUFAgRmlsZQ==" name="QysrIC5DUFAgRmlsZQ==" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "multithreading_demo.h"

#include &lt;godot_cpp/classes/engine.hpp&gt;
#include &lt;godot_cpp/classes/os.hpp&gt;
#include &lt;godot_cpp/classes/time.hpp&gt;
#include &lt;godot_cpp/core/class_db.hpp&gt;
#include &lt;godot_cpp/variant/utility_functions.hpp&gt;

using namespace godot;

void MultithreadingDemo::_bind_methods() {
    ClassDB::bind_method(D_METHOD("threaded_function"), &amp;MultithreadingDemo::demo_threaded_function);
}

void MultithreadingDemo::_notification(int p_what) {
    // Prevents this from running in the editor, only during game mode. In Godot 4.3+ use Runtime classes.
    if (Engine::get_singleton()-&gt;is_editor_hint()) {
        return;
    }

    switch (p_what) {
        case NOTIFICATION_READY: {
            worker.instantiate();
            worker-&gt;start(callable_mp(this, &amp;MultithreadingDemo::demo_threaded_function), Thread::PRIORITY_NORMAL);
        } break;
        case NOTIFICATION_EXIT_TREE: { // Thread must be disposed (or "joined"), for portability.
            // Wait until it exits.
            if (worker.is_valid()) {
                worker-&gt;wait_to_finish();
            }

            worker.unref();
        } break;
    }
}

MultithreadingDemo::MultithreadingDemo() {
    // Initialize any variables here.
}

MultithreadingDemo::~MultithreadingDemo() {
    // Add your cleanup here.
}

void MultithreadingDemo::demo_threaded_function() {
    UtilityFunctions::print("demo_threaded_function started!");
    int i = 0;
    uint64_t start = Time::get_singleton()-&gt;get_ticks_msec();
    while (Time::get_singleton()-&gt;get_ticks_msec() - start &lt; 5000) {
        OS::get_singleton()-&gt;delay_msec(10);
        i++;
    }

    UtilityFunctions::print("demo_threaded_function counted to: ", i, ".");
}</literal_block>
                </div>
            </container>
            <paragraph>Your function will, then, run in a separate thread until it returns.
                Even if the function has returned already, the thread must collect it, so call
                <reference internal="True" refuri="../../classes/class_thread#class-thread-method-wait-to-finish"><inline classes="std std-ref">Thread.wait_to_finish()</inline></reference>, which will
                wait until the thread is done (if not done yet), then properly dispose of it.</paragraph>
            <warning>
                <paragraph>Creating threads is a slow operation, especially on Windows. To avoid
                    unnecessary performance overhead, make sure to create threads before heavy
                    processing is needed instead of creating threads just-in-time.</paragraph>
                <paragraph>For example, if you need multiple threads during gameplay, you can create
                    threads while the level is loading and only actually start processing with
                    them later on.</paragraph>
                <paragraph>Additionally, locking and unlocking of mutexes can also be an expensive
                    operation. Locking should be done carefully; avoid locking too often (or for
                    too long).</paragraph>
            </warning>
            <target refid="doc-using-multiple-threads-mutexes"></target>
        </section>
        <section ids="mutexes doc-using-multiple-threads-mutexes" names="mutexes doc_using_multiple_threads_mutexes">
            <title>Mutexes</title>
            <paragraph>Accessing objects or data from multiple threads is not always supported (if you
                do it, it will cause unexpected behaviors or crashes). Read the
                <reference internal="True" refuri="thread_safe_apis#doc-thread-safe-apis"><inline classes="std std-ref">Thread-safe APIs</inline></reference> documentation to understand which engine APIs
                support multiple thread access.</paragraph>
            <paragraph>When processing your own data or calling your own functions, as a rule, try to
                avoid accessing the same data directly from different threads. You may run into
                synchronization problems, as the data is not always updated between CPU cores
                when modified. Always use a <reference internal="True" refuri="../../classes/class_mutex#class-mutex"><inline classes="std std-ref">Mutex</inline></reference> when accessing
                a piece of data from different threads.</paragraph>
            <paragraph>When calling <reference internal="True" refuri="../../classes/class_mutex#class-mutex-method-lock"><inline classes="std std-ref">Mutex.lock()</inline></reference>, a thread ensures that
                all other threads will be blocked (put on suspended state) if they try to <emphasis>lock</emphasis>
                the same mutex. When the mutex is unlocked by calling
                <reference internal="True" refuri="../../classes/class_mutex#class-mutex-method-unlock"><inline classes="std std-ref">Mutex.unlock()</inline></reference>, the other threads will be
                allowed to proceed with the lock (but only one at a time).</paragraph>
            <paragraph>Here is an example of using a Mutex:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QysrIC5IIEZpbGU=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QysrIC5IIEZpbGU=" name="QysrIC5IIEZpbGU=" role="tab" tabindex="-1">C++ .H File</button>
                    <button aria-controls="panel-1-QysrIC5DUFAgRmlsZQ==" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QysrIC5DUFAgRmlsZQ==" name="QysrIC5DUFAgRmlsZQ==" role="tab" tabindex="-1">C++ .CPP File</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var counter := 0
var mutex: Mutex
var thread: Thread


# The thread will start here.
func _ready():
    mutex = Mutex.new()
    thread = Thread.new()
    thread.start(_thread_function)

    # Increase value, protect it with Mutex.
    mutex.lock()
    counter += 1
    mutex.unlock()


# Increment the value from the thread, too.
func _thread_function():
    mutex.lock()
    counter += 1
    mutex.unlock()


# Thread must be disposed (or "joined"), for portability.
func _exit_tree():
    thread.wait_to_finish()
    print("Counter is: ", counter) # Should be 2.</literal_block>
                </div>
                <div aria-labelledby="tab-1-QysrIC5IIEZpbGU=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QysrIC5IIEZpbGU=" name="QysrIC5IIEZpbGU=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#pragma once

#include &lt;godot_cpp/classes/mutex.hpp&gt;
#include &lt;godot_cpp/classes/node.hpp&gt;
#include &lt;godot_cpp/classes/thread.hpp&gt;

namespace godot {
    class MutexDemo : public Node {
        GDCLASS(MutexDemo, Node);

    private:
        int counter = 0;
        Ref&lt;Mutex&gt; mutex;
        Ref&lt;Thread&gt; thread;

    protected:
        static void _bind_methods();
        void _notification(int p_what);

    public:
        MutexDemo();
        ~MutexDemo();

        void thread_function();
    };
} // namespace godot</literal_block>
                </div>
                <div aria-labelledby="tab-1-QysrIC5DUFAgRmlsZQ==" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QysrIC5DUFAgRmlsZQ==" name="QysrIC5DUFAgRmlsZQ==" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "mutex_demo.h"

#include &lt;godot_cpp/classes/engine.hpp&gt;
#include &lt;godot_cpp/classes/time.hpp&gt;
#include &lt;godot_cpp/core/class_db.hpp&gt;
#include &lt;godot_cpp/variant/utility_functions.hpp&gt;

using namespace godot;

void MutexDemo::_bind_methods() {
    ClassDB::bind_method(D_METHOD("thread_function"), &amp;MutexDemo::thread_function);
}

void MutexDemo::_notification(int p_what) {
    // Prevents this from running in the editor, only during game mode.
    if (Engine::get_singleton()-&gt;is_editor_hint()) {
        return;
    }

    switch (p_what) {
        case NOTIFICATION_READY: {
            UtilityFunctions::print("Mutex Demo Counter is starting at: ", counter);
            mutex.instantiate();
            thread.instantiate();
            thread-&gt;start(callable_mp(this, &amp;MutexDemo::thread_function), Thread::PRIORITY_NORMAL);

            // Increase value, protect it with Mutex.
            mutex-&gt;lock();
            counter += 1;
            UtilityFunctions::print("Mutex Demo Counter is ", counter, " after adding with Mutex protection.");
            mutex-&gt;unlock();
        } break;
        case NOTIFICATION_EXIT_TREE: { // Thread must be disposed (or "joined"), for portability.
            // Wait until it exits.
            if (thread.is_valid()) {
                thread-&gt;wait_to_finish();
            }
            thread.unref();

            UtilityFunctions::print("Mutex Demo Counter is ", counter, " at EXIT_TREE."); // Should be 2.
        } break;
    }
}

MutexDemo::MutexDemo() {
    // Initialize any variables here.
}

MutexDemo::~MutexDemo() {
    // Add your cleanup here.
}

// Increment the value from the thread, too.
void MutexDemo::thread_function() {
    mutex-&gt;lock();
    counter += 1;
    mutex-&gt;unlock();
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="semaphores" names="semaphores">
            <title>Semaphores</title>
            <paragraph>Sometimes you want your thread to work <emphasis>"on demand"</emphasis>. In other words, tell it
                when to work and let it suspend when it isn't doing anything.
                For this, <reference internal="True" refuri="../../classes/class_semaphore#class-semaphore"><inline classes="std std-ref">Semaphores</inline></reference> are used. The function
                <reference internal="True" refuri="../../classes/class_semaphore#class-semaphore-method-wait"><inline classes="std std-ref">Semaphore.wait()</inline></reference> is used in the thread to
                suspend it until some data arrives.</paragraph>
            <paragraph>The main thread, instead, uses
                <reference internal="True" refuri="../../classes/class_semaphore#class-semaphore-method-post"><inline classes="std std-ref">Semaphore.post()</inline></reference> to signal that data is
                ready to be processed:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QysrIC5IIEZpbGU=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QysrIC5IIEZpbGU=" name="QysrIC5IIEZpbGU=" role="tab" tabindex="-1">C++ .H File</button>
                    <button aria-controls="panel-2-QysrIC5DUFAgRmlsZQ==" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QysrIC5DUFAgRmlsZQ==" name="QysrIC5DUFAgRmlsZQ==" role="tab" tabindex="-1">C++ .CPP File</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var counter := 0
var mutex: Mutex
var semaphore: Semaphore
var thread: Thread
var exit_thread := false


# The thread will start here.
func _ready():
    mutex = Mutex.new()
    semaphore = Semaphore.new()
    exit_thread = false

    thread = Thread.new()
    thread.start(_thread_function)


func _thread_function():
    while true:
        semaphore.wait() # Wait until posted.

        mutex.lock()
        var should_exit = exit_thread # Protect with Mutex.
        mutex.unlock()

        if should_exit:
            break

        mutex.lock()
        counter += 1 # Increment counter, protect with Mutex.
        mutex.unlock()


func increment_counter():
    semaphore.post() # Make the thread process.


func get_counter():
    mutex.lock()
    # Copy counter, protect with Mutex.
    var counter_value = counter
    mutex.unlock()
    return counter_value


# Thread must be disposed (or "joined"), for portability.
func _exit_tree():
    # Set exit condition to true.
    mutex.lock()
    exit_thread = true # Protect with Mutex.
    mutex.unlock()

    # Unblock by posting.
    semaphore.post()

    # Wait until it exits.
    thread.wait_to_finish()

    # Print the counter.
    print("Counter is: ", counter)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QysrIC5IIEZpbGU=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QysrIC5IIEZpbGU=" name="QysrIC5IIEZpbGU=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#pragma once

#include &lt;godot_cpp/classes/mutex.hpp&gt;
#include &lt;godot_cpp/classes/node.hpp&gt;
#include &lt;godot_cpp/classes/semaphore.hpp&gt;
#include &lt;godot_cpp/classes/thread.hpp&gt;

namespace godot {
    class SemaphoreDemo : public Node {
        GDCLASS(SemaphoreDemo, Node);

    private:
        int counter = 0;
        Ref&lt;Mutex&gt; mutex;
        Ref&lt;Semaphore&gt; semaphore;
        Ref&lt;Thread&gt; thread;
        bool exit_thread = false;

    protected:
        static void _bind_methods();
        void _notification(int p_what);

    public:
        SemaphoreDemo();
        ~SemaphoreDemo();

        void thread_function();
        void increment_counter();
        int get_counter();
    };
} // namespace godot</literal_block>
                </div>
                <div aria-labelledby="tab-2-QysrIC5DUFAgRmlsZQ==" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QysrIC5DUFAgRmlsZQ==" name="QysrIC5DUFAgRmlsZQ==" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "semaphore_demo.h"

#include &lt;godot_cpp/classes/engine.hpp&gt;
#include &lt;godot_cpp/classes/time.hpp&gt;
#include &lt;godot_cpp/core/class_db.hpp&gt;
#include &lt;godot_cpp/variant/utility_functions.hpp&gt;

using namespace godot;

void SemaphoreDemo::_bind_methods() {
    ClassDB::bind_method(D_METHOD("thread_function"), &amp;SemaphoreDemo::thread_function);
}

void SemaphoreDemo::_notification(int p_what) {
    // Prevents this from running in the editor, only during game mode.
    if (Engine::get_singleton()-&gt;is_editor_hint()) {
        return;
    }

    switch (p_what) {
        case NOTIFICATION_READY: {
            UtilityFunctions::print("Semaphore Demo Counter is starting at: ", counter);
            mutex.instantiate();
            semaphore.instantiate();
            exit_thread = false;

            thread.instantiate();
            thread-&gt;start(callable_mp(this, &amp;SemaphoreDemo::thread_function), Thread::PRIORITY_NORMAL);

            increment_counter(); // Call increment counter to test.
        } break;
        case NOTIFICATION_EXIT_TREE: { // Thread must be disposed (or "joined"), for portability.
            // Set exit condition to true.
            mutex-&gt;lock();
            exit_thread = true; // Protect with Mutex.
            mutex-&gt;unlock();

            // Unblock by posting.
            semaphore-&gt;post();

            // Wait until it exits.
            if (thread.is_valid()) {
                thread-&gt;wait_to_finish();
            }
            thread.unref();

            // Print the counter.
            UtilityFunctions::print("Semaphore Demo Counter is ", get_counter(),  " at EXIT_TREE.");
        } break;
    }
}

SemaphoreDemo::SemaphoreDemo() {
    // Initialize any variables here.
}

SemaphoreDemo::~SemaphoreDemo() {
    // Add your cleanup here.
}

// Increment the value from the thread, too.
void SemaphoreDemo::thread_function() {
    while (true) {
        semaphore-&gt;wait(); // Wait until posted.

        mutex-&gt;lock();
        bool should_exit = exit_thread; // Protect with Mutex.
        mutex-&gt;unlock();

        if (should_exit) {
            break;
        }

        mutex-&gt;lock();
        counter += 1; // Increment counter, protect with Mutex.
        mutex-&gt;unlock();
    }
}

void SemaphoreDemo::increment_counter() {
    semaphore-&gt;post(); // Make the thread process.
}

int SemaphoreDemo::get_counter() {
    mutex-&gt;lock();
    // Copy counter, protect with Mutex.
    int counter_value = counter;
    mutex-&gt;unlock();
    return counter_value;
}</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
