<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/using_multimesh.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-multimesh"></target>
    <section ids="optimization-using-multimeshes doc-using-multimesh" names="optimization\ using\ multimeshes 使用\ multimesh\ 优化 doc_using_multimesh">
        <title>使用 MultiMesh 优化</title>
        <paragraph>对于大量的实例(成千上万), 需要不断处理(需要保留一定的控制), 建议优化 <reference internal="True" refuri="using_servers#doc-using-servers"><inline classes="std std-ref">直接使用服务</inline></reference> .</paragraph>
        <paragraph>当对象数量达到数十万或数百万时, 这些方法都不再有效. 尽管如此, 根据要求, 还有另一种可能的优化方法.</paragraph>
        <section ids="multimeshes" names="multimeshes multimesh">
            <title>MultiMesh</title>
            <paragraph><reference internal="True" refuri="../../classes/class_multimesh#class-multimesh"><inline classes="std std-ref">MultiMesh</inline></reference> 是一个单次绘制的图元，可以一次性绘制多达数百万个对象。它的效率非常高，因为它使用 GPU 硬件来做这件事（不过在 OpenGL ES 2.0 中，它的效率较低，因为没有硬件支持）。</paragraph>
            <paragraph>唯一的缺点是, 对于单个实例, 不可能进行 <emphasis>屏幕</emphasis> 或 <emphasis>视锥</emphasis> 剔除. 这意味着, 根据整个MultiMesh的可见性, 数百万个对象将被 <emphasis>始终</emphasis> 或 <emphasis>不会</emphasis> 绘制. 可以为它们提供一个自定义的可见性矩形, 但它将始终是 <emphasis>全或无</emphasis> 的可见性.</paragraph>
            <paragraph>如果对象足够简单(只有几个顶点), 这通常不是什么大问题, 因为大多数现代GPU都为这种用例进行了优化. 一个变通的方法是为世界的不同区域创建多个MultiMeshes.</paragraph>
            <paragraph>也可以在顶点着色器中执行一些逻辑(使用 <literal>INSTANCE_ID</literal> 或 <literal>INSTANCE_CUSTOM</literal> 内置常量). 关于在MultiMesh中对数千个对象进行动画制作的例子, 请参见 <reference internal="True" refuri="vertex_animation/animating_thousands_of_fish#doc-animating-thousands-of-fish"><inline classes="std std-ref">Animating thousands of fish</inline></reference> 教程. 可以通过纹理向着色器提供信息(有浮点 <reference internal="True" refuri="../../classes/class_image#class-image"><inline classes="std std-ref">Image</inline></reference> 格式是理想的格式).</paragraph>
            <paragraph>Another alternative is to use a GDExtension and C++, which should be extremely efficient (it's possible
                to set the entire state for all objects using linear memory via the
                <reference internal="True" refuri="../../classes/class_renderingserver#class-renderingserver-method-multimesh-set-buffer"><inline classes="std std-ref">RenderingServer.multimesh_set_buffer()</inline></reference>
                function). This way, the array can be created with multiple threads, then set in one call, providing
                high cache efficiency.</paragraph>
            <paragraph>最后, 并不是所有的MultiMesh实例都必须是可见的. 可以通过 <reference internal="True" refuri="../../classes/class_multimesh#class-multimesh-property-visible-instance-count"><inline classes="std std-ref">MultiMesh.visible_instance_count</inline></reference> 属性来控制可见的数量. 典型的工作流程是先分配最大数量的实例, 然后根据当前需要的数量改变可见的数量.</paragraph>
        </section>
        <section ids="multimesh-example" names="multimesh\ example 多重网格示例">
            <title>多重网格示例</title>
            <paragraph>这里是一个从代码中使用MultiMesh的例子.GDScript以外的其他语言对于数百万个对象来说可能更有效, 但对于几千个对象来说,GDScript应该是可以的.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends MultiMeshInstance3D


func _ready():
    # Create the multimesh.
    multimesh = MultiMesh.new()
    # Set the format first.
    multimesh.transform_format = MultiMesh.TRANSFORM_3D
    # Then resize (otherwise, changing the format is not allowed).
    multimesh.instance_count = 10000
    # Maybe not all of them should be visible at first.
    multimesh.visible_instance_count = 1000

    # Set the transform of the instances.
    for i in multimesh.visible_instance_count:
        multimesh.set_instance_transform(i, Transform3D(Basis(), Vector3(i * 20, 0, 0)))</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyMultiMeshInstance3D : MultiMeshInstance3D
{
    public override void _Ready()
    {
        // Create the multimesh.
        Multimesh = new MultiMesh();
        // Set the format first.
        Multimesh.TransformFormat = MultiMesh.TransformFormatEnum.Transform3D;
        // Then resize (otherwise, changing the format is not allowed)
        Multimesh.InstanceCount = 1000;
        // Maybe not all of them should be visible at first.
        Multimesh.VisibleInstanceCount = 1000;

        // Set the transform of the instances.
        for (int i = 0; i &lt; Multimesh.VisibleInstanceCount; i++)
        {
            Multimesh.SetInstanceTransform(i, new Transform3D(Basis.Identity, new Vector3(i * 20, 0, 0)));
        }
    }
}</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
