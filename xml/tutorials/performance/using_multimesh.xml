<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/using_multimesh.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-multimesh"></target>
    <section ids="optimization-using-multimeshes doc-using-multimesh" names="optimization\ using\ multimeshes doc_using_multimesh">
        <title>Optimization using MultiMeshes</title>
        <paragraph>For large amount of instances (in the thousands), that need to be constantly processed
            (and certain amount of control needs to be retained),
            <reference internal="True" refuri="using_servers#doc-using-servers"><inline classes="std std-ref">using servers directly</inline></reference> is the recommended optimization.</paragraph>
        <paragraph>When the amount of objects reach the hundreds of thousands or millions,
            none of these approaches are efficient anymore. Still, depending on the requirements, there
            is one more optimization possible.</paragraph>
        <section ids="multimeshes" names="multimeshes">
            <title>MultiMeshes</title>
            <paragraph>A <reference internal="True" refuri="../../classes/class_multimesh#class-multimesh"><inline classes="std std-ref">MultiMesh</inline></reference> is a single draw primitive that can draw up to millions
                of objects in one go. It's extremely efficient because it uses the GPU hardware to do this.</paragraph>
            <paragraph>The only drawback is that there is no <emphasis>screen</emphasis> or <emphasis>frustum</emphasis> culling possible for individual instances.
                This means, that millions of objects will be <emphasis>always</emphasis> or <emphasis>never</emphasis> drawn, depending on the visibility
                of the whole MultiMesh. It is possible to provide a custom visibility rect for them, but it will always
                be <emphasis>all-or-none</emphasis> visibility.</paragraph>
            <paragraph>If the objects are simple enough (just a couple of vertices), this is generally not much of a problem
                as most modern GPUs are optimized for this use case. A workaround is to create several MultiMeshes
                for different areas of the world.</paragraph>
            <paragraph>It is also possible to execute some logic inside the vertex shader (using the <literal>INSTANCE_ID</literal> or
                <literal>INSTANCE_CUSTOM</literal> built-in constants). For an example of animating thousands of objects in a MultiMesh,
                see the <reference internal="True" refuri="vertex_animation/animating_thousands_of_fish#doc-animating-thousands-of-fish"><inline classes="std std-ref">Animating thousands of fish</inline></reference> tutorial. Information
                to the shader can be provided via textures (there are floating-point <reference internal="True" refuri="../../classes/class_image#class-image"><inline classes="std std-ref">Image</inline></reference> formats
                which are ideal for this).</paragraph>
            <paragraph>Another alternative is to use a GDExtension and C++, which should be extremely efficient (it's possible
                to set the entire state for all objects using linear memory via the
                <reference internal="True" refuri="../../classes/class_renderingserver#class-renderingserver-method-multimesh-set-buffer"><inline classes="std std-ref">RenderingServer.multimesh_set_buffer()</inline></reference>
                function). This way, the array can be created with multiple threads, then set in one call, providing
                high cache efficiency.</paragraph>
            <paragraph>Finally, it's not required to have all MultiMesh instances visible. The amount of visible ones can be
                controlled with the <reference internal="True" refuri="../../classes/class_multimesh#class-multimesh-property-visible-instance-count"><inline classes="std std-ref">MultiMesh.visible_instance_count</inline></reference>
                property. The typical workflow is to allocate the maximum amount of instances that will be used,
                then change the amount visible depending on how many are currently needed.</paragraph>
        </section>
        <section ids="multimesh-example" names="multimesh\ example">
            <title>Multimesh example</title>
            <paragraph>Here is an example of using a MultiMesh from code. Languages other than GDScript may be more
                efficient for millions of objects, but for a few thousands, GDScript should be fine.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends MultiMeshInstance3D


func _ready():
    # Create the multimesh.
    multimesh = MultiMesh.new()
    # Set the format first.
    multimesh.transform_format = MultiMesh.TRANSFORM_3D
    # Then resize (otherwise, changing the format is not allowed).
    multimesh.instance_count = 10000
    # Maybe not all of them should be visible at first.
    multimesh.visible_instance_count = 1000

    # Set the transform of the instances.
    for i in multimesh.visible_instance_count:
        multimesh.set_instance_transform(i, Transform3D(Basis(), Vector3(i * 20, 0, 0)))</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyMultiMeshInstance3D : MultiMeshInstance3D
{
    public override void _Ready()
    {
        // Create the multimesh.
        Multimesh = new MultiMesh();
        // Set the format first.
        Multimesh.TransformFormat = MultiMesh.TransformFormatEnum.Transform3D;
        // Then resize (otherwise, changing the format is not allowed)
        Multimesh.InstanceCount = 1000;
        // Maybe not all of them should be visible at first.
        Multimesh.VisibleInstanceCount = 1000;

        // Set the transform of the instances.
        for (int i = 0; i &lt; Multimesh.VisibleInstanceCount; i++)
        {
            Multimesh.SetInstanceTransform(i, new Transform3D(Basis.Identity, new Vector3(i * 20, 0, 0)));
        }
    }
}</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
