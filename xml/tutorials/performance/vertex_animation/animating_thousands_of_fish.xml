<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/vertex_animation/animating_thousands_of_fish.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-animating-thousands-of-fish"></target>
    <section ids="animating-thousands-of-fish-with-multimeshinstance3d doc-animating-thousands-of-fish" names="animating\ thousands\ of\ fish\ with\ multimeshinstance3d 用\ multimeshinstance3d\ 动画化数以千计条鱼 doc_animating_thousands_of_fish">
        <title>用 MultiMeshInstance3D 动画化数以千计条鱼</title>
        <paragraph>本教程探索了游戏 <reference name="ABZU" refuri="https://www.gdcvault.com/play/1024409/Creating-the-Art-of-ABZ">ABZU</reference><target ids="abzu" names="abzu" refuri="https://www.gdcvault.com/play/1024409/Creating-the-Art-of-ABZ"></target> 中使用的一种技术, 该技术使用顶点动画和静态网格实例, 来渲染和制作成千上万的鱼动画.</paragraph>
        <paragraph>In Godot, this can be accomplished with a custom <reference internal="True" refuri="../../../classes/class_shader#class-shader"><inline classes="std std-ref">Shader</inline></reference> and
            a <reference internal="True" refuri="../../../classes/class_multimeshinstance3d#class-multimeshinstance3d"><inline classes="std std-ref">MultiMeshInstance3D</inline></reference>. Using the following technique you
            can render thousands of animated objects, even on low end hardware.</paragraph>
        <paragraph>我们将从一条鱼的动画开始. 然后, 我们将看到如何将该动画扩展到数千条鱼.</paragraph>
        <section ids="animating-one-fish" names="animating\ one\ fish 动画化一条鱼">
            <title>动画化一条鱼</title>
            <paragraph>We will start with a single fish. Load your fish model into a <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference>
                and add a new <reference internal="True" refuri="../../../classes/class_shadermaterial#class-shadermaterial"><inline classes="std std-ref">ShaderMaterial</inline></reference>.</paragraph>
            <paragraph>这是我们用于示例图像的鱼, 你可以使用任何你喜欢的鱼模型.</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/fish.png'}" uri="tutorials/performance/vertex_animation/img/fish.png"></image>
            <note>
                <paragraph>The fish model in this tutorial is made by <reference name="QuaterniusDev" refuri="https://quaternius.com">QuaterniusDev</reference><target ids="quaterniusdev" names="quaterniusdev" refuri="https://quaternius.com"></target> and is
                    shared with a creative commons license. CC0 1.0 Universal (CC0 1.0) Public Domain
                    Dedication <reference refuri="https://creativecommons.org/publicdomain/zero/1.0/">https://creativecommons.org/publicdomain/zero/1.0/</reference></paragraph>
            </note>
            <paragraph>Typically, you would use bones and a <reference internal="True" refuri="../../../classes/class_skeleton3d#class-skeleton3d"><inline classes="std std-ref">Skeleton3D</inline></reference> to animate objects. However,
                bones are animated on the CPU and so you end having to calculate thousands of operations every
                frame and it becomes impossible to have thousands of objects. Using vertex animation in a vertex
                shader, you avoid using bones and can instead calculate the full animation in a few lines of code
                and completely on the GPU.</paragraph>
            <paragraph>动画由四个关键帧动作组成:</paragraph>
            <block_quote>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>从一边运动到另一边</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>绕着鱼的中心作旋转运动</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>平移波动运动</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>平移扭转运动</paragraph>
                    </list_item>
                </enumerated_list>
            </block_quote>
            <paragraph>所有的动画代码都在顶点着色器中，并由 uniform 控制运动量。我们使用 uniform 来控制运动的强度，这样你就可以在编辑器中调整动画，并实时看到结果，而不用重新编译着色器。</paragraph>
            <paragraph>所有的运动都将使用余弦波应用于模型空间中的 <literal>VERTEX</literal> . 我们希望顶点在模型空间中, 使运动总是相对于鱼的方向. 例如,side-to-side将始终使鱼在其左至右的方向上来回移动, 而不是在世界方向的 <literal>x</literal> 轴上.</paragraph>
            <paragraph>为了控制动画的速度，我们将通过使用 <literal>TIME</literal> 定义自己的时间变量开始。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//time_scale is a uniform float
float time = TIME * time_scale;</literal_block>
            <paragraph>我们将实施的第一项议案是左右运动. 它可以通过 <literal>TIME</literal> 的 <literal>cos</literal> 抵消 <literal>VERTEX.x</literal> 来制作. 每次渲染网格时, 所有顶点都会移动到 "cos(时间)" 的数量.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//side_to_side is a uniform float
VERTEX.x += cos(time) * side_to_side;</literal_block>
            <paragraph>生成的动画看起来是这样的:</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/sidetoside.gif'}" uri="tutorials/performance/vertex_animation/img/sidetoside.gif"></image>
            <paragraph>接下来，我们添加轴心点。因为鱼以 (0, 0) 为中心，我们所要做的只是将 <literal>VERTEX</literal> 乘以旋转矩阵，使其围绕鱼的中心旋转。</paragraph>
            <paragraph>我们构造一个旋转矩阵, 如下所示:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//angle is scaled by 0.1 so that the fish only pivots and doesn't rotate all the way around
//pivot is a uniform float
float pivot_angle = cos(time) * 0.1 * pivot;
mat2 rotation_matrix = mat2(vec2(cos(pivot_angle), -sin(pivot_angle)), vec2(sin(pivot_angle), cos(pivot_angle)));</literal_block>
            <paragraph>然后我们把它乘以 <literal>VERTEX.xz</literal>，应用到 <literal>x</literal> 和 <literal>z</literal> 轴上。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">VERTEX.xz = rotation_matrix * VERTEX.xz;</literal_block>
            <paragraph>在只应用轴心的情况下，你会看到这个：</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/pivot.gif'}" uri="tutorials/performance/vertex_animation/img/pivot.gif"></image>
            <paragraph>接下来的两个动作需要沿着鱼的脊柱平移. 为此, 我们需要一个新的变量, <literal>body</literal> . <literal>body</literal> 是一个浮点数，在鱼的尾部是 <literal>0</literal> ，在头部是 <literal>1</literal> .</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float body = (VERTEX.z + 1.0) / 2.0; //for a fish centered at (0, 0) with a length of 2</literal_block>
            <paragraph>下一个运动是沿着鱼的长度向下移动的余弦波. 为了让它沿着鱼的脊柱移动, 我们用脊柱的位置来偏移输入到 <literal>cos</literal> 的位置, 也就是我们在上面定义的变量 <literal>body</literal>。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//wave is a uniform float
VERTEX.x += cos(time + body) * wave;</literal_block>
            <paragraph>这看起来很像我们上面定义的左右运动, 但在这个例子中, 通过使用 <literal>body</literal> 来偏移 <literal>cos</literal>，沿着脊柱的每个顶点在波浪中都有不同的位置, 使它看起来像是沿着鱼移动的波浪.</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/wave.gif'}" uri="tutorials/performance/vertex_animation/img/wave.gif"></image>
            <paragraph>最后一个动作是扭转，也就是沿着脊柱滚动。类似轴心运动，我们首先构造一个旋转矩阵。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//twist is a uniform float
float twist_angle = cos(time + body) * 0.3 * twist;
mat2 twist_matrix = mat2(vec2(cos(twist_angle), -sin(twist_angle)), vec2(sin(twist_angle), cos(twist_angle)));</literal_block>
            <paragraph>我们在 <literal>xy</literal> 轴上应用旋转, 使鱼看起来绕着它的脊柱滚动. 要做到这一点, 鱼的脊柱需要以 <literal>z</literal> 轴为中心.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">VERTEX.xy = twist_matrix * VERTEX.xy;</literal_block>
            <paragraph>这是应用扭曲的鱼:</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/twist.gif'}" uri="tutorials/performance/vertex_animation/img/twist.gif"></image>
            <paragraph>如果我们一个接一个地应用这些运动, 就得到一个类似液体凝胶似的运动.</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/all_motions.gif'}" uri="tutorials/performance/vertex_animation/img/all_motions.gif"></image>
            <paragraph>通常鱼主要使用身体的后半部分游泳，所以我们需要将平移运动限制在鱼的后半部分。为此，我们创建一个新变量 <literal>mask</literal> （遮罩）。</paragraph>
            <paragraph><literal>mask</literal> 是个浮点数，从鱼头的 <literal>0</literal> 过渡到鱼尾的 <literal>1</literal> ，我们用 <literal>smoothstep</literal> 来控制在哪里进行由 <literal>0</literal> 到 <literal>1</literal> 的过渡。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//mask_black and mask_white are uniforms
float mask = smoothstep(mask_black, mask_white, 1.0 - body);</literal_block>
            <paragraph>下面是把 <literal>COLOR</literal> 设置成 <literal>mask</literal> 后这条鱼的样子：</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/mask.png'}" uri="tutorials/performance/vertex_animation/img/mask.png"></image>
            <paragraph>我们在做波浪运动的地方乘以 <literal>mask</literal> 就可以把动作限制在后半部分。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//wave motion with mask
VERTEX.x += cos(time + body) * mask * wave;</literal_block>
            <paragraph>为了将遮罩应用于扭曲, 我们使用 <literal>mix</literal> . <literal>mix</literal> 允许在完全旋转的顶点和未旋转的顶点之间混合顶点位置. 需要使用 <literal>mix</literal> 而不是将 <literal>mask</literal> 乘以旋转后的 <literal>VERTEX</literal> , 因为不是将运动加到 <literal>VERTEX</literal> 上, 而是用旋转后的版本替换 <literal>VERTEX</literal> . 如果把它乘以 <literal>mask</literal> , 就会把鱼缩小.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//twist motion with mask
VERTEX.xy = mix(VERTEX.xy, twist_matrix * VERTEX.xy, mask);</literal_block>
            <paragraph>将四个动作组合在一起, 就得到了最终的动画效果.</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/all_motions_mask.gif'}" uri="tutorials/performance/vertex_animation/img/all_motions_mask.gif"></image>
            <paragraph>继续发挥 uniform 的作用, 以改变鱼的游泳周期. 你会发现, 你可以用这四个动作创造出各种各样的游泳方式.</paragraph>
        </section>
        <section ids="making-a-school-of-fish" names="making\ a\ school\ of\ fish 制作一群鱼">
            <title>制作一群鱼</title>
            <paragraph>Godot makes it easy to render thousands of the same object using a MultiMeshInstance3D node.</paragraph>
            <paragraph>A MultiMeshInstance3D node is created and used the same way you would make a MeshInstance3D node.
                For this tutorial, we will name the MultiMeshInstance3D node <literal>School</literal>, because it will contain
                a school of fish.</paragraph>
            <paragraph>Once you have a MultiMeshInstance3D add a <reference internal="True" refuri="../../../classes/class_multimesh#class-multimesh"><inline classes="std std-ref">MultiMesh</inline></reference>, and to that
                MultiMesh add your <reference internal="True" refuri="../../../classes/class_mesh#class-mesh"><inline classes="std std-ref">Mesh</inline></reference> with the shader from above.</paragraph>
            <paragraph>MultiMeshes 使用三个额外的实例属性来绘制 Mesh：变换（旋转、平移、缩放）、颜色和自定义。自定义用于使用 <reference internal="True" refuri="../../../classes/class_color#class-color"><inline classes="std std-ref">Color</inline></reference> 传入 4 个多用途变量。</paragraph>
            <paragraph><literal>instance_count</literal> 指定要绘制的网格的实例数量。现在，将 <literal>instance_count</literal> 保留为 <literal>0</literal>，因为当 <literal>instance_count</literal> 大于 <literal>0</literal> 时，你不能更改任何其他参数。我们稍后将在 GDScript 中设置 <literal>instance_count</literal>。</paragraph>
            <paragraph><literal>transform_format</literal> 指定使用的变换是 3D 还是 2D。对于本教程，请选择 3D。</paragraph>
            <paragraph>对于 <literal>color_format</literal> 和 <literal>custom_data_format</literal>，你可以在 <literal>None</literal>、<literal>Byte</literal>、<literal>Float</literal> 之间选择。<literal>None</literal> 意味着你不会将这些数据（无论是每个实例的 <literal>COLOR</literal> 变量还是 <literal>INSTANCE_CUSTOM</literal>）传递给着色器。<literal>Byte</literal> 意味着组成你传入的颜色的每一个数字将被存储为 8 位，而 <literal>Float</literal> 意味着每一个数字将被存储为浮点数（32 位）。<literal>Float</literal> 速度较慢但更精确，<literal>Byte</literal> 占用内存较少、速度较快，但你可能会看到一些视觉上的伪像。</paragraph>
            <paragraph>现在，将 <literal>instance_count</literal> 设置为你想要的鱼的数量。</paragraph>
            <paragraph>接下来, 我们需要设置每个实例的变换.</paragraph>
            <paragraph>There are two ways to set per-instance transforms for MultiMeshes. The first is entirely in editor
                and is described in the <reference internal="True" refuri="../../3d/using_multi_mesh_instance#doc-using-multi-mesh-instance"><inline classes="std std-ref">MultiMeshInstance3D tutorial</inline></reference>.</paragraph>
            <paragraph>第二种方法是, 遍历所有实例, 并在代码中设置它们的变换. 下面, 我们使用GDScript遍历所有实例, 并将它们的变换设置为随机位置.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for i in range($School.multimesh.instance_count):
  var position = Transform3D()
  position = position.translated(Vector3(randf() * 100 - 50, randf() * 50 - 25, randf() * 50 - 25))
  $School.multimesh.set_instance_transform(i, position)</literal_block>
            <paragraph>Running this script will place the fish in random positions in a box around the position of the
                MultiMeshInstance3D.</paragraph>
            <note>
                <paragraph>If performance is an issue for you, try running the scene with fewer fish.</paragraph>
            </note>
            <paragraph>你应该已经注意到所有鱼的游泳动作都是同步的了吧？这样看上去非常机械。下一步我们要做的就是让每一条鱼都处于游泳周期的不同位置，这样整个鱼群看起来就会更自然。</paragraph>
        </section>
        <section ids="animating-a-school-of-fish" names="animating\ a\ school\ of\ fish 动画鱼群">
            <title>动画鱼群</title>
            <paragraph>使用 <literal>cos</literal> 函数给鱼做动画的一个好处是，它们只需要一个 <literal>time</literal> 参数。为了让每条鱼在游泳周期中处于单独的位置，我们只需要偏移 <literal>time</literal>。</paragraph>
            <paragraph>为此，我们将每个实例的自定义值 <literal>INSTANCE_CUSTOM</literal> 添加到 <literal>time</literal> 中。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float time = (TIME * time_scale) + (6.28318 * INSTANCE_CUSTOM.x);</literal_block>
            <paragraph>接下来，我们需要向 <literal>INSTANCE_CUSTOM</literal> 传递一个值。通过在上面的 <literal>for</literal> 循环中添加一行来实现这一点。在 <literal>for</literal> 循环中，为每个实例分配一组四个随机浮点数来使用。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">$School.multimesh.set_instance_custom_data(i, Color(randf(), randf(), randf(), randf()))</literal_block>
            <paragraph>现在这些鱼在游泳周期中都有独特的位置。你可以通过使用 <literal>INSTANCE_CUSTOM</literal> 乘以 <literal>TIME</literal> 让它们游泳更快或更慢，从而让它们更个性化。</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//set speed from 50% - 150% of regular speed
float time = (TIME * (0.5 + INSTANCE_CUSTOM.y) * time_scale) + (6.28318 * INSTANCE_CUSTOM.x);</literal_block>
            <paragraph>甚至你还可以像更改每个实例的自定义值一样, 尝试更改每个实例的颜色.</paragraph>
            <paragraph>One problem that you will run into at this point is that the fish are animated, but they are not
                moving. You can move them by updating the per-instance transform for each fish every frame. Although
                doing so will be faster than moving thousands of MeshInstance3Ds per frame, it'll still likely be
                slow.</paragraph>
            <paragraph>In the next tutorial we will cover how to use <reference internal="True" refuri="../../../classes/class_gpuparticles3d#class-gpuparticles3d"><inline classes="std std-ref">GPUParticles3D</inline></reference> to take advantage
                of the GPU and move each fish around individually while still receiving the benefits of instancing.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
