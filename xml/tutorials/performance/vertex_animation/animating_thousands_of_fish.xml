<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/vertex_animation/animating_thousands_of_fish.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-animating-thousands-of-fish"></target>
    <section ids="animating-thousands-of-fish-with-multimeshinstance3d doc-animating-thousands-of-fish" names="animating\ thousands\ of\ fish\ with\ multimeshinstance3d doc_animating_thousands_of_fish">
        <title>Animating thousands of fish with MultiMeshInstance3D</title>
        <paragraph>This tutorial explores a technique used in the game <reference name="ABZU" refuri="https://www.gdcvault.com/play/1024409/Creating-the-Art-of-ABZ">ABZU</reference><target ids="abzu" names="abzu" refuri="https://www.gdcvault.com/play/1024409/Creating-the-Art-of-ABZ"></target>
            for rendering and animating thousands of fish using vertex animation and
            static mesh instancing.</paragraph>
        <paragraph>In Godot, this can be accomplished with a custom <reference internal="True" refuri="../../../classes/class_shader#class-shader"><inline classes="std std-ref">Shader</inline></reference> and
            a <reference internal="True" refuri="../../../classes/class_multimeshinstance3d#class-multimeshinstance3d"><inline classes="std std-ref">MultiMeshInstance3D</inline></reference>. Using the following technique you
            can render thousands of animated objects, even on low-end hardware.</paragraph>
        <paragraph>We will start by animating one fish. Then, we will see how to extend that animation to
            thousands of fish.</paragraph>
        <section ids="animating-one-fish" names="animating\ one\ fish">
            <title>Animating one Fish</title>
            <paragraph>We will start with a single fish. Load your fish model into a <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference>
                and add a new <reference internal="True" refuri="../../../classes/class_shadermaterial#class-shadermaterial"><inline classes="std std-ref">ShaderMaterial</inline></reference>.</paragraph>
            <paragraph>Here is the fish we will be using for the example images, you can use any fish model you like.</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/fish.png'}" original_uri="img/fish.png" uri="tutorials/performance/vertex_animation/img/fish.png"></image>
            <note>
                <paragraph>The fish model in this tutorial is made by <reference name="QuaterniusDev" refuri="https://quaternius.com">QuaterniusDev</reference><target ids="quaterniusdev" names="quaterniusdev" refuri="https://quaternius.com"></target> and is
                    shared with a creative commons license. CC0 1.0 Universal (CC0 1.0) Public Domain
                    Dedication <reference refuri="https://creativecommons.org/publicdomain/zero/1.0/">https://creativecommons.org/publicdomain/zero/1.0/</reference></paragraph>
            </note>
            <paragraph>Typically, you would use bones and a <reference internal="True" refuri="../../../classes/class_skeleton3d#class-skeleton3d"><inline classes="std std-ref">Skeleton3D</inline></reference> to animate objects. However,
                bones are animated on the CPU and so you end having to calculate thousands of operations every
                frame and it becomes impossible to have thousands of objects. Using vertex animation in a vertex
                shader, you avoid using bones and can instead calculate the full animation in a few lines of code
                and completely on the GPU.</paragraph>
            <paragraph>The animation will be made of four key motions:</paragraph>
            <block_quote>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>A side to side motion</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>A pivot motion around the center of the fish</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>A panning wave motion</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>A panning twist motion</paragraph>
                    </list_item>
                </enumerated_list>
            </block_quote>
            <paragraph>All the code for the animation will be in the vertex shader with uniforms controlling the amount of motion.
                We use uniforms to control the strength of the motion so that you can tweak the animation in editor and see the
                results in real time, without the shader having to recompile.</paragraph>
            <paragraph>All the motions will be made using cosine waves applied to <literal>VERTEX</literal> in model space. We want the vertices to
                be in model space so that the motion is always relative to the orientation of the fish. For example, side-to-side
                will always move the fish back and forth in its left to right direction, instead of on the <literal>x</literal> axis in the
                world orientation.</paragraph>
            <paragraph>In order to control the speed of the animation, we will start by defining our own time variable using <literal>TIME</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//time_scale is a uniform float
float time = TIME * time_scale;</literal_block>
            <paragraph>The first motion we will implement is the side to side motion. It can be made by offsetting <literal>VERTEX.x</literal> by
                <literal>cos</literal> of <literal>TIME</literal>. Each time the mesh is rendered, all the vertices will move to the side by the amount
                of <literal>cos(time)</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//side_to_side is a uniform float
VERTEX.x += cos(time) * side_to_side;</literal_block>
            <paragraph>The resulting animation should look something like this:</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/sidetoside.gif'}" original_uri="img/sidetoside.gif" uri="tutorials/performance/vertex_animation/img/sidetoside.gif"></image>
            <paragraph>Next, we add the pivot. Because the fish is centered at (0, 0), all we have to do is multiply <literal>VERTEX</literal> by a
                rotation matrix for it to rotate around the center of the fish.</paragraph>
            <paragraph>We construct a rotation matrix like so:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//angle is scaled by 0.1 so that the fish only pivots and doesn't rotate all the way around
//pivot is a uniform float
float pivot_angle = cos(time) * 0.1 * pivot;
mat2 rotation_matrix = mat2(vec2(cos(pivot_angle), -sin(pivot_angle)), vec2(sin(pivot_angle), cos(pivot_angle)));</literal_block>
            <paragraph>And then we apply it in the <literal>x</literal> and <literal>z</literal> axes by multiplying it by <literal>VERTEX.xz</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">VERTEX.xz = rotation_matrix * VERTEX.xz;</literal_block>
            <paragraph>With only the pivot applied you should see something like this:</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/pivot.gif'}" original_uri="img/pivot.gif" uri="tutorials/performance/vertex_animation/img/pivot.gif"></image>
            <paragraph>The next two motions need to pan down the spine of the fish. For that, we need a new variable, <literal>body</literal>.
                <literal>body</literal> is a float that is <literal>0</literal> at the tail of the fish and <literal>1</literal> at its head.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float body = (VERTEX.z + 1.0) / 2.0; //for a fish centered at (0, 0) with a length of 2</literal_block>
            <paragraph>The next motion is a cosine wave that moves down the length of the fish. To make
                it move along the spine of the fish, we offset the input to <literal>cos</literal> by the position
                along the spine, which is the variable we defined above, <literal>body</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//wave is a uniform float
VERTEX.x += cos(time + body) * wave;</literal_block>
            <paragraph>This looks very similar to the side to side motion we defined above, but in this one, by
                using <literal>body</literal> to offset <literal>cos</literal> each vertex along the spine has a different position in
                the wave making it look like a wave is moving along the fish.</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/wave.gif'}" original_uri="img/wave.gif" uri="tutorials/performance/vertex_animation/img/wave.gif"></image>
            <paragraph>The last motion is the twist, which is a panning roll along the spine. Similarly to the pivot,
                we first construct a rotation matrix.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//twist is a uniform float
float twist_angle = cos(time + body) * 0.3 * twist;
mat2 twist_matrix = mat2(vec2(cos(twist_angle), -sin(twist_angle)), vec2(sin(twist_angle), cos(twist_angle)));</literal_block>
            <paragraph>We apply the rotation in the <literal>xy</literal> axes so that the fish appears to roll around its spine. For
                this to work, the fish's spine needs to be centered on the <literal>z</literal> axis.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">VERTEX.xy = twist_matrix * VERTEX.xy;</literal_block>
            <paragraph>Here is the fish with twist applied:</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/twist.gif'}" original_uri="img/twist.gif" uri="tutorials/performance/vertex_animation/img/twist.gif"></image>
            <paragraph>If we apply all these motions one after another, we get a fluid jelly-like motion.</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/all_motions.gif'}" original_uri="img/all_motions.gif" uri="tutorials/performance/vertex_animation/img/all_motions.gif"></image>
            <paragraph>Normal fish swim mostly with the back half of their body. Accordingly, we need to limit the
                panning motions to the back half of the fish. To do this, we create a new variable, <literal>mask</literal>.</paragraph>
            <paragraph><literal>mask</literal> is a float that goes from <literal>0</literal> at the front of the fish to <literal>1</literal> at the end using
                <literal>smoothstep</literal> to control the point at which the transition from <literal>0</literal> to <literal>1</literal> happens.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//mask_black and mask_white are uniforms
float mask = smoothstep(mask_black, mask_white, 1.0 - body);</literal_block>
            <paragraph>Below is an image of the fish with <literal>mask</literal> used as <literal>COLOR</literal>:</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/mask.png'}" original_uri="img/mask.png" uri="tutorials/performance/vertex_animation/img/mask.png"></image>
            <paragraph>For the wave, we multiply the motion by <literal>mask</literal> which will limit it to the back half.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//wave motion with mask
VERTEX.x += cos(time + body) * mask * wave;</literal_block>
            <paragraph>In order to apply the mask to the twist, we use <literal>mix</literal>. <literal>mix</literal> allows us to mix the
                vertex position between a fully rotated vertex and one that is not rotated. We need to
                use <literal>mix</literal> instead of multiplying <literal>mask</literal> by the rotated <literal>VERTEX</literal> because we are not
                adding the motion to the <literal>VERTEX</literal> we are replacing the <literal>VERTEX</literal> with the rotated
                version. If we multiplied that by <literal>mask</literal>, we would shrink the fish.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//twist motion with mask
VERTEX.xy = mix(VERTEX.xy, twist_matrix * VERTEX.xy, mask);</literal_block>
            <paragraph>Putting the four motions together gives us the final animation.</paragraph>
            <image candidates="{'*': 'tutorials/performance/vertex_animation/img/all_motions_mask.gif'}" original_uri="img/all_motions_mask.gif" uri="tutorials/performance/vertex_animation/img/all_motions_mask.gif"></image>
            <paragraph>Go ahead and play with the uniforms in order to alter the swim cycle of the fish. You will
                find that you can create a wide variety of swim styles using these four motions.</paragraph>
        </section>
        <section ids="making-a-school-of-fish" names="making\ a\ school\ of\ fish">
            <title>Making a school of fish</title>
            <paragraph>Godot makes it easy to render thousands of the same object using a MultiMeshInstance3D node.</paragraph>
            <paragraph>A MultiMeshInstance3D node is created and used the same way you would make a MeshInstance3D node.
                For this tutorial, we will name the MultiMeshInstance3D node <literal>School</literal>, because it will contain
                a school of fish.</paragraph>
            <paragraph>Once you have a MultiMeshInstance3D add a <reference internal="True" refuri="../../../classes/class_multimesh#class-multimesh"><inline classes="std std-ref">MultiMesh</inline></reference>, and to that
                MultiMesh add your <reference internal="True" refuri="../../../classes/class_mesh#class-mesh"><inline classes="std std-ref">Mesh</inline></reference> with the shader from above.</paragraph>
            <paragraph>MultiMeshes draw your Mesh with three additional per-instance properties: Transform (rotation,
                translation, scale), Color, and Custom. Custom is used to pass in 4 multi-use variables using
                a <reference internal="True" refuri="../../../classes/class_color#class-color"><inline classes="std std-ref">Color</inline></reference>.</paragraph>
            <paragraph><literal>instance_count</literal> specifies how many instances of the mesh you want to draw. For now, leave
                <literal>instance_count</literal> at <literal>0</literal> because you cannot change any of the other parameters while
                <literal>instance_count</literal> is larger than <literal>0</literal>. We will set <literal>instance count</literal> in GDScript later.</paragraph>
            <paragraph><literal>transform_format</literal> specifies whether the transforms used are 3D or 2D. For this tutorial, select 3D.</paragraph>
            <paragraph>For both <literal>color_format</literal> and <literal>custom_data_format</literal> you can choose between <literal>None</literal>, <literal>Byte</literal>, and
                <literal>Float</literal>. <literal>None</literal> means you won't be passing in that data (either a per-instance <literal>COLOR</literal> variable,
                or <literal>INSTANCE_CUSTOM</literal>) to the shader. <literal>Byte</literal> means each number making up the color you pass in will
                be stored with 8 bits while <literal>Float</literal> means each number will be stored in a floating-point number
                (32 bits). <literal>Float</literal> is slower but more precise, <literal>Byte</literal> will take less memory and be faster, but you
                may see some visual artifacts.</paragraph>
            <paragraph>Now, set <literal>instance_count</literal> to the number of fish you want to have.</paragraph>
            <paragraph>Next we need to set the per-instance transforms.</paragraph>
            <paragraph>There are two ways to set per-instance transforms for MultiMeshes. The first is entirely in editor
                and is described in the <reference internal="True" refuri="../../3d/using_multi_mesh_instance#doc-using-multi-mesh-instance"><inline classes="std std-ref">MultiMeshInstance3D tutorial</inline></reference>.</paragraph>
            <paragraph>The second is to loop over all the instances and set their transforms in code. Below, we use GDScript
                to loop over all the instances and set their transform to a random position.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for i in range($School.multimesh.instance_count):
  var position = Transform3D()
  position = position.translated(Vector3(randf() * 100 - 50, randf() * 50 - 25, randf() * 50 - 25))
  $School.multimesh.set_instance_transform(i, position)</literal_block>
            <paragraph>Running this script will place the fish in random positions in a box around the position of the
                MultiMeshInstance3D.</paragraph>
            <note>
                <paragraph>If performance is an issue for you, try running the scene with fewer fish.</paragraph>
            </note>
            <paragraph>Notice how all the fish are all in the same position in their swim cycle? It makes them look very
                robotic. The next step is to give each fish a different position in the swim cycle so the entire
                school looks more organic.</paragraph>
        </section>
        <section ids="animating-a-school-of-fish" names="animating\ a\ school\ of\ fish">
            <title>Animating a school of fish</title>
            <paragraph>One of the benefits of animating the fish using <literal>cos</literal> functions is that they are animated with
                one parameter, <literal>time</literal>. In order to give each fish a unique position in the
                swim cycle, we only need to offset <literal>time</literal>.</paragraph>
            <paragraph>We do that by adding the per-instance custom value <literal>INSTANCE_CUSTOM</literal> to <literal>time</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float time = (TIME * time_scale) + (6.28318 * INSTANCE_CUSTOM.x);</literal_block>
            <paragraph>Next, we need to pass a value into <literal>INSTANCE_CUSTOM</literal>. We do that by adding one line into
                the <literal>for</literal> loop from above. In the <literal>for</literal> loop we assign each instance a set of four
                random floats to use.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">$School.multimesh.set_instance_custom_data(i, Color(randf(), randf(), randf(), randf()))</literal_block>
            <paragraph>Now the fish all have unique positions in the swim cycle. You can give them a little more
                individuality by using <literal>INSTANCE_CUSTOM</literal> to make them swim faster or slower by multiplying
                by <literal>TIME</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">//set speed from 50% - 150% of regular speed
float time = (TIME * (0.5 + INSTANCE_CUSTOM.y) * time_scale) + (6.28318 * INSTANCE_CUSTOM.x);</literal_block>
            <paragraph>You can even experiment with changing the per-instance color the same way you changed the per-instance
                custom value.</paragraph>
            <paragraph>One problem that you will run into at this point is that the fish are animated, but they are not
                moving. You can move them by updating the per-instance transform for each fish every frame. Although
                doing so will be faster than moving thousands of MeshInstance3Ds per frame, it'll still likely be
                slow.</paragraph>
            <paragraph>In the next tutorial we will cover how to use <reference internal="True" refuri="../../../classes/class_gpuparticles3d#class-gpuparticles3d"><inline classes="std std-ref">GPUParticles3D</inline></reference> to take advantage
                of the GPU and move each fish around individually while still receiving the benefits of instancing.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
