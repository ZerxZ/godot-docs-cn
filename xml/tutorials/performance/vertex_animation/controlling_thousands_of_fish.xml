<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/vertex_animation/controlling_thousands_of_fish.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-controlling-thousands-of-fish"></target>
    <section ids="controlling-thousands-of-fish-with-particles doc-controlling-thousands-of-fish" names="controlling\ thousands\ of\ fish\ with\ particles doc_controlling_thousands_of_fish">
        <title>Controlling thousands of fish with Particles</title>
        <paragraph>The problem with <reference internal="True" refuri="../../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> is that it is expensive to
            update their transform array. It is great for placing many static objects around the
            scene. But it is still difficult to move the objects around the scene.</paragraph>
        <paragraph>To make each instance move in an interesting way, we will use a
            <reference internal="True" refuri="../../../classes/class_gpuparticles3d#class-gpuparticles3d"><inline classes="std std-ref">GPUParticles3D</inline></reference> node. Particles take advantage of GPU acceleration
            by computing and setting the per-instance information in a <reference internal="True" refuri="../../../classes/class_shader#class-shader"><inline classes="std std-ref">Shader</inline></reference>.</paragraph>
        <paragraph>First create a Particles node. Then, under "Draw Passes" set the Particle's "Draw Pass 1" to your
            <reference internal="True" refuri="../../../classes/class_mesh#class-mesh"><inline classes="std std-ref">Mesh</inline></reference>. Then under "Process Material" create a new
            <reference internal="True" refuri="../../../classes/class_shadermaterial#class-shadermaterial"><inline classes="std std-ref">ShaderMaterial</inline></reference>.</paragraph>
        <paragraph>Set the <literal>shader_type</literal> to <literal>particles</literal>.</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type particles</literal_block>
        <paragraph>Then add the following two functions:</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">float rand_from_seed(in uint seed) {
  int k;
  int s = int(seed);
  if (s == 0)
    s = 305420679;
  k = s / 127773;
  s = 16807 * (s - k * 127773) - 2836 * k;
  if (s &lt; 0)
    s += 2147483647;
  seed = uint(s);
  return float(seed % uint(65536)) / 65535.0;
}

uint hash(uint x) {
  x = ((x &gt;&gt; uint(16)) ^ x) * uint(73244475);
  x = ((x &gt;&gt; uint(16)) ^ x) * uint(73244475);
  x = (x &gt;&gt; uint(16)) ^ x;
  return x;
}</literal_block>
        <paragraph>These functions come from the default <reference internal="True" refuri="../../../classes/class_particleprocessmaterial#class-particleprocessmaterial"><inline classes="std std-ref">ParticleProcessMaterial</inline></reference>.
            They are used to generate a random number from each particle's <literal>RANDOM_SEED</literal>.</paragraph>
        <paragraph>A unique thing about particle shaders is that some built-in variables are saved across frames.
            <literal>TRANSFORM</literal>, <literal>COLOR</literal>, and <literal>CUSTOM</literal> can all be accessed in the shader of the mesh, and
            also in the particle shader the next time it is run.</paragraph>
        <paragraph>Next, setup your <literal>start()</literal> function. Particles shaders contain a <literal>start()</literal> function and a
            <literal>process()</literal> function.</paragraph>
        <paragraph>The code in the <literal>start()</literal> function only runs when the particle system starts.
            The code in the <literal>process()</literal> function will always run.</paragraph>
        <paragraph>We need to generate 4 random numbers: 3 to create a random position and one for the random
            offset of the swim cycle.</paragraph>
        <paragraph>First, generate 4 seeds inside the <literal>start()</literal> function using the <literal>hash()</literal> function provided above:</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">uint alt_seed1 = hash(NUMBER + uint(1) + RANDOM_SEED);
uint alt_seed2 = hash(NUMBER + uint(27) + RANDOM_SEED);
uint alt_seed3 = hash(NUMBER + uint(43) + RANDOM_SEED);
uint alt_seed4 = hash(NUMBER + uint(111) + RANDOM_SEED);</literal_block>
        <paragraph>Then, use those seeds to generate random numbers using <literal>rand_from_seed</literal>:</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">CUSTOM.x = rand_from_seed(alt_seed1);
vec3 position = vec3(rand_from_seed(alt_seed2) * 2.0 - 1.0,
                     rand_from_seed(alt_seed3) * 2.0 - 1.0,
                     rand_from_seed(alt_seed4) * 2.0 - 1.0);</literal_block>
        <paragraph>Finally, assign <literal>position</literal> to <literal>TRANSFORM[3].xyz</literal>, which is the part of the transform that holds
            the position information.</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">TRANSFORM[3].xyz = position * 20.0;</literal_block>
        <paragraph>Remember, all this code so far goes inside the <literal>start()</literal> function.</paragraph>
        <paragraph>The vertex shader for your mesh can stay the exact same as it was in the previous tutorial.</paragraph>
        <paragraph>Now you can move each fish individually each frame, either by adding to the <literal>TRANSFORM</literal> directly
            or by writing to <literal>VELOCITY</literal>.</paragraph>
        <paragraph>Let's transform the fish by setting their <literal>VELOCITY</literal> in the <literal>start()</literal> function.</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">VELOCITY.z = 10.0;</literal_block>
        <paragraph>This is the most basic way to set <literal>VELOCITY</literal> every particle (or fish) will have the same velocity.</paragraph>
        <paragraph>Just by setting <literal>VELOCITY</literal> you can make the fish swim however you want. For example, try the code
            below.</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">VELOCITY.z = cos(TIME + CUSTOM.x * 6.28) * 4.0 + 6.0;</literal_block>
        <paragraph>This will give each fish a unique speed between <literal>2</literal> and <literal>10</literal>.</paragraph>
        <paragraph>You can also let each fish change its velocity over time if you set the velocity in the <literal>process()</literal>
            function.</paragraph>
        <paragraph>If you used <literal>CUSTOM.y</literal> in the last tutorial, you can also set the speed of the swim animation based
            on the <literal>VELOCITY</literal>. Just use <literal>CUSTOM.y</literal>.</paragraph>
        <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">CUSTOM.y = VELOCITY.z * 0.1;</literal_block>
        <paragraph>This code gives you the following behavior:</paragraph>
        <image candidates="{'*': 'tutorials/performance/vertex_animation/img/scene.gif'}" original_uri="img/scene.gif" uri="tutorials/performance/vertex_animation/img/scene.gif"></image>
        <paragraph>Using a ParticleProcessMaterial you can make the fish behavior as simple or complex as you like. In this
            tutorial we only set Velocity, but in your own Shaders you can also set <literal>COLOR</literal>, rotation, scale
            (through <literal>TRANSFORM</literal>). Please refer to the <reference internal="True" refuri="../../shaders/shader_reference/particle_shader#doc-particle-shader"><inline classes="std std-ref">Particles Shader Reference</inline></reference>
            for more information on particle shaders.</paragraph>
        <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
    </section>
</document>
