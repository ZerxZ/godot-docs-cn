<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/optimizing_3d_performance.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <meta content="优化" name="keywords">
    </meta>
    <target refid="doc-optimizing-3d-performance"></target>
    <section ids="optimizing-3d-performance doc-optimizing-3d-performance" names="optimizing\ 3d\ performance 优化\ 3d\ 性能 doc_optimizing_3d_performance">
        <title>优化 3D 性能</title>
        <section ids="culling" names="culling 剔除">
            <title>剔除</title>
            <paragraph>Godot会自动执行视图视锥剔除, 以防止渲染视口外的物体. 这对于发生在小范围内的游戏来说效果很好, 然而在较大的关卡中, 事情很快就会变得很麻烦.</paragraph>
            <section ids="occlusion-culling" names="occlusion\ culling 遮挡剔除">
                <title>遮挡剔除</title>
                <paragraph>比如走在一个小镇上, 你可能只能看到你所在的街道上的几栋建筑, 以及天空和几只飞过头顶的鸟. 然而就一个天真的渲染器而言, 你仍然可以看到整个小镇. 它不会只渲染你前面的建筑, 它会渲染那后面的街道, 与那条街上的人, 那后面的建筑. 你很快就会遇到这样的情况: 你试图渲染比可见的东西多10倍或100倍的东西.</paragraph>
                <paragraph>Things aren't quite as bad as they seem, because the Z-buffer usually allows the
                    GPU to only fully shade the objects that are at the front. This is called <emphasis>depth
                        prepass</emphasis> and is enabled by default in Godot when using the Forward+ or
                    Compatibility rendering methods. However, unneeded objects are still reducing
                    performance.</paragraph>
                <paragraph>One way we can potentially reduce the amount to be rendered is to <strong>take advantage
                        of occlusion</strong>. Godot 4.0 and later offers a new approach to occlusion culling
                    using occluder nodes. See <reference internal="True" refuri="../3d/occlusion_culling#doc-occlusion-culling"><inline classes="std std-ref">遮挡剔除</inline></reference> for instructions on
                    setting up occlusion culling in your scene.</paragraph>
                <note>
                    <paragraph>In some cases, you may have to adapt your level design to add more occlusion
                        opportunities. For example, you may have to add more walls to prevent the player
                        from seeing too far away, which would decrease performance due to the lost
                        opportunities for occlusion culling.</paragraph>
                </note>
            </section>
        </section>
        <section ids="transparent-objects" names="transparent\ objects 透明物体">
            <title>透明物体</title>
            <paragraph>Godot通过 <reference internal="True" refuri="../../classes/class_material#class-material"><inline classes="std std-ref">Material</inline></reference> 和 <reference internal="True" refuri="../../classes/class_shader#class-shader"><inline classes="std std-ref">Shader</inline></reference> 对对象进行排序以提高性能. 然而, 这对透明物体来说是不可能的. 透明物体从后往前渲染, 以便与后面的物体混合. 因此, <strong>尽量少使用透明对象</strong> . 如果一个物体有一小部分是透明的, 尽量让这部分成为一个独立的表面, 有自己的材质.</paragraph>
            <paragraph>更多信息请参阅 <reference internal="True" refuri="gpu_optimization#doc-gpu-optimization"><inline classes="std std-ref">GPU 优化</inline></reference> 文档。</paragraph>
        </section>
        <section ids="level-of-detail-lod" names="level\ of\ detail\ (lod) 细节程度（lod）">
            <title>细节程度（LOD）</title>
            <paragraph>在某些情况下, 特别是在远处, 用简单的版本**代替复杂的几何图形可能是个好主意. 最终用户可能看不出什么区别. 考虑看看远处的大量树木. 有几种策略可以替换不同距离的模型. 你可以使用较低的多边形模型, 或者使用透明度来模拟更复杂的几何体.</paragraph>
            <paragraph>Godot 4 提供了多种控制细节层次的方法：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>使用 <reference internal="True" refuri="../3d/mesh_lod#doc-mesh-lod"><inline classes="std std-ref">网格的细节级别（LOD）</inline></reference> 进行网格导入的自动方法。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>A manual approach configured in the 3D node using <reference internal="True" refuri="../3d/visibility_ranges#doc-visibility-ranges"><inline classes="std std-ref">可见范围（HLOD）</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../3d/using_decals#doc-using-decals"><inline classes="std std-ref">Decals</inline></reference> and <reference internal="True" refuri="../3d/lights_and_shadows#doc-lights-and-shadows"><inline classes="std std-ref">lights</inline></reference>
                        can also benefit from level of detail using their respective
                        <strong>Distance Fade</strong> properties.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>While they can be used independently, these approaches are most effective when
                used together. For example, you can set up visibility ranges to hide particle
                effects that are too far away from the player to notice. At the same time, you
                can rely on mesh LOD to make the particle effect's meshes rendered with less
                detail at a distance.</paragraph>
            <paragraph>Visibility ranges are also a good way to set up <emphasis>impostors</emphasis> for distant geometry
                (see below).</paragraph>
            <section ids="billboards-and-imposters" names="billboards\ and\ imposters billboard\ 和\ imposter">
                <title>Billboard 和 imposter</title>
                <paragraph>The simplest version of using transparency to deal with LOD is billboards. For
                    example, you can use a single transparent quad to represent a tree at distance.
                    This can be very cheap to render, unless of course, there are many trees in
                    front of each other. In this case, transparency may start eating into fill rate
                    (for more information on fill rate, see <reference internal="True" refuri="gpu_optimization#doc-gpu-optimization"><inline classes="std std-ref">GPU 优化</inline></reference>).</paragraph>
                <paragraph>另一种方法是不只渲染一棵树, 而是将一些树作为一组来渲染. 如果你能看到一个区域, 但在游戏中不能实际接近它, 这可能是特别有效的.</paragraph>
                <paragraph>你可以通过预先渲染对象的不同角度的视图来制作冒牌货. 或者你甚至可以更进一步, 周期性地将一个物体的视图重新渲染到一个纹理上, 作为一个冒牌货使用. 在远处, 你需要将观察者移动相当长的距离, 视角才会发生显著变化. 这可能是复杂的工作, 但可能是值得的, 这取决于你正在制作的项目类型.</paragraph>
            </section>
            <section ids="use-instancing-multimesh" names="use\ instancing\ (multimesh) 使用实例化（multimesh）">
                <title>使用实例化（MultiMesh）</title>
                <paragraph>如果必须在同一地点或附近绘制多个相同的对象, 请尝试使用 <reference internal="True" refuri="../../classes/class_multimesh#class-multimesh"><inline classes="std std-ref">MultiMesh</inline></reference> 来代替.MultiMesh允许以很小的性能代价来绘制成千上万的对象, 这使得它非常适合用于绘制羊群, 草地, 粒子以及其他任何有成千上万相同对象的地方.</paragraph>
                <paragraph>See also the <reference internal="True" refuri="using_multimesh#doc-using-multimesh"><inline classes="std std-ref">Using MultiMesh</inline></reference> documentation.</paragraph>
            </section>
        </section>
        <section ids="bake-lighting" names="bake\ lighting 烘焙照明">
            <title>烘焙照明</title>
            <paragraph>Lighting objects is one of the most costly rendering operations. Realtime
                lighting, shadows (especially multiple lights), and
                <reference internal="True" refuri="../3d/global_illumination/introduction_to_global_illumination#doc-introduction-to-global-illumination"><inline classes="std std-ref">global illumination</inline></reference> are especially
                expensive. They may simply be too much for lower power mobile devices to handle.</paragraph>
            <paragraph><strong>Consider using baked lighting</strong>, especially for mobile. This can look fantastic,
                but has the downside that it will not be dynamic. Sometimes, this is a tradeoff
                worth making.</paragraph>
            <paragraph>See <reference internal="True" refuri="../3d/global_illumination/using_lightmap_gi#doc-using-lightmap-gi"><inline classes="std std-ref">使用光照贴图全局照明</inline></reference> for instructions on using baked lightmaps. For
                best performance, you should set lights' bake mode to <strong>Static</strong> as opposed to
                the default <strong>Dynamic</strong>, as this will skip real-time lighting on meshes that
                have baked lighting.</paragraph>
            <paragraph>The downside of lights with the <strong>Static</strong> bake mode is that they can't cast
                shadows onto meshes with baked lighting. This can make scenes with outdoor
                environments and dynamic objects look flat. A good balance between performance
                and quality is to keep <strong>Dynamic</strong> for the <reference internal="True" refuri="../../classes/class_directionallight3d#class-directionallight3d"><inline classes="std std-ref">DirectionalLight3D</inline></reference> node,
                and use <strong>Static</strong> for most (if not all) omni and spot lights.</paragraph>
        </section>
        <section ids="animation-and-skinning" names="animation\ and\ skinning 动画和皮肤">
            <title>动画和皮肤</title>
            <paragraph>Animation and vertex animation such as skinning and morphing can be very
                expensive on some platforms. You may need to lower the polycount considerably
                for animated models, or limit the number of them on screen at any given time.
                You can also reduce the animation rate for distant or occluded meshes, or pause
                the animation entirely if the player is unlikely to notice the animation being
                stopped.</paragraph>
            <paragraph>The <reference internal="True" refuri="../../classes/class_visibleonscreenenabler3d#class-visibleonscreenenabler3d"><inline classes="std std-ref">VisibleOnScreenEnabler3D</inline></reference> and <reference internal="True" refuri="../../classes/class_visibleonscreennotifier3d#class-visibleonscreennotifier3d"><inline classes="std std-ref">VisibleOnScreenNotifier3D</inline></reference>
                nodes can be useful for this purpose.</paragraph>
        </section>
        <section ids="large-worlds" names="large\ worlds 庞大的世界">
            <title>庞大的世界</title>
            <paragraph>如果你要制作大型游戏, 则与小型游戏可能会有所不同.</paragraph>
            <paragraph>大型的世界可能需要用碎片建立, 可以在你在世界中移动时按需加载, 这可以防止内存使用失控, 也可以将所需的处理限制在局部区域.</paragraph>
            <paragraph>There may also be rendering and physics glitches due to floating point error in
                large worlds. This can be resolved using <reference internal="True" refuri="../physics/large_world_coordinates#doc-large-world-coordinates"><inline classes="std std-ref">大世界坐标</inline></reference>.
                If using large world coordinates is an option, you may be able to use techniques
                such as orienting the world around the player (rather than the other way
                around), or shifting the origin periodically to keep things centred around
                <literal>Vector3(0, 0, 0)</literal>.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
