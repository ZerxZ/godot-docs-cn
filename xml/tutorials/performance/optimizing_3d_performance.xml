<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/optimizing_3d_performance.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <meta content="optimization" name="keywords"></meta>
    <target refid="doc-optimizing-3d-performance"></target>
    <section ids="optimizing-3d-performance doc-optimizing-3d-performance" names="optimizing\ 3d\ performance doc_optimizing_3d_performance">
        <title>Optimizing 3D performance</title>
        <section ids="culling" names="culling">
            <title>Culling</title>
            <paragraph>Godot will automatically perform view frustum culling in order to prevent
                rendering objects that are outside the viewport. This works well for games that
                take place in a small area, however things can quickly become problematic in
                larger levels.</paragraph>
            <section ids="occlusion-culling" names="occlusion\ culling">
                <title>Occlusion culling</title>
                <paragraph>Walking around a town for example, you may only be able to see a few buildings
                    in the street you are in, as well as the sky and a few birds flying overhead. As
                    far as a naive renderer is concerned however, you can still see the entire town.
                    It won't just render the buildings in front of you, it will render the street
                    behind that, with the people on that street, the buildings behind that. You
                    quickly end up in situations where you are attempting to render 10× or 100× more
                    than what is visible.</paragraph>
                <paragraph>Things aren't quite as bad as they seem, because the Z-buffer usually allows the
                    GPU to only fully shade the objects that are at the front. This is called <emphasis>depth
                        prepass</emphasis> and is enabled by default in Godot when using the Forward+ or
                    Compatibility rendering methods. However, unneeded objects are still reducing
                    performance.</paragraph>
                <paragraph>One way we can potentially reduce the amount to be rendered is to <strong>take advantage
                        of occlusion</strong>. Godot offers an approach to occlusion culling
                    using occluder nodes. See <reference internal="True" refuri="../3d/occlusion_culling#doc-occlusion-culling"><inline classes="std std-ref">Occlusion culling</inline></reference> for instructions on
                    setting up occlusion culling in your scene.</paragraph>
                <note>
                    <paragraph>In some cases, you may have to adapt your level design to add more occlusion
                        opportunities. For example, you may have to add more walls to prevent the player
                        from seeing too far away, which would decrease performance due to the lost
                        opportunities for occlusion culling.</paragraph>
                </note>
            </section>
        </section>
        <section ids="transparent-objects" names="transparent\ objects">
            <title>Transparent objects</title>
            <paragraph>Godot sorts objects by <reference internal="True" refuri="../../classes/class_material#class-material"><inline classes="std std-ref">Material</inline></reference> and <reference internal="True" refuri="../../classes/class_shader#class-shader"><inline classes="std std-ref">Shader</inline></reference> to improve performance. This, however, can not be done with
                transparent objects. Transparent objects are rendered from back to front to make
                blending with what is behind work. As a result,
                <strong>try to use as few transparent objects as possible</strong>. If an object has a
                small section with transparency, try to make that section a separate surface
                with its own material.</paragraph>
            <paragraph>For more information, see the <reference internal="True" refuri="gpu_optimization#doc-gpu-optimization"><inline classes="std std-ref">GPU optimizations</inline></reference>
                doc.</paragraph>
        </section>
        <section ids="level-of-detail-lod" names="level\ of\ detail\ (lod)">
            <title>Level of detail (LOD)</title>
            <paragraph>In some situations, particularly at a distance, it can be a good idea to
                <strong>replace complex geometry with simpler versions</strong>. The end user will probably
                not be able to see much difference. Consider looking at a large number of trees
                in the far distance. There are several strategies for replacing models at
                varying distance. You could use lower poly models, or use transparency to
                simulate more complex geometry.</paragraph>
            <paragraph>Godot 4 offers several ways to control level of detail:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>An automatic approach on mesh import using <reference internal="True" refuri="../3d/mesh_lod#doc-mesh-lod"><inline classes="std std-ref">Mesh level of detail (LOD)</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>A manual approach configured in the 3D node using <reference internal="True" refuri="../3d/visibility_ranges#doc-visibility-ranges"><inline classes="std std-ref">Visibility ranges (HLOD)</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../3d/using_decals#doc-using-decals"><inline classes="std std-ref">Decals</inline></reference> and <reference internal="True" refuri="../3d/lights_and_shadows#doc-lights-and-shadows"><inline classes="std std-ref">lights</inline></reference>
                        can also benefit from level of detail using their respective
                        <strong>Distance Fade</strong> properties.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>While they can be used independently, these approaches are most effective when
                used together. For example, you can set up visibility ranges to hide particle
                effects that are too far away from the player to notice. At the same time, you
                can rely on mesh LOD to make the particle effect's meshes rendered with less
                detail at a distance.</paragraph>
            <paragraph>Visibility ranges are also a good way to set up <emphasis>impostors</emphasis> for distant geometry
                (see below).</paragraph>
            <section ids="billboards-and-imposters" names="billboards\ and\ imposters">
                <title>Billboards and imposters</title>
                <paragraph>The simplest version of using transparency to deal with LOD is billboards. For
                    example, you can use a single transparent quad to represent a tree at distance.
                    This can be very cheap to render, unless of course, there are many trees in
                    front of each other. In this case, transparency may start eating into fill rate
                    (for more information on fill rate, see <reference internal="True" refuri="gpu_optimization#doc-gpu-optimization"><inline classes="std std-ref">GPU optimization</inline></reference>).</paragraph>
                <paragraph>An alternative is to render not just one tree, but a number of trees together as
                    a group. This can be especially effective if you can see an area but cannot
                    physically approach it in a game.</paragraph>
                <paragraph>You can make imposters by pre-rendering views of an object at different angles.
                    Or you can even go one step further, and periodically re-render a view of an
                    object onto a texture to be used as an imposter. At a distance, you need to move
                    the viewer a considerable distance for the angle of view to change
                    significantly. This can be complex to get working, but may be worth it depending
                    on the type of project you are making.</paragraph>
            </section>
            <section ids="use-automatic-instancing" names="use\ automatic\ instancing">
                <title>Use automatic instancing</title>
                <paragraph><emphasis>This is only implemented in the Forward+ renderer, not Mobile or Compatibility.</emphasis></paragraph>
                <paragraph>If you have many identical objects in your scene, you can use automatic
                    instancing to reduce the number of draw calls. This automatically happens for
                    MeshInstance3D nodes that use the same mesh and material: no manual setup is required.</paragraph>
                <paragraph>For automatic instancing to be effective, the material must be opaque or
                    alpha-tested (alpha scissor or alpha hash). Alpha-blended or depth pre-pass
                    materials are never instanced this way. Instead, you must use MultiMesh as
                    described below.</paragraph>
            </section>
            <section ids="use-manual-instancing-multimesh" names="use\ manual\ instancing\ (multimesh)">
                <title>Use manual instancing (MultiMesh)</title>
                <paragraph>If several identical objects have to be drawn in the same place or nearby, try
                    using <reference internal="True" refuri="../../classes/class_multimesh#class-multimesh"><inline classes="std std-ref">MultiMesh</inline></reference> instead. MultiMesh allows the drawing
                    of many thousands of objects at very little performance cost, making it ideal
                    for flocks, grass, particles, and anything else where you have thousands of
                    identical objects.</paragraph>
                <paragraph>See also the <reference internal="True" refuri="using_multimesh#doc-using-multimesh"><inline classes="std std-ref">Using MultiMesh</inline></reference> documentation.</paragraph>
            </section>
        </section>
        <section ids="bake-lighting" names="bake\ lighting">
            <title>Bake lighting</title>
            <paragraph>Lighting objects is one of the most costly rendering operations. Realtime
                lighting, shadows (especially multiple lights), and
                <reference internal="True" refuri="../3d/global_illumination/introduction_to_global_illumination#doc-introduction-to-global-illumination"><inline classes="std std-ref">global illumination</inline></reference> are especially
                expensive. They may simply be too much for lower power mobile devices to handle.</paragraph>
            <paragraph><strong>Consider using baked lighting</strong>, especially for mobile. This can look fantastic,
                but has the downside that it will not be dynamic. Sometimes, this is a tradeoff
                worth making.</paragraph>
            <paragraph>See <reference internal="True" refuri="../3d/global_illumination/using_lightmap_gi#doc-using-lightmap-gi"><inline classes="std std-ref">Using Lightmap global illumination</inline></reference> for instructions on using baked lightmaps. For
                best performance, you should set lights' bake mode to <strong>Static</strong> as opposed to
                the default <strong>Dynamic</strong>, as this will skip real-time lighting on meshes that
                have baked lighting.</paragraph>
            <paragraph>The downside of lights with the <strong>Static</strong> bake mode is that they can't cast
                shadows onto meshes with baked lighting. This can make scenes with outdoor
                environments and dynamic objects look flat. A good balance between performance
                and quality is to keep <strong>Dynamic</strong> for the <reference internal="True" refuri="../../classes/class_directionallight3d#class-directionallight3d"><inline classes="std std-ref">DirectionalLight3D</inline></reference> node,
                and use <strong>Static</strong> for most (if not all) omni and spot lights.</paragraph>
        </section>
        <section ids="animation-and-skinning" names="animation\ and\ skinning">
            <title>Animation and skinning</title>
            <paragraph>Animation and vertex animation such as skinning and morphing can be very
                expensive on some platforms. You may need to lower the polycount considerably
                for animated models, or limit the number of them on screen at any given time.
                You can also reduce the animation rate for distant or occluded meshes, or pause
                the animation entirely if the player is unlikely to notice the animation being
                stopped.</paragraph>
            <paragraph>The <reference internal="True" refuri="../../classes/class_visibleonscreenenabler3d#class-visibleonscreenenabler3d"><inline classes="std std-ref">VisibleOnScreenEnabler3D</inline></reference> and <reference internal="True" refuri="../../classes/class_visibleonscreennotifier3d#class-visibleonscreennotifier3d"><inline classes="std std-ref">VisibleOnScreenNotifier3D</inline></reference>
                nodes can be useful for this purpose.</paragraph>
        </section>
        <section ids="large-worlds" names="large\ worlds">
            <title>Large worlds</title>
            <paragraph>If you are making large worlds, there are different considerations than what you
                may be familiar with from smaller games.</paragraph>
            <paragraph>Large worlds may need to be built in tiles that can be loaded on demand as you
                move around the world. This can prevent memory use from getting out of hand, and
                also limit the processing needed to the local area.</paragraph>
            <paragraph>There may also be rendering and physics glitches due to floating point error in
                large worlds. This can be resolved using <reference internal="True" refuri="../physics/large_world_coordinates#doc-large-world-coordinates"><inline classes="std std-ref">Large world coordinates</inline></reference>.
                If using large world coordinates is not an option, you may be able to use techniques
                such as orienting the world around the player (rather than the other way
                around), or shifting the origin periodically to keep things centred around
                <literal>Vector3(0, 0, 0)</literal>.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
