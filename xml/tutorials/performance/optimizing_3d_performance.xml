<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/optimizing_3d_performance.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <meta content="优化" name="keywords">
    </meta>
    <target refid="doc-optimizing-3d-performance"></target>
    <section ids="optimizing-3d-performance doc-optimizing-3d-performance" names="optimizing\ 3d\ performance 优化\ 3d\ 性能 doc_optimizing_3d_performance">
        <title>优化 3D 性能</title>
        <section ids="culling" names="culling 剔除">
            <title>剔除</title>
            <paragraph>Godot会自动执行视图视锥剔除, 以防止渲染视口外的物体. 这对于发生在小范围内的游戏来说效果很好, 然而在较大的关卡中, 事情很快就会变得很麻烦.</paragraph>
            <section ids="occlusion-culling" names="occlusion\ culling 遮挡剔除">
                <title>遮挡剔除</title>
                <paragraph>比如走在一个小镇上, 你可能只能看到你所在的街道上的几栋建筑, 以及天空和几只飞过头顶的鸟. 然而就一个天真的渲染器而言, 你仍然可以看到整个小镇. 它不会只渲染你前面的建筑, 它会渲染那后面的街道, 与那条街上的人, 那后面的建筑. 你很快就会遇到这样的情况: 你试图渲染比可见的东西多10倍或100倍的东西.</paragraph>
                <paragraph>Things aren't quite as bad as they seem, because the Z-buffer usually allows the
                    GPU to only fully shade the objects that are at the front. This is called <emphasis>depth
                        prepass</emphasis> and is enabled by default in Godot when using the Forward+ or
                    Compatibility rendering methods. However, unneeded objects are still reducing
                    performance.</paragraph>
                <paragraph>我们可以减少算绘量的一种方法是 <strong>take advantage of occlusion</strong>。Godot 4.0及更高版本提供了一种使用遮挡器节点进行遮蔽剔除的新方法。有关在场景中设定遮蔽剔除的说明，请参阅 <reference internal="True" refuri="../3d/occlusion_culling#doc-occlusion-culling"><inline classes="std std-ref">遮挡剔除</inline></reference> 。</paragraph>
                <note>
                    <paragraph>In some cases, you may have to adapt your level design to add more occlusion
                        opportunities. For example, you may have to add more walls to prevent the player
                        from seeing too far away, which would decrease performance due to the lost
                        opportunities for occlusion culling.</paragraph>
                </note>
            </section>
        </section>
        <section ids="transparent-objects" names="transparent\ objects 透明物体">
            <title>透明物体</title>
            <paragraph>Godot通过 <reference internal="True" refuri="../../classes/class_material#class-material"><inline classes="std std-ref">Material</inline></reference> 和 <reference internal="True" refuri="../../classes/class_shader#class-shader"><inline classes="std std-ref">Shader</inline></reference> 对对象进行排序以提高性能. 然而, 这对透明物体来说是不可能的. 透明物体从后往前渲染, 以便与后面的物体混合. 因此, <strong>尽量少使用透明对象</strong> . 如果一个物体有一小部分是透明的, 尽量让这部分成为一个独立的表面, 有自己的材质.</paragraph>
            <paragraph>更多信息请参阅 <reference internal="True" refuri="gpu_optimization#doc-gpu-optimization"><inline classes="std std-ref">GPU 优化</inline></reference> 文档。</paragraph>
        </section>
        <section ids="level-of-detail-lod" names="level\ of\ detail\ (lod) 细节程度（lod）">
            <title>细节程度（LOD）</title>
            <paragraph>在某些情况下, 特别是在远处, 用简单的版本**代替复杂的几何图形可能是个好主意. 最终用户可能看不出什么区别. 考虑看看远处的大量树木. 有几种策略可以替换不同距离的模型. 你可以使用较低的多边形模型, 或者使用透明度来模拟更复杂的几何体.</paragraph>
            <paragraph>Godot 4 提供了多种控制细节层次的方法：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>使用 <reference internal="True" refuri="../3d/mesh_lod#doc-mesh-lod"><inline classes="std std-ref">网格的细节级别（LOD）</inline></reference> 进行网格导入的自动方法。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>在3D节点中使用 :ref:<problematic ids="id2" refid="id1">`</problematic>doc_visibility_ranges`配置的手动方法。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>ref:<title_reference>Decals &lt;doc_using_decals&gt;</title_reference> 和 <reference internal="True" refuri="../3d/lights_and_shadows#doc-lights-and-shadows"><inline classes="std std-ref">lights</inline></reference> 也可以使用它们各自的 <strong>Distance Fade</strong> 属性从细节级别中获益。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>虽然它们可以单独使用，但一起使用时这些方法最有效。例如，你可以设定可见范围来隐藏距离玩家太远而无法注意到的粒子效果。同时，你可以依靠网格LOD来使粒子效果的网格在远处算绘时细节较少。</paragraph>
            <paragraph>可见范围也是为远处几何体设定「冒充者」的好方法（见下文）。</paragraph>
            <section ids="billboards-and-imposters" names="billboards\ and\ imposters billboard\ 和\ imposter">
                <title>Billboard 和 imposter</title>
                <paragraph>The simplest version of using transparency to deal with LOD is billboards. For
                    example, you can use a single transparent quad to represent a tree at distance.
                    This can be very cheap to render, unless of course, there are many trees in
                    front of each other. In this case, transparency may start eating into fill rate
                    (for more information on fill rate, see <reference internal="True" refuri="gpu_optimization#doc-gpu-optimization"><inline classes="std std-ref">GPU 优化</inline></reference>).</paragraph>
                <paragraph>另一种方法是不只渲染一棵树, 而是将一些树作为一组来渲染. 如果你能看到一个区域, 但在游戏中不能实际接近它, 这可能是特别有效的.</paragraph>
                <paragraph>你可以通过预先渲染对象的不同角度的视图来制作冒牌货. 或者你甚至可以更进一步, 周期性地将一个物体的视图重新渲染到一个纹理上, 作为一个冒牌货使用. 在远处, 你需要将观察者移动相当长的距离, 视角才会发生显著变化. 这可能是复杂的工作, 但可能是值得的, 这取决于你正在制作的项目类型.</paragraph>
            </section>
            <section ids="use-instancing-multimesh" names="use\ instancing\ (multimesh) 使用实例化（multimesh）">
                <title>使用实例化（MultiMesh）</title>
                <paragraph>如果必须在同一地点或附近绘制多个相同的对象, 请尝试使用 <reference internal="True" refuri="../../classes/class_multimesh#class-multimesh"><inline classes="std std-ref">MultiMesh</inline></reference> 来代替.MultiMesh允许以很小的性能代价来绘制成千上万的对象, 这使得它非常适合用于绘制羊群, 草地, 粒子以及其他任何有成千上万相同对象的地方.</paragraph>
                <paragraph>See also the <reference internal="True" refuri="using_multimesh#doc-using-multimesh"><inline classes="std std-ref">Using MultiMesh</inline></reference> documentation.</paragraph>
            </section>
        </section>
        <section ids="bake-lighting" names="bake\ lighting 烘焙照明">
            <title>烘焙照明</title>
            <paragraph>Lighting objects is one of the most costly rendering operations. Realtime
                lighting, shadows (especially multiple lights), and
                <reference internal="True" refuri="../3d/global_illumination/introduction_to_global_illumination#doc-introduction-to-global-illumination"><inline classes="std std-ref">global illumination</inline></reference> are especially
                expensive. They may simply be too much for lower power mobile devices to handle.</paragraph>
            <paragraph><strong>Consider using baked lighting</strong>, especially for mobile. This can look fantastic,
                but has the downside that it will not be dynamic. Sometimes, this is a tradeoff
                worth making.</paragraph>
            <paragraph>有关使用烘焙光照贴图的说明，请参阅doc_using_lightmap_gi。为了获得最佳性能，你应该将灯光的烘焙模式设定为 <strong>Static</strong> ，而不是预设的 <strong>Dynamic</strong>，因为这将跳过具有烘焙光照的网格体上的即时光照。</paragraph>
            <paragraph>使用 <strong>Static</strong> 烘焙模式的灯光的缺点是，它们无法将阴影投射到具有烘焙照明的网格上。这可以使具有室外环境和动态对象的场景看起来平坦。性能和质量之间的良好平衡是 <reference internal="True" refuri="../../classes/class_directionallight3d#class-directionallight3d"><inline classes="std std-ref">DirectionalLight3D</inline></reference> 节点保持 <strong>Dynamic</strong>，并对大多数（如果不是全部）泛光灯和聚光灯使用 <strong>Static</strong> 。</paragraph>
        </section>
        <section ids="animation-and-skinning" names="animation\ and\ skinning 动画和皮肤">
            <title>动画和皮肤</title>
            <paragraph>Animation and vertex animation such as skinning and morphing can be very
                expensive on some platforms. You may need to lower the polycount considerably
                for animated models, or limit the number of them on screen at any given time.
                You can also reduce the animation rate for distant or occluded meshes, or pause
                the animation entirely if the player is unlikely to notice the animation being
                stopped.</paragraph>
            <paragraph><reference internal="True" refuri="../../classes/class_visibleonscreenenabler3d#class-visibleonscreenenabler3d"><inline classes="std std-ref">VisibleOnScreenEnabler3D</inline></reference> 和 <reference internal="True" refuri="../../classes/class_visibleonscreennotifier3d#class-visibleonscreennotifier3d"><inline classes="std std-ref">VisibleOnScreenNotifier3D</inline></reference> 节点可用于此目的。</paragraph>
        </section>
        <section ids="large-worlds" names="large\ worlds 庞大的世界">
            <title>庞大的世界</title>
            <paragraph>如果你要制作大型游戏, 则与小型游戏可能会有所不同.</paragraph>
            <paragraph>大型的世界可能需要用碎片建立, 可以在你在世界中移动时按需加载, 这可以防止内存使用失控, 也可以将所需的处理限制在局部区域.</paragraph>
            <paragraph>There may also be rendering and physics glitches due to floating point error in
                large worlds. This can be resolved using <reference internal="True" refuri="../physics/large_world_coordinates#doc-large-world-coordinates"><inline classes="std std-ref">大世界坐标</inline></reference>.
                If using large world coordinates is not an option, you may be able to use techniques
                such as orienting the world around the player (rather than the other way
                around), or shifting the origin periodically to keep things centred around
                <literal>Vector3(0, 0, 0)</literal>.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
