<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/cpu_optimization.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-cpu-optimization"></target>
    <section ids="cpu-optimization doc-cpu-optimization" names="cpu\ optimization doc_cpu_optimization">
        <title>CPU optimization</title>
        <section ids="measuring-performance" names="measuring\ performance">
            <title>Measuring performance</title>
            <paragraph>We have to know where the "bottlenecks" are to know how to speed up our program.
                Bottlenecks are the slowest parts of the program that limit the rate that
                everything can progress. Focusing on bottlenecks allows us to concentrate our
                efforts on optimizing the areas which will give us the greatest speed
                improvement, instead of spending a lot of time optimizing functions that will
                lead to small performance improvements.</paragraph>
            <paragraph>For the CPU, the easiest way to identify bottlenecks is to use a profiler.</paragraph>
        </section>
        <section ids="cpu-profilers" names="cpu\ profilers">
            <title>CPU profilers</title>
            <paragraph>Profilers run alongside your program and take timing measurements to work out
                what proportion of time is spent in each function.</paragraph>
            <paragraph>The Godot IDE conveniently has a built-in profiler. It does not run every time
                you start your project: it must be manually started and stopped. This is
                because, like most profilers, recording these timing measurements can
                slow down your project significantly.</paragraph>
            <paragraph>After profiling, you can look back at the results for a frame.</paragraph>
            <figure align="center" ids="id2">
                <image alt="Screenshot of the Godot profiler" candidates="{'*': 'tutorials/performance/img/godot_profiler.png'}" original_uri="img/godot_profiler.png" uri="tutorials/performance/img/godot_profiler.png"></image>
                <caption>Results of a profile of one of the demo projects.</caption>
            </figure>
            <note>
                <paragraph>We can see the cost of built-in processes such as physics and audio,
                    as well as seeing the cost of our own scripting functions at the
                    bottom.</paragraph>
                <paragraph>Time spent waiting for various built-in servers may not be counted in
                    the profilers. This is a known bug.</paragraph>
            </note>
            <paragraph>When a project is running slowly, you will often see an obvious function or
                process taking a lot more time than others. This is your primary bottleneck, and
                you can usually increase speed by optimizing this area.</paragraph>
            <paragraph>For more info about using Godot's built-in profiler, see
                <reference internal="True" refuri="../scripting/debug/debugger_panel#doc-debugger-panel"><inline classes="std std-ref">Debugger panel</inline></reference>.</paragraph>
        </section>
        <section ids="external-profilers" names="external\ profilers">
            <title>External profilers</title>
            <paragraph>Although the Godot IDE profiler is very convenient and useful, sometimes you
                need more power, and the ability to profile the Godot engine source code itself.</paragraph>
            <paragraph>You can <reference internal="True" refuri="../../engine_details/development/debugging/using_cpp_profilers#doc-using-cpp-profilers"><inline classes="std std-ref">use a number of third-party C++ profilers</inline></reference>
                to do this.</paragraph>
            <figure ids="id3">
                <image alt="Screenshot of Callgrind" candidates="{'*': 'tutorials/performance/img/valgrind.png'}" original_uri="img/valgrind.png" uri="tutorials/performance/img/valgrind.png"></image>
                <caption>Example results from Callgrind, which is part of Valgrind.</caption>
            </figure>
            <paragraph>From the left, Callgrind is listing the percentage of time within a function and
                its children (Inclusive), the percentage of time spent within the function
                itself, excluding child functions (Self), the number of times the function is
                called, the function name, and the file or module.</paragraph>
            <paragraph>In this example, we can see nearly all time is spent under the
                <literal>Main::iteration()</literal> function. This is the master function in the Godot source
                code that is called repeatedly. It causes frames to be drawn, physics ticks to
                be simulated, and nodes and scripts to be updated. A large proportion of the
                time is spent in the functions to render a canvas (66%), because this example
                uses a 2D benchmark. Below this, we see that almost 50% of the time is spent
                outside Godot code in <literal>libglapi</literal> and <literal>i965_dri</literal> (the graphics driver).
                This tells us the a large proportion of CPU time is being spent in the
                graphics driver.</paragraph>
            <paragraph>This is actually an excellent example because, in an ideal world, only a very
                small proportion of time would be spent in the graphics driver. This is an
                indication that there is a problem with too much communication and work being
                done in the graphics API. This specific profiling led to the development of 2D
                batching, which greatly speeds up 2D rendering by reducing bottlenecks in this
                area.</paragraph>
        </section>
        <section ids="manually-timing-functions" names="manually\ timing\ functions">
            <title>Manually timing functions</title>
            <paragraph>Another handy technique, especially once you have identified the bottleneck
                using a profiler, is to manually time the function or area under test.
                The specifics vary depending on the language, but in GDScript, you would do
                the following:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var time_start = Time.get_ticks_usec()

# Your function you want to time
update_enemies()

var time_end = Time.get_ticks_usec()
print("update_enemies() took %d microseconds" % (time_end - time_start))</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var timeStart = Time.GetTicksUsec();

// Your function you want to time.
UpdateEnemies();

var timeEnd = Time.GetTicksUsec();
GD.Print($"UpdateEnemies() took {timeEnd - timeStart} microseconds");</literal_block>
                </div>
            </container>
            <paragraph>When manually timing functions, it is usually a good idea to run the function
                many times (1,000 or more times), instead of just once (unless it is a very slow
                function). The reason for doing this is that timers often have limited accuracy.
                Moreover, CPUs will schedule processes in a haphazard manner. Therefore, an
                average over a series of runs is more accurate than a single measurement.</paragraph>
            <paragraph>As you attempt to optimize functions, be sure to either repeatedly profile or
                time them as you go. This will give you crucial feedback as to whether the
                optimization is working (or not).</paragraph>
        </section>
        <section ids="caches" names="caches">
            <title>Caches</title>
            <paragraph>CPU caches are something else to be particularly aware of, especially when
                comparing timing results of two different versions of a function. The results
                can be highly dependent on whether the data is in the CPU cache or not. CPUs
                don't load data directly from the system RAM, even though it's huge in
                comparison to the CPU cache (several gigabytes instead of a few megabytes). This
                is because system RAM is very slow to access. Instead, CPUs load data from a
                smaller, faster bank of memory called cache. Loading data from cache is very
                fast, but every time you try and load a memory address that is not stored in
                cache, the cache must make a trip to main memory and slowly load in some data.
                This delay can result in the CPU sitting around idle for a long time, and is
                referred to as a "cache miss".</paragraph>
            <paragraph>This means that the first time you run a function, it may run slowly because the
                data is not in the CPU cache. The second and later times, it may run much faster
                because the data is in the cache. Due to this, always use averages when timing,
                and be aware of the effects of cache.</paragraph>
            <paragraph>Understanding caching is also crucial to CPU optimization. If you have an
                algorithm (routine) that loads small bits of data from randomly spread out areas
                of main memory, this can result in a lot of cache misses, a lot of the time, the
                CPU will be waiting around for data instead of doing any work. Instead, if you
                can make your data accesses localised, or even better, access memory in a linear
                fashion (like a continuous list), then the cache will work optimally and the CPU
                will be able to work as fast as possible.</paragraph>
            <paragraph>Godot usually takes care of such low-level details for you. For example, the
                Server APIs make sure data is optimized for caching already for things like
                rendering and physics. Still, you should be especially aware of caching when
                writing GDExtensions.</paragraph>
        </section>
        <section ids="languages" names="languages">
            <title>Languages</title>
            <paragraph>Godot supports a number of different languages, and it is worth bearing in mind
                that there are trade-offs involved. Some languages are designed for ease of use
                at the cost of speed, and others are faster but more difficult to work with.</paragraph>
            <paragraph>Built-in engine functions run at the same speed regardless of the scripting
                language you choose. If your project is making a lot of calculations in its own
                code, consider moving those calculations to a faster language.</paragraph>
            <section ids="gdscript" names="gdscript">
                <title>GDScript</title>
                <paragraph><reference internal="True" refuri="../scripting/gdscript/index#doc-gdscript"><inline classes="std std-ref">GDScript</inline></reference> is designed to be easy to use and iterate,
                    and is ideal for making many types of games. However, in this language, ease of
                    use is considered more important than performance. If you need to make heavy
                    calculations, consider moving some of your project to one of the other
                    languages.</paragraph>
            </section>
            <section ids="c" names="c#">
                <title>C#</title>
                <paragraph><reference internal="True" refuri="../scripting/c_sharp/index#doc-c-sharp"><inline classes="std std-ref">C#</inline></reference> is popular and has first-class support in Godot. It
                    offers a good compromise between speed and ease of use. Beware of possible
                    garbage collection pauses and leaks that can occur during gameplay, though. A
                    common approach to workaround issues with garbage collection is to use <emphasis>object
                        pooling</emphasis>, which is outside the scope of this guide.</paragraph>
            </section>
            <section ids="other-languages" names="other\ languages">
                <title>Other languages</title>
                <paragraph>Third parties provide support for several other languages, including <reference name="Rust" refuri="https://github.com/godot-rust/gdext">Rust</reference><target ids="rust" names="rust" refuri="https://github.com/godot-rust/gdext"></target>.</paragraph>
            </section>
            <section ids="id1" names="c++">
                <title>C++</title>
                <paragraph>Godot is written in C++. Using C++ will usually result in the fastest code.
                    However, on a practical level, it is the most difficult to deploy to end users'
                    machines on different platforms. Options for using C++ include
                    GDExtensions and
                    <reference internal="True" refuri="../../engine_details/architecture/custom_modules_in_cpp#doc-custom-modules-in-cpp"><inline classes="std std-ref">custom modules</inline></reference>.</paragraph>
            </section>
        </section>
        <section ids="threads" names="threads">
            <title>Threads</title>
            <paragraph>Consider using threads when making a lot of calculations that can run in
                parallel to each other. Modern CPUs have multiple cores, each one capable of
                doing a limited amount of work. By spreading work over multiple threads, you can
                move further towards peak CPU efficiency.</paragraph>
            <paragraph>The disadvantage of threads is that you have to be incredibly careful. As each
                CPU core operates independently, they can end up trying to access the same
                memory at the same time. One thread can be reading to a variable while another
                is writing: this is called a <emphasis>race condition</emphasis>. Before you use threads, make sure
                you understand the dangers and how to try and prevent these race conditions.
                Threads can make debugging considerably more difficult.</paragraph>
            <paragraph>For more information on threads, see <reference internal="True" refuri="using_multiple_threads#doc-using-multiple-threads"><inline classes="std std-ref">Using multiple threads</inline></reference>.</paragraph>
        </section>
        <section ids="scenetree" names="scenetree">
            <title>SceneTree</title>
            <paragraph>Although Nodes are an incredibly powerful and versatile concept, be aware that
                every node has a cost. Built-in functions such as <literal>_process()</literal> and
                <literal>_physics_process()</literal> propagate through the tree. This housekeeping can reduce
                performance when you have a very large numbers of nodes (how many exactly
                depends on the target platform and can range from thousands to tens of
                thousands so ensure that you profile performance on all target platforms
                during development).</paragraph>
            <paragraph>Each node is handled individually in the Godot renderer. Therefore, a smaller
                number of nodes with more in each can lead to better performance.</paragraph>
            <paragraph>One quirk of the <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> is that you can sometimes
                get much better performance by removing nodes from the SceneTree, rather than by
                pausing or hiding them. You don't have to delete a detached node. You can for
                example, keep a reference to a node, detach it from the scene tree using
                <reference internal="True" refuri="../../classes/class_node#class-node-method-remove-child"><inline classes="std std-ref">Node.remove_child(node)</inline></reference>, then reattach
                it later using <reference internal="True" refuri="../../classes/class_node#class-node-method-add-child"><inline classes="std std-ref">Node.add_child(node)</inline></reference>.
                This can be very useful for adding and removing areas from a game, for example.</paragraph>
            <paragraph>You can avoid the SceneTree altogether by using Server APIs. For more
                information, see <reference internal="True" refuri="using_servers#doc-using-servers"><inline classes="std std-ref">Optimization using Servers</inline></reference>.</paragraph>
        </section>
        <section ids="physics" names="physics">
            <title>Physics</title>
            <paragraph>In some situations, physics can end up becoming a bottleneck. This is
                particularly the case with complex worlds and large numbers of physics objects.</paragraph>
            <paragraph>Here are some techniques to speed up physics:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Try using simplified versions of your rendered geometry for collision shapes.
                        Often, this won't be noticeable for end users, but can greatly increase
                        performance.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Try removing objects from physics when they are out of view / outside the
                        current area, or reusing physics objects (maybe you allow 8 monsters per area,
                        for example, and reuse these).</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Another crucial aspect to physics is the physics tick rate. In some games, you
                can greatly reduce the tick rate, and instead of for example, updating physics
                60 times per second, you may update them only 30 or even 20 times per second.
                This can greatly reduce the CPU load.</paragraph>
            <paragraph>The downside of changing physics tick rate is you can get jerky movement or
                jitter when the physics update rate does not match the frames per second
                rendered. Also, decreasing the physics tick rate will increase input lag.
                It's recommended to stick to the default physics tick rate (60 Hz) in most games
                that feature real-time player movement.</paragraph>
            <paragraph>The solution to jitter is to use <emphasis>fixed timestep interpolation</emphasis>, which involves
                smoothing the rendered positions and rotations over multiple frames to match the
                physics. Godot has built-in physics interpolation which you can read about
                <reference internal="True" refuri="../physics/interpolation/index#doc-physics-interpolation"><inline classes="std std-ref">here</inline></reference>.
                Performance-wise, interpolation is a very cheap operation compared to running a
                physics tick. It's orders of magnitude faster, so this can be a significant
                performance win while also reducing jitter.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
