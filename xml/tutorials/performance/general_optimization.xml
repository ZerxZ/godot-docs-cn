<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/general_optimization.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-general-optimization"></target>
    <section ids="general-optimization-tips doc-general-optimization" names="general\ optimization\ tips doc_general_optimization">
        <title>General optimization tips</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>In an ideal world, computers would run at infinite speed. The only limit to
                what we could achieve would be our imagination. However, in the real world, it's
                all too easy to produce software that will bring even the fastest computer to
                its knees.</paragraph>
            <paragraph>Thus, designing games and other software is a compromise between what we would
                like to be possible, and what we can realistically achieve while maintaining
                good performance.</paragraph>
            <paragraph>To achieve the best results, we have two approaches:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Work faster.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Work smarter.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>And preferably, we will use a blend of the two.</paragraph>
            <section ids="smoke-and-mirrors" names="smoke\ and\ mirrors">
                <title>Smoke and mirrors</title>
                <paragraph>Part of working smarter is recognizing that, in games, we can often get the
                    player to believe they're in a world that is far more complex, interactive, and
                    graphically exciting than it really is. A good programmer is a magician, and
                    should strive to learn the tricks of the trade while trying to invent new ones.</paragraph>
            </section>
            <section ids="the-nature-of-slowness" names="the\ nature\ of\ slowness">
                <title>The nature of slowness</title>
                <paragraph>To the outside observer, performance problems are often lumped together.
                    But in reality, there are several different kinds of performance problems:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>A slow process that occurs every frame, leading to a continuously low frame
                            rate.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>An intermittent process that causes "spikes" of slowness, leading to
                            stalls.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>A slow process that occurs outside of normal gameplay, for instance,
                            when loading a level.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Each of these are annoying to the user, but in different ways.</paragraph>
            </section>
        </section>
        <section ids="measuring-performance" names="measuring\ performance">
            <title>Measuring performance</title>
            <paragraph>Probably the most important tool for optimization is the ability to measure
                performance - to identify where bottlenecks are, and to measure the success of
                our attempts to speed them up.</paragraph>
            <paragraph>There are several methods of measuring performance, including:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Putting a start/stop timer around code of interest.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Using the <reference internal="True" refuri="../scripting/debug/the_profiler#doc-the-profiler"><inline classes="std std-ref">Godot profiler</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Using <reference internal="True" refuri="../../engine_details/development/debugging/using_cpp_profilers#doc-using-cpp-profilers"><inline classes="std std-ref">external CPU profilers</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Using external GPU profilers/debuggers such as
                        <reference name="NVIDIA Nsight Graphics" refuri="https://developer.nvidia.com/nsight-graphics">NVIDIA Nsight Graphics</reference>,
                        <reference name="Radeon GPU Profiler" refuri="https://gpuopen.com/rgp/">Radeon GPU Profiler</reference>,
                        <reference name="PIX" refuri="https://devblogs.microsoft.com/pix/download/">PIX</reference> (Direct3D 12 only),
                        <reference name="Xcode" refuri="https://developer.apple.com/documentation/xcode/optimizing-gpu-performance">Xcode</reference> (Metal only), or
                        <reference name="Arm Performance Studio" refuri="https://developer.arm.com/Tools%20and%20Software/Arm%20Performance%20Studio">Arm Performance Studio</reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Checking the frame rate (with V-Sync disabled). Third-party utilities such as
                        <reference name="RivaTuner Statistics Server" refuri="https://www.guru3d.com/files-details/rtss-rivatuner-statistics-server-download.html">RivaTuner Statistics Server</reference> (Windows),
                        <reference name="Special K" refuri="https://www.special-k.info/">Special K</reference> (Windows),
                        or <reference name="MangoHud" refuri="https://github.com/flightlessmango/MangoHud">MangoHud</reference>
                        (Linux) can also be useful here.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Using an unofficial <reference name="debug menu add-on" refuri="https://github.com/godot-extended-libraries/godot-debug-menu">debug menu add-on</reference>.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Be very aware that the relative performance of different areas can vary on
                different hardware. It's often a good idea to measure timings on more than one
                device. This is especially the case if you're targeting mobile devices.</paragraph>
            <section ids="limitations" names="limitations">
                <title>Limitations</title>
                <paragraph>CPU profilers are often the go-to method for measuring performance. However,
                    they don't always tell the whole story.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Bottlenecks are often on the GPU, "as a result" of instructions given by the
                            CPU.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Spikes can occur in the operating system processes (outside of Godot) "as a
                            result" of instructions used in Godot (for example, dynamic memory allocation).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>You may not always be able to profile specific devices like a mobile phone
                            due to the initial setup required.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>You may have to solve performance problems that occur on hardware you don't
                            have access to.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>As a result of these limitations, you often need to use detective work to find
                    out where bottlenecks are.</paragraph>
            </section>
        </section>
        <section ids="detective-work" names="detective\ work">
            <title>Detective work</title>
            <paragraph>Detective work is a crucial skill for developers (both in terms of performance,
                and also in terms of bug fixing). This can include hypothesis testing, and
                binary search.</paragraph>
            <section ids="hypothesis-testing" names="hypothesis\ testing">
                <title>Hypothesis testing</title>
                <paragraph>Say, for example, that you believe sprites are slowing down your game.
                    You can test this hypothesis by:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Measuring the performance when you add more sprites, or take some away.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>This may lead to a further hypothesis: does the size of the sprite determine
                    the performance drop?</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>You can test this by keeping everything the same, but changing the sprite
                            size, and measuring performance.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="binary-search" names="binary\ search">
                <title>Binary search</title>
                <paragraph>If you know that frames are taking much longer than they should, but you're
                    not sure where the bottleneck lies. You could begin by commenting out
                    approximately half the routines that occur on a normal frame. Has the
                    performance improved more or less than expected?</paragraph>
                <paragraph>Once you know which of the two halves contains the bottleneck, you can
                    repeat this process until you've pinned down the problematic area.</paragraph>
            </section>
        </section>
        <section ids="profilers" names="profilers">
            <title>Profilers</title>
            <paragraph>Profilers allow you to time your program while running it. Profilers then
                provide results telling you what percentage of time was spent in different
                functions and areas, and how often functions were called.</paragraph>
            <paragraph>This can be very useful both to identify bottlenecks and to measure the results
                of your improvements. Sometimes, attempts to improve performance can backfire
                and lead to slower performance.
                <strong>Always use profiling and timing to guide your efforts.</strong></paragraph>
            <paragraph>For more info about using Godot's built-in profiler, see <reference internal="True" refuri="../scripting/debug/the_profiler#doc-the-profiler"><inline classes="std std-ref">The Profiler</inline></reference>.</paragraph>
        </section>
        <section ids="principles" names="principles">
            <title>Principles</title>
            <paragraph><reference name="Donald Knuth" refuri="https://en.wikipedia.org/wiki/Donald_Knuth">Donald Knuth</reference> said:</paragraph>
            <block_quote>
                <paragraph><emphasis>Programmers waste enormous amounts of time thinking about, or worrying
                        about, the speed of noncritical parts of their programs, and these attempts
                        at efficiency actually have a strong negative impact when debugging and
                        maintenance are considered. We should forget about small efficiencies, say
                        about 97% of the time: premature optimization is the root of all evil. Yet
                        we should not pass up our opportunities in that critical 3%.</emphasis></paragraph>
            </block_quote>
            <paragraph>The messages are very important:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Developer time is limited. Instead of blindly trying to speed up
                        all aspects of a program, we should concentrate our efforts on the aspects
                        that really matter.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Efforts at optimization often end up with code that is harder to read and
                        debug than non-optimized code. It is in our interests to limit this to areas
                        that will really benefit.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Just because we <emphasis>can</emphasis> optimize a particular bit of code, it doesn't necessarily
                mean that we <emphasis>should</emphasis>. Knowing when and when not to optimize is a great skill to
                develop.</paragraph>
            <paragraph>One misleading aspect of the quote is that people tend to focus on the subquote
                <emphasis>"premature optimization is the root of all evil"</emphasis>. While <emphasis>premature</emphasis>
                optimization is (by definition) undesirable, performant software is the result
                of performant design.</paragraph>
            <section ids="performant-design" names="performant\ design">
                <title>Performant design</title>
                <paragraph>The danger with encouraging people to ignore optimization until necessary, is
                    that it conveniently ignores that the most important time to consider
                    performance is at the design stage, before a key has even hit a keyboard. If the
                    design or algorithms of a program are inefficient, then no amount of polishing
                    the details later will make it run fast. It may run <emphasis>faster</emphasis>, but it will never
                    run as fast as a program designed for performance.</paragraph>
                <paragraph>This tends to be far more important in game or graphics programming than in
                    general programming. A performant design, even without low-level optimization,
                    will often run many times faster than a mediocre design with low-level
                    optimization.</paragraph>
            </section>
            <section ids="incremental-design" names="incremental\ design">
                <title>Incremental design</title>
                <paragraph>Of course, in practice, unless you have prior knowledge, you are unlikely to
                    come up with the best design the first time. Instead, you'll often make a series
                    of versions of a particular area of code, each taking a different approach to
                    the problem, until you come to a satisfactory solution. It's important not to
                    spend too much time on the details at this stage until you have finalized the
                    overall design. Otherwise, much of your work will be thrown out.</paragraph>
                <paragraph>It's difficult to give general guidelines for performant design because this is
                    so dependent on the problem. One point worth mentioning though, on the CPU side,
                    is that modern CPUs are nearly always limited by memory bandwidth. This has led
                    to a resurgence in data-oriented design, which involves designing data
                    structures and algorithms for <emphasis>cache locality</emphasis> of data and linear access, rather
                    than jumping around in memory.</paragraph>
            </section>
            <section ids="the-optimization-process" names="the\ optimization\ process">
                <title>The optimization process</title>
                <paragraph>Assuming we have a reasonable design, and taking our lessons from Knuth, our
                    first step in optimization should be to identify the biggest bottlenecks - the
                    slowest functions, the low-hanging fruit.</paragraph>
                <paragraph>Once we've successfully improved the speed of the slowest area, it may no
                    longer be the bottleneck. So we should test/profile again and find the next
                    bottleneck on which to focus.</paragraph>
                <paragraph>The process is thus:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>Profile / Identify bottleneck.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Optimize bottleneck.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Return to step 1.</paragraph>
                    </list_item>
                </enumerated_list>
            </section>
            <section ids="optimizing-bottlenecks" names="optimizing\ bottlenecks">
                <title>Optimizing bottlenecks</title>
                <paragraph>Some profilers will even tell you which part of a function (which data accesses,
                    calculations) are slowing things down.</paragraph>
                <paragraph>As with design, you should concentrate your efforts first on making sure the
                    algorithms and data structures are the best they can be. Data access should be
                    local (to make best use of CPU cache), and it can often be better to use compact
                    storage of data (again, always profile to test results). Often, you precalculate
                    heavy computations ahead of time. This can be done by performing the computation
                    when loading a level, by loading a file containing precalculated data, or
                    by storing the results of complex calculations into a script constant and
                    reading its value.</paragraph>
                <paragraph>Once algorithms and data are good, you can often make small changes in routines
                    which improve performance. For instance, you can move some calculations outside
                    of loops or transform nested <literal>for</literal> loops into non-nested loops.
                    (This should be feasible if you know a 2D array's width or height in advance.)</paragraph>
                <paragraph>Always retest your timing/bottlenecks after making each change. Some changes
                    will increase speed, others may have a negative effect. Sometimes, a small
                    positive effect will be outweighed by the negatives of more complex code, and
                    you may choose to leave out that optimization.</paragraph>
            </section>
        </section>
        <section ids="appendix" names="appendix">
            <title>Appendix</title>
            <section ids="bottleneck-math" names="bottleneck\ math">
                <title>Bottleneck math</title>
                <paragraph>The proverb <emphasis>"a chain is only as strong as its weakest link"</emphasis> applies directly to
                    performance optimization. If your project is spending 90% of the time in
                    function <literal>A</literal>, then optimizing <literal>A</literal> can have a massive effect on performance.</paragraph>
                <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">A: 9 ms
Everything else: 1 ms
Total frame time: 10 ms</literal_block>
                <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">A: 1 ms
Everything else: 1ms
Total frame time: 2 ms</literal_block>
                <paragraph>In this example, improving this bottleneck <literal>A</literal> by a factor of 9× decreases
                    overall frame time by 5× while increasing frames per second by 5×.</paragraph>
                <paragraph>However, if something else is running slowly and also bottlenecking your
                    project, then the same improvement can lead to less dramatic gains:</paragraph>
                <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">A: 9 ms
Everything else: 50 ms
Total frame time: 59 ms</literal_block>
                <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">A: 1 ms
Everything else: 50 ms
Total frame time: 51 ms</literal_block>
                <paragraph>In this example, even though we have hugely optimized function <literal>A</literal>,
                    the actual gain in terms of frame rate is quite small.</paragraph>
                <paragraph>In games, things become even more complicated because the CPU and GPU run
                    independently of one another. Your total frame time is determined by the slower
                    of the two.</paragraph>
                <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">CPU: 9 ms
GPU: 50 ms
Total frame time: 50 ms</literal_block>
                <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">CPU: 1 ms
GPU: 50 ms
Total frame time: 50 ms</literal_block>
                <paragraph>In this example, we optimized the CPU hugely again, but the frame time didn't
                    improve because we are GPU-bottlenecked.</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
