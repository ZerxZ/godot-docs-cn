<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/using_servers.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-servers"></target>
    <section ids="optimization-using-servers doc-using-servers" names="optimization\ using\ servers 利用服务器进行优化 doc_using_servers">
        <title>利用服务器进行优化</title>
        <paragraph>像 Godot 这样的引擎，由于其更高层次的构建和功能，提供了更多的易用性。它们中的大多数都是通过<reference internal="True" refuri="../scripting/scene_tree#doc-scene-tree"><inline classes="std std-ref">场景系统</inline></reference>来访问和使用的。使用节点和资源可以简化复杂游戏中的项目组织和资产管理。</paragraph>
        <paragraph>当然, 总是有缺点的:</paragraph>
        <bullet_list bullet="*">
            <list_item>
                <paragraph>那有一个额外复杂层。</paragraph>
            </list_item>
            <list_item>
                <paragraph>性能比直接使用简单API要低。</paragraph>
            </list_item>
            <list_item>
                <paragraph>无法使用多个线程来控制它们。</paragraph>
            </list_item>
            <list_item>
                <paragraph>需要更多的内存.</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>在很多情况下, 这并不是一个真正的问题(Godot是非常优化的, 大多数操作都是用信号处理的, 所以不需要轮询). 不过, 有时候还是会有这样的情况. 例如, 对于每一帧都需要处理的东西来说, 处理数以万计的实例可能是一个瓶颈.</paragraph>
        <paragraph>这种情况会让程序员后悔自己使用的是游戏引擎, 希望能回到更加手动, 更加低层的游戏代码实现中去.</paragraph>
        <paragraph>当然,Godot的设计工作中还是可以解决这个问题.</paragraph>
        <seealso>
            <paragraph>你可以使用`Bullet Shower 演示项目 &lt;<reference refuri="https://github.com/godotengine/godot-demo-projects/tree/master/2d/bullet_shower">https://github.com/godotengine/godot-demo-projects/tree/master/2d/bullet_shower</reference>&gt;`__ 来了解如何使用低阶服务器</paragraph>
        </seealso>
        <section ids="servers" names="servers 服务器">
            <title>服务器</title>
            <paragraph>Godot 有许多非常有趣的设计决定，其中之一就是整个场景系统都是<emphasis>可选的</emphasis>。虽然目前还不能在编译时去除，但你完全可以绕过它。</paragraph>
            <paragraph>Godot 在核心中使用了“服务器”的概念。它们是非常底层的 API，用来控制渲染、物理、声音等。场景系统建立在它们之上，直接使用它们。最常见的服务器有：</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_renderingserver#class-renderingserver"><inline classes="std std-ref">RenderingServer</inline></reference>: 处理所有与图形相关的内容。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_physicsserver3d#class-physicsserver3d"><inline classes="std std-ref">PhysicsServer3D</inline></reference>: 处理所有与 3D 物理相关的内容。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_physicsserver2d#class-physicsserver2d"><inline classes="std std-ref">PhysicsServer2D</inline></reference>: 处理所有与 2D 物理相关的内容。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_audioserver#class-audioserver"><inline classes="std std-ref">AudioServer</inline></reference>: 处理与音频相关的一切.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>你只需研究它们的 API 就会意识到，它们所提供的函数全部都是 Godot 允许你所进行的操作的底层实现。</paragraph>
        </section>
        <section ids="rids" names="rids rid">
            <title>RID</title>
            <paragraph>使用服务器的关键是理解资源 ID（Resource ID，即 <reference internal="True" refuri="../../classes/class_rid#class-rid"><inline classes="std std-ref">RID</inline></reference>）对象。这些对象是服务器实现的非公开的句柄。它们是手动分配和释放的。几乎服务器中的每个功能都需要 RID 来访问实际的资源。</paragraph>
            <paragraph>大多数 Godot 节点和资源都包含这些来自服务内部的 RID，它们可以通过不同的函数获得。事实上，任何继承 <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> 的东西都可以直接转换成 RID。不过并不是所有资源都包含 RID：在这种情况下，RID 为空。可以用 RID 的形式将资源传递给服务器 API。</paragraph>
            <warning>
                <paragraph>资源是引用计数的（参阅 <reference internal="True" refuri="../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference>），并且对资源 RID 的引用在确定资源仍在使用时 <emphasis>不</emphasis> 进行计数。请确保在服务外部保持对资源的引用，否则将删除资源及其 RID 。</paragraph>
            </warning>
            <paragraph>对于节点来说, 有很多函数功能可以使用:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>对于 CanvasItem，<reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-get-canvas-item"><inline classes="std std-ref">CanvasItem.get_canvas_item()</inline></reference> 方法将在服务器中返回该画布项目的 RID。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>对于CanvasLayer来说, <reference internal="True" refuri="../../classes/class_canvaslayer#class-canvaslayer-method-get-canvas"><inline classes="std std-ref">CanvasLayer.get_canvas()</inline></reference> 方法将返回服务器中的canvas RID.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>对于视口, <reference internal="True" refuri="../../classes/class_viewport#class-viewport-method-get-viewport-rid"><inline classes="std std-ref">Viewport.get_viewport_rid()</inline></reference> 方法将返回服务器中的视口RID.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>For 3D, the <reference internal="True" refuri="../../classes/class_world3d#class-world3d"><inline classes="std std-ref">World3D</inline></reference> resource (obtainable in the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>
                        and <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> nodes)
                        contains functions to get the <emphasis>RenderingServer Scenario</emphasis>, and the <emphasis>PhysicsServer Space</emphasis>. This
                        allows creating 3D objects directly with the server API and using them.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>For 2D, the <reference internal="True" refuri="../../classes/class_world2d#class-world2d"><inline classes="std std-ref">World2D</inline></reference> resource (obtainable in the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>
                        and <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference> nodes)
                        contains functions to get the <emphasis>RenderingServer Canvas</emphasis>, and the <emphasis>Physics2DServer Space</emphasis>. This
                        allows creating 2D objects directly with the server API and using them.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <reference internal="True" refuri="../../classes/class_visualinstance3d#class-visualinstance3d"><inline classes="std std-ref">VisualInstance3D</inline></reference> class, allows getting the scenario <emphasis>instance</emphasis> and
                        <emphasis>instance base</emphasis> via the <reference internal="True" refuri="../../classes/class_visualinstance3d#class-visualinstance3d-method-get-instance"><inline classes="std std-ref">VisualInstance3D.get_instance()</inline></reference>
                        and <reference internal="True" refuri="../../classes/class_visualinstance3d#class-visualinstance3d-method-get-base"><inline classes="std std-ref">VisualInstance3D.get_base()</inline></reference> respectively.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>请尝试探索你所熟悉的节点和资源，找到获得服务器 <emphasis>RID</emphasis> 的功能。</paragraph>
            <paragraph>不建议从已经有节点关联的对象中控制RID. 相反, 服务函数应始终用于创建和控制新的以及与现有的交互.</paragraph>
        </section>
        <section ids="creating-a-sprite" names="creating\ a\ sprite 创建精灵">
            <title>创建精灵</title>
            <paragraph>This is an example of how to create a sprite from code and move it using the low-level
                <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference> API.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D


# RenderingServer expects references to be kept around.
var texture


func _ready():
    # Create a canvas item, child of this node.
    var ci_rid = RenderingServer.canvas_item_create()
    # Make this node the parent.
    RenderingServer.canvas_item_set_parent(ci_rid, get_canvas_item())
    # Draw a texture on it.
    # Remember, keep this reference.
    texture = load("res://my_texture.png")
    # Add it, centered.
    RenderingServer.canvas_item_add_texture_rect(ci_rid, Rect2(texture.get_size() / 2, texture.get_size()), texture)
    # Add the item, rotated 45 degrees and translated.
    var xform = Transform2D().rotated(deg_to_rad(45)).translated(Vector2(20, 30))
    RenderingServer.canvas_item_set_transform(ci_rid, xform)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public partial class MyNode2D : Node2D
{
    // RenderingServer expects references to be kept around.
    private Texture2D _texture;

    public override void _Ready()
    {
        // Create a canvas item, child of this node.
        Rid ciRid = RenderingServer.CanvasItemCreate();
        // Make this node the parent.
        RenderingServer.CanvasItemSetParent(ciRid, GetCanvasItem());
        // Draw a texture on it.
        // Remember, keep this reference.
        _texture = ResourceLoader.Load&lt;Texture2D&gt;("res://MyTexture.png");
        // Add it, centered.
        RenderingServer.CanvasItemAddTextureRect(ciRid, new Rect2(_texture.GetSize() / 2, _texture.GetSize()), _texture.GetRid());
        // Add the item, rotated 45 degrees and translated.
        Transform2D xform = Transform2D.Identity.Rotated(Mathf.DegToRad(45)).Translated(new Vector2(20, 30));
        RenderingServer.CanvasItemSetTransform(ciRid, xform);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>服务器中的 Canvas Item API 允许你向其添加绘制图元。一旦添加，它们就不能被修改。需要清除 Item，并重新添加图元（设置变换时则不然，变换可根据需要多次进行）。</paragraph>
            <paragraph>图元的清除方式为：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">RenderingServer.canvas_item_clear(ci_rid)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">RenderingServer.CanvasItemClear(ciRid);</literal_block>
                </div>
            </container>
        </section>
        <section ids="instantiating-a-mesh-into-3d-space" names="instantiating\ a\ mesh\ into\ 3d\ space 将网格实例化到\ 3d\ 空间">
            <title>将网格实例化到 3D 空间</title>
            <paragraph>3D API 与 2D API 不同，所以必须使用实例化 API。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node3D


# RenderingServer expects references to be kept around.
var mesh


func _ready():
    # Create a visual instance (for 3D).
    var instance = RenderingServer.instance_create()
    # Set the scenario from the world, this ensures it
    # appears with the same objects as the scene.
    var scenario = get_world_3d().scenario
    RenderingServer.instance_set_scenario(instance, scenario)
    # Add a mesh to it.
    # Remember, keep the reference.
    mesh = load("res://mymesh.obj")
    RenderingServer.instance_set_base(instance, mesh)
    # Move the mesh around.
    var xform = Transform3D(Basis(), Vector3(20, 100, 0))
    RenderingServer.instance_set_transform(instance, xform)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public partial class MyNode3D : Node3D
{
    // RenderingServer expects references to be kept around.
    private Mesh _mesh;

    public override void _Ready()
    {
        // Create a visual instance (for 3D).
        Rid instance = RenderingServer.InstanceCreate();
        // Set the scenario from the world, this ensures it
        // appears with the same objects as the scene.
        Rid scenario = GetWorld3D().Scenario;
        RenderingServer.InstanceSetScenario(instance, scenario);
        // Add a mesh to it.
        // Remember, keep the reference.
        _mesh = ResourceLoader.Load&lt;Mesh&gt;("res://MyMesh.obj");
        RenderingServer.InstanceSetBase(instance, _mesh.GetRid());
        // Move the mesh around.
        Transform3D xform = new Transform3D(Basis.Identity, new Vector3(20, 100, 0));
        RenderingServer.InstanceSetTransform(instance, xform);
    }
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="creating-a-2d-rigidbody-and-moving-a-sprite-with-it" names="creating\ a\ 2d\ rigidbody\ and\ moving\ a\ sprite\ with\ it 创建\ 2d\ 刚体并使用它移动精灵">
            <title>创建 2D 刚体并使用它移动精灵</title>
            <paragraph>This creates a <reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d"><inline classes="std std-ref">RigidBody2D</inline></reference> using the <reference internal="True" refuri="../../classes/class_physicsserver2d#class-physicsserver2d"><inline classes="std std-ref">PhysicsServer2D</inline></reference> API,
                and moves a <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference> when the body moves.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Physics2DServer expects references to be kept around.
var body
var shape


func _body_moved(state, index):
    # Created your own canvas item, use it here.
    RenderingServer.canvas_item_set_transform(canvas_item, state.transform)


func _ready():
    # Create the body.
    body = Physics2DServer.body_create()
    Physics2DServer.body_set_mode(body, Physics2DServer.BODY_MODE_RIGID)
    # Add a shape.
    shape = Physics2DServer.rectangle_shape_create()
    # Set rectangle extents.
    Physics2DServer.shape_set_data(shape, Vector2(10, 10))
    # Make sure to keep the shape reference!
    Physics2DServer.body_add_shape(body, shape)
    # Set space, so it collides in the same space as current scene.
    Physics2DServer.body_set_space(body, get_world_2d().space)
    # Move initial position.
    Physics2DServer.body_set_state(body, Physics2DServer.BODY_STATE_TRANSFORM, Transform2D(0, Vector2(10, 20)))
    # Add the transform callback, when body moves
    # The last parameter is optional, can be used as index
    # if you have many bodies and a single callback.
    Physics2DServer.body_set_force_integration_callback(body, self, "_body_moved", 0)</literal_block>
                </div>
            </container>
            <paragraph>The 3D version should be very similar, as 2D and 3D physics servers are identical (using
                <reference internal="True" refuri="../../classes/class_rigidbody3d#class-rigidbody3d"><inline classes="std std-ref">RigidBody3D</inline></reference> and <reference internal="True" refuri="../../classes/class_physicsserver3d#class-physicsserver3d"><inline classes="std std-ref">PhysicsServer3D</inline></reference> respectively).</paragraph>
        </section>
        <section ids="getting-data-from-the-servers" names="getting\ data\ from\ the\ servers 从服务器获取数据">
            <title>从服务器获取数据</title>
            <paragraph>Try to <strong>never</strong> request any information from <literal>RenderingServer</literal>, <literal>PhysicsServer2D</literal> or <literal>PhysicsServer3D</literal>
                by calling functions unless you know what you are doing. These servers will often run asynchronously
                for performance and calling any function that returns a value will stall them and force them to process
                anything pending until the function is actually called. This will severely decrease performance if you
                call them every frame (and it won't be obvious why).</paragraph>
            <paragraph>正因为如此, 这类服务器中的大部分API都被设计成连信息都无法请求回来, 直到这是可以保存的实际数据.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
