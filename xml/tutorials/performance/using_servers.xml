<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/using_servers.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-servers"></target>
    <section ids="optimization-using-servers doc-using-servers" names="optimization\ using\ servers doc_using_servers">
        <title>Optimization using Servers</title>
        <paragraph>Engines like Godot provide increased ease of use thanks to their high-level constructs and features.
            Most of them are accessed and used via the <reference internal="True" refuri="../scripting/scene_tree#doc-scene-tree"><inline classes="std std-ref">Scene System</inline></reference>. Using nodes and
            resources simplifies project organization and asset management in complex games.</paragraph>
        <paragraph>There are, of course, always drawbacks:</paragraph>
        <bullet_list bullet="*">
            <list_item>
                <paragraph>There is an extra layer of complexity.</paragraph>
            </list_item>
            <list_item>
                <paragraph>Performance is lower than when using simple APIs directly.</paragraph>
            </list_item>
            <list_item>
                <paragraph>It is not possible to use multiple threads to control them.</paragraph>
            </list_item>
            <list_item>
                <paragraph>More memory is needed.</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>In many cases, this is not really a problem (Godot is very optimized, and most operations are handled
            with signals, so no polling is required). Still, sometimes it can be. For example, dealing with
            tens of thousands of instances for something that needs to be processed every frame can be a bottleneck.</paragraph>
        <paragraph>This type of situation makes programmers regret they are using a game engine and wish they could go
            back to a more handcrafted, low-level implementation of game code.</paragraph>
        <paragraph>Still, Godot is designed to work around this problem.</paragraph>
        <seealso>
            <paragraph>You can see how using low-level servers works in action using the
                <reference name="Bullet Shower demo project" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/2d/bullet_shower">Bullet Shower demo project</reference></paragraph>
        </seealso>
        <section ids="servers" names="servers">
            <title>Servers</title>
            <paragraph>One of the most interesting design decisions for Godot is the fact that the whole scene system is
                <emphasis>optional</emphasis>. While it is not currently possible to compile it out, it can be completely bypassed.</paragraph>
            <paragraph>At the core, Godot uses the concept of Servers. They are very low-level APIs to control
                rendering, physics, sound, etc. The scene system is built on top of them and uses them directly.
                The most common servers are:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_renderingserver#class-renderingserver"><inline classes="std std-ref">RenderingServer</inline></reference>: handles everything related to graphics.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_physicsserver3d#class-physicsserver3d"><inline classes="std std-ref">PhysicsServer3D</inline></reference>: handles everything related to 3D physics.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_physicsserver2d#class-physicsserver2d"><inline classes="std std-ref">PhysicsServer2D</inline></reference>: handles everything related to 2D physics.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_audioserver#class-audioserver"><inline classes="std std-ref">AudioServer</inline></reference>: handles everything related to audio.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Explore their APIs and you will realize that all the functions provided are low-level
                implementations of everything Godot allows you to do.</paragraph>
        </section>
        <section ids="rids" names="rids">
            <title>RIDs</title>
            <paragraph>The key to using servers is understanding Resource ID (<reference internal="True" refuri="../../classes/class_rid#class-rid"><inline classes="std std-ref">RID</inline></reference>) objects. These are opaque
                handles to the server implementation. They are allocated and freed manually. Almost every
                function in the servers requires RIDs to access the actual resource.</paragraph>
            <paragraph>Most Godot nodes and resources contain these RIDs from the servers internally, and they can
                be obtained with different functions. In fact, anything that inherits <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>
                can be directly casted to an RID. Not all resources contain an RID, though: in such cases, the RID will be empty. The resource can then be passed to server APIs as an RID.</paragraph>
            <warning>
                <paragraph>Resources are reference-counted (see <reference internal="True" refuri="../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference>), and
                    references to a resource's RID are <emphasis>not</emphasis> counted when determining whether
                    the resource is still in use. Make sure to keep a reference to the resource
                    outside the server, or else both it and its RID will be erased.</paragraph>
            </warning>
            <paragraph>For nodes, there are many functions available:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>For CanvasItem, the <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-method-get-canvas-item"><inline classes="std std-ref">CanvasItem.get_canvas_item()</inline></reference>
                        method will return the canvas item RID in the server.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>For CanvasLayer, the <reference internal="True" refuri="../../classes/class_canvaslayer#class-canvaslayer-method-get-canvas"><inline classes="std std-ref">CanvasLayer.get_canvas()</inline></reference>
                        method will return the canvas RID in the server.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>For Viewport, the <reference internal="True" refuri="../../classes/class_viewport#class-viewport-method-get-viewport-rid"><inline classes="std std-ref">Viewport.get_viewport_rid()</inline></reference>
                        method will return the viewport RID in the server.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>For 3D, the <reference internal="True" refuri="../../classes/class_world3d#class-world3d"><inline classes="std std-ref">World3D</inline></reference> resource (obtainable in the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>
                        and <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> nodes)
                        contains functions to get the <emphasis>RenderingServer Scenario</emphasis>, and the <emphasis>PhysicsServer Space</emphasis>. This
                        allows creating 3D objects directly with the server API and using them.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>For 2D, the <reference internal="True" refuri="../../classes/class_world2d#class-world2d"><inline classes="std std-ref">World2D</inline></reference> resource (obtainable in the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>
                        and <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference> nodes)
                        contains functions to get the <emphasis>RenderingServer Canvas</emphasis>, and the <emphasis>Physics2DServer Space</emphasis>. This
                        allows creating 2D objects directly with the server API and using them.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <reference internal="True" refuri="../../classes/class_visualinstance3d#class-visualinstance3d"><inline classes="std std-ref">VisualInstance3D</inline></reference> class, allows getting the scenario <emphasis>instance</emphasis> and
                        <emphasis>instance base</emphasis> via the <reference internal="True" refuri="../../classes/class_visualinstance3d#class-visualinstance3d-method-get-instance"><inline classes="std std-ref">VisualInstance3D.get_instance()</inline></reference>
                        and <reference internal="True" refuri="../../classes/class_visualinstance3d#class-visualinstance3d-method-get-base"><inline classes="std std-ref">VisualInstance3D.get_base()</inline></reference> respectively.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Try exploring the nodes and resources you are familiar with and find the functions to obtain the server <emphasis>RIDs</emphasis>.</paragraph>
            <paragraph>It is not advised to control RIDs from objects that already have a node associated. Instead, server
                functions should always be used for creating and controlling new ones and interacting with the existing ones.</paragraph>
        </section>
        <section ids="creating-a-sprite" names="creating\ a\ sprite">
            <title>Creating a sprite</title>
            <paragraph>This is an example of how to create a sprite from code and move it using the low-level
                <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference> API.</paragraph>
            <note>
                <paragraph>When creating canvas items using the RenderingServer, you should reset physics
                    interpolation on the first frame using
                    <reference internal="True" refuri="../../classes/class_renderingserver#class-renderingserver-method-canvas-item-reset-physics-interpolation"><inline classes="std std-ref">RenderingServer.canvas_item_reset_physics_interpolation()</inline></reference>.
                    This ensures proper synchronization between the rendering and physics systems.</paragraph>
            </note>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D


# RenderingServer expects references to be kept around.
var texture


func _ready():
    # Create a canvas item, child of this node.
    var ci_rid = RenderingServer.canvas_item_create()
    # Make this node the parent.
    RenderingServer.canvas_item_set_parent(ci_rid, get_canvas_item())
    # Draw a texture on it.
    # Remember, keep this reference.
    texture = load("res://my_texture.png")
    # Add it, centered.
    RenderingServer.canvas_item_add_texture_rect(ci_rid, Rect2(-texture.get_size() / 2, texture.get_size()), texture)
    # Add the item, rotated 45 degrees and translated.
    var xform = Transform2D().rotated(deg_to_rad(45)).translated(Vector2(20, 30))
    RenderingServer.canvas_item_set_transform(ci_rid, xform)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public partial class MyNode2D : Node2D
{
    // RenderingServer expects references to be kept around.
    private Texture2D _texture;

    public override void _Ready()
    {
        // Create a canvas item, child of this node.
        Rid ciRid = RenderingServer.CanvasItemCreate();
        // Make this node the parent.
        RenderingServer.CanvasItemSetParent(ciRid, GetCanvasItem());
        // Draw a texture on it.
        // Remember, keep this reference.
        _texture = ResourceLoader.Load&lt;Texture2D&gt;("res://MyTexture.png");
        // Add it, centered.
        RenderingServer.CanvasItemAddTextureRect(ciRid, new Rect2(-_texture.GetSize() / 2, _texture.GetSize()), _texture.GetRid());
        // Add the item, rotated 45 degrees and translated.
        Transform2D xform = Transform2D.Identity.Rotated(Mathf.DegToRad(45)).Translated(new Vector2(20, 30));
        RenderingServer.CanvasItemSetTransform(ciRid, xform);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>The Canvas Item API in the server allows you to add draw primitives to it. Once added, they can't be modified.
                The Item needs to be cleared and the primitives re-added (this is not the case for setting the transform,
                which can be done as many times as desired).</paragraph>
            <paragraph>Primitives are cleared this way:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">RenderingServer.canvas_item_clear(ci_rid)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">RenderingServer.CanvasItemClear(ciRid);</literal_block>
                </div>
            </container>
        </section>
        <section ids="instantiating-a-mesh-into-3d-space" names="instantiating\ a\ mesh\ into\ 3d\ space">
            <title>Instantiating a Mesh into 3D space</title>
            <paragraph>The 3D APIs are different from the 2D ones, so the instantiation API must be used.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node3D


# RenderingServer expects references to be kept around.
var mesh


func _ready():
    # Create a visual instance (for 3D).
    var instance = RenderingServer.instance_create()
    # Set the scenario from the world, this ensures it
    # appears with the same objects as the scene.
    var scenario = get_world_3d().scenario
    RenderingServer.instance_set_scenario(instance, scenario)
    # Add a mesh to it.
    # Remember, keep the reference.
    mesh = load("res://mymesh.obj")
    RenderingServer.instance_set_base(instance, mesh)
    # Move the mesh around.
    var xform = Transform3D(Basis(), Vector3(20, 100, 0))
    RenderingServer.instance_set_transform(instance, xform)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public partial class MyNode3D : Node3D
{
    // RenderingServer expects references to be kept around.
    private Mesh _mesh;

    public override void _Ready()
    {
        // Create a visual instance (for 3D).
        Rid instance = RenderingServer.InstanceCreate();
        // Set the scenario from the world, this ensures it
        // appears with the same objects as the scene.
        Rid scenario = GetWorld3D().Scenario;
        RenderingServer.InstanceSetScenario(instance, scenario);
        // Add a mesh to it.
        // Remember, keep the reference.
        _mesh = ResourceLoader.Load&lt;Mesh&gt;("res://MyMesh.obj");
        RenderingServer.InstanceSetBase(instance, _mesh.GetRid());
        // Move the mesh around.
        Transform3D xform = new Transform3D(Basis.Identity, new Vector3(20, 100, 0));
        RenderingServer.InstanceSetTransform(instance, xform);
    }
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="creating-a-2d-rigidbody-and-moving-a-sprite-with-it" names="creating\ a\ 2d\ rigidbody\ and\ moving\ a\ sprite\ with\ it">
            <title>Creating a 2D RigidBody and moving a sprite with it</title>
            <paragraph>This creates a <reference internal="True" refuri="../../classes/class_rigidbody2d#class-rigidbody2d"><inline classes="std std-ref">RigidBody2D</inline></reference> using the <reference internal="True" refuri="../../classes/class_physicsserver2d#class-physicsserver2d"><inline classes="std std-ref">PhysicsServer2D</inline></reference> API,
                and moves a <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference> when the body moves.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Physics2DServer expects references to be kept around.
var body
var shape


func _body_moved(state, index):
    # Created your own canvas item, use it here.
    RenderingServer.canvas_item_set_transform(canvas_item, state.transform)


func _ready():
    # Create the body.
    body = Physics2DServer.body_create()
    Physics2DServer.body_set_mode(body, Physics2DServer.BODY_MODE_RIGID)
    # Add a shape.
    shape = Physics2DServer.rectangle_shape_create()
    # Set rectangle extents.
    Physics2DServer.shape_set_data(shape, Vector2(10, 10))
    # Make sure to keep the shape reference!
    Physics2DServer.body_add_shape(body, shape)
    # Set space, so it collides in the same space as current scene.
    Physics2DServer.body_set_space(body, get_world_2d().space)
    # Move initial position.
    Physics2DServer.body_set_state(body, Physics2DServer.BODY_STATE_TRANSFORM, Transform2D(0, Vector2(10, 20)))
    # Add the transform callback, when body moves
    # The last parameter is optional, can be used as index
    # if you have many bodies and a single callback.
    Physics2DServer.body_set_force_integration_callback(body, self, "_body_moved", 0)</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode2D : Node2D
{
    private Rid _canvasItem;

    private void BodyMoved(PhysicsDirectBodyState2D state, int index)
    {
        RenderingServer.CanvasItemSetTransform(_canvasItem, state.Transform);
    }

    public override void _Ready()
    {
        // Create the body.
        var body = PhysicsServer2D.BodyCreate();
        PhysicsServer2D.BodySetMode(body, PhysicsServer2D.BodyMode.Rigid);
        // Add a shape.
        var shape = PhysicsServer2D.RectangleShapeCreate();
        // Set rectangle extents.
        PhysicsServer2D.ShapeSetData(shape, new Vector2(10, 10));
        // Make sure to keep the shape reference!
        PhysicsServer2D.BodyAddShape(body, shape);
        // Set space, so it collides in the same space as current scene.
        PhysicsServer2D.BodySetSpace(body, GetWorld2D().Space);
        // Move initial position.
        PhysicsServer2D.BodySetState(body, PhysicsServer2D.BodyState.Transform, new Transform2D(0, new Vector2(10, 20)));
        // Add the transform callback, when body moves
        // The last parameter is optional, can be used as index
        // if you have many bodies and a single callback.
        PhysicsServer2D.BodySetForceIntegrationCallback(body, new Callable(this, MethodName.BodyMoved), 0);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>The 3D version should be very similar, as 2D and 3D physics servers are identical (using
                <reference internal="True" refuri="../../classes/class_rigidbody3d#class-rigidbody3d"><inline classes="std std-ref">RigidBody3D</inline></reference> and <reference internal="True" refuri="../../classes/class_physicsserver3d#class-physicsserver3d"><inline classes="std std-ref">PhysicsServer3D</inline></reference> respectively).</paragraph>
        </section>
        <section ids="getting-data-from-the-servers" names="getting\ data\ from\ the\ servers">
            <title>Getting data from the servers</title>
            <paragraph>Try to <strong>never</strong> request any information from <literal>RenderingServer</literal>, <literal>PhysicsServer2D</literal> or <literal>PhysicsServer3D</literal>
                by calling functions unless you know what you are doing. These servers will often run asynchronously
                for performance and calling any function that returns a value will stall them and force them to process
                anything pending until the function is actually called. This will severely decrease performance if you
                call them every frame (and it won't be obvious why).</paragraph>
            <paragraph>Because of this, most APIs in such servers are designed so it's not even possible to request information
                back, until it's actual data that can be saved.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
