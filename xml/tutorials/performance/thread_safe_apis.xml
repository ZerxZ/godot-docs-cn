<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/performance/thread_safe_apis.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-thread-safe-apis"></target>
    <section ids="thread-safe-apis doc-thread-safe-apis" names="thread-safe\ apis doc_thread_safe_apis">
        <title>Thread-safe APIs</title>
        <section ids="threads" names="threads">
            <title>Threads</title>
            <paragraph>Threads are used to balance processing power across CPUs and cores.
                Godot supports multithreading, but not in the whole engine.</paragraph>
            <paragraph>Below is a list of ways multithreading can be used in different areas of Godot.</paragraph>
        </section>
        <section ids="global-scope" names="global\ scope">
            <title>Global scope</title>
            <paragraph>Most <reference internal="True" refuri="../../classes/class_@globalscope#class-globalscope"><inline classes="std std-ref">Global Scope</inline></reference> singletons are thread-safe by default.
                Accessing servers from threads is supported. However, for the
                <reference internal="True" refid="doc-thread-safe-apis-rendering"><inline classes="std std-ref">rendering</inline></reference> and
                <reference internal="True" refid="doc-thread-safe-apis-physics"><inline classes="std std-ref">physics</inline></reference> servers,
                thread-safe operation must be enabled in the project settings first.</paragraph>
            <paragraph>This makes singletons ideal for code that creates dozens of thousands of instances
                in servers and controls them from threads. Of course, it requires a bit more
                code, as this is used directly and not within the scene tree.</paragraph>
        </section>
        <section ids="scene-tree" names="scene\ tree">
            <title>Scene tree</title>
            <paragraph>Interacting with the active scene tree is <strong>not</strong> thread-safe. Make sure
                to use mutexes when sending data between threads. If you want to call
                functions or set properties from a thread, you may use
                <reference internal="True" refuri="../../classes/class_object#class-object-method-call-deferred"><inline classes="std std-ref">call_deferred</inline></reference> or <reference internal="True" refuri="../../classes/class_object#class-object-method-set-deferred"><inline classes="std std-ref">set_deferred</inline></reference>:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Unsafe:
node.add_child(child_node)
# Safe:
node.add_child.call_deferred(child_node)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Unsafe:
node.AddChild(childNode);
// Safe:
node.CallDeferred(Node.MethodName.AddChild, childNode);</literal_block>
                </div>
            </container>
            <paragraph>However, creating scene chunks (nodes in tree arrangement) outside the active
                tree is fine. This way, parts of a scene can be built or instantiated
                in a thread, then added in the main thread:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var enemy_scene = load("res://enemy_scene.scn")
var enemy = enemy_scene.instantiate()
enemy.add_child(weapon) # Set a weapon.
world.add_child.call_deferred(enemy)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">PackedScene enemyScene = GD.Load&lt;PackedScene&gt;("res://EnemyScene.scn");
Node enemy = enemyScene.Instantiate&lt;Node&gt;();
enemy.AddChild(weapon);
world.CallDeferred(Node.MethodName.AddChild, enemy);</literal_block>
                </div>
            </container>
            <paragraph>Still, this is only really useful if you have <strong>one</strong> thread loading data.
                Attempting to load or create scene chunks from multiple threads may work,
                but you risk resources (which are only loaded once in Godot) being tweaked
                by the multiple threads, resulting in unexpected behaviors or crashes.</paragraph>
            <paragraph>Only use more than one thread to generate scene data if you <emphasis>really</emphasis> know what
                you are doing and you are sure that a single resource is not being used or
                set in multiple ones. Otherwise, you are safer just using the servers API
                (which is fully thread-safe) directly and not touching scene or resources.</paragraph>
            <target refid="doc-thread-safe-apis-rendering"></target>
        </section>
        <section ids="rendering doc-thread-safe-apis-rendering" names="rendering doc_thread_safe_apis_rendering">
            <title>Rendering</title>
            <paragraph>Instancing nodes that render anything in 2D or 3D (such as <reference internal="True" refuri="../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite2D</inline></reference>
                or <reference internal="True" refuri="../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference>) is <emphasis>not</emphasis> thread-safe by default. To run the
                rendering driver on a separate thread, set the
                <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-rendering-driver-threads-thread-model"><inline classes="std std-ref">Rendering &gt; Driver &gt; Thread Model</inline></reference>
                project setting to <strong>Separate</strong>.</paragraph>
            <paragraph>Note that the <strong>Separate</strong> thread model has several known bugs, so it may not be usable
                in all scenarios.</paragraph>
            <warning>
                <paragraph>You should avoid calling functions involving direct interaction with the GPU
                    on other threads, such as creating new textures or modifying and retrieving
                    image data. These operations can lead to performance stalls because they require
                    synchronization with the <reference internal="True" refuri="../../classes/class_renderingserver#class-renderingserver"><inline classes="std std-ref">RenderingServer</inline></reference>,
                    as data needs to be transmitted to or updated on the GPU.</paragraph>
            </warning>
            <target refid="doc-thread-safe-apis-physics"></target>
        </section>
        <section ids="physics doc-thread-safe-apis-physics" names="physics doc_thread_safe_apis_physics">
            <title>Physics</title>
            <paragraph>Physics simulation is <emphasis>not</emphasis> thread-safe by default. To run the physics servers
                on separate threads (making them thread-safe), enable the following project settings:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>PhysicsServer2D:</strong> <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-2d-run-on-separate-thread"><inline classes="std std-ref">Physics &gt; 2D &gt; Run on Separate Thread</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>PhysicsServer3D:</strong> <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-physics-3d-run-on-separate-thread"><inline classes="std std-ref">Physics &gt; 3D &gt; Run on Separate Thread</inline></reference>.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="gdscript-arrays-and-dictionaries" names="gdscript\ arrays\ and\ dictionaries">
            <title>GDScript arrays and dictionaries</title>
            <paragraph>In GDScript, reading and writing elements from multiple threads is OK, but anything
                that changes the container size (resizing, adding, or removing elements) requires
                locking a <reference internal="True" refuri="using_multiple_threads#doc-using-multiple-threads-mutexes"><inline classes="std std-ref">mutex</inline></reference>.</paragraph>
        </section>
        <section ids="resources" names="resources">
            <title>Resources</title>
            <paragraph>Modifying a unique resource from multiple threads is not supported. However,
                handling references on multiple threads <emphasis>is</emphasis> supported. Hence loading resources
                on a thread is as well - scenes, textures, meshes, etc - can be loaded and manipulated
                on a thread and then added to the active scene on the main thread. The limitation here
                is as described above: one must be careful not to load the same resource from
                multiple threads at once. Therefore, it's easiest to use <strong>one</strong> thread for loading
                and modifying resources, and then the main thread for adding them.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
