<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/animation/playing_videos.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-playing-videos"></target>
    <section ids="playing-videos doc-playing-videos" names="playing\ videos 播放视频 doc_playing_videos">
        <title>播放视频</title>
        <paragraph>Godot 通过 <reference internal="True" refuri="../../classes/class_videostreamplayer#class-videostreamplayer"><inline classes="std std-ref">VideoStreamPlayer</inline></reference> 节点支持视频的播放。</paragraph>
        <section ids="supported-playback-formats" names="supported\ playback\ formats 支持的播放格式">
            <title>支持的播放格式</title>
            <paragraph>核心中仅支持 <strong>Ogg Theora</strong> 格式（请勿与 Ogg Vorbis 音频混淆）。扩展可以支持额外的格式，但是截止到 2022 年 7 月，还没有这种扩展存在。</paragraph>
            <paragraph>Godot 核心无法支持 H.264 和 H.265，因为它们都被软件专利所限。AV1 不需要授权，但 CPU 解码仍然很慢，也不是所有 GPU 都已支持硬件解码。</paragraph>
            <paragraph>Godot 3.x 核心中支持 WebM，但是会在 4.0 中移除支持，因为 bug 很多且难以维护。</paragraph>
            <note>
                <paragraph>你的视频可能使用的是 <literal>.ogg</literal> 或者 <literal>.ogx</literal> 扩展名，这是带有数据的 Ogg 容器的通用扩展名。</paragraph>
                <paragraph>将这些文件扩展名修改为 <literal>.ogv</literal><emphasis>可能</emphasis>可以让视频在 Godot 中导入。不过，并不是所有 <literal>.ogg</literal> 或 <literal>.ogx</literal> 扩展名的文件都是视频——有些可能只包含音频。</paragraph>
            </note>
        </section>
        <section ids="setting-up-videostreamplayer" names="setting\ up\ videostreamplayer 设置\ videostreamplayer">
            <title>设置 VideoStreamPlayer</title>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>使用“新建 Node”对话框创建 VideoStreamPlayer 节点。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>在场景树面板上选中 VideoStreamPlayer 节点，到检查器中为 Stream 属性加载 <literal>.ogv</literal> 文件。</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>如果你还没有把你的视频转为 Ogg Theora 格式，请跳转到 <reference internal="True" refid="doc-playing-videos-recommended-theora-encoding-settings"><inline classes="std std-ref">推荐 Theora 编码设置</inline></reference>。</paragraph>
                        </list_item>
                    </bullet_list>
                </list_item>
                <list_item>
                    <paragraph>如果你希望在场景加载时立即播放视频，请在检查器中勾选 <strong>Autoplay</strong>。否则，请保持 <strong>Autoplay</strong> 关闭，并在需要时在脚本中调用 VideoStreamPlayer 节点的 <literal>play()</literal> 开始播放。</paragraph>
                </list_item>
            </enumerated_list>
            <section ids="handling-resizing-and-different-aspect-ratios" names="handling\ resizing\ and\ different\ aspect\ ratios 处理大小变化及不同的纵横比">
                <title>处理大小变化及不同的纵横比</title>
                <paragraph>Godot 4.0 中在默认情况下，VideoStreamPlayer 会自动调整到与视频分辨率相匹配的大小。你可以让它遵循普通的 <reference internal="True" refuri="../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 大小规则，启用 VideoStreamPlayer 节点的 <strong>Expand</strong> 即可。</paragraph>
                <paragraph>要调整 VideoStreamPlayer 节点的大小随窗口大小改变的方式，请通过 2D 编辑器视口顶部的<strong>布局</strong>按钮调整锚点。不过，这种设置可能不足以处理所有可能的情况，例如全屏播放视频但不造成形变（需要在边界处留白）。要进行精确的控制，你可以使用专为处理这种情况设计的 <reference internal="True" refuri="../../classes/class_aspectratiocontainer#class-aspectratiocontainer"><inline classes="std std-ref">AspectRatioContainer</inline></reference> 节点：</paragraph>
                <paragraph>添加一个 AspectRatioContainer 节点。请确保它不是任何其他容器节点的子节点。选中该 AspectRatioContainer 节点，然后在 2D 编辑器的顶部将<strong>布局</strong>设置为<strong>整个矩形</strong>。将 AspectRatioContainer 节点的 <strong>Ratio（比例）</strong>设置为与你的视频的长宽比匹配的比例。你可以在检查器里直接输入数学公式。请记住要将其中的一个操作数写成浮点形式，否则会得到整数的商。</paragraph>
                <figure align="center" classes="figure-w480" ids="id1">
                    <image alt="在编辑器检查器中修改 AspectRatioContainer 的 Ratio 属性" candidates="{'*': 'tutorials/animation/img/playing_videos_aspect_ratio_container.png'}" uri="tutorials/animation/img/playing_videos_aspect_ratio_container.png"></image>
                    <caption>求值会得到（大约）1.777778</caption>
                </figure>
                <paragraph>配置好 AspectRatioContainer 之后，请将你的 VideoStreamPlayer 节点调整为该 AspectRatioContainer 节点的子节点。请确保禁用了该 VideoPlayer 的 <strong>Expand</strong>。你的视频现在应该就会自动适应到全屏的大小，不产生变形。</paragraph>
                <seealso>
                    <paragraph>更多在项目中支持不同的长宽比的技巧，请参阅 <reference internal="True" refuri="../rendering/multiple_resolutions#doc-multiple-resolutions"><inline classes="std std-ref">多分辨率</inline></reference>。</paragraph>
                </seealso>
            </section>
            <section ids="displaying-a-video-on-a-3d-surface" names="displaying\ a\ video\ on\ a\ 3d\ surface 在\ 3d\ 表面上显示视频">
                <title>在 3D 表面上显示视频</title>
                <paragraph>使用 VideoStreamPlayer 节点作为 <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> 节点的子节点，就可以在 3D 表面上显示任何 2D 节点。例如，可以用于显示动态的广告板，帧动画可能花费太多的内存。</paragraph>
                <paragraph>可以使用以下步骤实现：</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>创建一个 <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> 节点。将其设置为与你的视频大小相匹配的像素大小。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>创建一个 VideoStreamPlayer 节点<emphasis>作为该 SubViewport 节点的子节点</emphasis>，并为其指定一个视频的路径。请确保禁用了 <strong>Expand</strong>，需要时启用 <strong>Autoplay</strong>。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>创建一个 MeshInstance3D 节点，将其 Mesh 属性设为 PlaneMesh 或 QuadMesh。将该网格的大小调整到与视频的长宽比一致（否则看上去就会变形）。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>在 GeometryInstance3D 部分的 <strong>Material Override</strong> 属性中新建一个 StandardMaterial3D 资源。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>在该 StandardMaterial3D（底部）的 Resource 部分启用 <strong>Local To Scene</strong>。这是在 Albedo Texture 属性中使用 ViewportTexture 所<emphasis>必须的</emphasis>。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>在该 StandardMaterial3D中，将 <strong>Albedo &gt; Texture</strong> 属性设置为<strong>新建 ViewportTexture</strong>。点击编辑这个新的资源，在 <strong>Viewport Path</strong> 属性中指定指向 SubViewport 节点的路径。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>在该 StandardMaterial3D 中启用 <strong>Albedo Texture Force sRGB</strong>，防止颜色变化。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>如果广告板需要自发光，请将 <strong>着色模式</strong> 设置为 <strong>无阴着色</strong> 以提高渲染性能。</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>更多关于设置的信息，请参阅 <reference internal="True" refuri="../rendering/viewports#doc-viewports"><inline classes="std std-ref">使用 Viewport</inline></reference> 和 <reference name="3D GUI 演示" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/viewport/gui_in_3d">3D GUI 演示</reference>。</paragraph>
            </section>
            <section ids="looping-a-video" names="looping\ a\ video 循环视频">
                <title>循环视频</title>
                <paragraph>要循环视频，可以启用 <strong>Loop</strong> 属性。这样视频在抵达末尾时就会无缝重启。</paragraph>
                <paragraph>请注意，将项目设置 <strong>视频延迟补偿</strong> 设置为非零的值可能会导致视频循环不再无缝，因为音频和视频的同步发生在每个循环开始时，会导致偶尔丢失帧。将项目设置中的 <strong>视频延迟补偿</strong> 设置为 <strong>0</strong> 以避免丢帧问题。</paragraph>
            </section>
        </section>
        <section ids="video-decoding-conditions-and-recommended-resolutions" names="video\ decoding\ conditions\ and\ recommended\ resolutions 视频解码条件及推荐分辨率">
            <title>视频解码条件及推荐分辨率</title>
            <paragraph>由于 GPU 在解码 Theora 视频时没有硬件加速，所以视频解码是在 CPU 上执行的。现代的桌面 CPU 可以以 1440p @ 60 FPS 或更高的速度解码 Ogg Theora 格式的视频，但低端移动 CPU 处理高分辨率视频可能会比较吃力。</paragraph>
            <paragraph>为了确保视频在各种硬件上都能够顺利解码：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>为桌面平台开发游戏时，建议最多编码为 1080p（最好是 30 FPS）。大多数人还在使用 1080p 或者更低分辨率的显示器，所以编码为更高分辨率的视频可能不值那些增大的文件大小和 CPU 需求。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>为移动和 Web 平台开发游戏时，建议最多编码为 720p（最好是 30 FPS 或更低）。移动设备上 720p 和 1080p 的视频通常很难看出区别。</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="playback-limitations" names="playback\ limitations 播放限制">
            <title>播放限制</title>
            <paragraph>Godot 中目前的视频播放实现有一些限制：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>不支持将视频跳跃到特定的时间点。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>不支持修改播放速度。VideoStreamPlayer 也不会遵循 <reference internal="True" refuri="../../classes/class_engine#class-engine-property-time-scale"><inline classes="std std-ref">Engine.time_scale</inline></reference>。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>不支持从 URL 播放视频流。</paragraph>
                </list_item>
            </bullet_list>
            <target refid="doc-playing-videos-recommended-theora-encoding-settings"></target>
        </section>
        <section ids="recommended-theora-encoding-settings doc-playing-videos-recommended-theora-encoding-settings" names="recommended\ theora\ encoding\ settings 推荐\ theora\ 编码设置 doc_playing_videos_recommended_theora_encoding_settings">
            <title>推荐 Theora 编码设置</title>
            <paragraph>建议是（在大多数情况下）<strong>避免依赖内置的 Ogg Theora 导出器</strong>。你可能想要优先使用外部程序编码视频的原因有 2 个：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Blender 等程序可以渲染 Ogg Theora。然而，默认的质量预设就如今的标准而言通常是非常低的。你可能可以在软件里提高质量选项，但输出的质量可能仍然不理想（提升了文件大小）。这通常意味着那个软件只支持按照固定比特率（CBR）去进行编码，不支持可变比特率（VBR）。大多数场合应该都优先使用 VBR 编码，因为在相同的文件大小下能够提供更好的质量。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>有些其他的程序根本无法渲染 Ogg Theora。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>在这种情况下，你可以<strong>将视频使用高质量格式渲染作为中介</strong>（例如高比特率 H.264 视频），然后再重新编码成 Ogg Theora。理想情况下，你应该使用无损或者未压缩格式作为中介格式，最大化输出 Ogg Theora 视频的质量，不过这样做会需要大量的磁盘空间。</paragraph>
            <paragraph><reference name="HandBrake" refuri="https://handbrake.fr/">HandBrake</reference>（GUI）和 <reference name="FFmpeg" refuri="https://ffmpeg.org/">FFmpeg</reference>（CLI）都是这方面非常流行的开源工具。FFmpeg 的学习曲线相对陡峭，但功能也更强大。</paragraph>
            <paragraph>这是将 MP4 视频转换为 Ogg Theora 的 FFmpeg 命令示例。因为 FFmpeg 支持很多输入格式，几乎任何输入视频格式（AVI、MOV、WebM……）应该都可以使用下面的命令。</paragraph>
            <note>
                <paragraph>请确保你的 FFmpeg 副本是启用 libtheora 和 libvorbis 编译的。检查方法是不带任何参数执行 <literal>ffmpeg</literal>，然后查看命令输出中的 <literal>configuration:</literal> 一行。</paragraph>
            </note>
            <section ids="balancing-quality-and-file-size" names="balancing\ quality\ and\ file\ size 平衡质量与文件大小">
                <title>平衡质量与文件大小</title>
                <paragraph><strong>视频质量</strong>等级（<literal>-q:v</literal>）必须在 <literal>1</literal> 和 <literal>10</literal> 之间。将质量设为 <literal>6</literal> 是在质量和文件大小之间的一个不错的妥协。如果要编码较高的分辨率（例如 1440p 或者 4K），你可能想要把 <literal>-q:v</literal> 降为 <literal>5</literal>，把文件大小控制在合理的范围内。因为 1440p 和 4K 视频的像素密度更高，相较于低分辨率的视频，较低的质量预设看上去的效果是一样甚至更好的。</paragraph>
                <paragraph>** 音频质量**等级（<literal>-q:a</literal>）必须在 <literal>-1</literal> 和 <literal>10</literal> 之间。将质量设为 <literal>6</literal> 是在质量和文件大小之间的一个不错的妥协。与视频质量不同，提升音频质量并不会显著增加输出文件的大小。因此，如果你想要尽可能清晰的音频，可以将其设为 <literal>9</literal>，达到<emphasis>感知上无损</emphasis>的音频。在你的输入文件使用的已经是有损音频压缩时，这个设置尤其有用。更高质量的音频确实会增加解码器的 CPU 使用率，因此在系统负载较高的情况下可能会导致音频丢失。Ogg Vorbis 音频质量预设及其对应的可变比特率表见<reference name="这个页面" refuri="https://wiki.hydrogenaud.io/index.php?title=Recommended_Ogg_Vorbis#Recommended_Encoder_Settings">这个页面</reference>。</paragraph>
            </section>
            <section ids="ffmpeg-convert-while-preserving-original-video-resolution" names="ffmpeg:\ convert\ while\ preserving\ original\ video\ resolution ffmpeg：转换时保持原始视频分辨率">
                <title>FFmpeg：转换时保持原始视频分辨率</title>
                <paragraph>以下命令会在保持原始分辨率的前提下对视频进行转换。视频和音频的比特率会被设为可变，在最大化质量的同时在不需要高比特率视频/音频的时候节省空间（例如静态场景）。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">ffmpeg -i input.mp4 -q:v 6 -q:a 6 output.ogv</literal_block>
            </section>
            <section ids="ffmpeg-resize-the-video-then-convert-it" names="ffmpeg:\ resize\ the\ video\ then\ convert\ it ffmpeg：调整视频大小并转换">
                <title>FFmpeg：调整视频大小并转换</title>
                <paragraph>以下命令会在保持现有长宽比的前提下将视频调整到 720 像素高（720p）。如果原始文件分辨率是大于 720p 的，就能够显著降低文件大小：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">ffmpeg -i input.mp4 -vf "scale=-1:720" -q:v 6 -q:a 6 output.ogv</literal_block>
                <comment xml:space="preserve">Chroma Key Functionality Documentation</comment>
            </section>
        </section>
        <section ids="chroma-key-videos" names="chroma\ key\ videos 色键视频">
            <title>色键视频</title>
            <paragraph>色键（Chroma Key）也就是常说的“绿幕”“蓝幕”效果，能够移除图像或视频中的特定颜色，替换为其他背景。这种效果在视频制作领域广泛使用，可以将不同的元素无缝合成到一起。</paragraph>
            <block_quote>
                <image candidates="{'*': 'tutorials/animation/img/chroma_key_video.webp'}" uri="tutorials/animation/img/chroma_key_video.webp"></image>
            </block_quote>
            <paragraph>我们将通过在 GDScript 中编写自定义着色器，并使用 <title_reference>VideoStreamPlayer</title_reference> 节点来显示视频内容来实现色键效果。</paragraph>
            <section ids="scene-setup" names="scene\ setup 场景设置">
                <title>场景设置</title>
                <paragraph>确保场景包含用于播放视频的 <title_reference>VideoStreamPlayer</title_reference> 节点，和用于保存用于控制色键效果的 UI 元素的 <title_reference>Control</title_reference> 节点。</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/animation/img/chroma_key_scene.webp'}" uri="tutorials/animation/img/chroma_key_scene.webp"></image>
                </block_quote>
            </section>
            <section ids="writing-the-custom-shader" names="writing\ the\ custom\ shader 编写自定义着色器">
                <title>编写自定义着色器</title>
                <paragraph>要实现色键效果，请按照下列步骤操作：</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>选择场景中的 <title_reference>VideoStreamPlayer</title_reference> 节点。转到该节点属性栏，在 <title_reference>CanvasItem &gt; Material</title_reference> 下，创建一个名为“ChromaKeyShader.gdshader”的新着色器。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>在“ChromaKeyShader.gdshader”文件中，编写自定义着色器代码，如下所示：</paragraph>
                    </list_item>
                </enumerated_list>
                <literal_block force="False" highlight_args="{}" language="gd" linenos="False" xml:space="preserve">shader_type canvas_item;

# Uniform variables for chroma key effect
uniform vec3 chroma_key_color : source_color = vec3(0.0, 1.0, 0.0);
uniform float pickup_range : hint_range(0.0, 1.0) = 0.1;
uniform float fade_amount : hint_range(0.0, 1.0) = 0.1;

void fragment() {
    # Get the color from the texture at the given UV coordinates
    vec4 color = texture(TEXTURE, UV);

    # Calculate the distance between the current color and the chroma key color
    float distance = length(color.rgb - chroma_key_color);

    # If the distance is within the pickup range, discard the pixel
    # the lesser the distance more likely the colors are
    if (distance &lt;= pickup_range) {
        discard;
    }

    # Calculate the fade factor based on the pickup range and fade amount
    float fade_factor = smoothstep(pickup_range, pickup_range + fade_amount, distance);

    # Set the output color with the original RGB values and the calculated fade factor
    COLOR = vec4(color.rgb, fade_factor);
}</literal_block>
                <paragraph>着色器使用距离计算来识别接近色键颜色的像素并将其丢弃，从而有效地删除所选颜色。距离色键颜色稍远的像素将根据 fade_factor 进行淡入淡出，从而使它们与周围的颜色平滑地混合。此过程会创建所需的色键效果，使其看起来像是背景已被其他图像或视频替换。</paragraph>
                <paragraph>上面的代码是色键着色器的简单演示，用户可以根据自己的具体要求进行自定义。</paragraph>
            </section>
            <section ids="ui-controls" names="ui\ controls ui\ 控件">
                <title>UI 控件</title>
                <paragraph>为了允许用户实时操纵色键效果，我们在 <title_reference>Control</title_reference> 节点中创建了滑动条。 <title_reference>Control</title_reference> 节点的脚本包含以下功能：</paragraph>
                <literal_block force="False" highlight_args="{}" language="gd" linenos="False" xml:space="preserve">extends Control

func _on_color_picker_button_color_changed(color):
    # Update the "chroma_key_color" shader parameter of the VideoStreamPlayer's material
    $VideoStreamPlayer.material.set("shader_parameter/chroma_key_color", color)

func _on_h_slider_value_changed(value):
    # Update the "pickup_range" shader parameter of the VideoStreamPlayer's material
    $VideoStreamPlayer.material.set("shader_parameter/pickup_range", value)

func _on_h_slider_2_value_changed(value):
    # Update the "fade_amount" shader parameter of the VideoStreamPlayer's material
    $VideoStreamPlayer.material.set("shader_parameter/fade_amount", value)

func _on_video_stream_player_finished():
    # Restart the video playback when it's finished
    $VideoStreamPlayer.play()</literal_block>
                <paragraph>还要确保滑动条的范围合适，此处我们的设置是：</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/animation/img/slider_range.webp'}" uri="tutorials/animation/img/slider_range.webp"></image>
                </block_quote>
            </section>
            <section ids="signal-handling" names="signal\ handling 信号处理">
                <title>信号处理</title>
                <paragraph>将适当的信号从 UI 元素连接到你创建的 <title_reference>Control</title_reference> 节点的脚本上，来控制色键效果。这些信号处理函数会更新着色器的 uniform 变量，响应用户输入。</paragraph>
                <paragraph>保存并运行场景来查看色键效果的实际表现！通过 godot 提供的 UI 控件，现在你可以实时调整色键颜色、拾取范围（pickup range）和淡入度量（fade amount），从而为你的视频内容实现所需的色键功能。</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
