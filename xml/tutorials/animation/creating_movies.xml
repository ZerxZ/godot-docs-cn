<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/animation/creating_movies.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-creating-movies"></target>
    <section ids="creating-movies doc-creating-movies" names="creating\ movies 创建电影 doc_creating_movies">
        <title>创建电影</title>
        <paragraph>Godot 可以为任何 2D 或 3D 项目录制<strong>非实时</strong>音视频。这种录制也叫<emphasis>离线渲染</emphasis>。适合很多不同的场景：</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>录制游戏预告片以供宣传使用。</paragraph>
            </list_item>
            <list_item>
                <paragraph>录制过场动画，这些过场动画将在最终游戏中 <reference internal="True" refuri="playing_videos#doc-playing-videos"><inline classes="std std-ref">以预先录制的视频形式展现</inline></reference>。这会在不管播放器硬件水平如何的情况下，允许使用更高质量的设置（以文件大小为代价）。</paragraph>
            </list_item>
            <list_item>
                <paragraph>记录程序生成的动画或动作设计。在视频录制过程中，仍可以进行用户交互，录制的视频中也可以包含音频（尽管在录制视频时你将无法听到它）。</paragraph>
            </list_item>
            <list_item>
                <paragraph>比较动画场景中图形设置、着色器或渲染技术的视觉输出。</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>借助 Godot 的动画功能，例如 AnimationPlayer 节点、Tweeners、粒子和着色器，它可以有效地用于创建任何类型的 2D 和 3D 动画（以及静态图像）。</paragraph>
        <paragraph>如果你已经习惯了 Godot 的工作流程，你可能会发现使用 Godot 进行视频渲染会比 Blender 更加高效。 也就是说，非实时渲染器（例如 Cycles 和 Eevee）可以带来更好的视觉效果（代价是更长的渲染时间）。</paragraph>
        <paragraph>与实时视频录像相比，非实时录像的一些优点包括：</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>无论你的硬件性能如何，都可以使用任何图形设置（包括要求极高的设置）。输出视频 <emphasis>始终</emphasis> 具有完美的帧节奏；它永远不会出现丢帧或卡顿的情况。更快的硬件将允许你在更短的时间内渲染给定的动画，而视觉输出保持不变。</paragraph>
            </list_item>
            <list_item>
                <paragraph>以比屏幕分辨率更高的分辨率进行渲染，而无需依赖特定于驱动程序的工具，例如 NVIDIA 的动态超级分辨率（Dynamic Super Resolution）或 AMD 的虚拟超级分辨率（Virtual Super Resolution）。</paragraph>
            </list_item>
            <list_item>
                <paragraph>以高于视频目标帧率的帧率进行渲染，然后进行 <reference internal="True" refid="doc-creating-movies-motion-blur"><inline classes="std std-ref">后处理以生成高质量的运动模糊</inline></reference>。这也使得在多个帧上聚合的效果（例如时间抗锯齿、SDFGI 和体积雾）看起来更好。</paragraph>
            </list_item>
        </bullet_list>
        <warning>
            <paragraph><strong>此功能并非专为在游戏中捕捉实时镜头而设计。</strong></paragraph>
            <paragraph>玩家应该使用`OBS Studio &lt;<reference refuri="https://obsproject.com/">https://obsproject.com/</reference>&gt;`__ 或`SimpleScreenRecorder &lt;<reference refuri="https://www.maartenbaert.be/simplescreenrecorder/">https://www.maartenbaert.be/simplescreenrecorder/</reference>&gt;`__ 之类的工具来录制游戏视频，因为它们可以更好地截取合成器的输出，比 Godot 使用 Vulkan 或 OpenGL 所能完成的工作要多。</paragraph>
            <paragraph>也就是说，如果你的游戏在录制时以接近实时的速度运行，你仍可以使用此功能（但它将缺少可被听见的音频播放，因为音频会直接保存到视频文件中）。</paragraph>
        </warning>
        <section ids="enabling-movie-maker-mode" names="enabling\ movie\ maker\ mode 启用\ movie\ maker\ 模式">
            <title>启用 Movie Maker 模式</title>
            <paragraph>要启用 Movie Maker 模式，请在 <emphasis>运行项目之前</emphasis> 单击编辑器右上角的“电影胶片卷”（movie reel）按钮：</paragraph>
            <figure align="center" ids="id1">
                <image alt="Movie Maker 模式已禁用时，单击“电影胶片卷”图标即可启用" candidates="{'*': 'tutorials/animation/img/creating_movies_enable_movie_maker_mode.webp'}" uri="tutorials/animation/img/creating_movies_enable_movie_maker_mode.webp"></image>
                <caption>Movie Maker 模式已禁用时，单击“电影胶片卷”图标即可启用</caption>
            </figure>
            <paragraph>当启用 Movie Maker 模式时，图标的背景会与强调色相匹配：</paragraph>
            <figure align="center" ids="id2">
                <image alt="Movie Maker 模式启动后，再次点击“电影胶片卷”图标关闭" candidates="{'*': 'tutorials/animation/img/creating_movies_disable_movie_maker_mode.webp'}" uri="tutorials/animation/img/creating_movies_disable_movie_maker_mode.webp"></image>
                <caption>Movie Maker 模式启动后，再次点击“电影胶片卷”图标关闭</caption>
            </figure>
            <paragraph>当编辑器退出时，Movie Maker 状态 <strong>不会</strong> 保留，因此如果需要，你必须在重新启动编辑器后再次重新启用 Movie Maker 模式。</paragraph>
            <note>
                <paragraph>在项目重新启动之前，运行项目时切换 Movie Maker 模式不会产生任何效果。</paragraph>
            </note>
            <paragraph>在通过运行项目录制视频之前，仍然需要配置输出文件路径。可以在项目设置中为所有场景设置该路径：</paragraph>
            <figure align="center" ids="id3">
                <image alt="Movie Maker 项目设置（启用高级选项）" candidates="{'*': 'tutorials/animation/img/creating_movies_project_settings.webp'}" uri="tutorials/animation/img/creating_movies_project_settings.webp"></image>
                <caption>Movie Maker 项目设置（启用高级选项）</caption>
            </figure>
            <paragraph>或者，你可以通过将名为 <literal>movie_file</literal> 的 String 元数据添加到场景的 <strong>根节点</strong> ，来设置每个场景的输出文件路径。仅当主场景设置为相关场景时，或者通过按 <literal classes="kbd">F6`（在 macOS 上 :kbd:`Cmd + R</literal>）直接运行场景时，该功能才会被使用。</paragraph>
            <figure align="center" ids="id4">
                <image alt="创建 String 类型的 ``movie_file`` 元数据后的检查器视图" candidates="{'*': 'tutorials/animation/img/creating_movies_set_per_scene_metadata.webp'}" uri="tutorials/animation/img/creating_movies_set_per_scene_metadata.webp"></image>
                <caption>创建 String 类型的 <literal>movie_file</literal> 元数据后的检查器视图</caption>
            </figure>
            <paragraph>项目设置或元数据中指定的路径可以是绝对路径，也可以是相对于项目根目录的路径。</paragraph>
            <paragraph>在配置并启用 Movie Maker 模式后，从编辑器运行项目时将自动使用该模式。</paragraph>
            <section ids="command-line-usage" names="command\ line\ usage 命令行用法">
                <title>命令行用法</title>
                <paragraph>Movie Maker 也可以通过<reference internal="True" refuri="../editor/command_line_tutorial#doc-command-line-tutorial"><inline classes="std std-ref">命令行</inline></reference>启用：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">godot --path /path/to/your_project --write-movie output.avi</literal_block>
                <paragraph>如果输出路径是相对路径，那么它是 <strong>相对于项目文件夹</strong> ，而不是当前工作目录。在上面的示例中，文件将被写入 <literal>/path/to/your_project/output.avi</literal> 。此行为类似于 <literal>--export</literal> 命令行参数。</paragraph>
                <paragraph>由于 Movie Maker 的输出分辨率是由视口大小设置的，因此如果项目使用 <literal>disabled</literal> 或 <literal>canvas_items</literal> <reference internal="True" refuri="../rendering/multiple_resolutions#doc-multiple-resolutions"><inline classes="std std-ref">拉伸模式</inline></reference>，你可以在启动时调整窗口大小以覆盖它：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">godot --path /path/to/your_project --write-movie output.avi --resolution 1280x720</literal_block>
                <paragraph>请注意，窗口大小受显示器分辨率的限制。如果你需要以比屏幕分辨率更高的分辨率录制视频，请参阅 <reference internal="True" refid="doc-creating-movies-recording-at-higher-resolution"><inline classes="std std-ref">以比屏幕分辨率更高的分辨率进行渲染</inline></reference>。</paragraph>
                <paragraph>录制的 FPS 也可以在命令行上覆盖，而无需编辑项目设置：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">godot --path /path/to/your_project --write-movie output.avi --fixed-fps 30</literal_block>
                <note>
                    <paragraph><literal>--write-movie</literal> 和 <literal>--fixed-fps</literal> 命令行参数在导出的项目中都可用。项目运行时无法切换 Movie Maker 模式，但可以使用 <reference internal="True" refuri="../../classes/class_os#class-os-method-execute"><inline classes="std std-ref">OS.execute()</inline></reference> 方法来运行导出项目的第二个实例以录制视频文件。</paragraph>
                </note>
            </section>
        </section>
        <section ids="choosing-an-output-format" names="choosing\ an\ output\ format 选择输出格式">
            <title>选择输出格式</title>
            <paragraph>输出格式由 <reference internal="True" refuri="../../classes/class_moviewriter#class-moviewriter"><inline classes="std std-ref">MovieWriter</inline></reference> 类提供。 Godot 有 2 个内置的 <reference internal="True" refuri="../../classes/class_moviewriter#class-moviewriter"><inline classes="std std-ref">MovieWriter</inline></reference>，更多格式可以通过扩展来实现：</paragraph>
            <section ids="avi-recommended" names="avi\ (recommended) avi（推荐）">
                <title>AVI（推荐）</title>
                <paragraph>带有 MJPEG 的 AVI 容器，用于视频和未压缩的音频。具有有损视频压缩功能，可实现中等文件大小和快速编码。有损压缩质量可以通过更改 <strong>编辑器 &gt; Movie Writer &gt; MJPEG 质量</strong> 来调整。</paragraph>
                <paragraph>生成的文件可以在大多数视频播放器中查看，但必须将其转换为另一种格式才能在 Web 上查看，或在 Godot 使用 VideoStreamPlayer 节点查看。 MJPEG 不支持透明度。 AVI 输出的文件大小目前限制为最大 4 GB。</paragraph>
                <paragraph>要使用 AVI，请指定要在 <strong>编辑器 &gt; Movie Writer &gt; 电影文件</strong> 项目设置中创建的 <literal>.avi</literal> 文件的路径。</paragraph>
            </section>
            <section ids="png" names="png">
                <title>PNG</title>
                <paragraph>用于视频的 PNG 图像序列和用于音频的 WAV 图像序列。具有无损视频压缩功能，但代价是文件较大且编码速度较慢。这被设计为 <reference internal="True" refid="doc-creating-movies-converting-avi"><inline classes="std std-ref">录制后使用外部工具编码为视频文件</inline></reference>。</paragraph>
                <paragraph>支持透明度，但根视口 <strong>必须</strong> 将其 <literal>transparent_bg</literal> 属性设置为 <literal>true</literal> ，以使透明度在输出图像上可见。这可以通过启用 <strong>渲染 &gt; 视口 &gt; 透明背景</strong> 高级项目设置来实现。 <strong>显示 &gt; 窗口 &gt; 大小 &gt; 透明</strong> 和 <strong>显示 &gt; 窗口 &gt; 像素级透明度 &gt; 启用</strong> 可以选择启用，以允许在录制视频时预览透明度，但不必在录制视频时启用它们。输出图像包含透明度。</paragraph>
                <paragraph>要使用 PNG，请指定要在 <strong>编辑器 &gt; Movie Writer &gt; 电影文件</strong> 项目设置中创建的 <literal>.png</literal> 文件。生成的 <literal>.wav</literal> 文件将与 <literal>.png</literal> 文件同名（去掉扩展名的话）。</paragraph>
            </section>
            <section ids="custom" names="custom 自定义">
                <title>自定义</title>
                <paragraph>如果你需要直接编码为不同的格式或通过第三方软件传输数据流，可以扩展 MovieWriter 类来创建你自己的电影编写器（movie writers）。出于性能原因，这通常应该使用 GDExtension 来完成。</paragraph>
            </section>
        </section>
        <section ids="configuration" names="configuration 配置">
            <title>配置</title>
            <paragraph>在项目设置的 <strong>编辑器 &gt; Movie Writer</strong> 部分中可配置多个选项。其中一些仅在启用“项目设置”对话框右上角的 <strong>高级选项</strong> 后才可见。</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>混音率：</strong> 编写电影时在录制的音频中使用的音频混合率。这可能与项目的混合速率不同，但该值必须能被录制的 FPS 整除，以防止音频随着时间的推移而失去同步。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>扬声器模式：</strong> 编写电影时录制的音频中使用的扬声器模式（stereo 立体声、5.1 环绕声或 7.1 环绕声）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>MJPEG 质量：</strong> 将视频写入 AVI 文件时使用的 JPEG 质量，介于 <literal>0.01</literal> 和 <literal>1.0</literal> （包含）之间。质量值越高，输出效果越好，但文件大小会越大。建议的质量值在 <literal>0.75</literal> 和 <literal>0.9</literal> 之间。即使质量为 <literal>1.0</literal> ，JPEG 压缩仍然是有损的。此设置不会影响音频质量，并且在写入 PNG 图像序列时会被忽略。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>电影文件：</strong> 电影的输出路径。这可以是绝对路径，或相对于项目根目录的相对路径。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>禁用垂直同步：</strong> 如果启用，则在写入电影时请求禁用垂直同步。如果硬件足够快，能够以高于显示器刷新率的帧速率渲染、编码和保存视频，这可以加快视频写入速度。如果操作系统或图形驱动程序强制垂直同步且应用程序无法禁用它，则此设置无效。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>FPS：</strong> 输出影片中每秒渲染的帧数。值越高，动画越平滑，但代价是渲染时间更长和输出文件大小更大。大多数视频托管平台不支持高于 60 的 FPS 值，但你可以使用更高的值并用它来生成运动模糊。</paragraph>
                </list_item>
            </bullet_list>
            <note>
                <paragraph>当使用 <literal>disabled</literal> 或 <literal>2d</literal> <reference internal="True" refuri="../rendering/multiple_resolutions#doc-multiple-resolutions"><inline classes="std std-ref">拉伸模式</inline></reference> 时，输出文件的分辨率由窗口大小设置。确保在启动画面结束 <emphasis>之前</emphasis> 调整窗口大小。为此，建议调整高级设置中的 <strong>显示 &gt; 窗口 &gt; 大小 &gt; 窗口宽度覆盖</strong> 和 <strong>窗口高度覆盖</strong> 。</paragraph>
                <paragraph>另见 <reference internal="True" refid="doc-creating-movies-recording-at-higher-resolution"><inline classes="std std-ref">以比屏幕分辨率更高的分辨率进行渲染</inline></reference>。</paragraph>
            </note>
        </section>
        <section ids="quitting-movie-maker-mode" names="quitting\ movie\ maker\ mode 退出\ movie\ maker\ 模式">
            <title>退出 Movie Maker 模式</title>
            <paragraph>为了安全退出使用 Movie Maker 模式的项目，请使用窗口顶部的 X 按钮，或在脚本中调用 <literal>get_tree().quit()</literal> 。你也可以使用 <literal>--quit-after N</literal> 命令行参数，其中 <literal>N</literal> 是退出前要渲染的帧数。</paragraph>
            <paragraph><strong>不建议</strong> 按 <literal classes="kbd">F8`（在 macOS 上按 :kbd:`Cmd + .</literal>）或在运行 Godot 的终端上按 <literal classes="kbd">Ctrl + C</literal>，因为这会导致 AVI 文件出现没有时长信息的不正确情况。对于 PNG 图像序列而言，PNG 图像不会有负面影响，但关联的 WAV 文件仍会缺少时长信息。</paragraph>
            <paragraph>某些视频播放器可能仍然能够播放包含有效视频和音频的 AVI 或 WAV 文件。但是，使用 AVI 或 WAV 文件的软件（例如视频编辑器）可能无法打开该文件。在这些情况下， <reference internal="True" refid="doc-creating-movies-converting-avi"><inline classes="std std-ref">使用视频转换器程序</inline></reference> 可以提供一些帮助。</paragraph>
            <paragraph>如果你使用 AnimationPlayer 来控制场景中的“主要动作”（例如摄像机移动），则可以在相关的 AnimationPlayer 节点上启用 <strong>Movie Quit On Finish</strong> 属性。启用后，当动画播放完毕 <emphasis>并且</emphasis> 引擎在 Movie Maker 模式下运行时，此属性将使 Godot 自行退出。请注意， <emphasis>此属性对循环动画没有影响</emphasis> 。因此，你需要确保动画设置为非循环。</paragraph>
        </section>
        <section ids="using-high-quality-graphics-settings" names="using\ high-quality\ graphics\ settings 使用高质量的图形设置">
            <title>使用高质量的图形设置</title>
            <paragraph><literal>movie</literal> <reference internal="True" refuri="../export/feature_tags#doc-feature-tags"><inline classes="std std-ref">功能标签</inline></reference> 可用于覆盖特定的项目设置。这对于启用高质量图形设置来说非常有用，但这些设置的速度不足以在硬件上以实时速度运行。请记住，将每个设置设为最大值仍然会降低影片保存速度，尤其是在以更高分辨率录制时。因此，建议仅在图形设置对输出图像产生可以有价值的影响时，再增加图形设置。</paragraph>
            <paragraph>还可以在脚本中查询此功能标签，以提高环境资源中设置的质量设置。例如，为了进一步改善 SDFGI 细节并减少漏光：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node3D

func _ready():
    if OS.has_feature("movie"):
        # When recording a movie, improve SDFGI cell density
        # without decreasing its maximum distance.
        get_viewport().world_3d.environment.sdfgi_min_cell_size *= 0.25
        get_viewport().world_3d.environment.sdfgi_cascades = 8</literal_block>
            <target refid="doc-creating-movies-recording-at-higher-resolution"></target>
        </section>
        <section ids="rendering-at-a-higher-resolution-than-the-screen-resolution doc-creating-movies-recording-at-higher-resolution" names="rendering\ at\ a\ higher\ resolution\ than\ the\ screen\ resolution 以比屏幕分辨率更高的分辨率进行渲染 doc_creating_movies_recording_at_higher_resolution">
            <title>以比屏幕分辨率更高的分辨率进行渲染</title>
            <paragraph>通过4K或8K等高分辨率渲染可以显着提高整体渲染质量。</paragraph>
            <note>
                <paragraph>对于 3D 渲染，Godot 在高级项目设置中提供了 <strong>渲染 &gt; 缩放 3D &gt; 缩放</strong> ，可以将其设置为高于 <literal>1.0</literal> 以获得 <emphasis>超采样抗锯齿</emphasis> 。当 3D 渲染在视口上绘制时，它会被 <emphasis>降采样</emphasis> 。这提供了一种性能代价高昂但高质量的抗锯齿形式，并且不会增加最终的输出分辨率。</paragraph>
                <paragraph>首先考虑使用此项目设置，因为与实际增加输出分辨率相比，它可以避免减慢影片写入速度和增加输出文件大小。</paragraph>
            </note>
            <paragraph>如果你希望以更高分辨率渲染 2D，或者实际上你需要更高的原始像素输出来进行 3D 渲染，则可以将分辨率提高到屏幕允许的分辨率之上。</paragraph>
            <paragraph>默认情况下，Godot 在项目中使用 <literal>disabled</literal> <reference internal="True" refuri="../rendering/multiple_resolutions#doc-multiple-resolutions"><inline classes="std std-ref">拉伸模式</inline></reference> 。如果使用 <literal>disabled</literal> 或 <literal>canvas_items</literal> 拉伸模式，窗口大小决定输出视频分辨率。</paragraph>
            <paragraph>另一方面，如果项目配置中使用 <literal>viewport</literal> 拉伸模式，则视口分辨率会决定输出视频分辨率。视口分辨率使用 <strong>显示 &gt; 窗口 &gt; 大小 &gt; 视口宽度</strong> 和 <strong>视口高度</strong> 项目设置进行设置。这可用于以比屏幕分辨率更高的分辨率渲染视频。</paragraph>
            <paragraph>要在录制过程中缩小窗口而不影响输出视频分辨率，可以将高级项目设置中 <strong>显示 &gt; 窗口 &gt; 大小 &gt; 窗口宽度覆盖</strong> 和 <strong>窗口高度覆盖</strong> 设置为大于 <literal>0</literal> 的值。</paragraph>
            <paragraph>要仅在录制电影时应用分辨率覆盖，可以使用 <literal>movie</literal> <reference internal="True" refuri="../export/feature_tags#doc-feature-tags"><inline classes="std std-ref">功能标签</inline></reference> 来覆盖这些设置。</paragraph>
        </section>
        <section ids="post-processing-steps" names="post-processing\ steps 后期处理步骤">
            <title>后期处理步骤</title>
            <paragraph>以下列出一些常见的后期处理步骤。</paragraph>
            <note>
                <paragraph>当使用多步后处理时，请尝试在单一 FFmpeg命令中执行所有这些步骤。这将避免掉多个有损的编码步骤从而节省编码时间并提高品质。</paragraph>
            </note>
            <target refid="doc-creating-movies-converting-avi"></target>
            <section ids="converting-avi-video-to-mp4 doc-creating-movies-converting-avi" names="converting\ avi\ video\ to\ mp4 将\ avi\ 视频转换为\ mp4 doc_creating_movies_converting_avi">
                <title>将 AVI 视频转换为 MP4</title>
                <paragraph>尽管 YouTube 等一些平台支持直接上传 AVI 文件，但许多其他平台则需要事先进行格式转换。<reference name="HandBrake" refuri="https://handbrake.fr/">HandBrake</reference>（GUI）和 <reference name="FFmpeg" refuri="https://ffmpeg.org/">FFmpeg</reference>（CLI）都是这方面非常流行的开源工具。FFmpeg 的学习曲线相对陡峭，但功能也更强大。</paragraph>
                <paragraph>下面的命令将 AVI 视频转换为恒定速率因子 (Constant Rate Factor ，CRF) 为 15 的 MP4 (H.264) 视频。这会产生相对较大的文件，但非常适合各种平台（例如大多数视频共享网站），因为平台会重新编码视频将其压缩到它们设置的大小：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">ffmpeg -i input.avi -crf 15 output.mp4</literal_block>
                <paragraph>要以牺牲质量为代价获得较小的文件，请 <emphasis>增加</emphasis> 上述命令中的 CRF 值。</paragraph>
                <paragraph>要获得具有更好的大小/质量比的文件（以较慢的编码时间为代价），请在上述命令中的 <literal>-crf 15</literal> 之前添加 <literal>-preset veryslow</literal> 。相反地， <literal>-preset veryfast</literal> 可用于实现更快的编码，但代价是尺寸/质量比更差。</paragraph>
                <target refid="doc-creating-movies-converting-image-sequence"></target>
            </section>
            <section ids="converting-png-image-sequence-wav-audio-to-a-video doc-creating-movies-converting-image-sequence" names="converting\ png\ image\ sequence\ +\ wav\ audio\ to\ a\ video 将\ png\ 图像序列\ +\ wav\ 音频转换为视频 doc_creating_movies_converting_image_sequence">
                <title>将 PNG 图像序列 + WAV 音频转换为视频</title>
                <paragraph>如果你选择录制 PNG 图像序列和 WAV 文件，则需要先将其转换为视频，然后才能在其他地方使用。</paragraph>
                <paragraph>Godot 生成的 PNG 图像序列的文件名始终包含 8 位数字，从 0 开始，数字以零填充。如果指定输出路径 <literal>folder/example.png</literal> ，Godot 将在该文件夹中写入 <literal>folder/example00000000.png</literal> 、 <literal>folder/example00000001.png</literal> 等。音频将保存在 <literal>folder/example.wav</literal> 中。</paragraph>
                <paragraph>FPS 使用 <literal>-r</literal> 参数指定。它应该与录制期间指定的 FPS 相匹配。否则视频会显得速度减慢或加快，并且音频与视频不同步。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">ffmpeg -r 60 -i input%08d.png -i input.wav -crf 15 output.mp4</literal_block>
                <paragraph>如果你在启用透明度的情况下录制了 PNG 图像序列，则需要使用支持存储透明度的视频格式。 MP4/H.264 不支持存储透明度，因此可以使用 WebM/VP9 作为替代方案：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">ffmpeg -r 60 -i input%08d.png -i input.wav -c:v libvpx-vp9 -crf 15 -pix_fmt yuva420p output.webm</literal_block>
                <target refid="doc-creating-movies-motion-blur"></target>
            </section>
            <section ids="cutting-video doc-creating-movies-motion-blur" names="cutting\ video 视频剪辑 doc_creating_movies_motion_blur">
                <title>视频剪辑</title>
                <paragraph>录制视频后你可以剪辑掉不想保留的视频部分。例如，要丢弃 12.1 秒之前的所有内容，并仅保留该点之后 5.2 秒的视频：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">ffmpeg -i input.avi -ss 00:00:12.10 -t 00:00:05.20 -crf 15 output.mp4</literal_block>
                <paragraph>也可以使用 GUI 工具 <reference name="LosslessCut" refuri="https://mifi.github.io/lossless-cut/">LosslessCut</reference> 来剪辑视频。</paragraph>
            </section>
            <section ids="resizing-video" names="resizing\ video 视频缩放">
                <title>视频缩放</title>
                <paragraph>以下命令将视频大小调整为 1080 像素高 (1080p)，同时保留其现有的宽高比：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">ffmpeg -i input.avi -vf "scale=-1:1080" -crf 15 output.mp4</literal_block>
                <target refid="doc-creating-movies-reducing-framerate"></target>
            </section>
            <section ids="reducing-framerate doc-creating-movies-reducing-framerate" names="reducing\ framerate 降低帧率 doc_creating_movies_reducing_framerate">
                <title>降低帧率</title>
                <paragraph>下面的命令会将视频的帧率更改为 30 FPS，如果输入视频中帧率更高，则会丢弃一些原始帧：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">ffmpeg -i input.avi -r 30 -crf 15 output.mp4</literal_block>
            </section>
            <section ids="generating-accumulation-motion-blur-with-ffmpeg" names="generating\ accumulation\ motion\ blur\ with\ ffmpeg 使用\ ffmpeg\ 生成累积运动模糊">
                <title>使用 FFmpeg 生成累积运动模糊</title>
                <paragraph>Godot 没有内置对运动模糊的支持，但仍然可以在录制的视频中创建运动模糊。</paragraph>
                <paragraph>如果你以原始帧率的几倍来录制视频，则可以将帧混合在一起，然后再减少帧率以生成具有 <emphasis>累积运动模糊</emphasis> 的视频。这种运动模糊看起来很棒，但因为必须每秒渲染更多帧，生成可能需要很长时间（除了后期处理所花费的时间之外）。</paragraph>
                <paragraph>以 240 FPS 的源视频为例，生成 4 倍运动模糊并将其输出帧率降低至 60 FPS：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">ffmpeg -i input.avi -vf "tmix=frames=4, fps=60" -crf 15 output.mp4</literal_block>
                <paragraph>因为这个操作将能够在给定时间内处理更多数据，所以也会使得在多个帧上的收敛效果（例如时间抗锯齿、SDFGI 和体积雾）变得更快，因此看起来表现更好。如果你想在不添加运动模糊的情况下获得这个表现提升，请参阅 <reference internal="True" refid="doc-creating-movies-reducing-framerate"><inline classes="std std-ref">降低帧率</inline></reference>。</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
