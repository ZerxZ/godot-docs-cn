<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/plugins/running_code_in_the_editor.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-running-code-in-the-editor"></target>
    <section ids="running-code-in-the-editor doc-running-code-in-the-editor" names="running\ code\ in\ the\ editor 在编辑器中运行代码 doc_running_code_in_the_editor">
        <title>在编辑器中运行代码</title>
        <section ids="what-is-tool" names="what\ is\ @tool? @tool\ 是什么？">
            <title><literal>@tool</literal> 是什么？</title>
            <paragraph><literal>@tool</literal> 是一行强大的代码，添加到脚本的顶部后，脚本就会在编辑器中执行。你还可以决定脚本的哪些部分在编辑器中执行、哪些部分在游戏中执行、哪部分在两者中均执行。</paragraph>
            <paragraph>你可以使用它来做很多事情, 它在层次设计中非常有用, 可以直观地呈现难以预测的事物. 以下是一些用例:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>如果你有一门发射受物理学(重力)影响的炮弹的大炮, 你可以在编辑器中画出炮弹的轨迹, 使关卡设计容易得多.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>如果你有不同跳跃高度的跳线, 你可以绘制游戏角色能跳过的最大跳跃高度, 也可以让关卡设计变得更容易.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>如果你的游戏角色不使用精灵, 却使用代码来绘制, 你可以在编辑器中执行该绘图代码以查看你的游戏角色.</paragraph>
                </list_item>
            </bullet_list>
            <danger>
                <paragraph><literal>@tool</literal> scripts run inside the editor, and let you access the scene tree
                    of the currently edited scene. This is a powerful feature which also comes
                    with caveats, as the editor does not include protections for potential
                    misuse of <literal>@tool</literal> scripts.
                    Be <strong>extremely</strong> cautious when manipulating the scene tree, especially via
                    <reference internal="True" refuri="../../classes/class_node#class-node-method-queue-free"><inline classes="std std-ref">Node.queue_free</inline></reference>, as it can cause
                    crashes if you free a node while the editor runs logic involving it.</paragraph>
            </danger>
        </section>
        <section ids="how-to-use-tool" names="how\ to\ use\ @tool">
            <title>How to use <literal>@tool</literal></title>
            <paragraph>To turn a script into a tool, add the <literal>@tool</literal> annotation at the top of your code.</paragraph>
            <paragraph>To check if you are currently in the editor, use: <literal>Engine.is_editor_hint()</literal>.</paragraph>
            <paragraph>例如, 如果你想只在编辑器中执行一些代码, 可以使用:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">if Engine.is_editor_hint():
    # Code to execute when in editor.</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">if (Engine.IsEditorHint())
{
    // Code to execute when in editor.
}</literal_block>
                </div>
            </container>
            <paragraph>另一方面, 如果你想只在游戏中执行代码, 只需否定相同的语句:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">if not Engine.is_editor_hint():
    # Code to execute when in game.</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">if (!Engine.IsEditorHint())
{
    // Code to execute when in game.
}</literal_block>
                </div>
            </container>
            <paragraph>Pieces of code that do not have either of the 2 conditions above will run both
                in-editor and in-game.</paragraph>
            <paragraph>以下是 <literal>_process()</literal> 函数的示例:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _process(delta):
    if Engine.is_editor_hint():
        # Code to execute in editor.

    if not Engine.is_editor_hint():
        # Code to execute in game.

    # Code to execute both in editor and in game.</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Process(double delta)
{
    if (Engine.IsEditorHint())
    {
        // Code to execute in editor.
    }

    if (!Engine.IsEditorHint())
    {
        // Code to execute in game.
    }

    // Code to execute both in editor and in game.
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph>Modifications in the editor are permanent. For example, in the following
                    case, when we remove the script, the node will keep its rotation. Be careful
                    to avoid making unwanted modifications.</paragraph>
            </note>
            <note>
                <paragraph>Extending a <literal>@tool</literal> script does not automatically make the extending script
                    a <literal>@tool</literal>. Omitting <literal>@tool</literal> from the extending script will disable tool
                    behavior from the super class. Therefore the extending script should also
                    specify the <literal>@tool</literal> annotation.</paragraph>
            </note>
        </section>
        <section ids="try-tool-out" names="try\ @tool\ out">
            <title>Try <literal>@tool</literal> out</title>
            <paragraph>Add a <literal>Sprite2D</literal> node to your scene and set the texture to Godot icon. Attach
                and open a script, and change it to this:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@tool
extends Sprite2D

func _process(delta):
    rotation += PI * delta</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

[Tool]
public partial class MySprite : Sprite2D
{
    public override void _Process(double delta)
    {
        Rotation += Mathf.Pi * (float)delta;
    }
}</literal_block>
                </div>
            </container>
            <paragraph>保存脚本并返回编辑器. 现在你应该看到你的对象在旋转. 如果你运行游戏, 它也会旋转.</paragraph>
            <image candidates="{'*': 'tutorials/plugins/img/rotating_in_editor.gif'}" uri="tutorials/plugins/img/rotating_in_editor.gif"></image>
            <note>
                <paragraph>如果你没有看到变化, 请重新加载场景(关闭它并再次打开).</paragraph>
            </note>
            <paragraph>现在让我们选择何时运行代码. 将 <literal>_process()</literal> 函数修改为:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _process(delta):
    if Engine.is_editor_hint():
        rotation += PI * delta
    else:
        rotation -= PI * delta</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Process(double delta)
{
    if (Engine.IsEditorHint())
    {
        Rotation += Mathf.Pi * (float)delta;
    }
    else
    {
        Rotation -= Mathf.Pi * (float)delta;
    }
}</literal_block>
                </div>
            </container>
            <paragraph>保存脚本. 现在, 对象将在编辑器中顺时针旋转, 但如果你运行游戏, 它将逆时针旋转.</paragraph>
        </section>
        <section ids="editing-variables" names="editing\ variables 编辑变量">
            <title>编辑变量</title>
            <paragraph>Add and export a variable speed to the script. To update the speed and also reset the rotation
                angle add a setter <literal>set(new_speed)</literal> which is executed with the input from the inspector. Modify
                <literal>_process()</literal> to include the rotation speed.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@tool
extends Sprite2D


@export var speed = 1:
    # Update speed and reset the rotation.
    set(new_speed):
        speed = new_speed
        rotation = 0


func _process(delta):
    rotation += PI * delta * speed</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

[Tool]
public partial class MySprite : Sprite2D
{
    private float _speed = 1;

    [Export]
    public float Speed
    {
        get =&gt; _speed;
        set
        {
            // Update speed and reset the rotation.
            _speed = value;
            Rotation = 0;
        }
    }

    public override void _Process(double delta)
    {
        Rotation += Mathf.Pi * (float)delta * speed;
    }
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph>Code from other nodes doesn't run in the editor. Your access to other nodes
                    is limited. You can access the tree and nodes, and their default properties,
                    but you can't access user variables. If you want to do so, other nodes have
                    to run in the editor too. Autoload nodes cannot be accessed in the editor at
                    all.</paragraph>
            </note>
        </section>
        <section ids="reporting-node-configuration-warnings" names="reporting\ node\ configuration\ warnings 报告节点配置警告">
            <title>报告节点配置警告</title>
            <paragraph>Godot uses a <emphasis>node configuration warning</emphasis> system to warn users about incorrectly
                configured nodes. When a node isn't configured correctly, a yellow warning sign
                appears next to the node's name in the Scene dock. When you hover or click on
                the icon, a warning message pops up. You can use this feature in your scripts to
                help you and your team avoid mistakes when setting up scenes.</paragraph>
            <paragraph>When using node configuration warnings, when any value that should affect or
                remove the warning changes, you need to call
                <reference internal="True" refuri="../../classes/class_node#class-node-method-update-configuration-warnings"><inline classes="std std-ref">update_configuration_warnings</inline></reference> .
                By default, the warning only updates when closing and reopening the scene.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Use setters to update the configuration warning automatically.
@export var title = "":
    set(p_title):
        if p_title != title:
            title = p_title
            update_configuration_warnings()

@export var description = "":
    set(p_description):
        if p_description != description:
            description = p_description
            update_configuration_warnings()


func _get_configuration_warnings():
    var warnings = []

    if title == "":
        warnings.append("Please set `title` to a non-empty value.")

    if description.length() &gt;= 100:
        warnings.append("`description` should be less than 100 characters long.")

    # Returning an empty array means "no warning".
    return warnings</literal_block>
                </div>
            </container>
        </section>
        <section ids="running-one-off-scripts-using-editorscript" names="running\ one-off\ scripts\ using\ editorscript">
            <title>Running one-off scripts using EditorScript</title>
            <paragraph>Sometimes, you need to run code just one time to automate a certain task that is
                not available in the editor out of the box. Some examples might be:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Use as a playground for GDScript or C# scripting without having to run a project.
                        <literal>print()</literal> output is displayed in the editor Output panel.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Scale all light nodes in the currently edited scene, as you noticed your level
                        ends up looking too dark or too bright after placing lights where desired.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Replace nodes that were copy-pasted with scene instances to make them easier
                        to modify later.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>This is available in Godot by extending <reference internal="True" refuri="../../classes/class_editorscript#class-editorscript"><inline classes="std std-ref">EditorScript</inline></reference> in a script.
                This provides a way to run individual scripts in the editor without having to
                create an editor plugin.</paragraph>
            <paragraph>To create an EditorScript, right-click a folder or empty space in the FileSystem
                dock then choose <strong>New &gt; Script...</strong>. In the script creation dialog, click the
                tree icon to choose an object to extend from (or enter <literal>EditorScript</literal> directly
                in the field on the left, though note this is case-sensitive):</paragraph>
            <figure align="center" ids="id1">
                <image alt="Creating an editor script in the script editor creation dialog" candidates="{'*': 'tutorials/plugins/img/running_code_in_the_editor_creating_editor_script.webp'}" uri="tutorials/plugins/img/running_code_in_the_editor_creating_editor_script.webp"></image>
                <caption>Creating an editor script in the script editor creation dialog</caption>
            </figure>
            <paragraph>This will automatically select a script template that is suited for
                EditorScripts, with a <literal>_run()</literal> method already inserted:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@tool
extends EditorScript

# Called when the script is executed (using File -&gt; Run in Script Editor).
func _run():
    pass</literal_block>
            <paragraph>This <literal>_run()</literal> method is executed when you use <strong>File &gt; Run</strong> or the keyboard
                shortcut <literal classes="kbd">Ctrl + Shift + X</literal> while the EditorScript is the currently open
                script in the script editor. This keyboard shortcut is only effective when
                currently focused on the script editor.</paragraph>
            <paragraph>Scripts that extend EditorScript must be <literal>@tool</literal> scripts to function.</paragraph>
            <warning>
                <paragraph>EditorScripts have no undo/redo functionality, so <strong>make sure to save your
                        scene before running one</strong> if the script is designed to modify any data.</paragraph>
            </warning>
            <paragraph>To access nodes in the currently edited scene, use the
                <reference internal="True" refuri="../../classes/class_editorscript#class-editorscript-method-get-scene"><inline classes="std std-ref">EditorScript.get_scene</inline></reference> method which
                returns the root Node of the currently edited scene. Here's an example that
                recursively gets all nodes in the currently edited scene and doubles the range
                of all OmniLight3D nodes:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@tool
extends EditorScript

func _run():
    for node in get_all_children(get_scene()):
        if node is OmniLight3D:
            # Don't operate on instanced subscene children, as changes are lost
            # when reloading the scene.
            # See the "Instancing scenes" section below for a description of `owner`.
            var is_instanced_subscene_child = node != get_scene() and node.owner != get_scene()
            if not is_instanced_subscene_child:
                node.omni_range *= 2.0

# This function is recursive: it calls itself to get lower levels of child nodes as needed.
# `children_acc` is the accumulator parameter that allows this function to work.
# It should be left to its default value when you call this function directly.
func get_all_children(in_node, children_acc = []):
    children_acc.push_back(in_node)
    for child in in_node.get_children():
        children_acc = get_all_children(child, children_acc)

    return children_acc</literal_block>
            <tip>
                <paragraph>You can change the currently edited scene at the top of the editor even
                    while the Script view is open. This will affect the return value of
                    <reference internal="True" refuri="../../classes/class_editorscript#class-editorscript-method-get-scene"><inline classes="std std-ref">EditorScript.get_scene</inline></reference>, so make
                    sure you've selected the scene you intend to iterate upon before running
                    the script.</paragraph>
            </tip>
        </section>
        <section ids="instancing-scenes" names="instancing\ scenes 实例化场景">
            <title>实例化场景</title>
            <paragraph>在编辑器中，你可以正常实例化打包场景，并将它们添加到当前打开的场景中。默认情况下，使用 <reference internal="True" refuri="../../classes/class_node#class-node-method-add-child"><inline classes="std std-ref">Node.add_child(node)</inline></reference> 添加的节点或场景在“场景”树面板中是<strong>不可见</strong>的，也<strong>不会</strong>持久化到磁盘上。如果你希望节点和场景在场景树面板中可见，并在保存场景时持久化到磁盘上，则需要将这些子节点的 <reference internal="True" refuri="../../classes/class_node#class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> 属性设为当前编辑场景的根节点。</paragraph>
            <paragraph>If you are using <literal>@tool</literal>:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    var node = Node3D.new()
    add_child(node) # Parent could be any node in the scene

    # The line below is required to make the node visible in the Scene tree dock
    # and persist changes made by the tool script to the saved scene file.
    node.owner = get_tree().edited_scene_root</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    var node = new Node3D();
    AddChild(node); // Parent could be any node in the scene

    // The line below is required to make the node visible in the Scene tree dock
    // and persist changes made by the tool script to the saved scene file.
    node.Owner = GetTree().EditedSceneRoot;
}</literal_block>
                </div>
            </container>
            <paragraph>如果你使用 <reference internal="True" refuri="../../classes/class_editorscript#class-editorscript"><inline classes="std std-ref">EditorScript</inline></reference> :</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _run():
    # `parent` could be any node in the scene.
    var parent = get_scene().get_node("Parent")
    var node = Node3D.new()
    parent.add_child(node)

    # The line below is required to make the node visible in the Scene tree dock
    # and persist changes made by the tool script to the saved scene file.
    node.owner = get_scene()</literal_block>
                </div>
                <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Run()
{
    // `parent` could be any node in the scene.
    var parent = GetScene().GetNode("Parent");
    var node = new Node3D();
    parent.AddChild(node);

    // The line below is required to make the node visible in the Scene tree dock
    // and persist changes made by the tool script to the saved scene file.
    node.Owner = GetScene();
}</literal_block>
                </div>
            </container>
            <warning>
                <paragraph>Using <literal>@tool</literal> improperly can yield many errors. It is advised to first
                    write the code how you want it, and only then add the <literal>@tool</literal> annotation to
                    the top. Also, make sure to separate code that runs in-editor from code that
                    runs in-game. This way, you can find bugs more easily.</paragraph>
            </warning>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
