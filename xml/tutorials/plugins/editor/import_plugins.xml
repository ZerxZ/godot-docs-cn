<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/plugins/editor/import_plugins.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-import-plugins"></target>
    <section ids="import-plugins doc-import-plugins" names="import\ plugins 导入插件 doc_import_plugins">
        <title>导入插件</title>
        <note>
            <paragraph>本教程假设你已经知道如何制作通用插件. 如有疑问, 请参阅 <reference internal="True" refuri="making_plugins#doc-making-plugins"><inline classes="std std-ref">制作插件</inline></reference> 页面. 这也假设你熟悉Godot的导入系统.</paragraph>
        </note>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>导入插件是一种特殊的编辑器工具, 它允许Godot导入自定义资源, 并将其作为一级资源对待. 编辑器本身捆绑了很多导入插件来处理常见的资源, 如PNG图片, Collada和glTF模型, Ogg Vorbis声音等等.</paragraph>
            <paragraph>This tutorial shows how to create an import plugin to load a
                custom text file as a material resource. This text file will contain three
                numeric values separated by comma, which represents the three channels of a
                color, and the resulting color will be used as the albedo (main color) of the
                imported material. In this example it contains the pure blue color
                (zero red, zero green, and full blue):</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">0,0,255</literal_block>
        </section>
        <section ids="configuration" names="configuration 配置">
            <title>配置</title>
            <paragraph>首先, 我们需要一个通用插件来处理导入插件的初始化和销毁. 让我们先添加 <literal>plugin.cfg</literal> 文件:</paragraph>
            <literal_block force="False" highlight_args="{}" language="ini" linenos="False" xml:space="preserve">[plugin]

name="Silly Material Importer"
description="Imports a 3D Material from an external text file."
author="Yours Truly"
version="1.0"
script="material_import.gd"</literal_block>
            <paragraph>然后我们需要 <literal>material_import.gd</literal> 文件来在需要时添加和删除导入插件:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># material_import.gd
@tool
extends EditorPlugin


var import_plugin


func _enter_tree():
    import_plugin = preload("import_plugin.gd").new()
    add_import_plugin(import_plugin)


func _exit_tree():
    remove_import_plugin(import_plugin)
    import_plugin = null</literal_block>
            <paragraph>当这个插件被激活时, 它将创建一个新的导入插件实例(我们很快就会制作), 并使用 <reference internal="True" refuri="../../../classes/class_editorplugin#class-editorplugin-method-add-import-plugin"><inline classes="std std-ref">add_import_plugin()</inline></reference> 方法将其加入编辑器. 我们在类成员 <literal>import_plugin'</literal> 中存储它的引用, 这样我们就可以在以后删除它时引用它. <reference internal="True" refuri="../../../classes/class_editorplugin#class-editorplugin-method-remove-import-plugin"><inline classes="std std-ref">remove_import_plugin()</inline></reference> 方法在插件停用时被调用, 以清理内存并让编辑器知道导入插件不再可用.</paragraph>
            <paragraph>注意, 导入插件是一个引用类型, 所以它不需要明确地用 <literal>free()</literal> 函数从内存中释放. 当它超出范围时, 将被引擎自动释放.</paragraph>
        </section>
        <section ids="the-editorimportplugin-class" names="the\ editorimportplugin\ class editorimportplugin\ 类">
            <title>EditorImportPlugin 类</title>
            <paragraph>这个展示的主角是 <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin"><inline classes="std std-ref">EditorImportPlugin 类</inline></reference>. 它负责实现Godot需要知道如何处理文件时调用的方法.</paragraph>
            <paragraph>让我们开始编写我们的插件, 一个方法:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># import_plugin.gd
@tool
extends EditorImportPlugin


func _get_importer_name():
    return "demos.sillymaterial"</literal_block>
            <paragraph>The first method is the
                <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-get-importer-name"><inline classes="std std-ref">_get_importer_name()</inline></reference>. This is a
                unique name for your plugin that is used by Godot to know which import was used
                in a certain file. When the files needs to be reimported, the editor will know
                which plugin to call.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_visible_name():
    return "Silly Material"</literal_block>
            <paragraph>The <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-get-visible-name"><inline classes="std std-ref">_get_visible_name()</inline></reference> method is
                responsible for returning the name of the type it imports and it will be shown to the
                user in the Import dock.</paragraph>
            <paragraph>你选择的名字应该可以接到“导入为”后面，例如<emphasis>“导入为 Silly Material”</emphasis>。你可以随心所欲地命名，但我们建议为你的插件起一个描述性的名字。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_recognized_extensions():
    return ["mtxt"]</literal_block>
            <paragraph>Godot's import system detects file types by their extension. In the
                <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-get-recognized-extensions"><inline classes="std std-ref">_get_recognized_extensions()</inline></reference>
                method you return an array of strings to represent each extension that this
                plugin can understand. If an extension is recognized by more than one plugin,
                the user can select which one to use when importing the files.</paragraph>
            <tip>
                <paragraph>许多插件可能会使用像 <literal>.json</literal> 和 <literal>.txt</literal> 这样的常见扩展. 此外, 项目中可能存在仅作为游戏数据的文件, 不应导入. 导入时必须小心以验证数据. 永远不要指望文件格式正确.</paragraph>
            </tip>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_save_extension():
    return "material"</literal_block>
            <paragraph>导入的文件被保存在项目根部的 <literal>.import</literal> 文件夹中. 它们的扩展名应与你要导入的资源类型相匹配, 但由于Godot不能告诉你将使用什么(因为同一资源可能有多个有效的扩展名), 你需要声明将在导入时使用的内容.</paragraph>
            <paragraph>由于我们正在导入材质, 因此我们将对此类资源类型使用特殊扩展. 如果要导入场景, 可以使用 <literal>scn</literal> . 通用资源可以使用 <literal>res</literal> 扩展名. 但是, 引擎不会以任何方式强制执行此操作.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_resource_type():
    return "StandardMaterial3D"</literal_block>
            <paragraph>导入的资源具有特定类型，编辑器可以据此知道它属于哪个属性槽。这样就能够将其从文件系统面板拖放到检查器的属性之中。</paragraph>
            <paragraph>In our case it's a <reference internal="True" refuri="../../../classes/class_standardmaterial3d#class-standardmaterial3d"><inline classes="std std-ref">StandardMaterial3D</inline></reference>, which can be applied to 3D
                objects.</paragraph>
            <note>
                <paragraph>如果需要从同一扩展中导入不同类型, 则必须创建多个导入插件. 你可以在另一个文件上抽象导入代码, 以避免在这方面出现重复.</paragraph>
            </note>
        </section>
        <section ids="options-and-presets" names="options\ and\ presets 选项和预设">
            <title>选项和预设</title>
            <paragraph>你的插件可以提供不同的选项, 以允许用户控制资源的导入方式. 如果一组选定的选项很常见, 你还可以创建不同的预设以使用户更容易. 下图显示了选项在编辑器中的显示方式:</paragraph>
            <image candidates="{'*': 'tutorials/plugins/editor/img/import_plugin_options.png'}" uri="tutorials/plugins/editor/img/import_plugin_options.png"></image>
            <paragraph>由于可能有许多预设并且它们用数字标识, 因此使用枚举是一个很好的做法, 因此你可以使用名称来引用它们.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@tool
extends EditorImportPlugin


enum Presets { DEFAULT }


...</literal_block>
            <paragraph>既然定义了枚举, 让我们继续看一下导入插件的方法:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_preset_count():
    return Presets.size()</literal_block>
            <paragraph>The <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-get-preset-count"><inline classes="std std-ref">_get_preset_count()</inline></reference> method
                returns the amount of presets that this plugins defines. We only have one preset
                now, but we can make this method future-proof by returning the size of our
                <literal>Presets</literal> enumeration.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_preset_name(preset_index):
    match preset_index:
        Presets.DEFAULT:
            return "Default"
        _:
            return "Unknown"</literal_block>
            <paragraph>Here we have the
                <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-get-preset-name"><inline classes="std std-ref">_get_preset_name()</inline></reference> method, which
                gives names to the presets as they will be presented to the user, so be sure to
                use short and clear names.</paragraph>
            <paragraph>我们可以在这里使用 <literal>match</literal> 语句来使代码更加结构化. 这样, 将来很容易添加新的预设. 我们使用catch all模式来返回一些东西. 虽然Godot不会要求超出你定义的预设计数的预设, 但最好是安全起见.</paragraph>
            <paragraph>如果你只有一个预设, 则可以直接返回其名称, 但如果你这样做, 则在添加更多预设时必须小心.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_import_options(path, preset_index):
    match preset_index:
        Presets.DEFAULT:
            return [{
                       "name": "use_red_anyway",
                       "default_value": false
                    }]
        _:
            return []</literal_block>
            <paragraph>This is the method which defines the available options.
                <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-get-import-options"><inline classes="std std-ref">_get_import_options()</inline></reference> returns
                an array of dictionaries, and each dictionary contains a few keys that are
                checked to customize the option as its shown to the user. The following table
                shows the possible keys:</paragraph>
            <table>
                <tgroup cols="3">
                    <colspec colwidth="19"></colspec>
                    <colspec colwidth="12"></colspec>
                    <colspec colwidth="106"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>键</paragraph>
                            </entry>
                            <entry>
                                <paragraph>类型</paragraph>
                            </entry>
                            <entry>
                                <paragraph>描述</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><literal>name</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>字符串</paragraph>
                            </entry>
                            <entry>
                                <paragraph>选项的名称. 显示时, 下划线变为空格, 首字母大写.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><literal>default_value</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>任何类型</paragraph>
                            </entry>
                            <entry>
                                <paragraph>此预设的选项的默认值.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><literal>property_hint</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>枚举值</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../../classes/class_@globalscope#enum-globalscope-propertyhint"><inline classes="std std-ref">PropertyHint</inline></reference> 中的一个值, 作为提示使用.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><literal>hint_string</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>字符串</paragraph>
                            </entry>
                            <entry>
                                <paragraph>属性的提示文本. 与你在GDScript中的 <literal>export</literal> 语句中添加相同.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><literal>usage</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>枚举值</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refuri="../../../classes/class_@globalscope#enum-globalscope-propertyusageflags"><inline classes="std std-ref">PropertyUsageFlags</inline></reference> 中的一个值来定义用途.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <paragraph><literal>name</literal> 和 <literal>default_value</literal> 键是 <strong>强制</strong> , 其余是可选的.</paragraph>
            <paragraph>Note that the <literal>_get_import_options</literal> method receives the preset number, so you
                can configure the options for each different preset (especially the default
                value). In this example we use the <literal>match</literal> statement, but if you have lots of
                options and the presets only change the value you may want to create the array
                of options first and then change it based on the preset.</paragraph>
            <warning>
                <paragraph>The <literal>_get_import_options</literal> method is called even if you don't
                    define presets (by making <literal>_get_preset_count</literal> return zero). You
                    have to return an array even it's empty, otherwise you can get
                    errors.</paragraph>
            </warning>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_option_visibility(path, option_name, options):
    return true</literal_block>
            <paragraph>For the
                <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-get-option-visibility"><inline classes="std std-ref">_get_option_visibility()</inline></reference>
                method, we simply return <literal>true</literal> because all of our options (i.e. the single
                one we defined) are visible all the time.</paragraph>
            <paragraph>如果只有在使用某个值设置了另一个选项时才需要使某个选项可见, 则可以在此方法中添加逻辑.</paragraph>
        </section>
        <section ids="the-import-method" names="the\ import\ method import\ 方法">
            <title><literal>import</literal> 方法</title>
            <paragraph>The heavy part of the process, responsible for converting the files into
                resources, is covered by the <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-import"><inline classes="std std-ref">_import()</inline></reference>
                method. Our sample code is a bit long, so let's split in a few parts:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _import(source_file, save_path, options, r_platform_variants, r_gen_files):
    var file = FileAccess.open(source_file, FileAccess.READ)
    if file == null:
        return FileAccess.get_open_error()

    var line = file.get_line()</literal_block>
            <paragraph>The first part of our import method opens and reads the source file. We use the
                <reference internal="True" refuri="../../../classes/class_fileaccess#class-fileaccess"><inline classes="std std-ref">FileAccess</inline></reference> class to do that, passing the <literal>source_file</literal>
                parameter which is provided by the editor.</paragraph>
            <paragraph>如果打开文件时出错, 我们将其返回以让编辑器知道导入不成功.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var channels = line.split(",")
if channels.size() != 3:
    return ERR_PARSE_ERROR

var color
if options.use_red_anyway:
    color = Color8(255, 0, 0)
else:
    color = Color8(int(channels[0]), int(channels[1]), int(channels[2]))</literal_block>
            <paragraph>此代码获取之前读取的文件行, 并将其拆分为以逗号分隔的片段. 如果有多于或少于三个值, 则认为该文件无效并报告错误.</paragraph>
            <paragraph>然后它创建一个新的 <reference internal="True" refuri="../../../classes/class_color#class-color"><inline classes="std std-ref">Color</inline></reference> 变量, 并根据输入文件设置其值. 如果启用了 <literal>use_red_anyway</literal> 选项, 那么它将颜色设置为纯红色.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var material = StandardMaterial3D.new()
material.albedo_color = color</literal_block>
            <paragraph>This part makes a new <reference internal="True" refuri="../../../classes/class_standardmaterial3d#class-standardmaterial3d"><inline classes="std std-ref">StandardMaterial3D</inline></reference> that is the
                imported resource. We create a new instance of it and then set its albedo color
                as the value we got before.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">return ResourceSaver.save(material, "%s.%s" % [save_path, _get_save_extension()])</literal_block>
            <paragraph>This is the last part and quite an important one, because here we save the made
                resource to the disk. The path of the saved file is generated and informed by
                the editor via the <literal>save_path</literal> parameter. Note that this comes <strong>without</strong> the
                extension, so we add it using <reference internal="True" refuri="../../scripting/gdscript/gdscript_format_string#doc-gdscript-printf"><inline classes="std std-ref">string formatting</inline></reference>. For
                this we call the <literal>_get_save_extension</literal> method that we defined earlier, so we
                can be sure that they won't get out of sync.</paragraph>
            <paragraph>我们还返回 <reference internal="True" refuri="../../../classes/class_resourcesaver#class-resourcesaver-method-save"><inline classes="std std-ref">ResourceSaver.save()</inline></reference> 方法的结果, 所以如果这一步有错误, 编辑器会知道.</paragraph>
        </section>
        <section ids="platform-variants-and-generated-files" names="platform\ variants\ and\ generated\ files 平台变体和生成的文件">
            <title>平台变体和生成的文件</title>
            <paragraph>你可能已经注意到我们的插件忽略了 <literal>import</literal> 方法的两个参数。那些是<emphasis>返回参数</emphasis>（因此它们的名称以 <literal>r</literal> 开头），这意味着编辑器会在调用你的 import 方法之后读取它们。它们都是可以填充信息的数组。</paragraph>
            <paragraph><literal>r_platform_variants</literal> 参数用于需要根据目标平台导入不同的资源. 虽然被称为 <emphasis>平台</emphasis> 变体, 但它是基于 <reference internal="True" refuri="../../export/feature_tags#doc-feature-tags"><inline classes="std std-ref">feature tags</inline></reference> 的存在, 所以即使是同一个平台也可以有多个变体, 这取决于设置.</paragraph>
            <paragraph>要导入平台变体, 需要在扩展名之前使用feature标记保存它, 然后将标记推送到 <literal>r_platform_variants</literal> 数组, 以便编辑可以知道你做了.</paragraph>
            <paragraph>例如, 假设我们为移动平台保存一个不同的材质. 我们将需要做如下的事情:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">r_platform_variants.push_back("mobile")
return ResourceSaver.save(mobile_material, "%s.%s.%s" % [save_path, "mobile", _get_save_extension()])</literal_block>
            <paragraph><literal>r_gen_files</literal> 参数用于在导入过程中生成并需要保留的额外文件. 编辑器将查看它以了解依赖关系并确保不会无意中删除额外文件.</paragraph>
            <paragraph>这也是一个数组, 应该填充你保存的文件的完整路径. 例如, 让我们为下一个传递创建另一个材质并将其保存在不同的文件中:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var next_pass = StandardMaterial3D.new()
next_pass.albedo_color = color.inverted()
var next_pass_path = "%s.next_pass.%s" % [save_path, _get_save_extension()]

err = ResourceSaver.save(next_pass, next_pass_path)
if err != OK:
    return err
r_gen_files.push_back(next_pass_path)</literal_block>
        </section>
        <section ids="trying-the-plugin" names="trying\ the\ plugin 试试这个插件">
            <title>试试这个插件</title>
            <paragraph>这是理论上的, 但是现在导入插件已经完成了, 让我们来测试一下. 确保你创建了示例文件(包含介绍部分中描述的内容)并将其另存为 <literal>test.mtxt</literal> . 然后在 "项目设置" 中激活插件.</paragraph>
            <paragraph>如果一切顺利, 导入插件将添加到编辑器中并扫描文件系统, 使自定义资源显示在FileSystem基座上. 如果选择它并聚焦导入面板, 则可以看到选择该选项的唯一选项.</paragraph>
            <paragraph>Create a MeshInstance3D node in the scene, and for its Mesh property set up a new
                SphereMesh. Unfold the Material section in the Inspector and then drag the file
                from the FileSystem dock to the material property. The object will update in the
                viewport with the blue color of the imported material.</paragraph>
            <image candidates="{'*': 'tutorials/plugins/editor/img/import_plugin_trying.png'}" uri="tutorials/plugins/editor/img/import_plugin_trying.png"></image>
            <paragraph>转到导入面板, 启用 "强制使用红色" 选项, 然后单击 "重新导入". 这将更新导入的材质, 并应该自动更新显示红色的视图.</paragraph>
            <paragraph>就是这样！ 你的第一个导入插件已经完成！ 现在就发挥创造力，为自己心爱的格式制作插件吧。这对于以自定义格式编写数据然后在 Godot 中使用它就像它们是本机资源一样非常有用。这显示了导入系统如何强大和可扩展。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
