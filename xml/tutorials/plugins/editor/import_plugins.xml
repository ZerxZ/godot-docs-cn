<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/plugins/editor/import_plugins.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-import-plugins"></target>
    <section ids="import-plugins doc-import-plugins" names="import\ plugins doc_import_plugins">
        <title>Import plugins</title>
        <note>
            <paragraph>This tutorial assumes you already know how to make generic plugins. If
                in doubt, refer to the <reference internal="True" refuri="making_plugins#doc-making-plugins"><inline classes="std std-ref">Making plugins</inline></reference> page. This also
                assumes you are acquainted with Godot's import system.</paragraph>
        </note>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>An import plugin is a special type of editor tool that allows custom resources
                to be imported by Godot and be treated as first-class resources. The editor
                itself comes bundled with a lot of import plugins to handle the common resources
                like PNG images, Collada and glTF models, Ogg Vorbis sounds, and many more.</paragraph>
            <paragraph>This tutorial shows how to create an import plugin to load a
                custom text file as a material resource. This text file will contain three
                numeric values separated by comma, which represents the three channels of a
                color, and the resulting color will be used as the albedo (main color) of the
                imported material. In this example it contains the pure blue color
                (zero red, zero green, and full blue):</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">0,0,255</literal_block>
        </section>
        <section ids="configuration" names="configuration">
            <title>Configuration</title>
            <paragraph>First we need a generic plugin that will handle the initialization and
                destruction of our import plugin. Let's add the <literal>plugin.cfg</literal> file first:</paragraph>
            <literal_block force="False" highlight_args="{}" language="ini" linenos="False" xml:space="preserve">[plugin]

name="Silly Material Importer"
description="Imports a 3D Material from an external text file."
author="Yours Truly"
version="1.0"
script="material_import.gd"</literal_block>
            <paragraph>Then we need the <literal>material_import.gd</literal> file to add and remove the import plugin
                when needed:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># material_import.gd
@tool
extends EditorPlugin


var import_plugin


func _enter_tree():
    import_plugin = preload("import_plugin.gd").new()
    add_import_plugin(import_plugin)


func _exit_tree():
    remove_import_plugin(import_plugin)
    import_plugin = null</literal_block>
            <paragraph>When this plugin is activated, it will create a new instance of the import
                plugin (which we'll soon make) and add it to the editor using the
                <reference internal="True" refuri="../../../classes/class_editorplugin#class-editorplugin-method-add-import-plugin"><inline classes="std std-ref">add_import_plugin()</inline></reference> method. We store
                a reference to it in a class member <literal>import_plugin</literal> so we can refer to it
                later when removing it. The
                <reference internal="True" refuri="../../../classes/class_editorplugin#class-editorplugin-method-remove-import-plugin"><inline classes="std std-ref">remove_import_plugin()</inline></reference> method is
                called when the plugin is deactivated to clean up the memory and let the editor
                know the import plugin isn't available anymore.</paragraph>
            <paragraph>Note that the import plugin is a reference type, so it doesn't need to be
                explicitly released from memory with the <literal>free()</literal> function. It will be
                released automatically by the engine when it goes out of scope.</paragraph>
        </section>
        <section ids="the-editorimportplugin-class" names="the\ editorimportplugin\ class">
            <title>The EditorImportPlugin class</title>
            <paragraph>The main character of the show is the
                <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin"><inline classes="std std-ref">EditorImportPlugin class</inline></reference>. It is responsible for
                implementing the methods that are called by Godot when it needs to know how to deal
                with files.</paragraph>
            <paragraph>Let's begin to code our plugin, one method at time:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># import_plugin.gd
@tool
extends EditorImportPlugin


func _get_importer_name():
    return "demos.sillymaterial"</literal_block>
            <paragraph>The first method is the
                <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-get-importer-name"><inline classes="std std-ref">_get_importer_name()</inline></reference>. This is a
                unique name for your plugin that is used by Godot to know which import was used
                in a certain file. When the files needs to be reimported, the editor will know
                which plugin to call.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_visible_name():
    return "Silly Material"</literal_block>
            <paragraph>The <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-get-visible-name"><inline classes="std std-ref">_get_visible_name()</inline></reference> method is
                responsible for returning the name of the type it imports and it will be shown to the
                user in the Import dock.</paragraph>
            <paragraph>You should choose this name as a continuation to "Import as", e.g. <emphasis>"Import as
                    Silly Material"</emphasis>. You can name it whatever you want but we recommend a
                descriptive name for your plugin.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_recognized_extensions():
    return ["mtxt"]</literal_block>
            <paragraph>Godot's import system detects file types by their extension. In the
                <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-get-recognized-extensions"><inline classes="std std-ref">_get_recognized_extensions()</inline></reference>
                method you return an array of strings to represent each extension that this
                plugin can understand. If an extension is recognized by more than one plugin,
                the user can select which one to use when importing the files.</paragraph>
            <tip>
                <paragraph>Common extensions like <literal>.json</literal> and <literal>.txt</literal> might be used by many
                    plugins. Also, there could be files in the project that are just data
                    for the game and should not be imported. You have to be careful when
                    importing to validate the data. Never expect the file to be well-formed.</paragraph>
            </tip>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_save_extension():
    return "material"</literal_block>
            <paragraph>The imported files are saved in the <literal>.import</literal> folder at the project's root.
                Their extension should match the type of resource you are importing, but since
                Godot can't tell what you'll use (because there might be multiple valid
                extensions for the same resource), you need to declare what will be used in
                the import.</paragraph>
            <paragraph>Since we're importing a Material, we'll use the special extension for such
                resource types. If you are importing a scene, you can use <literal>scn</literal>. Generic
                resources can use the <literal>res</literal> extension. However, this is not enforced in any
                way by the engine.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_resource_type():
    return "StandardMaterial3D"</literal_block>
            <paragraph>The imported resource has a specific type, so the editor can know which property
                slot it belongs to. This allows drag and drop from the FileSystem dock to a
                property in the Inspector.</paragraph>
            <paragraph>In our case it's a <reference internal="True" refuri="../../../classes/class_standardmaterial3d#class-standardmaterial3d"><inline classes="std std-ref">StandardMaterial3D</inline></reference>, which can be applied to 3D
                objects.</paragraph>
            <note>
                <paragraph>If you need to import different types from the same extension, you
                    have to create multiple import plugins. You can abstract the import
                    code on another file to avoid duplication in this regard.</paragraph>
            </note>
        </section>
        <section ids="options-and-presets" names="options\ and\ presets">
            <title>Options and presets</title>
            <paragraph>Your plugin can provide different options to allow the user to control how the
                resource will be imported. If a set of selected options is common, you can also
                create different presets to make it easier for the user. The following image
                shows how the options will appear in the editor:</paragraph>
            <image candidates="{'*': 'tutorials/plugins/editor/img/import_plugin_options.png'}" original_uri="img/import_plugin_options.png" uri="tutorials/plugins/editor/img/import_plugin_options.png"></image>
            <paragraph>Since there might be many presets and they are identified with a number, it's a
                good practice to use an enum so you can refer to them using names.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@tool
extends EditorImportPlugin


enum Presets { DEFAULT }


...</literal_block>
            <paragraph>Now that the enum is defined, let's keep looking at the methods of an import
                plugin:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_preset_count():
    return Presets.size()</literal_block>
            <paragraph>The <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-get-preset-count"><inline classes="std std-ref">_get_preset_count()</inline></reference> method
                returns the amount of presets that this plugins defines. We only have one preset
                now, but we can make this method future-proof by returning the size of our
                <literal>Presets</literal> enumeration.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_preset_name(preset_index):
    match preset_index:
        Presets.DEFAULT:
            return "Default"
        _:
            return "Unknown"</literal_block>
            <paragraph>Here we have the
                <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-get-preset-name"><inline classes="std std-ref">_get_preset_name()</inline></reference> method, which
                gives names to the presets as they will be presented to the user, so be sure to
                use short and clear names.</paragraph>
            <paragraph>We can use the <literal>match</literal> statement here to make the code more structured. This
                way it's easy to add new presets in the future. We use the catch all pattern to
                return something too. Although Godot won't ask for presets beyond the preset
                count you defined, it's always better to be on the safe side.</paragraph>
            <paragraph>If you have only one preset you could simply return its name directly, but if
                you do this you have to be careful when you add more presets.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_import_options(path, preset_index):
    match preset_index:
        Presets.DEFAULT:
            return [{
                       "name": "use_red_anyway",
                       "default_value": false
                    }]
        _:
            return []</literal_block>
            <paragraph>This is the method which defines the available options.
                <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-get-import-options"><inline classes="std std-ref">_get_import_options()</inline></reference> returns
                an array of dictionaries, and each dictionary contains a few keys that are
                checked to customize the option as it's shown to the user. The following table
                shows the possible keys:</paragraph>
            <table>
                <tgroup cols="3">
                    <colspec colwidth="19"></colspec>
                    <colspec colwidth="12"></colspec>
                    <colspec colwidth="106"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Key</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Type</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Description</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><literal>name</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>String</paragraph>
                            </entry>
                            <entry>
                                <paragraph>The name of the option. When showed, underscores become spaces and first letters are capitalized.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><literal>default_value</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Any</paragraph>
                            </entry>
                            <entry>
                                <paragraph>The default value of the option for this preset.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><literal>property_hint</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Enum value</paragraph>
                            </entry>
                            <entry>
                                <paragraph>One of the <reference internal="True" refuri="../../../classes/class_@globalscope#enum-globalscope-propertyhint"><inline classes="std std-ref">PropertyHint</inline></reference> values to use as hint.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><literal>hint_string</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>String</paragraph>
                            </entry>
                            <entry>
                                <paragraph>The hint text of the property. The same as you'd add in the <literal>export</literal> statement in GDScript.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><literal>usage</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Enum value</paragraph>
                            </entry>
                            <entry>
                                <paragraph>One of the <reference internal="True" refuri="../../../classes/class_@globalscope#enum-globalscope-propertyusageflags"><inline classes="std std-ref">PropertyUsageFlags</inline></reference> values to define the usage.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <paragraph>The <literal>name</literal> and <literal>default_value</literal> keys are <strong>mandatory</strong>, the rest are optional.</paragraph>
            <paragraph>Note that the <literal>_get_import_options</literal> method receives the preset number, so you
                can configure the options for each different preset (especially the default
                value). In this example we use the <literal>match</literal> statement, but if you have lots of
                options and the presets only change the value you may want to create the array
                of options first and then change it based on the preset.</paragraph>
            <warning>
                <paragraph>The <literal>_get_import_options</literal> method is called even if you don't
                    define presets (by making <literal>_get_preset_count</literal> return zero). You
                    have to return an array even it's empty, otherwise you can get
                    errors.</paragraph>
            </warning>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _get_option_visibility(path, option_name, options):
    return true</literal_block>
            <paragraph>For the
                <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-get-option-visibility"><inline classes="std std-ref">_get_option_visibility()</inline></reference>
                method, we simply return <literal>true</literal> because all of our options (i.e. the single
                one we defined) are visible all the time.</paragraph>
            <paragraph>If you need to make certain option visible only if another is set with a certain
                value, you can add the logic in this method.</paragraph>
        </section>
        <section ids="the-import-method" names="the\ import\ method">
            <title>The <literal>import</literal> method</title>
            <paragraph>The heavy part of the process, responsible for converting the files into
                resources, is covered by the <reference internal="True" refuri="../../../classes/class_editorimportplugin#class-editorimportplugin-private-method-import"><inline classes="std std-ref">_import()</inline></reference>
                method. Our sample code is a bit long, so let's split in a few parts:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _import(source_file, save_path, options, r_platform_variants, r_gen_files):
    var file = FileAccess.open(source_file, FileAccess.READ)
    if file == null:
        return FileAccess.get_open_error()

    var line = file.get_line()</literal_block>
            <paragraph>The first part of our import method opens and reads the source file. We use the
                <reference internal="True" refuri="../../../classes/class_fileaccess#class-fileaccess"><inline classes="std std-ref">FileAccess</inline></reference> class to do that, passing the <literal>source_file</literal>
                parameter which is provided by the editor.</paragraph>
            <paragraph>If there's an error when opening the file, we return it to let the editor know
                that the import wasn't successful.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var channels = line.split(",")
if channels.size() != 3:
    return ERR_PARSE_ERROR

var color
if options.use_red_anyway:
    color = Color.from_rgba8(255, 0, 0)
else:
    color = Color.from_rgba8(int(channels[0]), int(channels[1]), int(channels[2]))</literal_block>
            <paragraph>This code takes the line of the file it read before and splits it in pieces
                that are separated by a comma. If there are more or less than the three values,
                it considers the file invalid and reports an error.</paragraph>
            <paragraph>Then it creates a new <reference internal="True" refuri="../../../classes/class_color#class-color"><inline classes="std std-ref">Color</inline></reference> variable and sets its values
                according to the input file. If the <literal>use_red_anyway</literal> option is enabled, then
                it sets the color as a pure red instead.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var material = StandardMaterial3D.new()
material.albedo_color = color</literal_block>
            <paragraph>This part makes a new <reference internal="True" refuri="../../../classes/class_standardmaterial3d#class-standardmaterial3d"><inline classes="std std-ref">StandardMaterial3D</inline></reference> that is the
                imported resource. We create a new instance of it and then set its albedo color
                as the value we got before.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">return ResourceSaver.save(material, "%s.%s" % [save_path, _get_save_extension()])</literal_block>
            <paragraph>This is the last part and quite an important one, because here we save the made
                resource to the disk. The path of the saved file is generated and informed by
                the editor via the <literal>save_path</literal> parameter. Note that this comes <strong>without</strong> the
                extension, so we add it using <reference internal="True" refuri="../../scripting/gdscript/gdscript_format_string#doc-gdscript-printf"><inline classes="std std-ref">string formatting</inline></reference>. For
                this we call the <literal>_get_save_extension</literal> method that we defined earlier, so we
                can be sure that they won't get out of sync.</paragraph>
            <paragraph>We also return the result from the
                <reference internal="True" refuri="../../../classes/class_resourcesaver#class-resourcesaver-method-save"><inline classes="std std-ref">ResourceSaver.save()</inline></reference> method, so if there's an
                error in this step, the editor will know about it.</paragraph>
        </section>
        <section ids="platform-variants-and-generated-files" names="platform\ variants\ and\ generated\ files">
            <title>Platform variants and generated files</title>
            <paragraph>You may have noticed that our plugin ignored two arguments of the <literal>import</literal>
                method. Those are <emphasis>return arguments</emphasis> (hence the <literal>r</literal> at the beginning of their
                name), which means that the editor will read from them after calling your import
                method. Both of them are arrays that you can fill with information.</paragraph>
            <paragraph>The <literal>r_platform_variants</literal> argument is used if you need to import the resource
                differently depending on the target platform. While it's called <emphasis>platform</emphasis>
                variants, it is based on the presence of <reference internal="True" refuri="../../export/feature_tags#doc-feature-tags"><inline classes="std std-ref">feature tags</inline></reference>,
                so even the same platform can have multiple variants depending on the setup.</paragraph>
            <paragraph>To import a platform variant, you need to save it with the feature tag before
                the extension, and then push the tag to the <literal>r_platform_variants</literal> array so the
                editor can know that you did.</paragraph>
            <paragraph>For example, let's say we save a different material for a mobile platform. We
                would need to do something like the following:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">r_platform_variants.push_back("mobile")
return ResourceSaver.save(mobile_material, "%s.%s.%s" % [save_path, "mobile", _get_save_extension()])</literal_block>
            <paragraph>The <literal>r_gen_files</literal> argument is meant for extra files that are generated during
                your import process and need to be kept. The editor will look at it to
                understand the dependencies and make sure the extra file is not inadvertently
                deleted.</paragraph>
            <paragraph>This is also an array and should be filled with full paths of the files you
                save. As an example, let's create another material for the next pass and save it
                in a different file:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var next_pass = StandardMaterial3D.new()
next_pass.albedo_color = color.inverted()
var next_pass_path = "%s.next_pass.%s" % [save_path, _get_save_extension()]

err = ResourceSaver.save(next_pass, next_pass_path)
if err != OK:
    return err
r_gen_files.push_back(next_pass_path)</literal_block>
        </section>
        <section ids="trying-the-plugin" names="trying\ the\ plugin">
            <title>Trying the plugin</title>
            <paragraph>This has been theoretical, but now that the import plugin is done, let's
                test it. Make sure you created the sample file (with the contents described in
                the introduction section) and save it as <literal>test.mtxt</literal>. Then activate the plugin
                in the Project Settings.</paragraph>
            <paragraph>If everything goes well, the import plugin is added to the editor and the file
                system is scanned, making the custom resource appear on the FileSystem dock. If
                you select it and focus the Import dock, you can see the only option to select
                there.</paragraph>
            <paragraph>Create a MeshInstance3D node in the scene, and for its Mesh property set up a new
                SphereMesh. Unfold the Material section in the Inspector and then drag the file
                from the FileSystem dock to the material property. The object will update in the
                viewport with the blue color of the imported material.</paragraph>
            <image candidates="{'*': 'tutorials/plugins/editor/img/import_plugin_trying.png'}" original_uri="img/import_plugin_trying.png" uri="tutorials/plugins/editor/img/import_plugin_trying.png"></image>
            <paragraph>Go to Import dock, enable the "Use Red Anyway" option, and click on "Reimport".
                This will update the imported material and should automatically update the view
                showing the red color instead.</paragraph>
            <paragraph>And that's it! Your first import plugin is done! Now get creative and make
                plugins for your own beloved formats. This can be quite useful to write your
                data in a custom format and then use it in Godot as if they were native
                resources. This shows how the import system is powerful and extendable.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
