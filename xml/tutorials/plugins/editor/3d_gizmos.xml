<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/plugins/editor/3d_gizmos.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-3d-gizmo-plugins"></target>
    <section ids="d-gizmo-plugins doc-3d-gizmo-plugins" names="3d\ gizmo\ plugins doc_3d_gizmo_plugins">
        <title>3D gizmo plugins</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>3D gizmo plugins are used by the editor and custom plugins to define the
                gizmos attached to any kind of Node3D node.</paragraph>
            <paragraph>This tutorial shows the two main approaches to defining your own custom
                gizmos. The first option works well for simple gizmos and creates less clutter in
                your plugin structure, and the second one will let you store some per-gizmo data.</paragraph>
            <note>
                <paragraph>This tutorial assumes you already know how to make generic plugins. If
                    in doubt, refer to the <reference internal="True" refuri="making_plugins#doc-making-plugins"><inline classes="std std-ref">Making plugins</inline></reference> page.</paragraph>
            </note>
        </section>
        <section ids="the-editornode3dgizmoplugin" names="the\ editornode3dgizmoplugin">
            <title>The EditorNode3DGizmoPlugin</title>
            <paragraph>Regardless of the approach we choose, we will need to create a new
                <reference internal="True" refuri="../../../classes/class_editornode3dgizmoplugin#class-editornode3dgizmoplugin"><inline classes="std std-ref">EditorNode3DGizmoPlugin</inline></reference>. This will allow
                us to set a name for the new gizmo type and define other behaviors such as whether
                the gizmo can be hidden or not.</paragraph>
            <paragraph>This would be a basic setup:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># my_custom_gizmo_plugin.gd
extends EditorNode3DGizmoPlugin


func _get_gizmo_name():
    return "CustomNode"</literal_block>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># MyCustomEditorPlugin.gd
@tool
extends EditorPlugin


const MyCustomGizmoPlugin = preload("res://addons/my-addon/my_custom_gizmo_plugin.gd")

var gizmo_plugin = MyCustomGizmoPlugin.new()


func _enter_tree():
    add_node_3d_gizmo_plugin(gizmo_plugin)


func _exit_tree():
    remove_node_3d_gizmo_plugin(gizmo_plugin)</literal_block>
            <paragraph>For simple gizmos, inheriting <reference internal="True" refuri="../../../classes/class_editornode3dgizmoplugin#class-editornode3dgizmoplugin"><inline classes="std std-ref">EditorNode3DGizmoPlugin</inline></reference>
                is enough. If you want to store some per-gizmo data, you should go with the second approach.</paragraph>
        </section>
        <section ids="simple-approach" names="simple\ approach">
            <title>Simple approach</title>
            <paragraph>The first step is to, in our custom gizmo plugin, override the <reference internal="True" refuri="../../../classes/class_editornode3dgizmoplugin#class-editornode3dgizmoplugin-private-method-has-gizmo"><inline classes="std std-ref">_has_gizmo()</inline></reference>
                method so that it returns <literal>true</literal> when the node parameter is of our target type.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># ...


func _has_gizmo(node):
    return node is MyCustomNode3D


# ...</literal_block>
            <paragraph>Then we can override methods like <reference internal="True" refuri="../../../classes/class_editornode3dgizmoplugin#class-editornode3dgizmoplugin-private-method-redraw"><inline classes="std std-ref">_redraw()</inline></reference>
                or all the handle related ones.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># ...


func _init():
    create_material("main", Color(1, 0, 0))
    create_handle_material("handles")


func _redraw(gizmo):
    gizmo.clear()

    var node3d = gizmo.get_node_3d()

    var lines = PackedVector3Array()

    lines.push_back(Vector3(0, 1, 0))
    lines.push_back(Vector3(0, node3d.my_custom_value, 0))

    var handles = PackedVector3Array()

    handles.push_back(Vector3(0, 1, 0))
    handles.push_back(Vector3(0, node3d.my_custom_value, 0))

    gizmo.add_lines(lines, get_material("main", gizmo), false)
    gizmo.add_handles(handles, get_material("handles", gizmo), [])


# ...</literal_block>
            <paragraph>Note that we created a material in the <title_reference>_init</title_reference> method, and retrieved it in the <title_reference>_redraw</title_reference>
                method using <reference internal="True" refuri="../../../classes/class_editornode3dgizmoplugin#class-editornode3dgizmoplugin-method-get-material"><inline classes="std std-ref">get_material()</inline></reference>. This
                method retrieves one of the material's variants depending on the state of the gizmo
                (selected and/or editable).</paragraph>
            <paragraph>So the final plugin would look somewhat like this:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends EditorNode3DGizmoPlugin


const MyCustomNode3D = preload("res://addons/my-addon/my_custom_node_3d.gd")


func _init():
    create_material("main", Color(1,0,0))
    create_handle_material("handles")


func _has_gizmo(node):
    return node is MyCustomNode3D


func _redraw(gizmo):
    gizmo.clear()

    var node3d = gizmo.get_node_3d()

    var lines = PackedVector3Array()

    lines.push_back(Vector3(0, 1, 0))
    lines.push_back(Vector3(0, node3d.my_custom_value, 0))

    var handles = PackedVector3Array()

    handles.push_back(Vector3(0, 1, 0))
    handles.push_back(Vector3(0, node3d.my_custom_value, 0))

    gizmo.add_lines(lines, get_material("main", gizmo), false)
    gizmo.add_handles(handles, get_material("handles", gizmo), [])


# You should implement the rest of handle-related callbacks
# (_get_handle_name(), _get_handle_value(), _commit_handle(), ...).</literal_block>
            <paragraph>Note that we just added some handles in the <title_reference>_redraw</title_reference> method, but we still need to implement
                the rest of handle-related callbacks in <reference internal="True" refuri="../../../classes/class_editornode3dgizmoplugin#class-editornode3dgizmoplugin"><inline classes="std std-ref">EditorNode3DGizmoPlugin</inline></reference>
                to get properly working handles.</paragraph>
        </section>
        <section ids="alternative-approach" names="alternative\ approach">
            <title>Alternative approach</title>
            <paragraph>In some cases we want to provide our own implementation of <reference internal="True" refuri="../../../classes/class_editornode3dgizmo#class-editornode3dgizmo"><inline classes="std std-ref">EditorNode3DGizmo</inline></reference>,
                maybe because we want to have some state stored in each gizmo or because we are porting
                an old gizmo plugin and we don't want to go through the rewriting process.</paragraph>
            <paragraph>In these cases all we need to do is, in our new gizmo plugin, override
                <reference internal="True" refuri="../../../classes/class_editornode3dgizmoplugin#class-editornode3dgizmoplugin-private-method-create-gizmo"><inline classes="std std-ref">_create_gizmo()</inline></reference>, so it returns our custom gizmo implementation
                for the Node3D nodes we want to target.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># my_custom_gizmo_plugin.gd
extends EditorNode3DGizmoPlugin


const MyCustomNode3D = preload("res://addons/my-addon/my_custom_node_3d.gd")
const MyCustomGizmo = preload("res://addons/my-addon/my_custom_gizmo.gd")


func _init():
    create_material("main", Color(1, 0, 0))
    create_handle_material("handles")


func _create_gizmo(node):
    if node is MyCustomNode3D:
        return MyCustomGizmo.new()
    else:
        return null</literal_block>
            <paragraph>This way all the gizmo logic and drawing methods can be implemented in a new class extending
                <reference internal="True" refuri="../../../classes/class_editornode3dgizmo#class-editornode3dgizmo"><inline classes="std std-ref">EditorNode3DGizmo</inline></reference>, like so:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># my_custom_gizmo.gd
extends EditorNode3DGizmo


# You can store data in the gizmo itself (more useful when working with handles).
var gizmo_size = 3.0


func _redraw():
    clear()

    var node3d = get_node_3d()

    var lines = PackedVector3Array()

    lines.push_back(Vector3(0, 1, 0))
    lines.push_back(Vector3(gizmo_size, node3d.my_custom_value, 0))

    var handles = PackedVector3Array()

    handles.push_back(Vector3(0, 1, 0))
    handles.push_back(Vector3(gizmo_size, node3d.my_custom_value, 0))

    var material = get_plugin().get_material("main", self)
    add_lines(lines, material, false)

    var handles_material = get_plugin().get_material("handles", self)
    add_handles(handles, handles_material, [])


# You should implement the rest of handle-related callbacks
# (_get_handle_name(), _get_handle_value(), _commit_handle(), ...).</literal_block>
            <paragraph>Note that we just added some handles in the <title_reference>_redraw</title_reference> method, but we still need to implement
                the rest of handle-related callbacks in <reference internal="True" refuri="../../../classes/class_editornode3dgizmo#class-editornode3dgizmo"><inline classes="std std-ref">EditorNode3DGizmo</inline></reference>
                to get properly working handles.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
