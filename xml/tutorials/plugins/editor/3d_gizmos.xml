<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/plugins/editor/3d_gizmos.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-3d-gizmo-plugins"></target>
    <section ids="d-gizmo-plugins doc-3d-gizmo-plugins" names="3d\ gizmo\ plugins 3d\ 小工具插件 doc_3d_gizmo_plugins">
        <title>3D 小工具插件</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>3D 小工具插件是由编辑器和自定义插件来定义附加到任何类型的 Node3D 节点的小工具。</paragraph>
            <paragraph>This tutorial shows the two main approaches to defining your own custom
                gizmos. The first option works well for simple gizmos and creates less clutter in
                your plugin structure, and the second one will let you store some per-gizmo data.</paragraph>
            <note>
                <paragraph>本教程假设你已经知道如何制作通用插件。如有疑问，请参阅 <reference internal="True" refuri="making_plugins#doc-making-plugins"><inline classes="std std-ref">制作插件</inline></reference> 页面。</paragraph>
            </note>
        </section>
        <section ids="the-editornode3dgizmoplugin" names="the\ editornode3dgizmoplugin editornode3dgizmoplugin">
            <title>EditorNode3DGizmoPlugin</title>
            <paragraph>Regardless of the approach we choose, we will need to create a new
                <reference internal="True" refuri="../../../classes/class_editornode3dgizmoplugin#class-editornode3dgizmoplugin"><inline classes="std std-ref">EditorNode3DGizmoPlugin</inline></reference>. This will allow
                us to set a name for the new gizmo type and define other behaviors such as whether
                the gizmo can be hidden or not.</paragraph>
            <paragraph>这是一个基本设置:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># my_custom_gizmo_plugin.gd
extends EditorNode3DGizmoPlugin


func get_name():
    return "CustomNode"</literal_block>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># MyCustomEditorPlugin.gd
@tool
extends EditorPlugin


const MyCustomGizmoPlugin = preload("res://addons/my-addon/my_custom_gizmo_plugin.gd")

var gizmo_plugin = MyCustomGizmoPlugin.new()


func _enter_tree():
    add_node_3d_gizmo_plugin(gizmo_plugin)


func _exit_tree():
    remove_node_3d_gizmo_plugin(gizmo_plugin)</literal_block>
            <paragraph>For simple gizmos, inheriting <reference internal="True" refuri="../../../classes/class_editornode3dgizmoplugin#class-editornode3dgizmoplugin"><inline classes="std std-ref">EditorNode3DGizmoPlugin</inline></reference>
                is enough. If you want to store some per-gizmo data or you are porting a Godot 3.0 gizmo
                to 3.1+, you should go with the second approach.</paragraph>
        </section>
        <section ids="simple-approach" names="simple\ approach 简单方法">
            <title>简单方法</title>
            <paragraph>The first step is to, in our custom gizmo plugin, override the <reference internal="True" refuri="../../../classes/class_editornode3dgizmoplugin#class-editornode3dgizmoplugin-private-method-has-gizmo"><inline classes="std std-ref">_has_gizmo()</inline></reference>
                method so that it returns <literal>true</literal> when the node parameter is of our target type.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># ...


func _has_gizmo(node):
    return node is MyCustomNode3D


# ...</literal_block>
            <paragraph>Then we can override methods like <reference internal="True" refuri="../../../classes/class_editornode3dgizmoplugin#class-editornode3dgizmoplugin-private-method-redraw"><inline classes="std std-ref">_redraw()</inline></reference>
                or all the handle related ones.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># ...


func _init():
    create_material("main", Color(1, 0, 0))
    create_handle_material("handles")


func _redraw(gizmo):
    gizmo.clear()

    var node3d = gizmo.get_node_3d()

    var lines = PackedVector3Array()

    lines.push_back(Vector3(0, 1, 0))
    lines.push_back(Vector3(0, node3d.my_custom_value, 0))

    var handles = PackedVector3Array()

    handles.push_back(Vector3(0, 1, 0))
    handles.push_back(Vector3(0, node3d.my_custom_value, 0))

    gizmo.add_lines(lines, get_material("main", gizmo), false)
    gizmo.add_handles(handles, get_material("handles", gizmo), [])


# ...</literal_block>
            <paragraph>Note that we created a material in the <title_reference>_init</title_reference> method, and retrieved it in the <title_reference>_redraw</title_reference>
                method using <reference internal="True" refuri="../../../classes/class_editornode3dgizmoplugin#class-editornode3dgizmoplugin-method-get-material"><inline classes="std std-ref">get_material()</inline></reference>. This
                method retrieves one of the material's variants depending on the state of the gizmo
                (selected and/or editable).</paragraph>
            <paragraph>你最后的场景应该是这样的:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends EditorNode3DGizmoPlugin


const MyCustomNode3D = preload("res://addons/my-addon/my_custom_node_3d.gd")


func _init():
    create_material("main", Color(1,0,0))
    create_handle_material("handles")


func _has_gizmo(node):
    return node is MyCustomNode3D


func _redraw(gizmo):
    gizmo.clear()

    var node3d = gizmo.get_node_3d()

    var lines = PackedVector3Array()

    lines.push_back(Vector3(0, 1, 0))
    lines.push_back(Vector3(0, node3d.my_custom_value, 0))

    var handles = PackedVector3Array()

    handles.push_back(Vector3(0, 1, 0))
    handles.push_back(Vector3(0, node3d.my_custom_value, 0))

    gizmo.add_lines(lines, get_material("main", gizmo), false)
    gizmo.add_handles(handles, get_material("handles", gizmo), [])


# You should implement the rest of handle-related callbacks
# (_get_handle_name(), _get_handle_value(), _commit_handle(), ...).</literal_block>
            <paragraph>Note that we just added some handles in the <title_reference>_redraw</title_reference> method, but we still need to implement
                the rest of handle-related callbacks in <reference internal="True" refuri="../../../classes/class_editornode3dgizmoplugin#class-editornode3dgizmoplugin"><inline classes="std std-ref">EditorNode3DGizmoPlugin</inline></reference>
                to get properly working handles.</paragraph>
        </section>
        <section ids="alternative-approach" names="alternative\ approach 替代方法">
            <title>替代方法</title>
            <paragraph>In some cases we want to provide our own implementation of <reference internal="True" refuri="../../../classes/class_editornode3dgizmo#class-editornode3dgizmo"><inline classes="std std-ref">EditorNode3DGizmo</inline></reference>,
                maybe because we want to have some state stored in each gizmo or because we are porting
                an old gizmo plugin and we don't want to go through the rewriting process.</paragraph>
            <paragraph>In these cases all we need to do is, in our new gizmo plugin, override
                <reference internal="True" refuri="../../../classes/class_editornode3dgizmoplugin#class-editornode3dgizmoplugin-private-method-create-gizmo"><inline classes="std std-ref">_create_gizmo()</inline></reference>, so it returns our custom gizmo implementation
                for the Node3D nodes we want to target.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># my_custom_gizmo_plugin.gd
extends EditorNode3DGizmoPlugin


const MyCustomNode3D = preload("res://addons/my-addon/my_custom_node_3d.gd")
const MyCustomGizmo = preload("res://addons/my-addon/my_custom_gizmo.gd")


func _init():
    create_material("main", Color(1, 0, 0))
    create_handle_material("handles")


func _create_gizmo(node):
    if node is MyCustomNode3D:
        return MyCustomGizmo.new()
    else:
        return null</literal_block>
            <paragraph>This way all the gizmo logic and drawing methods can be implemented in a new class extending
                <reference internal="True" refuri="../../../classes/class_editornode3dgizmo#class-editornode3dgizmo"><inline classes="std std-ref">EditorNode3DGizmo</inline></reference>, like so:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># my_custom_gizmo.gd
extends EditorNode3DGizmo


# You can store data in the gizmo itself (more useful when working with handles).
var gizmo_size = 3.0


func _redraw():
    clear()

    var node3d = get_node_3d()

    var lines = PackedVector3Array()

    lines.push_back(Vector3(0, 1, 0))
    lines.push_back(Vector3(gizmo_size, node3d.my_custom_value, 0))

    var handles = PackedVector3Array()

    handles.push_back(Vector3(0, 1, 0))
    handles.push_back(Vector3(gizmo_size, node3d.my_custom_value, 0))

    var material = get_plugin().get_material("main", self)
    add_lines(lines, material, false)

    var handles_material = get_plugin().get_material("handles", self)
    add_handles(handles, handles_material, [])


# You should implement the rest of handle-related callbacks
# (_get_handle_name(), _get_handle_value(), _commit_handle(), ...).</literal_block>
            <paragraph>Note that we just added some handles in the <title_reference>_redraw</title_reference> method, but we still need to implement
                the rest of handle-related callbacks in <reference internal="True" refuri="../../../classes/class_editornode3dgizmo#class-editornode3dgizmo"><inline classes="std std-ref">EditorNode3DGizmo</inline></reference>
                to get properly working handles.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
