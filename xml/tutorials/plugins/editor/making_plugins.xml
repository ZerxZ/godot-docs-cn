<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/plugins/editor/making_plugins.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-making-plugins"></target>
    <section ids="making-plugins doc-making-plugins" names="making\ plugins doc_making_plugins">
        <title>Making plugins</title>
        <section ids="about-plugins" names="about\ plugins">
            <title>About plugins</title>
            <paragraph>A plugin is a great way to extend the editor with useful tools. It can be made
                entirely with GDScript and standard scenes, without even reloading the editor.
                Unlike modules, you don't need to create C++ code nor recompile the engine.
                While this makes plugins less powerful, there are still many things you can
                do with them. Note that a plugin is similar to any scene you can already
                make, except it is created using a script to add editor functionality.</paragraph>
            <paragraph>This tutorial will guide you through the creation of two plugins so
                you can understand how they work and be able to develop your own. The first
                is a custom node that you can add to any scene in the project, and the
                other is a custom dock added to the editor.</paragraph>
        </section>
        <section ids="creating-a-plugin" names="creating\ a\ plugin">
            <title>Creating a plugin</title>
            <paragraph>Before starting, create a new empty project wherever you want. This will serve
                as a base to develop and test the plugins.</paragraph>
            <paragraph>The first thing you need for the editor to identify a new plugin is to
                create two files: a <literal>plugin.cfg</literal> for configuration and a tool script with the
                functionality. Plugins have a standard path like <literal>addons/plugin_name</literal> inside
                the project folder. Godot provides a dialog for generating those files and
                placing them where they need to be.</paragraph>
            <paragraph>In the main toolbar, click the <literal>Project</literal> dropdown. Then click
                <literal>Project Settings...</literal>. Go to the <literal>Plugins</literal> tab and then click
                on the <inline classes="role-button role-ui">Create New Plugin</inline> button in the top-right.</paragraph>
            <paragraph>You will see the dialog appear, like so:</paragraph>
            <image candidates="{'*': 'tutorials/plugins/editor/img/making_plugins-create_plugin_dialog.webp'}" original_uri="img/making_plugins-create_plugin_dialog.webp" uri="tutorials/plugins/editor/img/making_plugins-create_plugin_dialog.webp"></image>
            <paragraph>The placeholder text in each field describes how it affects the plugin's
                creation of the files and the config file's values.</paragraph>
            <paragraph>To continue with the example, use the following values:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="ini" linenos="False" xml:space="preserve">Plugin Name: My Custom Node
Subfolder: my_custom_node
Description: A custom node made to extend the Godot Engine.
Author: Your Name Here
Version: 1.0.0
Language: GDScript
Script Name: custom_node.gd</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="ini" linenos="False" xml:space="preserve">Plugin Name: My Custom Node
Subfolder: MyCustomNode
Description: A custom node made to extend the Godot Engine.
Author: Your Name Here
Version: 1.0.0
Language: C#
Script Name: CustomNode.cs</literal_block>
                </div>
            </container>
            <warning>
                <paragraph>In C#, the EditorPlugin script needs to be compiled, which
                    requires building the project. After building the project the plugin can be
                    enabled in the <literal>Plugins</literal> tab of <literal>Project Settings</literal>.</paragraph>
            </warning>
            <paragraph>You should end up with a directory structure like this:</paragraph>
            <image candidates="{'*': 'tutorials/plugins/editor/img/making_plugins-my_custom_mode_folder.webp'}" original_uri="img/making_plugins-my_custom_mode_folder.webp" uri="tutorials/plugins/editor/img/making_plugins-my_custom_mode_folder.webp"></image>
            <paragraph><literal>plugin.cfg</literal> is an INI file with metadata about your plugin.
                The name and description help people understand what it does.
                Your name helps you get properly credited for your work.
                The version number helps others know if they have an outdated version;
                if you are unsure on how to come up with the version number, check out <reference name="Semantic Versioning" refuri="https://semver.org/">Semantic Versioning</reference><target ids="semantic-versioning" names="semantic\ versioning" refuri="https://semver.org/"></target>.
                The main script file will instruct Godot what your plugin does in the editor
                once it is active.</paragraph>
            <section ids="the-script-file" names="the\ script\ file">
                <title>The script file</title>
                <paragraph>Upon creation of the plugin, the dialog will automatically open the
                    EditorPlugin script for you. The script has two requirements that you cannot
                    change: it must be a <literal>@tool</literal> script, or else it will not load properly in the
                    editor, and it must inherit from <reference internal="True" refuri="../../../classes/class_editorplugin#class-editorplugin"><inline classes="std std-ref">EditorPlugin</inline></reference>.</paragraph>
                <warning>
                    <paragraph>In addition to the EditorPlugin script, any other GDScript that your plugin uses
                        must <emphasis>also</emphasis> be a tool. Any GDScript without <literal>@tool</literal> used by the editor
                        will act like an empty file!</paragraph>
                </warning>
                <paragraph>It's important to deal with initialization and clean-up of resources.
                    A good practice is to use the virtual function
                    <reference internal="True" refuri="../../../classes/class_node#class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree()</inline></reference> to initialize your plugin and
                    <reference internal="True" refuri="../../../classes/class_node#class-node-private-method-exit-tree"><inline classes="std std-ref">_exit_tree()</inline></reference> to clean it up. Thankfully,
                    the dialog generates these callbacks for you. Your script should look something
                    like this:</paragraph>
                <target refid="doc-making-plugins-template-code"></target>
                <container classes="sphinx-tabs" ids="doc-making-plugins-template-code" names="doc_making_plugins_template_code" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@tool
extends EditorPlugin


func _enter_tree():
    # Initialization of the plugin goes here.
    pass


func _exit_tree():
    # Clean-up of the plugin goes here.
    pass</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">#if TOOLS
using Godot;

[Tool]
public partial class CustomNode : EditorPlugin
{
    public override void _EnterTree()
    {
        // Initialization of the plugin goes here.
    }

    public override void _ExitTree()
    {
        // Clean-up of the plugin goes here.
    }
}
#endif</literal_block>
                    </div>
                </container>
                <paragraph>This is a good template to use when creating new plugins.</paragraph>
            </section>
        </section>
        <section ids="a-custom-node" names="a\ custom\ node">
            <title>A custom node</title>
            <paragraph>Sometimes you want a certain behavior in many nodes, such as a custom scene
                or control that can be reused. Instancing is helpful in a lot of cases, but
                sometimes it can be cumbersome, especially if you're using it in many
                projects. A good solution to this is to make a plugin that adds a node with a
                custom behavior.</paragraph>
            <warning>
                <paragraph>Nodes added via an EditorPlugin's <reference internal="True" refuri="../../../classes/class_editorplugin#class-editorplugin-method-add-custom-type"><inline classes="std std-ref">add_custom_type()</inline></reference>
                    function are "custom type" nodes. While they work
                    with any scripting language, they have fewer features than
                    <reference internal="True" refuri="../../scripting/gdscript/gdscript_basics#doc-gdscript-basics-class-name"><inline classes="std std-ref">the Script Class system</inline></reference>. If you
                    are using GDScript or GDExtension, we recommend using Script Classes instead.</paragraph>
                <paragraph>Custom types are still the recommended approach for C#, as it does not support
                    Script Classes.</paragraph>
            </warning>
            <paragraph>To create a new node type, you can use the function
                <reference internal="True" refuri="../../../classes/class_editorplugin#class-editorplugin-method-add-custom-type"><inline classes="std std-ref">add_custom_type()</inline></reference> from the
                <reference internal="True" refuri="../../../classes/class_editorplugin#class-editorplugin"><inline classes="std std-ref">EditorPlugin</inline></reference> class. This function can add new types to the editor
                (nodes or resources). However, before you can create the type, you need a script
                that will act as the logic for the type. While that script doesn't have to use
                the <literal>@tool</literal> annotation, it can be added so the script runs in the editor.</paragraph>
            <paragraph>For this tutorial, we'll create a button that prints a message when
                clicked. For that, we'll need a script that extends from
                <reference internal="True" refuri="../../../classes/class_button#class-button"><inline classes="std std-ref">Button</inline></reference>. It could also extend
                <reference internal="True" refuri="../../../classes/class_basebutton#class-basebutton"><inline classes="std std-ref">BaseButton</inline></reference> if you prefer:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@tool
extends Button


func _enter_tree():
    pressed.connect(clicked)


func clicked():
    print("You clicked me!")</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

[Tool]
public partial class MyButton : Button
{
    public override void _EnterTree()
    {
        Pressed += Clicked;
    }

    public void Clicked()
    {
        GD.Print("You clicked me!");
    }
}</literal_block>
                </div>
            </container>
            <paragraph>That's it for our basic button. You can save this as <literal>my_button.gd</literal> inside the
                plugin folder. You'll also need a 16Ã—16 icon to show in the scene tree. If you
                don't have one, you can grab the default one from the engine and save it in your
                <title_reference>addons/my_custom_node</title_reference> folder as <title_reference>icon.png</title_reference>, or use the default Godot logo
                (<title_reference>preload("res://icon.svg")</title_reference>).</paragraph>
            <tip>
                <paragraph>SVG images that are used as custom node icons should have the
                    <strong>Editor &gt; Scale With Editor Scale</strong> and <strong>Editor &gt; Convert Colors With Editor Theme</strong>
                    <reference internal="True" refuri="../../assets_pipeline/importing_images#doc-importing-images-editor-import-options"><inline classes="std std-ref">import options</inline></reference> enabled. This allows
                    icons to follow the editor's scale and theming settings if the icons are designed with
                    the same color palette as Godot's own icons.</paragraph>
            </tip>
            <image candidates="{'*': 'tutorials/plugins/editor/img/making_plugins-custom_node_icon.png'}" original_uri="img/making_plugins-custom_node_icon.png" uri="tutorials/plugins/editor/img/making_plugins-custom_node_icon.png"></image>
            <paragraph>Now, we need to add it as a custom type so it shows on the <strong>Create New Node</strong>
                dialog. For that, change the <literal>custom_node.gd</literal> script to the following:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@tool
extends EditorPlugin


func _enter_tree():
    # Initialization of the plugin goes here.
    # Add the new type with a name, a parent type, a script and an icon.
    #
    # NOTE: If `my_button.gd` uses `class_name MyButton`, do not call `add_custom_type()`
    # and leave this function empty instead with `pass`.
    # Script Classes and custom types will conflict if the same name is used for both.
    add_custom_type("MyButton", "Button", preload("my_button.gd"), preload("icon.png"))


func _exit_tree():
    # Clean-up of the plugin goes here.
    # Always remember to remove it from the engine when deactivated.
    #
    # NOTE: This should not be called if Script Classes are used instead.
    # In this case, leave this function empty with `pass`.
    remove_custom_type("MyButton")</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">#if TOOLS
using Godot;

[Tool]
public partial class CustomNode : EditorPlugin
{
    public override void _EnterTree()
    {
        // Initialization of the plugin goes here.
        // Add the new type with a name, a parent type, a script and an icon.
        var script = GD.Load&lt;Script&gt;("res://addons/MyCustomNode/MyButton.cs");
        var texture = GD.Load&lt;Texture2D&gt;("res://addons/MyCustomNode/Icon.png");
        AddCustomType("MyButton", "Button", script, texture);
    }

    public override void _ExitTree()
    {
        // Clean-up of the plugin goes here.
        // Always remember to remove it from the engine when deactivated.
        RemoveCustomType("MyButton");
    }
}
#endif</literal_block>
                </div>
            </container>
            <paragraph>With that done, the plugin should already be available in the plugin list in the
                <strong>Project Settings</strong>, so activate it as explained in <reference name="Checking the results" refid="checking-the-results">Checking the results</reference>.</paragraph>
            <paragraph>Then try it out by adding your new node:</paragraph>
            <image candidates="{'*': 'tutorials/plugins/editor/img/making_plugins-custom_node_create.webp'}" original_uri="img/making_plugins-custom_node_create.webp" uri="tutorials/plugins/editor/img/making_plugins-custom_node_create.webp"></image>
            <paragraph>When you add the node, you can see that it already has the script you created
                attached to it. Set a text to the button, save and run the scene. When you
                click the button, you can see some text in the console:</paragraph>
            <image candidates="{'*': 'tutorials/plugins/editor/img/making_plugins-custom_node_console.webp'}" original_uri="img/making_plugins-custom_node_console.webp" uri="tutorials/plugins/editor/img/making_plugins-custom_node_console.webp"></image>
        </section>
        <section ids="a-custom-dock" names="a\ custom\ dock">
            <title>A custom dock</title>
            <paragraph>Sometimes, you need to extend the editor and add tools that are always available.
                An easy way to do it is to add a new dock with a plugin. Docks are just scenes
                based on Control, so they are created in a way similar to usual GUI scenes.</paragraph>
            <paragraph>Creating a custom dock is done just like a custom node. Create a new
                <literal>plugin.cfg</literal> file in the <literal>addons/my_custom_dock</literal> folder, then
                add the following content to it:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">[plugin]

name="My Custom Dock"
description="A custom dock made so I can learn how to make plugins."
author="Your Name Here"
version="1.0"
script="custom_dock.gd"</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[plugin]

name="My Custom Dock"
description="A custom dock made so I can learn how to make plugins."
author="Your Name Here"
version="1.0"
script="CustomDock.cs"</literal_block>
                </div>
            </container>
            <paragraph>Then create the script <literal>custom_dock.gd</literal> in the same folder. Fill it with the
                <reference internal="True" refid="doc-making-plugins-template-code"><inline classes="std std-ref">template we've seen before</inline></reference> to get a
                good start.</paragraph>
            <paragraph>Since we're trying to add a new custom dock, we need to create the contents of
                the dock. This is nothing more than a standard Godot scene: just create
                a new scene in the editor then edit it.</paragraph>
            <paragraph>For an editor dock, the root node <strong>must</strong> be a <reference internal="True" refuri="../../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference>
                or one of its child classes. For this tutorial, you can create a single button.
                Don't forget to add some text to your button.</paragraph>
            <image candidates="{'*': 'tutorials/plugins/editor/img/making_plugins-my_custom_dock_scene.webp'}" original_uri="img/making_plugins-my_custom_dock_scene.webp" uri="tutorials/plugins/editor/img/making_plugins-my_custom_dock_scene.webp"></image>
            <paragraph>Save this scene as <literal>my_dock.tscn</literal>. Now, we need to grab the scene we created
                then add it as a dock in the editor. For this, you can rely on the function
                <reference internal="True" refuri="../../../classes/class_editorplugin#class-editorplugin-method-add-dock"><inline classes="std std-ref">add_dock()</inline></reference> from the
                <reference internal="True" refuri="../../../classes/class_editorplugin#class-editorplugin"><inline classes="std std-ref">EditorPlugin</inline></reference> class.</paragraph>
            <paragraph>You need to select a dock position and define the control to add
                (which is the scene you just created). Don't forget to
                <strong>remove the dock</strong> when the plugin is deactivated.
                The script could look like this:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@tool
extends EditorPlugin


# A class member to hold the dock during the plugin life cycle.
var dock


func _enter_tree():
    # Initialization of the plugin goes here.
    # Load the dock scene and instantiate it.
    var dock_scene = preload("res://addons/my_custom_dock/my_dock.tscn").instantiate()

    # Create the dock and add the loaded scene to it.
    dock = EditorDock.new()
    dock.add_child(dock_scene)

    dock.title = "My Dock"

    # Note that LEFT_UL means the left of the editor, upper-left dock.
    dock.default_slot = DOCK_SLOT_LEFT_UL

    # Allow the dock to be on the left or right of the editor, and to be made floating.
    dock.available_layouts = EditorDock.DOCK_LAYOUT_VERTICAL | EditorDock.DOCK_LAYOUT_FLOATING

    add_dock(dock)


func _exit_tree():
    # Clean-up of the plugin goes here.
    # Remove the dock.
    remove_dock(dock)
    # Erase the control from the memory.
    dock.queue_free()</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">#if TOOLS
using Godot;

[Tool]
public partial class CustomDock : EditorPlugin
{
    private EditorDock _dock;

    public override void _EnterTree()
    {
        var _dock_scene = GD.Load&lt;PackedScene&gt;("res://addons/MyCustomDock/MyDock.tscn").Instantiate&lt;Control&gt;();
        AddControlToDock(DockSlot.LeftUl, _dock);

        // Create the dock and add the loaded scene to it.
        _dock = new EditorDock();
        _dock.AddChild(dock_scene);

        _dock.Title = "My Dock";

        // Note that LeftUl means the left of the editor, upper-left dock.
        _dock.DefaultSlot = DockSlot.LeftUl;

        // Allow the dock to be on the left or right of the editor, and to be made floating.
        _dock.AvailableLayouts = DockLayout.Horizontal | DockLayout.Floating;

        AddDock(_dock);
    }

    public override void _ExitTree()
    {
        // Clean-up of the plugin goes here.
        // Remove the dock.
        RemoveDock(_dock);
        // Erase the control from the memory.
        _dock.QueueFree();
    }
}
#endif</literal_block>
                </div>
            </container>
            <paragraph>Note that, while the dock will initially appear at its specified position,
                the user can freely change its position and save the resulting layout.</paragraph>
            <section ids="checking-the-results" names="checking\ the\ results">
                <title>Checking the results</title>
                <paragraph>It's now time to check the results of your work. Open the <strong>Project
                        Settings</strong> and click on the <strong>Plugins</strong> tab. Your plugin should be the only one
                    on the list.</paragraph>
                <image candidates="{'*': 'tutorials/plugins/editor/img/making_plugins-project_settings.webp'}" original_uri="img/making_plugins-project_settings.webp" uri="tutorials/plugins/editor/img/making_plugins-project_settings.webp"></image>
                <paragraph>You can see the plugin is not enabled.
                    Click the <strong>Enable</strong> checkbox to activate the plugin.
                    The dock should become visible before you even close
                    the settings window. You should now have a custom dock:</paragraph>
                <image candidates="{'*': 'tutorials/plugins/editor/img/making_plugins-custom_dock.webp'}" original_uri="img/making_plugins-custom_dock.webp" uri="tutorials/plugins/editor/img/making_plugins-custom_dock.webp"></image>
                <target refid="doc-making-plugins-autoload"></target>
            </section>
        </section>
        <section ids="registering-autoloads-singletons-in-plugins doc-making-plugins-autoload" names="registering\ autoloads/singletons\ in\ plugins doc_making_plugins_autoload">
            <title>Registering autoloads/singletons in plugins</title>
            <paragraph>It is possible for editor plugins to automatically register
                <reference internal="True" refuri="../../scripting/singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">autoloads</inline></reference> when the plugin is enabled.
                This also includes unregistering the autoload when the plugin is disabled.</paragraph>
            <paragraph>This makes setting up plugins faster for users, as they no longer have to manually
                add autoloads to their project settings if your editor plugin requires the use of
                an autoload.</paragraph>
            <paragraph>Use the following code to register a singleton from an editor plugin:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@tool
extends EditorPlugin

# Replace this value with a PascalCase autoload name, as per the GDScript style guide.
const AUTOLOAD_NAME = "SomeAutoload"


func _enable_plugin():
    # The autoload can be a scene or script file.
    add_autoload_singleton(AUTOLOAD_NAME, "res://addons/my_addon/some_autoload.tscn")


func _disable_plugin():
    remove_autoload_singleton(AUTOLOAD_NAME)</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">#if TOOLS
using Godot;

[Tool]
public partial class MyEditorPlugin : EditorPlugin
{
    // Replace this value with a PascalCase autoload name.
    private const string AutoloadName = "SomeAutoload";

    public override void _EnablePlugin()
    {
        // The autoload can be a scene or script file.
        AddAutoloadSingleton(AutoloadName, "res://addons/MyAddon/SomeAutoload.tscn");
    }

    public override void _DisablePlugin()
    {
        RemoveAutoloadSingleton(AutoloadName);
    }
}
#endif</literal_block>
                </div>
            </container>
        </section>
        <section ids="using-sub-plugins" names="using\ sub-plugins">
            <title>Using sub-plugins</title>
            <paragraph>Often a plugin adds multiple things, for example a custom node and a panel.
                In those cases it might be easier to have a separate plugin script for each of those features.
                Sub-plugins can be used for this.</paragraph>
            <paragraph>First create all plugins and sub plugins as normal plugins:</paragraph>
            <image candidates="{'*': 'tutorials/plugins/editor/img/sub_plugin_creation.webp'}" original_uri="img/sub_plugin_creation.webp" uri="tutorials/plugins/editor/img/sub_plugin_creation.webp"></image>
            <paragraph>Then move the sub plugins into the main plugin folder:</paragraph>
            <image candidates="{'*': 'tutorials/plugins/editor/img/sub_plugin_moved.webp'}" original_uri="img/sub_plugin_moved.webp" uri="tutorials/plugins/editor/img/sub_plugin_moved.webp"></image>
            <paragraph>Godot will hide sub-plugins from the plugin list, so that a user can't enable or disable them.
                Instead the main plugin script should enable and disable sub-plugins like this:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@tool
extends EditorPlugin

# The main plugin is located at res://addons/my_plugin/
const PLUGIN_NAME = "my_plugin"

func _enable_plugin():
    EditorInterface.set_plugin_enabled(PLUGIN_NAME + "/node", true)
    EditorInterface.set_plugin_enabled(PLUGIN_NAME + "/panel", true)

func _disable_plugin():
    EditorInterface.set_plugin_enabled(PLUGIN_NAME + "/node", false)
    EditorInterface.set_plugin_enabled(PLUGIN_NAME + "/panel", false)</literal_block>
                </div>
            </container>
        </section>
        <section ids="going-beyond" names="going\ beyond">
            <title>Going beyond</title>
            <paragraph>Now that you've learned how to make basic plugins, you can extend the editor in
                several ways. Lots of functionality can be added to the editor with GDScript;
                it is a powerful way to create specialized editors without having to delve into
                C++ modules.</paragraph>
            <paragraph>You can make your own plugins to help yourself and share them in the
                <reference name="Asset Library" refuri="https://godotengine.org/asset-library/">Asset Library</reference><target ids="asset-library" names="asset\ library" refuri="https://godotengine.org/asset-library/"></target> so that people
                can benefit from your work.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
