<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/plugins/editor/inspector_plugins.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-inspector-plugins"></target>
    <section ids="inspector-plugins doc-inspector-plugins" names="inspector\ plugins 检查器插件 doc_inspector_plugins">
        <title>检查器插件</title>
        <paragraph>检查器面板支持以插件的形式来创建自定义小工具编辑属性。尽管可以用它来修改内置类型的检查器小工具，但它在需要处理自定义数据类型和资源时尤其有用。你不但可以为特定的属性或者整个对象设计自定义控件，还可以为特定数据类型设计单独的控件。</paragraph>
        <paragraph>这份指南会介绍如何使用 <reference internal="True" refuri="../../../classes/class_editorinspectorplugin#class-editorinspectorplugin"><inline classes="std std-ref">EditorInspectorPlugin</inline></reference> 和 <reference internal="True" refuri="../../../classes/class_editorproperty#class-editorproperty"><inline classes="std std-ref">EditorProperty</inline></reference> 类来为整数类型创建自定义的界面，将默认的行为替换为一个按了以后就会生成 0 到 99 之间随机数的按钮。</paragraph>
        <figure align="center" ids="id1">
            <image candidates="{'*': 'tutorials/plugins/editor/img/inspector_plugin_example.png'}" uri="tutorials/plugins/editor/img/inspector_plugin_example.png"></image>
            <caption>左图为默认行为，右图为最终结果。</caption>
        </figure>
        <section ids="setting-up-your-plugin" names="setting\ up\ your\ plugin 创建你的插件">
            <title>创建你的插件</title>
            <paragraph>从创建新的空插件开始。</paragraph>
            <seealso>
                <paragraph>如何创建新插件请参阅 <reference internal="True" refuri="making_plugins#doc-making-plugins"><inline classes="std std-ref">制作插件</inline></reference>。</paragraph>
            </seealso>
            <paragraph>让我们假设你的插件文件夹叫做 <literal>my_inspector_plugin</literal>。那么此时你新建的 <literal>addons/my_inspector_plugin</literal> 文件夹中就有两个文件：<literal>plugin.cfg</literal> 和 <literal>plugin.gd</literal>。</paragraph>
            <paragraph>和之前一样，<literal>plugin.gd</literal> 是一个扩展了 <reference internal="True" refuri="../../../classes/class_editorplugin#class-editorplugin"><inline classes="std std-ref">EditorPlugin</inline></reference> 的脚本，你需要在 <literal>_enter_tree</literal> 和 <literal>_exit_tree</literal> 方法中加入新的代码。要创建自己的检查器插件，你必须加载对应的脚本，然后创建并调用 <literal>add_inspector_plugin()</literal> 来添加实例。禁用插件时，你应该调用 <literal>remove_inspector_plugin()</literal> 将该实例移除。</paragraph>
            <note>
                <paragraph>因为你在这里读取的是脚本而不是场景包，所以应该使用 <literal>new()</literal> 而不是 <literal>instance()</literal>。</paragraph>
            </note>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># plugin.gd
@tool
extends EditorPlugin

var plugin


func _enter_tree():
    plugin = preload("res://addons/my_inspector_plugin/my_inspector_plugin.gd").new()
    add_inspector_plugin(plugin)


func _exit_tree():
    remove_inspector_plugin(plugin)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Plugin.cs
#if TOOLS
using Godot;

[Tool]
public partial class Plugin : EditorPlugin
{
    private MyInspectorPlugin _plugin;

    public override void _EnterTree()
    {
        _plugin = new MyInspectorPlugin();
        AddInspectorPlugin(_plugin);
    }

    public override void _ExitTree()
    {
        RemoveInspectorPlugin(_plugin);
    }
}
#endif</literal_block>
                </div>
            </container>
        </section>
        <section ids="interacting-with-the-inspector" names="interacting\ with\ the\ inspector 与检查器交互">
            <title>与检查器交互</title>
            <paragraph>要和检查器面板交互，你的 <literal>my_inspector_plugin.gd</literal> 脚本必须继承自 <reference internal="True" refuri="../../../classes/class_editorinspectorplugin#class-editorinspectorplugin"><inline classes="std std-ref">EditorInspectorPlugin</inline></reference> 类。这个类提供了不少虚方法，可以用来控制检查器对属性的处理。</paragraph>
            <paragraph>脚本必须实现 <literal>can_handle()</literal> 方法才能生效。这个函数会针对每个被编辑的 <reference internal="True" refuri="../../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference> 对象调用，插件想要处理该对象或其属性的话，就必须返回 <literal>true</literal>。</paragraph>
            <note>
                <paragraph>要处理附加在该对象上的 <reference internal="True" refuri="../../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> 也同样如此。</paragraph>
            </note>
            <paragraph>You can implement four other methods to add controls to the inspector at
                specific positions. The <literal>_parse_begin()</literal> and <literal>_parse_end()</literal> methods are called
                only once at the beginning and the end of parsing for each object, respectively.
                They can add controls at the top or bottom of the inspector layout by calling
                <literal>add_custom_control()</literal>.</paragraph>
            <paragraph>As the editor parses the object, it calls the <literal>_parse_category()</literal> and
                <literal>_parse_property()</literal> methods. There, in addition to <literal>add_custom_control()</literal>,
                you can call both <literal>add_property_editor()</literal> and
                <literal>add_property_editor_for_multiple_properties()</literal>. Use these last two methods to
                specifically add <reference internal="True" refuri="../../../classes/class_editorproperty#class-editorproperty"><inline classes="std std-ref">EditorProperty</inline></reference>-based controls.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># my_inspector_plugin.gd
extends EditorInspectorPlugin

var RandomIntEditor = preload("res://addons/my_inspector_plugin/random_int_editor.gd")


func _can_handle(object):
    # We support all objects in this example.
    return true


func _parse_property(object, type, name, hint_type, hint_string, usage_flags, wide):
    # We handle properties of type integer.
    if type == TYPE_INT:
        # Create an instance of the custom property editor and register
        # it to a specific property path.
        add_property_editor(name, RandomIntEditor.new())
        # Inform the editor to remove the default property editor for
        # this property type.
        return true
    else:
        return false</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// MyInspectorPlugin.cs
#if TOOLS
using Godot;

public partial class MyInspectorPlugin : EditorInspectorPlugin
{
    public override bool _CanHandle(GodotObject @object)
    {
        // We support all objects in this example.
        return true;
    }

    public override bool _ParseProperty(GodotObject @object, Variant.Type type,
        string name, PropertyHint hintType, string hintString,
        PropertyUsageFlags usageFlags, bool wide)
    {
        // We handle properties of type integer.
        if (type == Variant.Type.Int)
        {
            // Create an instance of the custom property editor and register
            // it to a specific property path.
            AddPropertyEditor(name, new RandomIntEditor());
            // Inform the editor to remove the default property editor for
            // this property type.
            return true;
        }

        return false;
    }
}
#endif</literal_block>
                </div>
            </container>
        </section>
        <section ids="adding-an-interface-to-edit-properties" names="adding\ an\ interface\ to\ edit\ properties 添加编辑属性的界面">
            <title>添加编辑属性的界面</title>
            <paragraph><reference internal="True" refuri="../../../classes/class_editorproperty#class-editorproperty"><inline classes="std std-ref">EditorProperty</inline></reference> 是一种特殊的 <reference internal="True" refuri="../../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference>，可以与检查器面板所编辑的对象进行交互。它本身不显示任何内容，但可以放入其他控件节点，甚至是复杂的场景。</paragraph>
            <paragraph>扩展 <reference internal="True" refuri="../../../classes/class_editorproperty#class-editorproperty"><inline classes="std std-ref">EditorProperty</inline></reference> 的脚本有三个必不可少的部分：</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>必须定义 <literal>_init()</literal> 方法，设置控件节点的结构。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>应该实现 <literal>_update_property()</literal>，处理外部对数据的更改。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>必须在某处使用 <literal>emit_changed</literal> 触发信号，告知检查器本控件对属性进行了修改。</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>显示自定义小工具的方法有两种。可以只用默认的 <literal>add_child()</literal> 方法可以把它显示到属性名称的右边，在 <literal>add_child()</literal> 之后再调用 <literal>set_bottom_editor()</literal> 就可以把它显示到名称的下边。</paragraph>
            <comment xml:space="preserve">FIXME: The second tab has the C# lexer for hightlighting disabled for now, as the provided code causes errors.</comment>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># random_int_editor.gd
extends EditorProperty


# The main control for editing the property.
var property_control = Button.new()
# An internal value of the property.
var current_value = 0
# A guard against internal changes when the property is updated.
var updating = false


func _init():
    # Add the control as a direct child of EditorProperty node.
    add_child(property_control)
    # Make sure the control is able to retain the focus.
    add_focusable(property_control)
    # Setup the initial state and connect to the signal to track changes.
    refresh_control_text()
    property_control.pressed.connect(_on_button_pressed)


func _on_button_pressed():
    # Ignore the signal if the property is currently being updated.
    if (updating):
        return

    # Generate a new random integer between 0 and 99.
    current_value = randi() % 100
    refresh_control_text()
    emit_changed(get_edited_property(), current_value)


func _update_property():
    # Read the current value from the property.
    var new_value = get_edited_object()[get_edited_property()]
    if (new_value == current_value):
        return

    # Update the control with the new value.
    updating = true
    current_value = new_value
    refresh_control_text()
    updating = false

func refresh_control_text():
    property_control.text = "Value: " + str(current_value)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// RandomIntEditor.cs
#if TOOLS
using Godot;

public partial class RandomIntEditor : EditorProperty
{
    // The main control for editing the property.
    private Button _propertyControl = new Button();
    // An internal value of the property.
    private int _currentValue = 0;
    // A guard against internal changes when the property is updated.
    private bool _updating = false;

    public RandomIntEditor()
    {
        // Add the control as a direct child of EditorProperty node.
        AddChild(_propertyControl);
        // Make sure the control is able to retain the focus.
        AddFocusable(_propertyControl);
        // Setup the initial state and connect to the signal to track changes.
        RefreshControlText();
        _propertyControl.Pressed += OnButtonPressed;
    }

    private void OnButtonPressed()
    {
        // Ignore the signal if the property is currently being updated.
        if (_updating)
        {
            return;
        }

        // Generate a new random integer between 0 and 99.
        _currentValue = (int)GD.Randi() % 100;
        RefreshControlText();
        EmitChanged(GetEditedProperty(), _currentValue);
    }

    public override void _UpdateProperty()
    {
        // Read the current value from the property.
        var newValue = (int)GetEditedObject().Get(GetEditedProperty());
        if (newValue == _currentValue)
        {
            return;
        }

        // Update the control with the new value.
        _updating = true;
        _currentValue = newValue;
        RefreshControlText();
        _updating = false;
    }

    private void RefreshControlText()
    {
        _propertyControl.Text = $"Value: {_currentValue}";
    }
}
#endif</literal_block>
                </div>
            </container>
            <paragraph>使用上面的示例代码，可以实现用自定义的小工具替代整数默认的 <reference internal="True" refuri="../../../classes/class_spinbox#class-spinbox"><inline classes="std std-ref">SpinBox</inline></reference> 控件，点击 <reference internal="True" refuri="../../../classes/class_button#class-button"><inline classes="std std-ref">Button</inline></reference> 后生成随机值。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
