<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/nodes_and_scene_instances.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-nodes-and-scene-instances"></target>
    <section ids="nodes-and-scene-instances doc-nodes-and-scene-instances" names="nodes\ and\ scene\ instances 节点与场景实例 doc_nodes_and_scene_instances">
        <title>节点与场景实例</title>
        <paragraph>本指南将介绍如何获取节点、创建节点，如何将节点添加为子项，以及如何使用代码实例化场景。</paragraph>
        <section ids="getting-nodes" names="getting\ nodes 获取节点">
            <title>获取节点</title>
            <paragraph>你可以通过调用 <reference internal="True" refuri="../../classes/class_node#class-node-method-get-node"><inline classes="std std-ref">Node.get_node()</inline></reference> 方法来获取对某个节点的引用，此时子节点必须在场景树中才能获取成功。在父节点的 <literal>_ready()</literal> 函数中获取就可以保证这一点。</paragraph>
            <paragraph>例如，如果有这样的场景树，你希望获得对 Sprite2D 和 Camera2D 节点的引用，以便在脚本中访问这些节点。</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/nodes_and_scene_instances_player_scene_example.webp'}" uri="tutorials/scripting/img/nodes_and_scene_instances_player_scene_example.webp"></image>
            <paragraph>那么，你便可以使用如下代码。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var sprite2d
var camera2d

func _ready():
    sprite2d = get_node("Sprite2D")
    camera2d = get_node("Camera2D")</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private Sprite2D _sprite2D;
private Camera2D _camera2D;

public override void _Ready()
{
    base._Ready();

    _sprite2D = GetNode&lt;Sprite2D&gt;("Sprite2D");
    _camera2D = GetNode&lt;Camera2D&gt;("Camera2D");
}</literal_block>
                </div>
            </container>
            <paragraph>请注意：你是通过名称来获取节点的，而非通过节点的类型来获取的。上面的“Sprite2D”和“Camera2D”都是这些节点在场景中的名字。</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/nodes_and_scene_instances_sprite_node.webp'}" uri="tutorials/scripting/img/nodes_and_scene_instances_sprite_node.webp"></image>
            <paragraph>如果你在“场景”面板中将“Sprite2D”节点重命名为“Skin”，那么就必须在脚本里把获得节点的那一行语句改成 <literal>get_node("Skin")</literal>。</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/nodes_and_scene_instances_sprite_node_renamed.webp'}" uri="tutorials/scripting/img/nodes_and_scene_instances_sprite_node_renamed.webp"></image>
        </section>
        <section ids="node-paths" names="node\ paths 节点路径">
            <title>节点路径</title>
            <paragraph>获取节点的引用时，并不仅限于直接子节点。<literal>get_node()</literal> 函数支持使用节点路径来获取节点。节点路径有点类似文件浏览器里的路径，可以用斜杠来分隔节点。</paragraph>
            <paragraph>在下面这个实例场景中，脚本是附加在 UserInterface 节点上的。</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/nodes_and_scene_instances_ui_scene_example.webp'}" uri="tutorials/scripting/img/nodes_and_scene_instances_ui_scene_example.webp"></image>
            <paragraph>要获取 AnimationPlayer 节点，你可以使用如下代码。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var animation_player

func _ready():
    animation_player = get_node("ShieldBar/AnimationPlayer")</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private AnimationPlayer _animationPlayer;

public override void _Ready()
{
    base._Ready();

    _animationPlayer = GetNode&lt;AnimationPlayer&gt;("ShieldBar/AnimationPlayer");
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph>和文件路径一样，你也可以使用“..”来获取父节点，最好不要这么做，以免破坏封装。你还可以让路径以斜杠开头，这样的路径叫做绝对路径，其最上层的节点就是“/root”，即程序预定义的根视口。</paragraph>
            </note>
            <section ids="syntactic-sugar" names="syntactic\ sugar 语法糖">
                <title>语法糖</title>
                <paragraph>GDScript 中有两个快速写法来缩短节点获取代码的长度。首先是在成员变量的前面写上 <literal>@onready</literal> 注解，这样这个变量就会刚好在 <literal>_ready()</literal> 回调之前初始化。</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@onready var sprite2d = get_node("Sprite2D")</literal_block>
                <paragraph>还有一个快速写法就是 <literal>get_node()</literal> 的缩写：美元符号“$”，可以把它放在想要获取的名称或者节点路径之前。</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@onready var sprite2d = $Sprite2D
@onready var animation_player = $ShieldBar/AnimationPlayer</literal_block>
            </section>
        </section>
        <section ids="creating-nodes" names="creating\ nodes 创建节点">
            <title>创建节点</title>
            <paragraph>要通过代码创建节点，请像对象类型一样，调用其 <literal>new()</literal> 方法。</paragraph>
            <paragraph>你可以将新创建的节点的引用保存在一个变量中，然后调用 <literal>add_child()</literal> 方法，将其添加为脚本所在节点的子节点。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var sprite2d

func _ready():
    var sprite2d = Sprite2D.new() # Create a new Sprite2D.
    add_child(sprite2d) # Add it as a child of this node.</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private Sprite2D _sprite2D;

public override void _Ready()
{
    base._Ready();

    _sprite2D = new Sprite2D(); // Create a new Sprite2D.
    AddChild(_sprite2D); // Add it as a child of this node.
}</literal_block>
                </div>
            </container>
            <paragraph>要删除节点、将其从内存中释放，可以调用其 <literal>queue_free()</literal> 方法。这样，该节点的删除操作就会被排进一个队列当中，在当前帧处理完成之后就会执行队列中的节点删除操作。删除时，引擎会把该节点从场景（树）中删除，然后释放内存中相应的对象。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">sprite2d.queue_free()</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">_sprite2D.QueueFree();</literal_block>
                </div>
            </container>
            <paragraph>在调用 <literal>sprite2d.queue_free()</literal> 之前，远程场景树是这样的。</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/nodes_and_scene_instances_remote_tree_with_sprite.webp'}" uri="tutorials/scripting/img/nodes_and_scene_instances_remote_tree_with_sprite.webp"></image>
            <paragraph>在引擎释放节点后，远程场景树就不会再显示这个精灵节点了。</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/nodes_and_scene_instances_remote_tree_no_sprite.webp'}" uri="tutorials/scripting/img/nodes_and_scene_instances_remote_tree_no_sprite.webp"></image>
            <paragraph>你也可以调用 <literal>free()</literal> 来立即删除该节点。调用时需要小心：所有对它的引用都会立即变成 <literal>null</literal>，除非你知道自己在干什么，否则建议使用 <literal>queue_free()</literal>。</paragraph>
            <paragraph>释放节点时也会释放其所有子节点。得益于此，只需删除最顶端的父节点，就可以在场景树中删除该节点及其所有子孙节点了。</paragraph>
        </section>
        <section ids="instancing-scenes" names="instancing\ scenes 实例化场景">
            <title>实例化场景</title>
            <paragraph>场景就是模板，你可以用场景来创建出任意数量的复制品，这种的操作就叫作实例化（instancing）。在代码中进行实例化总共分两步：</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>从本地硬盘中加载场景。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>创建已加载好的 <reference internal="True" refuri="../../classes/class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference> 资源的实例。</paragraph>
                </list_item>
            </enumerated_list>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var scene = load("res://my_scene.tscn")</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var scene = GD.Load&lt;PackedScene&gt;("res://MyScene.tscn");</literal_block>
                </div>
            </container>
            <paragraph>预加载场景可以提升用户体验，因为加载操作是发生在编译器读取脚本的时候进行的，而非在游戏运行时进行，这个特性是 GDScript 所独有的。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var scene = preload("res://my_scene.tscn")</literal_block>
                </div>
            </container>
            <paragraph>此时的 <literal>scene</literal> 是个打包场景资源，并非节点。要创建实际的节点，你还需要调用 <reference internal="True" refuri="../../classes/class_packedscene#class-packedscene-method-instantiate"><inline classes="std std-ref">PackedScene.instantiate()</inline></reference>来创建节点，该方法会返回该打包场景的节点树的根节点。你可以将其添加为当前节点的子节点。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var instance = scene.instantiate()
add_child(instance)</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var instance = scene.Instantiate();
AddChild(instance);</literal_block>
                </div>
            </container>
            <paragraph>这两步过程的优点在于：打包的场景可以保持加载状态，且可以随时使用。例如，你可以对大量敌人或子弹快速进行实例化。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
