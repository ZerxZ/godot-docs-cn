<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/c_sharp/c_sharp_signals.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-c-sharp-signals"></target>
    <section ids="c-signals doc-c-sharp-signals" names="c#\ signals doc_c_sharp_signals">
        <title>C# signals</title>
        <paragraph>For a detailed explanation of signals in general, see the <reference internal="True" refuri="../../../getting_started/step_by_step/signals#doc-signals"><inline classes="std std-ref">Using signals</inline></reference> section in the step
            by step tutorial.</paragraph>
        <paragraph>Signals are implemented using C# events, the idiomatic way to represent
            <reference internal="True" refuri="../../../getting_started/introduction/key_concepts_overview#doc-key-concepts-signals"><inline classes="std std-ref">the observer pattern</inline></reference> in C#. This is the
            recommended way to use signals in C# and the focus of this page.</paragraph>
        <paragraph>In some cases it's necessary to use the older
            <reference internal="True" refuri="../../../classes/class_object#class-object-method-connect"><inline classes="std std-ref">Connect()</inline></reference> and
            <reference internal="True" refuri="../../../classes/class_object#class-object-method-disconnect"><inline classes="std std-ref">Disconnect()</inline></reference> APIs.
            See <reference internal="True" refid="using-connect-and-disconnect"><inline classes="std std-ref">Using Connect and Disconnect</inline></reference> for more details.</paragraph>
        <paragraph>If you encounter a <literal>System.ObjectDisposedException</literal> while handling a signal,
            you might be missing a signal disconnection. See
            <reference internal="True" refid="disconnecting-automatically-when-the-receiver-is-freed"><inline classes="std std-ref">Disconnecting automatically when the receiver is freed</inline></reference> for more details.</paragraph>
        <section ids="signals-as-c-events" names="signals\ as\ c#\ events">
            <title>Signals as C# events</title>
            <paragraph>To provide more type-safety, Godot signals are also all available through <reference name="events" refuri="https://learn.microsoft.com/en-us/dotnet/csharp/events-overview">events</reference><target ids="events" names="events" refuri="https://learn.microsoft.com/en-us/dotnet/csharp/events-overview"></target>.
                You can handle these events, as any other event, with the <literal>+=</literal> and <literal>-=</literal> operators.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Timer myTimer = GetNode&lt;Timer&gt;("Timer");
myTimer.Timeout += () =&gt; GD.Print("Timeout!");</literal_block>
            <paragraph>In addition, you can always access signal names associated with a node type through its nested
                <literal>SignalName</literal> class. This is useful when, for example, you want to await on a signal (see <reference internal="True" refuri="c_sharp_differences#doc-c-sharp-differences-await"><inline classes="std std-ref">await keyword</inline></reference>).</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">await ToSignal(GetTree(), SceneTree.SignalName.ProcessFrame);</literal_block>
        </section>
        <section ids="custom-signals-as-c-events" names="custom\ signals\ as\ c#\ events">
            <title>Custom signals as C# events</title>
            <paragraph>To declare a custom event in your C# script, use the <literal>[Signal]</literal> attribute on a public delegate type.
                Note that the name of this delegate needs to end with <literal>EventHandler</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Signal]
public delegate void MySignalEventHandler();

[Signal]
public delegate void MySignalWithArgumentEventHandler(string myString);</literal_block>
            <paragraph>Once this is done, Godot will create the appropriate events automatically behind the scenes. You
                can then use said events as you'd do for any other Godot signal. Note that events are named using
                your delegate's name minus the final <literal>EventHandler</literal> part.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    MySignal += () =&gt; GD.Print("Hello!");
    MySignalWithArgument += SayHelloTo;
}

private void SayHelloTo(string name)
{
    GD.Print($"Hello {name}!");
}</literal_block>
            <warning>
                <paragraph>If you want to connect to these signals in the editor, you will need to (re)build the project
                    to see them appear.</paragraph>
                <paragraph>You can click the <strong>Build</strong> button in the upper-right corner of the editor to do so.</paragraph>
            </warning>
        </section>
        <section ids="signal-emission" names="signal\ emission">
            <title>Signal emission</title>
            <paragraph>To emit signals, use the <literal>EmitSignal</literal> method. Note that, as for signals defined by the engine,
                your custom signal names are listed under the nested <literal>SignalName</literal> class.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void MyMethodEmittingSignals()
{
    EmitSignal(SignalName.MySignal);
    EmitSignal(SignalName.MySignalWithArgument, "World");
}</literal_block>
            <paragraph>In contrast with other C# events, you cannot use <literal>Invoke</literal> to raise events tied to Godot signals.</paragraph>
            <paragraph>Signals support arguments of any <reference internal="True" refuri="c_sharp_variant#c-sharp-variant-compatible-types"><inline classes="std std-ref">Variant-compatible type</inline></reference>.</paragraph>
            <paragraph>Consequently, any <literal>Node</literal> or <literal>RefCounted</literal> will be compatible automatically, but custom data objects will need
                to inherit from <literal>GodotObject</literal> or one of its subclasses.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class DataObject : GodotObject
{
    public string MyFirstString { get; set; }
    public string MySecondString { get; set; }
}</literal_block>
        </section>
        <section ids="bound-values" names="bound\ values">
            <title>Bound values</title>
            <paragraph>Sometimes you'll want to bind values to a signal when the connection is established, rather than
                (or in addition to) when the signal is emitted. To do so, you can use an anonymous function like in
                the following example.</paragraph>
            <paragraph>Here, the <reference internal="True" refuri="../../../classes/class_basebutton#class-basebutton-signal-pressed"><inline classes="std std-ref">Button.Pressed</inline></reference> signal does not take any argument. But we
                want to use the same <literal>ModifyValue</literal> for both the "plus" and "minus" buttons. So we bind the
                modifier value at the time we're connecting the signals.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public int Value { get; private set; } = 1;

public override void _Ready()
{
    Button plusButton = GetNode&lt;Button&gt;("PlusButton");
    plusButton.Pressed += () =&gt; ModifyValue(1);

    Button minusButton = GetNode&lt;Button&gt;("MinusButton");
    minusButton.Pressed += () =&gt; ModifyValue(-1);
}

private void ModifyValue(int modifier)
{
    Value += modifier;
}</literal_block>
        </section>
        <section ids="signal-creation-at-runtime" names="signal\ creation\ at\ runtime">
            <title>Signal creation at runtime</title>
            <paragraph>Finally, you can create custom signals directly while your game is running. Use the <literal>AddUserSignal</literal>
                method for that. Be aware that it should be executed before any use of said signals (either
                connecting to them or emitting them). Also, note that signals created this way won't be visible through the
                <literal>SignalName</literal> nested class.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    AddUserSignal("MyCustomSignal");
    EmitSignal("MyCustomSignal");
}</literal_block>
            <target refid="using-connect-and-disconnect"></target>
        </section>
        <section ids="using-connect-and-disconnect id1" names="using\ connect\ and\ disconnect using_connect_and_disconnect">
            <title>Using Connect and Disconnect</title>
            <paragraph>In general, it isn't recommended to use
                <reference internal="True" refuri="../../../classes/class_object#class-object-method-connect"><inline classes="std std-ref">Connect()</inline></reference> and
                <reference internal="True" refuri="../../../classes/class_object#class-object-method-disconnect"><inline classes="std std-ref">Disconnect()</inline></reference>. These APIs don't provide as
                much type safety as the events. However, they're necessary for
                <reference internal="True" refuri="../cross_language_scripting#connecting-to-signals-cross-language"><inline classes="std std-ref">connecting to signals defined by GDScript</inline></reference>
                and passing <reference internal="True" refuri="../../../classes/class_object#enum-object-connectflags"><inline classes="std std-ref">ConnectFlags</inline></reference>.</paragraph>
            <paragraph>In the following example, pressing the button for the first time prints
                <literal>Greetings!</literal>. <literal>OneShot</literal> disconnects the signal, so pressing the button again
                does nothing.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    Button button = GetNode&lt;Button&gt;("GreetButton");
    button.Connect(Button.SignalName.Pressed, Callable.From(OnButtonPressed), (uint)GodotObject.ConnectFlags.OneShot);
}

public void OnButtonPressed()
{
    GD.Print("Greetings!");
}</literal_block>
            <target refid="disconnecting-automatically-when-the-receiver-is-freed"></target>
        </section>
        <section ids="disconnecting-automatically-when-the-receiver-is-freed id2" names="disconnecting\ automatically\ when\ the\ receiver\ is\ freed disconnecting_automatically_when_the_receiver_is_freed">
            <title>Disconnecting automatically when the receiver is freed</title>
            <paragraph>Normally, when any <literal>GodotObject</literal> is freed (such as any <literal>Node</literal>), Godot
                automatically disconnects all connections associated with that object. This
                happens for both signal emitters and signal receivers.</paragraph>
            <paragraph>For example, a node with this code will print "Hello!" when the button is
                pressed, then free itself. Freeing the node disconnects the signal, so pressing
                the button again doesn't do anything:</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    Button myButton = GetNode&lt;Button&gt;("../MyButton");
    myButton.Pressed += SayHello;
}

private void SayHello()
{
    GD.Print("Hello!");
    Free();
}</literal_block>
            <paragraph>When a signal receiver is freed while the signal emitter is still alive, in some
                cases automatic disconnection won't happen:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The signal is connected to a lambda expression that captures a variable.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The signal is a custom signal.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The following sections explain these cases in more detail and include
                suggestions for how to disconnect manually.</paragraph>
            <note>
                <paragraph>Automatic disconnection is totally reliable if a signal emitter is freed
                    before any of its receivers are freed. With a project style that prefers
                    this pattern, the above limits may not be a concern.</paragraph>
            </note>
            <section ids="no-automatic-disconnection-a-lambda-expression-that-captures-a-variable" names="no\ automatic\ disconnection:\ a\ lambda\ expression\ that\ captures\ a\ variable">
                <title>No automatic disconnection: a lambda expression that captures a variable</title>
                <paragraph>If you connect to a lambda expression that captures variables, Godot can't tell
                    that the lambda is associated with the instance that created it. This causes
                    this example to have potentially unexpected behavior:</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Timer myTimer = GetNode&lt;Timer&gt;("../Timer");
int x = 0;
myTimer.Timeout += () =&gt;
{
    x++; // This lambda expression captures x.
    GD.Print($"Tick {x} my name is {Name}");
    if (x == 3)
    {
        GD.Print("Time's up!");
        Free();
    }
};</literal_block>
                <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">Tick 1, my name is ExampleNode
Tick 2, my name is ExampleNode
Tick 3, my name is ExampleNode
Time's up!
[...] System.ObjectDisposedException: Cannot access a disposed object.</literal_block>
                <paragraph>On tick 4, the lambda expression tries to access the <literal>Name</literal> property of the
                    node, but the node has already been freed. This causes the exception.</paragraph>
                <paragraph>To disconnect, keep a reference to the delegate created by the lambda expression
                    and pass that to <literal>-=</literal>. For example, this node connects and disconnects using
                    the <literal>_EnterTree</literal> and <literal>_ExitTree</literal> lifecycle methods:</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Timer MyTimer { get; set; }

private Action _tick;

public override void _EnterTree()
{
    int x = 0;
    _tick = () =&gt;
    {
        x++;
        GD.Print($"Tick {x} my name is {Name}");
        if (x == 3)
        {
            GD.Print("Time's up!");
            Free();
        }
    };
    MyTimer.Timeout += _tick;
}

public override void _ExitTree()
{
    MyTimer.Timeout -= _tick;
}</literal_block>
                <paragraph>In this example, <literal>Free</literal> causes the node to leave the tree, which calls
                    <literal>_ExitTree</literal>. <literal>_ExitTree</literal> disconnects the signal, so <literal>_tick</literal> is never
                    called again.</paragraph>
                <paragraph>The lifecycle methods to use depend on what the node does. Another option is to
                    connect to signals in <literal>_Ready</literal> and disconnect in <literal>Dispose</literal>.</paragraph>
                <note>
                    <paragraph>Godot uses <reference name="Delegate.Target" refuri="https://learn.microsoft.com/en-us/dotnet/api/system.delegate.target">Delegate.Target</reference><target ids="delegate-target" names="delegate.target" refuri="https://learn.microsoft.com/en-us/dotnet/api/system.delegate.target"></target>
                        to determine what instance a delegate is associated with. When a lambda
                        expression doesn't capture a variable, the generated delegate's <literal>Target</literal>
                        is the instance that created the delegate. When a variable is captured, the
                        <literal>Target</literal> instead points at a generated type that stores the captured
                        variable. This is what breaks the association. If you want to see if a
                        delegate will be automatically cleaned up, try checking its <literal>Target</literal>.</paragraph>
                    <paragraph><literal>Callable.From</literal> doesn't affect the <literal>Delegate.Target</literal>, so connecting a
                        lambda that captures variables using <literal>Connect</literal> doesn't work any better
                        than <literal>+=</literal>.</paragraph>
                </note>
            </section>
            <section ids="no-automatic-disconnection-a-custom-signal" names="no\ automatic\ disconnection:\ a\ custom\ signal">
                <title>No automatic disconnection: a custom signal</title>
                <paragraph>Connecting to a custom signal using <literal>+=</literal> doesn't disconnect automatically when
                    the receiving node is freed.</paragraph>
                <paragraph>To disconnect, use <literal>-=</literal> at an appropriate time. For example:</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public MyClass Target { get; set; }

public override void _EnterTree()
{
    Target.MySignal += OnMySignal;
}

public override void _ExitTree()
{
    Target.MySignal -= OnMySignal;
}</literal_block>
                <paragraph>Another solution is to use <literal>Connect</literal>, which does disconnect automatically with
                    custom signals:</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public MyClass Target { get; set; }

public override void _EnterTree()
{
    Target.Connect(MyClass.SignalName.MySignal, Callable.From(OnMySignal));
}</literal_block>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
