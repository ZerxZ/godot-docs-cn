<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/c_sharp/c_sharp_signals.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-c-sharp-signals"></target>
    <section ids="c-signals doc-c-sharp-signals" names="c#\ signals c#\ 信号 doc_c_sharp_signals">
        <title>C# 信号</title>
        <paragraph>有关信号的详细解释，请参阅逐步教程中的 <reference internal="True" refuri="../../../getting_started/step_by_step/signals#doc-signals"><inline classes="std std-ref">使用信号</inline></reference> 部分。</paragraph>
        <paragraph>虽然仍然可以通过 <literal>Connect</literal>/<literal>Disconnect</literal> API 使用信号，但 C# 为我们提供了一种更符合习惯的方式来实现 <reference internal="True" refuri="../../../getting_started/introduction/key_concepts_overview#doc-key-concepts-signals"><inline classes="std std-ref">观察者模式</inline></reference> 。</paragraph>
        <section ids="signals-as-c-events" names="signals\ as\ c#\ events 信号作为\ c#\ 事件">
            <title>信号作为 C# 事件</title>
            <paragraph>为了提供更多的类型安全，Godot 信号也都可以通过 <reference name="事件" refuri="https://learn.microsoft.com/zh-cn/dotnet/csharp/events-overview">事件</reference><target ids="id1" names="事件" refuri="https://learn.microsoft.com/zh-cn/dotnet/csharp/events-overview"></target> 获取。你可以用 <literal>+=</literal> 和 <literal>-=</literal> 运算符来处理这些事件，就像其他任何事件一样。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Timer myTimer = GetNode&lt;Timer&gt;("Timer");
myTimer.Timeout += () =&gt; GD.Print("Timeout!");</literal_block>
            <paragraph>此外，你可以通过节点类型的嵌套 <literal>SignalName</literal> 类来访问与之相关的信号名称。这在你想要等待一个信号时很有用，例如（参见 <reference internal="True" refuri="c_sharp_differences#doc-c-sharp-differences-await"><inline classes="std std-ref">await 关键字</inline></reference> ）。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">await ToSignal(GetTree(), SceneTree.SignalName.ProcessFrame);</literal_block>
            <warning>
                <paragraph>所有作为事件连接的引擎信号，在节点释放时会自动断开连接，但自定义信号不会。这意味着：你需要手动断开（使用 <literal>-=</literal> ）所有你连接为 C# 事件的自定义信号（使用 <literal>+=</literal> ）。</paragraph>
            </warning>
        </section>
        <section ids="custom-signals-as-c-events" names="custom\ signals\ as\ c#\ events 自定义信号作为\ c#\ 事件">
            <title>自定义信号作为 C# 事件</title>
            <paragraph>要在你的 C# 脚本中声明一个自定义事件，你需要在一个公共委托类型上使用 <literal>[Signal]</literal> 特性。注意，这个委托的名称必须以 <literal>EventHandler</literal> 结尾。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Signal]
public delegate void MySignalEventHandler();

[Signal]
public delegate void MySignalWithArgumentEventHandler(string myString);</literal_block>
            <paragraph>一旦完成这一步，Godot 就会在后台自动创建相应的事件。你可以像使用任何其他 Godot 信号一样使用这些事件。注意，事件的名称是用你的委托的名称减去最后的 <literal>EventHandler</literal> 部分来命名的。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    MySignal += () =&gt; GD.Print("Hello!");
    MySignalWithArgument += SayHelloTo;
}

private void SayHelloTo(string name)
{
    GD.Print($"Hello {name}!");
}</literal_block>
            <warning>
                <paragraph>如果你想在编辑器中连接到这些信号，你需要（重新）构建项目以查看它们的出现。</paragraph>
                <paragraph>你可以使用右上角的按钮来。</paragraph>
            </warning>
        </section>
        <section ids="signal-emission" names="signal\ emission 信号发射">
            <title>信号发射</title>
            <paragraph>要发射信号，使用 <literal>EmitSignal</literal> 方法。请注意，就像引擎定义的信号一样，你的自定义信号名称列在嵌套的 <literal>SignalName</literal> 类下。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void MyMethodEmittingSignals()
{
    EmitSignal(SignalName.MySignal);
    EmitSignal(SignalName.MySignalWithArgument, "World");
}</literal_block>
            <paragraph>与其他 C# 事件不同，你不能使用 <literal>Invoke</literal> 来触发与 Godot 信号绑定的事件。</paragraph>
            <paragraph>信号支持任何 <reference internal="True" refuri="c_sharp_variant#doc-c-sharp-variant"><inline classes="std std-ref">Variant 兼容</inline></reference> 类型的参数。</paragraph>
            <paragraph>因此，任何 <literal>Node</literal> 或 <literal>RefCounted</literal> 都会自动兼容，但自定义数据对象需要继承自 <literal>GodotObject</literal> 或其子类之一。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class DataObject : GodotObject
{
    public string MyFirstString { get; set; }
    public string MySecondString { get; set; }
}</literal_block>
        </section>
        <section ids="bound-values" names="bound\ values 绑定值">
            <title>绑定值</title>
            <paragraph>有时你会想在连接建立时将值绑定到信号，而不是（或者除了）在信号发出时。要做到这一点，你可以使用一个匿名函数，如下面的例子所示。</paragraph>
            <paragraph>在这里， <reference internal="True" refuri="../../../classes/class_basebutton#class-basebutton-signal-pressed"><inline classes="std std-ref">Button.Pressed</inline></reference> 信号不需要任何参数。但我们想要对“加”和“减”按钮使用相同的 <literal>ModifyValue</literal> 。所以我们在连接信号的时候绑定了修饰值。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public int Value { get; private set; } = 1;

public override void _Ready()
{
    Button plusButton = GetNode&lt;Button&gt;("PlusButton");
    plusButton.Pressed += () =&gt; ModifyValue(1);

    Button minusButton = GetNode&lt;Button&gt;("MinusButton");
    minusButton.Pressed += () =&gt; ModifyValue(-1);
}

private void ModifyValue(int modifier)
{
    Value += modifier;
}</literal_block>
        </section>
        <section ids="signal-creation-at-runtime" names="signal\ creation\ at\ runtime 运行时创建信号">
            <title>运行时创建信号</title>
            <paragraph>最后，你可以在游戏运行时直接创建自定义信号。使用 <literal>AddUserSignal</literal> 方法来实现这一功能。注意，这个方法应该在使用这些信号（无论是连接还是发射）之前执行。另外，注意这种方式创建的信号不会通过 <literal>SignalName</literal> 嵌套类显示。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    AddUserSignal("MyCustomSignal");
    EmitSignal("MyCustomSignal");
}</literal_block>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
