<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/c_sharp/c_sharp_exports.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-c-sharp-exports"></target>
    <section ids="c-exported-properties doc-c-sharp-exports" names="c#\ exported\ properties doc_c_sharp_exports">
        <title>C# exported properties</title>
        <paragraph>In Godot, class members can be exported. This means their value gets saved along
            with the resource (such as the <reference internal="True" refuri="../../../classes/class_packedscene#class-packedscene"><inline classes="std std-ref">scene</inline></reference>) they're
            attached to. They will also be available for editing in the property editor.
            Exporting is done by using the <literal>[Export]</literal> attribute.</paragraph>
        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class ExportExample : Node3D
{
    [Export]
    public int Number { get; set; } = 5;
}</literal_block>
        <paragraph>In that example the value <literal>5</literal> will be saved, and after building the current project
            it will be visible in the property editor.</paragraph>
        <paragraph>One of the fundamental benefits of exporting member variables is to have
            them visible and editable in the editor. This way, artists and game designers
            can modify values that later influence how the program runs. For this, a
            special export syntax is provided.</paragraph>
        <paragraph>Exporting can only be done with <reference internal="True" refuri="c_sharp_variant#c-sharp-variant-compatible-types"><inline classes="std std-ref">Variant-compatible types</inline></reference>.</paragraph>
        <note>
            <paragraph>Exporting properties can also be done in GDScript, for information on that
                see <reference internal="True" refuri="../gdscript/gdscript_exports#doc-gdscript-exports"><inline classes="std std-ref">GDScript exported properties</inline></reference>.</paragraph>
        </note>
        <section ids="basic-use" names="basic\ use">
            <title>Basic use</title>
            <paragraph>Exporting works with fields and properties. They can have any access modifier.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
private int _number;

[Export]
public int Number { get; set; }</literal_block>
            <paragraph>Exported members can specify a default value; otherwise, the <reference name="default value of the type" refuri="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values">default value of the type</reference><target ids="default-value-of-the-type" names="default\ value\ of\ the\ type" refuri="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values"></target> is used instead.</paragraph>
            <paragraph>An <literal>int</literal> like <literal>Number</literal> defaults to <literal>0</literal>. <literal>Text</literal> defaults to null because
                <literal>string</literal> is a reference type.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public int Number { get; set; }

[Export]
public string Text { get; set; }</literal_block>
            <paragraph>Default values can be specified for fields and properties.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
private string _greeting = "Hello World";

[Export]
public string Greeting { get; set; } = "Hello World";</literal_block>
            <paragraph>Properties with a backing field use the default value of the backing field.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private int _number = 2;

[Export]
public int NumberWithBackingField
{
    get =&gt; _number;
    set =&gt; _number = value;
}</literal_block>
            <note>
                <paragraph>A property's <literal>get</literal> is not actually executed to determine the default
                    value. Instead, Godot analyzes the C# source code. This works fine for most
                    cases, such as the examples on this page. However, some properties are too
                    complex for the analyzer to understand.</paragraph>
                <paragraph>For example, the following property attempts to use math to display the
                    default value as <literal>5</literal> in the property editor, but it doesn't work:</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public int NumberWithBackingField
{
    get =&gt; _number + 3;
    set =&gt; _number = value - 3;
}

private int _number = 2;</literal_block>
                <paragraph>The analyzer doesn't understand this code and falls back to the default
                    value for <literal>int</literal>, <literal>0</literal>. However, when running the scene or inspecting a
                    node with an attached tool script, <literal>_number</literal> will be <literal>2</literal>, and
                    <literal>NumberWithBackingField</literal> will return <literal>5</literal>. This difference may cause
                    confusing behavior. To avoid this, don't use complex properties. Alternatively,
                    if the default value can be explicitly specified, it can be overridden with the
                    <reference internal="True" refuri="../../../classes/class_object#class-object-private-method-property-can-revert"><inline classes="std std-ref">_PropertyCanRevert()</inline></reference> and
                    <reference internal="True" refuri="../../../classes/class_object#class-object-private-method-property-get-revert"><inline classes="std std-ref">_PropertyGetRevert()</inline></reference> methods.</paragraph>
            </note>
            <paragraph>Any type of <literal>Resource</literal> or <literal>Node</literal> can be exported. The property editor shows
                a user-friendly assignment dialog for these types. This can be used instead of
                <literal>GD.Load</literal> and <literal>GetNode</literal>. See <reference internal="True" refid="doc-c-sharp-exports-nodes"><inline classes="std std-ref">Nodes and Resources</inline></reference>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public PackedScene PackedScene { get; set; }

[Export]
public RigidBody2D RigidBody2D { get; set; }</literal_block>
        </section>
        <section ids="grouping-exports" names="grouping\ exports">
            <title>Grouping exports</title>
            <paragraph>It is possible to group your exported properties inside the Inspector with the <literal>[ExportGroup]</literal>
                attribute. Every exported property after this attribute will be added to the group. Start a new
                group or use <literal>[ExportGroup("")]</literal> to break out.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[ExportGroup("My Properties")]
[Export]
public int Number { get; set; } = 3;</literal_block>
            <paragraph>The second argument of the attribute can be used to only group properties with the specified prefix.</paragraph>
            <paragraph>Groups cannot be nested, use <literal>[ExportSubgroup]</literal> to create subgroups within a group.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[ExportSubgroup("Extra Properties")]
[Export]
public string Text { get; set; } = "";
[Export]
public bool Flag { get; set; } = false;</literal_block>
            <paragraph>You can also change the name of your main category, or create additional categories in the property
                list with the <literal>[ExportCategory]</literal> attribute.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[ExportCategory("Main Category")]
[Export]
public int Number { get; set; } = 3;
[Export]
public string Text { get; set; } = "";

[ExportCategory("Extra Category")]
[Export]
public bool Flag { get; set; } = false;</literal_block>
            <note>
                <paragraph>The list of properties is organized based on the class inheritance, and new categories break
                    that expectation. Use them carefully, especially when creating projects for public use.</paragraph>
            </note>
        </section>
        <section ids="strings-as-paths" names="strings\ as\ paths">
            <title>Strings as paths</title>
            <paragraph>Property hints can be used to export strings as paths</paragraph>
            <paragraph>String as a path to a file.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.File)]
public string GameFile { get; set; }</literal_block>
            <paragraph>String as a path to a directory.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Dir)]
public string GameDirectory { get; set; }</literal_block>
            <paragraph>String as a path to a file, custom filter provided as hint.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.File, "*.txt,")]
public string GameFile { get; set; }</literal_block>
            <paragraph>Using paths in the global filesystem is also possible,
                but only in scripts in tool mode.</paragraph>
            <paragraph>String as a path to a PNG file in the global filesystem.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.GlobalFile, "*.png")]
public string ToolImage { get; set; }</literal_block>
            <paragraph>String as a path to a directory in the global filesystem.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.GlobalDir)]
public string ToolDir { get; set; }</literal_block>
            <paragraph>The multiline annotation tells the editor to show a large input
                field for editing over multiple lines.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.MultilineText)]
public string Text { get; set; }</literal_block>
        </section>
        <section ids="limiting-editor-input-ranges" names="limiting\ editor\ input\ ranges">
            <title>Limiting editor input ranges</title>
            <paragraph>Using the range property hint allows you to limit what can be
                input as a value using the editor.</paragraph>
            <paragraph>Allow integer values from 0 to 20.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Range, "0,20,")]
public int Number { get; set; }</literal_block>
            <paragraph>Allow integer values from -10 to 20.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Range, "-10,20,")]
public int Number { get; set; }</literal_block>
            <paragraph>Allow floats from -10 to 20 and snap the value to multiples of 0.2.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Range, "-10,20,0.2")]
public float Number { get; set; }</literal_block>
            <paragraph>If you add the hints "or_greater" and/or "or_less" you can go above
                or below the limits when adjusting the value by typing it instead of using
                the slider.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Range, "0,100,1,or_greater,or_less")]
public int Number { get; set; }</literal_block>
        </section>
        <section ids="floats-with-easing-hint" names="floats\ with\ easing\ hint">
            <title>Floats with easing hint</title>
            <paragraph>Display a visual representation of the <reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-ease"><inline classes="std std-ref">ease</inline></reference>
                function when editing.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.ExpEasing)]
public float TransitionSpeed { get; set; }</literal_block>
        </section>
        <section ids="export-with-suffix-hint" names="export\ with\ suffix\ hint">
            <title>Export with suffix hint</title>
            <paragraph>Display a unit hint suffix for exported variables. Works with numeric types,
                such as floats or vectors:</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.None, "suffix:m/s\u00b2")]
public float Gravity { get; set; } = 9.8f;
[Export(PropertyHint.None, "suffix:m/s")]
public Vector3 Velocity { get; set; }</literal_block>
            <paragraph>In the above example, <literal>\u00b2</literal> is used to write the "squared" character
                (<literal>Â²</literal>).</paragraph>
        </section>
        <section ids="colors" names="colors">
            <title>Colors</title>
            <paragraph>Regular color given as red-green-blue-alpha value.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Color Color { get; set; }</literal_block>
            <paragraph>Color given as red-green-blue value (alpha will always be 1).</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.ColorNoAlpha)]
public Color Color { get; set; }</literal_block>
            <target refid="doc-c-sharp-exports-nodes"></target>
        </section>
        <section ids="nodes doc-c-sharp-exports-nodes" names="nodes doc_c_sharp_exports_nodes">
            <title>Nodes</title>
            <paragraph>Nodes can also be directly exported without having to use NodePaths.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Node Node { get; set; }</literal_block>
            <paragraph>A specific type of node can also be directly exported. The list of nodes shown
                after pressing "Assign" in the inspector is filtered to the specified type, and
                only a correct node can be assigned.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Sprite2D Sprite2D { get; set; }</literal_block>
            <paragraph>Custom node classes can also be exported directly. The filtering behavior
                depends on whether the custom class is a
                <reference internal="True" refuri="c_sharp_global_classes#doc-c-sharp-global-classes"><inline classes="std std-ref">global class</inline></reference>.</paragraph>
            <paragraph>Exporting NodePaths like in Godot 3.x is still possible, in case you need it:</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public NodePath NodePath { get; set; }

public override void _Ready()
{
    var node = GetNode(NodePath);
}</literal_block>
        </section>
        <section ids="resources" names="resources">
            <title>Resources</title>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Resource Resource { get; set; }</literal_block>
            <paragraph>In the Inspector, you can then drag and drop a resource file
                from the FileSystem dock into the variable slot.</paragraph>
            <paragraph>Opening the inspector dropdown may result in an
                extremely long list of possible classes to create, however.
                Therefore, if you specify a type derived from Resource such as:</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public AnimationNode AnimationNode { get; set; }</literal_block>
            <paragraph>The drop-down menu will be limited to AnimationNode and all
                its derived classes. Custom resource classes can also be used,
                see <reference internal="True" refuri="c_sharp_global_classes#doc-c-sharp-global-classes"><inline classes="std std-ref">C# global classes</inline></reference>.</paragraph>
            <paragraph>It must be noted that even if the script is not being run while in the
                editor, the exported properties are still editable. This can be used
                in conjunction with a <reference internal="True" refuri="../gdscript/gdscript_basics#doc-gdscript-tool-mode"><inline classes="std std-ref">script in "tool" mode</inline></reference>.</paragraph>
        </section>
        <section ids="exporting-bit-flags" names="exporting\ bit\ flags">
            <title>Exporting bit flags</title>
            <paragraph>Members whose type is an enum with the <literal>[Flags]</literal> attribute can be exported and
                their values are limited to the members of the enum type.
                The editor will create a widget in the Inspector, allowing to select none, one,
                or multiple of the enum members. The value will be stored as an integer.</paragraph>
            <paragraph>A flags enum uses powers of 2 for the values of the enum members. Members that
                combine multiple flags using logical OR (<literal>|</literal>) are also possible.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Flags]
public enum SpellElements
{
    Fire = 1 &lt;&lt; 1,
    Water = 1 &lt;&lt; 2,
    Earth = 1 &lt;&lt; 3,
    Wind = 1 &lt;&lt; 4,

    FireAndWater = Fire | Water,
}

[Export]
public SpellElements MySpellElements { get; set; }</literal_block>
            <paragraph>Integers used as bit flags can store multiple <literal>true</literal>/<literal>false</literal> (boolean)
                values in one property. By using the <literal>Flags</literal> property hint, any of the given
                flags can be set from the editor.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Flags, "Fire,Water,Earth,Wind")]
public int SpellElements { get; set; } = 0;</literal_block>
            <paragraph>You must provide a string description for each flag. In this example, <literal>Fire</literal>
                has value 1, <literal>Water</literal> has value 2, <literal>Earth</literal> has value 4 and <literal>Wind</literal>
                corresponds to value 8. Usually, constants should be defined accordingly (e.g.
                <literal>private const int ElementWind = 8</literal> and so on).</paragraph>
            <paragraph>You can add explicit values using a colon:</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Flags, "Self:4,Allies:8,Foes:16")]
public int SpellTargets { get; set; } = 0;</literal_block>
            <paragraph>Only power of 2 values are valid as bit flags options. The lowest allowed value
                is 1, as 0 means that nothing is selected. You can also add options that are a
                combination of other flags:</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Flags, "Self:4,Allies:8,Self and Allies:12,Foes:16")]
public int SpellTargets { get; set; } = 0;</literal_block>
            <paragraph>Export annotations are also provided for the physics and render layers defined in the project settings.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Layers2DPhysics)]
public uint Layers2DPhysics { get; set; }
[Export(PropertyHint.Layers2DRender)]
public uint Layers2DRender { get; set; }
[Export(PropertyHint.Layers3DPhysics)]
public uint Layers3DPhysics { get; set; }
[Export(PropertyHint.Layers3DRender)]
public uint Layers3DRender { get; set; }</literal_block>
            <paragraph>Using bit flags requires some understanding of bitwise operations.
                If in doubt, use boolean variables instead.</paragraph>
        </section>
        <section ids="exporting-enums" names="exporting\ enums">
            <title>Exporting enums</title>
            <paragraph>Members whose type is an enum can be exported and their values are limited to the members
                of the enum type. The editor will create a widget in the Inspector, enumerating the
                following as "Thing 1", "Thing 2", "Another Thing". The value will be stored as an integer.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public enum MyEnum
{
    Thing1,
    Thing2,
    AnotherThing = -1,
}

[Export]
public MyEnum MyEnumCurrent { get; set; }</literal_block>
            <paragraph>Integer and string members can also be limited to a specific list of values using the
                <literal>[Export]</literal> annotation with the <literal>PropertyHint.Enum</literal> hint.
                The editor will create a widget in the Inspector, enumerating the following as Warrior,
                Magician, Thief. The value will be stored as an integer, corresponding to the index
                of the selected option (i.e. <literal>0</literal>, <literal>1</literal>, or <literal>2</literal>).</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Enum, "Warrior,Magician,Thief")]
public int CharacterClass { get; set; }</literal_block>
            <paragraph>You can add explicit values using a colon:</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Enum, "Slow:30,Average:60,Very Fast:200")]
public int CharacterSpeed { get; set; }</literal_block>
            <paragraph>If the type is <literal>string</literal>, the value will be stored as a string.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Enum, "Rebecca,Mary,Leah")]
public string CharacterName { get; set; }</literal_block>
            <paragraph>If you want to set an initial value, you must specify it explicitly:</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Enum, "Rebecca,Mary,Leah")]
public string CharacterName { get; set; } = "Rebecca";</literal_block>
        </section>
        <section ids="exporting-inspector-buttons-with-exporttoolbutton" names="exporting\ inspector\ buttons\ with\ [exporttoolbutton]">
            <title>Exporting inspector buttons with <literal>[ExportToolButton]</literal></title>
            <paragraph>If you want to create a clickable button in the inspector, you can use the
                <literal>[ExportToolButton]</literal> attribute.  This exports a Callable property or field as
                a clickable button. Since this runs in the editor, usage of the <reference internal="True" refuri="../../plugins/running_code_in_the_editor#doc-running-code-in-the-editor"><inline classes="std std-ref">[Tool]</inline></reference> attribute is required. When the button is
                pressed, the callable is called:</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Tool]
public partial class MyNode : Node
{
    [ExportToolButton("Click me!")]
    public Callable ClickMeButton =&gt; Callable.From(ClickMe);

    public void ClickMe()
    {
        GD.Print("Hello world!");
    }
}</literal_block>
            <paragraph>You can also set an icon for the button with a second argument. If specified, an
                icon will be fetched via <reference internal="True" refuri="../../../classes/class_control#class-control-method-get-theme-icon"><inline classes="std std-ref">GetThemeIcon()</inline></reference>,
                from the <literal>"EditorIcons"</literal> theme type.</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[ExportToolButton("Click me!", Icon = "CharacterBody2D")]
public Callable ClickMeButton =&gt; Callable.From(ClickMe);</literal_block>
        </section>
        <section ids="exporting-collections" names="exporting\ collections">
            <title>Exporting collections</title>
            <paragraph>As explained in the <reference internal="True" refuri="c_sharp_variant#doc-c-sharp-variant"><inline classes="std std-ref">C# Variant</inline></reference> documentation, only
                certain C# arrays and the collection types defined in the <literal>Godot.Collections</literal>
                namespace are Variant-compatible, therefore, only those types can be exported.</paragraph>
            <section ids="exporting-godot-arrays" names="exporting\ godot\ arrays">
                <title>Exporting Godot arrays</title>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Godot.Collections.Array Array { get; set; }</literal_block>
                <paragraph>Using the generic <literal>Godot.Collections.Array&lt;T&gt;</literal> allows specifying the type of the
                    array elements, which will be used as a hint for the editor. The Inspector will
                    restrict the elements to the specified type.</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Godot.Collections.Array&lt;string&gt; Array { get; set; }</literal_block>
                <paragraph>The default value of Godot arrays is null. A different default can be specified:</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Godot.Collections.Array&lt;string&gt; CharacterNames { get; set; } =
[
    "Rebecca",
    "Mary",
    "Leah",
];</literal_block>
                <paragraph>Arrays with specified types which inherit from resource can be set by
                    drag-and-dropping multiple files from the FileSystem dock.</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Godot.Collections.Array&lt;Texture&gt; Textures { get; set; }

[Export]
public Godot.Collections.Array&lt;PackedScene&gt; Scenes { get; set; }</literal_block>
            </section>
            <section ids="exporting-godot-dictionaries" names="exporting\ godot\ dictionaries">
                <title>Exporting Godot dictionaries</title>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Godot.Collections.Dictionary Dictionary { get; set; }</literal_block>
                <paragraph>Using the generic <literal>Godot.Collections.Dictionary&lt;TKey, TValue&gt;</literal> allows specifying
                    the types of the key and value elements of the dictionary.</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Godot.Collections.Dictionary&lt;string, int&gt; Dictionary { get; set; }</literal_block>
                <paragraph>The default value of Godot dictionaries is null. A different default can be specified:</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Godot.Collections.Dictionary&lt;string, int&gt; CharacterLives { get; set; } = new Godot.Collections.Dictionary&lt;string, int&gt;
{
    ["Rebecca"] = 10,
    ["Mary"] = 42,
    ["Leah"] = 0,
};</literal_block>
            </section>
            <section ids="exporting-c-arrays" names="exporting\ c#\ arrays">
                <title>Exporting C# arrays</title>
                <paragraph>C# arrays can exported as long as the element type is a <reference internal="True" refuri="c_sharp_variant#c-sharp-variant-compatible-types"><inline classes="std std-ref">Variant-compatible type</inline></reference>.</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Vector3[] Vectors { get; set; }

[Export]
public NodePath[] NodePaths { get; set; }</literal_block>
                <paragraph>The default value of C# arrays is null. A different default can be specified:</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Vector3[] Vectors { get; set; } =
[
    new Vector3(1, 2, 3),
    new Vector3(3, 2, 1),
];</literal_block>
            </section>
        </section>
        <section ids="setting-exported-variables-from-a-tool-script" names="setting\ exported\ variables\ from\ a\ tool\ script">
            <title>Setting exported variables from a tool script</title>
            <paragraph>When changing an exported variable's value from a script in
                <reference internal="True" refuri="../gdscript/gdscript_basics#doc-gdscript-tool-mode"><inline classes="std std-ref">Tool mode</inline></reference>, the value in the inspector won't be updated
                automatically. To update it, call
                <reference internal="True" refuri="../../../classes/class_object#class-object-method-notify-property-list-changed"><inline classes="std std-ref">NotifyPropertyListChanged()</inline></reference>
                after setting the exported variable's value.</paragraph>
        </section>
        <section ids="advanced-exports" names="advanced\ exports">
            <title>Advanced exports</title>
            <paragraph>Not every type of export can be provided on the level of the language itself to
                avoid unnecessary design complexity. The following describes some more or less
                common exporting features which can be implemented with a low-level API.</paragraph>
            <paragraph>Before reading further, you should get familiar with the way properties are
                handled and how they can be customized with
                <reference internal="True" refuri="../../../classes/class_object#class-object-private-method-set"><inline classes="std std-ref">_Set()</inline></reference>,
                <reference internal="True" refuri="../../../classes/class_object#class-object-private-method-get"><inline classes="std std-ref">_Get()</inline></reference>, and
                <reference internal="True" refuri="../../../classes/class_object#class-object-private-method-get-property-list"><inline classes="std std-ref">_GetPropertyList()</inline></reference> methods as
                described in <reference internal="True" refuri="../../best_practices/godot_interfaces#doc-accessing-data-or-logic-from-object"><inline classes="std std-ref">Accessing data or logic from an object</inline></reference>.</paragraph>
            <seealso>
                <paragraph>For binding properties using the above methods in C++, see
                    <reference internal="True" refuri="../../../engine_details/architecture/object_class#doc-binding-properties-using-set-get-property-list"><inline classes="std std-ref">Binding properties using _set/_get/_get_property_list</inline></reference>.</paragraph>
            </seealso>
            <warning>
                <paragraph>The script must operate in the <literal>tool</literal> mode so the above methods
                    can work from within the editor.</paragraph>
            </warning>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
