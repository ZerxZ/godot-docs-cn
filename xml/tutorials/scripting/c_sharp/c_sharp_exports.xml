<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/c_sharp/c_sharp_exports.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-c-sharp-exports"></target>
    <section ids="c-exported-properties doc-c-sharp-exports" names="c#\ exported\ properties c#\ 导出属性 doc_c_sharp_exports">
        <title>C# 导出属性</title>
        <paragraph>在 Godot 中可以导出类成员。这意味着它们的值会与它们所附加的资源（例如<reference internal="True" refuri="../../../classes/class_packedscene#class-packedscene"><inline classes="std std-ref">场景</inline></reference>）一起保存。它们也可以在属性编辑器中进行编辑。导出使用特性 <literal>[Export]</literal> 来完成。</paragraph>
        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class ExportExample : Node3D
{
    [Export]
    private int Number = 5;
}</literal_block>
        <paragraph>在这个例子中，数值 <literal>5</literal> 将被保存，在构建当前项目后，它将在属性编辑器中可见。</paragraph>
        <paragraph>导出成员变量的基本好处之一，便是让这些变量在编辑器中可见可改，这样一来，美术师和游戏设计师就可以修改这些会影响程序运行方式的值。为此，Godot 提供了一种特殊的导出语法。</paragraph>
        <paragraph>导出只适用于<reference internal="True" refuri="c_sharp_variant#doc-c-sharp-variant"><inline classes="std std-ref">与 Variant 兼容</inline></reference>的类型。</paragraph>
        <note>
            <paragraph>GDScript 中也能够导出属性，相关信息见 <reference internal="True" refuri="../gdscript/gdscript_exports#doc-gdscript-exports"><inline classes="std std-ref">GDScript 导出属性</inline></reference>。</paragraph>
        </note>
        <section ids="basic-use" names="basic\ use 基本用法">
            <title>基本用法</title>
            <paragraph>导出包、补丁、Mod。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
private int _number;

[Export]
public int Number { get; set; }</literal_block>
            <paragraph>导出的成员可以指定默认值；否则，将使用类型的 <reference name="默认值" refuri="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/default-values">默认值</reference><target ids="id1" names="默认值" refuri="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/default-values"></target> 。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
private int _number; // Defaults to '0'

[Export]
private string _text; // Defaults to 'null' because it's a reference type

[Export]
private string _greeting = "Hello World"; // Exported field specifies a default value

[Export]
public string Greeting { get; set; } = "Hello World"; // Exported property specifies a default value

// This property uses `_greeting` as its backing field, so the default value
// will be the default value of the `_greeting` field.
[Export]
public string GreetingWithBackingField
{
    get =&gt; _greeting;
    set =&gt; _greeting = value;
}</literal_block>
            <paragraph>可以导出资源和节点。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Resource Resource { get; set; }

[Export]
public Node Node { get; set; }</literal_block>
        </section>
        <section ids="grouping-exports" names="grouping\ exports 导出分组">
            <title>导出分组</title>
            <paragraph>可以使用 <literal>[ExportGroup]</literal> 特性将导出的属性分组显示在检视器中。在此特性之后的每个导出的属性都将添加到该组中。开始一个新组，或使用 <literal>[ExportGroup("")]</literal> 进行分组结束。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[ExportGroup("My Properties")]
[Export]
public int Number { get; set; } = 3;</literal_block>
            <paragraph>该特性的第二个参数可用于仅将具有指定前缀的属性分组。</paragraph>
            <paragraph>分组可以嵌套，请使用 <literal>[ExportSubgroup]</literal> 在分组中创建子分组。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[ExportSubgroup("Extra Properties")]
[Export]
public string Text { get; set; } = "";
[Export]
public bool Flag { get; set; } = false;</literal_block>
            <paragraph>你也可以修改你的主分类的名称，或者在属性列表中使用 <literal>[ExportCategory]</literal> 特性创建额外的分类。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[ExportCategory("Main Category")]
[Export]
public int Number { get; set; } = 3;
[Export]
public string Text { get; set; } = "";

[ExportCategory("Extra Category")]
[Export]
private bool Flag { get; set; } = false;</literal_block>
            <note>
                <paragraph>属性列表是根据类继承来组织的，而新的分类会打破这种预期。使用它们时要小心，尤其是在创建公共项目时。</paragraph>
            </note>
        </section>
        <section ids="strings-as-paths" names="strings\ as\ paths 字符串用作文件路径">
            <title>字符串用作文件路径</title>
            <paragraph>属性提示可以用来导出字符串作为路径</paragraph>
            <paragraph>字符串可以用作文件路径。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.File)]
public string GameFile { get; set; }</literal_block>
            <paragraph>字符串也可以用作文件目录路径。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Dir)]
public string GameDirectory { get; set; }</literal_block>
            <paragraph>字符串在用作是文件路径时，可以在提示项中提供自定义过滤器。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.File, "*.txt,")]
public string GameFile { get; set; }</literal_block>
            <paragraph>也可以使用全局文件系统中的路径，仅工具模式下的脚本可以如此使用。</paragraph>
            <paragraph>字符串还可以用作全局文件系统中某个 PNG 文件的路径。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.GlobalFile, "*.png")]
public string ToolImage { get; set; }</literal_block>
            <paragraph>字符串也能用作全局文件系统中某个目录的路径。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.GlobalDir)]
public string ToolDir { get; set; }</literal_block>
            <paragraph>多行文本注释会让编辑器使用大文本输入框来输入文本，而非那种小小的单行输入框。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.MultilineText)]
public string Text { get; set; }</literal_block>
        </section>
        <section ids="limiting-editor-input-ranges" names="limiting\ editor\ input\ ranges 编辑器内限制值的输入范围">
            <title>编辑器内限制值的输入范围</title>
            <paragraph>使用范围属性提示允许你在编辑器中限制可以输入的值。</paragraph>
            <paragraph>允许 0 到 20 之间的整数。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Range, "0,20,")]
public int Number { get; set; }</literal_block>
            <paragraph>允许 -10 到 20 之间的整数。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Range, "-10,20,")]
public int Number { get; set; }</literal_block>
            <paragraph>允许 -10 到 20 之间的数，调整步长为 0.2 。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Range, "-10,20,0.2")]
public float Number { get; set; }</literal_block>
            <paragraph>如果添加了 "or_greater" 和/或 "or_less" 的提示，在调整值时通过键入而非使用滑块，可以超过或低于限制。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Range, "0,100,1,or_greater,or_less")]
public int Number { get; set; }</literal_block>
        </section>
        <section ids="floats-with-easing-hint" names="floats\ with\ easing\ hint 带缓动提示的浮点数">
            <title>带缓动提示的浮点数</title>
            <paragraph>在编辑器里提供 'ease()' 函数的视觉呈现。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.ExpEasing)]
public float TransitionSpeed { get; set; }</literal_block>
        </section>
        <section ids="colors" names="colors 颜色">
            <title>颜色</title>
            <paragraph>使用红、绿、蓝、Alpha 值指定普通颜色。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
private Color Color { get; set; }</literal_block>
            <paragraph>使用红、绿、蓝值指定颜色（此时Alpha 始终为 1）。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.ColorNoAlpha)]
private Color Color { get; set; }</literal_block>
        </section>
        <section ids="nodes" names="nodes 节点">
            <title>节点</title>
            <paragraph>从 Godot 4.0 开始，节点可以直接导出，而不需要使用节点路径(NodePath)。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Node Node { get; set; }</literal_block>
            <paragraph>也可以使用自定义节点类，参见 <reference internal="True" refuri="c_sharp_global_classes#doc-c-sharp-global-classes"><inline classes="std std-ref">C# 全局类</inline></reference> 。</paragraph>
            <paragraph>如有需要，仍可以像 Godot 3.x 中那样导出 NodePath：</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
private NodePath _nodePath;

public override void _Ready()
{
    var node = GetNode(_nodePath);
}</literal_block>
        </section>
        <section ids="resources" names="resources 资源">
            <title>资源</title>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
private Resource Resource;</literal_block>
            <paragraph>在检查器里，可以将资源文件从文件系统面板中拖放到导出变量所对应的槽位中。</paragraph>
            <paragraph>展开检查器下拉菜单可能导致一个极长的可能创建的类别列表。因此，如果你指定从 Resource 派生的类型的话：</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
private AnimationNode Resource;</literal_block>
            <paragraph>那么下拉菜单将只限于 AnimationNode 及其所有继承的类。也可以使用自定义的资源类，参见 <reference internal="True" refuri="c_sharp_global_classes#doc-c-sharp-global-classes"><inline classes="std std-ref">C# 全局类</inline></reference> 。</paragraph>
            <paragraph>必须注意：即使在在编辑器模式中未运行脚本，导出的属性仍可编辑。这一点可以与 <reference internal="True" refuri="../gdscript/gdscript_basics#doc-gdscript-tool-mode"><inline classes="std std-ref">使用工具模式的脚本</inline></reference> 配合使用。</paragraph>
        </section>
        <section ids="exporting-bit-flags" names="exporting\ bit\ flags 导出位标记">
            <title>导出位标记</title>
            <paragraph>具有 <literal>[Flags]</literal> 特性的枚举类型的成员可以被导出，它们的值被限制为枚举类型的成员。编辑器将在检查器中创建一个小部件，允许选择枚举成员中的零个、一个或多个。该值将被存储为整数。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Use power of 2 values for the values of the enum members.
[Flags]
public enum MyEnum
{
    Fire = 1 &lt;&lt; 1,
    Water = 1 &lt;&lt; 2,
    Earth = 1 &lt;&lt; 3,
    Wind = 1 &lt;&lt; 4,

    // A combination of flags is also possible.
    FireAndWater = Fire | Water,
}

[Export]
public SpellElements MySpellElements { get; set; }</literal_block>
            <paragraph>用作位标志的整数可以在一个属性中存储多个 <literal>true</literal>/ <literal>false</literal>（布尔）值。通过使用导出提示 <literal>int, FLAGS, ...</literal>，可以在编辑器中设置它们。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Set any of the given flags from the editor.
[Export(PropertyHint.Flags, "Fire,Water,Earth,Wind")]
public int SpellElements { get; set; } = 0;</literal_block>
            <paragraph>你必须为每个标志提供一个字符串描述。在这个例子中， <literal>Fire</literal> 的值是 1， <literal>Water</literal> 的值是 2， <literal>Earth</literal> 的值是 4， <literal>Wind</literal> 对应的值是 8。通常，应相应地定义常量（例如 <literal>private const int ElementWind = 8</literal> 等等）。</paragraph>
            <paragraph>你可以使用冒号添加显式的值：</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Flags, "Self:4,Allies:8,Foes:16")]
public int SpellTargets { get; set; } = 0;</literal_block>
            <paragraph>只有2的幂次方值才是有效的位标记选项。允许的最低值是1，因为0表示没有选中任何内容。你还可以添加一些其他标记的组合作为选项：</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Flags, "Self:4,Allies:8,Self and Allies:12,Foes:16")]
public int SpellTargets { get; set; } = 0;</literal_block>
            <paragraph>也可以为项目设置中定义的物理层和渲染层提供导出提示。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Layers2DPhysics)]
public uint Layers2DPhysics { get; set; }
[Export(PropertyHint.Layers2DRender)]
public uint Layers2DRender { get; set; }
[Export(PropertyHint.Layers3DPhysics)]
public uint Layers3DPhysics { get; set; }
[Export(PropertyHint.Layers3DRender)]
public uint Layers3DRender { get; set; }</literal_block>
            <paragraph>使用位标记需要对位操作有一定的了解，若对此有疑问，请使用布尔变量代替位标记使用。</paragraph>
        </section>
        <section ids="exporting-enums" names="exporting\ enums 导出枚举">
            <title>导出枚举</title>
            <paragraph>类型是枚举的成员可以导出，它们的值只能是枚举类型的成员之一。编辑器会在检查器中创建一个小部件，把以下内容列举为“Thing 1”、“Thing 2”、“Another Thing”。这个值会以整数的形式存储。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public enum MyEnum
{
    Thing1,
    Thing2,
    AnotherThing = -1,
}

[Export]
public MyEnum MyEnum { get; set; }</literal_block>
            <paragraph>整数和字符串类型的成员也可以使用 <literal>[Export]</literal> 特性和 <literal>PropertyHint.Enum</literal> 提示来限制为特定的值列表。编辑器会在检查器中创建一个小部件，把以下内容列举为 Warrior、Magician、Thief。这个值会以整数的形式存储，对应于所选选项的索引（即 <literal>0</literal> 、 <literal>1</literal> 或 <literal>2</literal> ）。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Enum, "Warrior,Magician,Thief")]
public int CharacterClass { get; set; };</literal_block>
            <paragraph>你可以使用冒号添加显式的值：</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Enum, "Slow:30,Average:60,Very Fast:200")]
public int CharacterSpeed { get; set; }</literal_block>
            <paragraph>如果类型是 <literal>string</literal> ，值将以字符串形式存储。</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Enum, "Rebecca,Mary,Leah")]
public string CharacterName { get; set; }</literal_block>
            <paragraph>如果你想设置初始值，你必须明确指定它：</paragraph>
            <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export(PropertyHint.Enum, "Rebecca,Mary,Leah")]
public string CharacterName { get; set; } = "Rebecca";</literal_block>
        </section>
        <section ids="exporting-collections" names="exporting\ collections 导出集合">
            <title>导出集合</title>
            <paragraph>如 <reference internal="True" refuri="c_sharp_variant#doc-c-sharp-variant"><inline classes="std std-ref">C# Variant</inline></reference> 文档所述，只有特定的 C# 数组和 <literal>Godot.Collections</literal> 命名空间中定义的集合类型是 Variant 兼容的，因此，只有这些类型才能被导出。</paragraph>
            <section ids="exporting-godot-arrays" names="exporting\ godot\ arrays 导出\ godot\ 数组">
                <title>导出 Godot 数组</title>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Godot.Collections.Array Array { get; set; }</literal_block>
                <paragraph>使用泛型 <literal>Godot.Collections.Array&lt;T&gt;</literal> 可以指定数组元素的类型，这将作为编辑器的提示。检查器会限制元素为指定的类型。</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Godot.Collections.Array&lt;string&gt; Array { get; set; }</literal_block>
                <paragraph>Godot 数组的默认值是 null，可以指定不同的默认值：</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Godot.Collections.Array&lt;string&gt; CharacterNames { get; set; } = new Godot.Collections.Array&lt;string&gt;
{
    "Rebecca",
    "Mary",
    "Leah",
};</literal_block>
                <paragraph>如果导出的数组指定了从 Resource 继承的类型，则可以一次性从文件系统面板中拖放多个文件到检查器中来设置该数组的值。</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Godot.Collections.Array&lt;Texture&gt; Textures { get; set; }

[Export]
public Godot.Collections.Array&lt;PackedScene&gt; Scenes { get; set; }</literal_block>
            </section>
            <section ids="exporting-godot-dictionaries" names="exporting\ godot\ dictionaries 导出\ godot\ 字典">
                <title>导出 Godot 字典</title>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Godot.Collections.Dictionary Dictionary { get; set; }</literal_block>
                <paragraph>使用泛型 <literal>Godot.Collections.Dictionary&lt;TKey, TValue&gt;</literal> 允许指定字典的键和值的元素的类型。</paragraph>
                <note>
                    <paragraph>目前在 Godot 编辑器中不支持类型化字典，因此检查器将不会限制可以分配的类型，可能导致运行时异常。</paragraph>
                </note>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Godot.Collections.Dictionary&lt;string, int&gt; Dictionary { get; set; }</literal_block>
                <paragraph>Godot 字典的默认值是 null，可以指定不同的默认值：</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Godot.Collections.Dictionary&lt;string, int&gt; CharacterLives { get; set; } = new Godot.Collections.Dictionary&lt;string, int&gt;
{
    ["Rebecca"] = 10,
    ["Mary"] = 42,
    ["Leah"] = 0,
};</literal_block>
            </section>
            <section ids="exporting-c-arrays" names="exporting\ c#\ arrays 导出\ c#\ 数组">
                <title>导出 C# 数组</title>
                <paragraph>C# 数组的元素类型是 <reference internal="True" refuri="c_sharp_variant#doc-c-sharp-variant"><inline classes="std std-ref">Variant 兼容</inline></reference> 类型，就可以导出。</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Vector3[] Vectors { get; set; }

[Export]
public NodePath[] NodePaths { get; set; }</literal_block>
                <paragraph>C# 数组的默认值是 null，可以指定不同的默认值：</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Export]
public Vector3[] Vectors { get; set; } = new Vector3[]
{
    new Vector3(1, 2, 3),
    new Vector3(3, 2, 1),
}</literal_block>
            </section>
        </section>
        <section ids="setting-exported-variables-from-a-tool-script" names="setting\ exported\ variables\ from\ a\ tool\ script 从工具脚本中设置导出变量">
            <title>从工具脚本中设置导出变量</title>
            <paragraph>当 <reference internal="True" refuri="../gdscript/gdscript_basics#doc-gdscript-tool-mode"><inline classes="std std-ref">工具模式</inline></reference> 下的脚本中的一个导出变量的值改变时，该值在检查器中不会自动更新。要更新它，请在设置该导出变量的值之后调用 <reference internal="True" refuri="../../../classes/class_object#class-object-method-notify-property-list-changed"><inline classes="std std-ref">NotifyPropertyListChanged()</inline></reference>。</paragraph>
        </section>
        <section ids="advanced-exports" names="advanced\ exports 高级导出">
            <title>高级导出</title>
            <paragraph>为了避免非必要的复杂设计，并非所有类型的导出都在语言层面上提供。下面将说明一些能用底层 API 实现的，且较为常见的导出方法。</paragraph>
            <paragraph>在进一步阅读前，你需要熟悉属性被处理的方式，以及它们是如何通过 <reference internal="True" refuri="../../../classes/class_object#class-object-private-method-set"><inline classes="std std-ref">_Set()</inline></reference>、 <reference internal="True" refuri="../../../classes/class_object#class-object-private-method-get"><inline classes="std std-ref">_Get()</inline></reference>、 <reference internal="True" refuri="../../../classes/class_object#class-object-private-method-get-property-list"><inline classes="std std-ref">_GetPropertyList()</inline></reference> 等方法进行定制的。详情可参阅 <reference internal="True" refuri="../../best_practices/godot_interfaces#doc-accessing-data-or-logic-from-object"><inline classes="std std-ref">从对象访问数据或逻辑</inline></reference>。</paragraph>
            <seealso>
                <paragraph>要在 C++ 中用上述方法绑定属性，请参阅 <reference internal="True" refuri="../../../contributing/development/core_and_modules/object_class#doc-binding-properties-using-set-get-property-list"><inline classes="std std-ref">使用 _set/_get/_get_property_list 绑定属性</inline></reference>。</paragraph>
            </seealso>
            <warning>
                <paragraph>脚本必须在 <literal>tool</literal> 模式运行，才能使上述方法在编辑器内运行。</paragraph>
            </warning>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
