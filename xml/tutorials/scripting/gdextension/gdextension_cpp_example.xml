<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/gdextension/gdextension_cpp_example.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-gdextension-cpp-example"></target>
    <section ids="gdextension-c-example doc-gdextension-cpp-example" names="gdextension\ c++\ example gdextension\ c++\ 示例 doc_gdextension_cpp_example">
        <title>GDExtension C++ 示例</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>GDExtension 的 C++ 绑定是在 C GDExtension API 基础之上构建的，为扩展 Godot 中的节点和其他内置类提供了一种更为简洁的方法。这一新系统使得通过 GDExtension 对 Godot 进行扩展的能力几乎可以与静态链接的 C++ 模块相媲美。</paragraph>
            <paragraph>你可以在`Github上的 godot-cpp 仓库 &lt;<reference refuri="https://github.com/godotengine/godot-cpp">https://github.com/godotengine/godot-cpp</reference>&gt;`__中下载 "test" 文件夹内的内置范例。</paragraph>
        </section>
        <section ids="setting-up-the-project" names="setting\ up\ the\ project 设置项目">
            <title>设置项目</title>
            <paragraph>这里有一些前置需求是你需要的：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>一份 Godot 4 可执行文件，</paragraph>
                </list_item>
                <list_item>
                    <paragraph>一个 C++ 编译器，</paragraph>
                </list_item>
                <list_item>
                    <paragraph>作为构建工具的 SCons ，</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="godot-cpp 仓库" refuri="https://github.com/godotengine/godot-cpp">godot-cpp 仓库</reference>的副本。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>另请参阅<reference internal="True" refuri="../../../contributing/development/compiling/index#toc-devel-compiling"><inline classes="std std-ref">《编译》</inline></reference>，因为构建工具与从源代码编译 Godot 所需的构建工具相同。</paragraph>
            <paragraph>你可以从 GitHub 下载 <problematic ids="id2" refid="id1">`godot-cpp 仓库&lt;https://github.com/godotengine/godot-cpp&gt;`__</problematic>，或者让 Git 为你完成这项工作。请注意，这个仓库为不同版本的 Godot 提供了不同的分支。GDExtensions 仅支持 Godot 的新版本（Godot 4 及更高版本），反之亦然，因此请确保你下载的是正确的分支。</paragraph>
            <note>
                <paragraph>To use <reference name="GDExtension" refuri="https://godotengine.org/article/introducing-gd-extensions">GDExtension</reference>
                    you need to use the godot-cpp branch that matches the version of Godot that you are
                    targeting. For example, if you're targeting Godot 4.1, use the <literal>4.1</literal> branch. Throughout
                    this tutorial we use <literal>4.x</literal>, which will need to be replaced with the version of Godot you
                    are targeting.</paragraph>
                <paragraph><literal>master</literal> 分支是开发分支，它会定期更新以与 Godot 的 <literal>master</literal> 分支保持兼容。</paragraph>
            </note>
            <warning>
                <paragraph>Our long-term goal is that GDExtensions targeting an earlier version of Godot will work
                    in later minor versions, but not vice-versa. For example, a GDExtension targeting Godot 4.1
                    should work just fine in Godot 4.2, but one targeting Godot 4.2 won't work in Godot 4.1.</paragraph>
                <paragraph>不过，GDExtension 目前仍是 <emphasis>实验性的</emphasis>，这就意味着我们为了修复严重的 bug 或引入重大的特性，可能会牺牲兼容性。例如，为 Godot 4.0 创建的 GDExtension 与 Godot 4.1 并不兼容（参见 <reference internal="True" refuri="../../migrating/upgrading_to_godot_4.1#updating-your-gdextension-for-godot-4-1"><inline classes="std std-ref">将 GDExtension 更新到 4.1</inline></reference> ）。</paragraph>
            </warning>
            <paragraph>如果您使用 Git 对项目进行版本控制，最好将项目添加为 Git 子模块：</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">mkdir gdextension_cpp_example
cd gdextension_cpp_example
git init
git submodule add -b 4.x https://github.com/godotengine/godot-cpp
cd godot-cpp
git submodule update --init</literal_block>
            <paragraph>也可以直接将该项目克隆到项目文件夹内：</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">mkdir gdextension_cpp_example
cd gdextension_cpp_example
git clone -b 4.x https://github.com/godotengine/godot-cpp</literal_block>
            <note>
                <paragraph>如果您决定下载仓库或将其克隆到您的文件夹中，请确保与我们这里所设置的文件夹结构相同，我们假定将在此展示的许多代码都基于这种项目结构。</paragraph>
            </note>
            <paragraph>如果从介绍中指定的链接克隆示例, 子模块不会自动初始化. 你需要执行以下命令:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">cd gdextension_cpp_example
git submodule update --init</literal_block>
            <paragraph>这会将该仓库克隆到您的项目文件夹中。</paragraph>
        </section>
        <section ids="building-the-c-bindings" names="building\ the\ c++\ bindings 构建\ c++\ 绑定">
            <title>构建 C++ 绑定</title>
            <paragraph>现在我们已经下载了我们的前置需求, 现在是构建C++绑定的时候了.</paragraph>
            <paragraph>仓库包含当前 Godot 版本的元数据副本，但如果你需要为较新版本的 Godot 构建这些绑定，只需调用 Godot 可执行文件：</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">godot --dump-extension-api</literal_block>
            <paragraph>生成的 <literal>extension_api.json</literal> 文件将会出现在可执行文件的目录中，将其复制到项目文件夹中，并在下面的 scons 命令中添加 <literal>custom_api_file=&lt;PATH_TO_FILE&gt;</literal> 参数。</paragraph>
            <paragraph>用该命令来生成、编译绑定（取决于你的操作系统，用 <literal>windows</literal> , <literal>linux</literal> 或 <literal>macos</literal> 代替 <literal>&lt;platform&gt;</literal> ）：</paragraph>
            <paragraph>构建过程会自动检测可用于并行构建的 CPU 线程数量。要指定使用的 CPU 线程数，请在 SCons 命令行的末尾添加 <literal>-jN</literal>，其中 <literal>N</literal> 是您希望使用的 CPU 线程数量。</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">cd godot-cpp
scons platform=&lt;platform&gt; custom_api_file=&lt;PATH_TO_FILE&gt;
cd ..</literal_block>
            <paragraph>这一步将需要一段时间。完成后，你应该有一个静态库，可以编译到你的项目中，存储在 <literal>godot-cpp / bin /</literal> 内。</paragraph>
            <note>
                <paragraph>你可能需要在 Windows 或 Linux 的命令行中添加 <literal>bits=64</literal>。</paragraph>
            </note>
        </section>
        <section ids="creating-a-simple-plugin" names="creating\ a\ simple\ plugin 创建一个简单的插件">
            <title>创建一个简单的插件</title>
            <paragraph>现在是构建实际插件的时候了。我们首先创建一个空的 Godot 项目，我们将在其中放置一些文件。</paragraph>
            <paragraph>打开 Godot 并创建一个新项目。对于该示例，我们将其放在我们的 GDExtension 的文件夹结构中名为 <literal>demo</literal> 的文件夹中。</paragraph>
            <paragraph>在我们的演示项目中，我们将创建一个包含名为 "Main" 的节点的场景，我们将其保存为 <literal>main.tscn</literal> ，稍后再回过头来看看。</paragraph>
            <paragraph>回到顶层 GDExtension 模块文件夹，我们还要创建一个名为 <literal>src</literal> 的子文件夹，将在其中放置源文件。</paragraph>
            <paragraph>在你的 GDExtension 模块中，你现在应该有 <literal>demo</literal> 、 <literal>godot-cpp</literal> 和 <literal>src</literal> 这三个目录。</paragraph>
            <paragraph>你的文件结构应如下所示：</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">gdextension_cpp_example/
|
+--demo/                  # game example/demo to test the extension
|
+--godot-cpp/             # C++ bindings
|
+--src/                   # source code of the extension we are building</literal_block>
            <paragraph>在 <literal>src</literal> 文件夹中，我们将首先为我们将要创建的 GDExtension 节点创建头文件，将其命名为 <literal>gdexample.h</literal> ：</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#ifndef GDEXAMPLE_H
#define GDEXAMPLE_H

#include &lt;godot_cpp/classes/sprite2d.hpp&gt;

namespace godot {

class GDExample : public Sprite2D {
    GDCLASS(GDExample, Sprite2D)

private:
    double time_passed;

protected:
    static void _bind_methods();

public:
    GDExample();
    ~GDExample();

    void _process(double delta) override;
};

}

#endif</literal_block>
            <paragraph>There are a few things of note to the above. We include <literal>sprite2d.hpp</literal> which
                contains bindings to the Sprite2D class. We'll be extending this class in our
                module.</paragraph>
            <paragraph>We're using the namespace <literal>godot</literal>, since everything in GDExtension is defined
                within this namespace.</paragraph>
            <paragraph>Then we have our class definition, which inherits from our Sprite2D through a
                container class. We'll see a few side effects of this later on. The
                <literal>GDCLASS</literal> macro sets up a few internal things for us.</paragraph>
            <paragraph>之后, 我们声明一个名为 <literal>time_passed</literal> 的成员变量.</paragraph>
            <paragraph>In the next block we're defining our methods, we have our constructor
                and destructor defined, but there are two other functions that will likely look
                familiar to some, and one new method.</paragraph>
            <paragraph>The first is <literal>_bind_methods</literal>, which is a static function that Godot will
                call to find out which methods can be called and which properties it exposes.
                The second is our <literal>_process</literal> function, which will work exactly the same
                as the <literal>_process</literal> function you're used to in GDScript.</paragraph>
            <paragraph>所以, 让我们通过创建 <literal>gdexample.cpp</literal> 文件来实现我们的函数:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "gdexample.h"
#include &lt;godot_cpp/core/class_db.hpp&gt;

using namespace godot;

void GDExample::_bind_methods() {
}

GDExample::GDExample() {
    // Initialize any variables here.
    time_passed = 0.0;
}

GDExample::~GDExample() {
    // Add your cleanup here.
}

void GDExample::_process(double delta) {
    time_passed += delta;

    Vector2 new_position = Vector2(10.0 + (10.0 * sin(time_passed * 2.0)), 10.0 + (10.0 * cos(time_passed * 1.5)));

    set_position(new_position);
}</literal_block>
            <paragraph>This one should be straightforward. We're implementing each method of our class
                that we defined in our header file.</paragraph>
            <paragraph>Note our <literal>_process</literal> function, which keeps track of how much time has passed
                and calculates a new position for our sprite using a sine and cosine function.</paragraph>
            <paragraph>There is one more C++ file we need; we'll name it <literal>register_types.cpp</literal>. Our
                GDExtension plugin can contain multiple classes, each with their own header
                and source file like we've implemented <literal>GDExample</literal> up above. What we need now
                is a small bit of code that tells Godot about all the classes in our
                GDExtension plugin.</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "register_types.h"

#include "gdexample.h"

#include &lt;gdextension_interface.h&gt;
#include &lt;godot_cpp/core/defs.hpp&gt;
#include &lt;godot_cpp/godot.hpp&gt;

using namespace godot;

void initialize_example_module(ModuleInitializationLevel p_level) {
    if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) {
        return;
    }

    GDREGISTER_CLASS(GDExample);
}

void uninitialize_example_module(ModuleInitializationLevel p_level) {
    if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) {
        return;
    }
}

extern "C" {
// Initialization.
GDExtensionBool GDE_EXPORT example_library_init(GDExtensionInterfaceGetProcAddress p_get_proc_address, const GDExtensionClassLibraryPtr p_library, GDExtensionInitialization *r_initialization) {
    godot::GDExtensionBinding::InitObject init_obj(p_get_proc_address, p_library, r_initialization);

    init_obj.register_initializer(initialize_example_module);
    init_obj.register_terminator(uninitialize_example_module);
    init_obj.set_minimum_library_initialization_level(MODULE_INITIALIZATION_LEVEL_SCENE);

    return init_obj.init();
}
}</literal_block>
            <paragraph>The <literal>initialize_example_module</literal> and <literal>uninitialize_example_module</literal> functions get
                called respectively when Godot loads our plugin and when it unloads it. All
                we're doing here is parse through the functions in our bindings module to
                initialize them, but you might have to set up more things depending on your
                needs. We call the function <literal>register_class</literal> for each of our classes in our library.</paragraph>
            <paragraph>The important function is the third function called <literal>example_library_init</literal>.
                We first call a function in our bindings library that creates an initialization object.
                This object registers the initialization and termination functions of the GDExtension.
                Furthermore, it sets the level of initialization (core, servers, scene, editor, level).</paragraph>
            <paragraph>At last, we need the header file for the <literal>register_types.cpp</literal> named
                <literal>register_types.h</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#ifndef GDEXAMPLE_REGISTER_TYPES_H
#define GDEXAMPLE_REGISTER_TYPES_H

#include &lt;godot_cpp/core/class_db.hpp&gt;

using namespace godot;

void initialize_example_module(ModuleInitializationLevel p_level);
void uninitialize_example_module(ModuleInitializationLevel p_level);

#endif // GDEXAMPLE_REGISTER_TYPES_H</literal_block>
        </section>
        <section ids="compiling-the-plugin" names="compiling\ the\ plugin 编译插件">
            <title>编译插件</title>
            <paragraph>手工编写 SCons 用于构建的 <literal>SConstruct</literal> 文件并不容易。出于这个示例的目的，只需使用我们已经准备好的<download_reference filename="45a3f5e351266601b5e7663dc077fe12/SConstruct" refdoc="tutorials/scripting/gdextension/gdextension_cpp_example" refdomain="" refexplicit="True" reftarget="files/cpp_example/SConstruct" reftype="download" refwarn="False"><literal classes="xref download">这个硬编码的 SConstruct 文件</literal></download_reference>。我们将在后续教程中介绍如何使用这些构建文件的更可定制的详细示例。</paragraph>
            <note>
                <paragraph>This <literal>SConstruct</literal> file was written to be used with the latest <literal>godot-cpp</literal>
                    master, you may need to make small changes using it with older versions or
                    refer to the <literal>SConstruct</literal> file in the Godot 4.x documentation.</paragraph>
            </note>
            <paragraph>Once you've downloaded the <literal>SConstruct</literal> file, place it in your GDExtension folder
                structure alongside <literal>godot-cpp</literal>, <literal>src</literal> and <literal>demo</literal>, then run:</paragraph>
            <literal_block force="False" highlight_args="{}" language="bash" linenos="False" xml:space="preserve">scons platform=&lt;platform&gt;</literal_block>
            <paragraph>你现在应该能够在 <literal>demo / bin / &lt;platform&gt;</literal> 中找到该模块.</paragraph>
            <note>
                <paragraph>Here, we've compiled both godot-cpp and our gdexample library as debug
                    builds. For optimized builds, you should compile them using the
                    <literal>target=template_release</literal> switch.</paragraph>
            </note>
        </section>
        <section ids="using-the-gdextension-module" names="using\ the\ gdextension\ module">
            <title>Using the GDExtension module</title>
            <paragraph>Before we jump back into Godot, we need to create one more file in
                <literal>demo/bin/</literal>.</paragraph>
            <paragraph>This file lets Godot know what dynamic libraries should be
                loaded for each platform and the entry function for the module. It is called <literal>gdexample.gdextension</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">[configuration]

entry_symbol = "example_library_init"
compatibility_minimum = "4.1"

[libraries]

macos.debug = "res://bin/libgdexample.macos.template_debug.framework"
macos.release = "res://bin/libgdexample.macos.template_release.framework"
windows.debug.x86_32 = "res://bin/libgdexample.windows.template_debug.x86_32.dll"
windows.release.x86_32 = "res://bin/libgdexample.windows.template_release.x86_32.dll"
windows.debug.x86_64 = "res://bin/libgdexample.windows.template_debug.x86_64.dll"
windows.release.x86_64 = "res://bin/libgdexample.windows.template_release.x86_64.dll"
linux.debug.x86_64 = "res://bin/libgdexample.linux.template_debug.x86_64.so"
linux.release.x86_64 = "res://bin/libgdexample.linux.template_release.x86_64.so"
linux.debug.arm64 = "res://bin/libgdexample.linux.template_debug.arm64.so"
linux.release.arm64 = "res://bin/libgdexample.linux.template_release.arm64.so"
linux.debug.rv64 = "res://bin/libgdexample.linux.template_debug.rv64.so"
linux.release.rv64 = "res://bin/libgdexample.linux.template_release.rv64.so"
android.debug.x86_64 = "res://bin/libgdexample.android.template_debug.x86_64.so"
android.release.x86_64 = "res://bin/libgdexample.android.template_release.x86_64.so"
android.debug.arm64 = "res://bin/libgdexample.android.template_debug.arm64.so"
android.release.arm64 = "res://bin/libgdexample.android.template_release.arm64.so"</literal_block>
            <paragraph>This file contains a <literal>configuration</literal> section that controls the entry function of the module.
                You should also set the minimum compatible Godot version with <literal>compatability_minimum</literal>,
                which prevents older version of Godot from trying to load your extension.</paragraph>
            <paragraph>The <literal>libraries</literal> section is the important bit: it tells Godot the location of the
                dynamic library in the project's filesystem for each supported platform. It will
                also result in <emphasis>just</emphasis> that file being exported when you export the project,
                which means the data pack won't contain libraries that are incompatible with the
                target platform.</paragraph>
            <paragraph>Finally, the <literal>dependencies</literal> section allows you to name additional dynamic
                libraries that should be included as well. This is important when your GDExtension
                plugin implements someone else's library and requires you to supply a
                third-party dynamic library with your project.</paragraph>
            <paragraph>Here is another overview to check the correct file structure:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">gdextension_cpp_example/
|
+--demo/                  # game example/demo to test the extension
|   |
|   +--main.tscn
|   |
|   +--bin/
|       |
|       +--gdexample.gdextension
|
+--godot-cpp/             # C++ bindings
|
+--src/                   # source code of the extension we are building
|   |
|   +--register_types.cpp
|   +--register_types.h
|   +--gdexample.cpp
|   +--gdexample.h</literal_block>
            <paragraph>Time to jump back into Godot. We load up the main scene we created way back in
                the beginning and now add a newly available GDExample node to the scene:</paragraph>
            <image candidates="{'*': 'tutorials/scripting/gdextension/img/gdextension_cpp_nodes.webp'}" uri="tutorials/scripting/gdextension/img/gdextension_cpp_nodes.webp"></image>
            <paragraph>We're going to assign the Godot logo to this node as our texture, disable the
                <literal>centered</literal> property:</paragraph>
            <image candidates="{'*': 'tutorials/scripting/gdextension/img/gdextension_cpp_sprite.webp'}" uri="tutorials/scripting/gdextension/img/gdextension_cpp_sprite.webp"></image>
            <paragraph>我们终于准备好运行这个项目了:</paragraph>
            <image candidates="{'*': 'tutorials/scripting/gdextension/img/gdextension_cpp_animated.gif'}" uri="tutorials/scripting/gdextension/img/gdextension_cpp_animated.gif"></image>
        </section>
        <section ids="custom-editor-icon" names="custom\ editor\ icon 自定义编辑器图标">
            <title>自定义编辑器图标</title>
            <paragraph>By default, Godot uses the node icon in the scene dock for GDExtension nodes. The custom icon can be
                added via the <literal>gdextension</literal> file. The node's icon is set by reference to its name and resource path
                of an SVG file.</paragraph>
            <paragraph>例如：</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">[icons]

GDExample = "res://icons/gd_example.svg"</literal_block>
            <paragraph>The path should point to a 16 by 16 pixel SVG image. Read the guide for <reference internal="True" refuri="../../../contributing/development/editor/creating_icons#doc-editor-icons"><inline classes="std std-ref">creating icons</inline></reference>
                for more information.</paragraph>
        </section>
        <section ids="adding-properties" names="adding\ properties 添加属性">
            <title>添加属性</title>
            <paragraph>GDScript allows you to add properties to your script using the <literal>export</literal>
                keyword. In GDExtension you have to register the properties with a getter and
                setter function or directly implement the <literal>_get_property_list</literal>, <literal>_get</literal> and
                <literal>_set</literal> methods of an object (but that goes far beyond the scope of this
                tutorial).</paragraph>
            <paragraph>Lets add a property that allows us to control the amplitude of our wave.</paragraph>
            <paragraph>In our <literal>gdexample.h</literal> file we need to add a member variable and getter and setter
                functions:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">...
private:
    double time_passed;
    double amplitude;

public:
    void set_amplitude(const double p_amplitude);
    double get_amplitude() const;
...</literal_block>
            <paragraph>在我们的 <literal>gdexample.cpp</literal> 文件中, 我们需要进行一些更改, 我们只会显示我们最终更改的方法, 不要删除我们省略的行:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void GDExample::_bind_methods() {
    ClassDB::bind_method(D_METHOD("get_amplitude"), &amp;GDExample::get_amplitude);
    ClassDB::bind_method(D_METHOD("set_amplitude", "p_amplitude"), &amp;GDExample::set_amplitude);
    ADD_PROPERTY(PropertyInfo(Variant::FLOAT, "amplitude"), "set_amplitude", "get_amplitude");
}

GDExample::GDExample() {
    // Initialize any variables here.
    time_passed = 0.0;
    amplitude = 10.0;
}

void GDExample::_process(double delta) {
    time_passed += delta;

    Vector2 new_position = Vector2(
        amplitude + (amplitude * sin(time_passed * 2.0)),
        amplitude + (amplitude * cos(time_passed * 1.5))
    );

    set_position(new_position);
}

void GDExample::set_amplitude(const double p_amplitude) {
    amplitude = p_amplitude;
}

double GDExample::get_amplitude() const {
    return amplitude;
}</literal_block>
            <paragraph>使用这些更改编译模块后，就会看到界面上加入了一个属性。你现在可以更改此属性，当运行项目时，你将看到我们的 Godot 图标沿着更大的数字移动。</paragraph>
            <paragraph>让我们做同样的事情但是为了我们动画的速度并使用 setter 和 getter 函数。我们的 <literal>gdexample.h</literal> 头文件再次只需要几行代码：</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">...
    double amplitude;
    double speed;
...
    void _process(double delta) override;
    void set_speed(const double p_speed);
    double get_speed() const;
...</literal_block>
            <paragraph>这需要对我们的 <literal>gdexample.cpp</literal> 文件进行一些更改, 同样我们只显示已更改的方法, 所以不要删除我们忽略的任何内容:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void GDExample::_bind_methods() {
    ...
    ClassDB::bind_method(D_METHOD("get_speed"), &amp;GDExample::get_speed);
    ClassDB::bind_method(D_METHOD("set_speed", "p_speed"), &amp;GDExample::set_speed);
    ADD_PROPERTY("GDExample", PropertyInfo(Variant::FLOAT, "speed", PROPERTY_HINT_RANGE, "0,20,0.01"), "set_speed", "get_speed");
}

GDExample::GDExample() {
    time_passed = 0.0;
    amplitude = 10.0;
    speed = 1.0;
}

void GDExample::_process(double delta) {
    time_passed += speed * delta;

    Vector2 new_position = Vector2(
        amplitude + (amplitude * sin(time_passed * 2.0)),
        amplitude + (amplitude * cos(time_passed * 1.5))
    );

    set_position(new_position);
}

...

void GDExample::set_speed(const double p_speed) {
    speed = p_speed;
}

double GDExample::get_speed() const {
    return speed;
}</literal_block>
            <paragraph>Now when the project is compiled, we'll see another property called speed.
                Changing its value will make the animation go faster or slower.
                Furthermore, we added a property range which describes in which range the value can be.
                The first two arguments are the minimum and maximum value and the third is the step size.</paragraph>
            <note>
                <paragraph>For simplicity, we've only used the hint_range of the property method.
                    There are a lot more options to choose from. These can be used to
                    further configure how properties are displayed and set on the Godot side.</paragraph>
            </note>
        </section>
        <section ids="signals" names="signals 信号">
            <title>信号</title>
            <paragraph>Last but not least, signals fully work in GDExtension as well. Having your extension
                react to a signal given out by another object requires you to call <literal>connect</literal>
                on that object. We can't think of a good example for our wobbling Godot icon, we
                would need to showcase a far more complete example.</paragraph>
            <paragraph>这是必需的语法：</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">some_other_node-&gt;connect("the_signal", Callable(this, "my_method"));</literal_block>
            <paragraph>To connect our signal <literal>the_signal</literal> from some other node with our method
                <literal>my_method</literal>, we need to provide the <literal>connect</literal> method with the name of the signal
                and a <literal>Callable</literal>. The <literal>Callable</literal> holds information about an object on which a method
                can be called. In our case, it associates our current object instance <literal>this</literal> with the
                method <literal>my_method</literal> of the object. Then the <literal>connect</literal> method will add this to the
                observers of <literal>the_signal</literal>. Whenever <literal>the_signal</literal> is now emitted, Godot knows which
                method of which object it needs to call.</paragraph>
            <paragraph>Note that you can only call <literal>my_method</literal> if you've previously registered it in
                your <literal>_bind_methods</literal> method. Otherwise Godot will not know about the existence
                of <literal>my_method</literal>.</paragraph>
            <paragraph>To learn more about <literal>Callable</literal>, check out the class reference here: <reference internal="True" refuri="../../../classes/class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>.</paragraph>
            <paragraph>让对象发出信号更为常见。对于我们摇摆不定的 Godot 图标，我们会做一些愚蠢的事情来展示它是如何工作的。每过一秒钟我们就会发出一个信号并传递新的位置。</paragraph>
            <paragraph>在我们的 <literal>gdexample.h</literal> 头文件中，我们需要定义一个新成员 <literal>time_emit</literal>：</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">...
    double time_passed;
    double time_emit;
    double amplitude;
...</literal_block>
            <paragraph><literal>gdexample.cpp</literal> 这次的修改有点复杂。首先，你需要在我们的 <literal>_init</literal> 方法或构造函数中设置 <literal>time_emit = 0.0</literal>。另外两个修改我们将逐一查看。</paragraph>
            <paragraph>In our <literal>_bind_methods</literal> method, we need to declare our signal. This is done
                as follows:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void GDExample::_bind_methods() {
    ...
    ADD_PROPERTY("GDExample", PropertyInfo(Variant::FLOAT, "speed", PROPERTY_HINT_RANGE, "0,20,0.01"), "set_speed", "get_speed");

    ADD_SIGNAL(MethodInfo("position_changed", PropertyInfo(Variant::OBJECT, "node"), PropertyInfo(Variant::VECTOR2, "new_pos")));
}</literal_block>
            <paragraph>Here, our <literal>ADD_SIGNAL</literal> macro can be a single call with a <literal>MethodInfo</literal> argument.
                <literal>MethodInfo</literal>'s first parameter will be the signal's name, and its remaining parameters
                are <literal>PropertyInfo</literal> types which describe the essentials of each of the method's parameters.
                <literal>PropertyInfo</literal> parameters are defined with the data type of the parameter, and then the name
                that the parameter will have by default.</paragraph>
            <paragraph>So here, we add a signal, with a <literal>MethodInfo</literal> which names the signal "position_changed". The
                <literal>PropertyInfo</literal> parameters describe two essential arguments, one of type <literal>Object</literal>, the other
                of type <literal>Vector2</literal>, respectively named "node" and "new_pos".</paragraph>
            <paragraph>接下来我们需要修改我们的 <literal>_process</literal> 方法：</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void GDExample::_process(double delta) {
    time_passed += speed * delta;

    Vector2 new_position = Vector2(
        amplitude + (amplitude * sin(time_passed * 2.0)),
        amplitude + (amplitude * cos(time_passed * 1.5))
    );

    set_position(new_position);

    time_emit += delta;
    if (time_emit &gt; 1.0) {
        emit_signal("position_changed", this, new_position);

        time_emit = 0.0;
    }
}</literal_block>
            <paragraph>经过一秒钟后， 我们发出信号并重置我们的计数器。我们可以将参数值直接添加给 <literal>emit_signal</literal>。</paragraph>
            <paragraph>Once the GDExtension library is compiled, we can go into Godot and select our sprite
                node. In the <strong>Node</strong> dock, we can find our new signal and link it up by pressing
                the <strong>Connect</strong> button or double-clicking the signal. We've added a script on
                our main node and implemented our signal like this:</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

func _on_Sprite2D_position_changed(node, new_pos):
    print("The position of " + node.get_class() + " is now " + str(new_pos))</literal_block>
            <paragraph>每一秒，我们都会将我们的位置输出到控制台。</paragraph>
        </section>
        <section ids="next-steps" names="next\ steps 下一步">
            <title>下一步</title>
            <paragraph>We hope the above example showed you the basics. You can
                build upon this example to create full-fledged scripts to control nodes in Godot
                using C++.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
