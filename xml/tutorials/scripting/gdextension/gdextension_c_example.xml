<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/gdextension/gdextension_c_example.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-gdextension-c-example"></target>
    <section ids="gdextension-c-example doc-gdextension-c-example" names="gdextension\ c\ example doc_gdextension_c_example">
        <title>GDExtension C example</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>This is a simple example on how to work with GDExtension directly with C code.
                Note that the API is not meant to be used directly, so this will definitely be
                quite verbose and require a lot of steps even for a small example. However, it
                serves as a reference for creating bindings for a different language. It is
                still possible to use the API directly if you prefer, which might be convenient
                when only binding a third-party library.</paragraph>
            <paragraph>In this example we will create a custom node that moves a sprite on the screen
                based on the user's parameters. While very simple, it serves to show how to do
                some of the things with GDExtension, like registering custom classes with
                methods, properties, and signals. It gives an insight on the GDExtension API.</paragraph>
        </section>
        <section ids="setting-up-the-project" names="setting\ up\ the\ project">
            <title>Setting up the project</title>
            <paragraph>There are a few prerequisites you'll need:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>a Godot 4.2 (or later) executable,</paragraph>
                </list_item>
                <list_item>
                    <paragraph>a C compiler,</paragraph>
                </list_item>
                <list_item>
                    <paragraph>SCons as a build tool.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Since this is using the API directly, there's no need to use the
                <reference name="godot-cpp repository" refuri="https://github.com/godotengine/godot-cpp">godot-cpp repository</reference>.</paragraph>
        </section>
        <section ids="file-structure" names="file\ structure">
            <title>File structure</title>
            <paragraph>To organize our files, we're gonna split into mainly two folders:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">gdextension_c_example/
|
+--demo/                  # game example/demo to test the extension
|
+--src/                   # source code of the extension we are building</literal_block>
            <paragraph>We also need a copy of the <literal>gdextension_interface.h</literal> header from the Godot
                source code, which can be obtained directly from the Godot executable by running
                the following command:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">godot --dump-gdextension-interface</literal_block>
            <paragraph>This creates the header in the current folder, so you can just copy it to the <literal>src</literal>
                folder in the example project.</paragraph>
            <paragraph>Lastly, there's another source of information we need to refer to, which is the JSON
                file with the Godot API reference. This file won't be used by the code directly, we
                will only use it to extract some information manually.</paragraph>
            <paragraph>To get this JSON file, just call the Godot executable:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">godot --dump-extension-api</literal_block>
            <paragraph>The resulting <literal>extension_api.json</literal> file will be created in the current
                folder. You can copy this file to the example folder to have it handy.</paragraph>
            <note>
                <paragraph>This extension is targeting Godot 4.2, but it should work on later versions as
                    well. If you want to target a different minimal version, make sure to get the
                    header and the JSON from the version Godot version you are targeting.</paragraph>
            </note>
        </section>
        <section ids="buildsystem" names="buildsystem">
            <title>Buildsystem</title>
            <paragraph>Using a buildsystem makes our life a lot easier when dealing with C code. For
                the sake of convenience, we'll use SCons since it's the same as what Godot
                itself uses.</paragraph>
            <paragraph>The following <literal>SConstruct</literal> file is a simple one that will build your extension
                to the current platform that you are using, be it Linux, macOS, or Windows. This
                will be a non-optimized build for debugging purposes. It also assumes a 64-bit
                build, which is relevant for some parts of the example code. Making other build
                types and cross-compilation is out of the scope of this tutorial. Save this file
                to the root folder.</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">#!/bin/env python
from SCons.Script import Environment
from os import path
import sys

env = Environment()

# Set the target path and name.
target_path = "demo/bin/"
target_name = "libgdexample"

# Set the compiler and flags.
env.Append(CPPPATH=["src"])  # Add the src folder to the include path.
env.Append(CFLAGS=["-O0", "-g"])  # Make it a debug build.

# Use Clang on macOS.
if sys.platform == "darwin":
    env["CC"] = "clang"

# Add all C files in "src" folder as sources.
sources = env.Glob("src/*.c")

# Create a shared library.
library = env.SharedLibrary(
    target=path.join(target_path, target_name),
    source=sources,
)

# Set the library as the default target.
env.Default(library)</literal_block>
            <paragraph>This will include all C files in the <literal>src</literal> folder, so we don't need to change
                this file when adding new source files.</paragraph>
        </section>
        <section ids="initializing-the-extension" names="initializing\ the\ extension">
            <title>Initializing the extension</title>
            <paragraph>The first bit of code will be responsible for initializing the extension. This is
                what makes Godot aware of what our GDExtension provides, such as classes and
                plugins.</paragraph>
            <paragraph>Create the file <literal>init.h</literal> in the <literal>src</literal> folder, with the following contents:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">#pragma once

#include "defs.h"

#include "gdextension_interface.h"

void initialize_gdexample_module(void *p_userdata, GDExtensionInitializationLevel p_level);
void deinitialize_gdexample_module(void *p_userdata, GDExtensionInitializationLevel p_level);
GDExtensionBool GDE_EXPORT gdexample_library_init(GDExtensionInterfaceGetProcAddress p_get_proc_address, GDExtensionClassLibraryPtr p_library, GDExtensionInitialization *r_initialization);</literal_block>
            <paragraph>The functions declared here have the signatures expected by the GDExtension API.</paragraph>
            <paragraph>Note the inclusion of the <literal>defs.h</literal> file. This is one of our helpers to
                simplify writing the extension code. For now it will only contain the definition
                of <literal>GDE_EXPORT</literal>, a macro that makes the function public in the shared library
                so Godot can properly call it. This macro helps abstracting what each compiler
                expects.</paragraph>
            <paragraph>Create the <literal>defs.h</literal> file in the <literal>src</literal> folder with the following contents:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">#pragma once

#include &lt;stdbool.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdint.h&gt;

#if !defined(GDE_EXPORT)
#if defined(_WIN32)
#define GDE_EXPORT __declspec(dllexport)
#elif defined(__GNUC__)
#define GDE_EXPORT __attribute__((visibility("default")))
#else
#define GDE_EXPORT
#endif
#endif // ! GDE_EXPORT</literal_block>
            <paragraph>We also include some standard headers to make things easier. Now we only have to
                include <literal>defs.h</literal> and those will come as a bonus.</paragraph>
            <paragraph>Now, let's implement the functions we just declared. Create a file called
                <literal>init.c</literal> in the <literal>src</literal> folder and add this code:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">#include "init.h"

void initialize_gdexample_module(void *p_userdata, GDExtensionInitializationLevel p_level)
{
}

void deinitialize_gdexample_module(void *p_userdata, GDExtensionInitializationLevel p_level)
{
}

GDExtensionBool GDE_EXPORT gdexample_library_init(GDExtensionInterfaceGetProcAddress p_get_proc_address, GDExtensionClassLibraryPtr p_library, GDExtensionInitialization *r_initialization)
{
    r_initialization-&gt;initialize = initialize_gdexample_module;
    r_initialization-&gt;deinitialize = deinitialize_gdexample_module;
    r_initialization-&gt;userdata = NULL;
    r_initialization-&gt;minimum_initialization_level = GDEXTENSION_INITIALIZATION_SCENE;

    return true;
}</literal_block>
            <paragraph>What this does is set up the initialization data that Godot expects. The
                functions to initialize and deinitialize are set so Godot will call then when
                needed. It also sets the initialization level which varies per extension. Since
                we plan to add a custom node, the <literal>SCENE</literal> level is enough.</paragraph>
            <paragraph>We will fill the <literal>initialize_gdexample_module()</literal> function later to register our custom class.</paragraph>
        </section>
        <section ids="a-basic-class" names="a\ basic\ class">
            <title>A basic class</title>
            <paragraph>In order to make an actual node, first we'll create a C struct to hold data and
                functions that will act as methods. The plan is to make this a custom node that
                inherits from <reference internal="True" refuri="../../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite2D</inline></reference>.</paragraph>
            <paragraph>Create a file called <literal>gdexample.h</literal> in the <literal>src</literal> folder with the following
                contents:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">#pragma once

#include "gdextension_interface.h"

#include "defs.h"

// Struct to hold the node data.
typedef struct
{
    // Metadata.
    GDExtensionObjectPtr object; // Stores the underlying Godot object.
} GDExample;

// Constructor for the node.
void gdexample_class_constructor(GDExample *self);

// Destructor for the node.
void gdexample_class_destructor(GDExample *self);

// Bindings.
void gdexample_class_bind_methods();</literal_block>
            <paragraph>Noteworthy here is the <literal>object</literal> field, which holds a pointer to
                the Godot object, and the <literal>gdexample_class_bind_methods()</literal> function, which will
                register the metadata of our custom class (properties, methods, and signals).
                The latter is not entirely necessary, as we can do it when registering the
                class, but it makes clearer to separate the concerns and let our class register
                its own metadata.</paragraph>
            <paragraph>The <literal>object</literal> field is necessary because our class will inherit a Godot class.
                Since we can't inherit it directly, as we are not interacting with the source
                code (and C doesn't even have classes), we instead tell Godot to create an
                object of a type it knows and attach our extension to it. We will need the
                reference to such objects when calling methods on the parent class, for
                instance.</paragraph>
            <paragraph>Let's create the source counterpart of this header. Create the file
                <literal>gdexample.c</literal> in the <literal>src</literal> folder and add the following code to it:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">#include "gdexample.h"

void gdexample_class_constructor(GDExample *self)
{
}

void gdexample_class_destructor(GDExample *self)
{
}

void gdexample_class_bind_methods()
{
}</literal_block>
            <paragraph>As we don't have anything to do with those functions yet, they'll stay empty
                for a while.</paragraph>
            <paragraph>The next step is registering our class. However, in order to do so we need to
                create a <reference internal="True" refuri="../../../classes/class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> and for that we have to get a
                function from the GDExtension API. Since we'll need this a few times and we'll
                also need other things, let's create a wrapper API to facilitate this kind of
                chore.</paragraph>
        </section>
        <section ids="a-wrapper-api" names="a\ wrapper\ api">
            <title>A wrapper API</title>
            <paragraph>We'll start by creating an <literal>api.h</literal> file in the <literal>src</literal> folder:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">#pragma once

/*
This file works as a collection of helpers to call the GDExtension API
in a less verbose way, as well as a cache for methods from the discovery API,
just so we don't have to keep loading the same methods again.
*/

#include "gdextension_interface.h"

#include "defs.h"

extern GDExtensionClassLibraryPtr class_library;

// API methods.

extern struct Constructors
{
    GDExtensionInterfaceStringNameNewWithLatin1Chars string_name_new_with_latin1_chars;
} constructors;

extern struct Destructors
{
    GDExtensionPtrDestructor string_name_destructor;
} destructors;

extern struct API
{
    GDExtensionInterfaceClassdbRegisterExtensionClass2 classdb_register_extension_class2;
} api;

void load_api(GDExtensionInterfaceGetProcAddress p_get_proc_address);</literal_block>
            <paragraph>This file will include many other helpers as we fill our extension with
                something useful. For now it only has a pointer to a function that creates a
                StringName from a C string (in Latin-1 encoding) and another to destruct a
                StringName, which we'll need to use to avoid leaking memory, as well as the
                function to register a class, which is our initial goal.</paragraph>
            <paragraph>We also keep a reference to the <literal>class_library</literal> here. This is something that
                Godot provides to us when initializing the extension and we'll need to use it
                when registering the things we create so Godot can tell which extension is
                making the call.</paragraph>
            <paragraph>There's also a function to load those function pointers from the GDExtension API.</paragraph>
            <paragraph>Let's work on the source counterpart of this header. Create the <literal>api.c</literal> file
                in the <literal>src</literal> folder, adding the following code:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">#include "api.h"

GDExtensionClassLibraryPtr class_library = NULL;

struct Constructors constructors;
struct Destructors destructors;
struct API api;

void load_api(GDExtensionInterfaceGetProcAddress p_get_proc_address)
{
    // Get helper functions first.
    GDExtensionInterfaceVariantGetPtrDestructor variant_get_ptr_destructor = (GDExtensionInterfaceVariantGetPtrDestructor)p_get_proc_address("variant_get_ptr_destructor");

    // API.
    api.classdb_register_extension_class2 = (GDExtensionInterfaceClassdbRegisterExtensionClass2)p_get_proc_address("classdb_register_extension_class2");

    // Constructors.
    constructors.string_name_new_with_latin1_chars = (GDExtensionInterfaceStringNameNewWithLatin1Chars)p_get_proc_address("string_name_new_with_latin1_chars");

    // Destructors.
    destructors.string_name_destructor = variant_get_ptr_destructor(GDEXTENSION_VARIANT_TYPE_STRING_NAME);
}</literal_block>
            <paragraph>The first important thing here is <literal>p_get_proc_address</literal>. This a function from
                the GDExtension API that is passed during initialization. You can use this
                function to request specific functions from the API by their name. Here we are
                caching the results so we don't have to keep a reference for
                <literal>p_get_proc_address</literal> everywhere and use our wrapper instead.</paragraph>
            <paragraph>At the start we request the <literal>variant_get_ptr_destructor()</literal> function. This is not
                going to be used outside of this function, so we don't add to our wrapper and
                only cache it locally. The cast is necessary to silence compiler warnings.</paragraph>
            <paragraph>Then we get the function that creates a StringName from a C string, exactly what
                we mentioned before as a needed function. We store that in our <literal>constructors</literal>
                struct.</paragraph>
            <paragraph>Next, we use the <literal>variant_get_ptr_destructor()</literal> function we just got to query
                for the destructor for StringName, using the enum value from
                <literal>gdextension_interface.h</literal> API as a parameter. We could get destructors for
                other types in a similar manner, but we'll limit ourselves to what is needed for
                the example.</paragraph>
            <paragraph>Lastly, we get the <literal>classdb_register_extension_class2()</literal> function, which we'll
                need in order to register our custom class.</paragraph>
            <note>
                <paragraph>You may wonder why the <literal>2</literal> is there in the function name. This means it's the
                    second version of this function. The old version is kept to ensure backwards
                    compatibility with older extensions, but since we have the second version
                    available, it's best to use the new one, because we don't intend to support older
                    Godot versions in this example.</paragraph>
                <paragraph>The <literal>gdextension_interface.h</literal> header documents in which Godot version each
                    function was introduced.</paragraph>
            </note>
            <paragraph>We also define the <literal>class_library</literal> variable here, which will be set during
                initialization.</paragraph>
            <paragraph>Speaking of initialization, now we have to change the <literal>init.c</literal> file in
                order to fill the things we just added:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">GDExtensionBool GDE_EXPORT gdexample_library_init(GDExtensionInterfaceGetProcAddress p_get_proc_address, GDExtensionClassLibraryPtr p_library, GDExtensionInitialization *r_initialization)
{
    class_library = p_library;
    load_api(p_get_proc_address);

    ...</literal_block>
            <paragraph>Here we set the <literal>class_library</literal> as needed and call our new <literal>load_api()</literal>
                function. Don't forget to also include the new headers at the top of this file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">#include "init.h"

#include "api.h"
#include "gdexample.h"
...</literal_block>
            <paragraph>Since we are here, we can register our new custom class. Let's fill the
                <literal>initialize_gdexample_module()</literal> function:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void initialize_gdexample_module(void *p_userdata, GDExtensionInitializationLevel p_level)
{
    if (p_level != GDEXTENSION_INITIALIZATION_SCENE)
    {
        return;
    }

    // Register class.
    StringName class_name;
    constructors.string_name_new_with_latin1_chars(&amp;class_name, "GDExample", false);
    StringName parent_class_name;
    constructors.string_name_new_with_latin1_chars(&amp;parent_class_name, "Sprite2D", false);

    GDExtensionClassCreationInfo2 class_info = {
        .is_virtual = false,
        .is_abstract = false,
        .is_exposed = true,
        .set_func = NULL,
        .get_func = NULL,
        .get_property_list_func = NULL,
        .free_property_list_func = NULL,
        .property_can_revert_func = NULL,
        .property_get_revert_func = NULL,
        .validate_property_func = NULL,
        .notification_func = NULL,
        .to_string_func = NULL,
        .reference_func = NULL,
        .unreference_func = NULL,
        .create_instance_func = gdexample_class_create_instance,
        .free_instance_func = gdexample_class_free_instance,
        .recreate_instance_func = NULL,
        .get_virtual_func = NULL,
        .get_virtual_call_data_func = NULL,
        .call_virtual_with_data_func = NULL,
        .get_rid_func = NULL,
        .class_userdata = NULL,
    };

    api.classdb_register_extension_class2(class_library, &amp;class_name, &amp;parent_class_name, &amp;class_info);

    // Bind methods.
    gdexample_class_bind_methods();

    // Destruct things.
    destructors.string_name_destructor(&amp;class_name);
    destructors.string_name_destructor(&amp;parent_class_name);
}</literal_block>
            <paragraph>The struct with the class information is the biggest thing here. None of its
                fields are required with the exception of <literal>create_instance_func</literal> and
                <literal>free_instance_func</literal>. We haven't made those functions yet, so we'll have
                to work on them soon. Note that we skip the initialization if it isn't at the
                <literal>SCENE</literal> level. This function may be called multiple times, once for each
                level, but we only want to register our class once.</paragraph>
            <paragraph>The other undefined thing here is <literal>StringName</literal>. This will be an opaque struct
                meant to hold the data of a Godot StringName in our extension. We'll define it
                in the appropriately named <literal>defs.h</literal> file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">...
// The sizes can be obtained from the extension_api.json file.
#ifdef BUILD_32
#define STRING_NAME_SIZE 4
#else
#define STRING_NAME_SIZE 8
#endif

// Types.

typedef struct
{
    uint8_t data[STRING_NAME_SIZE];
} StringName;</literal_block>
            <paragraph>As mentioned in the comment, the sizes can be found in the
                <literal>extension_api.json</literal> file that we generated earlier, under the
                <literal>builtin_class_sizes</literal> property. The <literal>BUILD_32</literal> is never defined, as we
                assume we are working with a 64-bits build of Godot here, but if you need it you
                can add <literal>env.Append(CPPDEFINES=["BUILD_32"])</literal> to your <literal>SConstruct</literal> file.</paragraph>
            <paragraph>The <literal>// Types.</literal> comment foreshadows that we'll be adding more types to this
                file. Let's leave that for later.</paragraph>
            <paragraph>The <literal>StringName</literal> struct here is just to hold Godot data, so we don't really
                care what is inside of it. Though, in this case, it is just a pointer to the
                data in the heap. We'll use this struct when we need to allocate data for a
                StringName ourselves, like we are doing when registering our class.</paragraph>
            <paragraph>Back to registering, we need to work on our create and free functions. Let's
                include them in <literal>gdexample.h</literal> since they're specific to the custom class:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">...
// Bindings.
void gdexample_class_bind_methods();
GDExtensionObjectPtr gdexample_class_create_instance(void *p_class_userdata);
void gdexample_class_free_instance(void *p_class_userdata, GDExtensionClassInstancePtr p_instance);
...</literal_block>
            <paragraph>Before we can implement those function, we'll need a few more things in our API.
                We need a way to allocate and free memory. While we could do this with good ol'
                <literal>malloc()</literal>, we can instead make use of Godot's memory management functions.
                We'll also need a way to create a Godot object and set it with our custom
                instance.</paragraph>
            <paragraph>So let's change the <literal>api.h</literal> to include these new functions:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">...
extern struct API
{
    GDExtensionInterfaceClassdbRegisterExtensionClass2 classdb_register_extension_class2;
    GDExtensionInterfaceClassdbConstructObject classdb_construct_object;
    GDExtensionInterfaceObjectSetInstance object_set_instance;
    GDExtensionInterfaceObjectSetInstanceBinding object_set_instance_binding;
    GDExtensionInterfaceMemAlloc mem_alloc;
    GDExtensionInterfaceMemFree mem_free;
} api;</literal_block>
            <paragraph>Then we change the <literal>load_api()</literal> function in <literal>api.c</literal> to grab these new functions:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">...
void load_api(GDExtensionInterfaceGetProcAddress p_get_proc_address)
{
    ...
    // API.
    api.classdb_register_extension_class2 = p_get_proc_address("classdb_register_extension_class2");
    api.classdb_construct_object = (GDExtensionInterfaceClassdbConstructObject)p_get_proc_address("classdb_construct_object");
    api.object_set_instance = (GDExtensionInterfaceObjectSetInstance)p_get_proc_address("object_set_instance");
    api.object_set_instance_binding = (GDExtensionInterfaceObjectSetInstanceBinding)p_get_proc_address("object_set_instance_binding");
    api.mem_alloc = (GDExtensionInterfaceMemAlloc)p_get_proc_address("mem_alloc");
    api.mem_free = (GDExtensionInterfaceMemFree)p_get_proc_address("mem_free");
}</literal_block>
            <paragraph>Now we can go back to <literal>gdexample.c</literal> and define the new functions, without forgetting to
                include the <literal>api.h</literal> header:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">#include "gdexample.h"

#include "api.h"

...

const GDExtensionInstanceBindingCallbacks gdexample_class_binding_callbacks = {
    .create_callback = NULL,
    .free_callback = NULL,
    .reference_callback = NULL,
};

GDExtensionObjectPtr gdexample_class_create_instance(void *p_class_userdata)
{
    // Create native Godot object;
    StringName class_name;
    constructors.string_name_new_with_latin1_chars(&amp;class_name, "Sprite2D", false);
    GDExtensionObjectPtr object = api.classdb_construct_object(&amp;class_name);
    destructors.string_name_destructor(&amp;class_name);

    // Create extension object.
    GDExample *self = (GDExample *)api.mem_alloc(sizeof(GDExample));
    gdexample_class_constructor(self);
    self-&gt;object = object;

    // Set the extension instance in the native Godot object.
    constructors.string_name_new_with_latin1_chars(&amp;class_name, "GDExample", false);
    api.object_set_instance(object, &amp;class_name, self);
    api.object_set_instance_binding(object, class_library, self, &amp;gdexample_class_binding_callbacks);
    destructors.string_name_destructor(&amp;class_name);

    return object;
}

void gdexample_class_free_instance(void *p_class_userdata, GDExtensionClassInstancePtr p_instance)
{
    if (p_instance == NULL)
    {
        return;
    }
    GDExample *self = (GDExample *)p_instance;
    gdexample_class_destructor(self);
    api.mem_free(self);
}</literal_block>
            <paragraph>When instantiating an object, first we create a new Sprite2D object, since
                that's the parent of our class. Then we allocate memory for our custom struct
                and call its constructor. We save the pointer to the Godot object in the struct
                as well like we mentioned earlier.</paragraph>
            <paragraph>Then we set our custom struct as the instance data. This will make Godot know
                that the object is an instance of our custom class and properly call our custom
                methods for instance, as well as passing this data back.</paragraph>
            <paragraph>Note that we return the Godot object we created, not our custom struct.</paragraph>
            <paragraph>For the <literal>gdextension_free_instance()</literal> function, we only call the destructor and free the memory we
                allocated for the custom data. It is not necessary to destruct the Godot object
                since that will be taken care of by the engine itself.</paragraph>
        </section>
        <section ids="a-demo-project" names="a\ demo\ project">
            <title>A demo project</title>
            <paragraph>Now that we can create and free our custom object, we should be able to try it
                out in an actual project. For this, you need to open Godot and create a new
                project on the <literal>demo</literal> folder. The project manager may warn you the folder
                isn't empty if you have compiled the extension before, you can safely ignore
                this warning this time.</paragraph>
            <paragraph>If you didn't compile the extension yet, it is the time to do it now. To do
                that, open a terminal or command prompt, navigate to the root folder of the
                extension and run <literal>scons</literal>. It should compile quickly since the extension is
                very simple.</paragraph>
            <paragraph>Then, create a file called <literal>gdexample.gdextension</literal> inside the <literal>demo</literal> folder.
                This is a Godot resource that describes the extension, allowing the engine to
                properly load it. Put the following content in this file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">[configuration]

entry_symbol = "gdexample_library_init"
compatibility_minimum = "4.2"

[libraries]
macos.debug = "res://bin/libgdexample.dylib"
linux.debug = "res://bin/libgdexample.so"
windows.debug = "res://bin/libgdexample.dll"</literal_block>
            <paragraph>As you can see, <literal>gdexample_library_init()</literal> is the same name of the function we
                defined in our <literal>init.c</literal> file. It is important that the names match because it
                is how Godot calls the entry point of the extension.</paragraph>
            <paragraph>We also set the compatibility minimum to 4.2, since we are targeting this
                version. It should still work on later versions. If you are using a later Godot
                version and rely on the new features, you need to increase this value to a
                version number that has everything you use.
                See <reference internal="True" refuri="../cpp/about_godot_cpp#doc-what-is-gdextension-version-compatibility"><inline classes="std std-ref">Version compatibility</inline></reference> for more information.</paragraph>
            <paragraph>In the <literal>[libraries]</literal> section we set up the paths to the shared library on
                different platforms. Here there's only the debug versions since that's what we
                are working on for the example. Using <reference internal="True" refuri="../../export/feature_tags#doc-feature-tags"><inline classes="std std-ref">feature tags</inline></reference> you
                can fine tune this to also provide release versions, add more target operating systems, as
                well as providing 32-bit and 64-bit binaries.</paragraph>
            <paragraph>You can also add library dependencies and custom icons for your classes in this
                file, but this is out of the scope for this tutorial.</paragraph>
            <paragraph>After saving the file, go back to the editor. Godot should automatically load
                the extension. Nothing will be seen because our extension only registers a new
                class. To use this class add a <literal>Node2D</literal> as a root of the scene. Move it to
                the middle of viewport for better visibility. Then add a new child node to the
                root and in the <strong>Create New Node</strong> dialog search for "GDExample", the name of
                our class, as it should be listed there. If it isn't, it means that Godot didn't
                load the extension properly, so try restarting the editor and retrace the steps
                to see if anything went missing.</paragraph>
            <paragraph>Our custom class is derived from <literal>Sprite2D</literal>, so it has a <strong>Texture</strong> property
                in the Inspector. Set this to the <literal>icon.svg</literal> file that Godot handily created
                for us when making the project. Save this scene as <literal>main.tscn</literal> and run it. You
                may want to set it as the main scene for convenience.</paragraph>
            <image candidates="{'*': 'tutorials/scripting/gdextension/img/gdextension_c_running.webp'}" original_uri="img/gdextension_c_running.webp" uri="tutorials/scripting/gdextension/img/gdextension_c_running.webp"></image>
            <paragraph>Voil√†! We have a custom node running in Godot. However, it does not do anything
                and has nothing different than a regular <literal>Sprite2D</literal> node. We will fix that next by
                adding custom methods and properties.</paragraph>
        </section>
        <section ids="custom-methods" names="custom\ methods">
            <title>Custom methods</title>
            <paragraph>A common thing in extensions is creating methods for the custom classes and
                exposing those to the Godot API. We are going to create a couple of getters and
                setters which are need for binding the properties afterwards.</paragraph>
            <paragraph>First, let's add the new fields in our struct to hold the values for
                <literal>amplitude</literal> and <literal>speed</literal>, which we will use later on when creating the
                behavior for the node. Add them to the <literal>gdexample.h</literal> file, changing the
                <literal>GDExample</literal> struct:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">...

typedef struct
{
    // Public properties.
    double amplitude;
    double speed;
    // Metadata.
    GDExtensionObjectPtr object; // Stores the underlying Godot object.
} GDExample;

...</literal_block>
            <paragraph>In the same file, add the declaration for the getters and setters, right after
                the destructor.</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">...

// Destructor for the node.
void gdexample_class_destructor(GDExample *self);

// Properties.
void gdexample_class_set_amplitude(GDExample *self, double amplitude);
double gdexample_class_get_amplitude(const GDExample *self);
void gdexample_class_set_speed(GDExample *self, double speed);
double gdexample_class_get_speed(const GDExample *self);

...</literal_block>
            <paragraph>In the <literal>gdexample.c</literal> file, we will initialize these values in the constructor
                and add the implementations for those new functions, which are quite trivial:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void gdexample_class_constructor(GDExample *self)
{
    self-&gt;amplitude = 10.0;
    self-&gt;speed = 1.0;
}

void gdexample_class_set_amplitude(GDExample *self, double amplitude)
{
    self-&gt;amplitude = amplitude;
}

double gdexample_class_get_amplitude(const GDExample *self)
{
    return self-&gt;amplitude;
}

void gdexample_class_set_speed(GDExample *self, double speed)
{
    self-&gt;speed = speed;
}

double gdexample_class_get_speed(const GDExample *self)
{
    return self-&gt;speed;
}</literal_block>
            <paragraph>To make those simple functions work when called by Godot, we will need some
                wrappers to help us properly convert the data to and from the engine.</paragraph>
            <paragraph>First, we will create wrappers for <literal>ptrcall</literal>. This is what Godot uses when the
                types of the values are known to be exact, which avoids using Variant. We're
                gonna need two of those: one for the functions that take no arguments and
                return a <literal>double</literal> (for the getters) and another for the functions that take a
                single <literal>double</literal> argument and return nothing (for the setters).</paragraph>
            <paragraph>Add the declarations to the <literal>api.h</literal> file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void ptrcall_0_args_ret_float(void *method_userdata, GDExtensionClassInstancePtr p_instance, const GDExtensionConstTypePtr *p_args, GDExtensionTypePtr r_ret);
void ptrcall_1_float_arg_no_ret(void *method_userdata, GDExtensionClassInstancePtr p_instance, const GDExtensionConstTypePtr *p_args, GDExtensionTypePtr r_ret);</literal_block>
            <paragraph>Those two functions follow the <literal>GDExtensionClassMethodPtrCall</literal> type, as
                defined in the <literal>gdextension_interface.h</literal>. We use <literal>float</literal> as a name here
                because in Godot the <literal>float</literal> type has double precision, so we keep this
                convention.</paragraph>
            <paragraph>Then we implement those functions in the <literal>api.c</literal> file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void ptrcall_0_args_ret_float(void *method_userdata, GDExtensionClassInstancePtr p_instance, const GDExtensionConstTypePtr *p_args, GDExtensionTypePtr r_ret)
{
    // Call the function.
    double (*function)(void *) = method_userdata;
    *((double *)r_ret) = function(p_instance);
}

void ptrcall_1_float_arg_no_ret(void *method_userdata, GDExtensionClassInstancePtr p_instance, const GDExtensionConstTypePtr *p_args, GDExtensionTypePtr r_ret)
{
    // Call the function.
    void (*function)(void *, double) = method_userdata;
    function(p_instance, *((double *)p_args[0]));
}</literal_block>
            <paragraph>The <literal>method_userdata</literal> argument is a custom value that we give to Godot, in
                this case we will set as the function pointer for the one we want to call. So
                first we convert it to the function type, then we just call it by passing the
                arguments when needed, or setting the return value.</paragraph>
            <paragraph>The <literal>p_instance</literal> argument contains the custom instance of our class, which we
                gave with <literal>object_set_instance()</literal> when creating the object.</paragraph>
            <paragraph><literal>p_args</literal> is an array of arguments. Note this contains <strong>pointers</strong> to the
                values. That's why we dereference it when passing to our functions. The number
                of arguments will be declared when binding the function (which we will do soon)
                and it will always include default ones if those exist.</paragraph>
            <paragraph>Finally, the <literal>r_ret</literal> is a pointer to the variable where the return value needs to
                be set. Like the arguments, it will be the correct type as declared. For the
                function that does not return, we have to avoid setting it.</paragraph>
            <paragraph>Note how the type and argument counts are exact, so if we needed different
                types, for example, we would have to create more wrappers. This could be
                automated using some code generation, but this is out of the scope for this
                tutorial.</paragraph>
            <paragraph>While the <literal>ptrcall</literal> functions are used when types are exact, sometimes Godot cannot know
                if that's the case (when the call comes from a dynamically typed language, such
                as GDScript). In those situations it uses regular <literal>call</literal> functions, so we need to
                provide those as well when binding.</paragraph>
            <paragraph>Let's create two new wrappers in the <literal>api.h</literal> file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void call_0_args_ret_float(void *method_userdata, GDExtensionClassInstancePtr p_instance, const GDExtensionConstVariantPtr *p_args, GDExtensionInt p_argument_count, GDExtensionVariantPtr r_return, GDExtensionCallError *r_error);
void call_1_float_arg_no_ret(void *method_userdata, GDExtensionClassInstancePtr p_instance, const GDExtensionConstVariantPtr *p_args, GDExtensionInt p_argument_count, GDExtensionVariantPtr r_return, GDExtensionCallError *r_error);</literal_block>
            <paragraph>These follow the <literal>GDExtensionClassMethodCall</literal> type, which is a bit different.
                First, you receive pointers to Variants instead of exact types. There's also the
                amount of arguments and an error struct that you can set if something goes
                wrong.</paragraph>
            <paragraph>In order to check the type and also extract interact with Variant, we will need
                a few more functions from the GDExtension API. So let's expand our wrapper
                structs:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">extern struct Constructors {
    ...
    GDExtensionVariantFromTypeConstructorFunc variant_from_float_constructor;
    GDExtensionTypeFromVariantConstructorFunc float_from_variant_constructor;
} constructors;

extern struct API
{
    ...
    GDExtensionInterfaceGetVariantFromTypeConstructor get_variant_from_type_constructor;
    GDExtensionInterfaceGetVariantToTypeConstructor get_variant_to_type_constructor;
    GDExtensionInterfaceVariantGetType variant_get_type;
} api;</literal_block>
            <paragraph>The names say all about what those do. We have a couple of constructors to
                create and extract a floating point value to and from a Variant. We also have a
                couple of helpers to actually get those constructors, as well as a function to
                find out the type of a Variant.</paragraph>
            <paragraph>Let's get those from the API, like we did before, by changing the <literal>load_api()</literal>
                function in the <literal>api.c</literal> file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void load_api(GDExtensionInterfaceGetProcAddress p_get_proc_address)
{
    ...

    // API.
    ...
    api.get_variant_from_type_constructor = (GDExtensionInterfaceGetVariantFromTypeConstructor)p_get_proc_address("get_variant_from_type_constructor");
    api.get_variant_to_type_constructor = (GDExtensionInterfaceGetVariantToTypeConstructor)p_get_proc_address("get_variant_to_type_constructor");
    api.variant_get_type = (GDExtensionInterfaceVariantGetType)p_get_proc_address("variant_get_type");
    ...

    // Constructors.
    ...
    constructors.variant_from_float_constructor = api.get_variant_from_type_constructor(GDEXTENSION_VARIANT_TYPE_FLOAT);
    constructors.float_from_variant_constructor = api.get_variant_to_type_constructor(GDEXTENSION_VARIANT_TYPE_FLOAT);
    ...
}</literal_block>
            <paragraph>Now that we have these set, we can implement our call wrappers in the same file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void call_0_args_ret_float(void *method_userdata, GDExtensionClassInstancePtr p_instance, const GDExtensionConstVariantPtr *p_args, GDExtensionInt p_argument_count, GDExtensionVariantPtr r_return, GDExtensionCallError *r_error)
{
    // Check argument count.
    if (p_argument_count != 0)
    {
        r_error-&gt;error = GDEXTENSION_CALL_ERROR_TOO_MANY_ARGUMENTS;
        r_error-&gt;expected = 0;
        return;
    }

    // Call the function.
    double (*function)(void *) = method_userdata;
    double result = function(p_instance);
    // Set resulting Variant.
    constructors.variant_from_float_constructor(r_return, &amp;result);
}

void call_1_float_arg_no_ret(void *method_userdata, GDExtensionClassInstancePtr p_instance, const GDExtensionConstVariantPtr *p_args, GDExtensionInt p_argument_count, GDExtensionVariantPtr r_return, GDExtensionCallError *r_error)
{
    // Check argument count.
    if (p_argument_count &lt; 1)
    {
        r_error-&gt;error = GDEXTENSION_CALL_ERROR_TOO_FEW_ARGUMENTS;
        r_error-&gt;expected = 1;
        return;
    }
    else if (p_argument_count &gt; 1)
    {
        r_error-&gt;error = GDEXTENSION_CALL_ERROR_TOO_MANY_ARGUMENTS;
        r_error-&gt;expected = 1;
        return;
    }

    // Check the argument type.
    GDExtensionVariantType type = api.variant_get_type(p_args[0]);
    if (type != GDEXTENSION_VARIANT_TYPE_FLOAT)
    {
        r_error-&gt;error = GDEXTENSION_CALL_ERROR_INVALID_ARGUMENT;
        r_error-&gt;expected = GDEXTENSION_VARIANT_TYPE_FLOAT;
        r_error-&gt;argument = 0;
        return;
    }

    // Extract the argument.
    double arg1;
    constructors.float_from_variant_constructor(&amp;arg1, (GDExtensionVariantPtr)p_args[0]);

    // Call the function.
    void (*function)(void *, double) = method_userdata;
    function(p_instance, arg1);
}</literal_block>
            <paragraph>These functions are a bit longer but easy to follow. First they check if the
                argument count is as expected and if not they set the error struct and
                return. For the one that has one parameter, it also checks if the argument type
                is correct. This is important because mismatched types when extracting from
                Variant can cause crashes.</paragraph>
            <paragraph>Then it proceeds to extract the argument using the constructor we setup before.
                The one with no arguments instead sets the return value after calling the
                function. Note how they use a pointer to a <literal>double</literal> variable, since this is
                what those constructors expect.</paragraph>
            <paragraph>Before we can actually bind our methods, we need a way to create
                <literal>GDExtensionPropertyInfo</literal> instances. While we could do them inside the binding
                functions that we'll implement afterwards, it's easier to have a helper for it
                since we'll need it multiple times, including for when we bind properties.</paragraph>
            <paragraph>Let's create these two functions in the <literal>api.h</literal> file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">// Create a PropertyInfo struct.
GDExtensionPropertyInfo make_property(
    GDExtensionVariantType type,
    const char *name);

GDExtensionPropertyInfo make_property_full(
    GDExtensionVariantType type,
    const char *name,
    uint32_t hint,
    const char *hint_string,
    const char *class_name,
    uint32_t usage_flags);

void destruct_property(GDExtensionPropertyInfo *info);</literal_block>
            <paragraph>The first one is a simplified version of the second since we usually don't need
                all the arguments for the property and are okay with the defaults. Then we also
                have a function to destruct the PropertyInfo since we need to create Strings and
                StringNames that need to be properly disposed of.</paragraph>
            <paragraph>Speaking of which, we also need a way to create and destruct Strings, so we'll
                make an addition to existing structs in this same file. We'll also get a new API
                function for actually binding our custom method.</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">extern struct Constructors
{
    ...
    GDExtensionInterfaceStringNewWithUtf8Chars string_new_with_utf8_chars;
} constructors;

extern struct Destructors
{
    ...
    GDExtensionPtrDestructor string_destructor;
} destructors;

extern struct API
{
    ...
    GDExtensionInterfaceClassdbRegisterExtensionClassMethod classdb_register_extension_class_method;
} api;</literal_block>
            <paragraph>Before implementing those, let's do a quick stop in the <literal>defs.h</literal> file and
                include the size of the <literal>String</literal> type and a couple of enums:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">// The sizes can be obtained from the extension_api.json file.
#ifdef BUILD_32
#define STRING_SIZE 4
#define STRING_NAME_SIZE 4
#else
#define STRING_SIZE 8
#define STRING_NAME_SIZE 8
#endif

...

typedef struct
{
    uint8_t data[STRING_SIZE];
} String;

// Enums.

typedef enum
{
    PROPERTY_HINT_NONE = 0,
} PropertyHint;

typedef enum
{
    PROPERTY_USAGE_NONE = 0,
    PROPERTY_USAGE_STORAGE = 2,
    PROPERTY_USAGE_EDITOR = 4,
    PROPERTY_USAGE_DEFAULT = PROPERTY_USAGE_STORAGE | PROPERTY_USAGE_EDITOR,
} PropertyUsageFlags;</literal_block>
            <paragraph>While it's the same size as <literal>StringName</literal>, it is more clear to use a different
                name for it.</paragraph>
            <paragraph>The enums here are just helpers to give names to the numbers they represent. The
                information about them is present in the <literal>extension_api.json</literal> file. Here we
                just set up the ones we need for the tutorial, to keep it more concise.</paragraph>
            <paragraph>Going now to the <literal>api.c</literal>, we need to load the pointers to the new functions we
                added to the API.</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void load_api(GDExtensionInterfaceGetProcAddress p_get_proc_address)
{
    ...
    // API
    ...
    api.classdb_register_extension_class_method = (GDExtensionInterfaceClassdbRegisterExtensionClassMethod)p_get_proc_address("classdb_register_extension_class_method");

    // Constructors.
    ...
    constructors.string_new_with_utf8_chars = (GDExtensionInterfaceStringNewWithUtf8Chars)p_get_proc_address("string_new_with_utf8_chars");

    // Destructors.
    ...
    destructors.string_destructor = variant_get_ptr_destructor(GDEXTENSION_VARIANT_TYPE_STRING);
}</literal_block>
            <paragraph>Then we can also implement the functions to create the <literal>PropertyInfo</literal> struct.</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">GDExtensionPropertyInfo make_property(
    GDExtensionVariantType type,
    const char *name)
{

    return make_property_full(type, name, PROPERTY_HINT_NONE, "", "", PROPERTY_USAGE_DEFAULT);
}

GDExtensionPropertyInfo make_property_full(
    GDExtensionVariantType type,
    const char *name,
    uint32_t hint,
    const char *hint_string,
    const char *class_name,
    uint32_t usage_flags)
{

    StringName *prop_name = api.mem_alloc(sizeof(StringName));
    constructors.string_name_new_with_latin1_chars(prop_name, name, false);
    String *prop_hint_string = api.mem_alloc(sizeof(String));
    constructors.string_new_with_utf8_chars(prop_hint_string, hint_string);
    StringName *prop_class_name = api.mem_alloc(sizeof(StringName));
    constructors.string_name_new_with_latin1_chars(prop_class_name, class_name, false);

    GDExtensionPropertyInfo info = {
        .name = prop_name,
        .type = type,
        .hint = hint,
        .hint_string = prop_hint_string,
        .class_name = prop_class_name,
        .usage = usage_flags,
    };

    return info;
}

void destruct_property(GDExtensionPropertyInfo *info)
{
    destructors.string_name_destructor(info-&gt;name);
    destructors.string_destructor(info-&gt;hint_string);
    destructors.string_name_destructor(info-&gt;class_name);
    api.mem_free(info-&gt;name);
    api.mem_free(info-&gt;hint_string);
    api.mem_free(info-&gt;class_name);
}</literal_block>
            <paragraph>The simple version of <literal>make_property()</literal> just calls the more complete one with a
                some default arguments. What those values mean exactly is out of the scope of
                this tutorial, check the page about the <reference internal="True" refuri="../../../engine_details/architecture/object_class#doc-object-class"><inline classes="std std-ref">Object class</inline></reference>
                for more details about binding methods and properties.</paragraph>
            <paragraph>The complete version is more involved. First, it creates <literal>String</literal>'s and
                <literal>StringName</literal>'s for the needed fields, by allocating memory and calling their
                constructors. Then it creates a <literal>GDExtensionPropertyInfo</literal> struct and sets all
                the fields with the arguments provided. Finally it returns this created struct.</paragraph>
            <paragraph>The <literal>destruct_property()</literal> function is straightforward, it simply calls the
                destructors for the created objects and frees their allocated memory.</paragraph>
            <paragraph>Let's go back again to the header <literal>api.h</literal> to create the functions that will
                actually bind the methods:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">// Version for 0 arguments, with return.
void bind_method_0_r(
    const char *class_name,
    const char *method_name,
    void *function,
    GDExtensionVariantType return_type);

// Version for 1 argument, no return.
void bind_method_1(
    const char *class_name,
    const char *method_name,
    void *function,
    const char *arg1_name,
    GDExtensionVariantType arg1_type);</literal_block>
            <paragraph>Then switch back to the <literal>api.c</literal> file to implement these:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">// Version for 0 arguments, with return.
void bind_method_0_r(
    const char *class_name,
    const char *method_name,
    void *function,
    GDExtensionVariantType return_type)
{
    StringName method_name_string;
    constructors.string_name_new_with_latin1_chars(&amp;method_name_string, method_name, false);

    GDExtensionClassMethodCall call_func = call_0_args_ret_float;
    GDExtensionClassMethodPtrCall ptrcall_func = ptrcall_0_args_ret_float;

    GDExtensionPropertyInfo return_info = make_property(return_type, "");

    GDExtensionClassMethodInfo method_info = {
        .name = &amp;method_name_string,
        .method_userdata = function,
        .call_func = call_func,
        .ptrcall_func = ptrcall_func,
        .method_flags = GDEXTENSION_METHOD_FLAGS_DEFAULT,
        .has_return_value = true,
        .return_value_info = &amp;return_info,
        .return_value_metadata = GDEXTENSION_METHOD_ARGUMENT_METADATA_NONE,
        .argument_count = 0,
    };

    StringName class_name_string;
    constructors.string_name_new_with_latin1_chars(&amp;class_name_string, class_name, false);

    api.classdb_register_extension_class_method(class_library, &amp;class_name_string, &amp;method_info);

    // Destruct things.
    destructors.string_name_destructor(&amp;method_name_string);
    destructors.string_name_destructor(&amp;class_name_string);
    destruct_property(&amp;return_info);
}

// Version for 1 argument, no return.
void bind_method_1(
    const char *class_name,
    const char *method_name,
    void *function,
    const char *arg1_name,
    GDExtensionVariantType arg1_type)
{

    StringName method_name_string;
    constructors.string_name_new_with_latin1_chars(&amp;method_name_string, method_name, false);

    GDExtensionClassMethodCall call_func = call_1_float_arg_no_ret;
    GDExtensionClassMethodPtrCall ptrcall_func = ptrcall_1_float_arg_no_ret;

    GDExtensionPropertyInfo args_info[] = {
        make_property(arg1_type, arg1_name),
    };
    GDExtensionClassMethodArgumentMetadata args_metadata[] = {
        GDEXTENSION_METHOD_ARGUMENT_METADATA_NONE,
    };

    GDExtensionClassMethodInfo method_info = {
        .name = &amp;method_name_string,
        .method_userdata = function,
        .call_func = call_func,
        .ptrcall_func = ptrcall_func,
        .method_flags = GDEXTENSION_METHOD_FLAGS_DEFAULT,
        .has_return_value = false,
        .argument_count = 1,
        .arguments_info = args_info,
        .arguments_metadata = args_metadata,
    };

    StringName class_name_string;
    constructors.string_name_new_with_latin1_chars(&amp;class_name_string, class_name, false);

    api.classdb_register_extension_class_method(class_library, &amp;class_name_string, &amp;method_info);

    // Destruct things.
    destructors.string_name_destructor(&amp;method_name_string);
    destructors.string_name_destructor(&amp;class_name_string);
    destruct_property(&amp;args_info[0]);
}</literal_block>
            <paragraph>Both functions are very similar. First, they create a <literal>StringName</literal> with the
                method name. This is created in the stack since we don't need to keep it after
                the function ends. Then they create local variables to hold the <literal>call_func</literal>
                and <literal>ptrcall_func</literal>, pointing to the helper functions we defined earlier.</paragraph>
            <paragraph>In the next step they diverge a bit. The first one creates a property for the
                return value, which has an empty name since it's not needed. The other creates
                an array of properties for the arguments, which in this case has a single
                element. This one also has an array of metadata, which can be used if there's
                something special about the argument (e.g. if an <literal>int</literal> value is 32 bits long
                instead of the default of 64 bits).</paragraph>
            <paragraph>Afterwards, they create the <literal>GDExtensionClassMethodInfo</literal> with the required
                fields for each case. Then they make a <literal>StringName</literal> for the class name, in
                order to associate the method with the class. Next, they call the API function
                to actually bind this method to the class. Finally, we destruct the objects we
                created since they aren't needed anymore.</paragraph>
            <note>
                <paragraph>The bind helpers here use the call helpers we created earlier, so do note that
                    those call helpers only accept the Godot <literal>FLOAT</literal> type (which is equivalent to
                    <literal>double</literal> in C). If you intend to use this for other types, you would need to
                    check the type of the arguments and return type and select an appropriate
                    function callback. This is avoided here only to keep the example from becoming
                    even longer.</paragraph>
            </note>
            <paragraph>Now that we have the means to bind methods, we can actually do so in our custom
                class. Go to the <literal>gdexample.c</literal> file and fill up the
                <literal>gdexample_class_bind_methods()</literal> function:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void gdexample_class_bind_methods()
{
    bind_method_0_r("GDExample", "get_amplitude", gdexample_class_get_amplitude, GDEXTENSION_VARIANT_TYPE_FLOAT);
    bind_method_1("GDExample", "set_amplitude", gdexample_class_set_amplitude, "amplitude", GDEXTENSION_VARIANT_TYPE_FLOAT);

    bind_method_0_r("GDExample", "get_speed", gdexample_class_get_speed, GDEXTENSION_VARIANT_TYPE_FLOAT);
    bind_method_1("GDExample", "set_speed", gdexample_class_set_speed, "speed", GDEXTENSION_VARIANT_TYPE_FLOAT);
}</literal_block>
            <paragraph>Since this function is already being called by the initialization process, we
                can stop here. This function is much more straightforward after we created all the
                infrastructure to make this work. You can see that implementing the binding
                functions inline here would take some space and also be quite repetitive. This
                also makes it easier to add another method in the future.</paragraph>
            <paragraph>If you compile the code and reopen the demo project, nothing will be different
                at first, since we only added two new methods. To ensure those are registered
                properly, you can search for <literal>GDExample</literal> in the editor help and verify they
                are present in the documentation page.</paragraph>
            <image candidates="{'*': 'tutorials/scripting/gdextension/img/gdextension_c_methods_doc.webp'}" original_uri="img/gdextension_c_methods_doc.webp" uri="tutorials/scripting/gdextension/img/gdextension_c_methods_doc.webp"></image>
        </section>
        <section ids="custom-properties" names="custom\ properties">
            <title>Custom properties</title>
            <paragraph>Since we now have the getter and setter for our properties already bound, we can
                move forward to create actual properties that will be displayed in the Godot
                editor inspector.</paragraph>
            <paragraph>Given our extensive setup in the previous section, there are only a few things
                needed to enable us to bind properties. First, let's get a new API function in
                the <literal>api.h</literal> file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">extern struct API {
    ...
    GDExtensionInterfaceClassdbRegisterExtensionClassProperty classdb_register_extension_class_property;
} api;</literal_block>
            <paragraph>Let's also declare a function here to bind properties:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void bind_property(
    const char *class_name,
    const char *name,
    GDExtensionVariantType type,
    const char *getter,
    const char *setter);</literal_block>
            <paragraph>In the <literal>api.c</literal> file, we can load the new API function:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void load_api(GDExtensionInterfaceGetProcAddress p_get_proc_address)
{
    // API
    ...
    api.classdb_register_extension_class_property = (GDExtensionInterfaceClassdbRegisterExtensionClassProperty)p_get_proc_address("classdb_register_extension_class_property");

    ...
}</literal_block>
            <paragraph>Then we can implement our new helper function in this same file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void bind_property(
    const char *class_name,
    const char *name,
    GDExtensionVariantType type,
    const char *getter,
    const char *setter)
{
    StringName class_string_name;
    constructors.string_name_new_with_latin1_chars(&amp;class_string_name, class_name, false);
    GDExtensionPropertyInfo info = make_property(type, name);
    StringName getter_name;
    constructors.string_name_new_with_latin1_chars(&amp;getter_name, getter, false);
    StringName setter_name;
    constructors.string_name_new_with_latin1_chars(&amp;setter_name, setter, false);

    api.classdb_register_extension_class_property(class_library, &amp;class_string_name, &amp;info, &amp;setter_name, &amp;getter_name);

    // Destruct things.
    destructors.string_name_destructor(&amp;class_string_name);
    destruct_property(&amp;info);
    destructors.string_name_destructor(&amp;getter_name);
    destructors.string_name_destructor(&amp;setter_name);
}</literal_block>
            <paragraph>This function is similar to the one for binding methods. The main difference is
                that we don't need an extra struct since we can simply use the
                <literal>GDExtensionPropertyInfo</literal> that is created by our helper function, so it's more
                straightforward. It only creates the <literal>StringName</literal> values from the
                C strings, creates a property info struct using our helper, calls the API
                function to register the property in the class and then destructs all the objects
                we created.</paragraph>
            <paragraph>With this done, we can extend the <literal>gdexample_class_bind_methods()</literal> function in the
                <literal>gdexample.c</literal> file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void gdexample_class_bind_methods()
{
    bind_method_0_r("GDExample", "get_amplitude", gdexample_class_get_amplitude, GDEXTENSION_VARIANT_TYPE_FLOAT);
    bind_method_1("GDExample", "set_amplitude", gdexample_class_set_amplitude, "amplitude", GDEXTENSION_VARIANT_TYPE_FLOAT);
    bind_property("GDExample", "amplitude", GDEXTENSION_VARIANT_TYPE_FLOAT, "get_amplitude", "set_amplitude");

    bind_method_0_r("GDExample", "get_speed", gdexample_class_get_speed, GDEXTENSION_VARIANT_TYPE_FLOAT);
    bind_method_1("GDExample", "set_speed", gdexample_class_set_speed, "speed", GDEXTENSION_VARIANT_TYPE_FLOAT);
    bind_property("GDExample", "speed", GDEXTENSION_VARIANT_TYPE_FLOAT, "get_speed", "set_speed");
}</literal_block>
            <paragraph>If you build the extension with <literal>scons</literal>, you'll see in the Godot editor the new property shown
                not only on the documentation page for the custom class but also in the Inspector dock when the
                <literal>GDExample</literal> node is selected.</paragraph>
            <image candidates="{'*': 'tutorials/scripting/gdextension/img/gdextension_c_inspector_properties.webp'}" original_uri="img/gdextension_c_inspector_properties.webp" uri="tutorials/scripting/gdextension/img/gdextension_c_inspector_properties.webp"></image>
        </section>
        <section ids="binding-virtual-methods" names="binding\ virtual\ methods">
            <title>Binding virtual methods</title>
            <paragraph>Our custom node now has properties to influence how it operates, but it still
                doesn't do anything. In this section, we will bind the virtual method
                <reference internal="True" refuri="../../../classes/class_node#class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference> and make our custom sprite
                move a little bit.</paragraph>
            <paragraph>In the <literal>gdexample.h</literal> file, let's add a function that represents the custom
                <literal>_process()</literal> method:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">// Methods.
void gdexample_class_process(GDExample *self, double delta);</literal_block>
            <paragraph>We'll also add a "private" field to keep track of the time passed in our custom
                struct. This is "private" only in the sense that it won't be bound to the Godot
                API, even though it is public in the C side, given the language lacks access
                modifiers.</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">typedef struct
{
    // Private properties.
    double time_passed;
    ...
} GDExample;</literal_block>
            <paragraph>On the counterpart source file <literal>gdexample.c</literal> we need to initialize the new
                field in the constructor:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void gdexample_class_constructor(GDExample *self)
{
    self-&gt;time_passed = 0.0;
    self-&gt;amplitude = 10.0;
    self-&gt;speed = 1.0;
}</literal_block>
            <paragraph>Then we can create the simplest implementation for the <literal>_process</literal> method:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void gdexample_class_process(GDExample *self, double delta)
{
    self-&gt;time_passed += self-&gt;speed * delta;
}</literal_block>
            <paragraph>For now it will do nothing but update the private field we created. We'll come
                back to this after the method is properly bound.</paragraph>
            <paragraph>Virtual methods are a bit different from the regular bindings. Instead of
                explicitly registering the method itself, we'll register a special function that
                Godot will call to ask if a particular virtual method is implemented in our
                extension. The engine will pass a <literal>StringName</literal> as an argument so, following
                the spirit of this tutorial, we'll create a helper function to check if it is
                equal to a C string.</paragraph>
            <paragraph>Let's add the declaration to the <literal>api.h</literal> file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">// Compare a StringName with a C string.
bool is_string_name_equal(GDExtensionConstStringNamePtr p_a, const char *p_b);</literal_block>
            <paragraph>We'll also add a new struct to this file, to hold function pointers for custom operators:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">extern struct Operators
{
    GDExtensionPtrOperatorEvaluator string_name_equal;
} operators;</literal_block>
            <paragraph>Then in the <literal>api.c</literal> file we'll load the function pointer from the API:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">struct Operators operators;

void load_api(GDExtensionInterfaceGetProcAddress p_get_proc_address)
{
    // Get helper functions first.
    ...
    GDExtensionInterfaceVariantGetPtrOperatorEvaluator variant_get_ptr_operator_evaluator = (GDExtensionInterfaceVariantGetPtrOperatorEvaluator)p_get_proc_address("variant_get_ptr_operator_evaluator");

    ...

    // Operators.
    operators.string_name_equal = variant_get_ptr_operator_evaluator(GDEXTENSION_VARIANT_OP_EQUAL, GDEXTENSION_VARIANT_TYPE_STRING_NAME, GDEXTENSION_VARIANT_TYPE_STRING_NAME);
}</literal_block>
            <paragraph>As you can see we need a new local helper here in order to grab the function
                pointer for the operator.</paragraph>
            <paragraph>With this handy, we can easily create our comparison function in the same file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">bool is_string_name_equal(GDExtensionConstStringNamePtr p_a, const char *p_b)
{
    // Create a StringName for the C string.
    StringName string_name;
    constructors.string_name_new_with_latin1_chars(&amp;string_name, p_b, false);

    // Compare both StringNames.
    bool is_equal = false;
    operators.string_name_equal(p_a, &amp;string_name, &amp;is_equal);

    // Destroy the created StringName.
    destructors.string_name_destructor(&amp;string_name);

    // Return the result.
    return is_equal;
}</literal_block>
            <paragraph>This function creates a <literal>StringName</literal> from the argument, compares with
                the other one using the operator function pointer, and returns the result. Note
                that the return value for the operator is passed as an out reference, this is a
                common thing in the API.</paragraph>
            <paragraph>Let's go back to the <literal>gdexample.h</literal> file and add a couple of functions that
                will be used as the callbacks for the Godot API:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void *gdexample_class_get_virtual_with_data(void *p_class_userdata, GDExtensionConstStringNamePtr p_name);
void gdexample_class_call_virtual_with_data(GDExtensionClassInstancePtr p_instance, GDExtensionConstStringNamePtr p_name, void *p_virtual_call_userdata, const GDExtensionConstTypePtr *p_args, GDExtensionTypePtr r_ret);</literal_block>
            <paragraph>There are actually two ways of registering virtual methods. Only one has the
                <literal>get</literal> part, in which you give Godot a properly crafted function pointer which
                will be called. For this we would need to create another helper for each virtual
                method, something that is not very convenient. Instead, we use the second method
                which allows us to return any data, and then Godot will call a second callback
                and give us back this data along with the call information. We can simply give
                our own function pointer as custom data and then have a single callback for all
                virtual methods. Although in this example we will only use it for one method,
                this way is simpler to expand.</paragraph>
            <paragraph>So let's implement those two functions in the <literal>gdexample.c</literal> file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void *gdexample_class_get_virtual_with_data(void *p_class_userdata, GDExtensionConstStringNamePtr p_name)
{
    // If it is the "_process" method, return a pointer to the gdexample_class_process function.
    if (is_string_name_equal(p_name, "_process"))
    {
        return (void *)gdexample_class_process;
    }
    // Otherwise, return NULL.
    return NULL;
}

void gdexample_class_call_virtual_with_data(GDExtensionClassInstancePtr p_instance, GDExtensionConstStringNamePtr p_name, void *p_virtual_call_userdata, const GDExtensionConstTypePtr *p_args, GDExtensionTypePtr r_ret)
{
    // If it is the "_process" method, call it with a helper.
    if (p_virtual_call_userdata == &amp;gdexample_class_process)
    {
        ptrcall_1_float_arg_no_ret(p_virtual_call_userdata, p_instance, p_args, r_ret);
    }
}</literal_block>
            <paragraph>Those functions are also quite straightforward after making all the helpers
                previously.</paragraph>
            <paragraph>For the first one, we simply check if the function name requested is
                <literal>_process</literal> and if it is we return a function pointer to our implementation of
                it. Otherwise we return <literal>NULL</literal>, signaling that the method is not being
                overridden. We don't use the <literal>p_class_userdata</literal> here since this function is
                meant only for one class and we don't have any data associated with it.</paragraph>
            <paragraph>The second one is similar. If it is the <literal>_process()</literal> method, it uses the given
                function pointer to call the <literal>ptrcall</literal> helper, passing the call arguments
                forward. Otherwise it simply does nothing, since we don't have any other virtual
                methods being implemented.</paragraph>
            <paragraph>The only thing missing is using those callbacks when the class is registered. Go
                to the <literal>init.c</literal> file and change the <literal>class_info</literal> initialization to include
                those, replacing the <literal>NULL</literal> value used previously:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void initialize_gdexample_module(void *p_userdata, GDExtensionInitializationLevel p_level)
{
    ...

    GDExtensionClassCreationInfo2 class_info = {
        ...
        .get_virtual_call_data_func = gdexample_class_get_virtual_with_data,
        .call_virtual_with_data_func = gdexample_class_call_virtual_with_data,
        ...
    };

    ...
}</literal_block>
            <paragraph>This is enough to bind the virtual method. If you build the extension and run
                the demo project again, the <literal>_process()</literal> function will be called. You just won't
                be able to tell since the function itself does nothing visible. We will solve
                this now by making the custom node move following a pattern.</paragraph>
            <paragraph>In order to make our node do stuff, we'll need to call Godot methods. Not only
                the GDExtension API functions as we've being doing so far, but actual engine
                methods, as we would do with scripting. This naturally requires some extra setup.</paragraph>
            <paragraph>First, let's add <reference internal="True" refuri="../../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> to our <literal>defs.h</literal> file, so we
                can use it in our method:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">// The sizes can be obtained from the extension_api.json file.
...
#ifdef REAL_T_IS_DOUBLE
#define VECTOR2_SIZE 16
#else
#define VECTOR2_SIZE 8
#endif

...

// Types.

...

typedef struct
{
    uint8_t data[VECTOR2_SIZE];
} Vector2;</literal_block>
            <paragraph>The <literal>REAL_T_IS_DOUBLE</literal> define is only needed if your Godot version was built
                with double precision support, which is not the default.</paragraph>
            <paragraph>Now, in the <literal>api.h</literal> file, we'll add few things to the API structs, including a
                new one for holding engine methods to call.</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">extern struct Constructors
{
    ...
    GDExtensionPtrConstructor vector2_constructor_x_y;
} constructors;

...

extern struct Methods
{
    GDExtensionMethodBindPtr node2d_set_position;
} methods;

extern struct API
{
    ...
    GDExtensionInterfaceClassdbGetMethodBind classdb_get_method_bind;
    GDExtensionInterfaceObjectMethodBindPtrcall object_method_bind_ptrcall;
} api;</literal_block>
            <paragraph>Then in the <literal>api.c</literal> file we can grab the function pointers from Godot:</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">struct Methods methods;

void load_api(GDExtensionInterfaceGetProcAddress p_get_proc_address)
{
    // Get helper functions first.
    ...
    GDExtensionInterfaceVariantGetPtrConstructor variant_get_ptr_constructor = (GDExtensionInterfaceVariantGetPtrConstructor)p_get_proc_address("variant_get_ptr_constructor");

    // API.
    ...
    api.classdb_get_method_bind = (GDExtensionInterfaceClassdbGetMethodBind)p_get_proc_address("classdb_get_method_bind");
    api.object_method_bind_ptrcall = (GDExtensionInterfaceObjectMethodBindPtrcall)p_get_proc_address("object_method_bind_ptrcall");

    // Constructors.
    ...
    constructors.vector2_constructor_x_y = variant_get_ptr_constructor(GDEXTENSION_VARIANT_TYPE_VECTOR2, 3); // See extension_api.json for indices.

    ...
}</literal_block>
            <paragraph>The only noteworthy part here is the <literal>Vector2</literal> constructor, for which we request the
                index <literal>3</literal>. Since there are multiple constructors with different kinds of
                arguments, we need to specify which one we want. In this case we're getting the
                one that takes two float numbers as the <literal>x</literal> and <literal>y</literal> coordinates, hence the
                name. This index can be retrieved from the <literal>extension_api.json</literal> file. Note we
                also need a new local helper to get it.</paragraph>
            <paragraph>Be aware that we don't get anything for the methods struct here. This is because
                this function is called too early in the initialization process, so classes
                won't be properly registered yet.</paragraph>
            <paragraph>Instead, we're gonna use the initialization level callback to grab those when we
                are registering our custom class. Add this to the <literal>init.c</literal> file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void initialize_gdexample_module(void *p_userdata, GDExtensionInitializationLevel p_level)
{
    if (p_level != GDEXTENSION_INITIALIZATION_SCENE)
    {
        return;
    }

    // Get ClassDB methods here because the classes we need are all properly registered now.
    // See extension_api.json for hashes.
    StringName native_class_name;
    StringName method_name;

    constructors.string_name_new_with_latin1_chars(&amp;native_class_name, "Node2D", false);
    constructors.string_name_new_with_latin1_chars(&amp;method_name, "set_position", false);
    methods.node2d_set_position = api.classdb_get_method_bind(&amp;native_class_name, &amp;method_name, 743155724);
    destructors.string_name_destructor(&amp;native_class_name);
    destructors.string_name_destructor(&amp;method_name);

    ...
}</literal_block>
            <paragraph>Here we create <literal>StringName</literal>'s for the class and method we want to get, then use
                the GDExtension API to retrieve their <literal>MethodBind</literal>, which is an object that
                represents the bound method. We get the <literal>set_position</literal> method from <literal>Node2D</literal>
                since this is where it was registered, even though we're going to use it in a
                <literal>Sprite2D</literal>, a derived class.</paragraph>
            <paragraph>The seemingly random number for getting the bind is actually a hash of the
                method signature. This allows Godot to match the method you're requesting even
                if in a future Godot version this signature changes, by providing a
                compatibility method that matches what you're asking for. This is one of the
                systems that allow the engine to load extensions made for previous versions. You
                can get the value of this hash from the <literal>extension_api.json</literal> file.</paragraph>
            <paragraph>With all that, we can finally implement our custom <literal>_process()</literal> method in the
                <literal>gdexample.c</literal> file:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">...

#include &lt;math.h&gt;

...

void gdexample_class_process(GDExample *self, double delta)
{
    self-&gt;time_passed += self-&gt;speed * delta;

    Vector2 new_position;

    // Set up the arguments for the Vector2 constructor.
    double x = self-&gt;amplitude + (self-&gt;amplitude * sin(self-&gt;time_passed * 2.0));
    double y = self-&gt;amplitude + (self-&gt;amplitude * cos(self-&gt;time_passed * 1.5));
    GDExtensionConstTypePtr args[] = {&amp;x, &amp;y};
    // Call the Vector2 constructor.
    constructors.vector2_constructor_x_y(&amp;new_position, args);

    // Set up the arguments for the set_position method.
    GDExtensionConstTypePtr args2[] = {&amp;new_position};
    // Call the set_position method.
    api.object_method_bind_ptrcall(methods.node2d_set_position, self-&gt;object, args2, NULL);
}</literal_block>
            <paragraph>After updating the time passed scaled by the <literal>speed</literal> property, it creates
                <literal>x</literal> and <literal>y</literal> values based on that, also modulated by the <literal>amplitude</literal>
                property. This is what will give the pattern effect. The <literal>math.h</literal> header is
                needed for the <literal>sin()</literal> and <literal>cos()</literal> functions used here.</paragraph>
            <paragraph>Then it sets up an array of arguments to construct a <literal>Vector2</literal>, followed by
                calling the constructor. It sets up another array of arguments and use it to
                call the <literal>set_position()</literal> method via the bind we acquired previously.</paragraph>
            <paragraph>Since nothing here allocates any memory, there's not a need to cleanup.</paragraph>
            <paragraph>Now we can build the extension again and reopen Godot. Even in the editor you'll
                see the custom sprite moving.</paragraph>
            <image candidates="{'*': 'tutorials/scripting/gdextension/img/gdextension_c_moving_sprite.gif'}" original_uri="img/gdextension_c_moving_sprite.gif" uri="tutorials/scripting/gdextension/img/gdextension_c_moving_sprite.gif"></image>
            <paragraph>Try changing the <strong>Speed</strong> and <strong>Amplitude</strong> properties and see how the sprite
                react.</paragraph>
        </section>
        <section ids="registering-and-emitting-a-signal" names="registering\ and\ emitting\ a\ signal">
            <title>Registering and emitting a signal</title>
            <paragraph>To complete this tutorial, let's see how you can register a custom signal and
                emit it when appropriate. As you might have guessed, we'll need a few more
                function pointers from the API and more helper functions.</paragraph>
            <paragraph>In the <literal>api.h</literal> file we're adding two things. One is an API function to
                register a signal, the other is a helper function to wrap the signal binding.</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">extern struct API
{
    ...
    GDExtensionInterfaceClassdbRegisterExtensionClassSignal classdb_register_extension_class_signal;
} api;

...

// Version for 1 argument.
void bind_signal_1(
    const char *class_name,
    const char *signal_name,
    const char *arg1_name,
    GDExtensionVariantType arg1_type);</literal_block>
            <paragraph>In this case we only have a version for one argument, since it's what we're
                going to use.</paragraph>
            <paragraph>Moving to the <literal>api.c</literal> file, we can load this new function pointer and
                implement the helper:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void load_api(GDExtensionInterfaceGetProcAddress p_get_proc_address)
{
    // API.
    ...
    api.classdb_register_extension_class_signal = (GDExtensionInterfaceClassdbRegisterExtensionClassSignal)p_get_proc_address("classdb_register_extension_class_signal");

    ...
}

void bind_signal_1(
    const char *class_name,
    const char *signal_name,
    const char *arg1_name,
    GDExtensionVariantType arg1_type)
{
    StringName class_string_name;
    constructors.string_name_new_with_latin1_chars(&amp;class_string_name, class_name, false);
    StringName signal_string_name;
    constructors.string_name_new_with_latin1_chars(&amp;signal_string_name, signal_name, false);

    GDExtensionPropertyInfo args_info[] = {
        make_property(arg1_type, arg1_name),
    };

    api.classdb_register_extension_class_signal(class_library, &amp;class_string_name, &amp;signal_string_name, args_info, 1);

    // Destruct things.
    destructors.string_name_destructor(&amp;class_string_name);
    destructors.string_name_destructor(&amp;signal_string_name);
    destruct_property(&amp;args_info[0]);
}</literal_block>
            <paragraph>This one is very similar to the function to bind methods. The main difference is
                that we don't need to fill another struct, we just pass the needed names and the
                array of arguments. The <literal>1</literal> at the end means the amount of arguments the
                signal provides.</paragraph>
            <paragraph>With this we can bind the signal in <literal>gdexample.c</literal>:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void gdexample_class_bind_methods()
{
    ...
    bind_signal_1("GDExample", "position_changed", "new_position", GDEXTENSION_VARIANT_TYPE_VECTOR2);
}</literal_block>
            <paragraph>In order to emit a signal, we need to call the
                <reference internal="True" refuri="../../../classes/class_object#class-object-method-emit-signal"><inline classes="std std-ref">emit_signal()</inline></reference> method on our custom node.
                Since this is a <literal>vararg</literal> function (meaning it takes any amount of arguments),
                we cannot use <literal>ptrcall</literal>. To do a regular call, we have to create Variants,
                which require a few more steps of plumbing to get done.</paragraph>
            <paragraph>First, in the <literal>defs.h</literal> file we create a definition for Variant:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">...

// The sizes can be obtained from the extension_api.json file.
...
#ifdef REAL_T_IS_DOUBLE
#define VARIANT_SIZE 40
#define VECTOR2_SIZE 16
#else
#define VARIANT_SIZE 24
#define VECTOR2_SIZE 8
#endif

...

// Types.

...

typedef struct
{
    uint8_t data[VARIANT_SIZE];
} Variant;</literal_block>
            <paragraph>We first set the size of Variant together with the size of Vector2 that we added
                before. Then we use it to create an opaque struct that is enough to hold the
                Variant data. Again, we set the size for double precision builds as a fallback,
                since by the official Godot builds use single precision.</paragraph>
            <paragraph>The <literal>emit_signal()</literal> function will be called with two arguments. The first is
                the name of the signal to be emitted and the second is the argument we're
                passing to the signal connections, which is a Vector2 as we declared when
                binding it. So we're gonna create a helper function that can call a MethodBind
                with these types. Even though it does return something (an error code), we don't
                need to deal with it, so for now we're just going to ignore it.</paragraph>
            <paragraph>In the <literal>api.h</literal>, we're adding a few things to the existing structs, plus a new
                helper function for the call:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">extern struct Constructors
{
    ...
    GDExtensionVariantFromTypeConstructorFunc variant_from_string_name_constructor;
    GDExtensionVariantFromTypeConstructorFunc variant_from_vector2_constructor;
} constructors;

extern struct Destructors
{
    ..
    GDExtensionInterfaceVariantDestroy variant_destroy;
} destructors;

...

extern struct Methods
{
    ...
    GDExtensionMethodBindPtr object_emit_signal;
} methods;

extern struct API
{
    ...
    GDExtensionInterfaceObjectMethodBindCall object_method_bind_call;
} api;

...

// Helper to call with Variant arguments.
void call_2_args_stringname_vector2_no_ret_variant(
    GDExtensionMethodBindPtr p_method_bind,
    GDExtensionObjectPtr p_instance,
    const GDExtensionTypePtr p_arg1,
    const GDExtensionTypePtr p_arg2);</literal_block>
            <paragraph>Now let's switch to the <literal>api.c</literal> file to load these new function pointers and
                implement the helper function.</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void load_api(GDExtensionInterfaceGetProcAddress p_get_proc_address)
{
    // API.
    ...
    api.object_method_bind_call = (GDExtensionInterfaceObjectMethodBindCall)p_get_proc_address("object_method_bind_call");

    // Constructors.
    ...
    constructors.variant_from_string_name_constructor = api.get_variant_from_type_constructor(GDEXTENSION_VARIANT_TYPE_STRING_NAME);
    constructors.variant_from_vector2_constructor = api.get_variant_from_type_constructor(GDEXTENSION_VARIANT_TYPE_VECTOR2);

    // Destructors.
    ...
    destructors.variant_destroy = (GDExtensionInterfaceVariantDestroy)p_get_proc_address("variant_destroy");

    ...
}

...

void call_2_args_stringname_vector2_no_ret_variant(GDExtensionMethodBindPtr p_method_bind, GDExtensionObjectPtr p_instance, const GDExtensionTypePtr p_arg1, const GDExtensionTypePtr p_arg2)
{
    // Set up the arguments for the call.
    Variant arg1;
    constructors.variant_from_string_name_constructor(&amp;arg1, p_arg1);
    Variant arg2;
    constructors.variant_from_vector2_constructor(&amp;arg2, p_arg2);
    GDExtensionConstVariantPtr args[] = {&amp;arg1, &amp;arg2};

    // Add dummy return value storage.
    Variant ret;

    // Call the function.
    api.object_method_bind_call(p_method_bind, p_instance, args, 2, &amp;ret, NULL);

    // Destroy the arguments.
    destructors.variant_destroy(&amp;arg1);
    destructors.variant_destroy(&amp;arg2);
    destructors.variant_destroy(&amp;ret);
}</literal_block>
            <paragraph>This helper function has some boilerplate code but is quite straightforward. It sets up the
                two arguments inside stack allocated Variants, then creates an array with
                pointers to those. It also sets up another Variant to keep the return value,
                which we don't need to construct since the call expects it to be uninitialized.</paragraph>
            <paragraph>Then it actually calls the MethodBind using the instance we provided and the
                arguments. The <literal>NULL</literal> at the end would be a pointer to a
                <literal>GDExtensionCallError</literal> struct. This can be used to treat potential errors when
                calling the functions (such as wrong arguments). For the sake of simplicity
                we're not gonna handle that here.</paragraph>
            <paragraph>At the end we need to destruct the Variants we created. While technically the
                Vector2 one does not require destructing, it is clearer to cleanup everything.</paragraph>
            <paragraph>We also need to load the MethodBind, which we'll do in the <literal>init.c</literal> file,
                right after loading the one for the <literal>set_position</literal> method we did before:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void initialize_gdexample_module(void *p_userdata, GDExtensionInitializationLevel p_level)
{
    ...

    constructors.string_name_new_with_latin1_chars(&amp;native_class_name, "Object", false);
    constructors.string_name_new_with_latin1_chars(&amp;method_name, "emit_signal", false);
    methods.object_emit_signal = api.classdb_get_method_bind(&amp;native_class_name, &amp;method_name, 4047867050);
    destructors.string_name_destructor(&amp;native_class_name);
    destructors.string_name_destructor(&amp;method_name);

    // Register class.
    ...
}</literal_block>
            <paragraph>Note that we reuse the <literal>native_class_name</literal> and <literal>method_name</literal> variables here,
                so we don't need to declare new ones.</paragraph>
            <paragraph>Now go to the <literal>gdexample.h</literal> file where we're going to add a couple of fields:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">typedef struct
{
    // Private properties.
    ..
    double time_emit;
    ..
    // Metadata.
    StringName position_changed; // For signal.
} GDExample;</literal_block>
            <paragraph>The first one will store the time passed since the last signal was emitted,
                since we'll be doing so at regular intervals. The other is just to cache the
                signal name so we don't need to create a new StringName every time.</paragraph>
            <paragraph>In the source <literal>gdexample.c</literal> file we can change the constructor and destructor
                to deal with the new fields:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void gdexample_class_constructor(GDExample *self)
{
    ...
    self-&gt;time_emit = 0.0;

    // Construct the StringName for the signal.
    constructors.string_name_new_with_latin1_chars(&amp;self-&gt;position_changed, "position_changed", false);
}

void gdexample_class_destructor(GDExample *self)
{
    // Destruct the StringName for the signal.
    destructors.string_name_destructor(&amp;self-&gt;position_changed);
}</literal_block>
            <paragraph>It is important to destruct the StringName to avoid memory leaks.</paragraph>
            <paragraph>Now we can add to the <literal>gdexample_class_process()</literal> function to actually emit the
                signal:</paragraph>
            <literal_block force="False" highlight_args="{}" language="c" linenos="False" xml:space="preserve">void gdexample_class_process(GDExample *self, double delta)
{
    ...

    self-&gt;time_emit += delta;
    if (self-&gt;time_emit &gt;= 1.0)
    {
        // Call the emit_signal method.
        call_2_args_stringname_vector2_no_ret_variant(methods.object_emit_signal, self-&gt;object, &amp;self-&gt;position_changed, &amp;new_position);
        self-&gt;time_emit = 0.0;
    }
}</literal_block>
            <paragraph>This updates the time passed for the signal emission and, if it is over one
                second it calls the <literal>emit_signal()</literal> function on the current instance, passing
                the name of the signal and the new position as arguments.</paragraph>
            <paragraph>Now we're done with our C GDExtension. Build it once more and reopen the demo
                project in the editor.</paragraph>
            <paragraph>In the documentation page for <literal>GDExample</literal> you can see the new signal we bound:</paragraph>
            <image candidates="{'*': 'tutorials/scripting/gdextension/img/gdextension_c_signal_doc.webp'}" original_uri="img/gdextension_c_signal_doc.webp" uri="tutorials/scripting/gdextension/img/gdextension_c_signal_doc.webp"></image>
            <paragraph>To check it's working, let's add a small script to the root node, parent of our
                custom one, that prints the position to the output every time it receives the
                signal:</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

func _ready():
    $GDExample.position_changed.connect(on_position_changed)

func on_position_changed(new_position):
    prints("New position:", new_position)</literal_block>
            <paragraph>Run the project and you can observe the values being printed in the Output dock
                in the editor:</paragraph>
            <image candidates="{'*': 'tutorials/scripting/gdextension/img/gdextension_c_signal_print.webp'}" original_uri="img/gdextension_c_signal_print.webp" uri="tutorials/scripting/gdextension/img/gdextension_c_signal_print.webp"></image>
        </section>
        <section ids="conclusion" names="conclusion">
            <title>Conclusion</title>
            <paragraph>This tutorial shows a basic extension with custom methods, properties, and
                signals. While it does require a good amount of boilerplate, it can scale well
                by creating helper functions to handle the tedious tasks.</paragraph>
            <paragraph>This should serve as a good basis to understand the GDExtension API and as a
                starting point to create custom binding generators. In fact, it would be
                possible to create bindings for C using such type of generator, making the
                actual coding look more like the <literal>gdexample.c</literal> file in this example, which is
                quite straightforward and not very verbose.</paragraph>
            <paragraph>If you want to create actual extensions, it is preferred to use the C++ bindings
                instead, as it takes away all of the boilerplate from your code. Check the
                <reference internal="True" refuri="../cpp/index#doc-godot-cpp"><inline classes="std std-ref">godot-cpp documentation</inline></reference> to see how you can
                do this.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
