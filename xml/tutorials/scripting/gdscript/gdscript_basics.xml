<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/gdscript/gdscript_basics.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-gdscript"></target>
    <section ids="gdscript-reference doc-gdscript" names="gdscript\ reference gdscript\ 参考 doc_gdscript">
        <title>GDScript 参考</title>
        <paragraph><reference internal="True" refid="doc-gdscript"><inline classes="std std-ref">GDScript</inline></reference> 是一种<reference name="面向对象" refuri="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">面向对象</reference><target ids="id1" names="面向对象" refuri="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"></target>的高级<reference name="指令式" refuri="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%B7%A8%E7%A8%8B">指令式</reference><target ids="id2" names="指令式" refuri="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%B7%A8%E7%A8%8B"></target><reference name="渐进类型" refuri="https://en.wikipedia.org/wiki/Gradual_typing">渐进类型</reference><target ids="id3" names="渐进类型" refuri="https://en.wikipedia.org/wiki/Gradual_typing"></target>编程语言，专为 Godot 构建，以与 <reference name="Python" refuri="https://zh.wikipedia.org/wiki/Python">Python</reference><target ids="python" names="python" refuri="https://zh.wikipedia.org/wiki/Python"></target> 等语言类似的缩进结构为其基本语句结构。设计 GDScript 这门语言旨在与 Godot 引擎紧密集成，对 Godot 引擎进行优化，从而为程序内容的创建与继承提供灵活的手段。</paragraph>
        <paragraph>GDScript 完全独立于 Python 而存在，二者之间并不存在继承与扩展关系。</paragraph>
        <section ids="history" names="history 历史">
            <title>历史</title>
            <note>
                <paragraph>关于 GDScript 历史的文档已移至<reference internal="True" refuri="../../../about/faq#doc-faq-what-is-gdscript"><inline classes="std std-ref">常见问题</inline></reference>。</paragraph>
            </note>
        </section>
        <section ids="example-of-gdscript" names="example\ of\ gdscript gdscript\ 示例">
            <title>GDScript 示例</title>
            <paragraph>考虑到部分开发者了解过编程语法，学起GDScript来会较为上手，这里给出一个简单的 GDScript 示例供参考学习。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Everything after "#" is a comment.
# A file is a class!

# (optional) icon to show in the editor dialogs:
@icon("res://path/to/optional/icon.svg")

# (optional) class definition:
class_name MyClass

# Inheritance:
extends BaseClass


# Member variables.
var a = 5
var s = "Hello"
var arr = [1, 2, 3]
var dict = {"key": "value", 2: 3}
var other_dict = {key = "value", other_key = 2}
var typed_var: int
var inferred_type := "String"

# Constants.
const ANSWER = 42
const THE_NAME = "Charly"

# Enums.
enum {UNIT_NEUTRAL, UNIT_ENEMY, UNIT_ALLY}
enum Named {THING_1, THING_2, ANOTHER_THING = -1}

# Built-in vector types.
var v2 = Vector2(1, 2)
var v3 = Vector3(1, 2, 3)


# Functions.
func some_function(param1, param2, param3):
    const local_const = 5

    if param1 &lt; local_const:
        print(param1)
    elif param2 &gt; 5:
        print(param2)
    else:
        print("Fail!")

    for i in range(20):
        print(i)

    while param2 != 0:
        param2 -= 1

    match param3:
        3:
            print("param3 is 3!")
        _:
            print("param3 is not 3!")

    var local_var = param1 + 3
    return local_var


# Functions override functions with the same name on the base/super class.
# If you still want to call them, use "super":
func something(p1, p2):
    super(p1, p2)


# It's also possible to call another function in the super class:
func other_something(p1, p2):
    super.something(p1, p2)


# Inner class
class Something:
    var a = 10


# Constructor
func _init():
    print("Constructed!")
    var lv = Something.new()
    print(lv.a)</literal_block>
            <paragraph>如果你以前有过使用如 C、 C++ 、C# 等静态类型语言的编程经验，却从未使用过动态类型编程语言，建议阅读此教程： <reference internal="True" refuri="gdscript_advanced#doc-gdscript-more-efficiently"><inline classes="std std-ref">GDScript：动态语言入门</inline></reference>。</paragraph>
        </section>
        <section ids="language" names="language 语言">
            <title>语言</title>
            <paragraph>下面是有关 GDScript 的一些概述。有关 GDScript 相关的详细内容，如哪些方法可用于数组或其他对象，可在相关链接所指向的类描述页面中查询。</paragraph>
            <section ids="identifiers" names="identifiers 标识符">
                <title>标识符</title>
                <paragraph>标识符仅限于含字母字符（ <literal>a</literal> 到 <literal>z</literal> 和 <literal>A</literal> 到 <literal>Z</literal> ）、 数字（ <literal>0</literal> 到 <literal>9</literal> ）和下划线 <literal>_</literal> 的字符串，不能以数字开头，且大小写敏感（如 <literal>foo</literal> 和 <literal>FOO</literal> 就是两个不同的标识符）。</paragraph>
                <paragraph>标识符现在也允许包含 <reference name="UAX#31" refuri="https://www.unicode.org/reports/tr31/">UAX#31</reference> 所提供的部分 Unicode 字符，即现在也可将非英文字符作为标识符使用，而 Unicode 字符中易与 ASCII 字符混淆的字符以及颜文字则无法作为标识符使用。</paragraph>
            </section>
            <section ids="keywords" names="keywords 关键字">
                <title>关键字</title>
                <paragraph>下表为该语言所支持的关键字列表。由于关键字是保留字（令牌字），因此不能用作标识符。操作符（如 <literal>in</literal>、<literal>not</literal>、<literal>and</literal>、<literal>or</literal>）及后文中出现的内置类型名称亦为保留字。</paragraph>
                <paragraph>若想深入了解关键字，可在 <reference name="GDScript 词法分析器" refuri="https://github.com/godotengine/godot/blob/master/modules/gdscript/gdscript_tokenizer.cpp">GDScript 词法分析器</reference><target ids="gdscript" names="gdscript\ 词法分析器" refuri="https://github.com/godotengine/godot/blob/master/modules/gdscript/gdscript_tokenizer.cpp"></target>中找到对于关键字的定义。</paragraph>
                <table>
                    <tgroup cols="2">
                        <colspec colwidth="12"></colspec>
                        <colspec colwidth="147"></colspec>
                        <thead>
                            <row>
                                <entry>
                                    <paragraph>关键字</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>描述</paragraph>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph>if</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>见 <reference name="if/else/elif" refid="if-else-elif">if/else/elif</reference> 。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>elif</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>见 <reference name="if/else/elif" refid="if-else-elif">if/else/elif</reference> 。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>else</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>见 <reference name="if/else/elif" refid="if-else-elif">if/else/elif</reference> 。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>for</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>见 <reference name="for" refid="for">for</reference> 。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>while</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>见 <reference name="while" refid="while">while</reference> 。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>match</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>见 <reference name="match" refid="match">match</reference> 。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>break</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>退出当前 <literal>for</literal> 或 <literal>while</literal> 循环的执行。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>continue</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>立即跳到 <literal>for</literal> 或 <literal>while</literal> 循环的下一个迭代。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>pass</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>语法上要求在不希望执行代码的语句中使用，例如在空函数中使用。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>return</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>从函数当中返回一个值。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>class</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>定义一个内部类。见 <reference name="内部类" refid="inner-classes">内部类</reference>。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>class_name</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>将脚本定义为具有指定名称的全局可访问类。见 <reference name="注册具名类" refid="registering-named-classes">注册具名类</reference>。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>extends</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>定义当前类的父类。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>is</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>检测变量是否继承自给定的类，或检测该变量是否为给定的内置类型。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>in</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>通常情况下用来检测字符串、列表、范围、字典、节点中是否存在某个值，而和 <literal>for</literal> 关键字连用时，则用于遍历字符串、列表、范围、字典、节点中的内容。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>as</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>尝试将值转换为给定类型的值。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>self</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>引用当前类实例。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>super</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Resolves the scope of the parent method. See <reference name="Inheritance" refid="inheritance">Inheritance</reference>.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>signal</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>定义信号。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>func</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>定义函数。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>static</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>将一个函数声明为静态函数，或将一个成员变量声明为静态成员变量。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>const</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>定义常量。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>enum</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>定义枚举。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>var</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>定义变量。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>breakpoint</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>用来设置脚本编辑器辅助调试断点的关键字。与在脚本编辑器每行最左侧点击红点所创建的断点不同， <literal>breakpoint</literal> 关键字可以储存在脚本内部。在不同设备上使用版本工具进行调试时，由 <literal>breakpoint</literal> 关键字创建的断点仍旧有效。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>preload</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>预加载一个类或变量，参见 <reference name="类作为资源" refid="classes-as-resources">类作为资源</reference> 。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>await</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Waits for a signal or a coroutine to finish. See <reference name="Awaiting signals or coroutines" refid="awaiting-signals-or-coroutines">Awaiting signals or coroutines</reference>.</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>yield</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>以前的版本中用于协程，现保留为关键字，以便旧版本迁移至新版本。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>assert</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>断言条件，若断言失败则记录错误，在非调试版本中会忽略断言语法。参见 <reference name="Assert 关键字" refid="assert-keyword">Assert 关键字</reference>。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>void</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>用于代表函数不返回任何值。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>PI</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>PI（π）常数。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>TAU</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>TAU（τ）常数。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>INF</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>无穷常量，用于比较和计算结果。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph>NAN</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>NAN（非数）常量，用作计算后不可能得到的结果。</paragraph>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
            </section>
            <section ids="operators" names="operators 运算符">
                <title>运算符</title>
                <paragraph>The following is the list of supported operators and their precedence. All binary operators are <reference name="left-associative" refuri="https://en.wikipedia.org/wiki/Operator_associativity">left-associative</reference><target ids="left-associative" names="left-associative" refuri="https://en.wikipedia.org/wiki/Operator_associativity"></target>,
                    including the <literal>**</literal> operator. This means that <literal>2 ** 2 ** 3</literal> is equal to <literal>(2 ** 2) ** 3</literal>. Use parentheses to explicitly specify precedence you need, for
                    example <literal>2 ** (2 ** 3)</literal>. The ternary <literal>if/else</literal> operator is right-associative.</paragraph>
                <table>
                    <tgroup cols="2">
                        <colspec colwidth="39"></colspec>
                        <colspec colwidth="77"></colspec>
                        <thead>
                            <row>
                                <entry>
                                    <paragraph><strong>运算符</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>描述</strong></paragraph>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph><literal>(</literal> <literal>)</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>分组（优先级最高）</paragraph>
                                    <paragraph>括号其实不是运算符，但是能够让你显式指定运算的优先级。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>x[index]</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>下标</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>x.attribute</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>属性引用</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>foo()</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>函数调用</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>await x</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><reference name="Awaiting signals or coroutines" refid="awaiting-signals-or-coroutines">Awaiting signals or coroutines</reference></paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <line_block>
                                        <line><literal>x is Node</literal></line>
                                        <line><literal>x is not Node</literal></line>
                                    </line_block>
                                </entry>
                                <entry>
                                    <paragraph>类型检查</paragraph>
                                    <paragraph>另见 <reference internal="True" refuri="../../../classes/class_@gdscript#class-gdscript-method-is-instance-of"><inline classes="std std-ref">is_instance_of()</inline></reference> 函数。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>x ** y</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>幂（乘方）</paragraph>
                                    <paragraph>将 <literal>x</literal> 与其自身相乘 <literal>y</literal> 次，类似于调用 <reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-pow"><inline classes="std std-ref">pow()</inline></reference> 函数。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>~x</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>按位取反</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <line_block>
                                        <line><literal>+x</literal></line>
                                        <line><literal>-x</literal></line>
                                    </line_block>
                                </entry>
                                <entry>
                                    <paragraph>取同 / 取负（相反数）</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <line_block>
                                        <line><literal>x * y</literal></line>
                                        <line><literal>x / y</literal></line>
                                        <line><literal>x % y</literal></line>
                                    </line_block>
                                </entry>
                                <entry>
                                    <paragraph>乘法/除法/余数</paragraph>
                                    <paragraph><literal>%</literal> 运算符也用于<reference internal="True" refuri="gdscript_format_string#doc-gdscript-printf"><inline classes="std std-ref">字符串的格式化</inline></reference>。</paragraph>
                                    <paragraph><strong>注意：</strong>这些运算符的运算机制与其在 C++ 中的运算机制一致，而对于使用 Python、JavaScript 等语言的用户则可能会存在在其意料之外的运算机制，详情见表后。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <line_block>
                                        <line><literal>x + y</literal></line>
                                        <line><literal>x - y</literal></line>
                                    </line_block>
                                </entry>
                                <entry>
                                    <paragraph>加法（或连接）/减法</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <line_block>
                                        <line><literal>x &lt;&lt; y</literal></line>
                                        <line><literal>x &gt;&gt; y</literal></line>
                                    </line_block>
                                </entry>
                                <entry>
                                    <paragraph>位移位</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>x &amp; y</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>按位与</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>x ^ y</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>按位异或</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>x | y</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>按位或</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <line_block>
                                        <line><literal>x == y</literal></line>
                                        <line><literal>x != y</literal></line>
                                        <line><literal>x &lt; y</literal></line>
                                        <line><literal>x &gt; y</literal></line>
                                        <line><literal>x &lt;= y</literal></line>
                                        <line><literal>x &gt;= y</literal></line>
                                    </line_block>
                                </entry>
                                <entry>
                                    <paragraph>比较</paragraph>
                                    <paragraph>详情见表后。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <line_block>
                                        <line><literal>x in y</literal></line>
                                        <line><literal>x not in y</literal></line>
                                    </line_block>
                                </entry>
                                <entry>
                                    <paragraph>检查包含关系</paragraph>
                                    <paragraph><literal>in</literal> 也在 <reference name="for" refid="for">for</reference> 关键字的语法中使用。</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <line_block>
                                        <line><literal>not x</literal></line>
                                        <line><literal>!x</literal></line>
                                    </line_block>
                                </entry>
                                <entry>
                                    <paragraph>布尔“非”及其<reference internal="True" refuri="gdscript_styleguide#boolean-operators"><inline classes="std std-ref">不推荐使用</inline></reference>的形式</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <line_block>
                                        <line><literal>x and y</literal></line>
                                        <line><literal>x &amp;&amp; y</literal></line>
                                    </line_block>
                                </entry>
                                <entry>
                                    <paragraph>布尔“与”及其<reference internal="True" refuri="gdscript_styleguide#boolean-operators"><inline classes="std std-ref">不推荐使用</inline></reference>的形式</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <line_block>
                                        <line><literal>x or y</literal></line>
                                        <line><literal>x || y</literal></line>
                                    </line_block>
                                </entry>
                                <entry>
                                    <paragraph>布尔“或”及其<reference internal="True" refuri="gdscript_styleguide#boolean-operators"><inline classes="std std-ref">不推荐使用</inline></reference>的形式</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>真表达式 if 条件 else 假表达式</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>三元（目）运算符 if/else</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>x as Node</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><reference name="类型转换" refid="casting">类型转换</reference><target names="类型转换" refname="casting"></target></paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <line_block>
                                        <line><literal>x = y</literal></line>
                                        <line><literal>x += y</literal></line>
                                        <line><literal>x -= y</literal></line>
                                        <line><literal>x *= y</literal></line>
                                        <line><literal>x /= y</literal></line>
                                        <line><literal>x **= y</literal></line>
                                        <line><literal>x %= y</literal></line>
                                        <line><literal>x &amp;= y</literal></line>
                                        <line><literal>x |= y</literal></line>
                                        <line><literal>x ^= y</literal></line>
                                        <line><literal>x &lt;&lt;= y</literal></line>
                                        <line><literal>x &gt;&gt;= y</literal></line>
                                    </line_block>
                                </entry>
                                <entry>
                                    <paragraph>赋值（优先级最低）</paragraph>
                                    <paragraph>表达式中不能使用赋值运算符。</paragraph>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <note>
                    <paragraph>一些运算符的运算机制可能会与你所预期的运算机制有所不同：</paragraph>
                    <enumerated_list enumtype="arabic" prefix="" suffix=".">
                        <list_item>
                            <paragraph>若运算符 <literal>/</literal> 两端的数值均为 <reference internal="True" refuri="../../../classes/class_int#class-int"><inline classes="std std-ref">int</inline></reference>，则进行整数除法而非浮点数除法。例如： <literal>5 /2 == 2</literal> 中该算式的结果为 <literal>2</literal> 而非 <literal>2.5</literal> 。若希望进行浮点数运算，请将该运算符两端的其中一个数值的类型改为 <reference internal="True" refuri="../../../classes/class_float#class-float"><inline classes="std std-ref">float</inline></reference> ，如直接使用浮点数（ <literal>x / 2.0</literal> ）、转换类型（ <literal>float(x) / y</literal> ）、乘以 <literal>1.0</literal> （ <literal>x * 1.0 / y</literal> ）等。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>运算符 <literal>%</literal> 仅适用于整型数值的取余运算，对于小数的取余运算，请使用 <reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-fmod"><inline classes="std std-ref">fmod()</inline></reference> 方法。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>对于负值，<literal>%</literal> 运算符和 <literal>fmod()</literal> 函数会使用 <reference name="截断算法" refuri="https://en.wikipedia.org/wiki/Truncation">截断算法</reference><target ids="id1" names="截断算法" refuri="https://en.wikipedia.org/wiki/Truncation"></target> 进行运算，而非向负无穷大舍入，此时余数会带有符号（即余数可能为负）。如果你需要数学意义上的余数，请改用 <reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-posmod"><inline classes="std std-ref">posmod()</inline></reference> 和 <reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-fposmod"><inline classes="std std-ref">fposmod()</inline></reference> 函数。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>==</literal> 和 <literal>!=</literal> 运算符在有些情况下允许比较不同类型的值（例如，<literal>1 == 1.0</literal> 的结果为真），但在其他情况下可能会发生运行时错误。若你不能确定操作数的类型，可使用 <reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-is-same"><inline classes="std std-ref">is_same()</inline></reference> 函数来进行安全比较（但请注意，该函数对类型和引用更加严格）。要比较浮点数，请改用 <reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-is-equal-approx"><inline classes="std std-ref">is_equal_approx()</inline></reference> 和 <reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-is-zero-approx"><inline classes="std std-ref">is_zero_approx()</inline></reference> 函数。</paragraph>
                        </list_item>
                    </enumerated_list>
                </note>
            </section>
            <section ids="literals" names="literals 字面量">
                <title>字面量</title>
                <table>
                    <tgroup cols="2">
                        <colspec colwidth="33"></colspec>
                        <colspec colwidth="43"></colspec>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph><strong>Example(s)</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>描述</strong></paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>null</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>空值</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>false</literal>, <literal>true</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>布尔值</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>45</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>十进制整数</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>0x8f51</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>十六进制整数</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>0b101010</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>二进制整数</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>3.14</literal>, <literal>58.1e-10</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>浮点数（实数）</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>"Hello"</literal>, <literal>"Hi"</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>常规字符串</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>"""Hello"""</literal>, <literal>'''Hi'''</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>常规字符串（用三对引号括住）</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>r"Hello"</literal>, <literal>r'Hi'</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>原始字符串</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>r"""Hello"""</literal>, <literal>r'''Hi'''</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>原始字符串（用三对引号括住）</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>&amp;"name"</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><reference internal="True" refuri="../../../classes/class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>^"Node/Label"</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><reference internal="True" refuri="../../../classes/class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference></paragraph>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <paragraph>也有两种长得像字面量，但实际上不是字面量的量：</paragraph>
                <table>
                    <tgroup cols="2">
                        <colspec colwidth="33"></colspec>
                        <colspec colwidth="43"></colspec>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph><strong>示例</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>描述</strong></paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>$NodePath</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><literal>get_node("NodePath")</literal> 的简写</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>%UniqueNode</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><literal>get_node("%UniqueNode")</literal> 的简写</paragraph>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <paragraph>整数和浮点数可用 <literal>_</literal> 进行分隔，使其更加易读。以下表示数字的方法均有效：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">12_345_678  # Equal to 12345678.
3.141_592_7  # Equal to 3.1415927.
0x8080_0000_ffff  # Equal to 0x80800000ffff.
0b11_00_11_00  # Equal to 0b11001100.</literal_block>
                <paragraph><strong>常规字符串字面量</strong> 内可包含以下转义序列：</paragraph>
                <table>
                    <tgroup cols="2">
                        <colspec colwidth="21"></colspec>
                        <colspec colwidth="33"></colspec>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph><strong>转义序列</strong></paragraph>
                                </entry>
                                <entry>
                                    <paragraph><strong>转义为</strong></paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>\n</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>换行(line feed,LF)</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>\t</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>水平制表符（tab）</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>\r</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>回车（carriage return,CR）</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>\a</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>警报（蜂鸣/响铃）</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>\b</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>退格键（Backspace）</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>\f</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>换页符（form feed,FF）</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>\v</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>垂直制表符（tab）</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>\"</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>双引号</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>\'</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>单引号</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>\\</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>反斜杠</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>\uXXXX</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Unicode UTF-16 码位 <literal>XXXX</literal> （16进制，不区分大小写）</paragraph>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><literal>\UXXXXXX</literal></paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Unicode UTF-32 码位 <literal>XXXXXX</literal> （16进制，不区分大小写）</paragraph>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <paragraph>有两种方法可以表示 <literal>0xFFFF</literal> 以上的转义 Unicode 字符：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>使用 <reference name="UTF-16 代理对" refuri="https://en.wikipedia.org/wiki/UTF-16#Code_points_from_U+010000_to_U+10FFFF">UTF-16 代理对</reference><target ids="utf-16" names="utf-16\ 代理对" refuri="https://en.wikipedia.org/wiki/UTF-16#Code_points_from_U+010000_to_U+10FFFF"></target> <literal>\uXXXX\uXXXX</literal> 表示。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>使用单个 UTF-32 码位 <literal>\UXXXXXX</literal> 表示。</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>此外，在字符串中使用 <literal>\</literal> 后换行可以让斜杠后的文字自动换行，而无需在字符串中插入换行符。</paragraph>
                <paragraph>使用某一种引号（如 <literal>"</literal>）构成的字符串，无需转义即可包含另一种引号（如 <literal>'</literal>），而三引号字符串在与其他字符串边缘不相邻的情况下，最多可避免连续两个同种引号的转义。</paragraph>
                <paragraph><strong>Raw string literals</strong> always encode the string as it appears in the source code.
                    This is especially useful for regular expressions. A raw string literal doesn't process escape sequences,
                    however it does recognize <literal>\\</literal> and <literal>\"</literal> (<literal>\'</literal>) and replaces them with themselves.
                    Thus, a string can have a quote that matches the opening one, but only if it's preceded by a backslash.</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("\tchar=\"\\t\"")  # Prints `    char="\t"`.
print(r"\tchar=\"\\t\"") # Prints `\tchar=\"\\t\"`.</literal_block>
                <note>
                    <paragraph>Some strings cannot be represented using raw string literals: you cannot have an odd number
                        of backslashes at the end of a string or have an unescaped opening quote inside the string.
                        However, in practice this doesn't matter since you can use a different quote type
                        or use concatenation with a regular string literal.</paragraph>
                </note>
                <paragraph>GDScript 也支持 <reference internal="True" refuri="gdscript_format_string#doc-gdscript-printf"><inline classes="std std-ref">GDScript 格式字符串</inline></reference>。</paragraph>
            </section>
            <section ids="annotations" names="annotations 注解">
                <title>注解</title>
                <paragraph>Annotations are special tokens in GDScript that act as modifiers to a script or
                    its code and may affect how the script is treated by the Godot engine or
                    editor.</paragraph>
                <paragraph>Every annotation starts with the <literal>@</literal> character and is specified by a name. A
                    detailed description and example for each annotation can be found inside the
                    <reference internal="True" refuri="../../../classes/class_@gdscript#class-gdscript"><inline classes="std std-ref">GDScript class reference</inline></reference>.</paragraph>
                <paragraph>比如，可以将变量导出到编辑器中：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@export_range(1, 100, 1, "or_greater")
var ranged_var: int = 50</literal_block>
                <paragraph>要获取更多关于导出属性的信息，请参阅 <reference internal="True" refuri="gdscript_exports#doc-gdscript-exports"><inline classes="std std-ref">GDScript exports</inline></reference>。</paragraph>
                <paragraph>所有与注解要求传入的参数类型相符、位置相配的常量表达式均可作为该注解的参数传入其中：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">const MAX_SPEED = 120.0

@export_range(0.0, 0.5 * MAX_SPEED)
var initial_speed: float = 0.25 * MAX_SPEED</literal_block>
                <paragraph>注解既可单行修饰，也可多行修饰，修饰离该注解最近的非注解语句。注解可携带参数，每个参数均在注解名后的括号内，彼此之间用逗号隔开。</paragraph>
                <paragraph>以下两个示例效果等价：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@annotation_a
@annotation_b
var variable

@annotation_a @annotation_b var variable</literal_block>
                <target refid="doc-gdscript-onready-annotation"></target>
            </section>
            <section ids="onready-annotation doc-gdscript-onready-annotation" names="@onready\ annotation @onready\ 注解 doc_gdscript_onready_annotation">
                <title><literal>@onready</literal> 注解</title>
                <paragraph>使用节点时，经常会需要将场景中某一部分的引用存放在变量中。由于场景只有在进入活动场景树时才会进行正确配置，故而仅在调用 <literal>Node._ready()</literal> 时才能获得子节点。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var my_label


func _ready():
    my_label = get_node("MyLabel")</literal_block>
                <paragraph>这种操作较为麻烦，而且节点和外部引用越多，操作起来就会越显不便。为此，GDScript 提供了 <literal>@onready</literal> 注解 ，将成员变量的初始化操作推迟到该节点调用 <literal>_ready()</literal> 的时刻进行。使用该注解，可以用一行代码替换掉上面的几行代码：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@onready var my_label = get_node("MyLabel")</literal_block>
                <warning>
                    <paragraph>同时使用 <literal>@onready</literal> 和 <literal>@export</literal> 这两个注解去修饰同一个变量，其效果并不会如你所愿，因为 <literal>@onready</literal> 注解会使该变量的默认值在 <literal>@export</literal> 注解起效后被赋值，导致该默认值被 <literal>@onready</literal> 的效果所覆盖：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@export var a = "init_value_a"
@onready @export var b = "init_value_b"

func _init():
    prints(a, b) # init_value_a &lt;null&gt;

func _notification(what):
    if what == NOTIFICATION_SCENE_INSTANTIATED:
        prints(a, b) # exported_value_a exported_value_b

func _ready():
    prints(a, b) # exported_value_a init_value_b</literal_block>
                    <paragraph>为此，本引擎提供了 <literal>ONREADY_WITH_EXPORT</literal> 警告选项，默认将该操作作为编辑器错误进行处理。我们并不推荐关闭或忽略该警告选项。</paragraph>
                </warning>
            </section>
            <section ids="comments" names="comments 注释">
                <title>注释</title>
                <paragraph><literal>#</literal> 所在行的所有内容都会被忽略，会视为注释进行处理。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># This is a comment.</literal_block>
                <tip>
                    <paragraph>在 Godot 的脚本编辑器中，一些特殊关键字会在注释中高亮显示以提醒用户：</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><strong>关键提示</strong> <emphasis>（标红）</emphasis>：<literal>ALERT</literal>、<literal>ATTENTION</literal>、<literal>CAUTION</literal>、<literal>CRITICAL</literal>、<literal>DANGER</literal>、<literal>SECURITY</literal></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><strong>警告提示</strong> <emphasis>（标黄）</emphasis>：<literal>BUG</literal>、<literal>DEPRECATED</literal>、<literal>FIXME</literal>、<literal>HACK</literal>、<literal>TASK</literal>、<literal>TBD</literal>、<literal>TODO</literal>、<literal>WARNING</literal></paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><strong>一般提示</strong> <emphasis>（标绿）</emphasis>：<literal>INFO</literal>、<literal>NOTE</literal>、<literal>NOTICE</literal>、<literal>TEST</literal>、<literal>TESTING</literal></paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>这些关键字均大小写敏感，故需要全大写以保证能被引擎所识别：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># In the example below, "TODO" will appear in yellow by default.
# The `:` symbol after the keyword is not required, but it's often used.

# TODO: Add more items for the player to choose from.</literal_block>
                    <paragraph>可在编辑器设置的 <strong>文本编辑器 &gt; 主题 &gt; 注释标记</strong> 部分中更改突出显示的关键字列表及其颜色。</paragraph>
                </tip>
                <target refid="doc-gdscript-builtin-types"></target>
            </section>
            <section ids="code-regions doc-gdscript-builtin-types" names="code\ regions 代码区块 doc_gdscript_builtin_types">
                <title>代码区块</title>
                <paragraph>代码区块是一种特殊类型的注释，脚本编辑器将其理解为 <emphasis>可折叠区块</emphasis>，即在编写代码区块注释后，可以通过点击注释左侧出现的箭头来折叠和展开该区块。该箭头用一个紫色方块包围起来，以区别于标准的代码折叠。</paragraph>
                <paragraph>语法如下：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Important: There must be *no* space between the `#` and `region` or `endregion`.

# Region without a description:
#region
...
#endregion

# Region with a description:
#region Some description that is displayed even when collapsed
...
#endregion</literal_block>
                <tip>
                    <paragraph>要快速创建代码区块，请在脚本编辑器中选择若干行，右键点击选区，然后选择 <strong>创建代码区块</strong>即可。系统将自动选中区块描述以对其进行编辑。</paragraph>
                    <paragraph>可将代码区块嵌套在其他代码区块内。</paragraph>
                </tip>
                <paragraph>以下为代码区块的具体使用示例：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># This comment is outside the code region. It will be visible when collapsed.
#region Terrain generation
# This comment is inside the code region. It won't be visible when collapsed.
func generate_lakes():
    pass

func generate_hills():
    pass
#endregion

#region Terrain population
func place_vegetation():
    pass

func place_roads():
    pass
#endregion</literal_block>
                <paragraph>代码区块可将大块代码组织成更容易理解的部分，但注意：外部编辑器通常不支持该特性。因此即便不依赖代码区块，也要确保你的代码易于理解。</paragraph>
                <note>
                    <paragraph>单独的函数与被缩进的部分（如 <literal>if</literal> 和 <literal>for</literal>） <emphasis>始终</emphasis> 可以在脚本编辑器中折叠，此时应避免使用代码区块来包含这些可始终折叠起来的部分，执意使用亦可，但也并不会带来太多好处。若要将多个元素分组在一起，使用代码区块效果最佳。</paragraph>
                </note>
            </section>
            <section ids="line-continuation" names="line\ continuation 行间语句接续">
                <title>行间语句接续</title>
                <paragraph>在GDScript中，一行语句可通过反斜杠（ <literal>\</literal> ）接续到下一行。将反斜杠加在一行语句末尾可将该行代码与下一行代码相衔接。如：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a = 1 + \
2</literal_block>
                <paragraph>可按以下方式对单个语句行进行多行接续：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a = 1 + \
4 + \
10 + \
4</literal_block>
            </section>
        </section>
        <section ids="built-in-types" names="built-in\ types 内置类型">
            <title>内置类型</title>
            <paragraph>内置类型分配在栈上，按值传递，在每次赋值或将其作为参数传递给函数时均会复制其值，例外：对象 <literal>Object</literal> 、数组 <literal>Array</literal> 、字典 <literal>Dictionary</literal> 以及密存数组（如 <literal>PackedByteArray</literal> ），这些类型的值按引用传递，其实例的值相互共享。数组、字典以及部分对象（ <literal>Node</literal> 、 <literal>Resource</literal> ）均有 <literal>duplicate()</literal> 方法，允许对其具体值进行复制操作。</paragraph>
            <section ids="basic-built-in-types" names="basic\ built-in\ types 基本内置类型">
                <title>基本内置类型</title>
                <paragraph>GDScript 中的变量可赋以不同内置类型的值。</paragraph>
                <section ids="null" names="null">
                    <title>null</title>
                    <paragraph><literal>null</literal> 为空数据类型，既不包含任何信息，也不能赋值为其他任何值。</paragraph>
                </section>
                <section ids="bool" names="bool">
                    <title><reference internal="True" refuri="../../../classes/class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></title>
                    <paragraph>“boolean”（布尔）的缩写，只能包含 <literal>true</literal> 或 <literal>false</literal>。</paragraph>
                </section>
                <section ids="int" names="int">
                    <title><reference internal="True" refuri="../../../classes/class_int#class-int"><inline classes="std std-ref">int</inline></reference></title>
                    <paragraph>英文“integer”（整数）的缩写，存储整数（正整数和负整数）。存储的是 64 位值，等效于 C++ 中的 <literal>int64_t</literal>。</paragraph>
                </section>
                <section ids="float" names="float">
                    <title><reference internal="True" refuri="../../../classes/class_float#class-float"><inline classes="std std-ref">float</inline></reference></title>
                    <paragraph>使用浮点值存储实数，包括小数。存储的是 64 位值，等效于 C++ 中的 <literal>double</literal>。注意：目前 <literal>Vector2</literal>、<literal>Vector3</literal>、<literal>PackedFloat32Array</literal> 等数据结构存储的是 32 位单精度 <literal>float</literal> 值。</paragraph>
                </section>
                <section ids="string" names="string">
                    <title><reference internal="True" refuri="../../../classes/class_string#class-string"><inline classes="std std-ref">String</inline></reference></title>
                    <paragraph><reference name="Unicode 格式" refuri="https://zh.wikipedia.org/zh-cn/Unicode">Unicode 格式</reference><target ids="unicode" names="unicode\ 格式" refuri="https://zh.wikipedia.org/zh-cn/Unicode"></target>的字符序列。</paragraph>
                </section>
                <section ids="stringname" names="stringname">
                    <title><reference internal="True" refuri="../../../classes/class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference></title>
                    <paragraph>不可变字符串，一个实例仅允许拥有一个名称。该类型的实例创建起来较慢，在多线程环境下可能会导致锁等待。不过，该类型的实例比较起来比字符串快，非常适合在字典中作为键名使用。</paragraph>
                </section>
                <section ids="nodepath" names="nodepath">
                    <title><reference internal="True" refuri="../../../classes/class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference></title>
                    <paragraph>节点或节点属性的预解析路径，可以轻松地赋值成字符串，亦或从字符串中转换为节点路径。节点路径可用于与节点树交互以获取节点，亦或通过诸如 <reference internal="True" refuri="../../../classes/class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference>等方式来影响属性。</paragraph>
                </section>
            </section>
            <section ids="vector-built-in-types" names="vector\ built-in\ types 内置向量类型">
                <title>内置向量类型</title>
                <section ids="vector2" names="vector2">
                    <title><reference internal="True" refuri="../../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference></title>
                    <paragraph>2D 向量类型，包含 <literal>x</literal> 和 <literal>y</literal> 两个字段，也可像访问数组元素一样访问这两个字段。</paragraph>
                </section>
                <section ids="vector2i" names="vector2i">
                    <title><reference internal="True" refuri="../../../classes/class_vector2i#class-vector2i"><inline classes="std std-ref">Vector2i</inline></reference></title>
                    <paragraph>同 Vector2，但其分量均为整型数值，非常适用于制作2D网格显示物品功能。</paragraph>
                </section>
                <section ids="rect2" names="rect2">
                    <title><reference internal="True" refuri="../../../classes/class_rect2#class-rect2"><inline classes="std std-ref">Rect2</inline></reference></title>
                    <paragraph>2D 矩形类型，包含两个向量字段： <literal>position</literal> 和 <literal>size</literal>。还包含一个 <literal>end</literal> 字段，即 <literal>position + size</literal>。</paragraph>
                </section>
                <section ids="vector3" names="vector3">
                    <title><reference internal="True" refuri="../../../classes/class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></title>
                    <paragraph>3D 向量类型，包含 <literal>x</literal> 、 <literal>y</literal> 和 <literal>z</literal> 这三个字段，也可以像访问数组元素一样访问这些字段。</paragraph>
                </section>
                <section ids="vector3i" names="vector3i">
                    <title><reference internal="True" refuri="../../../classes/class_vector3i#class-vector3i"><inline classes="std std-ref">Vector3i</inline></reference></title>
                    <paragraph>同 Vector3 ，但其分量均为整型数值，可用于为 3D 网格中的每个物品编制索引。</paragraph>
                </section>
                <section ids="transform2d" names="transform2d">
                    <title><reference internal="True" refuri="../../../classes/class_transform2d#class-transform2d"><inline classes="std std-ref">Transform2D</inline></reference></title>
                    <paragraph>用于 2D 线性变换的3x2矩阵。</paragraph>
                </section>
                <section ids="plane" names="plane">
                    <title><reference internal="True" refuri="../../../classes/class_plane#class-plane"><inline classes="std std-ref">Plane</inline></reference></title>
                    <paragraph>3D 平面类型的标准形式，包含一个向量字段 <literal>normal</literal> 以及一个 标量距离 <literal>d</literal> 。</paragraph>
                </section>
                <section ids="quaternion" names="quaternion">
                    <title><reference internal="True" refuri="../../../classes/class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference></title>
                    <paragraph>四元数是一种用于表示 3D 旋转的数据类型，对于内插旋转十分有用。</paragraph>
                </section>
                <section ids="aabb" names="aabb">
                    <title><reference internal="True" refuri="../../../classes/class_aabb#class-aabb"><inline classes="std std-ref">AABB</inline></reference></title>
                    <paragraph>轴对齐边界框（或 3D 边框），包含两个向量字段: <literal>position</literal> 和 <literal>size</literal>. 还包含一个 <literal>end</literal> 字段, 即 <literal>position + size</literal>.</paragraph>
                </section>
                <section ids="basis" names="basis">
                    <title><reference internal="True" refuri="../../../classes/class_basis#class-basis"><inline classes="std std-ref">Basis</inline></reference></title>
                    <paragraph>3×3矩阵，用于 3D 旋转与缩放。其包含3个向量字段（ <literal>x</literal>, <literal>y</literal> 和 <literal>z</literal> ），且可以像3D向量一样按索引访问这些向量字段。</paragraph>
                </section>
                <section ids="transform3d" names="transform3d">
                    <title><reference internal="True" refuri="../../../classes/class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference></title>
                    <paragraph>3D 线性变换，包含一个 Basis（基）字段 <literal>basis</literal> 和一个 Vector3 字段 <literal>origin</literal>。</paragraph>
                </section>
            </section>
            <section ids="engine-built-in-types" names="engine\ built-in\ types 引擎内置类型">
                <title>引擎内置类型</title>
                <section ids="color" names="color">
                    <title><reference internal="True" refuri="../../../classes/class_color#class-color"><inline classes="std std-ref">Color</inline></reference></title>
                    <paragraph>颜色数据类型包含 <literal>r</literal> 、 <literal>g</literal> 、 <literal>b</literal> 、 <literal>a</literal> 四个字段，也可以用 <literal>h</literal> 、 <literal>s</literal> 、 <literal>v</literal> 这三个字段来分别访问色相、饱和度、明度。</paragraph>
                </section>
                <section ids="rid" names="rid">
                    <title><reference internal="True" refuri="../../../classes/class_rid#class-rid"><inline classes="std std-ref">RID</inline></reference></title>
                    <paragraph>资源ID（RID）。服务使用通用的 RID 来引用不透明数据。</paragraph>
                </section>
                <section ids="object" names="object">
                    <title><reference internal="True" refuri="../../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference></title>
                    <paragraph>所有非内置类型的基类型。</paragraph>
                </section>
            </section>
            <section ids="container-built-in-types" names="container\ built-in\ types 容器内置类型">
                <title>容器内置类型</title>
                <section ids="array" names="array">
                    <title><reference internal="True" refuri="../../../classes/class_array#class-array"><inline classes="std std-ref">Array</inline></reference></title>
                    <paragraph>任意对象类型的泛型序列，包括其他数组或字典（见下文）。数组可以动态调整大小，其索引从 <literal>0</literal> 开始，索引为负整数时则表示从数组尾部开始计数。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var arr = []
arr = [1, 2, 3]
var b = arr[1] # This is 2.
var c = arr[arr.size() - 1] # This is 3.
var d = arr[-1] # Same as the previous line, but shorter.
arr[0] = "Hi!" # Replacing value 1 with "Hi!".
arr.append(4) # Array is now ["Hi!", 2, 3, 4].</literal_block>
                </section>
                <section ids="typed-arrays" names="typed\ arrays 类型化数组">
                    <title>类型化数组</title>
                    <paragraph>Godot 4.0 开始支持类型化数组。向类型化数组中写入数据时，Godot 会检查每个元素是否与该数组所指定的类型相匹配，因此类型化数组不能含有无效数据。而诸如 <literal>front()</literal> 和 <literal>back()</literal> 等方法，虽然 GDScript 静态分析器会将类型化数组考虑在内，却仍会返回 <literal>Variant</literal> 类型的数值。</paragraph>
                    <paragraph>类型化数组通过 <literal>Array[Type]</literal> 指定，其中类型 <literal>Type</literal> 可以是 <literal>Variant</literal> 类型、内置类型，也可以是用户自定义类型、枚举类型等。不支持类型化数组嵌套（如 <literal>Array[Array[int]]</literal> ）。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a: Array[int]
var b: Array[Node]
var c: Array[MyClass]
var d: Array[MyEnum]
var e: Array[Variant]</literal_block>
                    <paragraph><literal>Array</literal> 等价于 <literal>Array[Varaint]</literal> 。</paragraph>
                    <note>
                        <paragraph>数组是按引用传递的，因此数组元素类型也是运行时变量引用的内存结构的一个属性。变量的静态类型限制了它可以引用的结构。因此，你 <strong>不能</strong>为数组内的元素赋予不同的元素类型的值，即使该类型是数组所接受类型的子类型。</paragraph>
                        <paragraph>若需要对类型化数组进行 <emphasis>转型</emphasis> ，可以创建一个新数组，并使用 <reference internal="True" refuri="../../../classes/class_array#class-array-method-assign"><inline classes="std std-ref">Array.assign()</inline></reference> 方法:</paragraph>
                        <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a: Array[Node2D] = [Node2D.new()]

# (OK) You can add the value to the array because `Node2D` extends `Node`.
var b: Array[Node] = [a[0]]

# (Error) You cannot assign an `Array[Node2D]` to an `Array[Node]` variable.
b = a

# (OK) But you can use the `assign()` method instead. Unlike the `=` operator,
# the `assign()` method copies the contents of the array, not the reference.
b.assign(a)</literal_block>
                        <paragraph><literal>Array</literal> （ <literal>Array[Variant]</literal> ）则是例外，这样做可以保证用户使用的便捷性与与旧版本代码的兼容性。不过，非类型化的数组是不安全的。</paragraph>
                    </note>
                </section>
                <section ids="packed-arrays" names="packed\ arrays 压缩数组">
                    <title>压缩数组</title>
                    <paragraph>GDScript 数组在内存中通过线性分配以提高运行速度，但在使用大型数组（包含数万个元素）时可能会导致内存碎片。如果在意这个问题，可以使用特定类型的压缩数组，这些数组只接受单个数据类型，避免了内存碎片的同时使用的内存也更少。然而这些压缩数组是原子数组，运行起来通常要比通用数组慢，因此建议仅将压缩数组用于大型数据集当中：</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>：字节（从 0 到 255 的整数）数组。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference>：32位整数数组。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedint64array#class-packedint64array"><inline classes="std std-ref">PackedInt64Array</inline></reference>：64位整数数组。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference>：32位浮点数数组。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference>：64位浮点数数组。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference>：字符串数组。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>：<reference internal="True" refuri="../../../classes/class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> 类型的数组。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference>：<reference internal="True" refuri="../../../classes/class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> 类型的数组。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><reference internal="True" refuri="../../../classes/class_packedcolorarray#class-packedcolorarray"><inline classes="std std-ref">PackedColorArray</inline></reference>：<reference internal="True" refuri="../../../classes/class_color#class-color"><inline classes="std std-ref">Color</inline></reference> 类型的数组。</paragraph>
                        </list_item>
                    </bullet_list>
                </section>
                <section ids="dictionary" names="dictionary">
                    <title><reference internal="True" refuri="../../../classes/class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference></title>
                    <paragraph>关联容器，其内部数值通过与之对应的唯一的键进行引用。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var d = {4: 5, "A key": "A value", 28: [1, 2, 3]}
d["Hi!"] = 0
d = {
    22: "value",
    "some_key": 2,
    "other_key": [2, 3, 4],
    "more_key": "Hello"
}</literal_block>
                    <paragraph>字典也支持 Lua 风格的 table 语法。Lua 风格的 GDScript 字典语法在标记字符串键时，使用的是 <literal>=</literal> 而非 <literal>:</literal>，且不使用引号（这样要写的东西会稍微少一些）。但请注意，以这种形式编写的键和 GDScript 标识符一样不能以数字开头，且必须为字面量。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var d = {
    test22 = "value",
    some_key = 2,
    other_key = [2, 3, 4],
    more_key = "Hello"
}</literal_block>
                    <paragraph>若要向现有字典添加键，可以像访问现有键一样访问要添加的键，并给其赋值：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var d = {} # Create an empty Dictionary.
d.waiting = 14 # Add String "waiting" as a key and assign the value 14 to it.
d[4] = "hello" # Add integer 4 as a key and assign the String "hello" as its value.
d["Godot"] = 3.01 # Add String "Godot" as a key and assign the value 3.01 to it.

var test = 4
# Prints "hello" by indexing the dictionary with a dynamic key.
# This is not the same as `d.test`. The bracket syntax equivalent to
# `d.test` is `d["test"]`.
print(d[test])</literal_block>
                    <note>
                        <paragraph>方括号语法不仅可以用在 Dictionary 上，而且还可以用来存取任何 <reference internal="True" refuri="../../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference> 的属性。不过要注意：尝试读取不存在的属性会引发脚本错误。要避免这一点，可换用 <reference internal="True" refuri="../../../classes/class_object#class-object-method-get"><inline classes="std std-ref">Object.get()</inline></reference> 和 <reference internal="True" refuri="../../../classes/class_object#class-object-method-set"><inline classes="std std-ref">Object.set()</inline></reference> 方法。</paragraph>
                    </note>
                </section>
                <section ids="signal" names="signal">
                    <title><reference internal="True" refuri="../../../classes/class_signal#class-signal"><inline classes="std std-ref">Signal</inline></reference></title>
                    <paragraph>信号由对象发出，并由对象所监听。 <title_reference>Signal</title_reference> 类型可以用于将信号广播者作为参数进行传递。</paragraph>
                    <paragraph>信号可以直接从对象实例中进行引用，如 <literal>$Button.button_up</literal> 。</paragraph>
                </section>
                <section ids="callable" names="callable">
                    <title><reference internal="True" refuri="../../../classes/class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference></title>
                    <paragraph>可调用体包含一个对象及其某个函数，适用于将函数作为数值传递（例如：将可调用体用于信号连接）。</paragraph>
                    <paragraph>像引用成员属性那样引用一个方法的签名会返回可调用体。 如 <literal>var x = $Sprite2D.rotate</literal> 会将变量 <literal>x</literal> 赋值为一个可调用体，该可调用体含有对 <literal>$Sprite2D</literal> 对象的方法 <literal>rotate()</literal> 的引用。</paragraph>
                    <paragraph>可以调用 <literal>call</literal> 方法来调用可调体所指向的方法，如： <literal>x.call(PI)</literal> 。</paragraph>
                </section>
            </section>
        </section>
        <section ids="data" names="data 数据">
            <title>数据</title>
            <section ids="variables" names="variables 变量">
                <title>变量</title>
                <paragraph>变量可以作为类成员存在，也可以作为函数的局部变量存在，用 <literal>var</literal> 关键字创建，可以在初始化时指定一个值。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a # Data type is 'null' by default.
var b = 5
var c = 3.8
var d = b + c # Variables are always initialized in direct order (see below).</literal_block>
                <paragraph>变量可进行类型指定。指定类型时，将强制该变量始终容纳与被指定类型相同类型的数据。试图分配与该类型不兼容的值将触发报错。</paragraph>
                <paragraph>在变量声明中，在变量名后面使用 <literal>:</literal>（冒号）+ 类型名 来指定类型。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var my_vector2: Vector2
var my_node: Node = Sprite2D.new()</literal_block>
                <paragraph>如果在声明中初始化变量，则可以推断变量类型，在此情况下可省略类型名称：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var my_vector2 := Vector2() # 'my_vector2' is of type 'Vector2'.
var my_node := Sprite2D.new() # 'my_node' is of type 'Sprite2D'.</literal_block>
                <paragraph>类型推断只有在指定的值具有定义的类型时才能通过检查，否则将触发报错。</paragraph>
                <paragraph>有效的类型有：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>内置类型（如 Array 、 Vector2、 int、 String 等）。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>引擎自带类型（如 Node 、 Resource 、 Reference 等）。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>包含脚本资源的常量名（如 <literal>MyScript</literal> ，前提是声明了 <literal>const MyScript = preload("res://my_script.gd")</literal> ）。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>在同一个脚本中的其他内部类，此时需要注意作用域（比如：在相同作用域内，在 <literal>class InnerClass</literal> 中声明 <literal>class NestedClass</literal> 则会得到 <literal>InnerClass.NestedClass</literal> ）。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>通过 <literal>class_name</literal> 关键字声明的脚本类。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>自动加载的节点——单例节点。</paragraph>
                    </list_item>
                </bullet_list>
                <note>
                    <paragraph>虽然 <literal>Variant</literal> 类型被引擎视作有效类型，但其并不是一个确切的类型，只是一个“没有固定类型”的代名词。使用 <literal>Variant</literal> 类型很有可能会导致报错，因此引擎默认不会对该类型进行推断。</paragraph>
                    <paragraph>你可以在项目设置中将该检查关闭，或将其设为警告。详见 <reference internal="True" refuri="warning_system#doc-gdscript-warning-system"><inline classes="std std-ref">GDScript 警告系统</inline></reference>。</paragraph>
                </note>
                <section ids="initialization-order" names="initialization\ order 初始化顺序">
                    <title>初始化顺序</title>
                    <paragraph>成员变量的初始化顺序如下：</paragraph>
                    <enumerated_list enumtype="arabic" prefix="" suffix=".">
                        <list_item>
                            <paragraph>变量根据其静态类型，取值为 <literal>null</literal>（无类型变量和对象）或类型的默认值（<literal>int</literal>为 <literal>0</literal>、<literal>bool</literal>为<literal>false</literal>等）。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>根据脚本中变量的声明顺序，由上至下进行指定值的赋值。——<emphasis>（仅适用于派生自 ``Node`` 的类）</emphasis>如果变量由 <literal>@onready</literal> 注解修饰，则会推迟到第 5 步再初始化。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>所有非 <literal>@onready</literal> 成员变量均完成定义时调用 <literal>_init()</literal> 方法。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>初始化场景和资源时，赋导出的值。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><emphasis>（仅适用于派生自 ``Node`` 的类）</emphasis>初始化 <literal>@onready</literal> 变量。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><emphasis>（仅适用于派生自 ``Node`` 的类）</emphasis>所有 <literal>@onready</literal> 变量均完成定义时调用 <literal>_ready()</literal> 方法。</paragraph>
                        </list_item>
                    </enumerated_list>
                    <warning>
                        <paragraph>复杂表达式也能够作为变量的初始化器，其中也包括函数调用。请确保初始化变量时变量的声明顺序正确，否则对应的值可能会被覆盖。例如：</paragraph>
                        <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a: int = proxy("a", 1)
var b: int = proxy("b", 2)
var _data: Dictionary = {}

func proxy(key: String, value: int):
    _data[key] = value
    print(_data)
    return value

func _init() -&gt; void:
    print(_data)</literal_block>
                        <paragraph>会在控制台中打印出：</paragraph>
                        <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">{ "a": 1 }
{ "a": 1, "b": 2 }
{  }</literal_block>
                        <paragraph>解决这个问题只需将 <literal>_data</literal> 变量的定义移动到 <literal>a</literal> 的定义之前，或者移除空字典的赋值（<literal>={}</literal>）。</paragraph>
                    </warning>
                </section>
                <section ids="static-variables" names="static\ variables 静态变量">
                    <title>静态变量</title>
                    <paragraph>成员变量可以声明为静态成员变量：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">static var a</literal_block>
                    <paragraph>静态变量直属于类而非类的实例，即静态变量可以在多个类实例之间共享数据，这一点与一般的成员变量有所区别。</paragraph>
                    <paragraph>在类内，静态函数和非静态函数都可以访问静态变量。在类外，可以通过使用类名或类的实例来访问静态变量（后者并不推荐，因为可读性较低）。</paragraph>
                    <note>
                        <paragraph><literal>@export</literal> 注解和 <literal>@onready</literal> 注解不能修饰静态成员变量。局部变量不能声明为静态局部变量。</paragraph>
                    </note>
                    <paragraph>下例中，我们定义了一个 <literal>Person</literal> 类，声明了一个静态成员变量 <literal>max_id</literal> 。在游戏中，我们可以增加 <literal>max_id</literal> 这个静态成员变量来让我们更容易追踪游戏中 <literal>Person</literal> 实例的数量。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># person.gd
class_name Person

static var max_id = 0

var id
var name

func _init(p_name):
    max_id += 1
    id = max_id
    name = p_name</literal_block>
                    <paragraph>下面我们创建两个 <literal>Person</literal> 类的实例，会发现类和实例具有相同的 <literal>max_id</literal> 值，这是因为该成员变量是静态成员变量，能够在每个实例中访问。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># test.gd
extends Node

func _ready():
    var person1 = Person.new("John Doe")
    var person2 = Person.new("Jane Doe")

    print(person1.id) # 1
    print(person2.id) # 2

    print(Person.max_id)  # 2
    print(person1.max_id) # 2
    print(person2.max_id) # 2</literal_block>
                    <paragraph>静态变量可以指定类型、设置 setter 函数和 getter 函数：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">static var balance: int = 0

static var debt: int:
    get:
        return -balance
    set(value):
        balance = -value</literal_block>
                    <paragraph>父类的静态成员变量也可以在子类中访问：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">class A:
    static var x = 1

class B extends A:
    pass

func _ready():
    prints(A.x, B.x) # 1 1
    A.x = 2
    prints(A.x, B.x) # 2 2
    B.x = 3
    prints(A.x, B.x) # 3 3</literal_block>
                </section>
            </section>
            <section ids="static-unload-annotation" names="@static_unload\ annotation @static_unload\ 注解">
                <title><literal>@static_unload</literal> 注解</title>
                <paragraph>GDScript 的类均为资源，而静态变量会阻止脚本资源卸载，即便该脚本所对应的类的实例以及对该实例引用并不存在，静态变量依旧会阻止该脚本资源卸载。在静态变量存储大量数据，同时还含有对其他对象的引用（比如场景）的情况下，更需要引起格外重视。你需要手动清理掉这些数据，亦或是使用 <reference internal="True" refuri="../../../classes/class_@gdscript#class-gdscript-annotation-static-unload"><inline classes="std std-ref">@static_unload</inline></reference> 注解，让静态变量在不存储重要数据时得到重置。</paragraph>
                <warning>
                    <paragraph>目前由于某个漏洞导致含静态成员变量的脚本实例即使使用了 <literal>@static_unload</literal> 注解也无法被清除的问题。</paragraph>
                </warning>
                <paragraph>注意： <literal>@static_unload</literal> 注解修饰整个脚本（包括内部类），需置于脚本最开头，且位于 <literal>class_name</literal> 和 <literal>extends</literal> 关键字之前：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@static_unload
class_name MyNode
extends Node</literal_block>
                <paragraph>亦可见 <reference name="静态函数" refid="static-functions">静态函数</reference> 和 <reference name="静态构造函数" refid="static-constructor">静态构造函数</reference> 。</paragraph>
                <section ids="casting" names="casting 类型转换">
                    <title>类型转换</title>
                    <paragraph>赋予给指定了类型的变量的值必须具有与其类型相兼容的类型。若需要将值强制转换为特定类型，特别是对于对象类型而言要进行转型，则可以使用强制转型运算符 <literal>as</literal>。</paragraph>
                    <paragraph>如果值是对象类型，且为与目标类型相同的类型，亦或为目标类型的子类型，则进行转型后会得到同一个对象。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var my_node2D: Node2D
my_node2D = $Sprite2D as Node2D # Works since Sprite2D is a subtype of Node2D.</literal_block>
                    <paragraph>如果该值的类型不是目标类型的子类型，则强制转型操作将产生 <literal>null</literal> 值。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var my_node2D: Node2D
my_node2D = $Button as Node2D # Results in 'null' since a Button is not a subtype of Node2D.</literal_block>
                    <paragraph>对于内置类型，如果允许，则将对其进行强制转型，否则将触发报错。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var my_int: int
my_int = "123" as int # The string can be converted to int.
my_int = Vector2() as int # A Vector2 can't be converted to int, this will cause an error.</literal_block>
                    <paragraph>与场景树进行交互时，在获取节点这方面，强制转型也更加类型安全，十分有用：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Will infer the variable to be of type Sprite2D.
var my_sprite := $Character as Sprite2D

# Will fail if $AnimPlayer is not an AnimationPlayer, even if it has the method 'play()'.
($AnimPlayer as AnimationPlayer).play("walk")</literal_block>
                </section>
            </section>
            <section ids="constants" names="constants 常量">
                <title>常量</title>
                <paragraph>常量是游戏运行时不可更改的量，其值在编译时必须已知，可使用 <literal>const</literal> 关键字为常量值赋予名称。尝试为常量重新赋值将会触发报错。</paragraph>
                <paragraph>建议使用常量来储存不应更改的值。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">const A = 5
const B = Vector2(20, 20)
const C = 10 + 20 # Constant expression.
const D = Vector2(20, 30).x # Constant expression: 20.
const E = [1, 2, 3, 4][0] # Constant expression: 1.
const F = sin(20) # 'sin()' can be used in constant expressions.
const G = x + 20 # Invalid; this is not a constant expression!
const H = A + 20 # Constant expression: 25 (`A` is a constant).</literal_block>
                <paragraph>常量的类型虽然可以从赋予的值中推断出来，但也可以通过显式添加类型来指定：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">const A: int = 5
const B: Vector2 = Vector2()</literal_block>
                <paragraph>赋予与指定的类型不相容的值将触发报错。</paragraph>
                <paragraph>也可以在函数内使用常量来声明一些局部魔法值。</paragraph>
                <section ids="enums" names="enums 枚举">
                    <title>枚举</title>
                    <paragraph>枚举实质上是常量的简写，适用于为某些常量连续赋整数值。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">enum {TILE_BRICK, TILE_FLOOR, TILE_SPIKE, TILE_TELEPORT}

# Is the same as:
const TILE_BRICK = 0
const TILE_FLOOR = 1
const TILE_SPIKE = 2
const TILE_TELEPORT = 3</literal_block>
                    <paragraph>若将名称传递给枚举，则该枚举将会把所有键纳入该名称的 <reference internal="True" refuri="../../../classes/class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> 中，即字典中的所有常方法均可用于具名枚举当中。</paragraph>
                    <important>
                        <paragraph>从 Godot 3.1 开始，不会再将具名枚举的键注册为全局常量，此后，应在枚举常量前缀以枚举名的形式来访问枚举内的枚举常量（ <literal>Name.KEY</literal> ）；见后面的例子。</paragraph>
                    </important>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">enum State {STATE_IDLE, STATE_JUMP = 5, STATE_SHOOT}

# Is the same as:
const State = {STATE_IDLE = 0, STATE_JUMP = 5, STATE_SHOOT = 6}
# Access values with State.STATE_IDLE, etc.

func _ready():
    # Access values with Name.KEY, prints '5'
    print(State.STATE_JUMP)
    # Use dictionary methods:
    # prints '["STATE_IDLE", "STATE_JUMP", "STATE_SHOOT"]'
    print(State.keys())
    # prints '{ "STATE_IDLE": 0, "STATE_JUMP": 5, "STATE_SHOOT": 6 }'
    print(State)
    # prints '[0, 5, 6]'
    print(State.values())</literal_block>
                </section>
            </section>
            <section ids="functions" names="functions 函数">
                <title>函数</title>
                <paragraph>函数始终属于<reference name="类" refid="classes">类</reference><target names="类" refname="classes"></target>。查找变量时，函数作用域的查找顺序是：局部 → 类成员 → 全局。引擎始终允许用 <literal>self</literal> 作为访问本类及本类成员的关键字，但该关键字在一般情况下并无添加的必要（与 Python 不同，在 GDScript 中<emphasis>不应该</emphasis>将 <literal>self</literal> 作为函数的第一个参数传递）。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func my_function(a, b):
    print(a)
    print(b)
    return a + b  # Return is optional; without it 'null' is returned.</literal_block>
                <paragraph>函数可以在任何时候用 <literal>return</literal> 返回，默认的返回值为 <literal>null</literal>。</paragraph>
                <paragraph>若函数体只含一行语句，则可以将函数及其函数体缩在同一行语句内编写：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func square(a): return a * a

func hello_world(): print("Hello World")

func empty_function(): pass</literal_block>
                <paragraph>也可对函数参数及函数返回值进行类型指定。可使用与声明变量类似的方式添加参数的类型：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func my_function(a: int, b: String):
    pass</literal_block>
                <paragraph>如果函数参数具有默认值，则可以对该参数的类型进行推断：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func my_function(int_arg := 42, String_arg := "string"):
    pass</literal_block>
                <paragraph>可以在参数列表之后使用箭头标记（<literal>-&gt;</literal>）来指定函数的返回值类型：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func my_int_function() -&gt; int:
    return 0</literal_block>
                <paragraph>有返回类型的函数<strong>必须</strong>返回与返回值类型相匹配的值。将返回值类型设置为 <literal>void</literal> 表示该函数不返回任何东西。这种函数称为 void 函数，可以使用 <literal>return</literal> 关键字提前返回，但不能返回任何值。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func void_function() -&gt; void:
    return # Can't return a value.</literal_block>
                <note>
                    <paragraph>非 void 函数 <strong>必须</strong> 返回一个值，如果你的代码具有分支语句（例如 <literal>if</literal>/<literal>else</literal> 构造），则所有可能的路径都必须有返回值。例如，如果在 <literal>if</literal> 块内有一个 <literal>return</literal>，但在其后没有，则编辑器将抛出一个错误，因为如果该代码块未执行，那么该函数将没有值进行有效返回。</paragraph>
                </note>
                <section ids="referencing-functions" names="referencing\ functions 引用函数">
                    <title>引用函数</title>
                    <paragraph>就 <reference internal="True" refuri="../../../classes/class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> 对象而言，函数是其第一类对象。通过函数名称来引用一个函数，会自动生成指向该函数的可调用体，而非调用该函数。这种操作可用于将函数作为参数传递。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func map(arr: Array, function: Callable) -&gt; Array:
    var result = []
    for item in arr:
        result.push_back(function.call(item))
    return result

func add1(value: int) -&gt; int:
    return value + 1;

func _ready() -&gt; void:
    var my_array = [1, 2, 3]
    var plus_one = map(my_array, add1)
    print(plus_one) # Prints [2, 3, 4].</literal_block>
                    <note>
                        <paragraph>可调用体<strong>必须</strong>使用 <literal>call</literal> 方法进行调用，不能直接使用 <literal>()</literal> 运算符。实现这种行为是为了避免影响直接函数调用的性能。</paragraph>
                    </note>
                </section>
                <section ids="lambda-functions" names="lambda\ functions lambda\ 函数">
                    <title>Lambda 函数</title>
                    <paragraph>Lambda 函数允许声明不属于类的函数，直接创建 <reference internal="True" refuri="../../../classes/class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> 对象并将其赋值给变量，可以创建可传递的可调用体，同时又不会污染该类的作用范围，非常有用。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var lambda = func(x): print(x)
lambda.call(42) # Prints "42"</literal_block>
                    <paragraph>Lambda 函数还可用于代码调试：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var lambda = func my_lambda(x):
    print(x)</literal_block>
                    <paragraph>注意，若想要在 Lambda 函数中返回值，必须显式使用 <literal>return</literal> 关键字进行返回（即无法省略 <literal>return</literal>）</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var lambda = func(x): return x ** 2
print(lambda.call(2)) # Prints `4`.</literal_block>
                    <paragraph>局部变量是按值传递的，而Lambda 函数又会自动捕获其所在的函数体作用域。因此，这些局部变量即便在其所在的函数体作用域内发生更改，也不会影响其在 Lambda 函数中的效果：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var x = 42
var my_lambda = func(): print(x)
my_lambda.call() # Prints "42"
x = "Hello"
my_lambda.call() # Prints "42"</literal_block>
                    <note>
                        <paragraph>作用在 Lambda 函数体之外的变量值对该 Lambda 函数而言就像常量一样，如果你给变量声明了一个数组类型或字典类型的值，那么在 Lambda 函数的声明后面仍可修改这些值。</paragraph>
                    </note>
                </section>
                <section ids="static-functions" names="static\ functions 静态函数">
                    <title>静态函数</title>
                    <paragraph>函数可以声明为静态函数。静态函数不能访问实例成员变量，也不能使用 <literal>self</literal>，非常适用于创建辅助函数库：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">static func sum2(a, b):
    return a + b</literal_block>
                    <paragraph>Lambda 函数不可声明为静态函数。</paragraph>
                    <paragraph>见<reference name="静态变量" refid="static-variables">静态变量</reference>和<reference name="静态构造函数" refid="static-constructor">静态构造函数</reference>。</paragraph>
                </section>
            </section>
            <section ids="statements-and-control-flow" names="statements\ and\ control\ flow 语句与流程控制">
                <title>语句与流程控制</title>
                <paragraph>标准的语句可以是赋值、函数调用以及流程控制结构等（见下方）。 <literal>;</literal> 为语句分隔符，在使用时可写可略。</paragraph>
                <section ids="expressions" names="expressions 表达式">
                    <title>表达式</title>
                    <paragraph>表达式是运算符和操作数的有序排列，尽管表达式本身可以构成一个语句，但仅函数调用才适合作为语句使用，因为其他类型的表达式通常不会产生副作用。</paragraph>
                    <paragraph>表达式返回的数值可赋值给有效目标，而某些运算符的操作数也可以变成一条表达式。赋值语句因无返回值而不能作为表达式使用。</paragraph>
                    <paragraph>以下是一些表达式的示例:</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">2 + 2 # Binary operation.
-5 # Unary operation.
"okay" if x &gt; 4 else "not okay" # Ternary operation.
x # Identifier representing variable or constant.
x.a # Attribute access.
x[4] # Subscript access.
x &gt; 2 or x &lt; 5 # Comparisons and logic operators.
x == y + 2 # Equality test.
do_something() # Function call.
[1, 2, 3] # Array definition.
{A = 1, B = 2} # Dictionary definition.
preload("res://icon.png") # Preload builtin function.
self # Reference to current instance.</literal_block>
                    <paragraph>标识符、对象属性和下标均可视为表达式有效的赋值目标，而在赋值语句中，表达式不能位于赋值等号左侧。</paragraph>
                </section>
                <section ids="if-else-elif" names="if/else/elif">
                    <title>if/else/elif</title>
                    <paragraph>条件句通过使用 <literal>if</literal>/<literal>else</literal>/<literal>elif</literal> 语法创建。条件中的括号可写可不写。考虑到基于制表符缩进的性质，可以使用 <literal>elif</literal> 而非 <literal>else</literal>/<literal>if</literal> 来保持缩进级别相同。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">if (expression):
    statement(s)
elif (expression):
    statement(s)
else:
    statement(s)</literal_block>
                    <paragraph>短的语句可以与条件句写在同一行内：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">if 1 + 1 == 2: return 2 + 2
else:
    var x = 3 + 3
    return x</literal_block>
                    <paragraph>有时你可能希望基于布尔表达式来赋予不同的初始值，为此，三元表达式将派上用场：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var x = (value) if (expression) else (value)
y += 3 if y &lt; 10 else -1</literal_block>
                    <paragraph>可以通过嵌套三元 if 表达式来处理的超过两种可能性的情况。嵌套时，推荐把三元 if 表达式拆分为多行进行表达以保证代码的可读性：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var count = 0

var fruit = (
        "apple" if count == 2
        else "pear" if count == 1
        else "banana" if count == 0
        else "orange"
)
print(fruit)  # banana

# Alternative syntax with backslashes instead of parentheses (for multi-line expressions).
# Less lines required, but harder to refactor.
var fruit_alt = \
        "apple" if count == 2 \
        else "pear" if count == 1 \
        else "banana" if count == 0 \
        else "orange"
print(fruit_alt)  # banana</literal_block>
                    <paragraph>你可能还想要检查某个值是否包含在某些容器之中，可以通过 <literal>if</literal> 语句与 <literal>in</literal> 操作符组合来实现：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Check if a letter is in a string.
var text = "abc"
if 'b' in text: print("The string contains b")

# Check if a variable is contained within a node.
if "varName" in get_parent(): print("varName is defined in parent!")</literal_block>
                </section>
                <section ids="while" names="while">
                    <title>while</title>
                    <paragraph>一般的循环通过 <literal>while</literal> 语法创建，可以使用 <literal>break</literal> 来跳出整个循环，或者使用 <literal>continue</literal> 来跳出当前批次的循环并进入下一轮的循环当中（但会将该关键字下方所有在该循环体内的语句全部跳过）：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">while (expression):
    statement(s)</literal_block>
                </section>
                <section ids="for" names="for">
                    <title>for</title>
                    <paragraph>要迭代一个范围，例如数组或表，请使用 <emphasis>for</emphasis> 循环。迭代数组时，当前数组元素被存储在循环变量中。迭代字典时，<emphasis>键</emphasis> 被存储在循环变量中。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for x in [5, 7, 11]:
    statement # Loop iterates 3 times with 'x' as 5, then 7 and finally 11.

var dict = {"a": 0, "b": 1, "c": 2}
for i in dict:
    print(dict[i]) # Prints 0, then 1, then 2.

for i in range(3):
    statement # Similar to [0, 1, 2] but does not allocate an array.

for i in range(1, 3):
    statement # Similar to [1, 2] but does not allocate an array.

for i in range(2, 8, 2):
    statement # Similar to [2, 4, 6] but does not allocate an array.

for i in range(8, 2, -2):
    statement # Similar to [8, 6, 4] but does not allocate an array.

for c in "Hello":
    print(c) # Iterate through all characters in a String, print every letter on new line.

for i in 3:
    statement # Similar to range(3).

for i in 2.2:
    statement # Similar to range(ceil(2.2)).</literal_block>
                    <paragraph>若需要在数组迭代时对数组进行赋值操作，则推荐使用 <literal>for i in array.size()</literal> 来进行该操作。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for i in array.size():
    array[i] = "Hello World"</literal_block>
                    <paragraph>循环变量只属于该循环，为其赋值并不会更改数组的值。如果循环变量是通过引用传递的对象（如节点），则仍可通过调用其方法来操作所指向的对象。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for string in string_array:
    string = "Hello World" # This has no effect

for node in node_array:
    node.add_to_group("Cool_Group") # This has an effect</literal_block>
                </section>
                <section ids="match" names="match">
                    <title>match</title>
                    <paragraph><literal>match</literal> 语句用于分支流程的执行，相当于在许多其他语言中出现的 <literal>switch</literal> 语句，但提供了一些附加功能。</paragraph>
                    <warning>
                        <paragraph><literal>match</literal> 对类型的要求比 <literal>==</literal> 运算符更严格。例如 <literal>1</literal> 和 <literal>1.0</literal> 是<strong>不匹配</strong>的。唯一的例外是 <literal>String</literal> 和 <literal>StringName</literal> 的匹配：例如会认为字符串 <literal>"hello"</literal> 和 StringName <literal>&amp;"hello"</literal> 相等。</paragraph>
                    </warning>
                    <section ids="basic-syntax" names="basic\ syntax 基本语法">
                        <title>基本语法</title>
                        <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">match &lt;expression&gt;:
    &lt;pattern(s)&gt;:
        &lt;block&gt;
    &lt;pattern(s)&gt; when &lt;guard expression&gt;:
        &lt;block&gt;
    &lt;...&gt;</literal_block>
                    </section>
                    <section ids="crash-course-for-people-who-are-familiar-with-switch-statements" names="crash-course\ for\ people\ who\ are\ familiar\ with\ switch\ statements 给熟悉\ switch\ 语句的人提供的速成课程">
                        <title>给熟悉 switch 语句的人提供的速成课程</title>
                        <enumerated_list enumtype="arabic" prefix="" suffix=".">
                            <list_item>
                                <paragraph>将 <literal>switch</literal> 替换为 <literal>match</literal>。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>删除 <literal>case</literal>。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>删除 <literal>break</literal>。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>将 <literal>default</literal> 替换为单个下划线。</paragraph>
                            </list_item>
                        </enumerated_list>
                    </section>
                    <section ids="control-flow" names="control\ flow 流程控制">
                        <title>流程控制</title>
                        <paragraph>将值按从上到下的顺序为每个分支条件进行匹配，如果有一个分支条件匹配，则会执行第一个与之相应的分支条件，之后继续执行 <literal>match</literal> 语句下不含该分支条件的其他分支。</paragraph>
                        <note>
                            <paragraph>3.x 版本中， <literal>continue</literal> 在 <literal>match</literal> 语句中起着特殊作用，而在4.0版本中则移除了这一特殊作用。</paragraph>
                        </note>
                        <paragraph>可以使用以下模式类型：</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <definition_list>
                                    <definition_list_item>
                                        <term>字面量模式</term>
                                        <definition>
                                            <paragraph>匹配<reference name="字面量" refid="literals">字面量</reference><target names="字面量" refname="literals"></target>：</paragraph>
                                            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">match x:
    1:
        print("We are number one!")
    2:
        print("Two are better than one!")
    "test":
        print("Oh snap! It's a string!")</literal_block>
                                        </definition>
                                    </definition_list_item>
                                </definition_list>
                            </list_item>
                            <list_item>
                                <definition_list>
                                    <definition_list_item>
                                        <term>表达式模式</term>
                                        <definition>
                                            <paragraph>匹配表达式常量、标识符、或属性访问（<literal>A.B</literal>）：</paragraph>
                                            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">match typeof(x):
    TYPE_FLOAT:
        print("float")
    TYPE_STRING:
        print("text")
    TYPE_ARRAY:
        print("array")</literal_block>
                                        </definition>
                                    </definition_list_item>
                                </definition_list>
                            </list_item>
                            <list_item>
                                <definition_list>
                                    <definition_list_item>
                                        <term>通配符模式</term>
                                        <definition>
                                            <paragraph>匹配所有内容，用一个下划线来表示通配内容。</paragraph>
                                            <paragraph>可以与其他语言的 <literal>switch</literal> 语句中的 <literal>default</literal> 等效：</paragraph>
                                            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">match x:
    1:
        print("It's one!")
    2:
        print("It's one times two!")
    _:
        print("It's not 1 or 2. I don't care to be honest.")</literal_block>
                                        </definition>
                                    </definition_list_item>
                                </definition_list>
                            </list_item>
                            <list_item>
                                <definition_list>
                                    <definition_list_item>
                                        <term>绑定模式</term>
                                        <definition>
                                            <paragraph>绑定模式引入一个新的变量，与通配符模式类似匹配所有通配内容，并为该通配值提供一个名称，在数组和字典模式中特别有用：</paragraph>
                                            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">match x:
    1:
        print("It's one!")
    2:
        print("It's one times two!")
    var new_var:
        print("It's not 1 or 2, it's ", new_var)</literal_block>
                                        </definition>
                                    </definition_list_item>
                                </definition_list>
                            </list_item>
                            <list_item>
                                <definition_list>
                                    <definition_list_item>
                                        <term>数组模式</term>
                                        <definition>
                                            <paragraph>匹配一个数组，数组模式的每个元素本身都可以是一个模式，因此可以对其进行嵌套。</paragraph>
                                            <paragraph>首先检测数组的长度，其长度必须与语句块条件的数组长度相同，否则不匹配。</paragraph>
                                            <paragraph><strong>开放式数组</strong> : 通过使最后一个子模式为 <literal>..</literal> , 可以使被比较数组的长度超过语句块条件的数组的长度.</paragraph>
                                            <paragraph>每个子模式都必须用逗号分隔开来。</paragraph>
                                            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">match x:
    []:
        print("Empty array")
    [1, 3, "test", null]:
        print("Very specific array")
    [var start, _, "test"]:
        print("First element is ", start, ", and the last is \"test\"")
    [42, ..]:
        print("Open ended array")</literal_block>
                                        </definition>
                                    </definition_list_item>
                                </definition_list>
                            </list_item>
                            <list_item>
                                <definition_list>
                                    <definition_list_item>
                                        <term>字典模式</term>
                                        <definition>
                                            <paragraph>作用方式同数组模式，且每个键必须为一个常量模式。</paragraph>
                                            <paragraph>首先检测字典的大小，其大小必须与语句块条件的字典大小相同，否则不匹配。</paragraph>
                                            <paragraph><strong>开放式字典</strong> : 通过将最后一个子字样改为 <literal>..</literal> ，使被比较字典可以比语句块条件的字典更大。</paragraph>
                                            <paragraph>每个子模式都必须用逗号分隔开。</paragraph>
                                            <paragraph>若不指定键的值，则仅检查键的存在。</paragraph>
                                            <paragraph>值模式与键模式之间以 <literal>:</literal> 分隔。</paragraph>
                                            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">match x:
    {}:
        print("Empty dict")
    {"name": "Dennis"}:
        print("The name is Dennis")
    {"name": "Dennis", "age": var age}:
        print("Dennis is ", age, " years old.")
    {"name", "age"}:
        print("Has a name and an age, but it's not Dennis :(")
    {"key": "godotisawesome", ..}:
        print("I only checked for one entry and ignored the rest")</literal_block>
                                        </definition>
                                    </definition_list_item>
                                </definition_list>
                            </list_item>
                            <list_item>
                                <definition_list>
                                    <definition_list_item>
                                        <term>多重模式</term>
                                        <definition>
                                            <paragraph>你还可以用逗号来分隔同一语句块条件里的多个模式，这些模式不允许包含任何绑定。</paragraph>
                                            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">match x:
    1, 2, 3:
        print("It's 1 - 3")
    "Sword", "Splash potion", "Fist":
        print("Yep, you've taken damage")</literal_block>
                                        </definition>
                                    </definition_list_item>
                                </definition_list>
                            </list_item>
                        </bullet_list>
                    </section>
                    <section ids="pattern-guards" names="pattern\ guards 模式保护">
                        <title>模式保护</title>
                        <paragraph>在 <literal>match</literal> 结构中，每次只能执行其中一条分支，一旦有分支通过匹配，那么剩下的所有分支都将不再进行匹配。如果需要在多个分支中使用相同的匹配模式，或者想要避免由于模式过于宽泛而选择了其中一条错误的分支的话，那么可以使用模式保护语句，用 <literal>when</literal> 关键字引导：</paragraph>
                        <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">match point:
    [0, 0]:
        print("Origin")
    [_, 0]:
        print("Point on X-axis")
    [0, _]:
        print("Point on Y-axis")
    [var x, var y] when y == x:
        print("Point on line y = x")
    [var x, var y] when y == -x:
        print("Point on line y = -x")
    [var x, var y]:
        print("Point (%s, %s)" % [x, y])</literal_block>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>若当前分支没有匹配的模式，则保护表达式将不会执行，程序将自动转向下一条分支的模式进行匹配检查。</paragraph>
                            </list_item>
                            <list_item>
                                <paragraph>一旦识别到匹配的模式，相应的保护表达式便会执行，以决定是否执行该分支下的代码。</paragraph>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>若保护表达式结果为真，则执行该分支下的语句并跳出 <literal>match</literal> 结构。</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>若保护表达式结果为假，则程序将跳过当前分支，继续检查下一条分支的模式。</paragraph>
                                    </list_item>
                                </bullet_list>
                            </list_item>
                        </bullet_list>
                    </section>
                </section>
            </section>
            <section ids="classes" names="classes 类">
                <title>类</title>
                <paragraph>默认情况下，所有脚本文件都是未命名的类，这时只能使用文件的路径来引用这些无名类（相对路径或绝对路径）。如果你将脚本文件命名为 <literal>character.gd</literal>的话：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Inherit from 'character.gd'.

extends "res://path/to/character.gd"

# Load character.gd and create a new node instance from it.

var Character = load("res://path/to/character.gd")
var character_node = Character.new()</literal_block>
                <target refid="doc-gdscript-basics-class-name"></target>
            </section>
            <section ids="registering-named-classes doc-gdscript-basics-class-name" names="registering\ named\ classes 注册具名类 doc_gdscript_basics_class_name">
                <title>注册具名类</title>
                <paragraph>你也可以使用 <literal>class_name</literal> 关键字来为你的类起名，将其注册为 Godot 编辑器中的新类型。你还可以配合使用 <literal>@icon</literal> 注解，向其括号中输入图片的路径，来将该图片作为该类的图标使用。这样，你的类就会和新的图标一起显示在编辑器中：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># item.gd

@icon("res://interface/icons/item.png")
class_name Item
extends Node</literal_block>
                <image candidates="{'*': 'tutorials/scripting/gdscript/img/class_name_editor_register_example.png'}" uri="tutorials/scripting/gdscript/img/class_name_editor_register_example.png"></image>
                <tip>
                    <paragraph>SVG images that are used as custom node icons should have the
                        <strong>Editor &gt; Scale With Editor Scale</strong> and <strong>Editor &gt; Convert Icons With Editor Theme</strong>
                        <reference internal="True" refuri="../../assets_pipeline/importing_images#doc-importing-images-editor-import-options"><inline classes="std std-ref">import options</inline></reference> enabled. This allows
                        icons to follow the editor's scale and theming settings if the icons are designed with
                        the same color palette as Godot's own icons.</paragraph>
                </tip>
                <paragraph>这是一个类文件示例：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Saved as a file named 'character.gd'.

class_name Character


var health = 5


func print_health():
    print(health)


func print_this_script_three_times():
    print(get_script())
    print(ResourceLoader.load("res://character.gd"))
    print(Character)</literal_block>
                <paragraph>如果想要在声明类的同时让这个类继承自某个类，则可以将这两个关键字写在同一行内：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">class_name MyNode extends Node</literal_block>
                <note>
                    <paragraph>由于脚本可以在用户不知情的情况下在单独的线程中初始化，出于线程安全考虑，Godot 在每次创建实例时，引擎都会初始化非静态变量，其中就包括数组和字典。</paragraph>
                </note>
                <section ids="inheritance" names="inheritance 继承">
                    <title>继承</title>
                    <paragraph>类（以文件形式保存）可以继承自：</paragraph>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>全局类。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>另一个类文件。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>另一个类文件中的内部类。</paragraph>
                        </list_item>
                    </bullet_list>
                    <paragraph>不允许多重继承。</paragraph>
                    <paragraph>继承使用 <literal>extends</literal> 关键字：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Inherit/extend a globally available class.
extends SomeClass

# Inherit/extend a named class file.
extends "somefile.gd"

# Inherit/extend an inner class in another file.
extends "somefile.gd".SomeInnerClass</literal_block>
                    <note>
                        <paragraph>如果没有显式指定继承的类，则默认该类继承自 <reference internal="True" refuri="../../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference>。</paragraph>
                    </note>
                    <paragraph>要检查给定的实例是否继承自给定的类，可以使用 <literal>is</literal> 关键字：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Cache the enemy class.
const Enemy = preload("enemy.gd")

# [...]

# Use 'is' to check inheritance.
if entity is Enemy:
    entity.apply_damage()</literal_block>
                    <paragraph>要调用 <emphasis>基类</emphasis> （即当前类的 <literal>extends</literal> 关键字后的类）中的函数，请使用 <literal>super</literal> 关键字：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">super(args)</literal_block>
                    <paragraph>由于子类中的函数会替换基类中同名的函数，因此若仍然想调用在基类中的该函数，则可以使用 <literal>super</literal> 关键字：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func some_func(x):
    super(x) # Calls the same function on the super class.</literal_block>
                    <paragraph>若需要调用父类方法，可在 <literal>super</literal> 关键字后用英文句点连接父节点方法名（带括号）：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func overriding():
    return 0 # This overrides the method in the base class.

func dont_override():
    return super.overriding() # This calls the method as defined in the base class.</literal_block>
                    <warning>
                        <paragraph>开发者通常会误以为可以覆写引擎内的 <emphasis>非虚</emphasis> 方法，如 <literal>get_class()</literal> 、 <literal>queue_free()</literal> 等。出于技术性原因，暂不支持这种操作。</paragraph>
                        <paragraph>Godot 3 里的 GDScript 允许开发者 <emphasis>隐藏</emphasis> 引擎方法，而这些被隐藏后重新定义的方法却可以被其他 GDScript 脚本所调用，倘若该方法在引擎内部执行，那么引擎并不会执行你所“重新定义”的方法。</paragraph>
                        <paragraph>Godot 4 对 GDScript 内置方法调用机制进行了优化，隐藏方法再重新定义一个同名方法这招彻底行不通了。鉴于此，我们增添了 <literal>NATIVE_METHOD_OVERRIDE</literal> 警告选项，默认设置为一种抛错。我们强烈建议保持该选项开启，不要作为警告而忽略之。</paragraph>
                        <paragraph>不过需要注意：对于虚方法，比如 <literal>_ready()</literal>, <literal>_process()</literal> 以及其他虚方法（在文档中被标为 <literal>virtual</literal> 且以下划线开头的内置方法），则会进行覆写操作。虚方法是专门用于自定义引擎行为的方法，可被 GDScript 所覆写。信号、通知也可用于自定义引擎行为。</paragraph>
                    </warning>
                </section>
                <section ids="class-constructor" names="class\ constructor 类的构造函数">
                    <title>类的构造函数</title>
                    <paragraph>类的构造函数在类进行初始化时调用，在 GDScript 中构造函数为虚函数 <literal>_init</literal> 。若想要在构造函数中调用父类构造函数，同样可以使用 <literal>super</literal> 语法。需要注意：每个类都有一个隐式构造函数，始终由引擎调用，用于定义类变量的默认值，而 <literal>super</literal> 则用于显式调用构造函数：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _init(arg):
   super("some_default", arg) # Call the custom base constructor.</literal_block>
                    <paragraph>通过示例可以更好地说明这一点。考虑一下这种情况：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># state.gd (inherited class).
var entity = null
var message = null


func _init(e=null):
    entity = e


func enter(m):
    message = m


# idle.gd (inheriting class).
extends "state.gd"


func _init(e=null, m=null):
    super(e)
    # Do something with 'e'.
    message = m</literal_block>
                    <paragraph>这里有几点需要牢记：</paragraph>
                    <enumerated_list enumtype="arabic" prefix="" suffix=".">
                        <list_item>
                            <paragraph>如果被继承的类（<literal>State.gd</literal>）定义了一个带有参数（此处的 <literal>e</literal>）的 <literal>_init</literal> 构造函数，那么继承的类（<literal>Idle.gd</literal>）也<strong>必须</strong>定义 <literal>_init</literal> ，并且要将适当的参数从 <literal>State.gd</literal> 传递给 <literal>_init</literal>。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph><literal>Idle.gd</literal> 的构造函数的参数数量可以与基类 <literal>State.gd</literal> 的构造函数的参数数量有所不同。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>在上面的示例中，传递给 <literal>State.gd</literal> 构造函数的 <literal>e</literal> 与传递给 <literal>Idle.gd</literal> 的 <literal>e</literal> 是相同的。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>如果 <literal>Idle.gd</literal> 的 <literal>_init</literal> 构造函数不接受任何参数，即便该构造函数即便什么也不做，也仍然需要将一些值传递给 <literal>State.gd</literal> 父类。当然，我们除了可以给基类构造函数传变量之外，也可以传表达式，例如：</paragraph>
                            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># idle.gd

func _init():
    super(5)</literal_block>
                        </list_item>
                    </enumerated_list>
                </section>
                <section ids="static-constructor" names="static\ constructor 静态构造函数">
                    <title>静态构造函数</title>
                    <paragraph>静态构造函数用虚函数 <literal>_static_init</literal> 表示，该函数会在类被载入、静态变量初始化后自动调用：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">static var my_static_var = 1

static func _static_init():
    my_static_var = 2</literal_block>
                    <paragraph>静态构造函数不能含有任何参数，不能返回值。</paragraph>
                    <target refid="doc-gdscript-basics-inner-classes"></target>
                </section>
                <section ids="inner-classes doc-gdscript-basics-inner-classes" names="inner\ classes 内部类 doc_gdscript_basics_inner_classes">
                    <title>内部类</title>
                    <paragraph>类文件可以包含内部类。内部类使用 <literal>class</literal> 关键字定义，用 <literal>类名.new()</literal> 函数来进行实例化。</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Inside a class file.

# An inner class in this class file.
class SomeInnerClass:
    var a = 5


    func print_value_of_a():
        print(a)


# This is the constructor of the class file's main class.
func _init():
    var c = SomeInnerClass.new()
    c.print_value_of_a()</literal_block>
                    <target refid="doc-gdscript-classes-as-resources"></target>
                </section>
                <section ids="classes-as-resources doc-gdscript-classes-as-resources" names="classes\ as\ resources 类作为资源 doc_gdscript_classes_as_resources">
                    <title>类作为资源</title>
                    <paragraph>Classes stored as files are treated as <reference internal="True" refuri="../../../classes/class_gdscript#class-gdscript"><inline classes="std std-ref">GDScripts</inline></reference>. They
                        must be loaded from disk to access them in other classes. This is done using
                        either the <literal>load</literal> or <literal>preload</literal> functions (see below). Instancing of a loaded
                        class resource is done by calling the <literal>new</literal> function on the class object:</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Load the class resource when calling load().
var MyClass = load("myclass.gd")

# Preload the class only once at compile time.
const MyClass = preload("myclass.gd")


func _init():
    var a = MyClass.new()
    a.some_function()</literal_block>
                </section>
            </section>
            <section ids="exports" names="exports 导出">
                <title>导出</title>
                <note>
                    <paragraph>有关导出的文档已移至 <reference internal="True" refuri="gdscript_exports#doc-gdscript-exports"><inline classes="std std-ref">GDScript 导出属性</inline></reference>。</paragraph>
                </note>
                <target refid="doc-gdscript-basics-setters-getters"></target>
            </section>
            <section ids="properties-setters-and-getters doc-gdscript-basics-setters-getters" names="properties\ (setters\ and\ getters) 属性（setter\ 与\ getter） doc_gdscript_basics_setters_getters">
                <title>属性（setter 与 getter）</title>
                <paragraph>有时，你可能不止希望对类成员进行数据存储操作，甚至想要在更改成员值的时候对其进行有效性检查操作或运算操作。你也可能希望以某种方式对该类成员的访问进行封装。</paragraph>
                <paragraph>鉴于此，GDScript 提供了一套特别的语法，通过在变量定义后使用 <literal>set</literal>、<literal>get</literal> 关键字来对类成员属性的读写进行封装。这样一来，你就可以在 <literal>set</literal>（setter 函数）、<literal>get</literal>（getter 函数）语句块里定义代码，在该成员被读写时执行之。</paragraph>
                <paragraph>示例（以匿名 setter/getter 函数为例）:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var milliseconds: int = 0
var seconds: int:
    get:
        return milliseconds / 1000
    set(value):
        milliseconds = value * 1000</literal_block>
                <note>
                    <paragraph>与之前的 Godot 版本中的 <literal>setget</literal> 不同，即使在同一个类中进行访问（不管是否添加 <literal>self.</literal> 前缀），也<strong>始终</strong>会调用属性的 setter 和 getter（例外见下文） 。这样访问属性时的行为就一致了。如果你需要直接访问实际的值，请再添加一个变量用于直接访问，然后在属性相关的代码中使用这个变量的变量名。</paragraph>
                </note>
                <section ids="alternative-syntax" names="alternative\ syntax 替代方案（具名\ setter/getter\ 函数）">
                    <title>替代方案（具名 setter/getter 函数）</title>
                    <paragraph>若想从变量声明中分离 setter/getter 代码，亦或想在多个属性中共享这些代码，则可以借助现有的类函数来完成该操作：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var my_prop:
    get = get_my_prop, set = set_my_prop</literal_block>
                    <paragraph>也可以将这个写法缩在同一行内写：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var my_prop: get = get_my_prop, set = set_my_prop</literal_block>
                    <paragraph>Setter 函数和 Getter 函数在给一个变量定义时必须使用相同的定义格式，不允许混合使用这两种定义格式。</paragraph>
                    <note>
                        <paragraph>不允许对 <emphasis>匿名</emphasis>setter 函数和 getter 函数进行类型指定，以减少代码的重复抄写量。若变量含有指定的类型，则其 setter 函数的参数会自动转换到相同的类型，同时其 getter 函数的返回值类型也必须与该类型相配。具名 setter/getter 函数允许指定类型提示，但这些函数的设值/返回类型必须与该属性的类型或该类型的广义类型相配。</paragraph>
                    </note>
                </section>
                <section ids="when-setter-getter-is-not-called" names="when\ setter/getter\ is\ not\ called setter/getter\ 函数不会被调用的情况">
                    <title>Setter/getter 函数不会被调用的情况</title>
                    <paragraph>变量在进行初始化时，其初始值会直接赋予给该变量，包括 <literal>@onready</literal> 注解所修饰的变量也是如此。</paragraph>
                    <paragraph>在一个变量的 setter 函数和 getter 函数内访问该变量的变量名，会直接访问该变量所代表的成员属性，不会导致 setter 函数和 getter 函数被无限次迭代调用，同时避免了显式声明另一个变量：</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">signal changed(new_value)
var warns_when_changed = "some value":
    get:
        return warns_when_changed
    set(value):
        changed.emit(value)
        warns_when_changed = value</literal_block>
                    <paragraph>这种情况也同样适用于替代方案:</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var my_prop: set = set_my_prop

func set_my_prop(value):
    my_prop = value # No infinite recursion.</literal_block>
                    <warning>
                        <paragraph>在匿名 setter/getter 函数中调用具名 setter/getter 函数会导致无限递归调用，如下面的这个情况:</paragraph>
                        <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var my_prop:
    set(value):
        set_my_prop(value)

func set_my_prop(value):
    my_prop = value # Infinite recursion, since `set_my_prop()` is not the setter.</literal_block>
                    </warning>
                    <target refid="doc-gdscript-tool-mode"></target>
                </section>
            </section>
            <section ids="tool-mode doc-gdscript-tool-mode" names="tool\ mode 工具模式 doc_gdscript_tool_mode">
                <title>工具模式</title>
                <paragraph>默认情况下，脚本不会在编辑器内运行，只有更改导出的属性这一操作会在编辑器内运行。在某些情况下，我们确实希望这些代码能在编辑器中运行（只要这些代码不执行游戏逻辑，也可以手动避免之）。为此可以用 <literal>@tool</literal> 注解，必须将其写在文件的顶部：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@tool
extends Button

func _ready():
    print("Hello")</literal_block>
                <paragraph>详情见 <reference internal="True" refuri="../../plugins/running_code_in_the_editor#doc-running-code-in-the-editor"><inline classes="std std-ref">在编辑器中运行代码</inline></reference>。</paragraph>
                <warning>
                    <paragraph>由于工具脚本是在编辑器中运行代码的，故在工具脚本中使用 <literal>queue_free()</literal> 或 <literal>free()</literal> 释放节点时需要谨慎（尤其是对脚本所有者本身使用的时候更是如此）。对工具脚本滥用释放节点代码可能会导致编辑器崩溃。</paragraph>
                </warning>
                <target refid="doc-gdscript-basics-memory-management"></target>
            </section>
            <section ids="memory-management doc-gdscript-basics-memory-management" names="memory\ management 内存管理 doc_gdscript_basics_memory_management">
                <title>内存管理</title>
                <paragraph>Godot 通过实现引用计数来释放某些不再使用的实例，而非通过垃圾收集器（GC），或者需要纯手动管理内存释放来实现这一操作。<reference internal="True" refuri="../../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> 类（或继承该类的任何类，例如 <reference internal="True" refuri="../../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>）的任何实例在不再使用时将自动释放。对于非 <reference internal="True" refuri="../../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> 类（例如 <reference internal="True" refuri="../../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> 或基本 <reference internal="True" refuri="../../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference> 类型）的实例，这些实例将保留在内存中，直到使用 <literal>free()</literal> （或用于节点的 <literal>queue_free()</literal>）才会从内存中删除。</paragraph>
                <note>
                    <paragraph>如果通过 <literal>free()</literal> 或 <literal>queue_free()</literal> 删除 <reference internal="True" refuri="../../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference>，则它的所有子节点也将会被递归删除。</paragraph>
                </note>
                <paragraph>为了避免造成无法释放的循环引用，Godot 提供了用于创建弱引用的 <reference internal="True" refuri="../../../classes/class_weakref#class-weakref"><inline classes="std std-ref">WeakRef</inline></reference> 类，可以访问到对象，但是不会阻止 <reference internal="True" refuri="../../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> 的释放。见下例：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node

var my_file_ref

func _ready():
    var f = FileAccess.open("user://example_file.json", FileAccess.READ)
    my_file_ref = weakref(f)
    # the FileAccess class inherits RefCounted, so it will be freed when not in use

    # the WeakRef will not prevent f from being freed when other_node is finished
    other_node.use_file(f)

func _this_is_called_later():
    var my_file = my_file_ref.get_ref()
    if my_file:
        my_file.close()</literal_block>
                <paragraph>在没有使用引用的情况下，也可以用 <literal>is_instance_valid(instance)</literal> 来检查对象是否已被释放。</paragraph>
                <target refid="doc-gdscript-signals"></target>
            </section>
            <section ids="signals doc-gdscript-signals" names="signals 信号 doc_gdscript_signals">
                <title>信号</title>
                <paragraph>信号是从对象中发出消息的工具，其他对象可以对该信号做出反应。要为一个类创建自定义信号，请使用 <literal>signal</literal> 关键字。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node


# A signal named health_depleted.
signal health_depleted</literal_block>
                <note>
                    <paragraph>信号是一种<reference name="回调" refuri="https://zh.wikipedia.org/zh-cn/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">回调</reference><target ids="id1" names="回调" refuri="https://zh.wikipedia.org/zh-cn/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"></target>机制，同时还充当观察者的角色，这是一种常见的编程模式。有关更多信息，请阅读《游戏编程模式》电子书中的<reference name="观察者教程" refuri="https://gameprogrammingpatterns.com/observer.html">观察者教程</reference><target ids="id2" names="观察者教程" refuri="https://gameprogrammingpatterns.com/observer.html"></target>。</paragraph>
                </note>
                <paragraph>你可以将这些信号连接到方法，就像连接 <reference internal="True" refuri="../../../classes/class_button#class-button"><inline classes="std std-ref">Button</inline></reference> 或 <reference internal="True" refuri="../../../classes/class_rigidbody3d#class-rigidbody3d"><inline classes="std std-ref">RigidBody3D</inline></reference> 等节点的内置信号一样。</paragraph>
                <paragraph>在下面的示例中，我们将 <literal>Character</literal> 节点的 <literal>health_depleted</literal> 信号连接到 <literal>Game</literal> 节点上。当 <literal>Character</literal> 节点发出信号时，Game 节点的 <literal>_on_character_health_depleted</literal> 就会被调用：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># game.gd

func _ready():
    var character_node = get_node('Character')
    character_node.health_depleted.connect(_on_character_health_depleted)


func _on_character_health_depleted():
    get_tree().reload_current_scene()</literal_block>
                <paragraph>可以在发出一个信号时给该信号附带任意数量的参数。</paragraph>
                <paragraph>下面这个示例就是该特性的一个不错的实现。假设我们希望屏幕上的生命条能够通过动画对生命值做出反应，但我们希望在场景树中让用户界面与游戏角色保持独立。</paragraph>
                <paragraph>在我们的 <literal>character.gd</literal> 脚本中，我们定义了一个 <literal>health_changed</literal> 信号并使用 <reference internal="True" refuri="../../../classes/class_signal#class-signal-method-emit"><inline classes="std std-ref">Signal.emit()</inline></reference> 发出它，并从我们场景树中更高的 <literal>Game</literal> 节点发出，我们使用 <reference internal="True" refuri="../../../classes/class_signal#class-signal-method-connect"><inline classes="std std-ref">Signal.connect()</inline></reference> 方法将其连接到 <literal>Lifebar</literal>：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># character.gd

...
signal health_changed


func take_damage(amount):
    var old_health = health
    health -= amount

    # We emit the health_changed signal every time the
    # character takes damage.
    health_changed.emit(old_health, health)
...</literal_block>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># lifebar.gd

# Here, we define a function to use as a callback when the
# character's health_changed signal is emitted.

...
func _on_Character_health_changed(old_value, new_value):
    if old_value &gt; new_value:
        progress_bar.modulate = Color.RED
    else:
        progress_bar.modulate = Color.GREEN

    # Imagine that `animate` is a user-defined function that animates the
    # bar filling up or emptying itself.
    progress_bar.animate(old_value, new_value)
...</literal_block>
                <paragraph>在 <literal>Game</literal> 节点中，我们同时获得 <literal>Character</literal> 和 <literal>Lifebar</literal> 节点，然后将发出信号的 <literal>Character</literal> 连接到接收者节点上，在本例中 <literal>Lifebar</literal> 为这一接收者节点。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># game.gd

func _ready():
    var character_node = get_node('Character')
    var lifebar_node = get_node('UserInterface/Lifebar')

    character_node.health_changed.connect(lifebar_node._on_Character_health_changed)</literal_block>
                <paragraph>这样 <literal>Lifebar</literal> 就能够对生命值的变化做出反应，无需将其耦合到 <literal>Character</literal> 节点内。</paragraph>
                <paragraph>可以在信号的定义后面添加括号，并在该括号内写入可选的参数名称：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Defining a signal that forwards two arguments.
signal health_changed(old_value, new_value)</literal_block>
                <paragraph>这些参数会显示在编辑器的节点面板中，Godot 会在生成回调函数时自动为你添加这些参数。但是，在发出信号时仍然可以发出任意数量的参数，需要由你来确定该信号需要准确发出的值。</paragraph>
                <image candidates="{'*': 'tutorials/scripting/gdscript/img/gdscript_basics_signals_node_tab_1.png'}" uri="tutorials/scripting/gdscript/img/gdscript_basics_signals_node_tab_1.png"></image>
                <paragraph>GDScript 可以将一组值绑定到信号和方法之间的连接之上。发出信号时，回调方法将会接收这组绑定值。这些绑定参数对于每个连接都是唯一的，且其值均保持不变。</paragraph>
                <paragraph>若发出的信号本身不能让你访问所需的所有数据，则可以使用这组数值将额外的常量信息添加到连接当中。</paragraph>
                <paragraph>接着上面的示例，我们要在屏幕上显示每个角色受到的伤害，例如 <literal>Player1 遭受了 22 伤害。</literal>。然而 <literal>health_changed</literal> 信号并没有给我们提供受到伤害的角色的名称。因此，在我们将信号连接到游戏终端上时，可以在绑定参数这组数据中添加该角色的名称：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># game.gd

func _ready():
    var character_node = get_node('Character')
    var battle_log_node = get_node('UserInterface/BattleLog')

    character_node.health_changed.connect(battle_log_node._on_Character_health_changed.bind(character_node.name))</literal_block>
                <paragraph>我们的 <literal>BattleLog</literal> 节点接收信号时，将绑定参数这个数组中的每个元素作为额外的参数传入被连接的函数当中：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># battle_log.gd

func _on_Character_health_changed(old_value, new_value, character_name):
    if not new_value &lt;= old_value:
        return

    var damage = old_value - new_value
    label.text += character_name + " took " + str(damage) + " damage."</literal_block>
            </section>
            <section ids="awaiting-signals-or-coroutines" names="awaiting\ signals\ or\ coroutines">
                <title>Awaiting signals or coroutines</title>
                <paragraph><literal>await</literal> 关键字可以用来创建<reference name="协程" refuri="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B">协程</reference><target ids="id1" names="协程" refuri="https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B"></target>，会等待某个信号发出之后再继续执行下面的代码。对信号或者对同为协程的函数调用使用 <literal>await</literal> 关键字会立即将控制权返回给调用方。发出信号时（或者调用的协程函数完成时），就会从停止的地方继续往下执行代码。</paragraph>
                <paragraph>例如，要暂停代码执行，直到到用户按下某个按钮后才能继续往下执行剩余代码，你就可以这样写：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func wait_confirmation():
    print("Prompting user")
    await $Button.button_up # Waits for the button_up signal from Button node.
    print("User confirmed")
    return true</literal_block>
                <paragraph>In this case, the <literal>wait_confirmation</literal> becomes a coroutine, which means that the caller also needs to await it:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func request_confirmation():
    print("Will ask the user")
    var confirmed = await wait_confirmation()
    if confirmed:
        print("User confirmed")
    else:
        print("User cancelled")</literal_block>
                <paragraph>需要注意：在请求协程函数的返回值时，不带 <literal>await</literal> 将会触发报错：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func wrong():
    var confirmed = wait_confirmation() # Will give an error.</literal_block>
                <paragraph>如果你不需要结果，直接异步调用就可以了，既不会阻止代码的正常运行，也不会让当前的函数变成协程函数：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func okay():
    wait_confirmation()
    print("This will be printed immediately, before the user press the button.")</literal_block>
                <paragraph>若对不是信号和协程函数的表达式使用 await，则会立即返回对应的值，函数也不会将控制权转交回调用方：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func no_wait():
    var x = await get_five()
    print("This doesn't make this function a coroutine.")

func get_five():
    return 5</literal_block>
                <paragraph>This also means that returning a signal from a function that isn't a coroutine will make the caller await that signal:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func get_signal():
    return $Button.button_up

func wait_button():
    await get_signal()
    print("Button was pressed")</literal_block>
                <note>
                    <paragraph>与之前版本 Godot 中的 <literal>yield</literal> 不同，出于类型安全的考虑，现版本无法获取函数状态对象。实现了这种类型安全之后，就不能说函数在返回 <literal>int</literal> 的同时还可能在运行时返回函数状态对象了。</paragraph>
                </note>
            </section>
            <section ids="assert-keyword" names="assert\ keyword assert\ 关键字">
                <title>Assert 关键字</title>
                <paragraph><literal>assert</literal> 关键字可用于在调试版本中检查断言条件，而在非调试版本中则会忽略掉这些断言，意味着在发布模式下导出的项目中断言语法不会评估作为参数传递的表达式。因此，断言 <strong>决不能</strong> 包含具有副作用的表达式，否则，脚本的行为将取决于该项目是否在调试版本中运行。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Check that 'i' is 0. If 'i' is not 0, an assertion error will occur.
assert(i == 0)</literal_block>
                <paragraph>在编辑器中运行项目时，如果发生断言错误，则会暂停该项目的运行。</paragraph>
                <paragraph>你还可以传入自定义错误消息，这些消息会在断言失败时显示：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">assert(enemy_power &lt; 256, "Enemy is too powerful!")</literal_block>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
