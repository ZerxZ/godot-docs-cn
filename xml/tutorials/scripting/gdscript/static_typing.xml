<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/gdscript/static_typing.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-gdscript-static-typing"></target>
    <section ids="static-typing-in-gdscript doc-gdscript-static-typing" names="static\ typing\ in\ gdscript doc_gdscript_static_typing">
        <title>Static typing in GDScript</title>
        <paragraph>In this guide, you will learn:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>how to use static typing in GDScript;</paragraph>
            </list_item>
            <list_item>
                <paragraph>that static types can help you avoid bugs;</paragraph>
            </list_item>
            <list_item>
                <paragraph>that static typing improves your experience with the editor.</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>Where and how you use this language feature is entirely up to you: you can use it
            only in some sensitive GDScript files, use it everywhere, or don't use it at all.</paragraph>
        <paragraph>Static types can be used on variables, constants, functions, parameters,
            and return types.</paragraph>
        <section ids="a-brief-look-at-static-typing" names="a\ brief\ look\ at\ static\ typing">
            <title>A brief look at static typing</title>
            <paragraph>With static typing, GDScript can detect more errors without even running the code.
                Also type hints give you and your teammates more information as you're working,
                as the arguments' types show up when you call a method. Static typing improves
                editor autocompletion and <reference internal="True" refuri="gdscript_documentation_comments#doc-gdscript-documentation-comments"><inline classes="std std-ref">documentation</inline></reference>
                of your scripts.</paragraph>
            <paragraph>Imagine you're programming an inventory system. You code an <literal>Item</literal> class,
                then an <literal>Inventory</literal>. To add items to the inventory, the people who work with
                your code should always pass an <literal>Item</literal> to the <literal>Inventory.add()</literal> method.
                With types, you can enforce this:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">class_name Inventory


func add(reference: Item, amount: int = 1):
    var item := find_item(reference)
    if not item:
        item = _instance_item_from_db(reference)
    item.amount += amount</literal_block>
            <paragraph>Static types also give you better code completion options. Below, you can see
                the difference between a dynamic and a static typed completion options.</paragraph>
            <paragraph>You've probably encountered a lack of autocomplete suggestions after a dot:</paragraph>
            <figure>
                <image alt="Completion options for dynamic typed code." candidates="{'*': 'tutorials/scripting/gdscript/img/typed_gdscript_code_completion_dynamic.webp'}" original_uri="img/typed_gdscript_code_completion_dynamic.webp" uri="tutorials/scripting/gdscript/img/typed_gdscript_code_completion_dynamic.webp"></image>
            </figure>
            <paragraph>This is due to dynamic code. Godot cannot know what value type you're passing
                to the function. If you write the type explicitly however, you will get all
                methods, properties, constants, etc. from the value:</paragraph>
            <figure>
                <image alt="Completion options for static typed code." candidates="{'*': 'tutorials/scripting/gdscript/img/typed_gdscript_code_completion_typed.webp'}" original_uri="img/typed_gdscript_code_completion_typed.webp" uri="tutorials/scripting/gdscript/img/typed_gdscript_code_completion_typed.webp"></image>
            </figure>
            <tip>
                <paragraph>If you prefer static typing, we recommend enabling the
                    <strong>Text Editor &gt; Completion &gt; Add Type Hints</strong> editor setting. Also consider
                    enabling <reference name="some warnings" refid="warning-system">some warnings</reference><target names="some\ warnings" refid="warning-system"></target> that are disabled by default.</paragraph>
            </tip>
            <comment xml:space="preserve">UPDATE: Planned feature. If JIT/AOT are implemented, update this paragraph.</comment>
            <paragraph>Also, typed GDScript improves performance by using optimized opcodes when operand/argument
                types are known at compile time. More GDScript optimizations are planned in the future,
                such as JIT/AOT compilation.</paragraph>
            <paragraph>Overall, typed programming gives you a more structured experience. It
                helps prevent errors and improves the self-documenting aspect of your
                scripts. This is especially helpful when you're working in a team or on
                a long-term project: studies have shown that developers spend most of
                their time reading other people's code, or scripts they wrote in the
                past and forgot about. The clearer and the more structured the code, the
                faster it is to understand, the faster you can move forward.</paragraph>
        </section>
        <section ids="how-to-use-static-typing" names="how\ to\ use\ static\ typing">
            <title>How to use static typing</title>
            <paragraph>To define the type of a variable, parameter, or constant, write a colon after the name,
                followed by its type. E.g. <literal>var health: int</literal>. This forces the variable's type
                to always stay the same:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var damage: float = 10.5
const MOVE_SPEED: float = 50.0
func sum(a: float = 0.0, b: float = 0.0) -&gt; float:
    return a + b</literal_block>
            <paragraph>Godot will try to infer types if you write a colon, but you omit the type:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var damage := 10.5
const MOVE_SPEED := 50.0
func sum(a := 0.0, b := 0.0) -&gt; float:
    return a + b</literal_block>
            <note>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>There is no difference between <literal>=</literal> and <literal>:=</literal> for constants.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>You don't need to write type hints for constants, as Godot sets it automatically
                            from the assigned value. But you can still do so to make the intent of your code clearer.
                            Also, this is useful for typed arrays (like <literal>const A: Array[int] = [1, 2, 3]</literal>),
                            since untyped arrays are used by default.</paragraph>
                    </list_item>
                </enumerated_list>
            </note>
            <section ids="what-can-be-a-type-hint" names="what\ can\ be\ a\ type\ hint">
                <title>What can be a type hint</title>
                <paragraph>Here is a complete list of what can be used as a type hint:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph><literal>Variant</literal>. Any type. In most cases this is not much different from an untyped
                            declaration, but increases readability. As a return type, forces the function
                            to explicitly return some value.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><emphasis>(Only return type)</emphasis> <literal>void</literal>. Indicates that the function does not return any value.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="True" refuri="gdscript_basics#doc-gdscript-builtin-types"><inline classes="std std-ref">Built-in types</inline></reference>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Native classes (<literal>Object</literal>, <literal>Node</literal>, <literal>Area2D</literal>, <literal>Camera2D</literal>, etc.).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="True" refuri="gdscript_basics#doc-gdscript-basics-class-name"><inline classes="std std-ref">Global classes</inline></reference>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference internal="True" refuri="gdscript_basics#doc-gdscript-basics-inner-classes"><inline classes="std std-ref">Inner classes</inline></reference>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Global, native and custom named enums. Note that an enum type is just an <literal>int</literal>,
                            there is no guarantee that the value belongs to the set of enum values.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Constants (including local ones) if they contain a preloaded class or enum.</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>You can use any class, including your custom classes, as types. There are two ways
                    to use them in scripts. The first method is to preload the script you want to use
                    as a type in a constant:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">const Rifle = preload("res://player/weapons/rifle.gd")
var my_rifle: Rifle</literal_block>
                <paragraph>The second method is to use the <literal>class_name</literal> keyword when you create.
                    For the example above, your <literal>rifle.gd</literal> would look like this:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">class_name Rifle
extends Node2D</literal_block>
                <paragraph>If you use <literal>class_name</literal>, Godot registers the <literal>Rifle</literal> type globally in the editor,
                    and you can use it anywhere, without having to preload it into a constant:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var my_rifle: Rifle</literal_block>
            </section>
            <section ids="specify-the-return-type-of-a-function-with-the-arrow" names="specify\ the\ return\ type\ of\ a\ function\ with\ the\ arrow\ -&gt;">
                <title>Specify the return type of a function with the arrow <literal>-&gt;</literal></title>
                <paragraph>To define the return type of a function, write a dash and a right angle bracket <literal>-&gt;</literal>
                    after its declaration, followed by the return type:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _process(delta: float) -&gt; void:
    pass</literal_block>
                <paragraph>The type <literal>void</literal> means the function does not return anything. You can use any type,
                    as with variables:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func hit(damage: float) -&gt; bool:
    health_points -= damage
    return health_points &lt;= 0</literal_block>
                <paragraph>You can also use your own classes as return types:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Adds an item to the inventory and returns it.
func add(reference: Item, amount: int) -&gt; Item:
    var item: Item = find_item(reference)
    if not item:
        item = ItemDatabase.get_instance(reference)

    item.amount += amount
    return item</literal_block>
            </section>
            <section ids="covariance-and-contravariance" names="covariance\ and\ contravariance">
                <title>Covariance and contravariance</title>
                <paragraph>When inheriting base class methods, you should follow the <reference name="Liskov substitution principle" refuri="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution
                        principle</reference>.</paragraph>
                <paragraph><strong>Covariance:</strong> When you inherit a method, you can specify a return type that is
                    more specific (<strong>subtype</strong>) than the parent method.</paragraph>
                <paragraph><strong>Contravariance:</strong> When you inherit a method, you can specify a parameter type
                    that is less specific (<strong>supertype</strong>) than the parent method.</paragraph>
                <paragraph>Example:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">class_name Parent


func get_property(param: Label) -&gt; Node:
    # ...</literal_block>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">class_name Child extends Parent


# `Control` is a supertype of `Label`.
# `Node2D` is a subtype of `Node`.
func get_property(param: Control) -&gt; Node2D:
    # ...</literal_block>
            </section>
            <section ids="specify-the-element-type-of-an-array" names="specify\ the\ element\ type\ of\ an\ array">
                <title>Specify the element type of an <literal>Array</literal></title>
                <paragraph>To define the type of an <literal>Array</literal>, enclose the type name in <literal>[]</literal>.</paragraph>
                <paragraph>An array's type applies to <literal>for</literal> loop variables, as well as some operators like
                    <literal>[]</literal>, <literal>[...] =</literal> (assignment), and <literal>+</literal>. Array methods
                    (such as <literal>push_back</literal>) and other operators (such as <literal>==</literal>)
                    are still untyped. Built-in types, native and custom classes,
                    and enums may be used as element types. Nested array types (like <literal>Array[Array[int]]</literal>)
                    are not supported.</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var scores: Array[int] = [10, 20, 30]
var vehicles: Array[Node] = [$Car, $Plane]
var items: Array[Item] = [Item.new()]
var array_of_arrays: Array[Array] = [[], []]
# var arrays: Array[Array[int]] -- disallowed

for score in scores:
    # score has type `int`

# The following would be errors:
scores += vehicles
var s: String = scores[0]
scores[0] = "lots"</literal_block>
                <paragraph>Since Godot 4.2, you can also specify a type for the loop variable in a <literal>for</literal> loop.
                    For instance, you can write:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var names = ["John", "Marta", "Samantha", "Jimmy"]
for name: String in names:
    pass</literal_block>
                <paragraph>The array will remain untyped, but the <literal>name</literal> variable within the <literal>for</literal> loop
                    will always be of <literal>String</literal> type.</paragraph>
            </section>
            <section ids="specify-the-element-type-of-a-dictionary" names="specify\ the\ element\ type\ of\ a\ dictionary">
                <title>Specify the element type of a <literal>Dictionary</literal></title>
                <paragraph>To define the type of a <literal>Dictionary</literal>'s keys and values, enclose the type name in <literal>[]</literal>
                    and separate the key and value type with a comma.</paragraph>
                <paragraph>A dictionary's value type applies to <literal>for</literal> loop variables, as well as some operators like
                    <literal>[]</literal> and <literal>[...] =</literal> (assignment). Dictionary methods that return values
                    and other operators (such as <literal>==</literal>) are still untyped. Built-in types, native
                    and custom classes, and enums may be used as element types. Nested typed collections
                    (like <literal>Dictionary[String, Dictionary[String, int]]</literal>) are not supported.</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var fruit_costs: Dictionary[String, int] = { "apple": 5, "orange": 10 }
var vehicles: Dictionary[String, Node] = { "car": $Car, "plane": $Plane }
var item_tiles: Dictionary[Vector2i, Item] = { Vector2i(0, 0): Item.new(), Vector2i(0, 1): Item.new() }
var dictionary_of_dictionaries: Dictionary[String, Dictionary] = { { } }
# var dicts: Dictionary[String, Dictionary[String, int]] -- disallowed

for cost in fruit_costs:
    # cost has type `int`

# The following would be errors:
fruit_costs["pear"] += vehicles
var s: String = fruit_costs["apple"]
fruit_costs["orange"] = "lots"</literal_block>
            </section>
            <section ids="type-casting" names="type\ casting">
                <title>Type casting</title>
                <paragraph>Type casting is an important concept in typed languages.
                    Casting is the conversion of a value from one type to another.</paragraph>
                <paragraph>Imagine an <literal>Enemy</literal> in your game, that <literal>extends Area2D</literal>. You want it to collide
                    with the <literal>Player</literal>, a <literal>CharacterBody2D</literal> with a script called <literal>PlayerController</literal>
                    attached to it. You use the <literal>body_entered</literal> signal to detect the collision.
                    With typed code, the body you detect is going to be a generic <literal>PhysicsBody2D</literal>,
                    and not your <literal>PlayerController</literal> on the <literal>_on_body_entered</literal> callback.</paragraph>
                <paragraph>You can check if this <literal>PhysicsBody2D</literal> is your <literal>Player</literal> with the <literal>as</literal> keyword,
                    and using the colon <literal>:</literal> again to force the variable to use this type.
                    This forces the variable to stick to the <literal>PlayerController</literal> type:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_body_entered(body: PhysicsBody2D) -&gt; void:
    var player := body as PlayerController
    if not player:
        return

    player.damage()</literal_block>
                <paragraph>As we're dealing with a custom type, if the <literal>body</literal> doesn't extend
                    <literal>PlayerController</literal>, the <literal>player</literal> variable will be set to <literal>null</literal>.
                    We can use this to check if the body is the player or not. We will also
                    get full autocompletion on the player variable thanks to that cast.</paragraph>
                <note>
                    <paragraph>The <literal>as</literal> keyword silently casts the variable to <literal>null</literal> in case of a type
                        mismatch at runtime, without an error/warning. While this may be convenient
                        in some cases, it can also lead to bugs. Use the <literal>as</literal> keyword only if this
                        behavior is intended. A safer alternative is to use the <literal>is</literal> keyword:</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">if not (body is PlayerController):
    push_error("Bug: body is not PlayerController.")

var player: PlayerController = body
if not player:
    return

player.damage()</literal_block>
                    <paragraph>You can also simplify the code by using the <literal>is not</literal> operator:</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">if body is not PlayerController:
    push_error("Bug: body is not PlayerController")</literal_block>
                    <paragraph>Alternatively, you can use the <literal>assert()</literal> statement:</paragraph>
                    <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">assert(body is PlayerController, "Bug: body is not PlayerController.")

var player: PlayerController = body
if not player:
    return

player.damage()</literal_block>
                </note>
                <note>
                    <paragraph>If you try to cast with a built-in type and it fails, Godot will throw an error.</paragraph>
                </note>
                <target refid="doc-gdscript-static-typing-safe-lines"></target>
                <section ids="safe-lines doc-gdscript-static-typing-safe-lines" names="safe\ lines doc_gdscript_static_typing_safe_lines">
                    <title>Safe lines</title>
                    <paragraph>You can also use casting to ensure safe lines. Safe lines are a tool to tell you
                        when ambiguous lines of code are type-safe. As you can mix and match typed
                        and dynamic code, at times, Godot doesn't have enough information to know if
                        an instruction will trigger an error or not at runtime.</paragraph>
                    <paragraph>This happens when you get a child node. Let's take a timer for example:
                        with dynamic code, you can get the node with <literal>$Timer</literal>. GDScript supports
                        <reference name="duck-typing" refuri="https://stackoverflow.com/a/4205163/8125343">duck-typing</reference>,
                        so even if your timer is of type <literal>Timer</literal>, it is also a <literal>Node</literal> and
                        an <literal>Object</literal>, two classes it extends. With dynamic GDScript, you also don't
                        care about the node's type as long as it has the methods you need to call.</paragraph>
                    <paragraph>You can use casting to tell Godot the type you expect when you get a node:
                        <literal>($Timer as Timer)</literal>, <literal>($Player as CharacterBody2D)</literal>, etc.
                        Godot will ensure the type works and if so, the line number will turn
                        green at the left of the script editor.</paragraph>
                    <figure ids="id1">
                        <image alt="Unsafe vs Safe Line" candidates="{'*': 'tutorials/scripting/gdscript/img/typed_gdscript_safe_unsafe_line.webp'}" original_uri="img/typed_gdscript_safe_unsafe_line.webp" uri="tutorials/scripting/gdscript/img/typed_gdscript_safe_unsafe_line.webp"></image>
                        <caption>Unsafe line (line 7) vs Safe Lines (line 6 and 8)</caption>
                    </figure>
                    <note>
                        <paragraph>Safe lines do not always mean better or more reliable code. See the note above
                            about the <literal>as</literal> keyword. For example:</paragraph>
                        <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@onready var node_1 := $Node1 as Type1 # Safe line.
@onready var node_2: Type2 = $Node2 # Unsafe line.</literal_block>
                        <paragraph>Even though <literal>node_2</literal> declaration is marked as an unsafe line, it is more
                            reliable than <literal>node_1</literal> declaration. Because if you change the node type
                            in the scene and accidentally forget to change it in the script, the error
                            will be detected immediately when the scene is loaded. Unlike <literal>node_1</literal>,
                            which will be silently cast to <literal>null</literal> and the error will be detected later.</paragraph>
                    </note>
                    <note>
                        <paragraph>You can turn off safe lines or change their color in the editor settings.</paragraph>
                    </note>
                </section>
            </section>
        </section>
        <section ids="typed-or-dynamic-stick-to-one-style" names="typed\ or\ dynamic:\ stick\ to\ one\ style">
            <title>Typed or dynamic: stick to one style</title>
            <paragraph>Typed GDScript and dynamic GDScript can coexist in the same project. But
                it's recommended to stick to either style for consistency in your codebase,
                and for your peers. It's easier for everyone to work together if you follow
                the same guidelines, and faster to read and understand other people's code.</paragraph>
            <paragraph>Typed code takes a little more writing, but you get the benefits we discussed
                above. Here's an example of the same, empty script, in a dynamic style:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node


func _ready():
    pass


func _process(delta):
    pass</literal_block>
            <paragraph>And with static typing:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node


func _ready() -&gt; void:
    pass


func _process(delta: float) -&gt; void:
    pass</literal_block>
            <paragraph>As you can see, you can also use types with the engine's virtual methods.
                Signal callbacks, like any methods, can also use types. Here's a <literal>body_entered</literal>
                signal in a dynamic style:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_area_2d_body_entered(body):
    pass</literal_block>
            <paragraph>And the same callback, with type hints:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_area_2d_body_entered(body: PhysicsBody2D) -&gt; void:
    pass</literal_block>
        </section>
        <section ids="warning-system" names="warning\ system">
            <title>Warning system</title>
            <note>
                <paragraph>Detailed documentation about the GDScript warning system has been moved to
                    <reference internal="True" refuri="warning_system#doc-gdscript-warning-system"><inline classes="std std-ref">GDScript warning system</inline></reference>.</paragraph>
            </note>
            <paragraph>Godot gives you warnings about your code as you write it. The engine identifies
                sections of your code that may lead to issues at runtime, but lets you decide
                whether or not you want to leave the code as it is.</paragraph>
            <paragraph>We have a number of warnings aimed specifically at users of typed GDScript.
                By default, these warnings are disabled, you can enable them in Project Settings
                (<strong>Debug &gt; GDScript</strong>, make sure <strong>Advanced Settings</strong> is enabled).</paragraph>
            <paragraph>You can enable the <literal>UNTYPED_DECLARATION</literal> warning if you want to always use
                static types. Additionally, you can enable the <literal>INFERRED_DECLARATION</literal> warning
                if you prefer a more readable and reliable, but more verbose syntax.</paragraph>
            <paragraph><literal>UNSAFE_*</literal> warnings make unsafe operations more noticeable, than unsafe lines.
                Currently, <literal>UNSAFE_*</literal> warnings do not cover all cases that unsafe lines cover.</paragraph>
        </section>
        <section ids="common-unsafe-operations-and-their-safe-counterparts" names="common\ unsafe\ operations\ and\ their\ safe\ counterparts">
            <title>Common unsafe operations and their safe counterparts</title>
            <section ids="global-scope-methods" names="global\ scope\ methods">
                <title>Global scope methods</title>
                <paragraph>The following global scope methods are not statically typed, but they have
                    typed counterparts available. These methods return statically typed values:</paragraph>
                <table>
                    <tgroup cols="2">
                        <colspec colwidth="54"></colspec>
                        <colspec colwidth="85"></colspec>
                        <thead>
                            <row>
                                <entry>
                                    <paragraph>Method</paragraph>
                                </entry>
                                <entry>
                                    <paragraph>Statically typed equivalents</paragraph>
                                </entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>
                                    <paragraph><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-abs"><inline classes="std std-ref">abs()</inline></reference></paragraph>
                                </entry>
                                <entry>
                                    <line_block>
                                        <line><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-absf"><inline classes="std std-ref">absf()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-absi"><inline classes="std std-ref">absi()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector2#class-vector2-method-abs"><inline classes="std std-ref">Vector2.abs()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_vector2i#class-vector2i-method-abs"><inline classes="std std-ref">Vector2i.abs()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector3#class-vector3-method-abs"><inline classes="std std-ref">Vector3.abs()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_vector3i#class-vector3i-method-abs"><inline classes="std std-ref">Vector3i.abs()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector4#class-vector4-method-abs"><inline classes="std std-ref">Vector4.abs()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_vector4i#class-vector4i-method-abs"><inline classes="std std-ref">Vector4i.abs()</inline></reference></line>
                                    </line_block>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-ceil"><inline classes="std std-ref">ceil()</inline></reference></paragraph>
                                </entry>
                                <entry>
                                    <line_block>
                                        <line><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-ceilf"><inline classes="std std-ref">ceilf()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-ceili"><inline classes="std std-ref">ceili()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector2#class-vector2-method-ceil"><inline classes="std std-ref">Vector2.ceil()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector3#class-vector3-method-ceil"><inline classes="std std-ref">Vector3.ceil()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector4#class-vector4-method-ceil"><inline classes="std std-ref">Vector4.ceil()</inline></reference></line>
                                    </line_block>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-clamp"><inline classes="std std-ref">clamp()</inline></reference></paragraph>
                                </entry>
                                <entry>
                                    <line_block>
                                        <line><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-clampf"><inline classes="std std-ref">clampf()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-clampi"><inline classes="std std-ref">clampi()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector2#class-vector2-method-clamp"><inline classes="std std-ref">Vector2.clamp()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_vector2i#class-vector2i-method-clamp"><inline classes="std std-ref">Vector2i.clamp()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector3#class-vector3-method-clamp"><inline classes="std std-ref">Vector3.clamp()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_vector3i#class-vector3i-method-clamp"><inline classes="std std-ref">Vector3i.clamp()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector4#class-vector4-method-clamp"><inline classes="std std-ref">Vector4.clamp()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_vector4i#class-vector4i-method-clamp"><inline classes="std std-ref">Vector4i.clamp()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_color#class-color-method-clamp"><inline classes="std std-ref">Color.clamp()</inline></reference></line>
                                        <line>(untyped <literal>clamp()</literal> does not work on Color)</line>
                                    </line_block>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-floor"><inline classes="std std-ref">floor()</inline></reference></paragraph>
                                </entry>
                                <entry>
                                    <line_block>
                                        <line><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-floorf"><inline classes="std std-ref">floorf()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-floori"><inline classes="std std-ref">floori()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector2#class-vector2-method-floor"><inline classes="std std-ref">Vector2.floor()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector3#class-vector3-method-floor"><inline classes="std std-ref">Vector3.floor()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector4#class-vector4-method-floor"><inline classes="std std-ref">Vector4.floor()</inline></reference></line>
                                    </line_block>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-lerp"><inline classes="std std-ref">lerp()</inline></reference></paragraph>
                                </entry>
                                <entry>
                                    <line_block>
                                        <line><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-lerpf"><inline classes="std std-ref">lerpf()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector2#class-vector2-method-lerp"><inline classes="std std-ref">Vector2.lerp()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector3#class-vector3-method-lerp"><inline classes="std std-ref">Vector3.lerp()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector4#class-vector4-method-lerp"><inline classes="std std-ref">Vector4.lerp()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_color#class-color-method-lerp"><inline classes="std std-ref">Color.lerp()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_quaternion#class-quaternion-method-slerp"><inline classes="std std-ref">Quaternion.slerp()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_basis#class-basis-method-slerp"><inline classes="std std-ref">Basis.slerp()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_transform2d#class-transform2d-method-interpolate-with"><inline classes="std std-ref">Transform2D.interpolate_with()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_transform3d#class-transform3d-method-interpolate-with"><inline classes="std std-ref">Transform3D.interpolate_with()</inline></reference></line>
                                    </line_block>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-round"><inline classes="std std-ref">round()</inline></reference></paragraph>
                                </entry>
                                <entry>
                                    <line_block>
                                        <line><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-roundf"><inline classes="std std-ref">roundf()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-roundi"><inline classes="std std-ref">roundi()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector2#class-vector2-method-round"><inline classes="std std-ref">Vector2.round()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector3#class-vector3-method-round"><inline classes="std std-ref">Vector3.round()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector4#class-vector4-method-round"><inline classes="std std-ref">Vector4.round()</inline></reference></line>
                                    </line_block>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-sign"><inline classes="std std-ref">sign()</inline></reference></paragraph>
                                </entry>
                                <entry>
                                    <line_block>
                                        <line><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-signf"><inline classes="std std-ref">signf()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-signi"><inline classes="std std-ref">signi()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector2#class-vector2-method-sign"><inline classes="std std-ref">Vector2.sign()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_vector2i#class-vector2i-method-sign"><inline classes="std std-ref">Vector2i.sign()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector3#class-vector3-method-sign"><inline classes="std std-ref">Vector3.sign()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_vector3i#class-vector3i-method-sign"><inline classes="std std-ref">Vector3i.sign()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector4#class-vector4-method-sign"><inline classes="std std-ref">Vector4.sign()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_vector4i#class-vector4i-method-sign"><inline classes="std std-ref">Vector4i.sign()</inline></reference></line>
                                    </line_block>
                                </entry>
                            </row>
                            <row>
                                <entry>
                                    <paragraph><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-snapped"><inline classes="std std-ref">snapped()</inline></reference></paragraph>
                                </entry>
                                <entry>
                                    <line_block>
                                        <line><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-snappedf"><inline classes="std std-ref">snappedf()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_@globalscope#class-globalscope-method-snappedi"><inline classes="std std-ref">snappedi()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector2#class-vector2-method-snapped"><inline classes="std std-ref">Vector2.snapped()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_vector2i#class-vector2i-method-snapped"><inline classes="std std-ref">Vector2i.snapped()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector3#class-vector3-method-snapped"><inline classes="std std-ref">Vector3.snapped()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_vector3i#class-vector3i-method-snapped"><inline classes="std std-ref">Vector3i.snapped()</inline></reference></line>
                                        <line><reference internal="True" refuri="../../../classes/class_vector4#class-vector4-method-snapped"><inline classes="std std-ref">Vector4.snapped()</inline></reference>,
                                            <reference internal="True" refuri="../../../classes/class_vector4i#class-vector4i-method-snapped"><inline classes="std std-ref">Vector4i.snapped()</inline></reference></line>
                                    </line_block>
                                </entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <paragraph>When using static typing, use the typed global scope methods whenever possible.
                    This ensures you have safe lines and benefit from typed instructions for
                    better performance.</paragraph>
            </section>
            <section ids="unsafe-property-access-and-unsafe-method-access-warnings" names="unsafe_property_access\ and\ unsafe_method_access\ warnings">
                <title><literal>UNSAFE_PROPERTY_ACCESS</literal> and <literal>UNSAFE_METHOD_ACCESS</literal> warnings</title>
                <paragraph>In this example, we aim to set a property and call a method on an object
                    that has a script attached with <literal>class_name MyScript</literal> and that <literal>extends
Node2D</literal>. If we have a reference to the object as a <literal>Node2D</literal> (for instance,
                    as it was passed to us by the physics system), we can first check if the
                    property and method exist and then set and call them if they do:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">if "some_property" in node_2d:
    node_2d.some_property = 20  # Produces UNSAFE_PROPERTY_ACCESS warning.

if node_2d.has_method("some_function"):
    node_2d.some_function()  # Produces UNSAFE_METHOD_ACCESS warning.</literal_block>
                <paragraph>However, this code will produce <literal>UNSAFE_PROPERTY_ACCESS</literal> and
                    <literal>UNSAFE_METHOD_ACCESS</literal> warnings as the property and method are not present
                    in the referenced type - in this case a <literal>Node2D</literal>. To make these operations
                    safe, you can first check if the object is of type <literal>MyScript</literal> using the
                    <literal>is</literal> keyword and then declare a variable with the type <literal>MyScript</literal> on
                    which you can set its properties and call its methods:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">if node_2d is MyScript:
    var my_script: MyScript = node_2d
    my_script.some_property = 20
    my_script.some_function()</literal_block>
                <paragraph>Alternatively, you can declare a variable and use the <literal>as</literal> operator to try
                    to cast the object. You'll then want to check whether the cast was successful
                    by confirming that the variable was assigned:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var my_script := node_2d as MyScript
if my_script != null:
    my_script.some_property = 20
    my_script.some_function()</literal_block>
            </section>
            <section ids="unsafe-cast-warning" names="unsafe_cast\ warning">
                <title><literal>UNSAFE_CAST</literal> warning</title>
                <paragraph>In this example, we would like the label connected to an object entering our
                    collision area to show the area's name. Once the object enters the collision
                    area, the physics system sends a signal with a <literal>Node2D</literal> object, and the most
                    straightforward (but not statically typed) solution to do what we want could
                    be achieved like this:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_body_entered(body: Node2D) -&gt; void:
    body.label.text = name  # Produces UNSAFE_PROPERTY_ACCESS warning.</literal_block>
                <paragraph>This piece of code produces an <literal>UNSAFE_PROPERTY_ACCESS</literal> warning because
                    <literal>label</literal> is not defined in <literal>Node2D</literal>. To solve this, we could first check if the
                    <literal>label</literal> property exist and cast it to type <literal>Label</literal> before settings its text
                    property like so:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_body_entered(body: Node2D) -&gt; void:
    if "label" in body:
        (body.label as Label).text = name  # Produces UNSAFE_CAST warning.</literal_block>
                <paragraph>However, this produces an <literal>UNSAFE_CAST</literal> warning because <literal>body.label</literal> is of a
                    <literal>Variant</literal> type. To safely get the property in the type you want, you can use the
                    <literal>Object.get()</literal> method which returns the object as a <literal>Variant</literal> value or returns
                    <literal>null</literal> if the property doesn't exist. You can then determine whether the
                    property contains an object of the right type using the <literal>is</literal> keyword, and
                    finally declare a statically typed variable with the object:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_body_entered(body: Node2D) -&gt; void:
    var label_variant: Variant = body.get("label")
    if label_variant is Label:
        var label: Label = label_variant
        label.text = name</literal_block>
            </section>
        </section>
        <section ids="cases-where-you-can-t-specify-types" names="cases\ where\ you\ can't\ specify\ types">
            <title>Cases where you can't specify types</title>
            <comment xml:space="preserve">UPDATE: Not supported. If nested types are supported, update this section.</comment>
            <paragraph>To wrap up this introduction, let's mention cases where you can't use type hints.
                This will trigger a <strong>syntax error</strong>.</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>You can't specify the type of individual elements in an array or a dictionary:</paragraph>
                </list_item>
            </enumerated_list>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var enemies: Array = [$Goblin: Enemy, $Zombie: Enemy]
var character: Dictionary = {
    name: String = "Richard",
    money: int = 1000,
    inventory: Inventory = $Inventory,
}</literal_block>
            <enumerated_list enumtype="arabic" prefix="" start="2" suffix=".">
                <list_item>
                    <paragraph>Nested types are not currently supported:</paragraph>
                </list_item>
            </enumerated_list>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var teams: Array[Array[Character]] = []</literal_block>
        </section>
        <section ids="summary" names="summary">
            <title>Summary</title>
            <comment xml:space="preserve">UPDATE: Planned feature. If more optimizations (possibly JIT/AOT?) are</comment>
            <comment xml:space="preserve">implemented, update this paragraph.</comment>
            <paragraph>Typed GDScript is a powerful tool. It helps you write more structured code,
                avoid common errors, and create scalable and reliable systems. Static types
                improve GDScript performance and more optimizations are planned for the future.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
