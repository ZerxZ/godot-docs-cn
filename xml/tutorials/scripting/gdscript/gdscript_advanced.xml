<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/gdscript/gdscript_advanced.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-gdscript-more-efficiently"></target>
    <section ids="gdscript-an-introduction-to-dynamic-languages doc-gdscript-more-efficiently" names="gdscript:\ an\ introduction\ to\ dynamic\ languages doc_gdscript_more_efficiently">
        <title>GDScript: An introduction to dynamic languages</title>
        <section ids="about" names="about">
            <title>About</title>
            <paragraph>This tutorial aims to be a quick reference for how to use GDScript more
                efficiently. It focuses on common cases specific to the language, but
                also covers a lot of information on dynamically typed languages.</paragraph>
            <paragraph>It's meant to be especially useful for programmers with little or no previous
                experience with dynamically typed languages.</paragraph>
        </section>
        <section ids="dynamic-nature" names="dynamic\ nature">
            <title>Dynamic nature</title>
            <section ids="pros-cons-of-dynamic-typing" names="pros\ &amp;\ cons\ of\ dynamic\ typing">
                <title>Pros &amp; cons of dynamic typing</title>
                <paragraph>GDScript is a Dynamically Typed language. As such, its main advantages
                    are that:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>The language is easy to get started with.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Most code can be written and changed quickly and without hassle.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>The code is easy to read (little clutter).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>No compilation is required to test.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Runtime is tiny.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>It has duck-typing and polymorphism by nature.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>While the main disadvantages are:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Less performance than statically typed languages.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>More difficult to refactor (symbols can't be traced).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Some errors that would typically be detected at compile time in
                            statically typed languages only appear while running the code
                            (because expression parsing is more strict).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Less flexibility for code-completion (some variable types are only
                            known at runtime).</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>This, translated to reality, means that Godot used with GDScript is a combination
                    designed to create games quickly and efficiently. For games that are very
                    computationally intensive and can't benefit from the engine built-in
                    tools (such as the Vector types, Physics Engine, Math library, etc), the
                    possibility of using C++ is present too. This allows you to still create most of the
                    game in GDScript and add small bits of C++ in the areas that need
                    a performance boost.</paragraph>
            </section>
            <section ids="variables-assignment" names="variables\ &amp;\ assignment">
                <title>Variables &amp; assignment</title>
                <paragraph>All variables in a dynamically typed language are "variant"-like. This
                    means that their type is not fixed, and is only modified through
                    assignment. Example:</paragraph>
                <paragraph>Static:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">int a; // Value uninitialized.
a = 5; // This is valid.
a = "Hi!"; // This is invalid.</literal_block>
                <paragraph>Dynamic:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a # 'null' by default.
a = 5 # Valid, 'a' becomes an integer.
a = "Hi!" # Valid, 'a' changed to a string.</literal_block>
            </section>
            <section ids="as-function-arguments" names="as\ function\ arguments:">
                <title>As function arguments:</title>
                <paragraph>Functions are of dynamic nature too, which means they can be called with
                    different arguments, for example:</paragraph>
                <paragraph>Static:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void print_value(int value) {

    printf("value is %i\n", value);
}

[..]

print_value(55); // Valid.
print_value("Hello"); // Invalid.</literal_block>
                <paragraph>Dynamic:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func print_value(value):
    print(value)

[..]

print_value(55) # Valid.
print_value("Hello") # Valid.</literal_block>
            </section>
            <section ids="pointers-referencing" names="pointers\ &amp;\ referencing:">
                <title>Pointers &amp; referencing:</title>
                <paragraph>In static languages, such as C or C++ (and to some extent Java and C#),
                    there is a distinction between a variable and a pointer/reference to a
                    variable. The latter allows the object to be modified by other functions
                    by passing a reference to the original one.</paragraph>
                <paragraph>In C# or Java, everything not a built-in type (int, float, sometimes
                    String) is always a pointer or a reference. References are also
                    garbage-collected automatically, which means they are erased when no
                    longer used. Dynamically typed languages tend to use this memory model,
                    too. Some Examples:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>C++:</paragraph>
                    </list_item>
                </bullet_list>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void use_class(SomeClass *instance) {

    instance-&gt;use();
}

void do_something() {

    SomeClass *instance = new SomeClass; // Created as pointer.
    use_class(instance); // Passed as pointer.
    delete instance; // Otherwise it will leak memory.
}</literal_block>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Java:</paragraph>
                    </list_item>
                </bullet_list>
                <literal_block force="False" highlight_args="{}" language="java" linenos="False" xml:space="preserve">@Override
public final void use_class(SomeClass instance) {

    instance.use();
}

public final void do_something() {

    SomeClass instance = new SomeClass(); // Created as reference.
    use_class(instance); // Passed as reference.
    // Garbage collector will get rid of it when not in
    // use and freeze your game randomly for a second.
}</literal_block>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>GDScript:</paragraph>
                    </list_item>
                </bullet_list>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func use_class(instance): # Does not care about class type
    instance.use() # Will work with any class that has a ".use()" method.

func do_something():
    var instance = SomeClass.new() # Created as reference.
    use_class(instance) # Passed as reference.
    # Will be unreferenced and deleted.</literal_block>
                <paragraph>In GDScript, only base types (int, float, string and the vector types)
                    are passed by value to functions (value is copied). Everything else
                    (instances, arrays, dictionaries, etc) is passed as reference. Classes
                    that inherit <reference internal="True" refuri="../../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> (the default if nothing is specified)
                    will be freed when not used, but manual memory management is allowed too
                    if inheriting manually from <reference internal="True" refuri="../../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference>.</paragraph>
            </section>
        </section>
        <section ids="arrays" names="arrays">
            <title>Arrays</title>
            <paragraph>Arrays in dynamically typed languages can contain many different mixed
                datatypes inside and are always dynamic (can be resized at any time).
                Compare for example arrays in statically typed languages:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">int *array = new int[4]; // Create array.
array[0] = 10; // Initialize manually.
array[1] = 20; // Can't mix types.
array[2] = 40;
array[3] = 60;
// Can't resize.
use_array(array); // Passed as pointer.
delete[] array; // Must be freed.

// or

std::vector&lt;int&gt; array;
array.resize(4);
array[0] = 10; // Initialize manually.
array[1] = 20; // Can't mix types.
array[2] = 40;
array[3] = 60;
array.resize(3); // Can be resized.
use_array(array); // Passed reference or value.
// Freed when stack ends.</literal_block>
            <paragraph>And in GDScript:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var array = [10, "hello", 40, 60] # You can mix types.
array.resize(3) # Can be resized.
use_array(array) # Passed as reference.
# Freed when no longer in use.</literal_block>
            <paragraph>In dynamically typed languages, arrays can also double as other
                datatypes, such as lists:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var array = []
array.append(4)
array.append(5)
array.pop_front()</literal_block>
            <paragraph>Or unordered sets:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a = 20
if a in [10, 20, 30]:
    print("We have a winner!")</literal_block>
        </section>
        <section ids="dictionaries" names="dictionaries">
            <title>Dictionaries</title>
            <paragraph>Dictionaries are a powerful tool in dynamically typed languages. In
                GDScript, untyped dictionaries can be used for many cases where a statically
                typed language would tend to use another data structure.</paragraph>
            <paragraph>Dictionaries can map any value to any other value with complete
                disregard for the datatype used as either key or value. Contrary to
                popular belief, they are efficient because they can be implemented
                with hash tables. They are, in fact, so efficient that some languages
                will go as far as implementing arrays as dictionaries.</paragraph>
            <paragraph>Example of Dictionary:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var d = {"name": "John", "age": 22}
print("Name: ", d["name"], " Age: ", d["age"])</literal_block>
            <paragraph>Dictionaries are also dynamic, keys can be added or removed at any point
                at little cost:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">d["mother"] = "Rebecca" # Addition.
d["age"] = 11 # Modification.
d.erase("name") # Removal.</literal_block>
            <paragraph>In most cases, two-dimensional arrays can often be implemented more
                easily with dictionaries. Here's a battleship game example:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Battleship Game

const SHIP = 0
const SHIP_HIT = 1
const WATER_HIT = 2

var board = {}

func initialize():
    board[Vector2(1, 1)] = SHIP
    board[Vector2(1, 2)] = SHIP
    board[Vector2(1, 3)] = SHIP

func missile(pos):
    if pos in board: # Something at that position.
        if board[pos] == SHIP: # There was a ship! hit it.
            board[pos] = SHIP_HIT
        else:
            print("Already hit here!") # Hey dude you already hit here.
    else: # Nothing, mark as water.
        board[pos] = WATER_HIT

func game():
    initialize()
    missile(Vector2(1, 1))
    missile(Vector2(5, 8))
    missile(Vector2(2, 3))</literal_block>
            <paragraph>Dictionaries can also be used as data markup or quick structures. While
                GDScript's dictionaries resemble python dictionaries, it also supports Lua
                style syntax and indexing, which makes it useful for writing initial
                states and quick structs:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Same example, lua-style support.
# This syntax is a lot more readable and usable.
# Like any GDScript identifier, keys written in this form cannot start
# with a digit.

var d = {
    name = "John",
    age = 22
}

print("Name: ", d.name, " Age: ", d.age) # Used "." based indexing.

# Indexing

d["mother"] = "Rebecca"
d.mother = "Caroline" # This would work too to create a new key.</literal_block>
        </section>
        <section ids="for-while" names="for\ &amp;\ while">
            <title>For &amp; while</title>
            <paragraph>Iterating using the C-style for loop in C-derived languages can be quite complex:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">const char** strings = new const char*[50];

[..]

for (int i = 0; i &lt; 50; i++) {
    printf("Value: %c Index: %d\n", strings[i], i);
}

// Even in STL:
std::list&lt;std::string&gt; strings;

[..]

for (std::string::const_iterator it = strings.begin(); it != strings.end(); it++) {
    std::cout &lt;&lt; *it &lt;&lt; std::endl;
}</literal_block>
            <paragraph>Because of this, GDScript makes the opinionated decision to have a for-in loop over iterables instead:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for s in strings:
    print(s)</literal_block>
            <paragraph>Container datatypes (arrays and dictionaries) are iterable. Dictionaries
                allow iterating the keys:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for key in dict:
    print(key, " -&gt; ", dict[key])</literal_block>
            <paragraph>Iterating with indices is also possible:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for i in range(strings.size()):
    print(strings[i])</literal_block>
            <paragraph>The range() function can take 3 arguments:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">range(n) # Will count from 0 to n in steps of 1. The parameter n is exclusive.
range(b, n) # Will count from b to n in steps of 1. The parameters b is inclusive. The parameter n is exclusive.
range(b, n, s) # Will count from b to n, in steps of s. The parameters b is inclusive. The parameter n is exclusive.</literal_block>
            <paragraph>Some examples involving C-style for loops:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">for (int i = 0; i &lt; 10; i++) {}

for (int i = 5; i &lt; 10; i++) {}

for (int i = 5; i &lt; 10; i += 2) {}</literal_block>
            <paragraph>Translate to:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for i in range(10):
    pass

for i in range(5, 10):
    pass

for i in range(5, 10, 2):
    pass</literal_block>
            <paragraph>And backwards looping done through a negative counter:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for (int i = 10; i &gt; 0; i--) {}</literal_block>
            <paragraph>Becomes:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for i in range(10, 0, -1):
    pass</literal_block>
        </section>
        <section ids="while" names="while">
            <title>While</title>
            <paragraph>while() loops are the same everywhere:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var i = 0

while i &lt; strings.size():
    print(strings[i])
    i += 1</literal_block>
        </section>
        <section ids="custom-iterators" names="custom\ iterators">
            <title>Custom iterators</title>
            <paragraph>You can create custom iterators in case the default ones don't quite meet your
                needs by overriding the Variant class's <literal>_iter_init</literal>, <literal>_iter_next</literal>, and <literal>_iter_get</literal>
                functions in your script. An example implementation of a forward iterator follows:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">class ForwardIterator:
    var start
    var current
    var end
    var increment

    func _init(start, stop, increment):
        self.start = start
        self.current = start
        self.end = stop
        self.increment = increment

    func should_continue():
        return (current &lt; end)

    func _iter_init(arg):
        current = start
        return should_continue()

    func _iter_next(arg):
        current += increment
        return should_continue()

    func _iter_get(arg):
        return current</literal_block>
            <paragraph>And it can be used like any other iterator:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var itr = ForwardIterator.new(0, 6, 2)
for i in itr:
    print(i) # Will print 0, 2, and 4.</literal_block>
            <paragraph>Make sure to reset the state of the iterator in <literal>_iter_init</literal>, otherwise nested
                for-loops that use custom iterators will not work as expected.</paragraph>
        </section>
        <section ids="duck-typing" names="duck\ typing">
            <title>Duck typing</title>
            <paragraph>One of the most difficult concepts to grasp when moving from a
                statically typed language to a dynamic one is duck typing. Duck typing
                makes overall code design much simpler and straightforward to write, but
                it's not obvious how it works.</paragraph>
            <paragraph>As an example, imagine a situation where a big rock is falling down a
                tunnel, smashing everything on its way. The code for the rock, in a
                statically typed language would be something like:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void BigRollingRock::on_object_hit(Smashable *entity) {

    entity-&gt;smash();
}</literal_block>
            <paragraph>This way, everything that can be smashed by a rock would have to
                inherit Smashable. If a character, enemy, piece of furniture, small rock
                were all smashable, they would need to inherit from the class Smashable,
                possibly requiring multiple inheritance. If multiple inheritance was
                undesired, then they would have to inherit a common class like Entity.
                Yet, it would not be very elegant to add a virtual method <literal>smash()</literal> to
                Entity only if a few of them can be smashed.</paragraph>
            <paragraph>With dynamically typed languages, this is not a problem. Duck typing
                makes sure you only have to define a <literal>smash()</literal> function where required
                and that's it. No need to consider inheritance, base classes, etc.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_object_hit(object):
    object.smash()</literal_block>
            <paragraph>And that's it. If the object that hit the big rock has a smash() method,
                it will be called. No need for inheritance or polymorphism. Dynamically
                typed languages only care about the instance having the desired method
                or member, not what it inherits or the class type. The definition of
                Duck Typing should make this clearer:</paragraph>
            <paragraph><emphasis>"When I see a bird that walks like a duck and swims like a duck and
                    quacks like a duck, I call that bird a duck"</emphasis></paragraph>
            <paragraph>In this case, it translates to:</paragraph>
            <paragraph><emphasis>"If the object can be smashed, don't care what it is, just smash it."</emphasis></paragraph>
            <paragraph>Yes, we should call it Hulk typing instead.</paragraph>
            <paragraph>It's possible that the object being hit doesn't have a smash() function.
                Some dynamically typed languages simply ignore a method call when it
                doesn't exist, but GDScript is stricter, so checking if the function
                exists is desirable:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _on_object_hit(object):
    if object.has_method("smash"):
        object.smash()</literal_block>
            <paragraph>Then, define that method and anything the rock touches can be smashed.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
