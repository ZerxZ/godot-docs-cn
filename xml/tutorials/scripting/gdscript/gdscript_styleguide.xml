<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/gdscript/gdscript_styleguide.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-gdscript-styleguide"></target>
    <section ids="gdscript-style-guide doc-gdscript-styleguide" names="gdscript\ style\ guide gdscript\ 编写风格指南 doc_gdscript_styleguide">
        <title>GDScript 编写风格指南</title>
        <paragraph>本编写风格指南列出了几条规定，能够让用户将 GDScript 代码编写得更加优雅。本指南旨在让用户编写更为整洁、可读的代码，促进项目、讨论和教程之间的一致性。本教程也希望能够因此鼓励开发者们能够开发出来代码自动格式化工具。</paragraph>
        <paragraph>由于 GDScript 与 Python 非常接近，因此本指南的灵感来自 Python 的 <reference name="PEP 8" refuri="https://www.python.org/dev/peps/pep-0008/">PEP 8</reference> 编程风格指南。</paragraph>
        <paragraph>风格指南并不是硬性的规则教条，有些情况下，你可能无法施行下面的一些规范。如果这种情况发生在你身上，最好自行进行选择，并询问其他开发人员的见解。</paragraph>
        <paragraph>一般来说，在项目和团队中保持代码风格的一致性，比一板一眼地遵循本指南更为重要。</paragraph>
        <note>
            <paragraph>Godot的内置脚本编辑器默认使用了很多这些规范，那么就让这内置脚本编辑器来帮助你吧。</paragraph>
        </note>
        <paragraph>下面是基于这些规范的完整的类的示例：</paragraph>
        <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">class_name StateMachine
extends Node
## Hierarchical State machine for the player.
##
## Initializes states and delegates engine callbacks ([method Node._physics_process],
## [method Node._unhandled_input]) to the state.


signal state_changed(previous, new)

@export var initial_state: Node
var is_active = true:
    set = set_is_active

@onready var _state = initial_state:
    set = set_state
@onready var _state_name = _state.name


func _init():
    add_to_group("state_machine")


func _enter_tree():
    print("this happens before the ready method!")


func _ready():
    state_changed.connect(_on_state_changed)
    _state.enter()


func _unhandled_input(event):
    _state.unhandled_input(event)


func _physics_process(delta):
    _state.physics_process(delta)


func transition_to(target_state_path, msg={}):
    if not has_node(target_state_path):
        return

    var target_state = get_node(target_state_path)
    assert(target_state.is_composite == false)

    _state.exit()
    self._state = target_state
    _state.enter(msg)
    Events.player_state_changed.emit(_state.name)


func set_is_active(value):
    is_active = value
    set_physics_process(value)
    set_process_unhandled_input(value)
    set_block_signals(not value)


func set_state(value):
    _state = value
    _state_name = _state.name


func _on_state_changed(previous, new):
    print("state changed")
    state_changed.emit()


class State:
    var foo = 0

    func _init():
        print("Hello!")</literal_block>
        <target refid="formatting"></target>
        <section dupnames="formatting" ids="formatting id1" names="格式 formatting">
            <title>格式</title>
            <section ids="encoding-and-special-characters" names="encoding\ and\ special\ characters 编码与特殊字符">
                <title>编码与特殊字符</title>
                <bullet_list bullet="*">
                    <list_item>
                        <paragraph>使用换行符（<strong>LF</strong>）换行，而非 CRLF 或 CR。<emphasis>（编辑器默认）</emphasis></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>在每个文件的末尾使用一个换行符。<emphasis>（编辑器默认）</emphasis></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>使用不带<reference name="字节顺序标记" refuri="https://zh.wikipedia.org/zh-cn/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F">字节顺序标记</reference><target ids="id1" names="字节顺序标记" refuri="https://zh.wikipedia.org/zh-cn/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F"></target>的 <strong>UTF-8</strong> 编码。<emphasis>（编辑器默认）</emphasis></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>使用<strong>制表符</strong>代替空格进行缩进。<emphasis>（编辑器默认）</emphasis></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="indentation" names="indentation 缩进">
                <title>缩进</title>
                <paragraph>每个缩进的缩进级别必须大于包含该缩进的代码块的缩进级别。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">for i in range(10):
    print("hello")</literal_block>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">for i in range(10):
  print("hello")

for i in range(10):
        print("hello")</literal_block>
                <paragraph>使用2个缩进级别来区分续行代码块与常规代码块。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">effect.interpolate_property(sprite, "transform/scale",
        sprite.get_scale(), Vector2(2.0, 2.0), 0.3,
        Tween.TRANS_QUAD, Tween.EASE_OUT)</literal_block>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">effect.interpolate_property(sprite, "transform/scale",
    sprite.get_scale(), Vector2(2.0, 2.0), 0.3,
    Tween.TRANS_QUAD, Tween.EASE_OUT)</literal_block>
                <paragraph>此规则的例外：数组、字典和枚举。使用单个缩进级别来区分续行代码块：</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">var party = [
    "Godot",
    "Godette",
    "Steve",
]

var character_dict = {
    "Name": "Bob",
    "Age": 27,
    "Job": "Mechanic",
}

enum Tiles {
    TILE_BRICK,
    TILE_FLOOR,
    TILE_SPIKE,
    TILE_TELEPORT,
}</literal_block>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">var party = [
        "Godot",
        "Godette",
        "Steve",
]

var character_dict = {
        "Name": "Bob",
        "Age": 27,
        "Job": "Mechanic",
}

enum Tiles {
        TILE_BRICK,
        TILE_FLOOR,
        TILE_SPIKE,
        TILE_TELEPORT,
}</literal_block>
            </section>
            <section ids="trailing-comma" names="trailing\ comma 行尾逗号">
                <title>行尾逗号</title>
                <paragraph>请在数组、字典和枚举的最后一行使用逗号，这样，在添加新元素时就不需要修改最后一行了，既能让版本控制中的重构更容易，也会让 Diff 也更美观。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">enum Tiles {
    TILE_BRICK,
    TILE_FLOOR,
    TILE_SPIKE,
    TILE_TELEPORT,
}</literal_block>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">enum Tiles {
    TILE_BRICK,
    TILE_FLOOR,
    TILE_SPIKE,
    TILE_TELEPORT
}</literal_block>
                <paragraph>单行列表中不需要行尾逗号，故在此情况下不要添加逗号。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">enum Tiles {TILE_BRICK, TILE_FLOOR, TILE_SPIKE, TILE_TELEPORT}</literal_block>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">enum Tiles {TILE_BRICK, TILE_FLOOR, TILE_SPIKE, TILE_TELEPORT,}</literal_block>
            </section>
            <section ids="blank-lines" names="blank\ lines 空白行">
                <title>空白行</title>
                <paragraph>用两个空行来包围函数和类定义：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func heal(amount):
    health += amount
    health = min(health, max_health)
    health_changed.emit(health)


func take_damage(amount, effect=null):
    health -= amount
    health = max(0, health)
    health_changed.emit(health)</literal_block>
                <paragraph>函数内部使用一个空行来分隔每个逻辑片段。</paragraph>
                <note>
                    <paragraph>在类参考和本文档的短代码片段中，我们会在类和函数定义之间使用单个空行。</paragraph>
                </note>
            </section>
            <section ids="line-length" names="line\ length 行的长度">
                <title>行的长度</title>
                <paragraph>把每行代码控制在100个字符以内。</paragraph>
                <paragraph>如果可以的话，尽量把行控制在80个字符以下，既有助于在小屏幕上阅读代码，也有利于在外部文本编辑器中并排打开两个脚本。例如，在查看差异修订时。</paragraph>
            </section>
            <section ids="one-statement-per-line" names="one\ statement\ per\ line 一条语句一行">
                <title>一条语句一行</title>
                <paragraph>不要在同一行上合并多个语句。不要像 C 语言那样使用单行条件语句。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">if position.x &gt; width:
    position.x = 0

if flag:
    print("flagged")</literal_block>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">if position.x &gt; width: position.x = 0

if flag: print("flagged")</literal_block>
                <paragraph>该规则的唯一例外便是三元运算符：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">next_state = "idle" if is_on_floor() else "fall"</literal_block>
            </section>
            <section ids="format-multiline-statements-for-readability" names="format\ multiline\ statements\ for\ readability 对多行语句进行排版以提高可读性">
                <title>对多行语句进行排版以提高可读性</title>
                <paragraph>如果你的 <literal>if</literal> 语句特别长，亦或如果一条语句是嵌套的三元表达式，把它们拆分成多行可以提高可读性。由于这几行连续的代码仍属于同一个表达式，故应该缩进两级而非一级。</paragraph>
                <paragraph>GDScript 允许使用括号或反斜杠将语句拆成多行，本指南倾向于使用括号，重构起来更简单。使用反斜杠的话，必须保证最后一行的末尾没有反斜杠；而如果是括号，则不必担心最后一行的反斜杠问题。</paragraph>
                <paragraph>把条件表达式拆分成多行时，<literal>and</literal> 和 <literal>or</literal> 关键字应当放在下一行的开头，而非上一行的结尾。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">var angle_degrees = 135
var quadrant = (
        "northeast" if angle_degrees &lt;= 90
        else "southeast" if angle_degrees &lt;= 180
        else "southwest" if angle_degrees &lt;= 270
        else "northwest"
)

var position = Vector2(250, 350)
if (
        position.x &gt; 200 and position.x &lt; 400
        and position.y &gt; 300 and position.y &lt; 400
):
    pass</literal_block>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">var angle_degrees = 135
var quadrant = "northeast" if angle_degrees &lt;= 90 else "southeast" if angle_degrees &lt;= 180 else "southwest" if angle_degrees &lt;= 270 else "northwest"

var position = Vector2(250, 350)
if position.x &gt; 200 and position.x &lt; 400 and position.y &gt; 300 and position.y &lt; 400:
    pass</literal_block>
            </section>
            <section ids="avoid-unnecessary-parentheses" names="avoid\ unnecessary\ parentheses 避免冗余的圆括号">
                <title>避免冗余的圆括号</title>
                <paragraph>避免在表达式和条件语句中使用括号，除非需要修改操作顺序或者将语句拆分多行编写，否则只会降低可读性。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">if is_colliding():
    queue_free()</literal_block>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">if (is_colliding()):
    queue_free()</literal_block>
                <target refid="boolean-operators"></target>
            </section>
            <section ids="boolean-operators id2" names="boolean\ operators 布尔运算 boolean_operators">
                <title>布尔运算</title>
                <paragraph>推荐使用英文布尔运算符，简单易懂：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>用 <literal>and</literal> 代替 <literal>&amp;&amp;</literal>。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>用 <literal>or</literal> 代替 <literal>||</literal>。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>用 <literal>not</literal> 代替 <literal>!</literal>。</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>也可以在布尔运算符周围使用括号来消除歧义，这样还可以使长表达式更有可读性。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">if (foo and bar) or not baz:
    print("condition is true")</literal_block>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">if foo &amp;&amp; bar || !baz:
    print("condition is true")</literal_block>
            </section>
            <section ids="comment-spacing" names="comment\ spacing 注释间距">
                <title>注释间距</title>
                <paragraph>普通注释（ <literal>#</literal> ）与文档注释（ <literal>##</literal> ）均应与注释正文保持一个空格的距离，而被注释掉的代码开头则不需要空格间隙。需要注意：代码区域注释（ <literal>#region</literal> / <literal>#endregion</literal> ）为保持其作用需要，不可以在井号后使用空格。</paragraph>
                <paragraph>普通注释开头应该留一个空格，但如果是为了停用代码而将其注释掉则不需要留，以此区分文本注释和停用的代码。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve"># This is a comment.
#print("This is disabled code")</literal_block>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">#This is a comment.
# print("This is disabled code")</literal_block>
                <note>
                    <paragraph>In the script editor, to toggle commenting of the selected code, press
                        <literal classes="kbd">Ctrl + K</literal>. This feature adds/removes a single <literal>#</literal> sign before any
                        code on the selected lines.</paragraph>
                </note>
            </section>
            <section ids="whitespace" names="whitespace 空格">
                <title>空格</title>
                <paragraph>时刻记得在运算符前后和逗号后使用一个空格。同时，请避免在字典引用和函数调用中使用多余的空格。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">position.x = 5
position.y = target_position.y + 10
dict["key"] = 5
my_array = [4, 5, 6]
print("foo")</literal_block>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">position.x=5
position.y = mpos.y+10
dict ["key"] = 5
myarray = [4,5,6]
print ("foo")</literal_block>
                <paragraph>不要用空格去垂直对齐表达式：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">x        = 100
y        = 100
velocity = 500</literal_block>
            </section>
            <section ids="quotes" names="quotes 引号">
                <title>引号</title>
                <paragraph>尽量使用双引号，除非单引号可以让字符串中需要转义的字符变少。见如下示例：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Normal string.
print("hello world")

# Use double quotes as usual to avoid escapes.
print("hello 'world'")

# Use single quotes as an exception to the rule to avoid escapes.
print('hello "world"')

# Both quote styles would require 2 escapes; prefer double quotes if it's a tie.
print("'hello' \"world\"")</literal_block>
            </section>
            <section ids="numbers" names="numbers 数字">
                <title>数字</title>
                <paragraph>不要忽略浮点数中的前导和后缀零，否则会降低这些数字的可读性，很难一眼与整数区分开。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">var float_number = 0.234
var other_float_number = 13.0</literal_block>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">var float_number = .234
var other_float_number = 13.</literal_block>
                <paragraph>对于十六进制数字，请使用小写字母。小写字母较矮，使数字更易读。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">var hex_number = 0xfb8c0b</literal_block>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">var hex_number = 0xFB8C0B</literal_block>
                <paragraph>利用 GDScript 的文字下划线，让大数字更易读。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">var large_number = 1_234_567_890
var large_hex_number = 0xffff_f8f8_0000
var large_bin_number = 0b1101_0010_1010
# Numbers lower than 1000000 generally don't need separators.
var small_number = 12345</literal_block>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">var large_number = 1234567890
var large_hex_number = 0xfffff8f80000
var large_bin_number = 0b110100101010
# Numbers lower than 1000000 generally don't need separators.
var small_number = 12_345</literal_block>
                <target refid="naming-conventions"></target>
            </section>
        </section>
        <section ids="naming-conventions id3" names="naming\ conventions 命名规定 naming_conventions">
            <title>命名规定</title>
            <paragraph>这些命名规定遵循 Godot 引擎风格，不遵循这些规定都会使你的代码与内置的命名规定相冲突，导致风格不一致的代码.</paragraph>
            <section ids="file-names" names="file\ names 文件命名">
                <title>文件命名</title>
                <paragraph>文件名用 snake_case （蛇形）命名法，对于具名类，将其名字从帕斯卡命名（大驼峰命名，PascalCase）转化为 snake_case 命名：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># This file should be saved as `weapon.gd`.
class_name Weapon
extends Node</literal_block>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># This file should be saved as `yaml_parser.gd`.
class_name YAMLParser
extends Object</literal_block>
                <paragraph>这种命名与 Godot 源码中的 C++ 文件命名保持一致，也避免了由 Windows 导出到其他大小写敏感平台时所发生的问题。</paragraph>
            </section>
            <section ids="classes-and-nodes" names="classes\ and\ nodes 类与节点">
                <title>类与节点</title>
                <paragraph>对类和节点名称使用帕斯卡命名法（大驼峰命名法，PascalCase）:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D</literal_block>
                <paragraph>将类加载到常量或变量时也同样适用：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">const Weapon = preload("res://weapon.gd")</literal_block>
            </section>
            <section ids="functions-and-variables" names="functions\ and\ variables 函数与变量">
                <title>函数与变量</title>
                <paragraph>函数与变量使用 snake_case 命名：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var particle_effect
func load_level():</literal_block>
                <paragraph>在用户必须覆盖的虚方法、私有函数、私有变量的名称前加一个下划线（_）：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var _counter = 0
func _recalculate_path():</literal_block>
            </section>
            <section ids="signals" names="signals 信号">
                <title>信号</title>
                <paragraph>用过去时态（英文）来命名信号：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">signal door_opened
signal score_changed</literal_block>
            </section>
            <section ids="constants-and-enums" names="constants\ and\ enums 常量与枚举">
                <title>常量与枚举</title>
                <paragraph>使用 CONSTANT_CASE，全部大写，并用下划线（_）来分隔单词：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">const MAX_SPEED = 200</literal_block>
                <paragraph>对枚举的<emphasis>名称</emphasis>使用 PascalCase，对其成员使用 CONSTANT_CASE， 因为这些成员是常量：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">enum Element {
    EARTH,
    WATER,
    AIR,
    FIRE,
}</literal_block>
            </section>
        </section>
        <section ids="code-order" names="code\ order 代码顺序">
            <title>代码顺序</title>
            <paragraph>第一节主要讨论代码顺序。有关代码格式，请参见 <reference internal="True" refid="formatting"><inline classes="std std-ref">格式</inline></reference>。有关命名规定，请参见 <reference internal="True" refid="naming-conventions"><inline classes="std std-ref">命名规定</inline></reference>。</paragraph>
            <paragraph>我们建议按以下方式来组织 GDScript 代码：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">01. @tool
02. class_name
03. extends
04. # docstring

05. signals
06. enums
07. constants
08. @export variables
09. public variables
10. private variables
11. @onready variables

12. optional built-in virtual _init method
13. optional built-in virtual _enter_tree() method
14. built-in virtual _ready method
15. remaining built-in virtual methods
16. public methods
17. private methods
18. subclasses</literal_block>
            <paragraph>我们优化了代码顺序，从上往下阅读代码更加容易，帮助第一次阅读代码的开发人员了解代码的工作原理，同时避免与变量声明顺序相关的错误。</paragraph>
            <paragraph>此代码顺序遵循四个经验法则：</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>先写信号和属性，然后再写方法。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>先写公共成员，然后再写私有成员。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>先写虚函数回调，然后再写类的接口。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>先写对象的构造函数和初始化函数 <literal>_init</literal> 和 <literal>_ready</literal> ，然后再写修改对象的函数。</paragraph>
                </list_item>
            </enumerated_list>
            <section ids="class-declaration" names="class\ declaration 类声明">
                <title>类声明</title>
                <paragraph>如果代码要在编辑器中运行，请将 <literal>@tool</literal> 注解写在脚本的第一行。</paragraph>
                <paragraph>如有必要，在后面加上 <literal>class_name</literal>。你可以使用该特性将 GDScript 文件转换为项目中的全局类型。有关更多信息，请参阅 <reference internal="True" refuri="gdscript_basics#doc-gdscript"><inline classes="std std-ref">GDScript 参考</inline></reference>。</paragraph>
                <paragraph>然后，如果该类扩展了内置类型，请添加 <literal>extends</literal> 关键字。</paragraph>
                <paragraph>接下来，你应该有该类的可选 <reference internal="True" refuri="gdscript_documentation_comments#doc-gdscript-documentation-comments"><inline classes="std std-ref">文档注释</inline></reference>。例如，你可以用它来向你的队友解释你的类的作用、它是如何工作的、以及其他开发人员应该如何使用它。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">class_name MyNode
extends Node
## A brief description of the class's role and functionality.
##
## The description of the script, what it can do,
## and any further detail.</literal_block>
            </section>
            <section ids="signals-and-properties" names="signals\ and\ properties 信号和属性">
                <title>信号和属性</title>
                <paragraph>先声明信号，然后声明属性（即成员变量），这些都写在文档注释（docstring）之后。</paragraph>
                <paragraph>在信号之后声明枚举，枚举可以用作其他属性的导出提示。</paragraph>
                <paragraph>然后，按该顺序依次写入常量、导出变量、公共变量、私有变量和就绪加载（onready）变量。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">signal player_spawned(position)

enum Jobs {KNIGHT, WIZARD, ROGUE, HEALER, SHAMAN}

const MAX_LIVES = 3

@export var job: Jobs = Jobs.KNIGHT
@export var max_health = 50
@export var attack = 5

var health = max_health:
    set(new_health):
        health = new_health

var _speed = 300.0

@onready var sword = get_node("Sword")
@onready var gun = get_node("Gun")</literal_block>
                <note>
                    <paragraph>GDScript编译器在 <literal>_ready</literal> 函数回调之前计算就绪加载（onready）变量，因此可以使用该虚函数来缓存节点依赖项，在你的类所依赖的场景中获取子节点。这便是上面的例子所展示的内容。</paragraph>
                </note>
            </section>
            <section ids="member-variables" names="member\ variables 成员变量">
                <title>成员变量</title>
                <paragraph>如果变量只在方法中使用，请勿将该变量声明为成员变量，因为难以定位在何处使用了该变量。相反，你应该将这些变量在方法内部定义为局部变量。</paragraph>
            </section>
            <section ids="local-variables" names="local\ variables 局部变量">
                <title>局部变量</title>
                <paragraph>局部变量的声明位置离首次使用该局部变量的位置越近越好，让人更容易跟上代码的思路，而不需要上翻下找该变量的声明位置。</paragraph>
            </section>
            <section ids="methods-and-static-functions" names="methods\ and\ static\ functions 方法和静态函数">
                <title>方法和静态函数</title>
                <paragraph>先声明类的属性，再声明类的方法。</paragraph>
                <paragraph>从 <literal>_init()</literal> 回调方法开始，引擎将在内存创建对象时调用该方法，然后是 <literal>_ready()</literal> 回调，Godot 在向场景树添加一个节点时会调用该回调。</paragraph>
                <paragraph>这些函数应声明在脚本最前面，以便显示该对象的初始化方式。</paragraph>
                <paragraph><literal>_unhandling_input()</literal> 和 <literal>_physics_process</literal> 等其他内置的虚回调则应该放在后面，控制对象的主循环和与游戏引擎的交互。</paragraph>
                <paragraph>类的其余接口、公共和私有方法，均按照这个顺序呈现。</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _init():
    add_to_group("state_machine")


func _ready():
    state_changed.connect(_on_state_changed)
    _state.enter()


func _unhandled_input(event):
    _state.unhandled_input(event)


func transition_to(target_state_path, msg={}):
    if not has_node(target_state_path):
        return

    var target_state = get_node(target_state_path)
    assert(target_state.is_composite == false)

    _state.exit()
    self._state = target_state
    _state.enter(msg)
    Events.player_state_changed.emit(_state.name)


func _on_state_changed(previous, new):
    print("state changed")
    state_changed.emit()</literal_block>
            </section>
        </section>
        <section ids="static-typing" names="static\ typing 静态类型">
            <title>静态类型</title>
            <paragraph>从 Godot 3.1 开始，GDScript 支持 <reference internal="True" refuri="static_typing#doc-gdscript-static-typing"><inline classes="std std-ref">可选的静态类型</inline></reference>。</paragraph>
            <section ids="declared-types" names="declared\ types 声明类型">
                <title>声明类型</title>
                <paragraph>要声明变量的类型，请使用 <literal>&lt;variable&gt;: &lt;type&gt;</literal> ：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var health: int = 0</literal_block>
                <paragraph>要声明函数的返回类型，请使用 <literal>-&gt; &lt;type&gt;</literal> ：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func heal(amount: int) -&gt; void:</literal_block>
            </section>
            <section ids="inferred-types" names="inferred\ types 推断类型">
                <title>推断类型</title>
                <paragraph>大部分情况下，你可以让编译器自行推断变量类型，用 <literal>:=</literal> 来实现。在变量声明与变量类型写在同一行时使用该语法，除此之外还请显式指定变量类型。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">var health: int = 0 # The type can be int or float, and thus should be stated explicitly.
var direction := Vector3(1, 2, 3) # The type is clearly inferred as Vector3.</literal_block>
                <paragraph>在类型不明确时指定类型，在类型提示多余时省略类型指定。</paragraph>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve">var health := 0 # Typed as int, but it could be that float was intended.
var direction: Vector3 = Vector3(1, 2, 3) # The type hint has redundant information.

# What type is this? It's not immediately clear to the reader, so it's bad.
var value := complex_function()</literal_block>
                <paragraph>但在少数情况下，上下文缺失时，编译器会回退到函数的返回类型。例如，在节点的场景或文件被加载到内存中之前， <literal>get_node()</literal> 无法自动推断类型。在这种情况下，应明确指定类型。</paragraph>
                <paragraph><strong>规范示例</strong> :</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">@onready var health_bar: ProgressBar = get_node("UI/LifeBar")</literal_block>
                <paragraph>也可以使用 <literal>as</literal> 关键字来转换返回类型，该类型会用于推导变量类型。</paragraph>
                <literal_block classes="code-example-good" force="False" language="gdscript" linenos="False" xml:space="preserve">@onready var health_bar := get_node("UI/LifeBar") as ProgressBar
# health_bar will be typed as ProgressBar</literal_block>
                <paragraph>这种做法也比第一种更加<reference internal="True" refuri="static_typing#doc-gdscript-static-typing-safe-lines"><inline classes="std std-ref">类型安全</inline></reference>。</paragraph>
                <paragraph><strong>不规范示例</strong> :</paragraph>
                <literal_block classes="code-example-bad" force="False" language="gdscript" linenos="False" xml:space="preserve"># The compiler can't infer the exact type and will use Node
# instead of ProgressBar.
@onready var health_bar := get_node("UI/LifeBar")</literal_block>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
