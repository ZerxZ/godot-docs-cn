<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/evaluating_expressions.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-evaluating-expressions"></target>
    <section ids="evaluating-expressions doc-evaluating-expressions" names="evaluating\ expressions doc_evaluating_expressions">
        <title>Evaluating expressions</title>
        <paragraph>Godot provides an <reference internal="True" refuri="../../classes/class_expression#class-expression"><inline classes="std std-ref">Expression</inline></reference> class you can use to evaluate expressions.</paragraph>
        <paragraph>An expression can be:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>A mathematical expression such as <literal>(2 + 4) * 16/4.0</literal>.</paragraph>
            </list_item>
            <list_item>
                <paragraph>A boolean expression such as <literal>true &amp;&amp; false</literal>.</paragraph>
            </list_item>
            <list_item>
                <paragraph>A built-in method call like <literal>deg_to_rad(90)</literal>.</paragraph>
            </list_item>
            <list_item>
                <paragraph>A method call on a user-provided script like <literal>update_health()</literal>,
                    if <literal>base_instance</literal> is set to a value other than <literal>null</literal> when calling
                    <reference internal="True" refuri="../../classes/class_expression#class-expression-method-execute"><inline classes="std std-ref">Expression.execute()</inline></reference>.</paragraph>
            </list_item>
        </bullet_list>
        <note>
            <paragraph>The Expression class is independent from GDScript.
                It's available even if you compile Godot with the GDScript module disabled.</paragraph>
        </note>
        <section ids="basic-usage" names="basic\ usage">
            <title>Basic usage</title>
            <paragraph>To evaluate a mathematical expression, use:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var expression = Expression.new()
expression.parse("20 + 10*2 - 5/2.0")
var result = expression.execute()
print(result)  # 37.5</literal_block>
            <paragraph>The following operators are available:</paragraph>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="24"></colspec>
                    <colspec colwidth="85"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Operator</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Notes</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>Addition <literal>+</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>Can also be used to concatenate strings and arrays:
                                    - <literal>"hello" + " world"</literal> = <literal>hello world</literal>
                                    - <literal>[1, 2] + [3, 4]</literal> = <literal>[1, 2, 3, 4]</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>Subtraction (<literal>-</literal>)</paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>Multiplication (<literal>*</literal>)</paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>Division (<literal>/</literal>)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Performs and integer division if both operands are integers.
                                    If at least one of them is a floating-point number, returns a floating-point value.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>Remainder (<literal>%</literal>)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Returns the remainder of an integer division (modulo).
                                    The result will always have the sign of the dividend.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>Conjunction (<literal>&amp;&amp;</literal>)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Returns the result of a boolean AND.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>Disjunction (<literal>||</literal>)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Returns the result of a boolean OR.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>Negation (<literal>!</literal>)</paragraph>
                            </entry>
                            <entry>
                                <paragraph>Returns the result of a boolean NOT.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <paragraph>Spaces around operators are optional. Also, keep in mind the usual
                <reference name="order of operations" refuri="https://en.wikipedia.org/wiki/Order_of_operations">order of operations</reference>
                applies. Use parentheses to override the order of operations if needed.</paragraph>
            <paragraph>All the Variant types supported in Godot can be used: integers, floating-point
                numbers, strings, arrays, dictionaries, colors, vectors, â€¦</paragraph>
            <paragraph>Arrays and dictionaries can be indexed like in GDScript:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Returns 1.
[1, 2][0]

# Returns 3. Negative indices can be used to count from the end of the array.
[1, 3][-1]

# Returns "green".
{"favorite_color": "green"}["favorite_color"]

# All 3 lines below return 7.0 (Vector3 is floating-point).
Vector3(5, 6, 7)[2]
Vector3(5, 6, 7)["z"]
Vector3(5, 6, 7).z</literal_block>
        </section>
        <section ids="passing-variables-to-an-expression" names="passing\ variables\ to\ an\ expression">
            <title>Passing variables to an expression</title>
            <paragraph>You can pass variables to an expression. These variables will then
                become available in the expression's "context" and will be substituted when used
                in the expression:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var expression = Expression.new()
# Define the variable names first in the second parameter of `parse()`.
# In this example, we use `x` for the variable name.
expression.parse("20 + 2 * x", ["x"])
# Then define the variable values in the first parameter of `execute()`.
# Here, `x` is assigned the integer value 5.
var result = expression.execute([5])
print(result)  # 30</literal_block>
            <paragraph>Both the variable names and variable values <strong>must</strong> be specified as an array,
                even if you only define one variable. Also, variable names are <strong>case-sensitive</strong>.</paragraph>
        </section>
        <section ids="setting-a-base-instance-for-the-expression" names="setting\ a\ base\ instance\ for\ the\ expression">
            <title>Setting a base instance for the expression</title>
            <paragraph>By default, an expression has a base instance of <literal>null</literal>. This means the
                expression has no base instance associated to it.</paragraph>
            <paragraph>When calling <reference internal="True" refuri="../../classes/class_expression#class-expression-method-execute"><inline classes="std std-ref">Expression.execute()</inline></reference>,
                you can set the value of the <literal>base_instance</literal> parameter to a specific object
                instance such as <literal>self</literal>, another script instance or even a singleton:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func double(number):
    return number * 2


func _ready():
    var expression = Expression.new()
    expression.parse("double(10)")

    # This won't work since we're not passing the current script as the base instance.
    var result = expression.execute([], null)
    print(result)  # null

    # This will work since we're passing the current script (i.e. self)
    # as the base instance.
    result = expression.execute([], self)
    print(result)  # 20</literal_block>
            <paragraph>Associating a base instance allows doing the following:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Reference the instance's constants (<literal>const</literal>) in the expression.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Reference the instance's member variables (<literal>var</literal>) in the expression.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Call methods defined in the instance and use their return values in the expression.</paragraph>
                </list_item>
            </bullet_list>
            <warning>
                <paragraph>Setting a base instance to a value other than <literal>null</literal> allows referencing
                    constants, member variables, and calling all methods defined in the script
                    attached to the instance. Allowing users to enter expressions may allow
                    cheating in your game, or may even introduce security vulnerabilities if you
                    allow arbitrary clients to run expressions on other players' devices.</paragraph>
            </warning>
        </section>
        <section ids="example-script" names="example\ script">
            <title>Example script</title>
            <paragraph>The script below demonstrates what the Expression class is capable of:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">const DAYS_IN_YEAR = 365
var script_member_variable = 1000


func _ready():
    # Constant boolean expression.
    evaluate("true &amp;&amp; false")
    # Boolean expression with variables.
    evaluate("!(a &amp;&amp; b)", ["a", "b"], [true, false])

    # Constant mathexpression.
    evaluate("2 + 2")
    # Math expression with variables.
    evaluate("x + y", ["x", "y"], [60, 100])

    # Call built-in method (built-in math function call).
    evaluate("deg_to_rad(90)")

    # Call user method (defined in the script).
    # We can do this because the expression execution is bound to `self`
    # in the `evaluate()` method.
    # Since this user method returns a value, we can use it in math expressions.
    evaluate("call_me() + DAYS_IN_YEAR + script_member_variable")
    evaluate("call_me(42)")
    evaluate("call_me('some string')")


func evaluate(command, variable_names = [], variable_values = []) -&gt; void:
    var expression = Expression.new()
    var error = expression.parse(command, variable_names)
    if error != OK:
        push_error(expression.get_error_text())
        return

    var result = expression.execute(variable_values, self)

    if not expression.has_execute_failed():
        print(str(result))


func call_me(argument = null):
    print("\nYou called 'call_me()' in the expression text.")
    if argument:
        print("Argument passed: %s" % argument)

    # The method's return value is also the expression's return value.
    return 0</literal_block>
            <paragraph>The output from the script will be:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">false
true
4
160
1.5707963267949

You called 'call_me()' in the expression text.
1365

You called 'call_me()' in the expression text.
Argument passed: 42
0

You called 'call_me()' in the expression text.
Argument passed: some string
0</literal_block>
        </section>
        <section ids="built-in-functions" names="built-in\ functions">
            <title>Built-in functions</title>
            <paragraph>All methods in the <reference internal="True" refuri="../../classes/class_@globalscope#class-globalscope"><inline classes="std std-ref">Global Scope</inline></reference> are available in the
                Expression class, even if no base instance is bound to the expression.
                The same parameters and return types are available.</paragraph>
            <paragraph>However, unlike GDScript, parameters are <strong>always required</strong> even if they're
                specified as being optional in the class reference. In contrast, this
                restriction on arguments doesn't apply to user-made functions when you bind a
                base instance to the expression.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
