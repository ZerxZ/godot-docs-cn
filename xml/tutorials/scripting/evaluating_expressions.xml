<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/evaluating_expressions.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-evaluating-expressions"></target>
    <section ids="evaluating-expressions doc-evaluating-expressions" names="evaluating\ expressions 表达式估值 doc_evaluating_expressions">
        <title>表达式估值</title>
        <paragraph>Godot 提供了 <reference internal="True" refuri="../../classes/class_expression#class-expression"><inline classes="std std-ref">Expression</inline></reference> 类，可以用来对表达式进行估值。</paragraph>
        <paragraph>表达式可以是：</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>类似 <literal>(2 + 4) * 16/4.0</literal> 的数学表达式。</paragraph>
            </list_item>
            <list_item>
                <paragraph>A built-in method call like <literal>deg_to_rad(90)</literal>.</paragraph>
            </list_item>
            <list_item>
                <paragraph>A method call on a user-provided script like <literal>update_health()</literal>,
                    if <literal>base_instance</literal> is set to a value other than <literal>null</literal> when calling
                    <reference internal="True" refuri="../../classes/class_expression#class-expression-method-execute"><inline classes="std std-ref">Expression.execute()</inline></reference>.</paragraph>
            </list_item>
        </bullet_list>
        <note>
            <paragraph>Expression 类是独立于 GDScript 的。即便禁用 GDScript 模块编译 Godot 也能使用。</paragraph>
        </note>
        <section ids="basic-usage" names="basic\ usage 基本用法">
            <title>基本用法</title>
            <paragraph>要对数学表达式求值，请使用：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var expression = Expression.new()
expression.parse("20 + 10*2 - 5/2.0")
var result = expression.execute()
print(result)  # 37.5</literal_block>
            <paragraph>可以使用以下操作符：</paragraph>
            <table>
                <tgroup cols="2">
                    <colspec colwidth="24"></colspec>
                    <colspec colwidth="85"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>操作符</paragraph>
                            </entry>
                            <entry>
                                <paragraph>注意</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>加 <literal>+</literal></paragraph>
                            </entry>
                            <entry>
                                <paragraph>还可以用于连接字符串和数组：- <literal>"hello" + " world"</literal> = <literal>hello world</literal> - <literal>[1, 2] + [3, 4]</literal> = <literal>[1, 2, 3, 4]</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>减（<literal>-</literal>）</paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>乘（<literal>*</literal>）</paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>除（<literal>/</literal>）</paragraph>
                            </entry>
                            <entry>
                                <paragraph>两个操作数都是整数时执行整数除法。如果至少有一个是浮点数，就会返回浮点值。</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>求余（<literal>%</literal>）</paragraph>
                            </entry>
                            <entry>
                                <paragraph>返回整数除法的余数。</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <paragraph>操作符周围的空格是可选的。另外请记住，此处适用一般的<reference name="运算次序" refuri="https://zh.wikipedia.org/zh-cn/%E9%81%8B%E7%AE%97%E6%AC%A1%E5%BA%8F">运算次序</reference>。必要时请使用括号来覆盖运算符的次序。</paragraph>
            <paragraph>Godot 所支持的所有 Variant 类型都可以使用：整数、浮点数、字符串、数组、字典、颜色、向量……</paragraph>
            <paragraph>数组与字典的索引方法与 GDScript 一致：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Returns 1.
[1, 2][0]

# Returns 3. Negative indices can be used to count from the end of the array.
[1, 3][-1]

# Returns "green".
{"favorite_color": "green"}["favorite_color"]

# All 3 lines below return 7.0 (Vector3 is floating-point).
Vector3(5, 6, 7)[2]
Vector3(5, 6, 7)["z"]
Vector3(5, 6, 7).z</literal_block>
        </section>
        <section ids="passing-variables-to-an-expression" names="passing\ variables\ to\ an\ expression 向表达式传递变量">
            <title>向表达式传递变量</title>
            <paragraph>你可以将变量传入表达式。这些变量就会进入这个表达式的“上下文”，在表达式中使用就会被替换：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var expression = Expression.new()
# Define the variable names first in the second parameter of `parse()`.
# In this example, we use `x` for the variable name.
expression.parse("20 + 2 * x", ["x"])
# Then define the variable values in the first parameter of `execute()`.
# Here, `x` is assigned the integer value 5.
var result = expression.execute([5])
print(result)  # 30</literal_block>
            <paragraph>变量的名称和变量的值都<strong>必须</strong>以数组的形式指定，即便只定义一个变量也是如此。而且，变量名是<strong>大小写敏感</strong>的。</paragraph>
        </section>
        <section ids="setting-a-base-instance-for-the-expression" names="setting\ a\ base\ instance\ for\ the\ expression 为表达式设置基础实例">
            <title>为表达式设置基础实例</title>
            <paragraph>表达式默认的基础实例是 <literal>null</literal>。这意味着该表达式没有关联基础实例。</paragraph>
            <paragraph>调用 <reference internal="True" refuri="../../classes/class_expression#class-expression-method-execute"><inline classes="std std-ref">Expression.execute()</inline></reference> 时，你可以将参数 <literal>base_instance</literal> 的值设为 <literal>self</literal>、另一个脚本实例、单例等特定对象的实例：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func double(number):
    return number * 2


func _ready():
    var expression = Expression.new()
    expression.parse("double(10)")

    # This won't work since we're not passing the current script as the base instance.
    var result = expression.execute([], null)
    print(result)  # null

    # This will work since we're passing the current script (i.e. self)
    # as the base instance.
    result = expression.execute([], self)
    print(result)  # 20</literal_block>
            <paragraph>关联基础实例可以实现以下功能：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>在表达式中引用实例的常量（<literal>const</literal>）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>在表达式中引用实例的成员变量（<literal>var</literal>）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>在表达式中调用定义在实例上的方法，并使用其返回值。</paragraph>
                </list_item>
            </bullet_list>
            <warning>
                <paragraph>将基础实例设为非 <literal>null</literal> 值，就可以引用常量、成员变量、调用定义在该实例的附加脚本中的方法。允许用户输入表达式可能会导致在你的游戏出现作弊，如果你允许任意客户的在其他玩家的设备上运行表达式的话，甚至还可能引入安全隐患。</paragraph>
            </warning>
        </section>
        <section ids="example-script" names="example\ script 示例脚本">
            <title>示例脚本</title>
            <paragraph>下面的脚本演示的是 Expression 类的功能：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">const DAYS_IN_YEAR = 365
var script_member_variable = 1000


func _ready():
    # Constant mathexpression.
    evaluate("2 + 2")
    # Math expression with variables.
    evaluate("x + y", ["x", "y"], [60, 100])

    # Call built-in method (built-in math function call).
    evaluate("deg_to_rad(90)")

    # Call user method (defined in the script).
    # We can do this because the expression execution is bound to `self`
    # in the `evaluate()` method.
    # Since this user method returns a value, we can use it in math expressions.
    evaluate("call_me() + DAYS_IN_YEAR + script_member_variable")
    evaluate("call_me(42)")
    evaluate("call_me('some string')")


func evaluate(command, variable_names = [], variable_values = []) -&gt; void:
    var expression = Expression.new()
    var error = expression.parse(command, variable_names)
    if error != OK:
        push_error(expression.get_error_text())
        return

    var result = expression.execute(variable_values, self)

    if not expression.has_execute_failed():
        print(str(result))


func call_me(argument = null):
    print("\nYou called 'call_me()' in the expression text.")
    if argument:
        print("Argument passed: %s" % argument)

    # The method's return value is also the expression's return value.
    return 0</literal_block>
            <paragraph>脚本的输出将会是：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">4
160
1.5707963267949

You called 'call_me()' in the expression text.
1365

You called 'call_me()' in the expression text.
Argument passed: 42
0

You called 'call_me()' in the expression text.
Argument passed: some string
0</literal_block>
        </section>
        <section ids="built-in-functions" names="built-in\ functions 内置函数">
            <title>内置函数</title>
            <paragraph>All methods in the <reference internal="True" refuri="../../classes/class_@globalscope#class-globalscope"><inline classes="std std-ref">Global Scope</inline></reference> are available in the
                Expression class, even if no base instance is bound to the expression.
                The same parameters and return types are available.</paragraph>
            <paragraph>然而，与 GDScript 不同，参数<strong>始终是必须的</strong>，即使类参考中说明此参数为可选。不过，为表达式绑定了基础实例时，用户定义函数的参数没有此限制。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
