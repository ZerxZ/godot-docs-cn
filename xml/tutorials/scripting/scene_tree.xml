<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/scene_tree.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-scene-tree"></target>
    <section ids="using-scenetree doc-scene-tree" names="using\ scenetree doc_scene_tree">
        <title>Using SceneTree</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>In previous tutorials, everything revolved around the concept of
                nodes. Scenes are collections of nodes. They become active once
                they enter the <emphasis>scene tree</emphasis>.</paragraph>
        </section>
        <section ids="mainloop" names="mainloop">
            <title>MainLoop</title>
            <paragraph>The way Godot works internally is as follows. There is the
                <reference internal="True" refuri="../../classes/class_os#class-os"><inline classes="std std-ref">OS</inline></reference> class,
                which is the only instance that runs at the beginning. Afterwards, all
                drivers, servers, scripting languages, scene system, etc are loaded.</paragraph>
            <paragraph>When initialization is complete, <reference internal="True" refuri="../../classes/class_os#class-os"><inline classes="std std-ref">OS</inline></reference> needs to be
                supplied a <reference internal="True" refuri="../../classes/class_mainloop#class-mainloop"><inline classes="std std-ref">MainLoop</inline></reference>
                to run. Up to this point, all this is internals working (you can check
                main/main.cpp file in the source code if you are ever interested to
                see how this works internally).</paragraph>
            <paragraph>The user program, or game, starts in the MainLoop. This class has a few
                methods, for initialization, idle (frame-synchronized callback), fixed
                (physics-synchronized callback), and input. Again, this is low
                level and when making games in Godot, writing your own MainLoop seldom makes sense.</paragraph>
        </section>
        <section ids="scenetree" names="scenetree">
            <title>SceneTree</title>
            <paragraph>One of the ways to explain how Godot works is that it's a high-level
                game engine over a low-level middleware.</paragraph>
            <paragraph>The scene system is the game engine, while the <reference internal="True" refuri="../../classes/class_os#class-os"><inline classes="std std-ref">OS</inline></reference>
                and servers are the low-level API.</paragraph>
            <paragraph>The scene system provides its own main loop to OS,
                <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.
                This is automatically instanced and set when running a scene, no need
                to do any extra work.</paragraph>
            <paragraph>It's important to know that this class exists because it has a few
                important uses:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>It contains the root <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>, to which a
                        scene is added as a child when it's first opened to become
                        part of the <emphasis>Scene Tree</emphasis> (more on that next).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>It contains information about the groups and has the means to call all
                        nodes in a group or get a list of them.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>It contains some global state functionality, such as setting pause
                        mode or quitting the process.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>When a node is part of the Scene Tree, the
                <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>
                singleton can be obtained by calling
                <reference internal="True" refuri="../../classes/class_node#class-node-method-get-tree"><inline classes="std std-ref">Node.get_tree()</inline></reference>.</paragraph>
        </section>
        <section ids="root-viewport" names="root\ viewport">
            <title>Root viewport</title>
            <paragraph>The root <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>
                is always at the top of the scene. From a node, it can be obtained in
                two different ways:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">get_tree().root # Access via scene main loop.
get_node("/root") # Access via absolute path.</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GetTree().Root // Access via scene main loop.
GetNode("/root"); // Access via absolute path.</literal_block>
                </div>
            </container>
            <paragraph>This node contains the main viewport. Anything that is a child of a
                <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>
                is drawn inside of it by default, so it makes sense that the top of all
                nodes is always a node of this type otherwise nothing would be seen.</paragraph>
            <paragraph>While other viewports can be created in the scene (for split-screen
                effects and such), this one is the only one that is never created by the
                user. It's created automatically inside SceneTree.</paragraph>
        </section>
        <section ids="scene-tree" names="scene\ tree">
            <title>Scene tree</title>
            <paragraph>When a node is connected, directly or indirectly, to the root
                viewport, it becomes part of the <emphasis>scene tree</emphasis>.</paragraph>
            <paragraph>This means that as explained in previous tutorials, it will get the
                <literal>_enter_tree()</literal> and <literal>_ready()</literal> callbacks (as well as <literal>_exit_tree()</literal>).</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/activescene.webp'}" original_uri="img/activescene.webp" uri="tutorials/scripting/img/activescene.webp"></image>
            <paragraph>When nodes enter the <emphasis>Scene Tree</emphasis>, they become active. They get access
                to everything they need to process, get input, display 2D and 3D visuals,
                receive and send notifications, play sounds, etc. When they are removed from the
                <emphasis>scene tree</emphasis>, they lose these abilities.</paragraph>
        </section>
        <section ids="tree-order" names="tree\ order">
            <title>Tree order</title>
            <paragraph>Most node operations in Godot, such as drawing 2D, processing, or getting
                notifications are done in <emphasis>tree order</emphasis>, or top to bottom as seen in the
                editor (also known as pre-order traversal):</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/toptobottom.webp'}" original_uri="img/toptobottom.webp" uri="tutorials/scripting/img/toptobottom.webp"></image>
            <paragraph>For example, the top node in a scene has its <literal>_process()</literal> function
                called first, then the node below it has its <literal>_process()</literal> function called,
                then the node below that and so on.</paragraph>
            <paragraph>An important exception is the <literal>_ready()</literal> function: each parent node has its
                <literal>_ready()</literal> function called only after all its child nodes have their
                <literal>_ready()</literal> functions called, so that the parent knows its children are
                completely ready to be accessed. This is also known as post-order traversal.
                In the above image, <literal>NameLabel</literal> would be notified first (but only after its
                children, if it had any!), followed by <literal>Name</literal>, etc., and <literal>Panel</literal> would be
                notified last.</paragraph>
            <paragraph>The order of operations can also be overridden using the <literal>process_priority</literal>
                node property. Nodes with a lower number are called first. For example, nodes
                with the priorities "0, 1, 2, 3" would be called in that order from left to right.</paragraph>
        </section>
        <section ids="becoming-active-by-entering-the-scene-tree" names='"becoming\ active"\ by\ entering\ the\ scene\ tree'>
            <title>"Becoming active" by entering the <emphasis>Scene Tree</emphasis></title>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>A scene is loaded from disk or created by scripting.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The root node of that scene (only one root, remember?) is added as
                        either a child of the "root" Viewport (from SceneTree), or to any
                        of its descendants.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Every node of the newly added scene will receive the "enter_tree"
                        notification ( <literal>_enter_tree()</literal> callback in GDScript) in
                        top-to-bottom order (pre-order traversal).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Every node will receive the "ready" notification ( <literal>_ready()</literal>
                        callback in GDScript) for convenience, once all its children have
                        received the "ready" notification (post-order traversal).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>When a scene (or part of it) is removed, they receive the "exit
                        scene" notification ( <literal>_exit_tree()</literal> callback in GDScript) in
                        bottom-to-top order (the exact reverse of top-to-bottom order).</paragraph>
                </list_item>
            </enumerated_list>
        </section>
        <section ids="changing-current-scene" names="changing\ current\ scene">
            <title>Changing current scene</title>
            <paragraph>After a scene is loaded, you may want to change this scene for
                another one. One way to do this is to use the
                <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree-method-change-scene-to-file"><inline classes="std std-ref">SceneTree.change_scene_to_file()</inline></reference>
                function:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _my_level_was_completed():
    get_tree().change_scene_to_file("res://levels/level2.tscn")</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void _MyLevelWasCompleted()
{
    GetTree().ChangeSceneToFile("res://levels/level2.tscn");
}</literal_block>
                </div>
            </container>
            <paragraph>Rather than using file paths, one can also use ready-made
                <reference internal="True" refuri="../../classes/class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference> resources using the equivalent
                function
                <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree-method-change-scene-to-packed"><inline classes="std std-ref">SceneTree.change_scene_to_packed(PackedScene scene)</inline></reference>:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var next_scene = preload("res://levels/level2.tscn")

func _my_level_was_completed():
    get_tree().change_scene_to_packed(next_scene)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void _MyLevelWasCompleted()
{
    var nextScene = (PackedScene)ResourceLoader.Load("res://levels/level2.tscn");
    GetTree().ChangeSceneToPacked(nextScene);
}</literal_block>
                </div>
            </container>
            <paragraph>These are quick and useful ways to switch scenes but have the drawback
                that the game will stall until the new scene is loaded and running. At
                some point in the development of your game, it may be preferable to create proper loading
                screens with progress bar, animated indicators or threaded (background)
                loading. This must be done manually using <reference internal="True" refuri="singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">Singletons (Autoload)</inline></reference>
                and <reference internal="True" refuri="../io/background_loading#doc-background-loading"><inline classes="std std-ref">Background loading</inline></reference>.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
