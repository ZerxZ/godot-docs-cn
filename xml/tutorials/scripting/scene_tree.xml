<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/scene_tree.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-scene-tree"></target>
    <section ids="using-scenetree doc-scene-tree" names="using\ scenetree 使用\ scenetree doc_scene_tree">
        <title>使用 SceneTree</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>在之前的教程中，所有内容都是围绕节点这一概念展开的。场景是节点的合集，节点一进入 <emphasis>场景树</emphasis> 就会被激活。</paragraph>
        </section>
        <section ids="mainloop" names="mainloop">
            <title>MainLoop</title>
            <paragraph>Godot 内部的工作方式是这样的：开始的时候只会有一个 <reference internal="True" refuri="../../classes/class_os#class-os"><inline classes="std std-ref">OS</inline></reference> 类的实例在运行，然后才会把驱动程序、服务器、脚本语言、场景系统等等这些加载进来。</paragraph>
            <paragraph>初始化完成后，就会为 <reference internal="True" refuri="../../classes/class_os#class-os"><inline classes="std std-ref">OS</inline></reference> 提供一个 <reference internal="True" refuri="../../classes/class_mainloop#class-mainloop"><inline classes="std std-ref">MainLoop</inline></reference> 来运行。目前为止的所有内容都是内部工作（如果你有兴趣查看内部如何工作，可以在源代码中查看 main/main.cpp 文件）。</paragraph>
            <paragraph>用户程序或游戏会在 MainLoop 中启动，这个类包含初始化、空闲（帧同步回调）、固定（物理同步回调）、输入等方法。当然这也属于底层，用 Godot 制作游戏时几乎不会遇到需要自行编写 MainLoop 的情况。</paragraph>
        </section>
        <section ids="scenetree" names="scenetree">
            <title>SceneTree</title>
            <paragraph>解释Godot的工作方式的一种方法是, 它是基于低级中间件的高级游戏引擎.</paragraph>
            <paragraph>场景系统是游戏引擎, 而 <reference internal="True" refuri="../../classes/class_os#class-os"><inline classes="std std-ref">OS</inline></reference> 和服务是底层API.</paragraph>
            <paragraph>场景系统为OS提供了自己的主循环, 即 <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>. 运行场景时会自动实例化并设置该场景, 无需执行任何其他工作.</paragraph>
            <paragraph>重要的是要知道此类的存在, 因为它有一些重要的用途:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>它包含根 <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>, 当场景第一次打开成为 <emphasis>Scene Tree</emphasis> 的一部分时, 会将场景作为子级添加到其中(接下来会有更多).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>它包含有关编组的信息, 并具有调用编组中所有节点或获取它们的列表的方法.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>它包含一些全局状态功能, 例如设置暂停模式或退出进程.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>当节点是场景树的一部分时, 可以通过调用 <reference internal="True" refuri="../../classes/class_node#class-node-method-get-tree"><inline classes="std std-ref">Node.get_tree()</inline></reference> 获得 <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 单例.</paragraph>
        </section>
        <section ids="root-viewport" names="root\ viewport 根视图">
            <title>根视图</title>
            <paragraph>根 <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> 始终位于场景的顶部. 从一个节点, 可以通过两种不同的方式获得它:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">get_tree().root # Access via scene main loop.
get_node("/root") # Access via absolute path.</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GetTree().Root // Access via scene main loop.
GetNode("/root"); // Access via absolute path.</literal_block>
                </div>
            </container>
            <paragraph>此节点包含主视口, 默认情况下, <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> 的任何子节点都将绘制在其中, 因此以Viewport作为根节点是有意义的, 否则将看不到任何内容.</paragraph>
            <paragraph>尽管可以在场景中创建其他视图(用于分屏效果等), 但该视图是唯一不由用户创建的视图. 它是在 <literal>SceneTree</literal> 内部自动创建的.</paragraph>
        </section>
        <section ids="scene-tree" names="scene\ tree 场景树">
            <title>场景树</title>
            <paragraph>当节点直接或间接连接到根视图时，它就成为了<emphasis>场景树</emphasis>的一部分。</paragraph>
            <paragraph>因此，正如在之前的教程中所解释的，它将获得 <literal>_enter_tree()</literal> 和 <literal>_ready()</literal> 回调（以及 <literal>_exit_tree()</literal> ）。</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/activescene.webp'}" uri="tutorials/scripting/img/activescene.webp"></image>
            <paragraph>当节点进入<emphasis>场景树</emphasis>时，它们将变为活动状态。它们可以访问需要处理的所有内容、获取输入、显示 2D 和 3D 视觉效果、收发通知、播放声音等。当从<emphasis>场景树</emphasis>中删除时，它们将失去这些能力。</paragraph>
        </section>
        <section ids="tree-order" names="tree\ order 树顺序">
            <title>树顺序</title>
            <paragraph>Most node operations in Godot, such as drawing 2D, processing, or getting
                notifications are done in <emphasis>tree order</emphasis>, or top to bottom as seen in the
                editor (also known as pre-order traversal):</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/toptobottom.webp'}" uri="tutorials/scripting/img/toptobottom.webp"></image>
            <paragraph>For example, the top node in a scene has its <literal>_process()</literal> function
                called first, then the node below it has its <literal>_process()</literal> function called,
                then the node below that and so on.</paragraph>
            <paragraph>An important exception is the <literal>_ready()</literal> function: each parent node has its
                <literal>_ready()</literal> function called only after all its child nodes have their
                <literal>_ready()</literal> functions called, so that the parent knows its children are
                completely ready to be accessed. This is also known as post-order traversal.
                In the above image, <literal>NameLabel</literal> would be notified first (but only after its
                children, if it had any!), followed by <literal>Name</literal>, etc., and <literal>Panel</literal> would be
                notified last.</paragraph>
            <paragraph>The order of operations can also be overridden using the <literal>process_priority</literal>
                node property. Nodes with a lower number are called first. For example, nodes
                with the priorities "0, 1, 2, 3" would be called in that order from left to right.</paragraph>
        </section>
        <section ids="becoming-active-by-entering-the-scene-tree" names='"becoming\ active"\ by\ entering\ the\ scene\ tree 通过进入场景树“变为活动状态”'>
            <title>通过进入<emphasis>场景树</emphasis>“变为活动状态”</title>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>从磁盘加载场景或通过脚本创建场景。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The root node of that scene (only one root, remember?) is added as
                        either a child of the "root" Viewport (from SceneTree), or to any
                        of its descendants.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>新添加的场景的每个节点都将按照从上到下的顺序接收 <literal>enter_tree</literal> 通知（GDScript 中的 <literal>_enter_tree()</literal> 回调函数）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Every node will receive the "ready" notification ( <literal>_ready()</literal>
                        callback in GDScript) for convenience, once all its children have
                        received the "ready" notification (post-order traversal).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>删除场景（或场景的一部分）后，它们将按照自底向上的顺序（自顶向下的逆序）收到 <literal>exit scene</literal> 通知（GDScript中的 <literal>_exit_tree()</literal> 回调函数）。</paragraph>
                </list_item>
            </enumerated_list>
        </section>
        <section ids="changing-current-scene" names="changing\ current\ scene 更改当前场景">
            <title>更改当前场景</title>
            <paragraph>After a scene is loaded, you may want to change this scene for
                another one. One way to do this is to use the
                <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree-method-change-scene-to-file"><inline classes="std std-ref">SceneTree.change_scene_to_file()</inline></reference>
                function:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _my_level_was_completed():
    get_tree().change_scene_to_file("res://levels/level2.tscn")</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void _MyLevelWasCompleted()
{
    GetTree().ChangeSceneToFile("res://levels/level2.tscn");
}</literal_block>
                </div>
            </container>
            <paragraph>Rather than using file paths, one can also use ready-made
                <reference internal="True" refuri="../../classes/class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference> resources using the equivalent
                function
                <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree-method-change-scene-to-packed"><inline classes="std std-ref">SceneTree.change_scene_to_packed(PackedScene scene)</inline></reference>:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var next_scene = preload("res://levels/level2.tscn")

func _my_level_was_completed():
    get_tree().change_scene_to_packed(next_scene)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void _MyLevelWasCompleted()
{
    var nextScene = (PackedScene)ResourceLoader.Load("res://levels/level2.tscn");
    GetTree().ChangeSceneToPacked(nextScene);
}</literal_block>
                </div>
            </container>
            <paragraph>These are quick and useful ways to switch scenes but have the drawback
                that the game will stall until the new scene is loaded and running. At
                some point in the development of your game, it may be preferable to create proper loading
                screens with progress bar, animated indicators or threaded (background)
                loading. This must be done manually using <reference internal="True" refuri="singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">单例（自动加载）</inline></reference>
                and <reference internal="True" refuri="../io/background_loading#doc-background-loading"><inline classes="std std-ref">后台加载</inline></reference>.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
