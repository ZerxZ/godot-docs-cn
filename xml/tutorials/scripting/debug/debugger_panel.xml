<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/debug/debugger_panel.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-debugger-panel"></target>
    <section ids="debugger-panel doc-debugger-panel" names="debugger\ panel 调试器面板 doc_debugger_panel">
        <title>调试器面板</title>
        <paragraph>在屏幕下方的调试器面板中, 可以找到包括调试器在内的许多Godot的调试工具. 点击 <strong>调试器</strong> 即可打开.</paragraph>
        <image candidates="{'*': 'tutorials/scripting/debug/img/overview_debugger.webp'}" uri="tutorials/scripting/debug/img/overview_debugger.webp"></image>
        <paragraph>调试器面板被分成几个标签, 每个标签专注于一个特定的任务.</paragraph>
        <section ids="debugger" names="debugger 调试器">
            <title>调试器</title>
            <paragraph>当 GDScript 编译器在你的代码中达到一个断点时，“调试器”选项卡会自动打开。</paragraph>
            <paragraph>It gives you a <reference name="stack trace" refuri="https://en.wikipedia.org/wiki/Stack_trace">stack trace</reference>,
                information about the state of the object, and buttons to control the program's
                execution. When the debugger breaks on a breakpoint, a green triangle arrow is
                visible in the script editor's gutter. This arrow indicates the line of code the
                debugger broke on.</paragraph>
            <tip>
                <paragraph>You can create a breakpoint by clicking the gutter in the left of the script
                    editor (on the left of the line numbers). When hovering this gutter, you
                    will see a transparent red dot appearing, which turns into an opaque red dot
                    after the breakpoint is placed by clicking. Click the red dot again to
                    remove the breakpoint. Breakpoints created this way persist across editor
                    restarts, even if the script wasn't saved when exiting the editor.</paragraph>
                <paragraph>You can also use the <literal>breakpoint</literal> keyword in GDScript to create a
                    breakpoint that is stored in the script itself. Unlike breakpoints created by
                    clicking in the gutter, this keyword-based breakpoint is persistent across
                    different machines when using version control.</paragraph>
            </tip>
            <paragraph>你可以使用右上角的按钮来:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>跳过所有断点. 这样一来, 你就可以为将来的调试会话保存断点.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>复制当前错误消息.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>步入</strong> 代码. 这个按钮将带你进入下一行代码, 如果是函数, 它将逐行进入函数.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>步过</strong> 的代码. 这个按钮会进入下一行代码, 但它不会逐行跳过函数.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Break</strong> . 这个按钮会暂停执行游戏.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>继续</strong> . 该按钮在断点或暂停后恢复游戏.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="errors" names="errors 错误">
            <title>错误</title>
            <paragraph>这是运行游戏时打印错误和警告信息的地方.</paragraph>
            <paragraph>你可以在 <strong>项目设置&gt;调试&gt; GDScript</strong> 中禁用特定的警告.</paragraph>
        </section>
        <section ids="profiler" names="profiler 分析器">
            <title>分析器</title>
            <paragraph>The profiler is used to see what code is running while your project is in use,
                and how that effects performance.</paragraph>
            <seealso>
                <paragraph>A detailed explanation of how to use the profiler can be found in the
                    dedicated <reference internal="True" refuri="the_profiler#doc-the-profiler"><inline classes="std std-ref">性能分析器</inline></reference> page.</paragraph>
            </seealso>
        </section>
        <section ids="visual-profiler" names="visual\ profiler">
            <title>Visual Profiler</title>
            <paragraph>The Visual Profiler can be used to monitor what is taking the most time when
                rendering a frame on the CPU and GPU respectively. This allows tracking sources
                of potential CPU and GPU bottlenecks caused by rendering.</paragraph>
            <warning>
                <paragraph>The Visual Profiler only measures CPU time taken for rendering tasks, such
                    as performing draw calls. The Visual Profiler does <strong>not</strong> include CPU time
                    taken for other tasks such as scripting and physics. Use the standard
                    Profiler tab to track non-rendering-related CPU tasks.</paragraph>
            </warning>
            <paragraph>To use the visual profiler, run the project, switch to the <strong>Visual Profiler</strong>
                tab within the Debugger bottom panel, then click <strong>Start</strong>:</paragraph>
            <figure ids="id1">
                <image alt="Visual Profiler tab after clicking Start, waiting for a few seconds, then clicking Stop" candidates="{'*': 'tutorials/scripting/debug/img/debugger_visual_profiler_results.webp'}" uri="tutorials/scripting/debug/img/debugger_visual_profiler_results.webp"></image>
                <caption>Visual Profiler tab after clicking <strong>Start</strong>, waiting for a few seconds, then clicking <strong>Stop</strong></caption>
            </figure>
            <paragraph>You will see categories and results appearing as the profiler is running. Graph
                lines also appear, with the left side being a CPU framegraph and the right side
                being a GPU framegraph.</paragraph>
            <paragraph>Click <strong>Stop</strong> to finish profiling, which will keep the results visible but
                frozen in place. Results remain visible after stopping the running project, but
                not after exiting the editor.</paragraph>
            <paragraph>Click on result categories on the left to highlight them in the CPU and GPU
                graphs on the right. You can also click on the graph to move the cursor to a
                specific frame number and highlight the selected data type in the result
                categories on the left.</paragraph>
            <paragraph>You can switch the result display between a time value (in milliseconds per
                frame) or a percentage of the target frametime (which is currently hardcoded to
                16.67 milliseconds, or 60 FPS).</paragraph>
            <paragraph>If framerate spikes occur during profiling, this can cause the graph to be
                poorly scaled. Disable <strong>Fit to Frame</strong> so that the graph will zoom onto the 60
                FPS+ portion.</paragraph>
            <note>
                <paragraph>Remember that Visual Profiler results can vary <strong>heavily</strong> based on
                    viewport resolution, which is determined by the window size if using the
                    <literal>disabled</literal> or <literal>canvas_items</literal> <reference internal="True" refuri="../../rendering/multiple_resolutions#doc-multiple-resolutions"><inline classes="std std-ref">stretch modes</inline></reference>.</paragraph>
                <paragraph>When comparing results across different runs, make sure to use the same
                    viewport size for all runs.</paragraph>
            </note>
            <paragraph>Visual Profiler is supported when using any rendering method (Forward+, Mobile
                or Compatibility), but the reported categories will vary depending on the
                current rendering method as well as the enabled graphics features. For example,
                when using Forward+, a simple 2D scene with shadow-casting lights will result in
                the following categories appearing:</paragraph>
            <figure ids="id2">
                <image alt="例子结果来自Callgrind, 这是Valgrind的一部分" candidates="{'*': 'tutorials/scripting/debug/img/debugger_visual_profiler_2d_example.webp'}" uri="tutorials/scripting/debug/img/debugger_visual_profiler_2d_example.webp"></image>
                <caption>例子结果来自Callgrind, 这是Valgrind的一部分</caption>
            </figure>
            <paragraph>To give another example with Forward+, a 3D scene with shadow-casting lights and
                various effects enabled will result in the following categories enabled:</paragraph>
            <figure ids="id3">
                <image alt="可视分析器中 3D 场景的示例结果" candidates="{'*': 'tutorials/scripting/debug/img/debugger_visual_profiler_3d_example.webp'}" uri="tutorials/scripting/debug/img/debugger_visual_profiler_3d_example.webp"></image>
                <caption>可视分析器中 3D 场景的示例结果</caption>
            </figure>
            <paragraph>Notice how in the 3D example, several of the categories have <strong>(Parallel)</strong>
                appended to their name. This hints that multiple tasks are being performed in
                parallel on the GPU. This generally means that disabling only one of the
                features involved won't improve performance as much as anticipated, as the other
                task still needs to be performed sequentially.</paragraph>
        </section>
        <section ids="network-profiler" names="network\ profiler 网络分析器">
            <title>网络分析器</title>
            <paragraph>网络剖析器包含了所有通过多人游戏API进行通信的节点列表, 对于每个节点, 还包含了一些传入和传出网络交互量的计数器. 它还具有一个带宽表, 可以显示任何特定时刻的总带宽使用情况.</paragraph>
            <note>
                <paragraph>The bandwidth meter does <strong>not</strong> take the <reference internal="True" refuri="../../networking/high_level_multiplayer#doc-high-level-multiplayer"><inline classes="std std-ref">高级多人游戏</inline></reference>
                    API's own compression system into account. This means that changing the
                    compression algorithm used will not change the metrics reported by the
                    bandwidth meter.</paragraph>
            </note>
        </section>
        <section ids="monitors" names="monitors 监视">
            <title>监视</title>
            <paragraph>监视器是游戏运行时几个方面的图表, 如FPS, 内存使用情况, 场景中的节点数量等等. 所有的监控器都会自动跟踪统计, 所以即使游戏运行时一个监控器没有打开, 你也可以在以后打开它, 查看数值的变化.</paragraph>
            <seealso>
                <paragraph>In addition to the default performance monitors, you can also create
                    <reference internal="True" refuri="custom_performance_monitors#doc-custom-performance-monitors"><inline classes="std std-ref">custom performance monitors</inline></reference>
                    to track arbitrary values in your project.</paragraph>
            </seealso>
        </section>
        <section ids="video-ram" names="video\ ram 显存">
            <title>显存</title>
            <paragraph><strong>显存</strong>标签显示了游戏运行时的显存使用情况。它按资源路径提供了每一个使用显存的资源列表、资源的类型、资源的格式，以及该资源使用了多少显存。在面板的右上方还有一个显存占用总量的数字。</paragraph>
            <image candidates="{'*': 'tutorials/scripting/debug/img/video_ram.png'}" uri="tutorials/scripting/debug/img/video_ram.png"></image>
        </section>
        <section ids="misc" names="misc 其他">
            <title>其他</title>
            <paragraph><strong>其他</strong>选项卡中的工具可以用来识别你在运行时点击了哪个控件节点：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>点击的控件</strong>显示的是被点击节点在场景树中的位置。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>点击的控件类型</strong>显示的是被点击节点的类型。</paragraph>
                </list_item>
            </bullet_list>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
