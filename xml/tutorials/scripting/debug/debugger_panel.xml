<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/debug/debugger_panel.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-debugger-panel"></target>
    <section ids="debugger-panel doc-debugger-panel" names="debugger\ panel doc_debugger_panel">
        <title>Debugger panel</title>
        <paragraph>Many of Godot's debugging tools, including the debugger, can be found in the
            debugger panel at the bottom of the screen. Click on <strong>Debugger</strong> to open it.</paragraph>
        <image candidates="{'*': 'tutorials/scripting/debug/img/overview_debugger.webp'}" original_uri="img/overview_debugger.webp" uri="tutorials/scripting/debug/img/overview_debugger.webp"></image>
        <paragraph>The debugger panel is split into several tabs, each focusing on a specific task.</paragraph>
        <section ids="stack-trace" names="stack\ trace">
            <title>Stack Trace</title>
            <paragraph>The Stack Trace tab opens automatically when the GDScript compiler reaches
                a breakpoint in your code.</paragraph>
            <paragraph>It gives you a <reference name="stack trace" refuri="https://en.wikipedia.org/wiki/Stack_trace">stack trace</reference>,
                information about the state of the object, and buttons to control the program's
                execution. When the debugger breaks on a breakpoint, a green triangle arrow is
                visible in the script editor's gutter. This arrow indicates the line of code the
                debugger broke on.</paragraph>
            <tip>
                <paragraph>You can create a breakpoint by clicking the gutter in the left of the script
                    editor (on the left of the line numbers). When hovering this gutter, you
                    will see a transparent red dot appearing, which turns into an opaque red dot
                    after the breakpoint is placed by clicking. Click the red dot again to
                    remove the breakpoint. Breakpoints created this way persist across editor
                    restarts, even if the script wasn't saved when exiting the editor.</paragraph>
                <paragraph>You can also use the <literal>breakpoint</literal> keyword in GDScript to create a
                    breakpoint that is stored in the script itself. Unlike breakpoints created by
                    clicking in the gutter, this keyword-based breakpoint is persistent across
                    different machines when using version control.</paragraph>
            </tip>
            <paragraph>You can use the buttons in the top-right corner to:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Skip all breakpoints. That way, you can save breakpoints for future
                        debugging sessions.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Copy the current error message.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Step Into</strong> the code. This button takes you to the next line of code,
                        and if it's a function, it steps line-by-line through the function.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Step Over</strong> the code. This button goes to the next line of code,
                        but it doesn't step line-by-line through functions.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Break</strong>. This button pauses the game's execution.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Continue</strong>. This button resumes the game after a breakpoint or pause.</paragraph>
                </list_item>
            </bullet_list>
            <note>
                <paragraph>Using the debugger and breakpoints on <reference internal="True" refuri="../../plugins/running_code_in_the_editor#doc-running-code-in-the-editor"><inline classes="std std-ref">tool scripts</inline></reference>
                    is not currently supported. Breakpoints placed in the script editor or using
                    the <literal>breakpoint</literal> keyword are ignored. You can use print statements to
                    display the contents of variables instead.</paragraph>
            </note>
        </section>
        <section ids="errors" names="errors">
            <title>Errors</title>
            <paragraph>This is where error and warning messages are printed while running the game.</paragraph>
            <paragraph>You can disable specific warnings in <strong>Project Settings &gt; Debug &gt; GDScript</strong>.</paragraph>
        </section>
        <section ids="evaluator" names="evaluator">
            <title>Evaluator</title>
            <paragraph>This tab contains an expression evaluator, also known as a <abbreviation explanation="Read-Eval-Print Loop">REPL</abbreviation>.
                This is a more powerful complement to the Stack Variables tree available in the Stack Trace tab.</paragraph>
            <paragraph>When the project is interrupted in the debugger (due to a breakpoint or script
                error), you can enter an expression in the text field at the top. If the project
                is running, the expression field won't be editable, so you will need to set a
                breakpoint first. Expressions can be persisted across runs by unchecking <strong>Clear on Run</strong>,
                although they will be lost when the editor quits.</paragraph>
            <paragraph>Expressions are evaluated using <reference internal="True" refuri="../evaluating_expressions#doc-evaluating-expressions"><inline classes="std std-ref">Godot's expression language</inline></reference>, which allows you to perform arithmetic and call
                some functions within the expression. Expressions can refer to member variables,
                or local variables within the same scope as the line the breakpoint is on. You
                can also enter constant values, which makes it usable as a built-in calculator.</paragraph>
            <paragraph>Consider the following script:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var counter = 0

func _process(delta):
    counter += 1
    if counter == 5:
        var text = "Some text"
        breakpoint
    elif counter &gt;= 6:
        var other_text = "Some other text"
        breakpoint</literal_block>
            <paragraph>If the debugger breaks on the <strong>first</strong> line containing <literal>breakpoint</literal>, the following
                expressions return non-null values:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Constant expression:</strong> <literal>2 * PI + 5</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Member variable:</strong> <literal>counter</literal>, <literal>counter ** 2</literal>, <literal>sqrt(counter)</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Local variable or function parameter:</strong> <literal>delta</literal>, <literal>text</literal>, <literal>text.to_upper()</literal></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If the debugger breaks on the <strong>second</strong> line containing <literal>breakpoint</literal>, the following
                expressions return non-null values:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Constant expression:</strong> <literal>2 * PI + 5</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Member variable:</strong> <literal>counter</literal>, <literal>counter ** 2</literal>, <literal>sqrt(counter)</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Local variable or function parameter:</strong> <literal>delta</literal>, <literal>other_text</literal>, <literal>other_text.to_upper()</literal></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="profiler" names="profiler">
            <title>Profiler</title>
            <paragraph>The profiler is used to see what code is running while your project is in use,
                and how that effects performance.</paragraph>
            <seealso>
                <paragraph>A detailed explanation of how to use the profiler can be found in the
                    dedicated <reference internal="True" refuri="the_profiler#doc-the-profiler"><inline classes="std std-ref">The Profiler</inline></reference> page.</paragraph>
            </seealso>
            <target refid="doc-debugger-panel-visual-profiler"></target>
        </section>
        <section ids="visual-profiler doc-debugger-panel-visual-profiler" names="visual\ profiler doc_debugger_panel_visual_profiler">
            <title>Visual Profiler</title>
            <paragraph>The Visual Profiler can be used to monitor what is taking the most time when
                rendering a frame on the CPU and GPU respectively. This allows tracking sources
                of potential CPU and GPU bottlenecks caused by rendering.</paragraph>
            <warning>
                <paragraph>The Visual Profiler only measures CPU time taken for rendering tasks, such
                    as performing draw calls. The Visual Profiler does <strong>not</strong> include CPU time
                    taken for other tasks such as scripting and physics. Use the standard
                    Profiler tab to track non-rendering-related CPU tasks.</paragraph>
            </warning>
            <paragraph>To use the visual profiler, run the project, switch to the <strong>Visual Profiler</strong>
                tab within the Debugger bottom panel, then click <strong>Start</strong>:</paragraph>
            <figure ids="id1">
                <image alt="Visual Profiler tab after clicking Start, waiting for a few seconds, then clicking Stop" candidates="{'*': 'tutorials/scripting/debug/img/debugger_visual_profiler_results.webp'}" original_uri="img/debugger_visual_profiler_results.webp" uri="tutorials/scripting/debug/img/debugger_visual_profiler_results.webp"></image>
                <caption>Visual Profiler tab after clicking <strong>Start</strong>, waiting for a few seconds, then clicking <strong>Stop</strong></caption>
            </figure>
            <tip>
                <paragraph>You can also check <strong>Autostart</strong>, which will make the visual profiler automatically
                    start when the project is run the next time. Note that the <strong>Autostart</strong>
                    checkbox's state is not preserved across editor sessions.</paragraph>
            </tip>
            <paragraph>You will see categories and results appearing as the profiler is running. Graph
                lines also appear, with the left side being a CPU framegraph and the right side
                being a GPU framegraph.</paragraph>
            <paragraph>Click <strong>Stop</strong> to finish profiling, which will keep the results visible but
                frozen in place. Results remain visible after stopping the running project, but
                not after exiting the editor.</paragraph>
            <paragraph>Click on result categories on the left to highlight them in the CPU and GPU
                graphs on the right. You can also click on the graph to move the cursor to a
                specific frame number and highlight the selected data type in the result
                categories on the left.</paragraph>
            <paragraph>You can switch the result display between a time value (in milliseconds per
                frame) or a percentage of the target frametime (which is currently hardcoded to
                16.67 milliseconds, or 60 FPS).</paragraph>
            <paragraph>If framerate spikes occur during profiling, this can cause the graph to be
                poorly scaled. Disable <strong>Fit to Frame</strong> so that the graph will zoom onto the 60
                FPS+ portion.</paragraph>
            <note>
                <paragraph>Remember that Visual Profiler results can vary <strong>heavily</strong> based on
                    viewport resolution, which is determined by the window size if using the
                    <literal>disabled</literal> or <literal>canvas_items</literal> <reference internal="True" refuri="../../rendering/multiple_resolutions#doc-multiple-resolutions"><inline classes="std std-ref">stretch modes</inline></reference>.</paragraph>
                <paragraph>When comparing results across different runs, make sure to use the same
                    viewport size for all runs.</paragraph>
            </note>
            <paragraph>Visual Profiler is supported when using any rendering method (Forward+, Mobile
                or Compatibility), but the reported categories will vary depending on the
                current rendering method as well as the enabled graphics features. For example,
                when using Forward+, a simple 2D scene with shadow-casting lights will result in
                the following categories appearing:</paragraph>
            <figure ids="id2">
                <image alt="Example results from a 2D scene in the Visual Profiler" candidates="{'*': 'tutorials/scripting/debug/img/debugger_visual_profiler_2d_example.webp'}" original_uri="img/debugger_visual_profiler_2d_example.webp" uri="tutorials/scripting/debug/img/debugger_visual_profiler_2d_example.webp"></image>
                <caption>Example results from a 2D scene in the Visual Profiler</caption>
            </figure>
            <paragraph>To give another example with Forward+, a 3D scene with shadow-casting lights and
                various effects enabled will result in the following categories enabled:</paragraph>
            <figure ids="id3">
                <image alt="Example results from a 3D scene in the Visual Profiler" candidates="{'*': 'tutorials/scripting/debug/img/debugger_visual_profiler_3d_example.webp'}" original_uri="img/debugger_visual_profiler_3d_example.webp" uri="tutorials/scripting/debug/img/debugger_visual_profiler_3d_example.webp"></image>
                <caption>Example results from a 3D scene in the Visual Profiler</caption>
            </figure>
            <paragraph>Notice how in the 3D example, several of the categories have <strong>(Parallel)</strong>
                appended to their name. This hints that multiple tasks are being performed in
                parallel on the GPU. This generally means that disabling only one of the
                features involved won't improve performance as much as anticipated, as the other
                task still needs to be performed sequentially.</paragraph>
            <note>
                <paragraph>The Visual Profiler is not supported when using the Compatibility renderer
                    on macOS, due to platform limitations.</paragraph>
            </note>
        </section>
        <section ids="network-profiler" names="network\ profiler">
            <title>Network Profiler</title>
            <paragraph>The Network Profiler contains a list of all the nodes that communicate over the
                multiplayer API and, for each one, some counters on the amount of incoming and
                outgoing network interactions. It also features a bandwidth meter that displays
                the total bandwidth usage at any given moment.</paragraph>
            <note>
                <paragraph>The bandwidth meter does <strong>not</strong> take the <reference internal="True" refuri="../../networking/high_level_multiplayer#doc-high-level-multiplayer"><inline classes="std std-ref">High-level multiplayer</inline></reference>
                    API's own compression system into account. This means that changing the
                    compression algorithm used will not change the metrics reported by the
                    bandwidth meter.</paragraph>
            </note>
        </section>
        <section ids="monitors" names="monitors">
            <title>Monitors</title>
            <paragraph>The monitors are graphs of several aspects of the game while it's running such as
                FPS, memory usage, how many nodes are in a scene and more. All monitors keep
                track of stats automatically, so even if one monitor isn't open while the game
                is running, you can open it later and see how the values changed.</paragraph>
            <seealso>
                <paragraph>In addition to the default performance monitors, you can also create
                    <reference internal="True" refuri="custom_performance_monitors#doc-custom-performance-monitors"><inline classes="std std-ref">custom performance monitors</inline></reference>
                    to track arbitrary values in your project.</paragraph>
            </seealso>
        </section>
        <section ids="video-ram" names="video\ ram">
            <title>Video RAM</title>
            <paragraph>The <strong>Video RAM</strong> tab shows the video RAM usage of the game while it is running.
                It provides a list of every resource using video RAM by resource path, the type
                of resource it is, what format it is in, and how much Video RAM that resource is
                using. There is also a total video RAM usage number at the top right of the panel.</paragraph>
            <image candidates="{'*': 'tutorials/scripting/debug/img/video_ram.png'}" original_uri="img/video_ram.png" uri="tutorials/scripting/debug/img/video_ram.png"></image>
        </section>
        <section ids="misc" names="misc">
            <title>Misc</title>
            <paragraph>The <strong>Misc</strong> tab contains tools to identify the control nodes you are clicking
                at runtime:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Clicked Control</strong> tells you where the clicked node is in the scene tree.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Clicked Control Type</strong> tells you the type of the node you clicked is.</paragraph>
                </list_item>
            </bullet_list>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
