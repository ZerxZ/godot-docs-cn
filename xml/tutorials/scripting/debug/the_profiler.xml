<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/debug/the_profiler.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-the-profiler"></target>
    <section ids="the-profiler doc-the-profiler" names="the\ profiler 性能分析器 doc_the_profiler">
        <title>性能分析器</title>
        <paragraph>You run your game from Godot and play around. It's fun, it's becoming feature
            complete, and you feel it's getting close to release.</paragraph>
        <paragraph>But then, you open the skill tree, and it grinds to a halt as something snags in
            your code. Watching the skill tree scroll by like it's a slide show is
            unacceptable. What went wrong? Is it positioning the skill tree elements, the
            UI, or rendering?</paragraph>
        <paragraph>You could try to optimize everything and run the game repeatedly, but you can be
            smarter about this and narrow down the possibilities. Enter Godot's profiler.</paragraph>
        <section ids="an-overview-of-the-profiler" names="an\ overview\ of\ the\ profiler">
            <title>An overview of the profiler</title>
            <paragraph>You can open the profiler by opening the <strong>Debugger</strong> panel and clicking on the
                <strong>Profiler</strong> tab.</paragraph>
            <image candidates="{'*': 'tutorials/scripting/debug/img/profiler.png'}" uri="tutorials/scripting/debug/img/profiler.png"></image>
            <paragraph>Godot's profiler does not automatically run because profiling is
                performance-intensive. It has to continually measure everything happening in the
                game and report back to the debugger, so it's off by default.</paragraph>
            <paragraph>To begin profiling, click on the <strong>Start</strong> button in the top-left. Run your game
                and data will start appearing. You can also start profiling at any time before
                or during gameplay, depending on if you want.</paragraph>
            <note>
                <paragraph>The profiler does not currently support C# scripts. C# scripts can be profiled
                    using JetBrains Rider and JetBrains dotTrace with the Godot support plugin.</paragraph>
            </note>
            <paragraph>You can clear the data by clicking the <strong>Clear</strong> button anytime. Use the
                <strong>Measure</strong> drop-down menu to change the type of data you measure. The
                measurements panel and the graph will update accordingly.</paragraph>
        </section>
        <section ids="the-measured-data" names="the\ measured\ data">
            <title>The measured data</title>
            <paragraph>The profiler's interface is split into two. There is a list of functions on the
                left and the performance graph on the right.</paragraph>
            <paragraph>The main measurements are frame time, physics frame, idle time, and physics time.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The <strong>frame time</strong> is the time it takes Godot to execute all the logic for an
                        entire image, from physics to rendering.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Physics frame</strong> is the time Godot has allocated between physics updates. In
                        an ideal scenario, the frame time is whatever you chose: 16.66 milliseconds by
                        default, which corresponds to 60FPS. It's a frame of reference you can use for
                        everything else around it.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Idle time</strong> is the time Godot took to update logic other than physics, such
                        as code that lives in <title_reference>_process</title_reference> or timers and cameras set to update on
                        <strong>Idle</strong>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Physics time</strong> is the time Godot took to update physics tasks, like
                        <title_reference>_physics_process</title_reference> and built-in nodes set to <strong>Physics</strong> update.</paragraph>
                </list_item>
            </bullet_list>
            <note>
                <paragraph><strong>Frame Time</strong> includes rendering time. Say you find a mysterious
                    spike of lag in your game, but your physics and scripts are
                    all running fast. The delay could be due to the appearance of
                    particles or visual effects!</paragraph>
            </note>
            <paragraph>By default, Godot ticks on Frame Time and Physics Time. This gives you an
                overview of how long each frame takes relative to the allocated desired physics
                FPS. You can toggle functions on and off by clicking the checkboxes on the left.
                Other facilities make appearances as you go down the list, like Physics 2D,
                Physics, and Audio, before reaching Script functions, where your code appears.</paragraph>
            <paragraph>If you click on the graph, you change which frame's information appears on the
                left. In the top right, there is also a frame counter where you can manually
                adjust the frame you are looking at more granularly.</paragraph>
        </section>
        <section ids="scope-of-measurement-and-measurement-windows" names="scope\ of\ measurement\ and\ measurement\ windows">
            <title>Scope of measurement and measurement windows</title>
            <paragraph>You can change what measurement you are looking at using the <strong>Measure</strong>
                drop-down menu. By default, it starts with Frame Time and lists the time it
                takes to go through the frame in milliseconds. The average time is the average
                time any given function took when called more than once. For example, a function
                that took 0.05 milliseconds to run five times should give you an average of 0.01
                milliseconds.</paragraph>
            <paragraph>If accurate milliseconds count is not important, and you want to see proportions
                of time relative to the rest of the frame, use percentage measurements. Frame %
                is relative to Frame Time, and Physics % is relative to Physics Time.</paragraph>
            <paragraph>The last option is the scope of the time. <strong>Inclusive</strong> measures the time a
                function took <strong>with</strong> any nested function calls. For example:</paragraph>
            <image candidates="{'*': 'tutorials/scripting/debug/img/split_curve.png'}" uri="tutorials/scripting/debug/img/split_curve.png"></image>
            <paragraph><title_reference>get_neighbors</title_reference>, <title_reference>find_nearest_neighbor</title_reference> and <title_reference>move_subject</title_reference> all took a lot of
                time. You could be fooled into thinking that this is because all three of them
                are slow.</paragraph>
            <paragraph>But when changed to <strong>Self</strong>, Godot measures the time spent in the function body
                without considering function calls it made itself.</paragraph>
            <image candidates="{'*': 'tutorials/scripting/debug/img/self_curve.png'}" uri="tutorials/scripting/debug/img/self_curve.png"></image>
            <paragraph>You can see that <title_reference>get_neighbors</title_reference> and <title_reference>move_subject</title_reference> have lost a lot of their
                importance. In effect, that means that <title_reference>get_neighbors</title_reference> and <title_reference>move_subject</title_reference> have
                spent more time waiting for some other function call to finish than not, and
                <title_reference>find_nearest_neighbor</title_reference> is <strong>actually</strong> slow.</paragraph>
        </section>
        <section ids="debugging-slow-code-with-the-profiler" names="debugging\ slow\ code\ with\ the\ profiler">
            <title>Debugging slow code with the profiler</title>
            <paragraph>Finding slow code with the profiler boils down to running your game and watching
                the performance graph as it draws. When an unacceptable spike occurs in the
                frame time, you can click on the graph to pause your game and narrow the _Frame
                #_ to the spike's start. You may need to jump back and forth between frames and
                functions to find the root cause.</paragraph>
            <paragraph>Under the Script functions, turn on the checkboxes for some functions to find
                which take time. These are the functions you need to review and optimize.</paragraph>
        </section>
        <section ids="measuring-manually-in-microseconds" names="measuring\ manually\ in\ microseconds">
            <title>Measuring manually in microseconds</title>
            <paragraph>如果函数比较复杂，那么找出需要优化的部分可能会很困难。是数学的问题，还是获取进行数学运算所需数据的方式的问题？是 <title_reference>for</title_reference> 循环吗？还是 <title_reference>if</title_reference> 语句？</paragraph>
            <paragraph>你可以让程序运行一些临时函数，手动计算时刻，来缩小测量范围。有两个属于 <title_reference>Time</title_reference> 类对象的函数，分别是 <title_reference>get_ticks_msec</title_reference> 和 <title_reference>get_ticks_usec</title_reference> 。第一个会以毫秒为单位（每秒为1,000毫秒）测量，而第二个则以微秒为单位（每秒为1,000,000微秒）测量。</paragraph>
            <paragraph>两者都会以各自的时间量返回游戏引擎启动以来经过的时间。</paragraph>
            <paragraph>如果使用微秒的开始和结束包裹一段代码，那两者的差则是运行这段代码花费的时间。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Measuring the time it takes for worker_function() to run
var start = Time.get_ticks_usec()
worker_function()
var end = Time.get_ticks_usec()
var worker_time = (end-start)/1000000.0

# Measuring the time spent running a calculation over each element of an array
start = Time.get_ticks_usec()
for calc in calculations:
    result = pow(2, calc.power) * calc.product
end = Time.get_ticks_usec()
var loop_time = (end-start)/1000000.0

print("Worker time: %s\nLoop time: %s" % [worker_time, loop_time])</literal_block>
                </div>
            </container>
            <paragraph>As you become a more experienced programmer, this technique becomes less
                necessary. You begin to learn what parts of a running program are slow. Knowing
                that loops and branches can be slow comes from experience, and you gain
                experience by measuring and doing research.</paragraph>
            <paragraph>But between the profiler and the ticks functions, you should have enough to get
                started finding which parts of your code need optimization.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
