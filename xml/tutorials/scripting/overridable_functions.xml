<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/overridable_functions.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-overridable-functions"></target>
    <section ids="overridable-functions doc-overridable-functions" names="overridable\ functions doc_overridable_functions">
        <title>Overridable functions</title>
        <paragraph>Godot's Node class provides virtual functions you can override to update nodes
            every frame or on specific events, like when they enter the scene tree.</paragraph>
        <paragraph>This document presents the ones you'll use most often.</paragraph>
        <seealso>
            <paragraph>Under the hood, these functions rely on Godot's low-level
                notifications system. To learn more about it, see
                <reference internal="True" refuri="../best_practices/godot_notifications#doc-godot-notifications"><inline classes="std std-ref">Godot notifications</inline></reference>.</paragraph>
        </seealso>
        <paragraph>Two functions allow you to initialize and get nodes besides the class's
            constructor: <literal>_enter_tree()</literal> and <literal>_ready()</literal>.</paragraph>
        <paragraph>When the node enters the Scene Tree, it becomes active and the engine calls its
            <literal>_enter_tree()</literal> method. That node's children may not be part of the active scene yet. As
            you can remove and re-add nodes to the scene tree, this function may be called
            multiple times throughout a node's lifetime.</paragraph>
        <paragraph>Most of the time, you'll use <literal>_ready()</literal> instead. This function is called only
            once in a node's lifetime, after <literal>_enter_tree()</literal>. <literal>_ready()</literal> ensures that all children
            have entered the scene tree first, so you can safely call <literal>get_node()</literal> on them.</paragraph>
        <seealso>
            <paragraph>To learn more about getting node references, read
                <reference internal="True" refuri="nodes_and_scene_instances#doc-nodes-and-scene-instances"><inline classes="std std-ref">Nodes and scene instances</inline></reference>.</paragraph>
        </seealso>
        <paragraph>Another related callback is <literal>_exit_tree()</literal>, which the engine calls every time
            a node is about to exit the scene tree. This can be when you call <reference internal="True" refuri="../../classes/class_node#class-node-method-remove-child"><inline classes="std std-ref">Node.remove_child()</inline></reference> or when you free a node.</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Called every time the node enters the scene tree.
func _enter_tree():
    pass

# Called when both the node and its children have entered the scene tree.
func _ready():
    pass

# Called when the node is about to leave the scene tree, after all its
# children received the _exit_tree() callback.
func _exit_tree():
    pass</literal_block>
            </div>
            <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Called every time the node enters the scene tree.
public override void _EnterTree()
{
    base._EnterTree();
}

// Called when both the node and its children have entered the scene tree.
public override void _Ready()
{
    base._Ready();
}

// Called when the node is about to leave the scene tree, after all its
// children.
public override void _ExitTree()
{
    base._ExitTree();
}</literal_block>
            </div>
        </container>
        <paragraph>The two virtual methods <literal>_process()</literal> and <literal>_physics_process()</literal> allow you to
            update the node, every frame and every physics frame respectively. For more
            information, read the dedicated documentation:
            <reference internal="True" refuri="idle_and_physics_processing#doc-idle-and-physics-processing"><inline classes="std std-ref">Idle and Physics Processing</inline></reference>.</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Called every frame.
func _process(delta):
    pass

# Called every physics frame.
func _physics_process(delta):
    pass</literal_block>
            </div>
            <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Process(double delta)
{
    // Called every frame.
    base._Process(delta);
}

public override void _PhysicsProcess(double delta)
{
    // Called every physics frame.
    base._PhysicsProcess(delta);
}</literal_block>
            </div>
        </container>
        <paragraph>Two more essential built-in node callback functions are
            <reference internal="True" refuri="../../classes/class_node#class-node-private-method-unhandled-input"><inline classes="std std-ref">Node._unhandled_input()</inline></reference> and
            <reference internal="True" refuri="../../classes/class_node#class-node-private-method-input"><inline classes="std std-ref">Node._input()</inline></reference>, which you use to both receive
            and process individual input events. The <literal>_unhandled_input()</literal> method receives
            every key press, mouse click, etc. that have not been handled already in an
            <literal>_input()</literal> callback or in a user interface component. You want to use it for
            gameplay input in general. The <literal>_input()</literal> callback allows you to intercept and
            process input events before <literal>_unhandled_input()</literal> gets them.</paragraph>
        <paragraph>To learn more about inputs in Godot, see the <reference internal="True" refuri="../inputs/index#toc-learn-features-inputs"><inline classes="std std-ref">Input section</inline></reference>.</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Called once for every event.
func _unhandled_input(event):
    pass

# Called once for every event before _unhandled_input(), allowing you to
# consume some events.
func _input(event):
    pass</literal_block>
            </div>
            <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Called once for every event.
public override void _UnhandledInput(InputEvent @event)
{
    base._UnhandledInput(@event);
}

// Called once for every event before _UnhandledInput(), allowing you to
// consume some events.
public override void _Input(InputEvent @event)
{
    base._Input(@event);
}</literal_block>
            </div>
        </container>
        <paragraph>There are some more overridable functions like
            <reference internal="True" refuri="../../classes/class_node#class-node-private-method-get-configuration-warnings"><inline classes="std std-ref">Node._get_configuration_warnings()</inline></reference>. Specialized node types provide
            more callbacks like <reference internal="True" refuri="../../classes/class_canvasitem#class-canvasitem-private-method-draw"><inline classes="std std-ref">CanvasItem._draw()</inline></reference> to
            draw programmatically or <reference internal="True" refuri="../../classes/class_control#class-control-private-method-gui-input"><inline classes="std std-ref">Control._gui_input()</inline></reference> to handle clicks and input on UI elements.</paragraph>
        <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
    </section>
</document>
