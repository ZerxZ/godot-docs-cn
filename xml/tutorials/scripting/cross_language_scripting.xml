<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/cross_language_scripting.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-cross-language-scripting"></target>
    <section ids="cross-language-scripting doc-cross-language-scripting" names="cross-language\ scripting 跨语言脚本 doc_cross_language_scripting">
        <title>跨语言脚本</title>
        <paragraph>Godot 允许混合、匹配使用脚本语言以满足你的需求，也就是说，一个项目可以同时用 C# 和 GDScript 定义节点。本页将用不同语言编写的两个脚本来介绍这两种语言之间可进行的交互。</paragraph>
        <paragraph>以下两个脚本在整个页面中用作参考。</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

var my_field: String = "foo"

func print_node_name(node: Node) -&gt; void:
    print(node.get_name())

func print_array(arr: Array) -&gt; void:
    for element in arr:
        print(element)

func print_n_times(msg: String, n: int) -&gt; void:
    for i in range(n):
        print(msg)</literal_block>
            </div>
            <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyCSharpNode : Node
{
    public string myField = "bar";

    public void PrintNodeName(Node node)
    {
        GD.Print(node.Name);
    }

    public void PrintArray(string[] arr)
    {
        foreach (string element in arr)
        {
            GD.Print(element);
        }
    }

    public void PrintNTimes(string msg, int n)
    {
        for (int i = 0; i &lt; n; ++i)
        {
            GD.Print(msg);
        }
    }
}</literal_block>
            </div>
        </container>
        <section ids="instantiating-nodes" names="instantiating\ nodes 实例化节点">
            <title>实例化节点</title>
            <paragraph>如果不想通过场景树来使用节点，则可能需要直接通过代码来实例化节点。</paragraph>
            <section ids="instantiating-c-nodes-from-gdscript" names="instantiating\ c#\ nodes\ from\ gdscript 在\ gdscript\ 中实例化\ c#\ 节点">
                <title>在 GDScript 中实例化 C# 节点</title>
                <paragraph>在 GDScript 中使用 C# 脚本并不麻烦，C# 脚本经加载后（见 <reference internal="True" refuri="gdscript/gdscript_basics#doc-gdscript-classes-as-resources"><inline classes="std std-ref">类作为资源</inline></reference>）便可使用 <reference internal="True" refuri="../../classes/class_csharpscript#class-csharpscript-method-new"><inline classes="std std-ref">new()</inline></reference> 来进行实例化。</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var my_csharp_script = load("res://Path/To/MyCSharpNode.cs")
var my_csharp_node = my_csharp_script.new()</literal_block>
                <warning>
                    <paragraph>创建 <literal>.cs</literal> 脚本时，要始终记住：Godot 会使用和这个 <literal>.cs</literal> 文件名相同的类进行相关操作。如果文件中不存在该类，那么你将会看到以下错误: <literal>Invalid call. Nonexistent function `new` in base</literal> 。</paragraph>
                    <paragraph>例如：MyCoolNode.cs 应该包含一个名为 MyCoolNode 的类。</paragraph>
                    <paragraph>C# 类也需要获取 Godot 类，如<literal>GodotObject</literal>，否则将触发同样的错误。</paragraph>
                    <paragraph>你还需要检查在项目的 <literal>.csproj</literal> 文件中是否引用了该 <literal>.cs</literal> 文件的内容，否则将触发同样的错误。</paragraph>
                </warning>
            </section>
            <section ids="instantiating-gdscript-nodes-from-c" names="instantiating\ gdscript\ nodes\ from\ c# 在\ c#\ 中实例化\ gdscript\ 节点">
                <title>在 C# 中实例化 GDScript 节点</title>
                <paragraph>在 C# 侧的实例化方式与 GDScript 的基本相同，加载 GDScript 脚本后，该 GDScript 脚本就可以使用<reference internal="True" refuri="../../classes/class_gdscript#class-gdscript-method-new"><inline classes="std std-ref">GDScript.New()</inline></reference>实例化。</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GDScript MyGDScript = GD.Load&lt;GDScript&gt;("res://path/to/my_gd_script.gd");
GodotObject myGDScriptNode = (GodotObject)MyGDScript.New(); // This is a GodotObject.</literal_block>
                <paragraph>在这里我们用 <reference internal="True" refuri="../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference> 进行转型，但是也可以使用 Godot 所提供的类型转换语法转型，见<reference internal="True" refuri="c_sharp/c_sharp_features#doc-c-sharp-features-type-conversion-and-casting"><inline classes="std std-ref">类型转换和强制转换</inline></reference>章节。</paragraph>
            </section>
        </section>
        <section ids="accessing-fields" names="accessing\ fields 访问字段">
            <title>访问字段</title>
            <section ids="accessing-c-fields-from-gdscript" names="accessing\ c#\ fields\ from\ gdscript 从\ gdscript\ 中访问\ c#\ 字段">
                <title>从 GDScript 中访问 C# 字段</title>
                <paragraph>从 GDScript 访问 C# 字段非常简单，大可不必担心会出现什么问题。</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">print(my_csharp_node.myField) # bar
my_csharp_node.myField = "BAR"
print(my_csharp_node.myField) # BAR</literal_block>
            </section>
            <section ids="accessing-gdscript-fields-from-c" names="accessing\ gdscript\ fields\ from\ c# 从\ c#\ 中访问\ gdsscript">
                <title>从 C# 中访问 GDSscript</title>
                <paragraph>由于 C# 是静态类型语言，因此在 C# 脚本里访问 GDScript 字段会有点复杂，此时必须使用 <reference internal="True" refuri="../../classes/class_object#class-object-method-get"><inline classes="std std-ref">Object.Get()</inline></reference> 和 <reference internal="True" refuri="../../classes/class_object#class-object-method-set"><inline classes="std std-ref">Object.Set()</inline></reference> 来读写字段，其首个参数为要访问的字段的名称。</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GD.Print(myGDScriptNode.Get("my_field")); // foo
myGDScriptNode.Set("my_field", "FOO");
GD.Print(myGDScriptNode.Get("my_field")); // FOO</literal_block>
                <paragraph>需要牢记：在给字段赋值时只能使用 GDScript 已知的类型，实际上指的就是 GDScript 的内置类型 <reference internal="True" refuri="gdscript/gdscript_basics#doc-gdscript"><inline classes="std std-ref">GDScript 参考</inline></reference> 或 <reference internal="True" refuri="../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference> 的子类型。</paragraph>
            </section>
        </section>
        <section ids="calling-methods" names="calling\ methods 调用方法">
            <title>调用方法</title>
            <section ids="calling-c-methods-from-gdscript" names="calling\ c#\ methods\ from\ gdscript 在\ gdscript\ 中调用\ c#\ 方法">
                <title>在 GDScript 中调用 C# 方法</title>
                <paragraph>在 GDScript 里调用 C# 方法同样非常简单，调用 C# 脚本的方法时将尽可能地将你的参数类型进行强制转型以匹配函数签名。如果调用失败，则会看到以下错误 <literal>Invalid call. Nonexistent function `FunctionName`</literal>。</paragraph>
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">my_csharp_node.PrintNodeName(self) # myGDScriptNode
# my_csharp_node.PrintNodeName() # This line will fail.

my_csharp_node.PrintNTimes("Hello there!", 2) # Hello there! Hello there!

my_csharp_node.PrintArray(["a", "b", "c"]) # a, b, c
my_csharp_node.PrintArray([1, 2, 3]) # 1, 2, 3</literal_block>
            </section>
            <section ids="calling-gdscript-methods-from-c" names="calling\ gdscript\ methods\ from\ c# 从\ c#\ 中\ 调用\ gdscript\ 方法">
                <title>从 C# 中 调用 GDScript 方法</title>
                <paragraph>在 C# 脚本中调用 GDScript 脚本的方法时需要使用 <reference internal="True" refuri="../../classes/class_object#class-object-method-call"><inline classes="std std-ref">Object.Call()</inline></reference> 函数，该方法的第一个参数为想要调用方法的名称，之后的其他参数会顺次传递给被调用的方法。</paragraph>
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">myGDScriptNode.Call("print_node_name", this); // my_csharp_node
// myGDScriptNode.Call("print_node_name"); // This line will fail silently and won't error out.

myGDScriptNode.Call("print_n_times", "Hello there!", 2); // Hello there! Hello there!

string[] arr = new string[] { "a", "b", "c" };
myGDScriptNode.Call("print_array", arr); // a, b, c
myGDScriptNode.Call("print_array", new int[] { 1, 2, 3 }); // 1, 2, 3
// Note how the type of each array entry does not matter as long as it can be handled by the marshaller.</literal_block>
                <warning>
                    <paragraph>如你所见，若被调用方法的第一个参数为数组类型，则需要强制转为 <literal>object</literal>类型，否则该数组内的每个元素都将会被当做单个参数传入，导致与被调用的参数不匹配。</paragraph>
                </warning>
            </section>
        </section>
        <section ids="inheritance" names="inheritance 继承">
            <title>继承</title>
            <paragraph>GDScript 脚本无法继承 C＃脚本。同样，C＃脚本也无法继承 GDScript 脚本。由于该机制实现起来非常复杂，故未来不太可能取消此限制，详见 <reference name="该 GitHub issue" refuri="https://github.com/godotengine/godot/issues/38352">该 GitHub issue</reference><target ids="github-issue" names="该\ github\ issue" refuri="https://github.com/godotengine/godot/issues/38352"></target> 。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
