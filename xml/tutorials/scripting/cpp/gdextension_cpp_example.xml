<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/cpp/gdextension_cpp_example.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-godot-cpp-getting-started"></target>
    <section ids="getting-started doc-godot-cpp-getting-started" names="getting\ started doc_godot_cpp_getting_started">
        <title>Getting started</title>
        <section ids="workflow-overview" names="workflow\ overview">
            <title>Workflow overview</title>
            <paragraph>As a GDExtension, godot-cpp is more complicated to use than <reference internal="True" refuri="../gdscript/index#doc-gdscript"><inline classes="std std-ref">GDScript</inline></reference> and <reference internal="True" refuri="../c_sharp/index#doc-c-sharp"><inline classes="std std-ref">C#</inline></reference>.
                If you decide to work with it, here's what to expect your workflow to look like:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>Create a new godot-cpp project (from the <reference name="template" refuri="https://github.com/godotengine/godot-cpp-template">template</reference>, or from scratch, as explained below).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Develop your code with your <reference internal="True" refuri="../../../engine_details/development/configuring_an_ide/index#toc-devel-configuring-an-ide"><inline classes="std std-ref">favorite IDE</inline></reference> locally.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Build and test your code with the earliest compatible Godot version.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Create builds for all platforms you want to support (e.g. using <reference name="GitHub Actions" refuri="https://github.com/godotengine/godot-cpp-template/blob/main/.github/workflows/builds.yml">GitHub Actions</reference>).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Optional: Publish on the <reference name="Godot Asset Library" refuri="https://godotengine.org/asset-library/asset">Godot Asset Library</reference>.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="example-project" names="example\ project">
            <title>Example project</title>
            <paragraph>For your first godot-cpp project, we recommend starting with this guide to understand the technology involved with
                godot-cpp. After you're done, you can use the <reference name="godot-cpp template" refuri="https://github.com/godotengine/godot-cpp-template">godot-cpp template</reference>,
                which has better coverage of features, such as a GitHub action pipeline and useful <literal>SConstruct</literal> boilerplate code.
                However, the template does not explain itself to a high level of detail, which is why we recommend going through this
                guide first.</paragraph>
        </section>
        <section ids="setting-up-the-project" names="setting\ up\ the\ project">
            <title>Setting up the project</title>
            <paragraph>There are a few prerequisites you'll need:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>A Godot 4 executable.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>A C++ compiler.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>SCons as a build tool.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>A copy of the <reference name="godot-cpp repository" refuri="https://github.com/godotengine/godot-cpp">godot-cpp repository</reference>.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>See also <reference internal="True" refuri="../../../engine_details/development/configuring_an_ide/index#toc-devel-configuring-an-ide"><inline classes="std std-ref">Configuring an IDE</inline></reference>
                and <reference internal="True" refuri="../../../engine_details/development/compiling/index#toc-devel-compiling"><inline classes="std std-ref">Compiling</inline></reference> as the build tools are identical
                to the ones you need to compile Godot from source.</paragraph>
            <paragraph>You can download the <reference name="godot-cpp repository" refuri="https://github.com/godotengine/godot-cpp">godot-cpp repository</reference> from GitHub or let Git do the work for you.
                Note that this repository has different branches for different versions
                of Godot. GDExtensions will not work in older versions of Godot (only Godot 4 and up) and vice versa, so make sure you download the correct branch.</paragraph>
            <note>
                <paragraph>To use <reference name="GDExtension" refuri="https://godotengine.org/article/introducing-gd-extensions">GDExtension</reference>
                    you need to use the godot-cpp branch that matches the version of Godot that you are
                    targeting. For example, if you're targeting Godot 4.1, use the <literal>4.1</literal> branch. Throughout
                    this tutorial we use <literal>4.x</literal>, which will need to be replaced with the version of Godot you
                    are targeting.</paragraph>
                <paragraph>The <literal>master</literal> branch is the development branch which is updated regularly
                    to work with Godot's <literal>master</literal> branch.</paragraph>
            </note>
            <warning>
                <paragraph>GDExtensions targeting an earlier version of Godot should work in later
                    minor versions, but not vice-versa. For example, a GDExtension targeting Godot 4.2
                    should work just fine in Godot 4.3, but one targeting Godot 4.3 won't work in Godot 4.2.</paragraph>
                <paragraph>There is one exception to this: extensions targeting Godot 4.0 will <strong>not</strong> work with
                    Godot 4.1 and later (see <reference internal="True" refuri="../../migrating/upgrading_to_godot_4.1#updating-your-gdextension-for-godot-4-1"><inline classes="std std-ref">Updating your GDExtension for 4.1</inline></reference>).</paragraph>
            </warning>
            <paragraph>If you are versioning your project using Git, it is recommended to add it as
                a Git submodule:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">mkdir gdextension_cpp_example
cd gdextension_cpp_example
git init
git submodule add -b 4.x https://github.com/godotengine/godot-cpp
cd godot-cpp
git submodule update --init</literal_block>
            <paragraph>Alternatively, you can also clone it to the project folder:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">mkdir gdextension_cpp_example
cd gdextension_cpp_example
git clone -b 4.x https://github.com/godotengine/godot-cpp</literal_block>
            <note>
                <paragraph>If you decide to download the repository or clone it into your folder,
                    make sure to keep the folder layout the same as we've setup here. Much of
                    the code we'll be showcasing here assumes the project has this layout.</paragraph>
            </note>
            <paragraph>If you cloned the example from the link specified in the introduction, the
                submodules are not automatically initialized. You will need to execute the
                following commands:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">cd gdextension_cpp_example
git submodule update --init</literal_block>
            <paragraph>This will initialize the repository in your project folder.</paragraph>
        </section>
        <section ids="creating-a-simple-plugin" names="creating\ a\ simple\ plugin">
            <title>Creating a simple plugin</title>
            <paragraph>Now it's time to build an actual plugin. We'll start by creating an empty Godot
                project in which we'll place a few files.</paragraph>
            <paragraph>Open Godot and create a new project. For this example, we will place it in a
                folder called <literal>demo</literal> inside our GDExtension's folder structure.</paragraph>
            <paragraph>In our demo project, we'll create a scene containing a Node called "Main" and
                we'll save it as <literal>main.tscn</literal>. We'll come back to that later.</paragraph>
            <paragraph>Back in the top-level GDExtension module folder, we're also going to create a
                subfolder called <literal>src</literal> in which we'll place our source files.</paragraph>
            <paragraph>You should now have <literal>demo</literal>, <literal>godot-cpp</literal>, and <literal>src</literal>
                directories in your GDExtension module.</paragraph>
            <paragraph>Your folder structure should now look like this:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">gdextension_cpp_example/
|
+--demo/                  # game example/demo to test the extension
|
+--godot-cpp/             # C++ bindings
|
+--src/                   # source code of the extension we are building</literal_block>
            <paragraph>In the <literal>src</literal> folder, we'll start with creating our header file for the
                GDExtension node we'll be creating. We will name it <literal>gdexample.h</literal>:</paragraph>
            <container classes="literal-block-wrapper" ids="id1" literal_block="True">
                <caption>gdextension_cpp_example/src/gdexample.h</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#pragma once

#include &lt;godot_cpp/classes/sprite2d.hpp&gt;

namespace godot {

class GDExample : public Sprite2D {
    GDCLASS(GDExample, Sprite2D)

private:
    double time_passed;

protected:
    static void _bind_methods();

public:
    GDExample();
    ~GDExample();

    void _process(double delta) override;
};

} // namespace godot</literal_block>
            </container>
            <paragraph>There are a few things of note to the above. We include <literal>sprite2d.hpp</literal> which
                contains bindings to the Sprite2D class. We'll be extending this class in our
                module.</paragraph>
            <paragraph>We're using the namespace <literal>godot</literal>, since everything in GDExtension is defined
                within this namespace.</paragraph>
            <paragraph>Then we have our class definition, which inherits from our Sprite2D through a
                container class. We'll see a few side effects of this later on. The
                <literal>GDCLASS</literal> macro sets up a few internal things for us.</paragraph>
            <paragraph>After that, we declare a single member variable called <literal>time_passed</literal>.</paragraph>
            <paragraph>In the next block we're defining our methods, we have our constructor
                and destructor defined, but there are two other functions that will likely look
                familiar to some, and one new method.</paragraph>
            <paragraph>The first is <literal>_bind_methods</literal>, which is a static function that Godot will
                call to find out which methods can be called and which properties it exposes.
                The second is our <literal>_process</literal> function, which will work exactly the same
                as the <literal>_process</literal> function you're used to in GDScript.</paragraph>
            <paragraph>Let's implement our functions by creating our <literal>gdexample.cpp</literal> file:</paragraph>
            <container classes="literal-block-wrapper" ids="id2" literal_block="True">
                <caption>gdextension_cpp_example/src/gdexample.cpp</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "gdexample.h"
#include &lt;godot_cpp/core/class_db.hpp&gt;

using namespace godot;

void GDExample::_bind_methods() {
}

GDExample::GDExample() {
    // Initialize any variables here.
    time_passed = 0.0;
}

GDExample::~GDExample() {
    // Add your cleanup here.
}

void GDExample::_process(double delta) {
    time_passed += delta;

    Vector2 new_position = Vector2(10.0 + (10.0 * sin(time_passed * 2.0)), 10.0 + (10.0 * cos(time_passed * 1.5)));

    set_position(new_position);
}</literal_block>
            </container>
            <paragraph>This one should be straightforward. We're implementing each method of our class
                that we defined in our header file.</paragraph>
            <paragraph>Note our <literal>_process</literal> function, which keeps track of how much time has passed
                and calculates a new position for our sprite using a sine and cosine function.</paragraph>
            <paragraph>There is one more C++ file we need; we'll name it <literal>register_types.cpp</literal>. Our
                GDExtension plugin can contain multiple classes, each with their own header
                and source file like we've implemented <literal>GDExample</literal> up above. What we need now
                is a small bit of code that tells Godot about all the classes in our
                GDExtension plugin.</paragraph>
            <container classes="literal-block-wrapper" ids="id3" literal_block="True">
                <caption>gdextension_cpp_example/src/register_types.cpp</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "register_types.h"

#include "gdexample.h"

#include &lt;gdextension_interface.h&gt;
#include &lt;godot_cpp/core/defs.hpp&gt;
#include &lt;godot_cpp/godot.hpp&gt;

using namespace godot;

void initialize_example_module(ModuleInitializationLevel p_level) {
    if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) {
        return;
    }

    GDREGISTER_RUNTIME_CLASS(GDExample);
}

void uninitialize_example_module(ModuleInitializationLevel p_level) {
    if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) {
        return;
    }
}

extern "C" {
// Initialization.
GDExtensionBool GDE_EXPORT example_library_init(GDExtensionInterfaceGetProcAddress p_get_proc_address, const GDExtensionClassLibraryPtr p_library, GDExtensionInitialization *r_initialization) {
    godot::GDExtensionBinding::InitObject init_obj(p_get_proc_address, p_library, r_initialization);

    init_obj.register_initializer(initialize_example_module);
    init_obj.register_terminator(uninitialize_example_module);
    init_obj.set_minimum_library_initialization_level(MODULE_INITIALIZATION_LEVEL_SCENE);

    return init_obj.init();
}
}</literal_block>
            </container>
            <paragraph>The <literal>initialize_example_module</literal> and <literal>uninitialize_example_module</literal> functions get
                called respectively when Godot loads our plugin and when it unloads it. All
                we're doing here is parse through the functions in our bindings module to
                initialize them, but you might have to set up more things depending on your
                needs. We call the <literal>GDREGISTER_RUNTIME_CLASS</literal> macro for each of our classes
                in our library. This will make them run only in game, like the default for GDScript.</paragraph>
            <paragraph>The important function is the third function called <literal>example_library_init</literal>.
                We first call a function in our bindings library that creates an initialization object.
                This object registers the initialization and termination functions of the GDExtension.
                Furthermore, it sets the level of initialization (core, servers, scene, editor, level).</paragraph>
            <paragraph>At last, we need the header file for the <literal>register_types.cpp</literal> named
                <literal>register_types.h</literal>.</paragraph>
            <container classes="literal-block-wrapper" ids="id4" literal_block="True">
                <caption>gdextension_cpp_example/src/register_types.h</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#pragma once

#include &lt;godot_cpp/core/class_db.hpp&gt;

using namespace godot;

void initialize_example_module(ModuleInitializationLevel p_level);
void uninitialize_example_module(ModuleInitializationLevel p_level);</literal_block>
            </container>
        </section>
        <section ids="compiling-the-plugin" names="compiling\ the\ plugin">
            <title>Compiling the plugin</title>
            <paragraph>To compile the project we need to define how SCons using should compile it
                using an <literal>SConstruct</literal> file which references the one in <literal>godot-cpp</literal>.
                Writing it from scratch is outside the scope of this tutorial, but you can
                <download_reference filename="8df537a8866633825684515bce40faa6/SConstruct" refdoc="tutorials/scripting/cpp/gdextension_cpp_example" refdomain="" refexplicit="True" reftarget="files/cpp_example/SConstruct" reftype="download" refwarn="False"><literal classes="xref download">the SConstruct file we prepared</literal></download_reference>.
                We'll cover a more customizable, detailed example on how to use these
                build files in a subsequent tutorial.</paragraph>
            <note>
                <paragraph>This <literal>SConstruct</literal> file was written to be used with the latest <literal>godot-cpp</literal>
                    master, you may need to make small changes using it with older versions or
                    refer to the <literal>SConstruct</literal> file in the Godot 4.x documentation.</paragraph>
            </note>
            <paragraph>Once you've downloaded the <literal>SConstruct</literal> file, place it in your GDExtension folder
                structure alongside <literal>godot-cpp</literal>, <literal>src</literal> and <literal>demo</literal>, then run:</paragraph>
            <literal_block force="False" highlight_args="{}" language="bash" linenos="False" xml:space="preserve">scons platform=&lt;platform&gt;</literal_block>
            <paragraph>You should now be able to find the module in <literal>demo/bin/&lt;platform&gt;</literal>.</paragraph>
            <note>
                <paragraph>Here, we've compiled both godot-cpp and our gdexample library as debug
                    builds. For optimized builds, you should compile them using the
                    <literal>target=template_release</literal> switch.</paragraph>
            </note>
        </section>
        <section ids="using-the-gdextension-module" names="using\ the\ gdextension\ module">
            <title>Using the GDExtension module</title>
            <paragraph>Before we jump back into Godot, we need to create one more file in
                <literal>demo/bin/</literal>.</paragraph>
            <paragraph>This file lets Godot know what dynamic libraries should be
                loaded for each platform and the entry function for the module. It is called <literal>gdexample.gdextension</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">[configuration]

entry_symbol = "example_library_init"
compatibility_minimum = "4.1"
reloadable = true

[libraries]

macos.debug = "./libgdexample.macos.template_debug.dylib"
macos.release = "./libgdexample.macos.template_release.dylib"
windows.debug.x86_32 = "./gdexample.windows.template_debug.x86_32.dll"
windows.release.x86_32 = "./gdexample.windows.template_release.x86_32.dll"
windows.debug.x86_64 = "./gdexample.windows.template_debug.x86_64.dll"
windows.release.x86_64 = "./gdexample.windows.template_release.x86_64.dll"
linux.debug.x86_64 = "./libgdexample.linux.template_debug.x86_64.so"
linux.release.x86_64 = "./libgdexample.linux.template_release.x86_64.so"
linux.debug.arm64 = "./libgdexample.linux.template_debug.arm64.so"
linux.release.arm64 = "./libgdexample.linux.template_release.arm64.so"
linux.debug.rv64 = "./libgdexample.linux.template_debug.rv64.so"
linux.release.rv64 = "./libgdexample.linux.template_release.rv64.so"</literal_block>
            <paragraph>This file contains a <literal>configuration</literal> section that controls the entry function of the module.
                You should also set the minimum compatible Godot version with <literal>compatibility_minimum</literal>,
                which prevents older version of Godot from trying to load your extension.
                The <literal>reloadable</literal> flag enables automatic reloading of your extension by the editor every time you recompile it,
                without needing to restart the editor. This only works if you compile your extension in debug mode (default).</paragraph>
            <paragraph>The <literal>libraries</literal> section is the important bit: it tells Godot the location of the
                dynamic library in the project's filesystem for each supported platform. It will
                also result in <emphasis>just</emphasis> that file being exported when you export the project,
                which means the data pack won't contain libraries that are incompatible with the
                target platform.</paragraph>
            <paragraph>You can learn more about <literal>.gdextension</literal> files at <reference internal="True" refuri="../gdextension/gdextension_file#doc-gdextension-file"><inline classes="std std-ref">The .gdextension file</inline></reference>.</paragraph>
            <paragraph>Here is another overview to check the correct file structure:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">gdextension_cpp_example/
|
+--demo/                  # game example/demo to test the extension
|   |
|   +--main.tscn
|   |
|   +--bin/
|       |
|       +--gdexample.gdextension
|
+--godot-cpp/             # C++ bindings
|
+--src/                   # source code of the extension we are building
|   |
|   +--register_types.cpp
|   +--register_types.h
|   +--gdexample.cpp
|   +--gdexample.h</literal_block>
            <paragraph>Time to jump back into Godot. We load up the main scene we created way back in
                the beginning and now add a newly available GDExample node to the scene:</paragraph>
            <image candidates="{'*': 'tutorials/scripting/cpp/img/gdextension_cpp_nodes.webp'}" original_uri="img/gdextension_cpp_nodes.webp" uri="tutorials/scripting/cpp/img/gdextension_cpp_nodes.webp"></image>
            <paragraph>We're going to assign the Godot logo to this node as our texture, disable the
                <literal>centered</literal> property:</paragraph>
            <image candidates="{'*': 'tutorials/scripting/cpp/img/gdextension_cpp_sprite.webp'}" original_uri="img/gdextension_cpp_sprite.webp" uri="tutorials/scripting/cpp/img/gdextension_cpp_sprite.webp"></image>
            <paragraph>We're finally ready to run the project:</paragraph>
            <video_node align="default" alt="Screen recording of a game window, with Godot logo moving in the top-left corner" autoplay="True" caption="" controls="True" controlslist="" figwidth="" height="" klass="" loop="True" muted="True" playsinline="False" poster="" preload="auto" sources="['tutorials/scripting/cpp/img/gdextension_cpp_animated.webm',\ 'video/webm',\ False]" width="">
            </video_node>
        </section>
        <section ids="adding-properties" names="adding\ properties">
            <title>Adding properties</title>
            <paragraph>GDScript allows you to add properties to your script using the <literal>export</literal>
                keyword. In GDExtension you have to register the properties with a getter and
                setter function or directly implement the <literal>_get_property_list</literal>, <literal>_get</literal> and
                <literal>_set</literal> methods of an object (but that goes far beyond the scope of this
                tutorial).</paragraph>
            <paragraph>Lets add a property that allows us to control the amplitude of our wave.</paragraph>
            <paragraph>In our <literal>gdexample.h</literal> file we need to add a member variable and getter and setter
                functions:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">...
private:
    double time_passed;
    double amplitude;

public:
    void set_amplitude(const double p_amplitude);
    double get_amplitude() const;
...</literal_block>
            <paragraph>In our <literal>gdexample.cpp</literal> file we need to make a number of changes, we will only
                show the methods we end up changing, don't remove the lines we're omitting:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void GDExample::_bind_methods() {
    ClassDB::bind_method(D_METHOD("get_amplitude"), &amp;GDExample::get_amplitude);
    ClassDB::bind_method(D_METHOD("set_amplitude", "p_amplitude"), &amp;GDExample::set_amplitude);

    ADD_PROPERTY(PropertyInfo(Variant::FLOAT, "amplitude"), "set_amplitude", "get_amplitude");
}

GDExample::GDExample() {
    // Initialize any variables here.
    time_passed = 0.0;
    amplitude = 10.0;
}

void GDExample::_process(double delta) {
    time_passed += delta;

    Vector2 new_position = Vector2(
        amplitude + (amplitude * sin(time_passed * 2.0)),
        amplitude + (amplitude * cos(time_passed * 1.5))
    );

    set_position(new_position);
}

void GDExample::set_amplitude(const double p_amplitude) {
    amplitude = p_amplitude;
}

double GDExample::get_amplitude() const {
    return amplitude;
}</literal_block>
            <paragraph>Once you compile the module with these changes in place, you will see that a
                property has been added to our interface. You can now change this property and
                when you run your project, you will see that our Godot icon travels along a
                larger figure.</paragraph>
            <paragraph>Let's do the same but for the speed of our animation and use a setter and getter
                function. Our <literal>gdexample.h</literal> header file again only needs a few more lines of
                code:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">...
    double amplitude;
    double speed;
...
    void _process(double delta) override;
    void set_speed(const double p_speed);
    double get_speed() const;
...</literal_block>
            <paragraph>This requires a few more changes to our <literal>gdexample.cpp</literal> file, again we're only
                showing the methods that have changed so don't remove anything we're omitting:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void GDExample::_bind_methods() {
    ...
    ClassDB::bind_method(D_METHOD("get_speed"), &amp;GDExample::get_speed);
    ClassDB::bind_method(D_METHOD("set_speed", "p_speed"), &amp;GDExample::set_speed);

    ADD_PROPERTY(PropertyInfo(Variant::FLOAT, "speed", PROPERTY_HINT_RANGE, "0,20,0.01"), "set_speed", "get_speed");
}

GDExample::GDExample() {
    time_passed = 0.0;
    amplitude = 10.0;
    speed = 1.0;
}

void GDExample::_process(double delta) {
    time_passed += speed * delta;

    Vector2 new_position = Vector2(
        amplitude + (amplitude * sin(time_passed * 2.0)),
        amplitude + (amplitude * cos(time_passed * 1.5))
    );

    set_position(new_position);
}

...

void GDExample::set_speed(const double p_speed) {
    speed = p_speed;
}

double GDExample::get_speed() const {
    return speed;
}</literal_block>
            <paragraph>Now when the project is compiled, we'll see another property called speed.
                Changing its value will make the animation go faster or slower.
                Furthermore, we added a property range which describes in which range the value can be.
                The first two arguments are the minimum and maximum value and the third is the step size.</paragraph>
            <note>
                <paragraph>For simplicity, we've only used the hint_range of the property method.
                    There are a lot more options to choose from. These can be used to
                    further configure how properties are displayed and set on the Godot side.</paragraph>
            </note>
        </section>
        <section ids="signals" names="signals">
            <title>Signals</title>
            <paragraph>Last but not least, signals fully work in GDExtension as well. Having your extension
                react to a signal given out by another object requires you to call <literal>connect</literal>
                on that object. We can't think of a good example for our wobbling Godot icon, we
                would need to showcase a far more complete example.</paragraph>
            <paragraph>This is the required syntax:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">some_other_node-&gt;connect("the_signal", Callable(this, "my_method"));</literal_block>
            <paragraph>To connect our signal <literal>the_signal</literal> from some other node with our method
                <literal>my_method</literal>, we need to provide the <literal>connect</literal> method with the name of the signal
                and a <literal>Callable</literal>. The <literal>Callable</literal> holds information about an object on which a method
                can be called. In our case, it associates our current object instance <literal>this</literal> with the
                method <literal>my_method</literal> of the object. Then the <literal>connect</literal> method will add this to the
                observers of <literal>the_signal</literal>. Whenever <literal>the_signal</literal> is now emitted, Godot knows which
                method of which object it needs to call.</paragraph>
            <paragraph>Note that you can only call <literal>my_method</literal> if you've previously registered it in
                your <literal>_bind_methods</literal> method. Otherwise Godot will not know about the existence
                of <literal>my_method</literal>.</paragraph>
            <paragraph>To learn more about <literal>Callable</literal>, check out the class reference here: <reference internal="True" refuri="../../../classes/class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>.</paragraph>
            <paragraph>Having your object sending out signals is more common. For our wobbling
                Godot icon, we'll do something silly just to show how it works. We're going to
                emit a signal every time a second has passed and pass the new location along.</paragraph>
            <paragraph>In our <literal>gdexample.h</literal> header file, we need to define a new member <literal>time_emit</literal>:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">...
    double time_passed;
    double time_emit;
    double amplitude;
...</literal_block>
            <paragraph>This time, the changes in <literal>gdexample.cpp</literal> are more elaborate. First,
                you'll need to set <literal>time_emit = 0.0;</literal> in either our <literal>_init</literal> method or in our
                constructor. We'll look at the other 2 needed changes one by one.</paragraph>
            <paragraph>In our <literal>_bind_methods</literal> method, we need to declare our signal. This is done
                as follows:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void GDExample::_bind_methods() {
    ...
    ADD_PROPERTY(PropertyInfo(Variant::FLOAT, "speed", PROPERTY_HINT_RANGE, "0,20,0.01"), "set_speed", "get_speed");

    ADD_SIGNAL(MethodInfo("position_changed", PropertyInfo(Variant::OBJECT, "node"), PropertyInfo(Variant::VECTOR2, "new_pos")));
}</literal_block>
            <paragraph>Here, our <literal>ADD_SIGNAL</literal> macro can be a single call with a <literal>MethodInfo</literal> argument.
                <literal>MethodInfo</literal>'s first parameter will be the signal's name, and its remaining parameters
                are <literal>PropertyInfo</literal> types which describe the essentials of each of the method's parameters.
                <literal>PropertyInfo</literal> parameters are defined with the data type of the parameter, and then the name
                that the parameter will have by default.</paragraph>
            <paragraph>So here, we add a signal, with a <literal>MethodInfo</literal> which names the signal "position_changed". The
                <literal>PropertyInfo</literal> parameters describe two essential arguments, one of type <literal>Object</literal>, the other
                of type <literal>Vector2</literal>, respectively named "node" and "new_pos".</paragraph>
            <paragraph>Next, we'll need to change our <literal>_process</literal> method:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void GDExample::_process(double delta) {
    time_passed += speed * delta;

    Vector2 new_position = Vector2(
        amplitude + (amplitude * sin(time_passed * 2.0)),
        amplitude + (amplitude * cos(time_passed * 1.5))
    );

    set_position(new_position);

    time_emit += delta;
    if (time_emit &gt; 1.0) {
        emit_signal("position_changed", this, new_position);

        time_emit = 0.0;
    }
}</literal_block>
            <paragraph>After a second has passed, we emit our signal and reset our counter. We can add
                our parameter values directly to <literal>emit_signal</literal>.</paragraph>
            <paragraph>Once the GDExtension library is compiled, we can go into Godot and select our sprite
                node. In the <strong>Node</strong> dock, we can find our new signal and link it up by pressing
                the <strong>Connect</strong> button or double-clicking the signal. We've added a script on
                our main node and implemented our signal like this:</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

func _on_Sprite2D_position_changed(node, new_pos):
    print("The position of " + node.get_class() + " is now " + str(new_pos))</literal_block>
            <paragraph>Every second, we output our position to the console.</paragraph>
        </section>
        <section ids="next-steps" names="next\ steps">
            <title>Next steps</title>
            <paragraph>We hope the above example showed you the basics. You can build upon this example to create full-fledged scripts
                to control nodes in Godot using C++!</paragraph>
            <paragraph>Instead of basing your project off the above example setup, we recommend to restart now by cloning the
                <reference name="godot-cpp template" refuri="https://github.com/godotengine/godot-cpp-template">godot-cpp template</reference>, and base your project off of that.
                It has better coverage of features, such as a GitHub build action and additional useful <literal>SConstruct</literal> boilerplate.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
