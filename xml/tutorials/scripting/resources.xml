<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/resources.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-resources"></target>
    <section ids="resources doc-resources" names="resources doc_resources">
        <title>Resources</title>
        <section ids="nodes-and-resources" names="nodes\ and\ resources">
            <title>Nodes and resources</title>
            <paragraph>Up to this tutorial, we focused on the <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference>
                class in Godot as that's the one you use to code behavior and
                most of the engine's features rely on it. There is
                another datatype that is just as important:
                <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>.</paragraph>
            <paragraph><emphasis>Nodes</emphasis> give you functionality: they draw sprites, 3D models, simulate physics,
                arrange user interfaces, etc. <strong>Resources</strong> are <strong>data containers</strong>. They don't
                do anything on their own: instead, nodes use the data contained in resources.</paragraph>
            <paragraph>Anything Godot saves or loads from disk is a resource. Be it a scene (a <literal>.tscn</literal>
                or a <literal>.scn</literal> file), an image, a script... Here are some <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> examples:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_texture#class-texture"><inline classes="std std-ref">Texture</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_script#class-script"><inline classes="std std-ref">Script</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_mesh#class-mesh"><inline classes="std std-ref">Mesh</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_animation#class-animation"><inline classes="std std-ref">Animation</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_audiostream#class-audiostream"><inline classes="std std-ref">AudioStream</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_font#class-font"><inline classes="std std-ref">Font</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_translation#class-translation"><inline classes="std std-ref">Translation</inline></reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>When the engine loads a resource from disk, <strong>it only loads it once</strong>. If a copy
                of that resource is already in memory, trying to load the resource again will
                return the same copy every time. As resources only contain data, there is no need
                to duplicate them.</paragraph>
            <paragraph>Every object, be it a Node or a Resource, can export properties. There are many
                types of Properties, like String, integer, Vector2, etc., and any of these types
                can become a resource. This means that both nodes and resources can contain
                resources as properties:</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/nodes_resources.webp'}" original_uri="img/nodes_resources.webp" uri="tutorials/scripting/img/nodes_resources.webp"></image>
        </section>
        <section ids="external-vs-built-in" names="external\ vs\ built-in">
            <title>External vs built-in</title>
            <paragraph>There are two ways to save resources. They can be:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>External</strong> to a scene, saved on the disk as individual files.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Built-in</strong>, saved inside the <literal>.tscn</literal> or the <literal>.scn</literal> file they're attached to.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>To be more specific, here's a <reference internal="True" refuri="../../classes/class_texture2d#class-texture2d"><inline classes="std std-ref">Texture2D</inline></reference>
                in a <reference internal="True" refuri="../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite2D</inline></reference> node:</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/spriteprop.webp'}" original_uri="img/spriteprop.webp" uri="tutorials/scripting/img/spriteprop.webp"></image>
            <paragraph>Clicking the resource preview allows us to view the resource's properties.</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/resourcerobi.webp'}" original_uri="img/resourcerobi.webp" uri="tutorials/scripting/img/resourcerobi.webp"></image>
            <paragraph>The path property tells us where the resource comes from. In this case, it comes
                from a PNG image called <literal>robi.png</literal>. When the resource comes from a file like
                this, it is an external resource. If you erase the path or this path is empty,
                it becomes a built-in resource.</paragraph>
            <paragraph>The switch between built-in and external resources happens when you save the
                scene. In the example above, if you erase the path <literal>"res://robi.png"</literal> and
                save, Godot will save the image inside the <literal>.tscn</literal> scene file.</paragraph>
            <note>
                <paragraph>Even if you save a built-in resource, when you instance a scene multiple
                    times, the engine will only load one copy of it.</paragraph>
            </note>
        </section>
        <section ids="loading-resources-from-code" names="loading\ resources\ from\ code">
            <title>Loading resources from code</title>
            <paragraph>There are two ways to load resources from code. First, you can use the <literal>load()</literal> function anytime:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    # Godot loads the Resource when it reads this very line.
    var imported_resource = load("res://robi.png")
    $sprite.texture = imported_resource</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    // Godot loads the Resource when it executes this line.
    var texture = GD.Load&lt;Texture&gt;("res://Robi.png");
    var sprite = GetNode&lt;Sprite2D&gt;("sprite");
    sprite.Texture = texture;
}</literal_block>
                </div>
            </container>
            <paragraph>You can also <literal>preload</literal> resources. Unlike <literal>load</literal>, this function will read the
                file from disk and load it at compile-time. As a result, you cannot call <literal>preload</literal>
                with a variable path: you need to use a constant string.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    # Godot loads the resource at compile-time
    var imported_resource = preload("res://robi.png")
    get_node("sprite").texture = imported_resource</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// 'preload()' is unavailable in C Sharp.</literal_block>
                </div>
            </container>
        </section>
        <section ids="loading-scenes" names="loading\ scenes">
            <title>Loading scenes</title>
            <paragraph>Scenes are also resources, but there is a catch. Scenes saved to disk are
                resources of type <reference internal="True" refuri="../../classes/class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference>. The
                scene is packed inside a <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>.</paragraph>
            <paragraph>To get an instance of the scene, you have to use the
                <reference internal="True" refuri="../../classes/class_packedscene#class-packedscene-method-instantiate"><inline classes="std std-ref">PackedScene.instantiate()</inline></reference> method.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_shoot():
        var bullet = preload("res://bullet.tscn").instantiate()
        add_child(bullet)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private PackedScene _bulletScene = GD.Load&lt;PackedScene&gt;("res://Bullet.tscn");

private void OnShoot()
{
    Node bullet = _bulletScene.Instantiate();
    AddChild(bullet);
}</literal_block>
                </div>
            </container>
            <paragraph>This method creates the nodes in the scene's hierarchy, configures them, and
                returns the root node of the scene. You can then add it as a child of any other
                node.</paragraph>
            <paragraph>The approach has several advantages. As the <reference internal="True" refuri="../../classes/class_packedscene#class-packedscene-method-instantiate"><inline classes="std std-ref">PackedScene.instantiate()</inline></reference> function is fast, you can create new
                enemies, bullets, effects, etc. without having to load them again from disk each
                time. Remember that, as always, images, meshes, etc. are all shared between the
                scene instances.</paragraph>
        </section>
        <section ids="freeing-resources" names="freeing\ resources">
            <title>Freeing resources</title>
            <paragraph>When a <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> is no longer in use, it will automatically free itself.
                Since, in most cases, Resources are contained in Nodes, when you free a node,
                the engine frees all the resources it owns as well if no other node uses them.</paragraph>
        </section>
        <section ids="creating-your-own-resources" names="creating\ your\ own\ resources">
            <title>Creating your own resources</title>
            <paragraph>Like any Object in Godot, users can also script Resources. Resource scripts
                inherit the ability to freely translate between object properties and serialized
                text or binary data (*.tres, *.res). They also inherit the reference-counting
                memory management from the RefCounted type.</paragraph>
            <paragraph>This comes with many distinct advantages over alternative data
                structures, such as JSON, CSV, or custom TXT files. Users can only import these
                assets as a <reference internal="True" refuri="../../classes/class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> (JSON) or as a
                <reference internal="True" refuri="../../classes/class_fileaccess#class-fileaccess"><inline classes="std std-ref">FileAccess</inline></reference> to parse. What sets Resources apart is their
                inheritance of <reference internal="True" refuri="../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference>, <reference internal="True" refuri="../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference>,
                and <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> features:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>They can define constants, so constants from other data fields or objects are not needed.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>They can define methods, including setter/getter methods for properties. This allows for abstraction and encapsulation of the underlying data. If the Resource script's structure needs to change, the game using the Resource need not also change.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>They can define signals, so Resources can trigger responses to changes in the data they manage.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>They have defined properties, so users know 100% that their data will exist.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Resource auto-serialization and deserialization is a built-in Godot Engine feature. Users do not need to implement custom logic to import/export a resource file's data.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Resources can even serialize sub-Resources recursively, meaning users can design even more sophisticated data structures.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Users can save Resources as version-control-friendly text files (*.tres). Upon exporting a game, Godot serializes resource files as binary files (*.res) for increased speed and compression.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Godot Engine's Inspector renders and edits Resource files out-of-the-box. As such, users often do not need to implement custom logic to visualize or edit their data. To do so, double-click the resource file in the FileSystem dock or click the folder icon in the Inspector and open the file in the dialog.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>They can extend <strong>other</strong> resource types besides just the base Resource.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Godot makes it easy to create custom Resources in the Inspector.</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Create a new Resource object in the Inspector. This can even be a type that derives Resource, so long as your script is extending that type.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Set the <literal>script</literal> property in the Inspector to be your script.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>The Inspector will now display your Resource script's custom properties. If one edits
                those values and saves the resource, the Inspector serializes the custom properties
                too! To save a resource from the Inspector, click the save icon at the top of the Inspector,
                and select "Save" or "Save As...".</paragraph>
            <paragraph>If the script's language supports <reference internal="True" refuri="gdscript/gdscript_basics#doc-gdscript-basics-class-name"><inline classes="std std-ref">script classes</inline></reference>,
                then it streamlines the process. Defining a name for your script alone will add it to
                the Inspector's creation dialog. This will auto-add your script to the Resource
                object you create.</paragraph>
            <paragraph>Let's see some examples.
                Create a <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> and name it <literal>bot_stats</literal>.
                It should appear in your file tab with the full name <literal>bot_stats.tres</literal>.
                Without a script, it's useless, so let's add some data and logic!
                Attach a script to it named <literal>bot_stats.gd</literal> (or just create a new script, and then drag it to it).</paragraph>
            <note>
                <paragraph>To make the new resource class appear in the Create Resource GUI you need to provide a class name for GDScript, or use the [GlobalClass] attribute in C#.</paragraph>
            </note>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">class_name BotStats
extends Resource

@export var health: int
@export var sub_resource: Resource
@export var strings: PackedStringArray

# Make sure that every parameter has a default value.
# Otherwise, there will be problems with creating and editing
# your resource via the inspector.
func _init(p_health = 0, p_sub_resource = null, p_strings = []):
    health = p_health
    sub_resource = p_sub_resource
    strings = p_strings</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// BotStats.cs
using Godot;

namespace ExampleProject
{
    [GlobalClass]
    public partial class BotStats : Resource
    {
        [Export]
        public int Health { get; set; }

        [Export]
        public Resource SubResource { get; set; }

        [Export]
        public string[] Strings { get; set; }

        // Make sure you provide a parameterless constructor.
        // In C#, a parameterless constructor is different from a
        // constructor with all default values.
        // Without a parameterless constructor, Godot will have problems
        // creating and editing your resource via the inspector.
        public BotStats() : this(0, null, null) {}

        public BotStats(int health, Resource subResource, string[] strings)
        {
            Health = health;
            SubResource = subResource;
            Strings = strings ?? System.Array.Empty&lt;string&gt;();
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>Now, create a <reference internal="True" refuri="../../classes/class_characterbody3d#class-characterbody3d"><inline classes="std std-ref">CharacterBody3D</inline></reference>, name it <literal>Bot</literal>, and add the following script to it:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

@export var stats: Resource

func _ready():
    # Uses an implicit, duck-typed interface for any 'health'-compatible resources.
    if stats:
        stats.health = 10
        print(stats.health)
        # Prints "10"</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Bot.cs
using Godot;

namespace ExampleProject
{
    public partial class Bot : CharacterBody3D
    {
        [Export]
        public Resource Stats;

        public override void _Ready()
        {
            if (Stats is BotStats botStats)
            {
                GD.Print(botStats.Health); // Prints '10'.
            }
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>Now, select the <reference internal="True" refuri="../../classes/class_characterbody3d#class-characterbody3d"><inline classes="std std-ref">CharacterBody3D</inline></reference> node which we named <literal>bot</literal>, and drag&amp;drop the <literal>bot_stats.tres</literal> resource onto the Inspector. It should print 10! Obviously, this setup can be used for more advanced features than this, but as long you really understand <emphasis>how</emphasis> it all worked, you should figure out everything else related to Resources.</paragraph>
            <note>
                <paragraph>Resource scripts are similar to Unity's ScriptableObjects. The Inspector
                    provides built-in support for custom resources. If desired though, users
                    can even design their own Control-based tool scripts and combine them
                    with an <reference internal="True" refuri="../../classes/class_editorplugin#class-editorplugin"><inline classes="std std-ref">EditorPlugin</inline></reference> to create custom
                    visualizations and editors for their data.</paragraph>
                <paragraph>Unreal Engine's DataTables and CurveTables are also easy to recreate with
                    Resource scripts. DataTables are a String mapped to a custom struct, similar
                    to a Dictionary mapping a String to a secondary custom Resource script.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># bot_stats_table.gd
extends Resource

const BotStats = preload("bot_stats.gd")

var data = {
    "GodotBot": BotStats.new(10), # Creates instance with 10 health.
    "DifferentBot": BotStats.new(20) # A different one with 20 health.
}

func _init():
    print(data)</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

[GlobalClass]
public partial class BotStatsTable : Resource
{
    private Godot.Collections.Dictionary&lt;string, BotStats&gt; _stats = new Godot.Collections.Dictionary&lt;string, BotStats&gt;();

    public BotStatsTable()
    {
        _stats["GodotBot"] = new BotStats(10); // Creates instance with 10 health.
        _stats["DifferentBot"] = new BotStats(20); // A different one with 20 health.
        GD.Print(_stats);
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>Instead of inlining the Dictionary values, one could also, alternatively:</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>Import a table of values from a spreadsheet and generate these key-value pairs.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Design a visualization within the editor and create a plugin that adds it
                            to the Inspector when you open these types of Resources.</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>CurveTables are the same thing, except mapped to an Array of float values
                    or a <reference internal="True" refuri="../../classes/class_curve#class-curve"><inline classes="std std-ref">Curve</inline></reference>/<reference internal="True" refuri="../../classes/class_curve2d#class-curve2d"><inline classes="std std-ref">Curve2D</inline></reference> resource object.</paragraph>
            </note>
            <warning>
                <paragraph>Beware that resource files (*.tres/*.res) will store the path of the script
                    they use in the file. When loaded, they will fetch and load this script as an
                    extension of their type. This means that trying to assign an
                    inner class of a script (i.e. using the <literal>class</literal> keyword in GDScript) won't
                    work. Godot will not serialize the custom properties on the script inner class properly.</paragraph>
                <paragraph>In the example below, Godot would load the <literal>Node</literal> script, see that it doesn't
                    extend <literal>Resource</literal>, and then determine that the script failed to load for the
                    Resource object since the types are incompatible.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

class MyResource:
    extends Resource
    @export var value = 5

func _ready():
    var my_res = MyResource.new()

    # This will NOT serialize the 'value' property.
    ResourceSaver.save(my_res, "res://my_res.tres")</literal_block>
                    </div>
                    <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode : Node
{
    [GlobalClass]
    public partial class MyResource : Resource
    {
        [Export]
        public int Value { get; set; } = 5;
    }

    public override void _Ready()
    {
        var res = new MyResource();

        // This will NOT serialize the 'Value' property.
        ResourceSaver.Save(res, "res://MyRes.tres");
    }
}</literal_block>
                    </div>
                </container>
            </warning>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
