<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/resources.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-resources"></target>
    <section ids="resources doc-resources" names="resources 资源 doc_resources">
        <title>资源</title>
        <section ids="nodes-and-resources" names="nodes\ and\ resources 节点和资源">
            <title>节点和资源</title>
            <paragraph>在本教程之前, 我们重点研究Godot中的 <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> 类, 因为它是你用来编码行为的类, 并且引擎的大多数功能都依赖于该类. 还有另一个同样重要的数据类型: <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>.</paragraph>
            <paragraph><emphasis>节点</emphasis> 为你提供功能: 它们绘制精灵, 3D模型, 模拟物理, 排列用户界面等. <strong>资源</strong> 是 <strong>数据容器</strong> . 它们自己不能做任何事情: 而是, 节点使用资源中包含的数据.</paragraph>
            <paragraph>Godot 保存到磁盘、从磁盘读取的都是资源。资源可以是场景（<literal>.tscn</literal> 或 <literal>.scn</literal> 文件）、图像、脚本……以下是一些 <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> 的示例：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_texture#class-texture"><inline classes="std std-ref">Texture</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_script#class-script"><inline classes="std std-ref">Script</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_mesh#class-mesh"><inline classes="std std-ref">Mesh</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_animation#class-animation"><inline classes="std std-ref">Animation</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_audiostream#class-audiostream"><inline classes="std std-ref">AudioStream</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_font#class-font"><inline classes="std std-ref">Font</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_translation#class-translation"><inline classes="std std-ref">Translation</inline></reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>当引擎从磁盘加载资源时, <strong>它只加载一次</strong> . 如果该资源的副本已在内存中, 则每次尝试再次加载该资源将返回相同的副本. 由于资源只包含数据, 因此无需复制它们.</paragraph>
            <paragraph>每个对象(无论是节点还是资源)都可以导出属性. 属性有很多类型, 例如String, integer, Vector2等, 并且任何这些类型都可以成为资源. 这意味着节点和资源都可以包含资源以作为属性:</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/nodes_resources.webp'}" uri="tutorials/scripting/img/nodes_resources.webp"></image>
        </section>
        <section ids="external-vs-built-in" names="external\ vs\ built-in 外部与内置">
            <title>外部与内置</title>
            <paragraph>有两种保存资源的方法. 它们是:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph><strong>外部</strong> , 对于场景, 作为单独文件保存在磁盘上.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>内置</strong>，保存在它们所附加的 <literal>.tscn</literal> 或 <literal>.scn</literal> 文件内。</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>To be more specific, here's a <reference internal="True" refuri="../../classes/class_texture2d#class-texture2d"><inline classes="std std-ref">Texture2D</inline></reference>
                in a <reference internal="True" refuri="../../classes/class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite2D</inline></reference> node:</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/spriteprop.webp'}" uri="tutorials/scripting/img/spriteprop.webp"></image>
            <paragraph>Clicking the resource preview allows us to view the resource's properties.</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/resourcerobi.webp'}" uri="tutorials/scripting/img/resourcerobi.webp"></image>
            <paragraph><literal>Path</literal> 属性告诉我们资源来自何处. 在这里, 它来自一个叫 <literal>robi.png</literal> 的PNG图像. 当资源来自这样的文件时, 它属于外部资源. 如果你去掉这个路径或此路径为空, 则它将成为内置资源.</paragraph>
            <paragraph>保存场景时, 将在内置资源和外部资源之间进行切换. 在上面的示例中, 如果删除路径 <literal>"res://robi.png"</literal> 并保存,Godot会将图像保存在 <literal>.tscn</literal> 场景文件中.</paragraph>
            <note>
                <paragraph>即使你保存一个内置资源, 当多次实例化一个场景时, 引擎也只会加载该场景的一个副本.</paragraph>
            </note>
        </section>
        <section ids="loading-resources-from-code" names="loading\ resources\ from\ code 从代码中加载资源">
            <title>从代码中加载资源</title>
            <paragraph>有两种方法可以从代码加载资源. 首先, 你可以随时使用 <literal>load()</literal> 函数:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    # Godot loads the Resource when it reads this very line.
    var imported_resource = load("res://robi.png")
    $sprite.texture = imported_resource</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    // Godot loads the Resource when it executes this line.
    var texture = GD.Load&lt;Texture&gt;("res://Robi.png");
    var sprite = GetNode&lt;Sprite2D&gt;("sprite");
    sprite.Texture = texture;
}</literal_block>
                </div>
            </container>
            <paragraph>You can also <literal>preload</literal> resources. Unlike <literal>load</literal>, this function will read the
                file from disk and load it at compile-time. As a result, you cannot call <literal>preload</literal>
                with a variable path: you need to use a constant string.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    # Godot loads the resource at compile-time
    var imported_resource = preload("res://robi.png")
    get_node("sprite").texture = imported_resource</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// 'preload()' is unavailable in C Sharp.</literal_block>
                </div>
            </container>
        </section>
        <section ids="loading-scenes" names="loading\ scenes 加载场景">
            <title>加载场景</title>
            <paragraph>Scenes are also resources, but there is a catch. Scenes saved to disk are
                resources of type <reference internal="True" refuri="../../classes/class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference>. The
                scene is packed inside a <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>.</paragraph>
            <paragraph>To get an instance of the scene, you have to use the
                <reference internal="True" refuri="../../classes/class_packedscene#class-packedscene-method-instantiate"><inline classes="std std-ref">PackedScene.instantiate()</inline></reference> method.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_shoot():
        var bullet = preload("res://bullet.tscn").instantiate()
        add_child(bullet)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private PackedScene _bulletScene = GD.Load&lt;PackedScene&gt;("res://Bullet.tscn");

private void OnShoot()
{
    Node bullet = _bulletScene.Instantiate();
    AddChild(bullet);
}</literal_block>
                </div>
            </container>
            <paragraph>此方法在场景的层次结构中创建节点, 对其进行配置, 然后返回场景的根节点. 然后, 你可以将其添加为任何其他节点的子级.</paragraph>
            <paragraph>The approach has several advantages. As the <reference internal="True" refuri="../../classes/class_packedscene#class-packedscene-method-instantiate"><inline classes="std std-ref">PackedScene.instantiate()</inline></reference> function is fast, you can create new
                enemies, bullets, effects, etc. without having to load them again from disk each
                time. Remember that, as always, images, meshes, etc. are all shared between the
                scene instances.</paragraph>
        </section>
        <section ids="freeing-resources" names="freeing\ resources 释放资源">
            <title>释放资源</title>
            <paragraph>When a <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> is no longer in use, it will automatically free itself.
                Since, in most cases, Resources are contained in Nodes, when you free a node,
                the engine frees all the resources it owns as well if no other node uses them.</paragraph>
        </section>
        <section ids="creating-your-own-resources" names="creating\ your\ own\ resources 创建自己的资源">
            <title>创建自己的资源</title>
            <paragraph>Like any Object in Godot, users can also script Resources. Resource scripts
                inherit the ability to freely translate between object properties and serialized
                text or binary data (*.tres, *.res). They also inherit the reference-counting
                memory management from the RefCounted type.</paragraph>
            <paragraph>This comes with many distinct advantages over alternative data
                structures, such as JSON, CSV, or custom TXT files. Users can only import these
                assets as a <reference internal="True" refuri="../../classes/class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> (JSON) or as a
                <reference internal="True" refuri="../../classes/class_fileaccess#class-fileaccess"><inline classes="std std-ref">FileAccess</inline></reference> to parse. What sets Resources apart is their
                inheritance of <reference internal="True" refuri="../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference>, <reference internal="True" refuri="../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference>,
                and <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> features:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>它们可以定义常量, 因此不需要其他数据字段或对象中的常量.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>它们可以定义方法, 包括属性的 <literal>setter/getter</literal> 方法. 这允许对基础数据进行抽象和封装. 如果资源脚本的结构需要更改, 则使用资源的游戏则不必更改.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>它们可以定义信号, 因此 <literal>Resources</literal> 可以触发对所管理数据更改的响应.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>它们具有已定义的属性, 因此用户知道其数据将100％存在.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>资源自动序列化和反序列化是一个Godot引擎的内置功能. 用户无需实现自定义逻辑即可导入/导出资源文件的数据.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>资源甚至可以递归地序列化子资源, 这意味着用户可以设计更复杂的数据结构.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>用户可以将资源保存为版本控制友好的文本文件(<literal>*.tres</literal>). 导出游戏后,Godot将资源文件序列化为二进制文件(<literal>*.res</literal>), 以提高速度和压缩率.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Godot 引擎的检查器开箱即用地渲染和编辑资源文件。这样，用户通常不需要实现自定义逻辑即可可视化或编辑其数据。为此，请在文件系统面板中双击资源文件，或在检查器中点击文件夹图标，然后在对话框中打开该文件。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>它们可以扩展除基本 Resource 之外的<strong>其他</strong>资源类型。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Godot 可以轻松地在检查器面板中创建自定义 Resource。</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>在检查器面板中创建一个普通的 Resource 对象。只要是扩展自 Resource 的类型，你的脚本就可以去扩展。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>将检查器中的 <literal>script</literal> 属性设置为你的脚本。</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>现在，检查器将显示 Resource 脚本的自定义属性。如果编辑这些值并保存资源，则检查器也会序列化自定义属性！要从检查器中保存资源，请点击检查器的工具菜单（右上角），然后选择“保存”或“另存为...”。</paragraph>
            <paragraph>如果脚本的语言支持<reference internal="True" refuri="gdscript/gdscript_basics#doc-gdscript-basics-class-name"><inline classes="std std-ref">脚本类</inline></reference>，则可以简化该过程。仅为脚本定义名称会将其添加到“检查器”的创建对话框。这会将脚本自动添加到你创建的 Resource 对象中。</paragraph>
            <paragraph>让我们来看一个例子。创建一个 <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> 然后把它命名为 <literal>bot_stats</literal>。此时文件面板中会显示全名 <literal>bot_stats.tres</literal>。不带脚本的话这个文件没什么意义，那我们就来添加一些数据和逻辑吧！给它附加一个名叫 <literal>bot_stats.gd</literal> 的脚本（或者新建一个脚本之后把它拖上来）。</paragraph>
            <note>
                <paragraph>If you're using C#, you need to annotate your Resource class with the <literal>[GlobalClass]</literal> attribute for it to show up in the create resource GUI.</paragraph>
            </note>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Resource

@export var health: int
@export var sub_resource: Resource
@export var strings: PackedStringArray

# Make sure that every parameter has a default value.
# Otherwise, there will be problems with creating and editing
# your resource via the inspector.
func _init(p_health = 0, p_sub_resource = null, p_strings = []):
    health = p_health
    sub_resource = p_sub_resource
    strings = p_strings</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// BotStats.cs
using Godot;

namespace ExampleProject
{
    [GlobalClass]
    public partial class BotStats : Resource
    {
        [Export]
        public int Health { get; set; }

        [Export]
        public Resource SubResource { get; set; }

        [Export]
        public string[] Strings { get; set; }

        // Make sure you provide a parameterless constructor.
        // In C#, a parameterless constructor is different from a
        // constructor with all default values.
        // Without a parameterless constructor, Godot will have problems
        // creating and editing your resource via the inspector.
        public BotStats() : this(0, null, null) {}

        public BotStats(int health, Resource subResource, string[] strings)
        {
            Health = health;
            SubResource = subResource;
            Strings = strings ?? System.Array.Empty&lt;string&gt;();
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>然后创建一个 <reference internal="True" refuri="../../classes/class_characterbody3d#class-characterbody3d"><inline classes="std std-ref">CharacterBody3D</inline></reference>，命名为 <literal>Bot</literal>，再加一个脚本，内容如下：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

@export var stats: Resource

func _ready():
    # Uses an implicit, duck-typed interface for any 'health'-compatible resources.
    if stats:
        stats.health = 10
        print(stats.health)
        # Prints "10"</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Bot.cs
using Godot;

namespace ExampleProject
{
    public partial class Bot : CharacterBody3D
    {
        [Export]
        public Resource Stats;

        public override void _Ready()
        {
            if (Stats is BotStats botStats)
            {
                GD.Print(botStats.Health); // Prints '10'.
            }
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>现在选中这个名为 <literal>bot</literal> 的 <reference internal="True" refuri="../../classes/class_characterbody3d#class-characterbody3d"><inline classes="std std-ref">CharacterBody3D</inline></reference> 节点，将 <literal>bot_stats.tres</literal> 资源拖到检查器中。这样就会输出 10 了！很显然，这种做法能够实现比这更加高级的功能，只要你能够理解其中的<emphasis>原理</emphasis>，那么 Resource 相关的东西就是一通百通的了。</paragraph>
            <note>
                <paragraph>资源脚本类似于 Unity 的 ScriptableObject。检查器为自定义资源提供内置支持。如果需要的话，用户甚至可以设计自己的基于 Control 控件的工具脚本，并将它们与一个 <reference internal="True" refuri="../../classes/class_editorplugin#class-editorplugin"><inline classes="std std-ref">EditorPlugin</inline></reference> 结合起来，以为他们的数据创建自定义的可视化和编辑器。</paragraph>
                <paragraph>用 Resource 脚本来模拟虚幻引擎的 DataTable 和 CurveTable 也很容易。DataTable 是将字符串映射到了自定义结构体，类似于用字典将字符串映射到次级自定义 Resource 脚本。</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># bot_stats_table.gd
extends Resource

const BotStats = preload("bot_stats.gd")

var data = {
    "GodotBot": BotStats.new(10), # Creates instance with 10 health.
    "DifferentBot": BotStats.new(20) # A different one with 20 health.
}

func _init():
    print(data)</literal_block>
                    </div>
                    <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

[GlobalClass]
public partial class BotStatsTable : Resource
{
    private Godot.Collections.Dictionary&lt;string, BotStats&gt; _stats = new Godot.Collections.Dictionary&lt;string, BotStats&gt;();

    public BotStatsTable()
    {
        _stats["GodotBot"] = new BotStats(10); // Creates instance with 10 health.
        _stats["DifferentBot"] = new BotStats(20); // A different one with 20 health.
        GD.Print(_stats);
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>除了内联 Dictionary 值之外，还可以选择：</paragraph>
                <enumerated_list enumtype="arabic" prefix="" suffix=".">
                    <list_item>
                        <paragraph>从电子表格导入值表并生成这些键值对。</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>在编辑器中设计可视化方法，创建一个简单的插件，在你打开这些类型的 Resource 时，将其添加到检查器中。</paragraph>
                    </list_item>
                </enumerated_list>
                <paragraph>CurveTable 是相同的东西，除了映射到一个浮点值数组或一个 <reference internal="True" refuri="../../classes/class_curve#class-curve"><inline classes="std std-ref">Curve</inline></reference>/ <reference internal="True" refuri="../../classes/class_curve2d#class-curve2d"><inline classes="std std-ref">Curve2D</inline></reference> 资源对象之外。</paragraph>
            </note>
            <warning>
                <paragraph>请注意，资源文件（*.tres/*.res）将在文件中存储它们使用的脚本的路径。加载后，它们将获取并加载此脚本作为其类型的扩展。这意味着尝试指定一个子类，即脚本的内部类（例如在 GDScript 中使用 <literal>class</literal> 关键字）将不起作用。Godot 将无法正确序列化脚本子类上的自定义属性。</paragraph>
                <paragraph>在下面的示例中，Godot 将加载 <literal>Node</literal> 脚本，并看到它没有扩展 <literal>Resource</literal>，然后判断脚本由于类型不兼容而无法为 Resource 对象加载。</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

class MyResource:
    extends Resource
    @export var value = 5

func _ready():
    var my_res = MyResource.new()

    # This will NOT serialize the 'value' property.
    ResourceSaver.save(my_res, "res://my_res.tres")</literal_block>
                    </div>
                    <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode : Node
{
    [GlobalClass]
    public partial class MyResource : Resource
    {
        [Export]
        public int Value { get; set; } = 5;
    }

    public override void _Ready()
    {
        var res = new MyResource();

        // This will NOT serialize the 'Value' property.
        ResourceSaver.Save(res, "res://MyRes.tres");
    }
}</literal_block>
                    </div>
                </container>
            </warning>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
