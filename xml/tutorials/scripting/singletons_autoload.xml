<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/singletons_autoload.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-singletons-autoload"></target>
    <section ids="singletons-autoload doc-singletons-autoload" names="singletons\ (autoload) 单例（自动加载） doc_singletons_autoload">
        <title>单例（自动加载）</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>Godot 的场景系统虽然强大而灵活，但有一个缺点：无法保存多个场景都需要的信息（例如玩家的分数或者背包）。</paragraph>
            <paragraph>可以通过一些变通方法来解决此问题，但是它们有其自身的局限性：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>你可以使用“主”场景来把其它场景当作自己的子节点来加载和卸载。然而，这就意味着这些场景无法再独立正常运行。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>信息可以存储在磁盘的 <literal>user://</literal> 下，然后由需要它的场景加载，但是经常保存和加载数据很麻烦并且可能很慢。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><reference name="单例模式" refuri="https://en.wikipedia.org/wiki/Singleton_pattern">单例模式</reference><target ids="id1" names="单例模式" refuri="https://en.wikipedia.org/wiki/Singleton_pattern"></target>是解决需要在场景之间存储持久性信息的常见用例的实用工具。在我们的示例中，只要多个单例具有不同的名称，就可以复用相同的场景或类。</paragraph>
            <paragraph>利用这个概念，你可以创建这样的对象：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>无论当前运行哪个场景，始终加载。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>可以存储全局变量，如玩家信息。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>可以处理切换场景和场景间的过渡。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><emphasis>行为</emphasis>类似单例，因为 GDScript 在设计上就不支持全局变量。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>自动加载的节点和脚本可以为我们提供这些特征。</paragraph>
            <note>
                <paragraph>Godot won't make an Autoload a "true" singleton as per the singleton design
                    pattern. It may still be instanced more than once by the user if desired.</paragraph>
            </note>
            <tip>
                <paragraph>如果你创建的自动加载是编辑器插件的一部分，请考虑在启用插件时<reference internal="True" refuri="../plugins/editor/making_plugins#doc-making-plugins-autoload"><inline classes="std std-ref">将其自动注册到项目设置中</inline></reference>。</paragraph>
            </tip>
        </section>
        <section ids="autoload" names="autoload 自动加载">
            <title>自动加载</title>
            <paragraph>You can create an Autoload to load a scene or a script that inherits from
                <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference>.</paragraph>
            <note>
                <paragraph>自动加载脚本时，会创建一个 <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> 并把脚本附加上去。加载其它任何场景前，这个节点就会被加到根视图上。</paragraph>
            </note>
            <image candidates="{'*': 'tutorials/scripting/img/singleton.webp'}" uri="tutorials/scripting/img/singleton.webp"></image>
            <paragraph>To autoload a scene or script, select <strong>Project &gt; Project Settings</strong> from the
                menu and switch to the <strong>Autoload</strong> tab.</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/autoload_tab.webp'}" uri="tutorials/scripting/img/autoload_tab.webp"></image>
            <paragraph>你可以在这里添加任意数量的场景或脚本。列表中的每个条目都需要一个名称，会被用来给该节点的 <literal>name</literal> 属性赋值。使用上下箭头键可以操纵将条目添加到全局场景树时的顺序。与普通场景一样，引擎读取这些节点的顺序是从上到下的。</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/autoload_example.webp'}" uri="tutorials/scripting/img/autoload_example.webp"></image>
            <paragraph>If the <strong>Enable</strong> column is checked (which is the default), then the singleton can
                be accessed directly in GDScript:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">PlayerVariables.health -= 10</literal_block>
                </div>
            </container>
            <paragraph>请注意，访问自动加载对象（脚本、场景）的方式和访问场景树中的任何其他节点是一样的。实际上，如果你查看正在运行的场景树，就会看到自动加载的节点出现：</paragraph>
            <image candidates="{'*': 'tutorials/scripting/img/autoload_runtime.webp'}" uri="tutorials/scripting/img/autoload_runtime.webp"></image>
            <warning>
                <paragraph>运行时绝对<strong>不能</strong>通过 <literal>free()</literal> 或 <literal>queue_free()</literal> 去移除自动加载，否则引擎会崩溃。</paragraph>
            </warning>
        </section>
        <section ids="custom-scene-switcher" names="custom\ scene\ switcher 自定义场景切换器">
            <title>自定义场景切换器</title>
            <paragraph>This tutorial will demonstrate building a scene switcher using autoloads.
                For basic scene switching, you can use the
                <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree-method-change-scene-to-file"><inline classes="std std-ref">SceneTree.change_scene_to_file()</inline></reference>
                method (see <reference internal="True" refuri="scene_tree#doc-scene-tree"><inline classes="std std-ref">使用 SceneTree</inline></reference> for details). However, if you need more
                complex behavior when changing scenes, this method provides more functionality.</paragraph>
            <paragraph>To begin, download the template from here:
                <reference name="singleton_autoload_starter.zip" refuri="https://github.com/godotengine/godot-docs-project-starters/releases/download/latest-4.x/singleton_autoload_starter.zip">singleton_autoload_starter.zip</reference><target ids="singleton-autoload-starter-zip" names="singleton_autoload_starter.zip" refuri="https://github.com/godotengine/godot-docs-project-starters/releases/download/latest-4.x/singleton_autoload_starter.zip"></target>
                and open it in Godot.</paragraph>
            <paragraph>The project contains two scenes: <literal>scene_1.tscn</literal> and <literal>scene_2.tscn</literal>. Each
                scene contains a label displaying the scene name and a button with its
                <literal>pressed()</literal> signal connected. When you run the project, it starts in
                <literal>scene_1.tscn</literal>. However, pressing the button does nothing.</paragraph>
            <section ids="creating-the-script" names="creating\ the\ script">
                <title>Creating the script</title>
                <paragraph>Open the <strong>Script</strong> window and create a new script called <literal>global.gd</literal>.
                    Make sure it inherits from <literal>Node</literal>:</paragraph>
                <image candidates="{'*': 'tutorials/scripting/img/autoload_script.webp'}" uri="tutorials/scripting/img/autoload_script.webp"></image>
                <paragraph>The next step is to add this script to the autoLoad list. Open
                    <strong>Project &gt; Project Settings</strong> from the menu, switch to the <strong>Autoload</strong> tab and
                    select the script by clicking the browse button or typing its path:
                    <literal>res://global.gd</literal>. Press <strong>Add</strong> to add it to the autoload list:</paragraph>
                <image candidates="{'*': 'tutorials/scripting/img/autoload_tutorial1.webp'}" uri="tutorials/scripting/img/autoload_tutorial1.webp"></image>
                <paragraph>现在，无论何时在项目中运行任何场景，该脚本都将始终加载。</paragraph>
                <paragraph>Returning to the script, it needs to fetch the current scene in the
                    <title_reference>_ready()</title_reference> function. Both the current scene (the one with the button) and
                    <literal>global.gd</literal> are children of root, but autoloaded nodes are always first. This
                    means that the last child of root is always the loaded scene.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

var current_scene = null

func _ready():
    var root = get_tree().root
    current_scene = root.get_child(root.get_child_count() - 1)</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Global : Node
{
    public Node CurrentScene { get; set; }

    public override void _Ready()
    {
        Viewport root = GetTree().Root;
        CurrentScene = root.GetChild(root.GetChildCount() - 1);
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>现在我们需要一个用于更改场景的函数。这个函数需要释放当前场景，并将其替换为请求的场景。</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func goto_scene(path):
    # This function will usually be called from a signal callback,
    # or some other function in the current scene.
    # Deleting the current scene at this point is
    # a bad idea, because it may still be executing code.
    # This will result in a crash or unexpected behavior.

    # The solution is to defer the load to a later time, when
    # we can be sure that no code from the current scene is running:

    call_deferred("_deferred_goto_scene", path)


func _deferred_goto_scene(path):
    # It is now safe to remove the current scene.
    current_scene.free()

    # Load the new scene.
    var s = ResourceLoader.load(path)

    # Instance the new scene.
    current_scene = s.instantiate()

    # Add it to the active scene, as child of root.
    get_tree().root.add_child(current_scene)

    # Optionally, to make it compatible with the SceneTree.change_scene_to_file() API.
    get_tree().current_scene = current_scene</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void GotoScene(string path)
{
    // This function will usually be called from a signal callback,
    // or some other function from the current scene.
    // Deleting the current scene at this point is
    // a bad idea, because it may still be executing code.
    // This will result in a crash or unexpected behavior.

    // The solution is to defer the load to a later time, when
    // we can be sure that no code from the current scene is running:

    CallDeferred(MethodName.DeferredGotoScene, path);
}

public void DeferredGotoScene(string path)
{
    // It is now safe to remove the current scene.
    CurrentScene.Free();

    // Load a new scene.
    var nextScene = GD.Load&lt;PackedScene&gt;(path);

    // Instance the new scene.
    CurrentScene = nextScene.Instantiate();

    // Add it to the active scene, as child of root.
    GetTree().Root.AddChild(CurrentScene);

    // Optionally, to make it compatible with the SceneTree.change_scene_to_file() API.
    GetTree().CurrentScene = CurrentScene;
}</literal_block>
                    </div>
                </container>
                <paragraph>使用 <reference internal="True" refuri="../../classes/class_object#class-object-method-call-deferred"><inline classes="std std-ref">Object.call_deferred()</inline></reference>，第二个函数将仅在当前场景中的所有代码完成后运行。因此，当前场景在仍在使用（即其代码仍在运行）时不会被删除。</paragraph>
                <paragraph>最后，我们需要在两个场景中填充空的回调函数：</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Add to 'scene_1.gd'.

func _on_button_pressed():
    Global.goto_scene("res://scene_2.tscn")</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Add to 'Scene1.cs'.

private void OnButtonPressed()
{
    var global = GetNode&lt;Global&gt;("/root/Global");
    global.GotoScene("res://Scene2.tscn");
}</literal_block>
                    </div>
                </container>
                <paragraph>以及</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Add to 'scene_2.gd'.

func _on_button_pressed():
    Global.goto_scene("res://scene_1.tscn")</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Add to 'Scene2.cs'.

private void OnButtonPressed()
{
    var global = GetNode&lt;Global&gt;("/root/Global");
    global.GotoScene("res://Scene1.tscn");
}</literal_block>
                    </div>
                </container>
                <paragraph>运行该项目，并测试你可以通过按下按钮来切换场景。</paragraph>
                <note>
                    <paragraph>当场景较小时，过渡是瞬时的。但是，如果你的场景比较复杂，则可能需要花费相当长的时间才能显示出来。要了解如何处理此问题，请参阅下一个教程：<reference internal="True" refuri="../io/background_loading#doc-background-loading"><inline classes="std std-ref">后台加载</inline></reference>。</paragraph>
                    <paragraph>另外，如果加载时间相对较短（少于 3 秒左右），你可以在改变场景之前，通过显示某种 2D 元素来显示一个“加载中图标”，然后在改变场景后隐藏它。这能让玩家知道场景正在载入。</paragraph>
                </note>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
