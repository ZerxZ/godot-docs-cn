<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/logging.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-logging"></target>
    <section ids="logging doc-logging" names="logging doc_logging">
        <title>Logging</title>
        <paragraph>Godot comes with several ways to organize and collect log messages.</paragraph>
        <section ids="printing-messages" names="printing\ messages">
            <title>Printing messages</title>
            <seealso>
                <paragraph>See <reference internal="True" refuri="debug/output_panel#doc-output-panel-printing-messages"><inline classes="std std-ref">Printing messages</inline></reference> for instructions on printing
                    messages. The printed output is generally identical to the logged output.</paragraph>
                <paragraph>When running a project from the editor, the editor will display logged text
                    in the <reference internal="True" refuri="debug/output_panel#doc-output-panel"><inline classes="std std-ref">Output panel</inline></reference>.</paragraph>
            </seealso>
        </section>
        <section ids="project-settings" names="project\ settings">
            <title>Project settings</title>
            <paragraph>There are several project settings to control logging behavior in Godot:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Application &gt; Run &gt; Disable stdout:</strong> Disables logging to standard output entirely.
                        This also affects what custom loggers receive. This can be controlled at runtime
                        by setting <reference internal="True" refuri="../../classes/class_engine#class-engine-property-print-to-stdout"><inline classes="std std-ref">Engine.print_to_stdout</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Application &gt; Run &gt; Disable stderr:</strong> Disables logging to standard error entirely.
                        This also affects what custom loggers receive. This can be controlled at runtime
                        by setting <reference internal="True" refuri="../../classes/class_engine#class-engine-property-print-error-messages"><inline classes="std std-ref">Engine.print_error_messages</inline></reference>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Debug &gt; Settings &gt; stdout &gt; Verbose stdout:</strong> Enables verbose logging to standard output.
                        Prints from <reference internal="True" refuri="../../classes/class_@globalscope#class-globalscope-method-print-verbose"><inline classes="std std-ref">print_verbose()</inline></reference> are only
                        visible if verbose mode is enabled.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Debug &gt; Settings &gt; stdout &gt; Print FPS:</strong> Prints the frames per second every second,
                        as well as the V-Sync status on startup (as it can effectively cap the maximum framerate).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Debug &gt; Settings &gt; stdout &gt; Print GPU Profile:</strong> Prints a report of GPU utilization
                        every second, using the same data source as the <reference internal="True" refuri="debug/debugger_panel#doc-debugger-panel-visual-profiler"><inline classes="std std-ref">Visual Profiler</inline></reference>.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Some of these project settings can also be overridden using
                <reference internal="True" refuri="../editor/command_line_tutorial#doc-command-line-tutorial"><inline classes="std std-ref">command line arguments</inline></reference> such as <literal>--quiet</literal>,
                <literal>--verbose</literal>, and <literal>--print-fps</literal>.</paragraph>
            <paragraph>The engine's own file logging is also configurable, as described in the section below.</paragraph>
        </section>
        <section ids="built-in-file-logging" names="built-in\ file\ logging">
            <title>Built-in file logging</title>
            <paragraph>By default, Godot writes log files in <literal>user://logs/godot.log</literal> on desktop
                platforms. You can change this location by modifying the
                <literal>debug/file_logging/log_path</literal> project setting. Logs are rotated to keep older
                files available for inspection. Each session creates a new log file, with the
                old file renamed to contain the date at which it was rotated. Up to 5 log files
                are kept by default, which can be adjusted using the
                <literal>debug/file_logging/max_log_files</literal> project setting.</paragraph>
            <paragraph>File logging can also be disabled completely using the
                <literal>debug/file_logging/enable_file_logging</literal> project setting.</paragraph>
            <paragraph>When the project crashes, crash logs are written to the same file as the log
                file. The crash log will only contain a usable backtrace if the binary that was
                run contains debugging symbols, or if it can find a debug symbols file that
                matches the binary. Official binaries don't provide debugging symbols, so this
                requires a custom build to work. See
                <reference internal="True" refuri="../../engine_details/development/compiling/introduction_to_the_buildsystem#doc-introduction-to-the-buildsystem-debugging-symbols"><inline classes="std std-ref">Debugging symbols</inline></reference>
                for guidance on compiling binaries with debugging symbols enabled.</paragraph>
            <note>
                <paragraph>Log files for <reference internal="True" refuri="../../classes/class_@globalscope#class-globalscope-method-print"><inline classes="std std-ref">print()</inline></reference>
                    statements are updated when standard output is <emphasis>flushed</emphasis> by the engine.
                    Standard output is flushed on every print in debug builds only. In projects that
                    are exported in release mode, standard output is only flushed when the project exits
                    or crashes to improve performance, especially if the project is often printing
                    text to standard output.</paragraph>
                <paragraph>On the other hand, the standard error stream
                    (used by <reference internal="True" refuri="../../classes/class_@globalscope#class-globalscope-method-printerr"><inline classes="std std-ref">printerr()</inline></reference>,
                    <reference internal="True" refuri="../../classes/class_@globalscope#class-globalscope-method-push-error"><inline classes="std std-ref">push_error()</inline></reference>, and
                    <reference internal="True" refuri="../../classes/class_@globalscope#class-globalscope-method-push-warning"><inline classes="std std-ref">push_warning()</inline></reference>) is always
                    flushed on every print, even in projects exported in release mode.</paragraph>
                <paragraph>For some use cases like dedicated servers, it can be preferred to have release
                    builds always flush stdout on print, so that logging services like journald can
                    collect logs while the process is running. This can be done by enabling
                    <literal>application/run/flush_stdout_on_print</literal> in the Project Settings.</paragraph>
            </note>
        </section>
        <section ids="script-backtraces" names="script\ backtraces">
            <title>Script backtraces</title>
            <paragraph>Since Godot 4.5, when GDScript code encounters an error, it will log a backtrace that points
                to the origin of the error, while also containing the call stack leading to it. This behavior
                is always enabled when running in the editor, or when the project is exported in debug mode.</paragraph>
            <paragraph>In projects exported in release mode, backtraces are disabled by default for performance reasons.
                You can enable them by checking <strong>Debug &gt; Settings &gt; GDScript &gt; Always Track Call Stacks</strong> in
                the Project Settings. If you use a custom logging system that reports exceptions to a remote
                service, it's recommended to enable this to make reported errors more actionable.</paragraph>
        </section>
        <section ids="crash-backtraces" names="crash\ backtraces">
            <title>Crash backtraces</title>
            <warning>
                <paragraph>Crash backtraces are only useful if they were recorded in a build that
                    contains <reference internal="True" refuri="../../engine_details/development/compiling/introduction_to_the_buildsystem#doc-introduction-to-the-buildsystem-debugging-symbols"><inline classes="std std-ref">debugging symbols</inline></reference>.
                    Official Godot binaries do not contain debugging symbols, so you must compile a
                    custom editor or export template binary to get useful crash backtraces.</paragraph>
            </warning>
            <paragraph>When the project crashes, a crash backtrace is printed to the standard error stream. This is what
                it can look like in a build with debug symbols:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">================================================================
handle_crash: Program crashed with signal 4
Engine version: Godot Engine v4.5.beta.custom_build (6c9aa4c7d3b9b91cd50714c40eeb234874df7075)
Dumping the backtrace. Please include this when reporting the bug to the project developer.
[1] /lib64/libc.so.6(+0x1a070) [0x7f6e5e277070] (??:0)
[2] godot() [0x4da3358] (/path/to/godot/core/core_bind.cpp:336 (discriminator 2))
[3] godot() [0xdf5f2f] (/path/to/godot/modules/gdscript/gdscript.h:591)
[4] godot() [0xbffd46] (/path/to/godot/modules/gdscript/gdscript.cpp:2065 (discriminator 1))
[5] godot() [0x30f2ea4] (/path/to/godot/core/variant/variant.h:870)
[6] godot() [0x550d4e1] (/path/to/godot/core/object/object.cpp:933)
[7] godot() [0x30d996a] (/path/to/godot/scene/main/node.cpp:318 (discriminator 1))
[8] godot() [0x3131a7f] (/path/to/godot/core/templates/hash_map.h:465)
[9] godot() [0x424589] (/path/to/godot/platform/linuxbsd/os_linuxbsd.cpp:970)
[10] /lib64/libc.so.6(+0x3575) [0x7f6e5e260575] (??:0)
[11] /lib64/libc.so.6(__libc_start_main+0x88) [0x7f6e5e260628] (??:0)
[12] godot() [0x464df5] (??:?)
-- END OF C++ BACKTRACE --
================================================================
GDScript backtrace (most recent call first):
    [0] _ready (res://test.gd:5)
-- END OF GDSCRIPT BACKTRACE --
================================================================</literal_block>
            <paragraph>On the other hand, without debug symbols, it will look like this instead:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">================================================================
handle_crash: Program crashed with signal 4
Engine version: Godot Engine v4.5.beta.custom_build (6c9aa4c7d3b9b91cd50714c40eeb234874df7075)
Dumping the backtrace. Please include this when reporting the bug to the project developer.
[1] /lib64/libc.so.6(+0x1a070) [0x7fdfaf666070] (??:0)
[2] godot() [0x4da3358] (??:0)
[3] godot() [0xdf5f2f] (??:0)
[4] godot() [0xbffd46] (??:0)
[5] godot() [0x30f2ea4] (??:0)
[6] godot() [0x550d4e1] (??:0)
[7] godot() [0x30d996a] (??:0)
[8] godot() [0x3131a7f] (??:0)
[9] godot() [0x424589] (??:0)
[10] /lib64/libc.so.6(+0x3575) [0x7fdfaf64f575] (??:0)
[11] /lib64/libc.so.6(__libc_start_main+0x88) [0x7fdfaf64f628] (??:0)
[12] godot() [0x464df5] (??:0)
-- END OF C++ BACKTRACE --
================================================================
GDScript backtrace (most recent call first):
    [0] _ready (res://test.gd:5)
-- END OF GDSCRIPT BACKTRACE --
================================================================</literal_block>
            <paragraph>This backtrace is also logged to the file for the current session, but it is <strong>not</strong>
                visible in the editor Output panel. Since the engine's scripting system is not running
                anymore when the engine is crashing, it is not possible to access it from scripting in
                the same session. However, you can still read the crash backtrace on the next session
                by loading log files and searching for the crash backtrace string
                (<literal>Program crashed with signal</literal>) using <reference internal="True" refuri="../../classes/class_fileaccess#class-fileaccess"><inline classes="std std-ref">FileAccess</inline></reference>. This allows you to access
                the backtrace information even after a crash, as long as the user restarts the project
                and file logging is enabled:</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># This script can be made an autoload, so that it runs when the project starts.
extends Node

func _ready() -&gt; void:
  var log_dir: String = String(ProjectSettings.get_setting("debug/file_logging/log_path")).get_base_dir()
  # Get the last log file by alphabetical order.
  # Since the timestamp is featured in the file name, it should always be the most recent
  # log file that was rotated. The non-timestamped log file is for the current session,
  # so we don't want to read that one.
  var last_log_file: String = log_dir.path_join(DirAccess.get_files_at(log_dir)[-1])
  var last_long_contents: String = FileAccess.get_file_as_string(last_log_file)

  var crash_begin_idx: int = last_long_contents.find("Program crashed with signal")
  if crash_begin_idx != -1:
      print("The previous session has crashed with the following backtrace:\n")
      print(last_long_contents.substr(crash_begin_idx))</literal_block>
            <paragraph>You can customize the message that appears at the top of the backtrace using the
                <strong>Debug &gt; Settings &gt; Crash Handler &gt; Message</strong> project setting. This can be used
                to point to a URL or email address that users can report issues to.</paragraph>
        </section>
        <section ids="creating-custom-loggers" names="creating\ custom\ loggers">
            <title>Creating custom loggers</title>
            <paragraph>Since Godot 4.5, it is possible to create custom loggers. This custom logging can
                be used for many purposes:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Show an in-game console with the same messages as printed by the engine,
                        without requiring other scripts to be modified.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Report printed errors from the player's machine to a remote server.
                        This can make it easier for developers to fix bugs when the game is already released,
                        or during playtesting.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Integrate a dedicated server export with monitoring platforms.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>A custom logger can be registered by creating a class that inherits from <reference internal="True" refuri="../../classes/class_logger#class-logger"><inline classes="std std-ref">Logger</inline></reference>,
                then passing an instance of this class to <reference internal="True" refuri="../../classes/class_os#class-os-method-add-logger"><inline classes="std std-ref">OS.add_logger</inline></reference>,
                in a script's <reference internal="True" refuri="../../classes/class_object#class-object-private-method-init"><inline classes="std std-ref">_init()</inline></reference> method. A good place to do this
                is an <reference internal="True" refuri="singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">autoload</inline></reference>.</paragraph>
            <paragraph>The class must define two methods: <reference internal="True" refuri="../../classes/class_logger#class-logger-private-method-log-message"><inline classes="std std-ref">_log_message()</inline></reference>
                and <reference internal="True" refuri="../../classes/class_logger#class-logger-private-method-log-error"><inline classes="std std-ref">_log_error()</inline></reference>.</paragraph>
            <paragraph>Here is a minimal working example of a custom logger, with the script added as an autoload:</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

class CustomLogger extends Logger:
    # Note that this method is not called for messages that use
    # `push_error()` and `push_warning()`, even though these are printed to stderr.
    func _log_message(message: String, error: bool) -&gt; void:
        # Do something with `message`.
        # `error` is `true` for messages printed to the standard error stream (stderr) with `print_error()`.
        # Note that this method will be called from threads other than the main thread, possibly at the same
        # time, so you will need to have some kind of thread-safety as part of it, like a Mutex.
        pass

    func _log_error(
            function: String,
            file: String,
            line: int,
            code: String,
            rationale: String,
            editor_notify: bool,
            error_type: int,
            script_backtraces: Array[ScriptBacktrace]
    ) -&gt; void:
        # Do something with the error. The error text is in `rationale`.
        # See the Logger class reference for details on other parameters.
        # Note that this method will be called from threads other than the main thread, possibly at the same
        # time, so you will need to have some kind of thread-safety as part of it, like a Mutex.
        pass

# Use `_init()` to initialize the logger as early as possible, which ensures that messages
# printed early are taken into account. However, even when using `_init()`, the engine's own
# initialization messages are not accessible.
func _init() -&gt; void:
    OS.add_logger(CustomLogger.new())</literal_block>
            <paragraph>Note that to avoid infinite recursion, you cannot effectively use
                <reference internal="True" refuri="../../classes/class_@globalscope#class-globalscope-method-print"><inline classes="std std-ref">print()</inline></reference> and its related methods in
                <literal>_log_message()</literal>. You also can't effectively use
                <reference internal="True" refuri="../../classes/class_@globalscope#class-globalscope-method-push-error"><inline classes="std std-ref">push_error()</inline></reference>
                or <reference internal="True" refuri="../../classes/class_@globalscope#class-globalscope-method-push-warning"><inline classes="std std-ref">push_warning()</inline></reference> in
                <literal>_log_error()</literal>. Attempting to do so will print a message to the same stream
                as the original message. This message is not available in the custom logger,
                which is what prevents infinite recursion from occurring:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">While attempting to print a message, another message was printed:
...

While attempting to print an error, another error was printed:
...</literal_block>
            <seealso>
                <paragraph>You can find an example of an in-game console built with a custom logger in the
                    <reference name="Custom Logging demo project" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/misc/custom_logging">Custom Logging demo project</reference>.</paragraph>
            </seealso>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
