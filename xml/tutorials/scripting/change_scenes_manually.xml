<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/change_scenes_manually.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-change-scenes-manually"></target>
    <section ids="change-scenes-manually doc-change-scenes-manually" names="change\ scenes\ manually doc_change_scenes_manually">
        <title>Change scenes manually</title>
        <paragraph>Sometimes it helps to have more control over how you swap scenes around.
            A <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>'s child nodes will render to the image
            it generates. This holds true even for nodes outside of the "current"
            scene. Autoloads fall into this category, and also scenes which you
            instantiate and add to the tree at runtime:</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var simultaneous_scene = preload("res://levels/level2.tscn").instantiate()

func _add_a_scene_manually():
    # This is like autoloading the scene, only
    # it happens after already loading the main scene.
    get_tree().root.add_child(simultaneous_scene)</literal_block>
            </div>
            <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public Node simultaneousScene;

public MyClass()
{
    simultaneousScene = ResourceLoader.Load&lt;PackedScene&gt;("res://levels/level2.tscn").Instantiate();
}

public void _AddASceneManually()
{
    // This is like autoloading the scene, only
    // it happens after already loading the main scene.
    GetTree().Root.AddChild(simultaneousScene);
}</literal_block>
            </div>
        </container>
        <paragraph>To complete the cycle and swap out the new scene with the old one,
            you have a choice to make. Many strategies exist for removing a scene
            from view of the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>. The tradeoffs involve
            balancing operation speed and memory consumption, as well as balancing data
            access and integrity.</paragraph>
        <enumerated_list enumtype="arabic" prefix="" suffix=".">
            <list_item>
                <paragraph><strong>Delete the existing scene.</strong>
                    <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree-method-change-scene-to-file"><inline classes="std std-ref">SceneTree.change_scene_to_file()</inline></reference> and
                    <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree-method-change-scene-to-packed"><inline classes="std std-ref">SceneTree.change_scene_to_packed()</inline></reference>
                    will delete the current scene immediately. You can also delete the
                    main scene. Assuming the root node's name is "Main", you could do
                    <literal>get_node("/root/Main").free()</literal> to delete the whole scene.</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>Unloads memory.</paragraph>
                            <block_quote>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>Pro: RAM is no longer dragging the dead weight.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>Con: Returning to that scene is now more expensive since it must be
                                            loaded back into memory again (takes time AND memory). Not a problem
                                            if returning soon is unnecessary.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>Con: No longer have access to that scene's data. Not a problem if
                                            using that data soon is unnecessary.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>Note: It can be useful to preserve the data in a soon-to-be-deleted
                                            scene by re-attaching one or more of its nodes to a different scene,
                                            or even directly to the <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.</paragraph>
                                    </list_item>
                                </bullet_list>
                            </block_quote>
                        </list_item>
                        <list_item>
                            <paragraph>Processing stops.</paragraph>
                            <block_quote>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>Pro: No nodes means no processing, physics processing, or input
                                            handling. The CPU is available to work on the new scene's contents.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>Con: Those nodes' processing and input handling no longer operate.
                                            Not a problem if using the updated data is unnecessary.</paragraph>
                                    </list_item>
                                </bullet_list>
                            </block_quote>
                        </list_item>
                    </bullet_list>
                </block_quote>
            </list_item>
            <list_item>
                <paragraph><strong>Hide the existing scene.</strong> By changing the visibility or collision
                    detection of the nodes, you can hide the entire node sub-tree from the
                    player's perspective.</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>Memory still exists.</paragraph>
                            <block_quote>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>Pro: You can still access the data if needed.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>Pro: There's no need to move any more nodes around to save data.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>Con: More data is being kept in memory, which will be become a problem
                                            on memory-sensitive platforms like web or mobile.</paragraph>
                                    </list_item>
                                </bullet_list>
                            </block_quote>
                        </list_item>
                        <list_item>
                            <paragraph>Processing continues.</paragraph>
                            <block_quote>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>Pro: Data continues to receive processing updates, so the scene will
                                            keep any data within it that relies on delta time or frame data
                                            updated.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>Pro: Nodes are still members of groups (since groups belong to the
                                            <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>).</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>Con: The CPU's attention is now divided between both scenes. Too much
                                            load could result in low frame rates. You should be sure to test
                                            performance as you go to ensure the target platform can support the
                                            load from this approach.</paragraph>
                                    </list_item>
                                </bullet_list>
                            </block_quote>
                        </list_item>
                    </bullet_list>
                </block_quote>
            </list_item>
            <list_item>
                <paragraph><strong>Remove the existing scene from the tree.</strong> Assign a variable
                    to the existing scene's root node. Then use
                    <reference internal="True" refuri="../../classes/class_node#class-node-method-remove-child"><inline classes="std std-ref">Node.remove_child(Node)</inline></reference> to detach the entire
                    scene from the tree.</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>Memory still exists (similar pros/cons as hiding it from view).</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Processing stops (similar pros/cons as deleting it completely).</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Pro: This variation of "hiding" it is much easier to show/hide. Rather
                                than potentially keeping track of multiple changes to the scene, you
                                only need to call the add/remove_child methods. This is similar to
                                disabling game objects in other engines.</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Con: Unlike with hiding it from view only, the data contained within
                                the scene will become stale if it relies on delta time, input, groups,
                                or other data that is derived from <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>
                                access.</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
            </list_item>
        </enumerated_list>
        <paragraph>There are also cases where you may wish to have many scenes present at the same
            time, such as adding your own singleton at runtime, or preserving
            a scene's data between scene changes (adding the scene to the root node).</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">get_tree().root.add_child(scene)</literal_block>
            </div>
            <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GetTree().Root.AddChild(scene);</literal_block>
            </div>
        </container>
        <paragraph>Another case may be displaying multiple scenes at the same time using
            <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainers</inline></reference>. This is optimal for
            rendering different content in different parts of the screen (e.g. minimaps,
            split-screen multiplayer).</paragraph>
        <paragraph>Each option will have cases where it is best appropriate, so you must examine
            the effects of each approach, and determine what path best fits your unique
            situation.</paragraph>
        <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
    </section>
</document>
