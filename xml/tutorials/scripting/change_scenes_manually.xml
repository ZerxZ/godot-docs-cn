<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/scripting/change_scenes_manually.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-change-scenes-manually"></target>
    <section ids="change-scenes-manually doc-change-scenes-manually" names="change\ scenes\ manually 手动更改场景 doc_change_scenes_manually">
        <title>手动更改场景</title>
        <paragraph>Sometimes it helps to have more control over how one swaps scenes around.
            A <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>'s child nodes will render to the image
            it generates, this holds true even for nodes outside
            of the "current" scene. Autoloads fall into this category, but so do
            scenes which one instances and adds to the tree at runtime:</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var simultaneous_scene = preload("res://levels/level2.tscn").instantiate()

func _add_a_scene_manually():
    # This is like autoloading the scene, only
    # it happens after already loading the main scene.
    get_tree().root.add_child(simultaneous_scene)</literal_block>
            </div>
            <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public Node simultaneousScene;

public MyClass()
{
    simultaneousScene = ResourceLoader.Load&lt;PackedScene&gt;("res://levels/level2.tscn").Instantiate();
}

public void _AddASceneManually()
{
    // This is like autoloading the scene, only
    // it happens after already loading the main scene.
    GetTree().Root.AddChild(simultaneousScene);
}</literal_block>
            </div>
        </container>
        <paragraph>要完成循环并将旧场景替换为旧场景, 开发人员可以选择制作. 从视图中删除场景有很多策略 <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>. 权衡涉及平衡操作速度和内存消耗以及平衡数据访问和完整性.</paragraph>
        <enumerated_list enumtype="arabic" prefix="" suffix=".">
            <list_item>
                <paragraph><strong>We can delete the existing scene.</strong>
                    <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree-method-change-scene-to-file"><inline classes="std std-ref">SceneTree.change_scene_to_file()</inline></reference> and
                    <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree-method-change-scene-to-packed"><inline classes="std std-ref">SceneTree.change_scene_to_packed()</inline></reference>
                    will delete the current scene immediately. Developers can also delete the
                    main scene though. Assuming the root node's name is "Main", one could do
                    <literal>get_node("/root/Main").free()</literal> to delete the whole scene.</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>卸载内存.</paragraph>
                            <block_quote>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>好处: RAM不再拖累自重.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>坏处: 回到那个场景现在更加昂贵, 因为它必须再次加载回内存(需要时间和内存). 如果不久就回来是不必要的.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>坏处: 无法再访问该场景的数据. 如果不久就使用这些数据就不成问题了.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>注意: 通过将一个或多个节点重新附加到不同的场景, 甚至直接将其重新附加到 <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>, 可以将数据保存在即将删除的场景中.</paragraph>
                                    </list_item>
                                </bullet_list>
                            </block_quote>
                        </list_item>
                        <list_item>
                            <paragraph>处理停止.</paragraph>
                            <block_quote>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>好处: 没有节点意味着没有进程, 物理过程或输入处理. CPU可用于处理新场景的内容.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>坏处: 这些节点的处理和输入处理不再运行. 如果不需要使用更新的数据, 则不成问题.</paragraph>
                                    </list_item>
                                </bullet_list>
                            </block_quote>
                        </list_item>
                    </bullet_list>
                </block_quote>
            </list_item>
            <list_item>
                <paragraph><strong>我们可以隐藏现有场景.</strong> 通过更改节点的可见性或碰撞检测, 我们可以从游戏角色的角度隐藏整个节点子树.</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>记忆仍然存在.</paragraph>
                            <block_quote>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>好处: 如果需要, 仍然可以访问数据.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>好处: 无需再移动任何节点来保存数据.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>坏处: 更多数据被保存在内存中, 这将成为对内存敏感平台(如Web或移动设备)的问题.</paragraph>
                                    </list_item>
                                </bullet_list>
                            </block_quote>
                        </list_item>
                        <list_item>
                            <paragraph>处理继续.</paragraph>
                            <block_quote>
                                <bullet_list bullet="-">
                                    <list_item>
                                        <paragraph>好处: 数据继续接收处理更新, 因此场景将不断更新其中依赖于增量时间或帧数据的任何数据.</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>Pro: 节点仍然是组的成员(因为组属于 <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>).</paragraph>
                                    </list_item>
                                    <list_item>
                                        <paragraph>坏处: 现在CPU的注意力分散在两个场景之间. 负载过大可能导致帧速率降低. 应该确保测试性能, 以确保目标平台能够支持它们提供的负载.</paragraph>
                                    </list_item>
                                </bullet_list>
                            </block_quote>
                        </list_item>
                    </bullet_list>
                </block_quote>
            </list_item>
            <list_item>
                <paragraph><strong>我们可以从树上删除现有的场景.</strong> 给现有场景的根节点分配一个变量. 然后使用 <reference internal="True" refuri="../../classes/class_node#class-node-method-remove-child"><inline classes="std std-ref">Node.remove_child(Node)</inline></reference> 来将整个场景从树上分离.</paragraph>
                <block_quote>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph>记忆仍然存在(与从视图中隐藏它相似的优点/缺点).</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>处理停止(类似于完全删除它的优点/缺点).</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>好处：这种形式的“隐藏”更容易进行显示/隐藏。人们必须只调用一个方法 add / remove_child 方法，而不是潜在地跟踪场景的多个变化。它类似于在其他引擎中禁用游戏对象。</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>坏处：与仅从视图中隐藏它不同，如果场景中包含的数据依赖于时间增量、输入、分组或其他通过访问 <reference internal="True" refuri="../../classes/class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 才能得到的数据，则它将变为陈旧。</paragraph>
                        </list_item>
                    </bullet_list>
                </block_quote>
            </list_item>
        </enumerated_list>
        <paragraph>在有些情况下, 人们可能希望有许多场景同时存在. 也许人们在运行时添加他们自己的单例, 或者在场景变化之间保留一个场景的数据(将场景添加到根节点).</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">get_tree().root.add_child(scene)</literal_block>
            </div>
            <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GetTree().Root.AddChild(scene);</literal_block>
            </div>
        </container>
        <paragraph>Perhaps instead they wish to display multiple scenes at the same time using
            <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainers</inline></reference>. This is optimal in
            cases where the intent is to render different content in different parts of the
            screen. Minimaps and split-screen multiplayer are good examples.</paragraph>
        <paragraph>每个选项都有最合适的情况, 因此必须检查每个选项的效果并确定最适合其独特情况的路径.</paragraph>
        <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
    </section>
</document>
