<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/xr/a_better_xr_start_script.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-a-better-xr-start-script"></target>
    <section ids="a-better-xr-start-script doc-a-better-xr-start-script" names="a\ better\ xr\ start\ script doc_a_better_xr_start_script">
        <title>A better XR start script</title>
        <paragraph>In <reference internal="True" refuri="setting_up_xr#doc-setting-up-xr"><inline classes="std std-ref">设置 XR</inline></reference> we introduced a startup script that initialises our setup which we used as our script on our main node.
            This script performs the minimum steps required for any given interface.</paragraph>
        <paragraph>When using OpenXR there are a number of improvements we should do here.
            For this we've created a more elaborate starting script.
            You will find these used in our demo projects.</paragraph>
        <paragraph>Alternatively, if you are using XR Tools (see <reference internal="True" refuri="introducing_xr_tools#doc-introducing-xr-tools"><inline classes="std std-ref">XR 工具简介</inline></reference>) it contains a version of this script updated with some features related to XR tools.</paragraph>
        <paragraph>Below we will detail out the script used in our demos and explain the parts that are added.</paragraph>
        <section ids="signals-for-our-script" names="signals\ for\ our\ script">
            <title>Signals for our script</title>
            <paragraph>We are introducing 3 signals to our script so that our game can add further logic:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>focus_lost</literal> is emitted when the player takes off their headset or when the player enters the menu system of the headset.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>focus_gained</literal> is emitted when the player puts their headset back on or exists the menu system and returns to the game.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>pose_recentered</literal> is emitted when the headset requests the players position to be reset.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Our game should react accordingly to these signals.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node3D

signal focus_lost
signal focus_gained
signal pose_recentered

...</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode3D : Node3D
{
    [Signal]
    public delegate void FocusLostEventHandler();

    [Signal]
    public delegate void FocusGainedEventHandler();

    [Signal]
    public delegate void PoseRecenteredEventHandler();

...</literal_block>
                </div>
            </container>
        </section>
        <section ids="variables-for-our-script" names="variables\ for\ our\ script">
            <title>Variables for our script</title>
            <paragraph>We introduce a few new variables to our script as well:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>maximum_refresh_rate</literal> will control the headsets refresh rate if this is supported by the headset.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>xr_interface</literal> holds a reference to our XR interface, this already existed but we now type it to get full access to our <reference internal="True" refuri="../../classes/class_xrinterface#class-xrinterface"><inline classes="std std-ref">XRInterface</inline></reference> API.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>xr_is_focussed</literal> will be set to true whenever our game has focus.</paragraph>
                </list_item>
            </bullet_list>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

@export var maximum_refresh_rate : int = 90

var xr_interface : OpenXRInterface
var xr_is_focussed = false

...</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">...

    [Export]
    public int MaximumRefreshRate { get; set; } = 90;

    private OpenXRInterface _xrInterface;

    private bool _xrIsFocused;

...</literal_block>
                </div>
            </container>
        </section>
        <section ids="our-updated-ready-function" names="our\ updated\ ready\ function">
            <title>Our updated ready function</title>
            <paragraph>We add a few things to the ready function.</paragraph>
            <paragraph>If we're using the mobile or forward+ renderer we set the viewports <literal>vrs_mode</literal> to <literal>VRS_XR</literal>.
                On platforms that support this, this will enable foveated rendering.</paragraph>
            <paragraph>If we're using the compatibility renderer, we check if the OpenXR foveated rendering settings
                are configured and if not, we output a warning.
                See <reference internal="True" refuri="openxr_settings#doc-openxr-settings"><inline classes="std std-ref">OpenXR Settings</inline></reference> for further details.</paragraph>
            <paragraph>We hook up a number of signals that will be emitted by the <reference internal="True" refuri="../../classes/class_xrinterface#class-xrinterface"><inline classes="std std-ref">XRInterface</inline></reference>.
                We'll provide more detail about these signals as we implement them.</paragraph>
            <paragraph>We also quit our application if we couldn't successfully initialise OpenXR.
                Now this can be a choice.
                If you are making a mixed mode game you setup the VR mode of your game on success,
                and setup the non-VR mode of your game on failure.
                However, when running a VR only application on a standalone headset,
                it is nicer to exit on failure than to hang the system.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

# Called when the node enters the scene tree for the first time.
func _ready():
    xr_interface = XRServer.find_interface("OpenXR")
    if xr_interface and xr_interface.is_initialized():
        print("OpenXR instantiated successfully.")
        var vp : Viewport = get_viewport()

        # Enable XR on our viewport
        vp.use_xr = true

        # Make sure v-sync is off, v-sync is handled by OpenXR
        DisplayServer.window_set_vsync_mode(DisplayServer.VSYNC_DISABLED)

        # Enable VRS
        if RenderingServer.get_rendering_device():
            vp.vrs_mode = Viewport.VRS_XR
        elif int(ProjectSettings.get_setting("xr/openxr/foveation_level")) == 0:
            push_warning("OpenXR: Recommend setting Foveation level to High in Project Settings")

        # Connect the OpenXR events
        xr_interface.session_begun.connect(_on_openxr_session_begun)
        xr_interface.session_visible.connect(_on_openxr_visible_state)
        xr_interface.session_focussed.connect(_on_openxr_focused_state)
        xr_interface.session_stopping.connect(_on_openxr_stopping)
        xr_interface.pose_recentered.connect(_on_openxr_pose_recentered)
    else:
        # We couldn't start OpenXR.
        print("OpenXR not instantiated!")
        get_tree().quit()

...</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">...

    /// &lt;summary&gt;
    /// Called when the node enters the scene tree for the first time.
    /// &lt;/summary&gt;
    public override void _Ready()
    {
        _xrInterface = (OpenXRInterface)XRServer.FindInterface("OpenXR");
        if (_xrInterface != null &amp;&amp; _xrInterface.IsInitialized())
        {
            GD.Print("OpenXR instantiated successfully.");
            var vp = GetViewport();

            // Enable XR on our viewport
            vp.UseXR = true;

            // Make sure v-sync is off, v-sync is handled by OpenXR
            DisplayServer.WindowSetVsyncMode(DisplayServer.VSyncMode.Disabled);

            // Enable VRS
            if (RenderingServer.GetRenderingDevice() != null)
                vp.VrsMode = Viewport.VrsModeEnum.XR;
            else if ((int)ProjectSettings.GetSetting("xr/openxr/foveation_level") == 0)
                GD.PushWarning("OpenXR: Recommend setting Foveation level to High in Project Settings");

            // Connect the OpenXR events
            _xrInterface.SessionBegun += OnOpenXRSessionBegun;
            _xrInterface.SessionVisible += OnOpenXRVisibleState;
            _xrInterface.SessionFocussed += OnOpenXRFocusedState;
            _xrInterface.SessionStopping += OnOpenXRStopping;
            _xrInterface.PoseRecentered += OnOpenXRPoseRecentered;
        }
        else
        {
            // We couldn't start OpenXR.
            GD.Print("OpenXR not instantiated!");
            GetTree().Quit();
        }
    }

...</literal_block>
                </div>
            </container>
        </section>
        <section ids="on-session-begun" names="on\ session\ begun">
            <title>On session begun</title>
            <paragraph>This signal is emitted by OpenXR when our session is setup.
                This means the headset has run through setting everything up and is ready to begin receiving content from us.
                Only at this time various information is properly available.</paragraph>
            <paragraph>The main thing we do here is to check our headsets refresh rate.
                We also check the available refresh rates reported by the XR runtime to determine if we want to set our headset to a higher refresh rate.</paragraph>
            <paragraph>Finally we match our physics update rate to our headset update rate.
                Godot runs at a physics update rate of 60 updates per second by default while headsets run at a minimum of 72,
                and for modern headsets often up to 144 frames per second.
                Not matching the physics update rate will cause stuttering as frames are rendered without objects moving.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

# Handle OpenXR session ready
func _on_openxr_session_begun() -&gt; void:
    # Get the reported refresh rate
    var current_refresh_rate = xr_interface.get_display_refresh_rate()
    if current_refresh_rate &gt; 0:
        print("OpenXR: Refresh rate reported as ", str(current_refresh_rate))
    else:
        print("OpenXR: No refresh rate given by XR runtime")

    # See if we have a better refresh rate available
    var new_rate = current_refresh_rate
    var available_rates : Array = xr_interface.get_available_display_refresh_rates()
    if available_rates.size() == 0:
        print("OpenXR: Target does not support refresh rate extension")
    elif available_rates.size() == 1:
        # Only one available, so use it
        new_rate = available_rates[0]
    else:
        for rate in available_rates:
            if rate &gt; new_rate and rate &lt;= maximum_refresh_rate:
                new_rate = rate

    # Did we find a better rate?
    if current_refresh_rate != new_rate:
        print("OpenXR: Setting refresh rate to ", str(new_rate))
        xr_interface.set_display_refresh_rate(new_rate)
        current_refresh_rate = new_rate

    # Now match our physics rate
    Engine.physics_ticks_per_second = current_refresh_rate

...</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">...

    /// &lt;summary&gt;
    /// Handle OpenXR session ready
    /// &lt;/summary&gt;
    private void OnOpenXRSessionBegun()
    {
        // Get the reported refresh rate
        var currentRefreshRate = _xrInterface.DisplayRefreshRate;
        GD.Print(currentRefreshRate &gt; 0.0F
            ? $"OpenXR: Refresh rate reported as {currentRefreshRate}"
            : "OpenXR: No refresh rate given by XR runtime");

        // See if we have a better refresh rate available
        var newRate = currentRefreshRate;
        var availableRates = _xrInterface.GetAvailableDisplayRefreshRates();
        if (availableRates.Count == 0)
        {
            GD.Print("OpenXR: Target does not support refresh rate extension");
        }
        else if (availableRates.Count == 1)
        {
            // Only one available, so use it
            newRate = (float)availableRates[0];
        }
        else
        {
            GD.Print("OpenXR: Available refresh rates: ", availableRates);
            foreach (float rate in availableRates)
                if (rate &gt; newRate &amp;&amp; rate &lt;= MaximumRefreshRate)
                    newRate = rate;
        }

        // Did we find a better rate?
        if (currentRefreshRate != newRate)
        {
            GD.Print($"OpenXR: Setting refresh rate to {newRate}");
            _xrInterface.DisplayRefreshRate = newRate;
            currentRefreshRate = newRate;
        }

        // Now match our physics rate
        Engine.PhysicsTicksPerSecond = (int)currentRefreshRate;
    }

...</literal_block>
                </div>
            </container>
        </section>
        <section ids="on-visible-state" names="on\ visible\ state">
            <title>On visible state</title>
            <paragraph>This signal is emitted by OpenXR when our game becomes visible but is not focussed.
                This is a bit of a weird description in OpenXR but it basically means that our game has just started
                and we're about to switch to the focussed state next,
                that the user has opened a system menu or the users has just took their headset off.</paragraph>
            <paragraph>On receiving this signal we'll update our focussed state,
                we'll change the process mode of our node to disabled which will pause processing on this node and it's children,
                and emit our <literal>focus_lost</literal> signal.</paragraph>
            <paragraph>If you've added this script to your root node,
                this means your game will automatically pause when required.
                If you haven't, you can connect a method to the signal that performs additional changes.</paragraph>
            <note>
                <paragraph>While your game is in visible state because the user has opened a system menu,
                    Godot will keep rendering frames and head tracking will remain active so your game will remain visible in the background.
                    However controller and hand tracking will be disabled until the user exits the system menu.</paragraph>
            </note>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

# Handle OpenXR visible state
func _on_openxr_visible_state() -&gt; void:
    # We always pass this state at startup,
    # but the second time we get this it means our player took off their headset
    if xr_is_focussed:
        print("OpenXR lost focus")

        xr_is_focussed = false

        # pause our game
        process_mode = Node.PROCESS_MODE_DISABLED

        emit_signal("focus_lost")

...</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">...

    /// &lt;summary&gt;
    /// Handle OpenXR visible state
    /// &lt;/summary&gt;
    private void OnOpenXRVisibleState()
    {
        // We always pass this state at startup,
        // but the second time we get this it means our player took off their headset
        if (_xrIsFocused)
        {
            GD.Print("OpenXR lost focus");

            _xrIsFocused = false;

            // Pause our game
            ProcessMode = ProcessModeEnum.Disabled;

            EmitSignal(SignalName.FocusLost);
        }
    }

...</literal_block>
                </div>
            </container>
        </section>
        <section ids="on-focussed-state" names="on\ focussed\ state">
            <title>On focussed state</title>
            <paragraph>This signal is emitted by OpenXR when our game gets focus.
                This is done at the completion of our startup,
                but it can also be emitted when the user exits a system menu, or put their headset back on.</paragraph>
            <paragraph>Note also that when your game starts while the user is not wearing their headset,
                the game stays in 'visible' state until the user puts their headset on.</paragraph>
            <warning>
                <paragraph>It is thus important to keep your game paused while in visible mode.
                    If you don't the game will keep on running while your user isn't interacting with your game.
                    Also when the game returns to focussed mode,
                    suddenly all controller and hand tracking is re-enabled and could have game breaking consequences
                    if you do not react to this accordingly.
                    Be sure to test this behaviour in your game!</paragraph>
            </warning>
            <paragraph>While handling our signal we will update the focusses state, unpause our node and emit our <literal>focus_gained</literal> signal.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

# Handle OpenXR focused state
func _on_openxr_focused_state() -&gt; void:
    print("OpenXR gained focus")
    xr_is_focussed = true

    # unpause our game
    process_mode = Node.PROCESS_MODE_INHERIT

    emit_signal("focus_gained")

...</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">...

    /// &lt;summary&gt;
    /// Handle OpenXR focused state
    /// &lt;/summary&gt;
    private void OnOpenXRFocusedState()
    {
        GD.Print("OpenXR gained focus");
        _xrIsFocused = true;

        // Un-pause our game
        ProcessMode = ProcessModeEnum.Inherit;

        EmitSignal(SignalName.FocusGained);
    }

...</literal_block>
                </div>
            </container>
        </section>
        <section ids="on-stopping-state" names="on\ stopping\ state">
            <title>On stopping state</title>
            <paragraph>This signal is emitted by OpenXR when we enter our stop state.
                There are some differences between platforms when this happens.
                On some platforms this is only emitted when the game is being closed.
                But on other platforms this will also be emitted every time the player takes off their headset.</paragraph>
            <paragraph>For now this method is only a place holder.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

# Handle OpenXR stopping state
func _on_openxr_stopping() -&gt; void:
    # Our session is being stopped.
    print("OpenXR is stopping")

...</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">...

    /// &lt;summary&gt;
    /// Handle OpenXR stopping state
    /// &lt;/summary&gt;
    private void OnOpenXRStopping()
    {
        // Our session is being stopped.
        GD.Print("OpenXR is stopping");
    }

...</literal_block>
                </div>
            </container>
        </section>
        <section ids="on-pose-recentered" names="on\ pose\ recentered">
            <title>On pose recentered</title>
            <paragraph>This signal is emitted by OpenXR when the user requests their view to be recentered.
                Basically this communicates to your game that the user is now facing forward
                and you should re-orient the player so they are facing forward in the virtual world.</paragraph>
            <paragraph>As doing so is dependent on your game, your game needs to react accordingly.</paragraph>
            <paragraph>All we do here is emit the <literal>pose_recentered</literal> signal.
                You can connect to this signal and implement the actual recenter code.
                Often it is enough to call <reference internal="True" refuri="../../classes/class_xrserver#class-xrserver-method-center-on-hmd"><inline classes="std std-ref">center_on_hmd()</inline></reference>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

# Handle OpenXR pose recentered signal
func _on_openxr_pose_recentered() -&gt; void:
    # User recentered view, we have to react to this by recentering the view.
    # This is game implementation dependent.
    emit_signal("pose_recentered")</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">...

    /// &lt;summary&gt;
    /// Handle OpenXR pose recentered signal
    /// &lt;/summary&gt;
    private void OnOpenXRPoseRecentered()
    {
        // User recentered view, we have to react to this by recentering the view.
        // This is game implementation dependent.
        EmitSignal(SignalName.PoseRecentered);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>And that finished our script. It was written so that it can be re-used over multiple projects.
                Just add it as the script on your main node (and extend it if needed)
                or add it on a child node specific for this script.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
