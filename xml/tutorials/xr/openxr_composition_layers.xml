<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/xr/openxr_composition_layers.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-openxr-composition-layers"></target>
    <section ids="openxr-composition-layers doc-openxr-composition-layers" names="openxr\ composition\ layers doc_openxr_composition_layers">
        <title>OpenXR composition layers</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>In XR games you generally want to create user interactions that happen in 3D space
                and involve users touching objects as if they are touching them in real life.</paragraph>
            <paragraph>Sometimes however creating a more traditional 2D interface is unavoidable.
                In XR however you can't just add 2D components to your scene.
                Godot needs depth information to properly position these elements so they appear at
                a comfortable place for the user.
                Even with depth information there are headsets with slanted displays that make it impossible
                for the standard 2D pipeline to correctly render the 2D elements.</paragraph>
            <paragraph>The solution then is to render the UI to a <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>
                and display the result of this using a <reference internal="True" refuri="../../classes/class_viewporttexture#class-viewporttexture"><inline classes="std std-ref">ViewportTexture</inline></reference> on a 3D mesh.
                The <reference internal="True" refuri="../../classes/class_quadmesh#class-quadmesh"><inline classes="std std-ref">QuadMesh</inline></reference> is a suitable option for this.</paragraph>
            <note>
                <paragraph>See the <reference name="GUI in 3D" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/viewport/gui_in_3d">GUI in 3D</reference><target ids="gui-in-3d" names="gui\ in\ 3d" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/viewport/gui_in_3d"></target>
                    example project for an example of this approach.</paragraph>
            </note>
            <paragraph>The problem with displaying the viewport in this way is that the rendered result
                is sampled for lens distortion by the XR runtime and the resulting quality loss
                can make UI text hard to read.</paragraph>
            <paragraph>OpenXR offers a solution to this problem through composition layers.
                With composition layers it is possible for the contents of a viewport to be projected
                on a surface after lens distortion resulting in a much higher quality end result.</paragraph>
            <note>
                <paragraph>As not all XR runtimes support all composition layer types,
                    Godot implements a fallback solution where we render the viewport
                    as part of the normal scene but with the aforementioned quality
                    limitations.</paragraph>
            </note>
            <warning>
                <paragraph>When the composition layer is supported,
                    it is the XR runtime that presents the subviewport.
                    This means the UI is only visible in the headset,
                    it will not be accessible by Godot and will thus
                    not be shown when you have a spectator view on the desktop.</paragraph>
            </warning>
            <paragraph>There are currently 3 nodes that expose this functionality:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_openxrcompositionlayercylinder#class-openxrcompositionlayercylinder"><inline classes="std std-ref">OpenXRCompositionLayerCylinder</inline></reference> shows the contents of the SubViewport on the inside of a cylinder (or "slice" of a cylinder).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_openxrcompositionlayerequirect#class-openxrcompositionlayerequirect"><inline classes="std std-ref">OpenXRCompositionLayerEquirect</inline></reference> shows the contents of the SubViewport on the interior of a sphere (or "slice" of a sphere).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_openxrcompositionlayerquad#class-openxrcompositionlayerquad"><inline classes="std std-ref">OpenXRCompositionLayerQuad</inline></reference> shows the contents of the SubViewport on a flat rectangle.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="setting-up-the-subviewport" names="setting\ up\ the\ subviewport 设置\ subviewport">
            <title>设置 SubViewport</title>
            <paragraph>The first step is adding a SubViewport for our 2D UI,
                this doesn't require any specific steps.
                For our example we do mark the viewport as transparent.</paragraph>
            <paragraph>You can now create the 2D UI by adding child nodes to the SubViewport as you normally would.
                It is advisable to save the 2D UI in a subscene, this makes it easier to do your layout.</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/openxr_composition_layer_subviewport.webp'}" uri="tutorials/xr/img/openxr_composition_layer_subviewport.webp"></image>
            <warning>
                <paragraph>The update mode "When Visible" will not work as Godot can't determine whether
                    the viewport is visible to the user.
                    When assigning our viewport to a composition layer Godot will automatically adjust this.</paragraph>
            </warning>
        </section>
        <section ids="adding-a-composition-layer" names="adding\ a\ composition\ layer">
            <title>Adding a composition layer</title>
            <paragraph>The second step is adding our composition layer.
                We simply add the correct composition layer node as a child node of
                our <reference internal="True" refuri="../../classes/class_xrorigin3d#class-xrorigin3d"><inline classes="std std-ref">XROrigin3D</inline></reference> node.
                This is very important as the XR runtime positions everything in relation to our origin.</paragraph>
            <paragraph>We want to position the composition layer so it is at eye height and roughly 1 to 1.5 meters
                away from the player.</paragraph>
            <paragraph>We now assign the SubViewport to the <literal>Layer Viewport</literal> property and enable Alpha Blend.</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/openxr_composition_layer_quad.webp'}" uri="tutorials/xr/img/openxr_composition_layer_quad.webp"></image>
            <note>
                <paragraph>As the player can walk away from the origin point,
                    you will want to reposition the composition layer when the player recenters the view.
                    Using the reference space <literal>Local Floor</literal> will apply this logic automatically.</paragraph>
            </note>
        </section>
        <section ids="making-the-interface-work" names="making\ the\ interface\ work">
            <title>Making the interface work</title>
            <paragraph>So far we're only displaying our UI, to make it work we need to add some code.
                For this example we're going to keep things simple and
                make one of the controllers work as a pointer.
                We'll then simulate mouse actions with this pointer.</paragraph>
            <paragraph>This code also requires a <literal>MeshInstance3D</literal> node called <literal>Pointer</literal> to be added
                as a child to our <literal>OpenXRCompositionLayerQuad</literal> node.
                We configure a <literal>SphereMesh</literal> with a radius <literal>0.01</literal> meters.
                We'll be using this as a helper to visualize where the user is pointing.</paragraph>
            <paragraph>The main function that drives this functionality is the <literal>intersects_ray</literal>
                function on our composition layer node.
                This function takes the global position and orientation of our pointer and returns
                the UV where our ray intersects our viewport.
                It returns <literal>Vector2(-1.0, -1.0)</literal> if we're not pointing at our viewport.</paragraph>
            <paragraph>We start with setting up some variables, important here are the export variables
                which identify our controller node with which we point to our screen.</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends OpenXRCompositionLayerQuad

const NO_INTERSECTION = Vector2(-1.0, -1.0)

@export var controller : XRController3D
@export var button_action : String = "trigger_click"

var was_pressed : bool = false
var was_intersect : Vector2 = NO_INTERSECTION

...</literal_block>
            <paragraph>Next we define a helper function that takes the value returned from <literal>intersects_ray</literal>
                and gives us the global position for that intersection point.
                This implementation only works for our <literal>OpenXRCompositionLayerQuad</literal> node.</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

func _intersect_to_global_pos(intersect : Vector2) -&gt; Vector3:
    if intersect != NO_INTERSECTION:
        var local_pos : Vector2 = (intersect - Vector2(0.5, 0.5)) * quad_size
        return global_transform * Vector3(local_pos.x, -local_pos.y, 0.0)
    else:
        return Vector3()

...</literal_block>
            <paragraph>We also define a helper function that takes our <literal>intersect</literal> value and
                returns our location in the viewports local coordinate system:</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

func _intersect_to_viewport_pos(intersect : Vector2) -&gt; Vector2i:
    if layer_viewport and intersect != NO_INTERSECTION:
        var pos : Vector2 = intersect * Vector2(layer_viewport.size)
        return Vector2i(pos)
    else:
        return Vector2i(-1, -1)

...</literal_block>
            <paragraph>The main logic happens in our <literal>_process</literal> function.
                Here we start by hiding our pointer,
                we then check if we have a valid controller and viewport,
                and we call <literal>intersects_ray</literal> with the position and orientation of our controller:</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(_delta):
    # Hide our pointer, we'll make it visible if we're interacting with the viewport.
    $Pointer.visible = false

    if controller and layer_viewport:
        var controller_t : Transform3D = controller.global_transform
        var intersect : Vector2 = intersects_ray(controller_t.origin, -controller_t.basis.z)

...</literal_block>
            <paragraph>Next we check if we're intersecting with our viewport.
                If so, we check if our button is pressed and place our pointer at our intersection point.</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

        if intersect != NO_INTERSECTION:
            var is_pressed : bool = controller.is_button_pressed(button_action)

            # Place our pointer where we're pointing
            var pos : Vector3 = _intersect_to_global_pos(intersect)
            $Pointer.visible = true
            $Pointer.global_position = pos

...</literal_block>
            <paragraph>If we were intersecting in our previous process call and our pointer has moved,
                we prepare a <reference internal="True" refuri="../../classes/class_inputeventmousemotion#class-inputeventmousemotion"><inline classes="std std-ref">InputEventMouseMotion</inline></reference> object
                to simulate our mouse moving and send that to our viewport for further processing.</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

            if was_intersect != NO_INTERSECTION and intersect != was_intersect:
                # Pointer moved
                var event : InputEventMouseMotion = InputEventMouseMotion.new()
                var from : Vector2 = _intersect_to_viewport_pos(was_intersect)
                var to : Vector2 = _intersect_to_viewport_pos(intersect)
                if was_pressed:
                    event.button_mask = MOUSE_BUTTON_MASK_LEFT
                event.relative = to - from
                event.position = to
                layer_viewport.push_input(event)

...</literal_block>
            <paragraph>If we've just released our button we also prepare
                a <reference internal="True" refuri="../../classes/class_inputeventmousebutton#class-inputeventmousebutton"><inline classes="std std-ref">InputEventMouseButton</inline></reference> object
                to simulate a button release and send that to our viewport for further processing.</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

            if not is_pressed and was_pressed:
                # Button was let go?
                var event : InputEventMouseButton = InputEventMouseButton.new()
                event.button_index = 1
                event.pressed = false
                event.position = _intersect_to_viewport_pos(intersect)
                layer_viewport.push_input(event)

...</literal_block>
            <paragraph>Or if we've just pressed our button we prepare
                a <reference internal="True" refuri="../../classes/class_inputeventmousebutton#class-inputeventmousebutton"><inline classes="std std-ref">InputEventMouseButton</inline></reference> object
                to simulate a button press and send that to our viewport for further processing.</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

            elif is_pressed and not was_pressed:
                # Button was pressed?
                var event : InputEventMouseButton = InputEventMouseButton.new()
                event.button_index = 1
                event.button_mask = MOUSE_BUTTON_MASK_LEFT
                event.pressed = true
                event.position = _intersect_to_viewport_pos(intersect)
                layer_viewport.push_input(event)

...</literal_block>
            <paragraph>Next we remember our state for next frame.</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

            was_pressed = is_pressed
            was_intersect = intersect

...</literal_block>
            <paragraph>Finally, if we aren't intersecting, we simply clear our state.</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">...

        else:
            was_pressed = false
            was_intersect = NO_INTERSECTION</literal_block>
        </section>
        <section ids="hole-punching" names="hole\ punching">
            <title>Hole punching</title>
            <paragraph>As the composition layer is composited on top of the render result,
                it can be rendered in front of objects that are actually forward of the viewport.</paragraph>
            <paragraph>By enabling hole punch you instruct Godot to render a transparent object
                where our viewport is displayed.
                It does this in a way that fills the depth buffer and clears the current rendering result.
                Anything behind our viewport will now be cleared,
                while anything in front of our viewport will be rendered as usual.</paragraph>
            <paragraph>You also need to set <literal>Sort Order</literal> to a negative value,
                the XR compositor will now draw the viewport first, and then overlay our rendering result.</paragraph>
            <figure align="center" ids="id1">
                <image candidates="{'*': 'tutorials/xr/img/openxr_composition_layer_hole_punch.webp'}" uri="tutorials/xr/img/openxr_composition_layer_hole_punch.webp"></image>
                <caption>Use case showing how the users hand is incorrectly obscured
                    by a composition layer when hole punching is not used.</caption>
            </figure>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
