<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/xr/ar_passthrough.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-openxr-passthrough"></target>
    <section ids="ar-passthrough doc-openxr-passthrough" names="ar\ /\ passthrough doc_openxr_passthrough">
        <title>AR / Passthrough</title>
        <paragraph>Augmented Reality is supported through various methods depending on the capabilities of the hardware.</paragraph>
        <paragraph>Headsets such as the Magic Leap and glasses such as TiltFive show the rendered result on
            <reference name="see-through displays" refuri="https://en.wikipedia.org/wiki/See-through_display">see-through displays</reference> allowing the user
            to see the real world.</paragraph>
        <paragraph>Headsets such as the Quest, HTC Elite, and Lynx R1 implement this through a technique called video passthrough,
            where cameras record the real world and these images are used as the background on top of which our rendered
            result is used.</paragraph>
        <note>
            <paragraph>Passthrough is implemented very differently across platforms.</paragraph>
            <paragraph>In Godot 4.3 we have implemented a unified approach that is explained on this help page
                so you don't need to worry about these differences, the <reference internal="True" refuri="../../classes/class_xrinterface#class-xrinterface"><inline classes="std std-ref">XRInterface</inline></reference>
                implementation is now responsible for applying the correct platform dependent method <footnote_reference auto="1" docname="tutorials/xr/ar_passthrough" ids="id1" refid="id3">1</footnote_reference>.</paragraph>
            <paragraph>For headsets such as the Meta Quest and HTC Elite you will need to use the
                <reference name="OpenXR vendors plugin v3.0.0" refuri="https://github.com/GodotVR/godot_openxr_vendors/releases">OpenXR vendors plugin v3.0.0</reference>
                or later to enable video passthrough.</paragraph>
            <paragraph>For backwards compatibility the old API for passthrough is still available but it is recommended
                to follow the new instructions below.</paragraph>
        </note>
        <section ids="environment-blend-modes" names="environment\ blend\ modes">
            <title>Environment blend modes</title>
            <paragraph>The way we configure VR or AR functionality is through setting the environment blend mode.
                This mode determines how the (real world) environment is blended with the virtual world.</paragraph>
            <table classes="colwidths-given" ids="id5">
                <title>Blend modes</title>
                <tgroup cols="2">
                    <colspec colwidth="35"></colspec>
                    <colspec colwidth="65"></colspec>
                    <thead>
                        <row>
                            <entry>
                                <paragraph>Blend mode</paragraph>
                            </entry>
                            <entry>
                                <paragraph>描述</paragraph>
                            </entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>XR_ENV_BLEND_MODE_OPAQUE</paragraph>
                            </entry>
                            <entry>
                                <paragraph>The rendered image is opaque, we do not see the real world. We're in VR mode.
                                    This will turn off passthrough if video-passthrough is used.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>XR_ENV_BLEND_MODE_ADDITIVE</paragraph>
                            </entry>
                            <entry>
                                <paragraph>The rendered image is added to the real world and will look semi transparent.
                                    This mode is generally used with see-through devices that are unable to obscure
                                    the real world.
                                    This will turn on passthrough if video-passthrough is used.</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>XR_ENV_BLEND_MODE_ALPHA_BLEND</paragraph>
                            </entry>
                            <entry>
                                <paragraph>The rendered image is alpha blended with the real world.
                                    On see-through devices that support this, the alpha will control the translucency
                                    of the optics.
                                    On video-passthrough devices alpha blending is applied with the video image.
                                    passthrough will also be enabled if applicable.</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <paragraph>You can set the environment blend mode for your application through the <literal>environment_blend_mode</literal>
                property of the <reference internal="True" refuri="../../classes/class_xrinterface#class-xrinterface"><inline classes="std std-ref">XRInterface</inline></reference> instance.</paragraph>
            <paragraph>You can query the supported blend modes on the hardware using the
                <literal>get_supported_environment_blend_modes</literal> property on the same instance.</paragraph>
        </section>
        <section ids="configuring-your-background" names="configuring\ your\ background">
            <title>Configuring your background</title>
            <paragraph>When setting the blend mode to <literal>XR_ENV_BLEND_MODE_ALPHA_BLEND</literal> you must set
                the <literal>transparent_bg</literal> property on <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> to true.
                When using the <literal>XR_ENV_BLEND_MODE_ADDITIVE</literal> blend mode you should set your
                background color to black.</paragraph>
            <paragraph>Either solution will result in the background rendering not contributing to lighting.
                It is thus also recommended you adjust your environment settings accordingly and ensure
                there is adequate ambient light set to illuminate your scene.</paragraph>
            <note>
                <paragraph>Some AR SDKs do provide ambient lighting information or even provide a full radiance
                    map to allow for real world reflections in your virtual objects.
                    The core Godot XR functionality doesn't currently have support for this, however this
                    functionality can be exposed through plugins.</paragraph>
            </note>
        </section>
        <section ids="openxr-specific" names="openxr\ specific">
            <title>OpenXR specific</title>
            <paragraph>In OpenXR you can configure the default blend mode you want to use.
                Godot will select this blend mode at startup if available.
                If not available Godot will default to the first supported blend mode provided
                by the XR runtime.</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/openxr_default_blend_mode.webp'}" uri="tutorials/xr/img/openxr_default_blend_mode.webp"></image>
            <paragraph>For passthrough devices OpenXR requires additional settings to be configured.
                These settings are platform dependent and provided through the OpenXR vendors plugin.</paragraph>
            <paragraph>For example, these are the settings required on Meta Quest:</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/openxr_export_passthrough.webp'}" uri="tutorials/xr/img/openxr_export_passthrough.webp"></image>
            <paragraph>The <literal>Passthrough</literal> setting defines whether passthrough is supported or even required.</paragraph>
            <paragraph>The <literal>Boundary Mode</literal> allows you to define whether the guardian is needed,
                disabling this fully requires passthrough to be enabled at all times.</paragraph>
        </section>
        <section ids="putting-it-together" names="putting\ it\ together">
            <title>Putting it together</title>
            <paragraph>Putting the above together we can use the following code as a base:</paragraph>
            <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@onready var viewport : Viewport = get_viewport()
@onready var environment : Environment = $WorldEnvironment.environment

func switch_to_ar() -&gt; bool:
    var xr_interface: XRInterface = XRServer.primary_interface
    if xr_interface:
        var modes = xr_interface.get_supported_environment_blend_modes()
        if XRInterface.XR_ENV_BLEND_MODE_ALPHA_BLEND in modes:
            xr_interface.environment_blend_mode = XRInterface.XR_ENV_BLEND_MODE_ALPHA_BLEND
            viewport.transparent_bg = true
        elif XRInterface.XR_ENV_BLEND_MODE_ADDITIVE in modes:
            xr_interface.environment_blend_mode = XRInterface.XR_ENV_BLEND_MODE_ADDITIVE
            viewport.transparent_bg = false
    else:
        return false

    environment.background_mode = Environment.BG_COLOR
    environment.background_color = Color(0.0, 0.0, 0.0, 0.0)
    environment.ambient_light_source = Environment.AMBIENT_SOURCE_COLOR
    return true

func switch_to_vr() -&gt; bool:
    var xr_interface: XRInterface = XRServer.primary_interface
    if xr_interface:
        var modes = xr_interface.get_supported_environment_blend_modes()
        if XRInterface.XR_ENV_BLEND_MODE_OPAQUE in modes:
            xr_interface.environment_blend_mode = XRInterface.XR_ENV_BLEND_MODE_OPAQUE
        else:
            return false

    viewport.transparent_bg = false
    environment.background_mode = Environment.BG_SKY
    environment.ambient_light_source = Environment.AMBIENT_SOURCE_BG
    return true</literal_block>
        </section>
        <section ids="shadow-to-opacity" names="shadow\ to\ opacity">
            <title>Shadow to opacity</title>
            <paragraph>Shadow to opacity is a render mode for Godot spatial shaders
                that was introduced in Godot 3 specifically for AR.
                It is a special render mode where the more a surface is in shadow,
                the more opaque the surface becomes. When a surface is fully lit,
                the surface becomes fully transparent and thus shows the real world.</paragraph>
            <paragraph>However the surface is rendered during the opaque state effectively.
                This has two consequences:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>As both the depth buffer and color buffer are written to, we occlude
                        any geometry behind our surface even when fully transparent.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>As we are making the surface opaque if in shadow, we can have virtual
                        objects cast shadows on real world objects <footnote_reference auto="1" docname="tutorials/xr/ar_passthrough" ids="id2" refid="id4">2</footnote_reference>.</paragraph>
                </list_item>
            </bullet_list>
            <figure ids="id6">
                <image alt="Image showing shadow to opacity being used to show the users desk." candidates="{'*': 'tutorials/xr/img/xr_passthrough_example.webp'}" uri="tutorials/xr/img/xr_passthrough_example.webp"></image>
                <caption>Image showing shadow to opacity being used to show the users desk.</caption>
            </figure>
            <paragraph>This enabled the following use cases:</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph>You can render a box mesh around a real world table, this ensures the
                        table remains visible even if a virtual object is placed underneath it.
                        The virtual object will be correctly occluded.
                        Placing a virtual object on top of the real world table, will result in
                        a shadow being cast on the table.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>You can use a shader with this render mode when render a hand mesh
                        using the hand tracking functionality, and ensure your hands properly
                        occlude virtual objects.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The following shader code is a good base for this functionality:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;
render_mode blend_mix, depth_draw_opaque, cull_back, shadow_to_opacity;

void fragment() {
    ALBEDO = vec3(0.0, 0.0, 0.0);
}</literal_block>
            <footnote auto="1" backrefs="id1" docname="tutorials/xr/ar_passthrough" ids="id3" names="1">
                <label>1</label>
                <paragraph>Restrictions may apply depending on XR interface implementation.</paragraph>
            </footnote>
            <footnote auto="1" backrefs="id2" docname="tutorials/xr/ar_passthrough" ids="id4" names="2">
                <label>2</label>
                <paragraph>This feature is still being perfected.</paragraph>
            </footnote>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
