<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/xr/openxr_settings.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-openxr-settings"></target>
    <section ids="openxr-settings doc-openxr-settings" names="openxr\ settings openxr\ 设置 doc_openxr_settings">
        <title>OpenXR 设置</title>
        <paragraph>OpenXR 有一套自己的设置，这些设置会在 OpenXR 启动时应用。尽管能通过插件实现的 OpenXR 扩展以添加额外设置，但在这里我们只讨论 Godot 核心中的设置。</paragraph>
        <image candidates="{'*': 'tutorials/xr/img/openxr_settings.png'}" uri="tutorials/xr/img/openxr_settings.png"></image>
        <section ids="enabled" names="enabled">
            <title>Enabled</title>
            <paragraph>此设置决定了在 Godot 启动时是否启用 OpenXR。当使用 Vulkan 后端时，该选项必须打开。对于其他后端，可随时通过调用 <reference internal="True" refuri="../../classes/class_openxrinterface#class-openxrinterface"><inline classes="std std-ref">OpenXRInterface</inline></reference> 类的 <literal>initialize</literal> 来启用 OpenXR。</paragraph>
            <paragraph>如果要访问动作映射编辑器，该选项也需启用。</paragraph>
            <paragraph>你可以使用 <literal>--xr-mode on</literal> 命令行指令以强制启用该模式。</paragraph>
        </section>
        <section ids="default-action-map" names="default\ action\ map 默认动作映射">
            <title>默认动作映射</title>
            <paragraph>该选项指定了 OpenXR 将加载并与 XR 运行时通信的操作映射文件的路径。</paragraph>
        </section>
        <section ids="form-factor" names="form\ factor 构成因素">
            <title>构成因素</title>
            <paragraph>该选项指定了你的游戏是为以下哪种设备设计的：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>Head Mounted</literal> 头戴式设备，如 Meta Quest、Valve Index 或 Magic Leap，</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>Handheld</literal> 手持设备，例如手机。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>如果运行游戏的设备与此处不匹配，OpenXR 将无法初始化。</paragraph>
        </section>
        <section ids="view-configuration" names="view\ configuration 视图配置">
            <title>视图配置</title>
            <paragraph>该选项指定了游戏是为哪种视图配置而设计的：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>Mono</literal>，游戏只提供单一图像输出。例：手机 AR;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>Stereo</literal>，你的游戏提供立体图像输出。例：头戴式设备。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>如果运行游戏的设备与此处不匹配，OpenXR 将无法初始化。</paragraph>
            <note>
                <paragraph>Godot 暂不支持 OpenXR 中针对特定设备的额外视图配置。例如，Varjo 头显有一个四视图配置，可以输出两组立体图像。这些特例可能会在不久的将来得到支持。</paragraph>
            </note>
        </section>
        <section ids="reference-space" names="reference\ space 参照空间">
            <title>参照空间</title>
            <paragraph>在 XR 中，玩家的头部和手部等所有元素的追踪都在一个追踪体积内进行。这个追踪体积的基点是将虚拟空间映射到现实空间的原点。根据使用的 XR 系统的不同，该点会被放置在不同的位置。在 OpenXR 中，这些场景被明确定义，并通过设置参考空间来选择。</paragraph>
            <section ids="local" names="local local（本地）">
                <title>Local（本地）</title>
                <paragraph>本地参照空间默认将原点放置在玩家的头部。一些 XR 运行时会在游戏启动时重设该位置，而其他则会让该位置在多个会话中保持不变。</paragraph>
                <paragraph>然而，这种参照空间并不会阻止用户走开，因此如果你希望阻止用户离开他们正在控制的部件（这可能会破坏游戏），则需要检测用户是否离开。</paragraph>
                <paragraph>本地参照空间是飞行模拟器或赛车模拟器的最佳选择，这类游戏通常希望将 <reference internal="True" refuri="../../classes/class_xrorigin3d#class-xrorigin3d"><inline classes="std std-ref">XROrigin3D</inline></reference> 节点放置在玩家头部应在的位置。</paragraph>
                <paragraph>When the user enacts the recenter option on their headset, the method of which is different per XR runtime,
                    the XR runtime will move the <reference internal="True" refuri="../../classes/class_xrcamera3d#class-xrcamera3d"><inline classes="std std-ref">XRCamera3D</inline></reference> to the <reference internal="True" refuri="../../classes/class_xrorigin3d#class-xrorigin3d"><inline classes="std std-ref">XROrigin3D</inline></reference> node.
                    The <reference internal="True" refuri="../../classes/class_openxrinterface#class-openxrinterface"><inline classes="std std-ref">OpenXRInterface</inline></reference> will also emit the <literal>pose_recentered</literal> signal
                    so your game can react accordingly.</paragraph>
                <note>
                    <paragraph>其他 XR 追踪元素，如控制器、锚点，也将相应调整，以保持和重置后的玩家位置一致。</paragraph>
                </note>
                <warning>
                    <paragraph>在使用此参照空间时，<strong>不应</strong>调用 <literal>center_on_hmd</literal>。</paragraph>
                </warning>
            </section>
            <section ids="stage" names="stage stage（暂存区）">
                <title>Stage（暂存区）</title>
                <paragraph>The stage reference space is our default reference space and places our origin point at the center of our play space.
                    For XR runtimes that allow you to draw out a guardian boundary this location and its orientation is often set by the user.
                    Other XR runtimes may decide on the placement of this point by other means.
                    It is however a stationary point in the real world.</paragraph>
                <paragraph>This reference space is the best option for room scale games where the user is expected to walk around a larger space,
                    or for games where there is a need to switch between game modes.
                    See <reference internal="True" refuri="xr_room_scale#doc-xr-room-scale"><inline classes="std std-ref">Room Scale</inline></reference> for more information.</paragraph>
                <paragraph>When the user enacts the recenter option on their headset, the method of which is different per XR runtime,
                    the XR runtime will not change the origin point.
                    The <reference internal="True" refuri="../../classes/class_openxrinterface#class-openxrinterface"><inline classes="std std-ref">OpenXRInterface</inline></reference> will emit the <literal>pose_recentered</literal> signal
                    and it is up to the game to react appropriately.
                    Not doing so will prevent your game from being accepted on various stores.</paragraph>
                <paragraph>In Godot you can do this by calling the <literal>center_on_hmd</literal> function on the <reference internal="True" refuri="../../classes/class_xrserver#class-xrserver"><inline classes="std std-ref">XRServer</inline></reference>:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Calling <literal>XRServer.center_on_hmd(XRServer.RESET_BUT_KEEP_TILT, true)</literal> will move the <reference internal="True" refuri="../../classes/class_xrcamera3d#class-xrcamera3d"><inline classes="std std-ref">XRCamera3D</inline></reference> node
                            to the <reference internal="True" refuri="../../classes/class_xrorigin3d#class-xrorigin3d"><inline classes="std std-ref">XROrigin3D</inline></reference> node similar to the <literal>Local</literal> reference space.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Calling <literal>XRServer.center_on_hmd(XRServer.RESET_BUT_KEEP_TILT, true)</literal> will move the <reference internal="True" refuri="../../classes/class_xrcamera3d#class-xrcamera3d"><inline classes="std std-ref">XRCamera3D</inline></reference> node
                            above the <reference internal="True" refuri="../../classes/class_xrorigin3d#class-xrorigin3d"><inline classes="std std-ref">XROrigin3D</inline></reference> node keeping the player's height, similar to the <literal>Local Floor</literal> reference space.</paragraph>
                    </list_item>
                </bullet_list>
                <note>
                    <paragraph>其他 XR 追踪元素，如控制器、锚点，也将相应调整，以保持和重置后的玩家位置一致。</paragraph>
                </note>
            </section>
            <section ids="local-floor" names="local\ floor">
                <title>Local Floor</title>
                <paragraph>The local floor reference space is similar to the local reference space as it positions the origin point where the player is.
                    In this mode however the height of the player is kept.
                    Same as with the local reference space, some XR runtimes will persist this location over sessions.</paragraph>
                <paragraph>It is thus not guaranteed the player will be standing on the origin point,
                    the only guarantee is that they were standing there when the user last recentered.
                    The player is thus also free to walk away.</paragraph>
                <paragraph>This reference space is the best option of games where the user is expected to stand in the same location
                    or for AR type games where the user's interface elements are bound to the origin node
                    and are quickly placed at the player's location on recenter.</paragraph>
                <paragraph>When the user enacts the recenter option on their headset, the method of which is different per XR runtime,
                    the XR runtime will move the <reference internal="True" refuri="../../classes/class_xrcamera3d#class-xrcamera3d"><inline classes="std std-ref">XRCamera3D</inline></reference> above the <reference internal="True" refuri="../../classes/class_xrorigin3d#class-xrorigin3d"><inline classes="std std-ref">XROrigin3D</inline></reference> node
                    but keeping the player's height.
                    The <reference internal="True" refuri="../../classes/class_openxrinterface#class-openxrinterface"><inline classes="std std-ref">OpenXRInterface</inline></reference> will also emit the <literal>pose_recentered</literal> signal
                    so your game can react accordingly.</paragraph>
                <warning>
                    <paragraph>Be careful using this mode in combination with virtual movement of the player.
                        The user recentering in this scenario can be unpredictable unless you counter the move when handling the recenter signal.
                        This can even be game breaking as the effect in this scenario would be the player teleporting to whatever abstract location
                        the origin point was placed at during virtual movement, including the ability for players teleporting into
                        locations that should be off limits.
                        It is better to use the Stage mode in this scenario and limit resetting to orientation only when a <literal>pose_recentered</literal> signal is received.</paragraph>
                </warning>
                <note>
                    <paragraph>其他 XR 追踪元素，如控制器、锚点，也将相应调整，以保持和重置后的玩家位置一致。</paragraph>
                </note>
                <warning>
                    <paragraph>在使用此参照空间时，<strong>不应</strong>调用 <literal>center_on_hmd</literal>。</paragraph>
                </warning>
            </section>
        </section>
        <section ids="environment-blend-mode" names="environment\ blend\ mode 环境混合模式">
            <title>环境混合模式</title>
            <paragraph>The environment blend mode defines how our rendered output is blended into "the real world" provided this is supported by the headset.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>Opaque</literal> means our output obscures the real world, we are in VR mode.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>Additive</literal> means our output is added to the real world,
                        this is an AR mode where optics do not allow us to fully obscure the real world (e.g. Hololens),</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>Alpha</literal> means our output is blended with the real world using the alpha output (viewport should have transparent background enabled),
                        this is an AR mode where optics can fully obscure the real world (Magic Leap, all pass through devices, etc.).</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If a mode is selected that is not supported by the headset, the first available mode will be selected.</paragraph>
            <note>
                <paragraph>Some OpenXR devices have separate systems for enabling/disabling passthrough.
                    From Godot 4.3 onwards selecting the alpha blend mode will also perform these extra steps.
                    This does require the latest vendor plugin to be installed.</paragraph>
            </note>
        </section>
        <section ids="foveation-level" names="foveation\ level 注视点级别">
            <title>注视点级别</title>
            <paragraph>Sets the foveation level used when rendering provided this feature is supported by the hardware used.
                Foveation is a technique where the further away from the center of the viewport we render content, the lower resolution we render at.
                Most XR runtimes only support fixed foveation, but some will take eye tracking into account and use the focal point for this effect.</paragraph>
            <paragraph>The higher the level, the better the performance gains, but also the more reduction in quality there is in the users peripheral vision.</paragraph>
            <note>
                <paragraph><strong>Compatibility renderer only</strong>,
                    for Mobile and Forward+ renderer, set the <literal>vrs_mode</literal> property on <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> to <literal>VRS_XR</literal>.</paragraph>
            </note>
            <warning>
                <paragraph>This feature is disabled if post effects are used such as glow, bloom, or DOF.</paragraph>
            </warning>
        </section>
        <section ids="foveation-dynamic" names="foveation\ dynamic 动态注视点">
            <title>动态注视点</title>
            <paragraph>When enabled the foveation level will be adjusted automatically depending on current GPU load.
                It will be adjusted between low and the select foveation level in the previous setting.
                It is therefore best to combine this setting with foveation level set to high.</paragraph>
            <note>
                <paragraph><strong>Compatibility renderer only</strong></paragraph>
            </note>
        </section>
        <section ids="submit-depth-buffer" names="submit\ depth\ buffer 提交深度缓冲区">
            <title>提交深度缓冲区</title>
            <paragraph>If enabled an OpenXR supplied depth buffer will be used while rendering which is submitted alongside the rendered image.
                The XR runtime can use this for improved reprojection.</paragraph>
            <note>
                <paragraph>Enabling this feature will disable stencil support during rendering.
                    Not many XR runtimes make use of this,
                    it is advised to leave this setting off unless it provides noticeable benefits for your use case.</paragraph>
            </note>
        </section>
        <section ids="startup-alert" names="startup\ alert 启动警报">
            <title>启动警报</title>
            <paragraph>If enabled, this will result in an alert message presented to the user if OpenXR fails to start.
                We don't always receive feedback from the XR system as to why starting fails. If we do, we log this to the console.
                Common failure reasons are:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>No OpenXR runtime is installed on the host system.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Microsoft's WMR OpenXR runtime is currently active, this only supports DirectX and will fail if OpenGL or Vulkan is used.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>SteamVR is used but no headset is connected/turned on.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Disable this if you support a fallback mode in your game so it can be played in desktop mode when no VR headset is connected,
                or if you're handling the failure condition yourself by checking <literal>OpenXRInterface.is_initialized()</literal>.</paragraph>
        </section>
        <section ids="extensions" names="extensions 拓展选项">
            <title>拓展选项</title>
            <paragraph>This subsection provides access to various optional OpenXR extensions.</paragraph>
            <section ids="hand-tracking" names="hand\ tracking 手部跟踪">
                <title>手部跟踪</title>
                <paragraph>This enables the hand tracking extension when supported by the device used. This is on by default for legacy reasons.
                    The hand tracking extension provides access to data that allows you to visualise the user's hands with correct finger positions.
                    Depending on platform capabilities the hand tracking data can be inferred from controller inputs, come from data gloves,
                    come from optical hand tracking sensors or any other applicable source.</paragraph>
                <paragraph>If your game only supports controllers this should be turned off.</paragraph>
                <paragraph>See the chapter on <reference internal="True" refuri="openxr_hand_tracking#doc-openxr-hand-tracking"><inline classes="std std-ref">hand tracking</inline></reference> for additional details.</paragraph>
            </section>
            <section ids="eye-gaze-interaction" names="eye\ gaze\ interaction 眼动交互">
                <title>眼动交互</title>
                <paragraph>This enables the eye gaze interaction extension when supported by the device used.
                    When enabled we will get feedback from eye tracking through a pose situated between the user's eyes
                    orientated in the direction the user is looking. This will be a unified orientation.</paragraph>
                <paragraph>In order to use this functionality you need to edit your action map and add a new pose action,
                    say <literal>eye_pose</literal>.
                    Now add a new interaction profile for the eye gaze interaction and map the <literal>eye_pose</literal>:</paragraph>
                <image candidates="{'*': 'tutorials/xr/img/openxr_eye_gaze_interaction.webp'}" uri="tutorials/xr/img/openxr_eye_gaze_interaction.webp"></image>
                <paragraph>Don't forget to save!</paragraph>
                <paragraph>Next add a new <reference internal="True" refuri="../../classes/class_xrcontroller3d#class-xrcontroller3d"><inline classes="std std-ref">XRController3D</inline></reference> node to your origin node
                    and set its <literal>tracker</literal> property to <literal>/user/eyes_ext</literal>
                    and set its <literal>pose</literal> property to <literal>eye_pose</literal>.</paragraph>
                <paragraph>Now you can add things to this controller node such as a raycast, and control things with your eyes.</paragraph>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
