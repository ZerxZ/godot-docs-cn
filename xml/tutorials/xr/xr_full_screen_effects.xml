<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/xr/xr_full_screen_effects.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-xr-full-screen-effects"></target>
    <section ids="xr-full-screen-effects doc-xr-full-screen-effects" names="xr\ full\ screen\ effects doc_xr_full_screen_effects">
        <title>XR full screen effects</title>
        <paragraph>When adding custom full screen effects to your XR application, one approach is
            using a full screen quad and applying effects to that quad's shader.
            Add a <reference internal="True" refuri="../../classes/class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> node
            to your scene as a child of your <reference internal="True" refuri="../../classes/class_xrcamera3d#class-xrcamera3d"><inline classes="std std-ref">XRCamera3D</inline></reference>,
            and set the <literal>mesh</literal> property to a <reference internal="True" refuri="../../classes/class_quadmesh#class-quadmesh"><inline classes="std std-ref">QuadMesh</inline></reference>.
            Set the width and height of the quad to <literal>2</literal>.</paragraph>
        <image candidates="{'*': 'tutorials/xr/img/xr_full_screen_effects_starting_quad.webp'}" original_uri="img/xr_full_screen_effects_starting_quad.webp" uri="tutorials/xr/img/xr_full_screen_effects_starting_quad.webp"></image>
        <paragraph>You can then add a shader to your quad to make it cover the screen. This is done by setting the
            vertex shader's <literal>POSITION</literal> built-in to <literal>vec4(VERTEX.xy, 1.0, 1.0)</literal>.
            However, when creating an effect that is centered straight ahead in the user's view
            (such as a vignette effect), the end result may look incorrect in XR.</paragraph>
        <paragraph>Below shows captures of the right-eye view with a vignette shader, both from the headset and the render target itself.
            The left captures are an unmodified shader; the right captures adjust the full screen quad using the projection matrix.
            While the capture on the left is centered in the render target, it is off-center in the headset view.
            But, after applying the projection matrix, we see that the effect is centered in the headset itself.</paragraph>
        <image candidates="{'*': 'tutorials/xr/img/xr_full_screen_effects_vignette_before_after.webp'}" original_uri="img/xr_full_screen_effects_vignette_before_after.webp" uri="tutorials/xr/img/xr_full_screen_effects_vignette_before_after.webp"></image>
        <section ids="applying-the-projection-matrix" names="applying\ the\ projection\ matrix">
            <title>Applying the projection matrix</title>
            <paragraph>To properly center the effect, the <literal>POSITION</literal> of the full screen quad
                needs to take the asymmetric field of view into account. To do this while also ensuring the quad
                has full coverage of the entire render target, we can subdivide the quad and apply the projection matrix
                to the inner vertices. Let's increase the subdivide width and depth of the quad.</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/xr_full_screen_effects_ending_quad.webp'}" original_uri="img/xr_full_screen_effects_ending_quad.webp" uri="tutorials/xr/img/xr_full_screen_effects_ending_quad.webp"></image>
            <paragraph>Then, in the vertex function of our shader, we apply an offset from the projection matrix to
                the inner vertices. Here's an example of how you might do this with the above simple vignette shader:</paragraph>
            <literal_block force="False" highlight_args="{}" language="glsl" linenos="False" xml:space="preserve">shader_type spatial;
render_mode depth_test_disabled, skip_vertex_transform, unshaded, cull_disabled;

// Modify VERTEX.xy using the projection matrix to correctly center the effect.
void vertex() {
        vec2 vert_pos = VERTEX.xy;

        if (length(vert_pos) &lt; 0.99) {
                vec4 offset = PROJECTION_MATRIX * vec4(0.0, 0.0, 1.0, 1.0);
                vert_pos += (offset.xy / offset.w);
        }

        POSITION = vec4(vert_pos, 1.0, 1.0);
}

void fragment() {
        ALBEDO = vec3(0.0);
        ALPHA = dot(UV * 2.0 - 1.0, UV * 2.0 - 1.0) * 2.0;
}</literal_block>
            <note>
                <paragraph>For more info on asymmetric FOV and its purpose, see this
                    <reference name="Meta Asymmetric Field of View FAQ" refuri="https://developers.meta.com/horizon/documentation/unity/unity-asymmetric-fov-faq/">Meta Asymmetric Field of View FAQ</reference><target ids="meta-asymmetric-field-of-view-faq" names="meta\ asymmetric\ field\ of\ view\ faq" refuri="https://developers.meta.com/horizon/documentation/unity/unity-asymmetric-fov-faq/"></target>.</paragraph>
            </note>
        </section>
        <section ids="limitations" names="limitations">
            <title>Limitations</title>
            <paragraph>This full screen effect method has no performance concerns for per-pixel effects such as the above vignette shader.
                However, it is not recommended to read from the screen texture when using this technique.
                Full screen effects that require reading from the screen texture effectively disable all rendering performance optimizations in XR.
                This is because, when reading from the screen texture, Godot makes a full copy of the render buffer;
                this drastically increases the workload for the GPU and can create performance concerns.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
