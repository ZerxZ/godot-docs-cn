<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/xr/setting_up_xr.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-setting-up-xr"></target>
    <section ids="setting-up-xr doc-setting-up-xr" names="setting\ up\ xr 设置\ xr doc_setting_up_xr">
        <title>设置 XR</title>
        <section ids="introduction-to-the-xr-system-in-godot" names="introduction\ to\ the\ xr\ system\ in\ godot godot\ 的\ xr\ 系统简介">
            <title>Godot 的 XR 系统简介</title>
            <paragraph>Godot provides a modular XR system that abstracts many of the different XR platform specifics away from the user.
                At the core sits the <reference internal="True" refuri="../../classes/class_xrserver#class-xrserver"><inline classes="std std-ref">XRServer</inline></reference> which acts as a central interface to the XR system that allows users to discover interfaces and interact with the components of the XR system.</paragraph>
            <paragraph>Each supported XR platform is implemented as an <reference internal="True" refuri="../../classes/class_xrinterface#class-xrinterface"><inline classes="std std-ref">XRInterface</inline></reference>. Supported interfaces register themselves with the <reference internal="True" refuri="../../classes/class_xrserver#class-xrserver"><inline classes="std std-ref">XRServer</inline></reference> and can be queried with the <literal>find_interface</literal> method on the <reference internal="True" refuri="../../classes/class_xrserver#class-xrserver"><inline classes="std std-ref">XRServer</inline></reference>. When the desired interface is found it can be initialized by calling <literal>initialize</literal> on the interface.</paragraph>
            <warning>
                <paragraph>A registered interface means nothing more than that the interface is available, if the interface is not supported by the host system, initialization may fail and return <literal>false</literal>. This can have many reasons and sadly the reasons differ from platform to platform. It can be because the user hasn't installed the required software, or that the user simply hasn't plugged in their headset. You as a developer must thus react properly on an interface failing to initialize.</paragraph>
            </warning>
            <paragraph>Due to the special requirements for output in XR, especially for head mounted devices that supply different images to each eye, the <reference internal="True" refuri="../../classes/class_xrserver#class-xrserver"><inline classes="std std-ref">XRServer</inline></reference> in Godot will override various features in the rendering system. For stand-alone devices this means the final output is handled by the <reference internal="True" refuri="../../classes/class_xrinterface#class-xrinterface"><inline classes="std std-ref">XRInterface</inline></reference> and Godot's usual output system is disabled. For desktop XR devices that work as a second screen it is possible to dedicate a separate <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> to handle the XR output, leaving the main Godot window available for displaying alternative content.</paragraph>
            <note>
                <paragraph>Note that only one interface can be responsible for handling the output to an XR device, this is known as the primary interface and by default will be the first interface that is initialized. Godot currently thus only supports implementations with a single headset.
                    It is possible, but increasingly uncommon, to have a secondary interface, for example to add tracking to an otherwise 3DOF only device.</paragraph>
            </note>
            <paragraph>There are three XR specific node types that you will find in nearly all XR applications:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_xrorigin3d#class-xrorigin3d"><inline classes="std std-ref">XROrigin3D</inline></reference> represents, for all intents and purposes, the center point of your play space. That is an oversimplified statement but we'll go into more detail later. All objects tracked in physical space by the XR platform are positioned in relation to this point.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_xrcamera3d#class-xrcamera3d"><inline classes="std std-ref">XRCamera3D</inline></reference> represents the (stereo) camera that is used when rendering output for the XR device. The positioning of this node is controlled by the XR system and updated automatically using the tracking information provided by the XR platform.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../../classes/class_xrcontroller3d#class-xrcontroller3d"><inline classes="std std-ref">XRController3D</inline></reference> represents a controller used by the player, commonly there are two, one held in each hand. These nodes give access to various states on these controllers and send out signals when the player presses buttons on them. The positioning of this node is controlled by the XR system and updated automatically using the tracking information provided by the XR platform.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>There are other XR related nodes and there is much more to say about these three nodes, but we'll get into that later on.</paragraph>
        </section>
        <section ids="prerequisites-for-xr-in-godot-4" names="prerequisites\ for\ xr\ in\ godot\ 4 godot\ 4\ 中\ xr\ 的先决条件">
            <title>Godot 4 中 XR 的先决条件</title>
            <paragraph>While in Godot 3 most things worked out of the box, Godot 4 needs a little more setup. This is mainly due to the more advanced nature of the Vulkan renderer. There are many rendering features in Vulkan the XR system uses that aren't enabled by default. They are very easy to turn on, simply open up your project settings and tick the XR shaders tickbox in the XR section:</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/xr_shaders.png'}" uri="tutorials/xr/img/xr_shaders.png"></image>
            <warning>
                <paragraph>As Godot 4 is still in development, many post process effects have not yet been updated to support stereoscopic rendering. Using these will have adverse effects.</paragraph>
            </warning>
            <note>
                <paragraph>Godot 4 has 3 renderer options, Compatibility, Mobile, and Forward+. In the future XR desktop projects should use Forward+, and projects for stand-alone headsets
                    should use Mobile. However Compatibility is the recommended renderer for now due to it having the best XR performance.</paragraph>
            </note>
        </section>
        <section ids="openxr" names="openxr">
            <title>OpenXR</title>
            <paragraph>OpenXR is a new industry standard that allows different XR platforms to present themselves through a standardised API to XR applications. This standard is an open standard maintained by the Khronos Group and thus aligns very well with Godot's interests.</paragraph>
            <paragraph>The Vulkan implementation of OpenXR is closely integrated with Vulkan, taking over part of the Vulkan system. This requires tight integration of certain core graphics features in the Vulkan renderer which are needed before the XR system is setup. This was one of the main deciding factors to include OpenXR as a core interface.</paragraph>
            <paragraph>This also means OpenXR needs to be enabled when Godot starts in order to set things up correctly. The required setting can be found in your project settings:</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/openxr_settings.png'}" uri="tutorials/xr/img/openxr_settings.png"></image>
            <paragraph>As setup is brought forward with OpenXR you can find several other settings related to OpenXR here as well. These can't be changed while your application is running.
                The default settings will get us started and we will go into detail in another section of the documentation.</paragraph>
        </section>
        <section ids="setting-up-the-xr-scene" names="setting\ up\ the\ xr\ scene 设置\ xr\ 场景">
            <title>设置 XR 场景</title>
            <paragraph>Every XR application needs at least an <reference internal="True" refuri="../../classes/class_xrorigin3d#class-xrorigin3d"><inline classes="std std-ref">XROrigin3D</inline></reference> and an <reference internal="True" refuri="../../classes/class_xrcamera3d#class-xrcamera3d"><inline classes="std std-ref">XRCamera3D</inline></reference> node. Most will have two <reference internal="True" refuri="../../classes/class_xrcontroller3d#class-xrcontroller3d"><inline classes="std std-ref">XRController3D</inline></reference>, one for the left hand and one for the right. Keep in mind that the camera and controller nodes should be children of the origin node. Add these nodes to a new scene and rename the controller nodes to <literal>LeftHand</literal> and <literal>RightHand</literal>, your scene should look something like this:</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/xr_basic_scene.png'}" uri="tutorials/xr/img/xr_basic_scene.png"></image>
            <paragraph>Next you need to configure the controllers, select the left hand and set it up as follows:</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/xr_left_hand.png'}" uri="tutorials/xr/img/xr_left_hand.png"></image>
            <paragraph>将脚本添加到节点：</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/xr_right_hand.png'}" uri="tutorials/xr/img/xr_right_hand.png"></image>
            <paragraph>Right now all these nodes are on the floor, they will be positioned correctly in runtime. To help during development, it can be helpful to move the camera upwards so its <literal>y</literal> is set to <literal>1.7</literal>, and move the controller nodes to <literal>-0.5, 1.0, -0.5</literal> and <literal>0.5, 1.0, -0.5</literal> for respectively the left and right hand.</paragraph>
            <paragraph>Next we need to add a script to our root node. Add the following code into this script:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node3D

var xr_interface: XRInterface

func _ready():
    xr_interface = XRServer.find_interface("OpenXR")
    if xr_interface and xr_interface.is_initialized():
        print("OpenXR initialized successfully")

        # Turn off v-sync!
        DisplayServer.window_set_vsync_mode(DisplayServer.VSYNC_DISABLED)

        # Change our main viewport to output to the HMD
        get_viewport().use_xr = true
    else:
        print("OpenXR not initialized, please check if your headset is connected")</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode3D : Node3D
{
    private XRInterface _xrInterface;

    public override void _Ready()
    {
        _xrInterface = XRServer.FindInterface("OpenXR");
        if(_xrInterface != null &amp;&amp; _xrInterface.IsInitialized())
        {
            GD.Print("OpenXR initialized successfully");

            // Turn off v-sync!
            DisplayServer.WindowSetVsyncMode(DisplayServer.VSyncMode.Disabled);

            // Change our main viewport to output to the HMD
            GetViewport().UseXR = true;
        }
        else
        {
            GD.Print("OpenXR not initialized, please check if your headset is connected");
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>This code fragment assumes we are using OpenXR, if you wish to use any of the other interfaces you can change the <literal>find_interface</literal> call.</paragraph>
            <warning>
                <paragraph>As you can see in the code snippet above, we turn off v-sync.
                    When using OpenXR you are outputting the rendering results to an HMD that often requires us to run at 90Hz or higher.
                    If your monitor is a 60hz monitor and v-sync is turned on, you will limit the output to 60 frames per second.</paragraph>
                <paragraph>XR interfaces like OpenXR perform their own sync.</paragraph>
                <paragraph>Also note that by default the physics engine runs at 60Hz as well and this can result in choppy physics.
                    You should set <literal>Engine.physics_ticks_per_second</literal> to a higher value.</paragraph>
            </warning>
            <paragraph>If you run your project at this point in time, everything will work but you will be in a dark world. So to finish off our starting point add a <reference internal="True" refuri="../../classes/class_directionallight3d#class-directionallight3d"><inline classes="std std-ref">DirectionalLight3D</inline></reference> and a <reference internal="True" refuri="../../classes/class_worldenvironment#class-worldenvironment"><inline classes="std std-ref">WorldEnvironment</inline></reference> node to your scene.
                You may wish to also add a mesh instance as a child to each controller node just to temporarily visualise them.
                Make sure you configure a sky in your world environment.</paragraph>
            <paragraph>Now run your project, you should be floating somewhere in space and be able to look around.</paragraph>
            <note>
                <paragraph>While traditional level switching can definitely be used with XR applications, where this scene setup is repeated in each level, most find it easier to set this up once and loading levels as a subscene. If you do switch scenes and replicate the XR setup in each one, do make sure you do not run <literal>initialize</literal> multiple times. The effect can be unpredictable depending on the XR interface used.</paragraph>
                <paragraph>For the rest of this basic tutorial series we will create a game that uses a single scene.</paragraph>
            </note>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
