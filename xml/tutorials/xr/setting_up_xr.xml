<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/xr/setting_up_xr.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-setting-up-xr"></target>
    <section ids="setting-up-xr doc-setting-up-xr" names="setting\ up\ xr 设置\ xr doc_setting_up_xr">
        <title>设置 XR</title>
        <section ids="introduction-to-the-xr-system-in-godot" names="introduction\ to\ the\ xr\ system\ in\ godot godot\ 的\ xr\ 系统简介">
            <title>Godot 的 XR 系统简介</title>
            <paragraph>Godot provides a modular XR system that abstracts many of the different XR platform specifics away from the user.
                At the core sits the <reference internal="True" refuri="../../classes/class_xrserver#class-xrserver"><inline classes="std std-ref">XRServer</inline></reference> which acts as a central interface to the XR system that allows users to discover interfaces and interact with the components of the XR system.</paragraph>
            <paragraph>Each supported XR platform is implemented as an <reference internal="True" refuri="../../classes/class_xrinterface#class-xrinterface"><inline classes="std std-ref">XRInterface</inline></reference>. Supported interfaces register themselves with the <reference internal="True" refuri="../../classes/class_xrserver#class-xrserver"><inline classes="std std-ref">XRServer</inline></reference> and can be queried with the <literal>find_interface</literal> method on the <reference internal="True" refuri="../../classes/class_xrserver#class-xrserver"><inline classes="std std-ref">XRServer</inline></reference>. When the desired interface is found it can be initialized by calling <literal>initialize</literal> on the interface.</paragraph>
            <warning>
                <paragraph>A registered interface means nothing more than that the interface is available, if the interface is not supported by the host system, initialization may fail and return <literal>false</literal>. This can have many reasons and sadly the reasons differ from platform to platform. It can be because the user hasn't installed the required software, or that the user simply hasn't plugged in their headset. You as a developer must thus react properly on an interface failing to initialize.</paragraph>
            </warning>
            <paragraph>Due to the special requirements for output in XR, especially for head mounted devices that supply different images to each eye, the <reference internal="True" refuri="../../classes/class_xrserver#class-xrserver"><inline classes="std std-ref">XRServer</inline></reference> in Godot will override various features in the rendering system. For stand-alone devices this means the final output is handled by the <reference internal="True" refuri="../../classes/class_xrinterface#class-xrinterface"><inline classes="std std-ref">XRInterface</inline></reference> and Godot's usual output system is disabled. For desktop XR devices that work as a second screen it is possible to dedicate a separate <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> to handle the XR output, leaving the main Godot window available for displaying alternative content.</paragraph>
            <note>
                <paragraph>Note that only one interface can be responsible for handling the output to an XR device, this is known as the primary interface and by default will be the first interface that is initialized. Godot currently thus only supports implementations with a single headset.
                    It is possible, but increasingly uncommon, to have a secondary interface, for example to add tracking to an otherwise 3DOF only device.</paragraph>
            </note>
            <paragraph>There are three XR specific node types that you will find in nearly all XR applications:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>:ref:<problematic ids="id2" refid="id1">`</problematic>XROrigin3D &lt;class_xrorigin3d&gt;`代表着游戏空间的中心点。这种说法易于理解，但有些过于简化，我们稍后会详细解释。XR 平台跟踪的所有物体都是相对于这一点定位的。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>:ref:<problematic ids="id2" refid="id1">`</problematic>XRCamera3D &lt;class_xrcamera3d&gt;`代表着在为 XR 设备渲染输出时使用的（立体）摄像机。该节点的定位由 XR 系统控制，并基于 XR 平台提供的跟踪信息自动更新。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>:ref:<problematic ids="id2" refid="id1">`</problematic>XRController3D &lt;class_xrcontroller3d&gt;`代表玩家使用的控制器，通常有两个：左右手各一个。该节点提供对控制器上各种状态的访问，并在玩家按下按钮时发送信号。节点的定位由 XR 系统控制，并基于 XR 平台提供的跟踪信息自动更新。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>There are other XR related nodes and there is much more to say about these three nodes, but we'll get into that later on.</paragraph>
        </section>
        <section ids="prerequisites-for-xr-in-godot-4" names="prerequisites\ for\ xr\ in\ godot\ 4 在\ godot\ 4\ 中使用\ xr\ 的先决条件">
            <title>在 Godot 4 中使用 XR 的先决条件</title>
            <paragraph>While in Godot 3 most things worked out of the box, Godot 4 needs a little more setup. This is mainly due to the more advanced nature of the Vulkan renderer. There are many rendering features in Vulkan the XR system uses that aren't enabled by default. They are very easy to turn on, simply open up your project settings and tick the XR shaders tickbox in the XR section:</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/xr_shaders.png'}" uri="tutorials/xr/img/xr_shaders.png"></image>
            <warning>
                <paragraph>由于 Godot 4 仍在开发中，许多后期处理效果尚未更新以支持立体渲染。使用这些效果将产生不良影响。</paragraph>
            </warning>
            <note>
                <paragraph>Godot 4 has 3 renderer options, Compatibility, Mobile, and Forward+. In the future XR desktop projects should use Forward+, and projects for stand-alone headsets
                    should use Mobile. However Compatibility is the recommended renderer for now due to it having the best XR performance.</paragraph>
            </note>
        </section>
        <section ids="openxr" names="openxr">
            <title>OpenXR</title>
            <paragraph>OpenXR is a new industry standard that allows different XR platforms to present themselves through a standardised API to XR applications. This standard is an open standard maintained by the Khronos Group and thus aligns very well with Godot's interests.</paragraph>
            <paragraph>OpenXR 的 Vulkan 实现与 Vulkan 紧密集成，并接管了 Vulkan 系统的一部分。这就要求在设置 XR 系统之前，需要对 Vulkan 渲染器中的某些核心图形功能先行集成。这是将 OpenXR 包含为核心接口的主要决定因素之一。</paragraph>
            <paragraph>这也意味着需要在 Godot 启动时启用 OpenXR，以便正确设置。启动页面可在项目设置中找到：</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/openxr_settings.png'}" uri="tutorials/xr/img/openxr_settings.png"></image>
            <paragraph>你还可以在这里找到与 OpenXR 相关的其他设置。这些设置在应用程序运行时无法更改。默认设置即可让我们开始工作，并且我们将在文档的另一部分详细介绍这些设置。</paragraph>
        </section>
        <section ids="setting-up-the-xr-scene" names="setting\ up\ the\ xr\ scene 设置\ xr\ 场景">
            <title>设置 XR 场景</title>
            <paragraph>Every XR application needs at least an <reference internal="True" refuri="../../classes/class_xrorigin3d#class-xrorigin3d"><inline classes="std std-ref">XROrigin3D</inline></reference> and an <reference internal="True" refuri="../../classes/class_xrcamera3d#class-xrcamera3d"><inline classes="std std-ref">XRCamera3D</inline></reference> node. Most will have two <reference internal="True" refuri="../../classes/class_xrcontroller3d#class-xrcontroller3d"><inline classes="std std-ref">XRController3D</inline></reference>, one for the left hand and one for the right. Keep in mind that the camera and controller nodes should be children of the origin node. Add these nodes to a new scene and rename the controller nodes to <literal>LeftHand</literal> and <literal>RightHand</literal>, your scene should look something like this:</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/xr_basic_scene.png'}" uri="tutorials/xr/img/xr_basic_scene.png"></image>
            <paragraph>接下来，你需要配置控制器。选择左手控制器，并按如下方式进行设置：</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/xr_left_hand.png'}" uri="tutorials/xr/img/xr_left_hand.png"></image>
            <paragraph>将脚本添加到节点：</paragraph>
            <image candidates="{'*': 'tutorials/xr/img/xr_right_hand.png'}" uri="tutorials/xr/img/xr_right_hand.png"></image>
            <paragraph>现在，所有节点都在场景的平面上，它们将在运行时自动正确定位。为了帮助开发期间的调试，可以将相机向上移动，再把 <literal>y</literal> 轴设置为 <literal>1.7</literal>，并将控制器节点分别移动到 <problematic ids="id2" refid="id1">``</problematic>-0.5, 1.0, -0.5``（左手）和 <problematic ids="id4" refid="id3">``</problematic>0.5, 1.0, -0.5``（右手）。</paragraph>
            <paragraph>Next we need to add a script to our root node. Add the following code into this script:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node3D

var xr_interface: XRInterface

func _ready():
    xr_interface = XRServer.find_interface("OpenXR")
    if xr_interface and xr_interface.is_initialized():
        print("OpenXR initialized successfully")

        # Turn off v-sync!
        DisplayServer.window_set_vsync_mode(DisplayServer.VSYNC_DISABLED)

        # Change our main viewport to output to the HMD
        get_viewport().use_xr = true
    else:
        print("OpenXR not initialized, please check if your headset is connected")</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode3D : Node3D
{
    private XRInterface _xrInterface;

    public override void _Ready()
    {
        _xrInterface = XRServer.FindInterface("OpenXR");
        if(_xrInterface != null &amp;&amp; _xrInterface.IsInitialized())
        {
            GD.Print("OpenXR initialized successfully");

            // Turn off v-sync!
            DisplayServer.WindowSetVsyncMode(DisplayServer.VSyncMode.Disabled);

            // Change our main viewport to output to the HMD
            GetViewport().UseXR = true;
        }
        else
        {
            GD.Print("OpenXR not initialized, please check if your headset is connected");
        }
    }
}</literal_block>
                </div>
            </container>
            <paragraph>上述代码片段假设我们正在使用 OpenXR，如果你希望使用其他接口，可以更改``find_interface`` 调用。</paragraph>
            <warning>
                <paragraph>正如你看到的，我们在代码中关闭了垂直同步（DisplayServer.VSYNC_DISABLED）。在使用 OpenXR 时，将渲染结果输出到一个头戴显示器（HMD）通常需要以 90Hz 或更高的频率运行。如果你的显示器是 60Hz 且开启了垂直同步，那么输出将限制在每秒 60 帧。</paragraph>
                <paragraph>像 OpenXR 这样的 XR 接口会执行它们自己的同步。</paragraph>
                <paragraph>同时请注意，默认情况下物理引擎以 60Hz 运行，渲染和物理帧数不一致可能会导致物理效果不流畅。你应该将 <literal>Engine.physics_ticks_per_second</literal> 设置为更高的值。</paragraph>
            </warning>
            <paragraph>If you run your project at this point in time, everything will work but you will be in a dark world. So to finish off our starting point add a <reference internal="True" refuri="../../classes/class_directionallight3d#class-directionallight3d"><inline classes="std std-ref">DirectionalLight3D</inline></reference> and a <reference internal="True" refuri="../../classes/class_worldenvironment#class-worldenvironment"><inline classes="std std-ref">WorldEnvironment</inline></reference> node to your scene.
                You may wish to also add a mesh instance as a child to each controller node just to temporarily visualise them.
                Make sure you configure a sky in your world environment.</paragraph>
            <paragraph>完成配置后运行项目，你应该会漂浮在某个空间中，并能够四处观察。</paragraph>
            <note>
                <paragraph>While traditional level switching can definitely be used with XR applications, where this scene setup is repeated in each level, most find it easier to set this up once and loading levels as a subscene. If you do switch scenes and replicate the XR setup in each one, do make sure you do not run <literal>initialize</literal> multiple times. The effect can be unpredictable depending on the XR interface used.</paragraph>
                <paragraph>在接下来的基础教程中，我们将创建一个只使用单场景的游戏作为练习。</paragraph>
            </note>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
