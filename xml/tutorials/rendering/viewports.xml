<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/rendering/viewports.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-viewports"></target>
    <section ids="using-viewports doc-viewports" names="using\ viewports doc_viewports">
        <title>Using Viewports</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>Think of a <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> as a screen onto which the game is projected. In order
                to see the game, we need to have a surface on which to draw it. That surface is
                the Root Viewport.</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/subviewportnode.webp'}" original_uri="img/subviewportnode.webp" uri="tutorials/rendering/img/subviewportnode.webp"></image>
            <paragraph><reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewports</inline></reference> are a kind of Viewport that can be added to the scene so that there
                are multiple surfaces to draw on. When we are drawing to a SubViewport, we call it a render target. We can access the contents
                of a render target by accessing its corresponding <reference internal="True" refuri="../../classes/class_viewport#class-viewport-method-get-texture"><inline classes="std std-ref">texture</inline></reference>.
                By using a SubViewport as render target, we can either render multiple scenes simultaneously or we can render to
                a <reference internal="True" refuri="../../classes/class_viewporttexture#class-viewporttexture"><inline classes="std std-ref">ViewportTexture</inline></reference> which is applied to an object in the scene, for example a dynamic
                skybox.</paragraph>
            <paragraph><reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewports</inline></reference> have a variety of use cases, including:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Rendering 3D objects within a 2D game</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Rendering 2D elements in a 3D game</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Rendering dynamic textures</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Generating procedural textures at runtime</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Rendering multiple cameras in the same scene</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>What all these use cases have in common is that you are given the ability to
                draw objects to a texture as if it were another screen and can then choose
                what to do with the resulting texture.</paragraph>
            <paragraph>Another kind of Viewports in Godot are <reference internal="True" refuri="../../classes/class_window#class-window"><inline classes="std std-ref">Windows</inline></reference>. They allow their content to be projected onto a window. While the Root Viewport is a Window, they are less
                flexible. If you want to use the texture of a Viewport, you'll be working with <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewports</inline></reference> most of the time.</paragraph>
        </section>
        <section ids="input" names="input">
            <title>Input</title>
            <paragraph><reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewports</inline></reference> are also responsible for delivering properly adjusted and
                scaled input events to their children nodes. By default <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewports</inline></reference> don't
                automatically receive input, unless they receive it from their direct
                <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainer</inline></reference> parent node. In this case, input can be
                disabled with the <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-gui-disable-input"><inline classes="std std-ref">Disable Input</inline></reference> property.</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/input.webp'}" original_uri="img/input.webp" uri="tutorials/rendering/img/input.webp"></image>
            <paragraph>For more information on how Godot handles input, please read the <reference internal="True" refuri="../inputs/inputevent#doc-inputevent"><inline classes="std std-ref">Input Event Tutorial</inline></reference>.</paragraph>
        </section>
        <section ids="listener" names="listener">
            <title>Listener</title>
            <paragraph>Godot supports 3D sound (in both 2D and 3D nodes). More on this can be
                found in the <reference internal="True" refuri="../audio/audio_streams#doc-audio-streams"><inline classes="std std-ref">Audio Streams Tutorial</inline></reference>. For this type of sound to be
                audible, the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> needs to be enabled as a listener (for 2D or 3D).
                If you are using a <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> to display your <reference internal="True" refuri="../../classes/class_world3d#class-world3d"><inline classes="std std-ref">World3D</inline></reference> or
                <reference internal="True" refuri="../../classes/class_world2d#class-world2d"><inline classes="std std-ref">World2D</inline></reference>, don't forget to enable this!</paragraph>
        </section>
        <section ids="cameras-2d-3d" names="cameras\ (2d\ &amp;\ 3d)">
            <title>Cameras (2D &amp; 3D)</title>
            <paragraph>When using a <reference internal="True" refuri="../../classes/class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference> or
                <reference internal="True" refuri="../../classes/class_camera2d#class-camera2d"><inline classes="std std-ref">Camera2D</inline></reference>, it will always display on the
                closest parent <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> (going towards the root). For example, in the
                following hierarchy:</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/cameras.webp'}" original_uri="img/cameras.webp" uri="tutorials/rendering/img/cameras.webp"></image>
            <paragraph><literal>CameraA</literal> will display on the Root <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> and it will draw <literal>MeshA</literal>. <literal>CameraB</literal>
                will be captured by the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> along with <literal>MeshB</literal>. Even though <literal>MeshB</literal> is in the scene
                hierarchy, it will still not be drawn to the Root Viewport. Similarly, <literal>MeshA</literal> will not
                be visible from the SubViewport because SubViewports only
                capture nodes below them in the hierarchy.</paragraph>
            <paragraph>There can only be one active camera per <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>, so if there is more
                than one, make sure that the desired one has the <reference internal="True" refuri="../../classes/class_camera3d#class-camera3d-property-current"><inline classes="std std-ref">current</inline></reference> property set,
                or make it the current camera by calling:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">camera.make_current()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">camera.MakeCurrent();</literal_block>
                </div>
            </container>
            <paragraph>By default, cameras will render all objects in their world. In 3D, cameras can use their
                <reference internal="True" refuri="../../classes/class_camera3d#class-camera3d-property-cull-mask"><inline classes="std std-ref">cull_mask</inline></reference> property combined with the
                <reference internal="True" refuri="../../classes/class_visualinstance3d#class-visualinstance3d"><inline classes="std std-ref">VisualInstance3D's</inline></reference> <reference internal="True" refuri="../../classes/class_visualinstance3d#class-visualinstance3d-property-layers"><inline classes="std std-ref">layer</inline></reference>
                property to restrict which objects are rendered.</paragraph>
        </section>
        <section ids="scale-stretching" names="scale\ &amp;\ stretching">
            <title>Scale &amp; stretching</title>
            <paragraph><reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewports</inline></reference> have a <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport-property-size"><inline classes="std std-ref">size</inline></reference> property, which represents the size of the SubViewport
                in pixels. For SubViewports which are children of <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainers</inline></reference>,
                these values are overridden, but for all others, this sets their resolution.</paragraph>
            <paragraph>It is also possible to scale the 2D content and make the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> resolution
                different from the one specified in size, by calling:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">sub_viewport.set_size_2d_override(Vector2i(width, height)) # Custom size for 2D.
sub_viewport.set_size_2d_override_stretch(true) # Enable stretch for custom size.</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">subViewport.Size2DOverride = new Vector2I(width, height); // Custom size for 2D.
subViewport.Size2DOverrideStretch = true; // Enable stretch for custom size.</literal_block>
                </div>
            </container>
            <paragraph>For information on scaling and stretching with the Root Viewport visit the <reference internal="True" refuri="multiple_resolutions#doc-multiple-resolutions"><inline classes="std std-ref">Multiple Resolutions Tutorial</inline></reference></paragraph>
        </section>
        <section ids="worlds" names="worlds">
            <title>Worlds</title>
            <paragraph>For 3D, a <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> will contain a <reference internal="True" refuri="../../classes/class_world3d#class-world3d"><inline classes="std std-ref">World3D</inline></reference>. This
                is basically the universe that links physics and rendering together.
                Node3D-based nodes will register using the World3D of the closest Viewport.
                By default, newly created Viewports do not contain a World3D but
                use the same as their parent Viewport. The Root Viewport always contains a
                World3D, which is the one objects are rendered to by default.</paragraph>
            <paragraph>A <reference internal="True" refuri="../../classes/class_world3d#class-world3d"><inline classes="std std-ref">World3D</inline></reference> can
                be set in a <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> using the <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-world-3d"><inline classes="std std-ref">World 3D</inline></reference> property, that will separate
                all children nodes of this <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> and will prevent them from interacting with the parent
                Viewport's World3D. This is especially useful in scenarios where, for
                example, you might want to show a separate character in 3D imposed over
                the game (like in StarCraft).</paragraph>
            <paragraph>As a helper for situations where you want to create <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewports</inline></reference> that
                display single objects and don't want to create a <reference internal="True" refuri="../../classes/class_world3d#class-world3d"><inline classes="std std-ref">World3D</inline></reference>, Viewport has
                the option to use its <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-own-world-3d"><inline classes="std std-ref">Own World3D</inline></reference>. This is useful when you want to
                instance 3D characters or objects in <reference internal="True" refuri="../../classes/class_world2d#class-world2d"><inline classes="std std-ref">World2D</inline></reference>.</paragraph>
            <paragraph>For 2D, each <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> always contains its own <reference internal="True" refuri="../../classes/class_world2d#class-world2d"><inline classes="std std-ref">World2D</inline></reference>.
                This suffices in most cases, but in case sharing them may be desired, it
                is possible to do so by setting <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-world-2d"><inline classes="std std-ref">world_2d</inline></reference> on the Viewport through code.</paragraph>
            <paragraph>For an example of how this works, see the demo projects <reference name="3D in 2D" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d">3D in 2D</reference><target ids="d-in-2d" names="3d\ in\ 2d" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d"></target> and <reference name="2D in 3D" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/viewport/2d_in_3d">2D in 3D</reference><target ids="d-in-3d" names="2d\ in\ 3d" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/viewport/2d_in_3d"></target> respectively.</paragraph>
        </section>
        <section ids="capture" names="capture">
            <title>Capture</title>
            <paragraph>It is possible to query a capture of the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> contents. For the Root
                Viewport, this is effectively a screen capture. This is done with the
                following code:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Retrieve the captured Image using get_image().
var img = get_viewport().get_texture().get_image()
# Convert Image to ImageTexture.
var tex = ImageTexture.create_from_image(img)
# Set sprite texture.
sprite.texture = tex</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Retrieve the captured Image using get_image().
var img = GetViewport().GetTexture().GetImage();
// Convert Image to ImageTexture.
var tex = ImageTexture.CreateFromImage(img);
// Set sprite texture.
sprite.Texture = tex;</literal_block>
                </div>
            </container>
            <paragraph>But if you use this in <literal>_ready()</literal> or from the first frame of the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport's</inline></reference> initialization,
                you will get an empty texture because there is nothing to get as texture. You can deal with
                it using (for example):</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Wait until the frame has finished before getting the texture.
await RenderingServer.frame_post_draw
# You can get the image after this.</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Wait until the frame has finished before getting the texture.
await ToSignal(RenderingServer.Singleton, RenderingServer.SignalName.FramePostDraw);
// You can get the image after this.</literal_block>
                </div>
            </container>
        </section>
        <section ids="viewport-container" names="viewport\ container">
            <title>Viewport Container</title>
            <paragraph>If the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> is a child of a <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainer</inline></reference>, it will become active and display anything it has inside. The layout looks like this:</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/container.webp'}" original_uri="img/container.webp" uri="tutorials/rendering/img/container.webp"></image>
            <paragraph>The <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> will cover the area of its parent <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainer</inline></reference> completely
                if <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer-property-stretch"><inline classes="std std-ref">Stretch</inline></reference> is set to <literal>true</literal> in the SubViewportContainer.</paragraph>
            <note>
                <paragraph>The size of the <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainer</inline></reference> cannot be smaller than the size of the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>.</paragraph>
            </note>
        </section>
        <section ids="rendering" names="rendering">
            <title>Rendering</title>
            <paragraph>Due to the fact that the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> is an entryway into another rendering surface, it exposes a few
                rendering properties that can be different from the project settings. You can
                choose to use a different level of <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-msaa-2d"><inline classes="std std-ref">MSAA</inline></reference> for each Viewport. The default behavior is <literal>Disabled</literal>.</paragraph>
            <paragraph>If you know that the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> is only going to be used for 2D, you can <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-disable-3d"><inline classes="std std-ref">Disable 3D</inline></reference>. Godot will then
                restrict how the Viewport is drawn.
                Disabling 3D is slightly faster and uses less memory compared to enabled 3D. It's a good idea to disable 3D if your viewport doesn't render anything in 3D.</paragraph>
            <note>
                <paragraph>If you need to render 3D shadows in the viewport, make sure to set the viewport's <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-positional-shadow-atlas-size"><inline classes="std std-ref">positional_shadow_atlas_size</inline></reference> property to a value higher than <literal>0</literal>.
                    Otherwise, shadows won't be rendered. By default, the equivalent project setting is set to <literal>4096</literal> on desktop platforms and <literal>2048</literal> on mobile platforms.</paragraph>
            </note>
            <paragraph>Godot also provides a way of customizing how everything is drawn inside <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewports</inline></reference> using <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-debug-draw"><inline classes="std std-ref">Debug Draw</inline></reference>.
                Debug Draw allows you to specify a mode which determines how the Viewport will display things drawn
                inside it. Debug Draw is <literal>Disabled</literal> by default. Some other options are <literal>Unshaded</literal>, <literal>Overdraw</literal>, and <literal>Wireframe</literal>. For a full list, refer to the <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-debug-draw"><inline classes="std std-ref">Viewport Documentation</inline></reference>.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Debug Draw = Disabled</strong> (default): The scene is drawn normally.</paragraph>
                </list_item>
            </bullet_list>
            <block_quote>
                <image candidates="{'*': 'tutorials/rendering/img/default_scene.webp'}" original_uri="img/default_scene.webp" uri="tutorials/rendering/img/default_scene.webp"></image>
            </block_quote>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Debug Draw = Unshaded</strong>: Unshaded draws the scene without using lighting information so all the objects appear flatly colored in their albedo color.</paragraph>
                </list_item>
            </bullet_list>
            <block_quote>
                <image candidates="{'*': 'tutorials/rendering/img/unshaded.webp'}" original_uri="img/unshaded.webp" uri="tutorials/rendering/img/unshaded.webp"></image>
            </block_quote>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Debug Draw = Overdraw</strong>: Overdraw draws the meshes semi-transparent with an additive blend so you can see how the meshes overlap.</paragraph>
                </list_item>
            </bullet_list>
            <block_quote>
                <image candidates="{'*': 'tutorials/rendering/img/overdraw.webp'}" original_uri="img/overdraw.webp" uri="tutorials/rendering/img/overdraw.webp"></image>
            </block_quote>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Debug Draw = Wireframe</strong>: Wireframe draws the scene using only the edges of triangles in the meshes.</paragraph>
                </list_item>
            </bullet_list>
            <block_quote>
                <image candidates="{'*': 'tutorials/rendering/img/wireframe.webp'}" original_uri="img/wireframe.webp" uri="tutorials/rendering/img/wireframe.webp"></image>
            </block_quote>
            <note>
                <paragraph>Debug Draw modes are currently <strong>not</strong> supported when using the
                    Compatibility rendering method. They will appear as regular draw modes.</paragraph>
            </note>
        </section>
        <section ids="render-target" names="render\ target">
            <title>Render target</title>
            <paragraph>When rendering to a <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>, whatever is inside will not be
                visible in the scene editor. To display the contents, you have to draw the SubViewport's <reference internal="True" refuri="../../classes/class_viewporttexture#class-viewporttexture"><inline classes="std std-ref">ViewportTexture</inline></reference> somewhere.
                This can be requested via code using (for example):</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># This gives us the ViewportTexture.
var tex = viewport.get_texture()
sprite.texture = tex</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// This gives us the ViewportTexture.
var tex = viewport.GetTexture();
sprite.Texture = tex;</literal_block>
                </div>
            </container>
            <paragraph>Or it can be assigned in the editor by selecting "New ViewportTexture"</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/texturemenu.webp'}" original_uri="img/texturemenu.webp" uri="tutorials/rendering/img/texturemenu.webp"></image>
            <paragraph>and then selecting the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> you want to use.</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/texturepath.webp'}" original_uri="img/texturepath.webp" uri="tutorials/rendering/img/texturepath.webp"></image>
            <paragraph>Every frame, the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport's</inline></reference> texture is cleared away with the default clear color (or a transparent
                color if <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-transparent-bg"><inline classes="std std-ref">Transparent BG</inline></reference> is set to <literal>true</literal>). This can be changed by setting <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport-property-render-target-clear-mode"><inline classes="std std-ref">Clear Mode</inline></reference> to <literal>Never</literal> or <literal>Next Frame</literal>.
                As the name implies, Never means the texture will never be cleared, while next frame will
                clear the texture on the next frame and then set itself to Never.</paragraph>
            <paragraph>By default, re-rendering of the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> happens when
                its <reference internal="True" refuri="../../classes/class_viewporttexture#class-viewporttexture"><inline classes="std std-ref">ViewportTexture</inline></reference> has been drawn in a frame. If visible, it will be
                rendered, otherwise, it will not. This behavior can be changed by setting <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport-property-render-target-update-mode"><inline classes="std std-ref">Update Mode</inline></reference> to <literal>Never</literal>, <literal>Once</literal>, <literal>Always</literal>, or <literal>When Parent Visible</literal>.
                Never and Always will never or always re-render respectively. Once will re-render the next frame and change to Never afterwards. This can be used to manually update the Viewport.
                This flexibility allows users to render an image once and then use the texture without incurring the cost of rendering every frame.</paragraph>
            <note>
                <paragraph>Make sure to check the Viewport demos. They are available in the
                    viewport folder of the demos archive, or at
                    <reference refuri="https://github.com/godotengine/godot-demo-projects/tree/master/viewport">https://github.com/godotengine/godot-demo-projects/tree/master/viewport</reference>.</paragraph>
            </note>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
