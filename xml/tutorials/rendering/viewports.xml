<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/rendering/viewports.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-viewports"></target>
    <section ids="using-viewports doc-viewports" names="using\ viewports 使用\ viewport doc_viewports">
        <title>使用 Viewport</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>Think of a <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> as a screen onto which the game is projected. In order
                to see the game, we need to have a surface on which to draw it. That surface is
                the Root Viewport.</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/subviewportnode.webp'}" uri="tutorials/rendering/img/subviewportnode.webp"></image>
            <paragraph><reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewports</inline></reference> are a kind of Viewport that can be added to the scene so that there
                are multiple surfaces to draw on. When we are drawing to a SubViewport, we call it a render target. We can access the contents
                of a render target by accessing its corresponding <reference internal="True" refuri="../../classes/class_viewport#class-viewport-method-get-texture"><inline classes="std std-ref">texture</inline></reference>.
                By using a SubViewport as render target, we can either render multiple scenes simultaneously or we can render to
                a <reference internal="True" refuri="../../classes/class_viewporttexture#class-viewporttexture"><inline classes="std std-ref">ViewportTexture</inline></reference> which is applied to an object in the scene, for example a dynamic
                skybox.</paragraph>
            <paragraph><reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewports</inline></reference> have a variety of use cases, including:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>在2D游戏中渲染3D物体</paragraph>
                </list_item>
                <list_item>
                    <paragraph>在3D游戏中渲染2D元素</paragraph>
                </list_item>
                <list_item>
                    <paragraph>渲染动态纹理</paragraph>
                </list_item>
                <list_item>
                    <paragraph>在运行时生成程序式纹理</paragraph>
                </list_item>
                <list_item>
                    <paragraph>在同一场景中渲染多个摄像机</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>所有这些用例的共同点是, 你被赋予了在纹理上绘制物体的能力, 就好像它是另一个屏幕一样, 然后可以选择如何处理产生的纹理.</paragraph>
            <paragraph>Another kind of Viewports in Godot are <reference internal="True" refuri="../../classes/class_window#class-window"><inline classes="std std-ref">Windows</inline></reference>. They allow their content to be projected onto a window. While the Root Viewport is a Window, they are less
                flexible. If you want to use the texture of a Viewport, you'll be working with <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewports</inline></reference> most of the time.</paragraph>
        </section>
        <section ids="input" names="input 输入">
            <title>输入</title>
            <paragraph><reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewports</inline></reference> are also responsible for delivering properly adjusted and
                scaled input events to their children nodes. By default <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewports</inline></reference> don't
                automatically receive input, unless they receive it from their direct
                <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainer</inline></reference> parent node. In this case, input can be
                disabled with the <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-gui-disable-input"><inline classes="std std-ref">Disable Input</inline></reference> property.</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/input.webp'}" uri="tutorials/rendering/img/input.webp"></image>
            <paragraph>For more information on how Godot handles input, please read the <reference internal="True" refuri="../inputs/inputevent#doc-inputevent"><inline classes="std std-ref">Input Event Tutorial</inline></reference>.</paragraph>
        </section>
        <section ids="listener" names="listener">
            <title>Listener</title>
            <paragraph>Godot supports 3D sound (in both 2D and 3D nodes). More on this can be
                found in the <reference internal="True" refuri="../audio/audio_streams#doc-audio-streams"><inline classes="std std-ref">Audio Streams Tutorial</inline></reference>. For this type of sound to be
                audible, the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> needs to be enabled as a listener (for 2D or 3D).
                If you are using a <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> to display your <reference internal="True" refuri="../../classes/class_world3d#class-world3d"><inline classes="std std-ref">World3D</inline></reference> or
                <reference internal="True" refuri="../../classes/class_world2d#class-world2d"><inline classes="std std-ref">World2D</inline></reference>, don't forget to enable this!</paragraph>
        </section>
        <section ids="cameras-2d-3d" names="cameras\ (2d\ &amp;\ 3d) 摄像机（2d\ 和\ 3d）">
            <title>摄像机（2D 和 3D）</title>
            <paragraph>When using a <reference internal="True" refuri="../../classes/class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference> or
                <reference internal="True" refuri="../../classes/class_camera2d#class-camera2d"><inline classes="std std-ref">Camera2D</inline></reference>, it will always display on the
                closest parent <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> (going towards the root). For example, in the
                following hierarchy:</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/cameras.webp'}" uri="tutorials/rendering/img/cameras.webp"></image>
            <paragraph><literal>CameraA</literal> will display on the Root <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> and it will draw <literal>MeshA</literal>. <literal>CameraB</literal>
                will be captured by the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> along with <literal>MeshB</literal>. Even though <literal>MeshB</literal> is in the scene
                hierarchy, it will still not be drawn to the Root Viewport. Similarly, <literal>MeshA</literal> will not
                be visible from the SubViewport because SubViewports only
                capture nodes below them in the hierarchy.</paragraph>
            <paragraph>There can only be one active camera per <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>, so if there is more
                than one, make sure that the desired one has the <reference internal="True" refuri="../../classes/class_camera3d#class-camera3d-property-current"><inline classes="std std-ref">current</inline></reference> property set,
                or make it the current camera by calling:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">camera.make_current()</literal_block>
            <paragraph>By default, cameras will render all objects in their world. In 3D, cameras can use their
                <reference internal="True" refuri="../../classes/class_camera3d#class-camera3d-property-cull-mask"><inline classes="std std-ref">cull_mask</inline></reference> property combined with the
                <reference internal="True" refuri="../../classes/class_visualinstance3d#class-visualinstance3d"><inline classes="std std-ref">VisualInstance3D's</inline></reference> <reference internal="True" refuri="../../classes/class_visualinstance3d#class-visualinstance3d-property-layers"><inline classes="std std-ref">layer</inline></reference>
                property to restrict which objects are rendered.</paragraph>
        </section>
        <section ids="scale-stretching" names="scale\ &amp;\ stretching 缩放和拉伸">
            <title>缩放和拉伸</title>
            <paragraph><reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewports</inline></reference> have a <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport-property-size"><inline classes="std std-ref">size</inline></reference> property, which represents the size of the SubViewport
                in pixels. For SubViewports which are children of <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainers</inline></reference>,
                these values are overridden, but for all others, this sets their resolution.</paragraph>
            <paragraph>It is also possible to scale the 2D content and make the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> resolution
                different from the one specified in size, by calling:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">sub_viewport.set_size_2d_override(Vector2i(width, height)) # Custom size for 2D.
sub_viewport.set_size_2d_override_stretch(true) # Enable stretch for custom size.</literal_block>
            <paragraph>For information on scaling and stretching with the Root Viewport visit the <reference internal="True" refuri="multiple_resolutions#doc-multiple-resolutions"><inline classes="std std-ref">Multiple Resolutions Tutorial</inline></reference></paragraph>
        </section>
        <section ids="worlds" names="worlds 世界">
            <title>世界</title>
            <paragraph>For 3D, a <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> will contain a <reference internal="True" refuri="../../classes/class_world3d#class-world3d"><inline classes="std std-ref">World3D</inline></reference>. This
                is basically the universe that links physics and rendering together.
                Node3D-based nodes will register using the World3D of the closest Viewport.
                By default, newly created Viewports do not contain a World3D but
                use the same as their parent Viewport. The Root Viewport always contains a
                World3D, which is the one objects are rendered to by default.</paragraph>
            <paragraph>A <reference internal="True" refuri="../../classes/class_world3d#class-world3d"><inline classes="std std-ref">World3D</inline></reference> can
                be set in a <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> using the <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-world-3d"><inline classes="std std-ref">World 3D</inline></reference> property, that will separate
                all children nodes of this <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> and will prevent them from interacting with the parent
                Viewport's World3D. This is especially useful in scenarios where, for
                example, you might want to show a separate character in 3D imposed over
                the game (like in StarCraft).</paragraph>
            <paragraph>As a helper for situations where you want to create <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewports</inline></reference> that
                display single objects and don't want to create a <reference internal="True" refuri="../../classes/class_world3d#class-world3d"><inline classes="std std-ref">World3D</inline></reference>, Viewport has
                the option to use its <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-own-world-3d"><inline classes="std std-ref">Own World3D</inline></reference>. This is useful when you want to
                instance 3D characters or objects in <reference internal="True" refuri="../../classes/class_world2d#class-world2d"><inline classes="std std-ref">World2D</inline></reference>.</paragraph>
            <paragraph>For 2D, each <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> always contains its own <reference internal="True" refuri="../../classes/class_world2d#class-world2d"><inline classes="std std-ref">World2D</inline></reference>.
                This suffices in most cases, but in case sharing them may be desired, it
                is possible to do so by setting <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-world-2d"><inline classes="std std-ref">world_2d</inline></reference> on the Viewport through code.</paragraph>
            <paragraph>关于如何工作的例子, 请分别参阅演示项目 <reference name="3D in 2D" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d">3D in 2D</reference><target ids="d-in-2d" names="3d\ in\ 2d" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/viewport/3d_in_2d"></target> 和 <reference name="2D in 3D" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/viewport/2d_in_3d">2D in 3D</reference><target ids="d-in-3d" names="2d\ in\ 3d" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/viewport/2d_in_3d"></target> .</paragraph>
        </section>
        <section ids="capture" names="capture 捕获">
            <title>捕获</title>
            <paragraph>It is possible to query a capture of the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> contents. For the Root
                Viewport, this is effectively a screen capture. This is done with the
                following code:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Retrieve the captured Image using get_image().
var img = get_viewport().get_texture().get_image()
# Convert Image to ImageTexture.
var tex = ImageTexture.create_from_image(img)
# Set sprite texture.
sprite.texture = tex</literal_block>
            <paragraph>但是如果你在 <literal>_ready()</literal> 中使用, 或者从 <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport 的</inline></reference> 初始化的第一帧开始使用, 你会得到一个空的纹理, 因为没有什么可以作为纹理获得. 你可以用来处理它, 例如:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Wait until the frame has finished before getting the texture.
await RenderingServer.frame_post_draw
# You can get the image after this.</literal_block>
        </section>
        <section ids="viewport-container" names="viewport\ container 视口容器">
            <title>视口容器</title>
            <paragraph>If the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> is a child of a <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainer</inline></reference>, it will become active and display anything it has inside. The layout looks like this:</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/container.webp'}" uri="tutorials/rendering/img/container.webp"></image>
            <paragraph>The <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> will cover the area of its parent <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainer</inline></reference> completely
                if <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer-property-stretch"><inline classes="std std-ref">Stretch</inline></reference> is set to <literal>true</literal> in the SubViewportContainer.</paragraph>
            <note>
                <paragraph>The size of the <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainer</inline></reference> cannot be smaller than the size of the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>.</paragraph>
            </note>
        </section>
        <section ids="rendering" names="rendering 渲染">
            <title>渲染</title>
            <paragraph>Due to the fact that the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> is an entryway into another rendering surface, it exposes a few
                rendering properties that can be different from the project settings. You can
                choose to use a different level of <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-msaa-2d"><inline classes="std std-ref">MSAA</inline></reference> for each Viewport. The default behavior is <literal>Disabled</literal>.</paragraph>
            <paragraph>If you know that the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> is only going to be used for 2D, you can <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-disable-3d"><inline classes="std std-ref">Disable 3D</inline></reference>. Godot will then
                restrict how the Viewport is drawn.
                Disabling 3D is slightly faster and uses less memory compared to enabled 3D. It's a good idea to disable 3D if your viewport doesn't render anything in 3D.</paragraph>
            <note>
                <paragraph>If you need to render 3D shadows in the viewport, make sure to set the viewport's <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-positional-shadow-atlas-size"><inline classes="std std-ref">positional_shadow_atlas_size</inline></reference> property to a value higher than <literal>0</literal>.
                    Otherwise, shadows won't be rendered. By default, the equivalent project setting is set to <literal>4096</literal> on desktop platforms and <literal>2048</literal> on mobile platforms.</paragraph>
            </note>
            <paragraph>Godot also provides a way of customizing how everything is drawn inside <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewports</inline></reference> using <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-debug-draw"><inline classes="std std-ref">Debug Draw</inline></reference>.
                Debug Draw allows you to specify a mode which determines how the Viewport will display things drawn
                inside it. Debug Draw is <literal>Disabled</literal> by default. Some other options are <literal>Unshaded</literal>, <literal>Overdraw</literal>, and <literal>Wireframe</literal>. For a full list, refer to the <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-debug-draw"><inline classes="std std-ref">Viewport Documentation</inline></reference>.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Debug Draw = Disabled</strong> (default): The scene is drawn normally.</paragraph>
                </list_item>
            </bullet_list>
            <block_quote>
                <image candidates="{'*': 'tutorials/rendering/img/default_scene.webp'}" uri="tutorials/rendering/img/default_scene.webp"></image>
            </block_quote>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Debug Draw = Unshaded</strong>: Unshaded draws the scene without using lighting information so all the objects appear flatly colored in their albedo color.</paragraph>
                </list_item>
            </bullet_list>
            <block_quote>
                <image candidates="{'*': 'tutorials/rendering/img/unshaded.webp'}" uri="tutorials/rendering/img/unshaded.webp"></image>
            </block_quote>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Debug Draw = Overdraw</strong>: Overdraw draws the meshes semi-transparent with an additive blend so you can see how the meshes overlap.</paragraph>
                </list_item>
            </bullet_list>
            <block_quote>
                <image candidates="{'*': 'tutorials/rendering/img/overdraw.webp'}" uri="tutorials/rendering/img/overdraw.webp"></image>
            </block_quote>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Debug Draw = Wireframe</strong>: Wireframe draws the scene using only the edges of triangles in the meshes.</paragraph>
                </list_item>
            </bullet_list>
            <block_quote>
                <image candidates="{'*': 'tutorials/rendering/img/wireframe.webp'}" uri="tutorials/rendering/img/wireframe.webp"></image>
            </block_quote>
            <note>
                <paragraph>Debug Draw modes are currently <strong>not</strong> supported when using the
                    Compatibility rendering method. They will appear as regular draw modes.</paragraph>
            </note>
        </section>
        <section ids="render-target" names="render\ target 渲染目标">
            <title>渲染目标</title>
            <paragraph>When rendering to a <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference>, whatever is inside will not be
                visible in the scene editor. To display the contents, you have to draw the SubViewport's <reference internal="True" refuri="../../classes/class_viewporttexture#class-viewporttexture"><inline classes="std std-ref">ViewportTexture</inline></reference> somewhere.
                This can be requested via code using (for example):</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># This gives us the ViewportTexture.
var tex = viewport.get_texture()
sprite.texture = tex</literal_block>
            <paragraph>或者可以通过选择"New ViewportTexture"在编辑器中指定它</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/texturemenu.webp'}" uri="tutorials/rendering/img/texturemenu.webp"></image>
            <paragraph>然后选择你想要使用的 <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>.</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/texturepath.webp'}" uri="tutorials/rendering/img/texturepath.webp"></image>
            <paragraph>Every frame, the <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport's</inline></reference> texture is cleared away with the default clear color (or a transparent
                color if <reference internal="True" refuri="../../classes/class_viewport#class-viewport-property-transparent-bg"><inline classes="std std-ref">Transparent BG</inline></reference> is set to <literal>true</literal>). This can be changed by setting <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport-property-render-target-clear-mode"><inline classes="std std-ref">Clear Mode</inline></reference> to <literal>Never</literal> or <literal>Next Frame</literal>.
                As the name implies, Never means the texture will never be cleared, while next frame will
                clear the texture on the next frame and then set itself to Never.</paragraph>
            <paragraph>By default, re-rendering of the <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport"><inline classes="std std-ref">SubViewport</inline></reference> happens when
                its <reference internal="True" refuri="../../classes/class_viewporttexture#class-viewporttexture"><inline classes="std std-ref">ViewportTexture</inline></reference> has been drawn in a frame. If visible, it will be
                rendered, otherwise, it will not. This behavior can be changed by setting <reference internal="True" refuri="../../classes/class_subviewport#class-subviewport-property-render-target-update-mode"><inline classes="std std-ref">Update Mode</inline></reference> to <literal>Never</literal>, <literal>Once</literal>, <literal>Always</literal>, or <literal>When Parent Visible</literal>.
                Never and Always will never or always re-render respectively. Once will re-render the next frame and change to Never afterwards. This can be used to manually update the Viewport.
                This flexibility allows users to render an image once and then use the texture without incurring the cost of rendering every frame.</paragraph>
            <note>
                <paragraph>一定要查看Viewport系列演示！ 它们位于演示存档中的Viewport文件夹，或https://github.com/godotengine/godot-demo-projects/tree/master/viewport。</paragraph>
            </note>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
