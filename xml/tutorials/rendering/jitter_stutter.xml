<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/rendering/jitter_stutter.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-jitter-stutter"></target>
    <section ids="fixing-jitter-stutter-and-input-lag doc-jitter-stutter" names="fixing\ jitter,\ stutter\ and\ input\ lag 修复抖动、卡顿和输入延迟 doc_jitter_stutter">
        <title>修复抖动、卡顿和输入延迟</title>
        <section ids="what-is-jitter-stutter-and-input-lag" names="what\ is\ jitter,\ stutter\ and\ input\ lag? 什么是抖动、卡顿和输入延迟？">
            <title>什么是抖动、卡顿和输入延迟？</title>
            <paragraph><emphasis>抖动</emphasis>（Jitter）和<emphasis>卡顿</emphasis>（stutter）是即使游戏在全速运行时，也可能出现在屏幕上物体可见运动中的两种不同变化，可能会影响游戏体验。这些问题在世界以恒定速度朝着固定方向运动的游戏中影响最明显, 比如跑酷或平台类游戏.</paragraph>
            <paragraph><emphasis>输入延迟</emphasis>与抖动和卡顿无关，但也是经常为人讨论的话题。输入延迟指在鼠标、键盘、控制器与触屏在与游戏进行互动时，在屏幕上所呈现的视觉延迟，产生的原因与游戏代码、引擎代码及外部因素（如硬件因素）等方面有关。尤其是在第一人称游戏当中，输入延迟尤为明显。输入延迟无法消除，但可以通过某些手段来减少输入延迟。</paragraph>
        </section>
        <section ids="distinguishing-between-jitter-and-stutter" names="distinguishing\ between\ jitter\ and\ stutter 抖动和卡顿的区分">
            <title>抖动和卡顿的区分</title>
            <paragraph>一款在正常帧下运行, 而不显示任何效果的游戏将显得平滑:</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/motion_normal.gif'}" uri="tutorials/rendering/img/motion_normal.gif"></image>
            <paragraph>游戏展示了<emphasis>抖动</emphasis>将以非常细微的方式持续抖动：</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/motion_jitter.gif'}" uri="tutorials/rendering/img/motion_jitter.gif"></image>
            <paragraph>最后，存在“卡顿”的游戏看上去是流畅的，但似乎每隔几秒钟就会<emphasis>停顿</emphasis>或<emphasis>回滚一帧</emphasis>：</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/motion_stutter.gif'}" uri="tutorials/rendering/img/motion_stutter.gif"></image>
        </section>
        <section ids="jitter" names="jitter 抖动">
            <title>抖动</title>
            <paragraph>产生抖动的原因有很多，最典型的情况发生在运行游戏时的<emphasis>物理频率</emphasis>（通常为 60 Hz）以与显示器刷新率不同。检查你的显示器刷新率是否为 60 Hz。</paragraph>
            <paragraph>这通常不是一个问题, 因为大多数显示器都是60赫兹, 而且从Godot 3.1开始, 引入了一个帧定时器, 尽量与刷新同步.</paragraph>
            <paragraph>Sometimes only some objects appear to jitter (character or background). This
                happens when they are processed in different time sources (one is processed in
                the physics step while another is processed in the idle step). Godot 3.1 does
                some improvements to this, from allowing kinematic bodies to be animated in the
                regular <literal>_process()</literal> loop, to further fixes in the frame timer.</paragraph>
        </section>
        <section ids="stutter" names="stutter 卡顿">
            <title>卡顿</title>
            <paragraph>产生卡顿有两个不同原因。第一个，也是最明显的一个，就是游戏无法保持完整的帧率性能。解决方法是因游戏而异的，需要进行优化。</paragraph>
            <paragraph>第二个原因更复杂，因为它通常与引擎或游戏无关，而与底层操作系统有关。下面是不同操作系统上，关于卡顿的一些信息。</paragraph>
            <paragraph>On platforms that support disabling V-Sync, stuttering can be made less
                noticeable by disabling V-Sync in the project settings. This will however cause
                tearing to appear, especially on monitors with low refresh rates. If your
                monitor supports it, consider enabling variable refresh rate (G-Sync/FreeSync)
                while leaving V-Sync enabled. This avoids mitigating some forms of stuttering
                without introducing tearing.</paragraph>
            <paragraph>Forcing your graphics card to use the maximum performance profile can also help
                reduce stuttering, at the cost of increased GPU power draw.</paragraph>
            <section ids="windows" names="windows">
                <title>Windows</title>
                <paragraph>众所周知，Windows 操作系统在窗口化游戏时会产生卡顿。这主要取决于你所安装的硬件，驱动程序版本和并行运行的进程（例如，打开多个浏览器标签页可能导致游戏在运行时出现卡顿）。为了避免这种情况，从 3.1 版本开始，Godot 将游戏的优先级提升到了“高于标准”。这样能够相当程度缓解问题，但可能无法完全消除卡顿现象。</paragraph>
                <paragraph>完全消除这种情况需要给你的游戏以充分的权限, 使之成为 "time critical" , 这是不建议的. 有些游戏可能会这样做, 但建议学会忍受这个问题, 因为这对Windows游戏来说很常见, 而且大多数用户不会在窗口中玩游戏(反正在窗口中玩的游戏, 如益智游戏, 通常不会出现这个问题).</paragraph>
                <paragraph>对于全屏来说，Windows 系统对游戏给予了特殊的优先级，所以卡顿现象不再可见，也非常罕见。大多数游戏都是这样玩的。</paragraph>
                <tip>
                    <paragraph>Games should use the <strong>Exclusive Fullscreen</strong> window mode, as opposed to
                        <strong>Fullscreen</strong> which is designed to prevent Windows from automatically
                        treating the window as if it was exclusive fullscreen.</paragraph>
                    <paragraph><strong>Fullscreen</strong> is meant to be used by GUI applications that want to use
                        per-pixel transparency without a risk of having it disabled by the OS. It
                        achieves this by leaving a 1-pixel line at the bottom of the screen. By
                        contrast, <strong>Exclusive Fullscreen</strong> uses the actual screen size and allows
                        Windows to reduce jitter and input lag for fullscreen games.</paragraph>
                </tip>
            </section>
            <section ids="linux" names="linux">
                <title>Linux</title>
                <paragraph>Stutter may be visible on desktop Linux, but this is usually associated with
                    different video drivers and compositors. Some compositors may also trigger this
                    problem (e.g. KWin), so it is advised to try using a different one to rule it
                    out as the cause. Some window managers such as KWin and Xfwm allow you to
                    manually disable compositing, which can improve performance (at the cost of
                    tearing).</paragraph>
                <paragraph>There is no workaround for driver or compositor stuttering, other than reporting
                    it as an issue to the driver or compositor developers. Stutter may be more
                    present when playing in windowed mode as opposed to fullscreen, even with
                    compositing disabled.</paragraph>
                <paragraph><reference name="Feral GameMode" refuri="https://github.com/FeralInteractive/gamemode">Feral GameMode</reference> can be used
                    to automatically apply optimizations (such as forcing the GPU performance profile)
                    when running specific processes.</paragraph>
            </section>
            <section ids="macos" names="macos">
                <title>macOS</title>
                <paragraph>通常情况下，macOS 不会出现卡顿现象，尽管最近在全屏运行时报告了一些 bug（这是 macOS 的 bug）。如果你的机器表现出这种行为，请将这问题提交给我们。</paragraph>
            </section>
            <section ids="android" names="android">
                <title>Android</title>
                <paragraph>通常情况下，Android 平台不会出现卡顿和抖动现象，因为运行活动拥有所有的优先级。也就是说，可能会出现问题的设备（较旧的 Kindle Fire 就是其中之一）。如果你在 Android 平台上看到这些问题，请将问题提交给我们。</paragraph>
            </section>
            <section ids="ios" names="ios">
                <title>iOS</title>
                <paragraph>iOS设备通常没有卡顿现象，但运行新版操作系统的旧式设备可能会出现问题。这通常是不可避免的。</paragraph>
            </section>
        </section>
        <section ids="input-lag" names="input\ lag 输入延迟">
            <title>输入延迟</title>
            <section ids="project-configuration" names="project\ configuration 项目配置">
                <title>项目配置</title>
                <paragraph>On platforms that support disabling V-Sync, input lag can be made less
                    noticeable by disabling V-Sync in the project settings. This will however cause
                    tearing to appear, especially on monitors with low refresh rates.</paragraph>
                <paragraph>Increasing the number of physics iterations per second can also reduce
                    physics-induced input latency. This is especially noticeable when using physics
                    interpolation (which improves smoothness but increases latency). To do so, set
                    <strong>Physics &gt; Common &gt; Physics Ticks Per Second</strong> to a value higher than the
                    default <literal>60</literal>, or set <literal>Engine.physics_ticks_per_second</literal> at run-time in a
                    script. Values that are a multiple of the monitor refresh rate (typically
                    <literal>60</literal>) work best when physics interpolation is disabled, as they will avoid
                    jitter. This means values such as <literal>120</literal>, <literal>180</literal> and <literal>240</literal> are good starting
                    points. As a bonus, higher physics FPSes make tunneling and physics instability
                    issues less likely to occur.</paragraph>
                <paragraph>The downside of increasing physics FPS is that CPU usage will increase, which
                    can lead to performance bottlenecks in games that have heavy physics simulation
                    code. This can be alleviated by increasing physics FPS only in situations where
                    low latency is critical, or by letting players adjust physics FPS to match their
                    hardware. However, different physics FPS will lead to different outcomes in
                    physics simulation, even when <literal>delta</literal> is consistently used in your game logic.
                    This can give certain players an advantage over others. Therefore, allowing the
                    player to change the physics FPS themselves should be avoided for competitive
                    multiplayer games.</paragraph>
                <paragraph>Lastly, you can disable input buffering on a per-rendered frame basis by calling
                    <literal>Input.set_use_accumulated_input(false)</literal> in a script. This will make it so the
                    <literal>_input()</literal> and <literal>_unhandled_input()</literal> functions in your scripts are called on
                    every input, rather than accumulating inputs and waiting for a frame to be
                    rendered. Disabling input accumulation will increase CPU usage, so it should be
                    done with caution.</paragraph>
            </section>
            <section ids="hardware-os-specific" names="hardware/os-specific 针对硬件/操作系统">
                <title>针对硬件/操作系统</title>
                <paragraph>If your monitor supports it, consider enabling variable refresh rate
                    (G-Sync/FreeSync) while leaving V-Sync enabled, then cap the framerate in the
                    project settings to a slightly lower value than your monitor's maximum refresh
                    rate as per <reference name="this page" refuri="https://blurbusters.com/howto-low-lag-vsync-on/">this page</reference>.
                    For example, on a 144 Hz monitor, you can set the project's framerate cap to
                    <literal>141</literal>. This may be counterintuitive at first, but capping the FPS below the
                    maximum refresh rate range ensures that the OS never has to wait for vertical
                    blanking to finish. This leads to <emphasis>similar</emphasis> input lag as V-Sync disabled with
                    the same framerate cap (usually less than 1 ms greater), but without any
                    tearing.</paragraph>
                <paragraph>This can be done by changing the <strong>Application &gt; Run &gt; Max FPS</strong> project
                    setting or assigning <literal>Engine.max_fps</literal> at run-time in a script.</paragraph>
                <paragraph>On some platforms, you can also opt into a low-latency mode in the graphics
                    driver options (such as the NVIDIA Control Panel on Windows). The <strong>Ultra</strong>
                    setting will give you the lowest possible latency, at the cost of slightly lower
                    average framerates. Forcing the GPU to use the maximum performance profile
                    can also further reduce input lag, at the cost of higher power consumption
                    (and resulting heat/fan noise).</paragraph>
                <paragraph>Finally, make sure your monitor is running at its highest possible refresh rate
                    in the OS' display settings.</paragraph>
                <paragraph>Also, ensure that your mouse is configured to use its highest polling rate
                    (typically 1,000 Hz for gaming mice, sometimes more). High USB polling rates can
                    however result in high CPU usage, so 500 Hz may be a safer bet on low-end CPUs.
                    If your mouse offers multiple <abbreviation explanation="Dots Per Inch">DPI</abbreviation> settings, consider also
                    <reference name="using the highest possible setting and reducing in-game sensitivity to reduce mouse latency" refuri="https://www.youtube.com/watch?v=6AoRfv9W110">using the highest possible setting and reducing in-game sensitivity to reduce mouse latency</reference>.</paragraph>
                <paragraph>On Linux, disabling compositing in window managers that allow it (such as KWin
                    or Xfwm) can reduce input lag significantly.</paragraph>
            </section>
        </section>
        <section ids="reporting-jitter-stutter-or-input-lag-problems" names="reporting\ jitter,\ stutter\ or\ input\ lag\ problems 报告卡顿、抖动或输入延迟问题">
            <title>报告卡顿、抖动或输入延迟问题</title>
            <paragraph>如果你报告的卡顿或抖动问题（提交 Issue）不是由上述原因引起的，请尽可能详细说明关于你的设备配置、操作系统、驱动程序版本等信息。这有助于我们更好地排除故障。</paragraph>
            <paragraph>If you are reporting input lag problems, please include a capture made with a
                high speed camera (such as your phone's slow motion video mode). The capture
                <strong>must</strong> have both the screen and the input device visible so that the number of
                frames between an input and the on-screen result can be counted. Also, make
                sure to mention your monitor's refresh rate and your input device's polling rate
                (especially for mice).</paragraph>
            <paragraph>Also, make sure to use the correct term (jitter, stutter, input lag) based on the
                exhibited behavior. This will help understand your issue much faster. Provide a
                project that can be used to reproduce the issue, and if possible, include a
                screen capture demonstrating the bug.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
