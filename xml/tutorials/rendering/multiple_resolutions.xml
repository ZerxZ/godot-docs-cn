<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/rendering/multiple_resolutions.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-multiple-resolutions"></target>
    <section ids="multiple-resolutions doc-multiple-resolutions" names="multiple\ resolutions doc_multiple_resolutions">
        <title>Multiple resolutions</title>
        <section ids="the-problem-of-multiple-resolutions" names="the\ problem\ of\ multiple\ resolutions">
            <title>The problem of multiple resolutions</title>
            <paragraph>Developers often have trouble understanding how to best support multiple
                resolutions in their games. For desktop and console games, this is more or less
                straightforward, as most screen aspect ratios are 16:9 and resolutions
                are standard (720p, 1080p, 1440p, 4K, …).</paragraph>
            <paragraph>For mobile games, at first, it was easy. For many years, the iPhone and iPad
                used the same resolution. When <emphasis>Retina</emphasis> was implemented, they just doubled
                the pixel density; most developers had to supply assets in default and double
                resolutions.</paragraph>
            <paragraph>Nowadays, this is no longer the case, as there are plenty of different screen
                sizes, densities, and aspect ratios. Non-conventional sizes are also becoming
                increasingly popular, such as ultrawide displays.</paragraph>
            <paragraph>For 3D rendering, there is not much of a need to support multiple resolutions.
                Thanks to its vector-based nature, 3D geometry will just fill the screen based
                on the viewport size. For 2D and game UIs, this is a different matter,
                as art needs to be created using specific pixel sizes in software such
                as Photoshop, GIMP or Krita.</paragraph>
            <paragraph>Since layouts, aspect ratios, resolutions, and pixel densities can change so
                much, it is no longer possible to design UIs for every specific screen.
                Another method must be used.</paragraph>
        </section>
        <section ids="one-size-fits-all" names="one\ size\ fits\ all">
            <title>One size fits all</title>
            <paragraph>The most common approach is to use a single <emphasis>base</emphasis> resolution and
                then fit it to everything else. This resolution is how most players are expected
                to play the game (given their hardware). For mobile, Google has useful <reference name="stats" refuri="https://developer.android.com/about/dashboards">stats</reference><target ids="stats" names="stats" refuri="https://developer.android.com/about/dashboards"></target> online, and for desktop,
                Steam <reference name="also does" refuri="https://store.steampowered.com/hwsurvey/">also does</reference><target ids="also-does" names="also\ does" refuri="https://store.steampowered.com/hwsurvey/"></target>.</paragraph>
            <paragraph>As an example, Steam shows that the most common <emphasis>primary display resolution</emphasis> is
                1920×1080, so a sensible approach is to develop a game for this resolution, then
                handle scaling for different sizes and aspect ratios.</paragraph>
            <paragraph>Godot provides several useful tools to do this easily.</paragraph>
            <seealso>
                <paragraph>You can see how Godot's support for multiple resolutions works in action using the
                    <reference name="Multiple Resolutions and Aspect Ratios demo project" refuri="https://github.com/godotengine/godot-demo-projects/tree/master/gui/multiple_resolutions">Multiple Resolutions and Aspect Ratios demo project</reference>.</paragraph>
            </seealso>
        </section>
        <section ids="base-size" names="base\ size">
            <title>Base size</title>
            <paragraph>A base size for the window can be specified in the Project Settings under
                <strong>Display → Window</strong>.</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/screenres.webp'}" original_uri="img/screenres.webp" uri="tutorials/rendering/img/screenres.webp"></image>
            <paragraph>However, what it does is not completely obvious; the engine will <emphasis>not</emphasis>
                attempt to switch the monitor to this resolution. Rather, think of this
                setting as the "design size", i.e. the size of the area that you work
                with in the editor. This setting corresponds directly to the size of the
                blue rectangle in the 2D editor.</paragraph>
            <paragraph>There is often a need to support devices with screen and window sizes
                that are different from this base size. Godot offers many ways to
                control how the viewport will be resized and stretched to different
                screen sizes.</paragraph>
            <note>
                <paragraph>On this page, <emphasis>window</emphasis> refers to the screen area allotted to your game
                    by the system, while <emphasis>viewport</emphasis> refers to the root object (accessible
                    from <literal>get_tree().root</literal>) which the game controls to fill this screen area.
                    This viewport is a <reference internal="True" refuri="../../classes/class_window#class-window"><inline classes="std std-ref">Window</inline></reference> instance. Recall from the
                    <reference internal="True" refuri="viewports#doc-viewports"><inline classes="std std-ref">introduction</inline></reference> that <emphasis>all</emphasis> Window objects are viewports.</paragraph>
            </note>
            <paragraph>To configure the stretch base size at runtime from a script, use the
                <literal>get_tree().root.content_scale_size</literal> property (see
                <reference internal="True" refuri="../../classes/class_window#class-window-property-content-scale-size"><inline classes="std std-ref">Window.content_scale_size</inline></reference>).
                Changing this value can indirectly change the size of 2D elements. However, to
                provide a user-accessible scaling option, using
                <reference internal="True" refid="doc-multiple-resolutions-stretch-scale"><inline classes="std std-ref">Stretch Scale</inline></reference> is recommended as it's easier to
                adjust.</paragraph>
            <note>
                <paragraph>Godot follows a modern approach to multiple resolutions. The engine will
                    never change the monitor's resolution on its own. While changing the
                    monitor's resolution is the most efficient approach, it's also the least
                    reliable approach as it can leave the monitor stuck on a low resolution if
                    the game crashes. This is especially common on macOS or Linux which don't
                    handle resolution changes as well as Windows.</paragraph>
                <paragraph>Changing the monitor's resolution also removes any control from the game
                    developer over filtering and aspect ratio stretching, which can be important
                    to ensure correct display for pixel art games.</paragraph>
                <paragraph>On top of that, changing the monitor's resolution makes alt-tabbing in and
                    out of a game much slower since the monitor has to change resolutions every
                    time this is done.</paragraph>
            </note>
        </section>
        <section ids="resizing" names="resizing">
            <title>Resizing</title>
            <paragraph>There are several types of devices, with several types of screens, which
                in turn have different pixel density and resolutions. Handling all of
                them can be a lot of work, so Godot tries to make the developer's life a
                little easier. The <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>
                node has several functions to handle resizing, and the root node of the
                scene tree is always a viewport (scenes loaded are instanced as a child
                of it, and it can always be accessed by calling
                <literal>get_tree().root</literal> or <literal>get_node("/root")</literal>).</paragraph>
            <paragraph>In any case, while changing the root Viewport params is probably the
                most flexible way to deal with the problem, it can be a lot of work,
                code and guessing, so Godot provides a set of parameters in the
                project settings to handle multiple resolutions.</paragraph>
            <tip>
                <paragraph>To render 3D at a lower resolution than 2D elements (without needing
                    separate viewports), you can use Godot's
                    <reference internal="True" refuri="../3d/resolution_scaling#doc-resolution-scaling"><inline classes="std std-ref">resolution scaling</inline></reference> support. This is a good way
                    to improve performance significantly in GPU-bottlenecked scenarios.
                    This works with any stretch mode and stretch aspect combination.</paragraph>
            </tip>
        </section>
        <section ids="stretch-settings" names="stretch\ settings">
            <title>Stretch settings</title>
            <paragraph>Stretch settings are located in the project settings and provide several options:</paragraph>
            <image candidates="{'*': 'tutorials/rendering/img/stretchsettings.webp'}" original_uri="img/stretchsettings.webp" uri="tutorials/rendering/img/stretchsettings.webp"></image>
            <section ids="stretch-mode" names="stretch\ mode">
                <title>Stretch Mode</title>
                <paragraph>The <strong>Stretch Mode</strong> setting defines how the base size is stretched to fit
                    the resolution of the window or screen. The animations below use a "base
                    size" of just 16×9 pixels to demonstrate the effect of different stretch
                    modes. A single sprite, also 16×9 pixels in size, covers the entire viewport,
                    and a diagonal <reference internal="True" refuri="../../classes/class_line2d#class-line2d"><inline classes="std std-ref">Line2D</inline></reference> is added on top of it:</paragraph>
                <image candidates="{'*': 'tutorials/rendering/img/stretch_demo_scene.png'}" original_uri="img/stretch_demo_scene.png" uri="tutorials/rendering/img/stretch_demo_scene.png"></image>
                <comment xml:space="preserve">Animated GIFs are generated from:</comment>
                <comment xml:space="preserve">https://github.com/ttencate/godot_scaling_mode</comment>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Stretch Mode = Disabled</strong> (default): No stretching happens. One
                            unit in the scene corresponds to one pixel on the screen. In this
                            mode, the <strong>Stretch Aspect</strong> setting has no effect.</paragraph>
                        <image candidates="{'*': 'tutorials/rendering/img/stretch_disabled_expand.gif'}" original_uri="img/stretch_disabled_expand.gif" uri="tutorials/rendering/img/stretch_disabled_expand.gif"></image>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Stretch Mode = Canvas Items</strong>: In this mode, the base size specified in
                            width and height in the project settings is
                            stretched to cover the whole screen (taking the <strong>Stretch Aspect</strong>
                            setting into account). This means that everything is rendered
                            directly at the target resolution. 3D is unaffected,
                            while in 2D, there is no longer a 1:1 correspondence between sprite
                            pixels and screen pixels, which may result in scaling artifacts.</paragraph>
                        <image candidates="{'*': 'tutorials/rendering/img/stretch_2d_expand.gif'}" original_uri="img/stretch_2d_expand.gif" uri="tutorials/rendering/img/stretch_2d_expand.gif"></image>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Stretch Mode = Viewport</strong>: Viewport scaling means that the size of
                            the root <reference internal="True" refuri="../../classes/class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> is set precisely to the
                            base size specified in the Project Settings' <strong>Display</strong> section.
                            The scene is rendered to this viewport first. Finally, this viewport
                            is scaled to fit the screen (taking the <strong>Stretch Aspect</strong> setting into
                            account).</paragraph>
                        <image candidates="{'*': 'tutorials/rendering/img/stretch_viewport_expand.gif'}" original_uri="img/stretch_viewport_expand.gif" uri="tutorials/rendering/img/stretch_viewport_expand.gif"></image>
                    </list_item>
                </bullet_list>
                <paragraph>To configure the stretch mode at runtime from a script, use the
                    <literal>get_tree().root.content_scale_mode</literal> property (see
                    <reference internal="True" refuri="../../classes/class_window#class-window-property-content-scale-mode"><inline classes="std std-ref">Window.content_scale_mode</inline></reference>
                    and the <reference internal="True" refuri="../../classes/class_window#enum-window-contentscalemode"><inline classes="std std-ref">ContentScaleMode</inline></reference> enum).</paragraph>
            </section>
            <section ids="stretch-aspect" names="stretch\ aspect">
                <title>Stretch Aspect</title>
                <paragraph>The second setting is the stretch aspect. Note that this only takes effect if
                    <strong>Stretch Mode</strong> is set to something other than <strong>Disabled</strong>.</paragraph>
                <paragraph>In the animations below, you will notice gray and black areas. The black
                    areas are added by the engine and cannot be drawn into. The gray areas
                    are part of your scene, and can be drawn to. The gray areas correspond
                    to the region outside the blue frame you see in the 2D editor.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Stretch Aspect = Ignore</strong>: Ignore the aspect ratio when stretching
                            the screen. This means that the original resolution will be stretched
                            to exactly fill the screen, even if it's wider or narrower. This may
                            result in nonuniform stretching: things looking wider or taller than
                            designed.</paragraph>
                        <image candidates="{'*': 'tutorials/rendering/img/stretch_viewport_ignore.gif'}" original_uri="img/stretch_viewport_ignore.gif" uri="tutorials/rendering/img/stretch_viewport_ignore.gif"></image>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Stretch Aspect = Keep</strong>: Keep aspect ratio when stretching the
                            screen. This means that the viewport retains its original size
                            regardless of the screen resolution, and black bars will be added to
                            the top/bottom of the screen ("letterboxing") or the sides
                            ("pillarboxing").</paragraph>
                        <paragraph>This is a good option if you know the aspect ratio of your target
                            devices in advance, or if you don't want to handle different aspect
                            ratios.</paragraph>
                        <image candidates="{'*': 'tutorials/rendering/img/stretch_viewport_keep.gif'}" original_uri="img/stretch_viewport_keep.gif" uri="tutorials/rendering/img/stretch_viewport_keep.gif"></image>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Stretch Aspect = Keep Width</strong>: Keep aspect ratio when stretching the
                            screen. If the screen is wider than the base size, black bars are
                            added at the left and right (pillarboxing). But if the screen is
                            taller than the base resolution, the viewport will be grown in the
                            vertical direction (and more content will be visible to the bottom).
                            You can also think of this as "Expand Vertically".</paragraph>
                        <paragraph>This is usually the best option for creating GUIs or HUDs that scale,
                            so some controls can be anchored to the bottom
                            (<reference internal="True" refuri="../ui/size_and_anchors#doc-size-and-anchors"><inline classes="std std-ref">Size and anchors</inline></reference>).</paragraph>
                        <image candidates="{'*': 'tutorials/rendering/img/stretch_viewport_keep_width.gif'}" original_uri="img/stretch_viewport_keep_width.gif" uri="tutorials/rendering/img/stretch_viewport_keep_width.gif"></image>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Stretch Aspect = Keep Height</strong>: Keep aspect ratio when stretching
                            the screen. If the screen is taller than the base size, black
                            bars are added at the top and bottom (letterboxing). But if the
                            screen is wider than the base resolution, the viewport will be grown
                            in the horizontal direction (and more content will be visible to the
                            right). You can also think of this as "Expand Horizontally".</paragraph>
                        <paragraph>This is usually the best option for 2D games that scroll horizontally
                            (like runners or platformers).</paragraph>
                        <image candidates="{'*': 'tutorials/rendering/img/stretch_viewport_keep_height.gif'}" original_uri="img/stretch_viewport_keep_height.gif" uri="tutorials/rendering/img/stretch_viewport_keep_height.gif"></image>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Stretch Aspect = Expand</strong>: Keep aspect ratio when stretching the
                            screen, but keep neither the base width nor height. Depending on the
                            screen aspect ratio, the viewport will either be larger in the
                            horizontal direction (if the screen is wider than the base size) or
                            in the vertical direction (if the screen is taller than the original
                            size).</paragraph>
                        <image candidates="{'*': 'tutorials/rendering/img/stretch_viewport_expand.gif'}" original_uri="img/stretch_viewport_expand.gif" uri="tutorials/rendering/img/stretch_viewport_expand.gif"></image>
                    </list_item>
                </bullet_list>
                <tip>
                    <paragraph>To support both portrait and landscape mode with a similar automatically
                        determined scale factor, set your project's base resolution to be a <emphasis>square</emphasis>
                        (1:1 aspect ratio) instead of a rectangle. For instance, if you wish to design
                        for 1280×720 as the base resolution but wish to support both portrait and
                        landscape mode, use 720×720 as the project's base window size in the
                        Project Settings.</paragraph>
                    <paragraph>To allow the user to choose their preferred screen orientation at runtime,
                        remember to set <strong>Display &gt; Window &gt; Handheld &gt; Orientation</strong> to <literal>sensor</literal>.</paragraph>
                </tip>
                <paragraph>To configure the stretch aspect at runtime from a script, use the
                    <literal>get_tree().root.content_scale_aspect</literal> property (see
                    <reference internal="True" refuri="../../classes/class_window#class-window-property-content-scale-aspect"><inline classes="std std-ref">Window.content_scale_aspect</inline></reference>
                    and the <reference internal="True" refuri="../../classes/class_window#enum-window-contentscaleaspect"><inline classes="std std-ref">ContentScaleAspect</inline></reference> enum).</paragraph>
                <target refid="doc-multiple-resolutions-stretch-scale"></target>
            </section>
            <section ids="stretch-scale doc-multiple-resolutions-stretch-scale" names="stretch\ scale doc_multiple_resolutions_stretch_scale">
                <title>Stretch Scale</title>
                <paragraph>The <strong>Scale</strong> setting allows you to add an extra scaling factor on top of
                    what the <strong>Stretch</strong> options above already provide. The default value of <literal>1.0</literal>
                    means that no additional scaling occurs.</paragraph>
                <paragraph>For example, if you set <strong>Scale</strong> to <literal>2.0</literal> and leave <strong>Stretch Mode</strong> on
                    <strong>Disabled</strong>, each unit in your scene will correspond to 2×2 pixels on the
                    screen. This is a good way to provide scaling options for non-game applications.</paragraph>
                <paragraph>If <strong>Stretch Mode</strong> is set to <strong>canvas_items</strong>, 2D elements will be scaled
                    relative to the base window size, then multiplied by the <strong>Scale</strong> setting. This
                    can be exposed to players to allow them to adjust the automatically determined
                    scale to their liking, for better accessibility.</paragraph>
                <paragraph>If <strong>Stretch Mode</strong> is set to <strong>viewport</strong>, the viewport's resolution is divided
                    by <strong>Scale</strong>. This makes pixels look larger and reduces rendering resolution
                    (with a given window size), which can improve performance.</paragraph>
                <paragraph>To configure the stretch scale at runtime from a script, use the
                    <literal>get_tree().root.content_scale_factor</literal> property (see
                    <reference internal="True" refuri="../../classes/class_window#class-window-property-content-scale-factor"><inline classes="std std-ref">Window.content_scale_factor</inline></reference>).</paragraph>
                <paragraph>You can also adjust the scale at which the default project theme is generated
                    using the <strong>GUI &gt; Theme &gt; Default Theme Scale</strong> project setting. This can be
                    used to create more logically-sized UIs at base resolutions that are
                    significantly higher or lower than the default. However, this project setting
                    cannot be changed at runtime, as its value is only read once when the project starts.</paragraph>
                <target refid="doc-multiple-resolutions-stretch-scale-mode"></target>
            </section>
            <section ids="stretch-scale-mode doc-multiple-resolutions-stretch-scale-mode" names="stretch\ scale\ mode doc_multiple_resolutions_stretch_scale_mode">
                <title>Stretch Scale Mode</title>
                <paragraph>Since Godot 4.2, the <strong>Stretch Scale Mode</strong> setting allows you to constrain the
                    automatically determined scale factor (as well as the manually specified
                    <strong>Stretch Scale</strong> setting) to integer values. By default, this setting is set to
                    <literal>fractional</literal>, which allows any scale factor to be applied (including fractional
                    values such as <literal>2.5</literal>). When set to <literal>integer</literal>, the value is rounded down to
                    the nearest integer. For example, instead of using a scale factor of <literal>2.5</literal>, it
                    would be rounded down to <literal>2.0</literal>. This is useful to prevent distortion when
                    displaying pixel art.</paragraph>
                <paragraph>Compare this pixel art which is displayed with the <literal>viewport</literal> stretch mode,
                    with the stretch scale mode set to <literal>fractional</literal>:</paragraph>
                <figure align="center" ids="id1">
                    <image alt="Fractional scaling example (incorrect pixel art appearance)" candidates="{'*': 'tutorials/rendering/img/multiple_resolutions_pixel_art_fractional_scaling.webp'}" original_uri="img/multiple_resolutions_pixel_art_fractional_scaling.webp" uri="tutorials/rendering/img/multiple_resolutions_pixel_art_fractional_scaling.webp"></image>
                    <caption>Checkerboard doesn't look "even". Line widths in the logo and text varies wildly.</caption>
                </figure>
                <paragraph>This pixel art is also displayed with the <literal>viewport</literal> stretch mode, but the
                    stretch scale mode is set to <literal>integer</literal> this time:</paragraph>
                <figure align="center" ids="id2">
                    <image alt="Integer scaling example (correct pixel art appearance)" candidates="{'*': 'tutorials/rendering/img/multiple_resolutions_pixel_art_integer_scaling.webp'}" original_uri="img/multiple_resolutions_pixel_art_integer_scaling.webp" uri="tutorials/rendering/img/multiple_resolutions_pixel_art_integer_scaling.webp"></image>
                    <caption>Checkerboard looks perfectly even. Line widths are consistent.</caption>
                </figure>
                <paragraph>For example, if your viewport base size is 640×360 and the window size is 1366×768:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>When using <literal>fractional</literal>, the viewport is displayed at a resolution of
                            1366×768 (scale factor is roughly 2.133×). The entire window space is used.
                            Each pixel in the viewport corresponds to 2.133×2.133 pixels in the displayed
                            area. However, since displays can only display "whole" pixels, this will lead
                            to uneven pixel scaling which results in incorrect appearance of pixel art.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>When using <literal>integer</literal>, the viewport is displayed at a resolution of 1280×720
                            (scale factor is 2×). The remaining space is filled with black bars on all
                            four sides, so that each pixel in the viewport corresponds to 2×2 pixels in
                            the displayed area.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>This setting is effective with any stretch mode. However, when using the
                    <literal>disabled</literal> stretch mode, it will only affect the <strong>Stretch Scale</strong> setting by
                    rounding it <emphasis>down</emphasis> to the nearest integer value. This can be used for 3D games
                    that have a pixel art UI, so that the visible area in the 3D viewport doesn't
                    reduce in size (which occurs when using <literal>canvas_items</literal> or <literal>viewport</literal> stretch
                    mode with the <literal>integer</literal> scale mode).</paragraph>
                <tip>
                    <paragraph>Games should use the <strong>Exclusive Fullscreen</strong> window mode, as opposed to
                        <strong>Fullscreen</strong> which is designed to prevent Windows from automatically
                        treating the window as if it was exclusive fullscreen.</paragraph>
                    <paragraph><strong>Fullscreen</strong> is meant to be used by GUI applications that want to use
                        per-pixel transparency without a risk of having it disabled by the OS. It
                        achieves this by leaving a 1-pixel line at the bottom of the screen. By
                        contrast, <strong>Exclusive Fullscreen</strong> uses the actual screen size and allows
                        Windows to reduce jitter and input lag for fullscreen games.</paragraph>
                    <paragraph>When using integer scaling, this is particularly important as the 1-pixel
                        height reduction from the <strong>Fullscreen</strong> mode can cause integer scaling to
                        use a smaller scale factor than expected.</paragraph>
                </tip>
            </section>
        </section>
        <section ids="common-use-case-scenarios" names="common\ use\ case\ scenarios">
            <title>Common use case scenarios</title>
            <paragraph>The following settings are recommended to support multiple resolutions and aspect
                ratios well.</paragraph>
            <section ids="desktop-game" names="desktop\ game">
                <title>Desktop game</title>
                <paragraph><strong>Non-pixel art:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Set the base window width to <literal>1920</literal> and window height to <literal>1080</literal>. If you have a
                            display smaller than 1920×1080, set <strong>Window Width Override</strong> and <strong>Window Height Override</strong> to
                            lower values to make the window smaller when the project starts.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Alternatively, if you're targeting high-end devices primarily, set the base
                            window width to <literal>3840</literal> and window height to <literal>2160</literal>.
                            This allows you to provide higher resolution 2D assets, resulting in crisper
                            visuals at the cost of higher memory usage and file sizes. You'll also want
                            to increase <strong>GUI &gt; Theme &gt; Default Theme Scale</strong> to a value between <literal>2.0</literal>
                            and <literal>3.0</literal> to ensure UI elements remain readable.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Note that this will make non-mipmapped textures grainy on low resolution devices,
                                    so make sure to follow the instructions described in
                                    <reference internal="True" refid="doc-multiple-resolutions-reducing-aliasing-on-downsampling"><inline classes="std std-ref">Reducing aliasing on downsampling</inline></reference>.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph>Set the stretch mode to <literal>canvas_items</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Set the stretch aspect to <literal>expand</literal>. This allows for supporting multiple aspect ratios
                            and makes better use of tall smartphone displays (such as 18:9 or 19:9 aspect ratios).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Configure Control nodes' anchors to snap to the correct corners using the <strong>Layout</strong> menu.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>For 3D games, consider exposing <reference internal="True" refuri="../3d/resolution_scaling#doc-resolution-scaling"><inline classes="std std-ref">Resolution scaling</inline></reference> in the game's options menu
                            to allow players to adjust the 3D rendering resolution separately from UI elements.
                            This is useful for performance tuning, especially on lower-end hardware.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Pixel art:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Set the base window size to the viewport size you intend to use. Most pixel
                            art games use viewport sizes between 256×224 and 640×480. 640×360 is a good
                            baseline, as it scales to 1280×720, 1920×1080, 2560×1440, and 3840×2160 without
                            any black bars when using integer scaling. Higher viewport sizes will require
                            using higher resolution artwork, unless you intend to show more of the game
                            world at a given time.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Set the stretch mode to <literal>viewport</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Set the stretch aspect to <literal>keep</literal> to enforce a single aspect ratio (with
                            black bars). As an alternative, you can set the stretch aspect to <literal>expand</literal> to
                            support multiple aspect ratios.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>If using the <literal>expand</literal> stretch aspect, Configure Control nodes' anchors to
                            snap to the correct corners using the <strong>Layout</strong> menu.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Set the stretch scale mode to <literal>integer</literal>. This prevents uneven pixel scaling
                            from occurring, which makes pixel art not display as intended.</paragraph>
                    </list_item>
                </bullet_list>
                <note>
                    <paragraph>The <literal>viewport</literal> stretch mode provides low-resolution rendering that is then
                        stretched to the final window size. If you are OK with sprites being able to
                        move or rotate in "sub-pixel" positions or wish to have a high resolution 3D
                        viewport, you should use the <literal>canvas_items</literal> stretch mode instead of the <literal>viewport</literal>
                        stretch mode.</paragraph>
                </note>
            </section>
            <section ids="mobile-game-in-landscape-mode" names="mobile\ game\ in\ landscape\ mode">
                <title>Mobile game in landscape mode</title>
                <paragraph>Godot is configured to use landscape mode by default. This means you don't need
                    to change the display orientation project setting.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Set the base window width to <literal>1280</literal> and window height to <literal>720</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Alternatively, if you're targeting high-end devices primarily, set the base
                            window width to <literal>1920</literal> and window height to <literal>1080</literal>.
                            This allows you to provide higher resolution 2D assets, resulting in crisper
                            visuals at the cost of higher memory usage and file sizes. Many devices have
                            even higher resolution displays (1440p), but the difference with 1080p is
                            barely visible given the small size of smartphone displays. You'll also want
                            to increase <strong>GUI &gt; Theme &gt; Default Theme Scale</strong> to a value between <literal>1.5</literal>
                            and <literal>2.0</literal> to ensure UI elements remain readable.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Note that this will make non-mipmapped textures grainy on low resolution devices,
                                    so make sure to follow the instructions described in
                                    <reference internal="True" refid="doc-multiple-resolutions-reducing-aliasing-on-downsampling"><inline classes="std std-ref">Reducing aliasing on downsampling</inline></reference>.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph>Set the stretch mode to <literal>canvas_items</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Set the stretch aspect to <literal>expand</literal>. This allows for supporting multiple aspect ratios
                            and makes better use of tall smartphone displays (such as 18:9 or 19:9 aspect ratios).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Configure Control nodes' anchors to snap to the correct corners using the <strong>Layout</strong> menu.</paragraph>
                    </list_item>
                </bullet_list>
                <tip>
                    <paragraph>To better support tablets and foldable phones (which frequently feature
                        displays with aspect ratios close to 4:3), consider using a base resolution
                        that has a 4:3 aspect ratio while following the rest of the instructions
                        here. For instance, you can set the base window width to <literal>1280</literal> and the
                        base window height to <literal>960</literal>.</paragraph>
                </tip>
            </section>
            <section ids="mobile-game-in-portrait-mode" names="mobile\ game\ in\ portrait\ mode">
                <title>Mobile game in portrait mode</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Set the base window width to <literal>720</literal> and window height to <literal>1280</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Alternatively, if you're targeting high-end devices primarily, set the base
                            window width to <literal>1080</literal> and window height to <literal>1920</literal>.
                            This allows you to provide higher resolution 2D assets, resulting in crisper
                            visuals at the cost of higher memory usage and file sizes. Many devices have
                            even higher resolution displays (1440p), but the difference with 1080p is
                            barely visible given the small size of smartphone displays. You'll also want
                            to increase <strong>GUI &gt; Theme &gt; Default Theme Scale</strong> to a value between <literal>1.5</literal>
                            and <literal>2.0</literal> to ensure UI elements remain readable.</paragraph>
                        <bullet_list bullet="-">
                            <list_item>
                                <paragraph>Note that this will make non-mipmapped textures grainy on low resolution devices,
                                    so make sure to follow the instructions described in
                                    <reference internal="True" refid="doc-multiple-resolutions-reducing-aliasing-on-downsampling"><inline classes="std std-ref">Reducing aliasing on downsampling</inline></reference>.</paragraph>
                            </list_item>
                        </bullet_list>
                    </list_item>
                    <list_item>
                        <paragraph>Set <strong>Display &gt; Window &gt; Handheld &gt; Orientation</strong> to <literal>portrait</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Set the stretch mode to <literal>canvas_items</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Set the stretch aspect to <literal>expand</literal>. This allows for supporting multiple aspect ratios
                            and makes better use of tall smartphone displays (such as 18:9 or 19:9 aspect ratios).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Configure Control nodes' anchors to snap to the correct corners using the <strong>Layout</strong> menu.</paragraph>
                    </list_item>
                </bullet_list>
                <tip>
                    <paragraph>To better support tablets and foldable phones (which frequently feature
                        displays with aspect ratios close to 4:3), consider using a base resolution
                        that has a 3:4 aspect ratio while following the rest of the instructions
                        here. For instance, you can set the base window width to <literal>960</literal> and the
                        base window height to <literal>1280</literal>.</paragraph>
                </tip>
            </section>
            <section ids="non-game-application" names="non-game\ application">
                <title>Non-game application</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Set the base window width and height to the smallest window size that you intend to target.
                            This is not required, but this ensures that you design your UI with small window sizes in mind.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Keep the stretch mode to its default value, <literal>disabled</literal>.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Keep the stretch aspect to its default value, <literal>ignore</literal>
                            (its value won't be used since the stretch mode is <literal>disabled</literal>).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>You can define a minimum window size by calling <literal>get_window().set_min_size()</literal> in a
                            script's <literal>_ready()</literal> function. This prevents the user from resizing the application
                            below a certain size, which could break the UI layout.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Add a setting in the application's settings to change the root viewport's
                            <reference internal="True" refid="doc-multiple-resolutions-stretch-scale"><inline classes="std std-ref">stretch scale</inline></reference>,
                            so that the UI can be made larger to account for hiDPI displays.
                            See also the section on hiDPI support below.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="hidpi-support" names="hidpi\ support">
            <title>hiDPI support</title>
            <paragraph>By default, Godot projects are considered DPI-aware by the operating system.
                This is controlled by the <strong>Display &gt; Window &gt; DPI &gt; Allow hiDPI</strong> project setting,
                which should be left enabled whenever possible. Disabling DPI awareness can break
                fullscreen behavior on Windows.</paragraph>
            <paragraph>Since Godot projects are DPI-aware, they may appear at a very small window size
                when launching on an hiDPI display (proportionally to the screen resolution).
                For a game, the most common way to work around this issue is to make them
                fullscreen by default. Alternatively, you could set the window size in an
                <reference internal="True" refuri="../scripting/singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">autoload</inline></reference>'s <literal>_ready()</literal> function according to
                the screen size.</paragraph>
            <paragraph>To ensure 2D elements don't appear too small on hiDPI displays:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>For games, use the <literal>canvas_items</literal> or <literal>viewport</literal> stretch modes so that 2D
                        elements are automatically resized according to the current window size.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>For non-game applications, use the <literal>disabled</literal> stretch mode and set the
                        stretch scale to a value corresponding to the display scale factor in an
                        <reference internal="True" refuri="../scripting/singletons_autoload#doc-singletons-autoload"><inline classes="std std-ref">autoload</inline></reference>'s <literal>_ready()</literal> function.
                        The display scale factor is set in the operating system's settings and can be queried
                        using <reference internal="True" refuri="../../classes/class_displayserver#class-displayserver-method-screen-get-scale"><inline classes="std std-ref">screen_get_scale</inline></reference>. This
                        method is currently implemented on Android, iOS, Linux (Wayland only), macOS and Web.
                        On other platforms, you'll have to implement a method to guess the display
                        scale factor based on the screen resolution (with a setting to let the
                        user override this if needed). This is the approach currently used by the Godot editor.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The <strong>Allow hiDPI</strong> setting is only effective on Windows and macOS. It's ignored
                on all other platforms.</paragraph>
            <note>
                <paragraph>The Godot editor itself is always marked as DPI-aware. Running the project
                    from the editor will only be DPI-aware if <strong>Allow hiDPI</strong> is enabled in the
                    Project Settings.</paragraph>
            </note>
            <target refid="doc-multiple-resolutions-reducing-aliasing-on-downsampling"></target>
        </section>
        <section ids="reducing-aliasing-on-downsampling doc-multiple-resolutions-reducing-aliasing-on-downsampling" names="reducing\ aliasing\ on\ downsampling doc_multiple_resolutions_reducing_aliasing_on_downsampling">
            <title>Reducing aliasing on downsampling</title>
            <paragraph>If the game has a very high base resolution (e.g. 3840×2160), aliasing might
                appear when downsampling to something considerably lower like 1280×720.</paragraph>
            <paragraph>To resolve this, you can <reference internal="True" refuri="../assets_pipeline/importing_images#doc-importing-images-mipmaps"><inline classes="std std-ref">enable mipmaps</inline></reference> on
                all your 2D textures. However, enabling mipmaps will increase memory usage which
                can be an issue on low-end mobile devices.</paragraph>
        </section>
        <section ids="handling-aspect-ratios" names="handling\ aspect\ ratios">
            <title>Handling aspect ratios</title>
            <paragraph>Once scaling for different resolutions is accounted for, make sure that
                your <emphasis>user interface</emphasis> also scales for different aspect ratios. This can be
                done using <reference internal="True" refuri="../ui/size_and_anchors#doc-size-and-anchors"><inline classes="std std-ref">anchors</inline></reference> and/or <reference internal="True" refuri="../ui/gui_containers#doc-gui-containers"><inline classes="std std-ref">containers</inline></reference>.</paragraph>
        </section>
        <section ids="field-of-view-scaling" names="field\ of\ view\ scaling">
            <title>Field of view scaling</title>
            <paragraph>The 3D Camera node's <strong>Keep Aspect</strong> property defaults to the <strong>Keep Height</strong>
                scaling mode (also called <emphasis>Hor+</emphasis>). This is usually the best value for desktop
                games and mobile games in landscape mode, as widescreen displays will
                automatically use a wider field of view.</paragraph>
            <paragraph>However, if your 3D game is intended to be played in portrait mode, it may make
                more sense to use <strong>Keep Width</strong> instead (also called <emphasis>Vert-</emphasis>). This way,
                smartphones with an aspect ratio taller than 16:9 (e.g. 19:9) will use a
                <emphasis>taller</emphasis> field of view, which is more logical here.</paragraph>
        </section>
        <section ids="scaling-2d-and-3d-elements-differently" names="scaling\ 2d\ and\ 3d\ elements\ differently">
            <title>Scaling 2D and 3D elements differently</title>
            <paragraph>To render 3D at a different resolution from 2D elements (such as the UI), use Godot's
                <reference internal="True" refuri="../3d/resolution_scaling#doc-resolution-scaling"><inline classes="std std-ref">resolution scaling</inline></reference> functionality. This allows you to
                control the resolution scale factor used for 3D without needing to use a separate Viewport
                node. This can either be used to improve performance by rendering 3D at a lower resolution,
                or improve quality via supersampling.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
