<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/ui/gui_skinning.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-gui-skinning"></target>
    <section ids="introduction-to-gui-skinning doc-gui-skinning" names="introduction\ to\ gui\ skinning doc_gui_skinning">
        <title>Introduction to GUI skinning</title>
        <paragraph>It is essential for a game to provide clear, informative, and yet visually
            pleasing user interface to its players. While <reference internal="True" refuri="../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference>
            nodes come with a decently functional look out of the box, there is always
            room for uniqueness and case-specific tuning. For this purpose Godot engine
            includes a system for GUI skinning (or theming), which allows you to customize
            the look of every control in your user interface, including your custom controls.</paragraph>
        <paragraph>Here is an example of this system in action â€” a game with the GUI that is
            radically different from the default UI theme of the engine:</paragraph>
        <figure align="center" ids="id1">
            <image candidates="{'*': 'tutorials/ui/img/tank-kings-by-winterpixel-games.png'}" original_uri="img/tank-kings-by-winterpixel-games.png" uri="tutorials/ui/img/tank-kings-by-winterpixel-games.png"></image>
            <caption>A "Gear Up!" screen in Tank Kings, courtesy of Winterpixel Games</caption>
        </figure>
        <paragraph>Beyond achieving a unique look for your game, this system also enables developers
            to provide customization options to the end users, including accessibility settings.
            UI themes are applied in a cascading manner (i.e. they propagate from parent
            controls to their children), which means that font settings or adjustments for
            colorblind users can be applied in a single place and affect the entire UI tree.
            Of course this system can also be used for gameplay purposes: your hero-based game
            can change its style for the selected player character, or you can give different
            flavors to the sides in your team-based project.</paragraph>
        <section ids="basics-of-themes" names="basics\ of\ themes">
            <title>Basics of themes</title>
            <paragraph>The skinning system is driven by the <reference internal="True" refuri="../../classes/class_theme#class-theme"><inline classes="std std-ref">Theme</inline></reference> resource. Every
                Godot project has an inherent default theme that contains the settings used by
                the built-in control nodes. This is what gives the controls their distinct look
                out of the box. A theme only describes the configuration, however, and it is still
                the job of each individual control to use that configuration in the way it requires
                to display itself. This is important to remember when implementing
                <reference internal="True" refuri="custom_gui_controls#doc-custom-gui-controls"><inline classes="std std-ref">your own custom controls</inline></reference>.</paragraph>
            <note>
                <paragraph>Even the Godot editor itself relies on the default theme. But it doesn't look the
                    same as a Godot project, because it applies its own heavily customized theme on top
                    of the default one. In principle, this works exactly like it would in your game
                    as explained <reference internal="True" refid="doc-gui-theme-in-project"><inline classes="std std-ref">below</inline></reference>.</paragraph>
            </note>
            <section ids="theme-items" names="theme\ items">
                <title>Theme items</title>
                <paragraph>The configuration that is stored in a theme consists of theme items. Each item has
                    a unique name and must be one of the following data types:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><strong>Color</strong></paragraph>
                        <paragraph>A <reference internal="True" refuri="../../classes/class_color#class-color"><inline classes="std std-ref">color</inline></reference> value, which is often used for fonts
                            and backgrounds. Colors can also be used for modulation of controls
                            and icons.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Constant</strong></paragraph>
                        <paragraph>An integer value, which can be used either for numeric properties of
                            controls (such as the item separation in a <reference internal="True" refuri="../../classes/class_boxcontainer#class-boxcontainer"><inline classes="std std-ref">BoxContainer</inline></reference>),
                            or for boolean flags (such as the drawing of relationship lines in a <reference internal="True" refuri="../../classes/class_tree#class-tree"><inline classes="std std-ref">Tree</inline></reference>).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Font</strong></paragraph>
                        <paragraph>A <reference internal="True" refuri="../../classes/class_font#class-font"><inline classes="std std-ref">font</inline></reference> resource, which is used by controls that
                            display text. Fonts contain most text rendering settings, except for
                            its size and color. On top of that, alignment and text direction are
                            controlled by individual controls.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Font size</strong></paragraph>
                        <paragraph>An integer value, which is used alongside a font to determine the
                            size at which the text should be displayed.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>Icon</strong></paragraph>
                        <paragraph>A <reference internal="True" refuri="../../classes/class_texture2d#class-texture2d"><inline classes="std std-ref">texture</inline></reference> resource, which is normally used
                            to display an icon (on a <reference internal="True" refuri="../../classes/class_button#class-button"><inline classes="std std-ref">Button</inline></reference>, for example).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><strong>StyleBox</strong></paragraph>
                        <paragraph>A <reference internal="True" refuri="../../classes/class_stylebox#class-stylebox"><inline classes="std std-ref">StyleBox</inline></reference> resource, a collection of configuration
                            options which define the way a UI panel should be displayed. This is
                            not limited to the <reference internal="True" refuri="../../classes/class_panel#class-panel"><inline classes="std std-ref">Panel</inline></reference> control, as styleboxes
                            are used by many controls for their backgrounds and overlays.</paragraph>
                        <paragraph>Different controls will apply StyleBoxes in a different manner. Most notably,
                            <literal>focus</literal> styleboxes are drawn as an <emphasis>overlay</emphasis> to other styleboxes (such as
                            <literal>normal</literal> or <literal>pressed</literal>) to allow the base stylebox to remain visible.
                            This means the focus stylebox should be designed as an outline or translucent
                            box, so that its background can remain visible.</paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="theme-types" names="theme\ types">
                <title>Theme types</title>
                <paragraph>To help with the organization of its items each theme is separated into types,
                    and each item must belong to a single type. In other words, each theme item
                    is defined by its name, its data type and its theme type. This combination
                    must be unique within the theme. For example, there cannot be two color items named
                    <literal>font_color</literal> in a type called <literal>Label</literal>, but there can be another <literal>font_color</literal>
                    item in a type <literal>LineEdit</literal>.</paragraph>
                <paragraph>The default Godot theme comes with multiple theme types already defined,
                    one for every built-in control node that uses UI skinning. The example above
                    contains actual theme items present in the default theme. You can refer to the
                    <strong>Theme Properties</strong> section in the class reference for each control to see
                    which items are available to it and its child classes.</paragraph>
                <note>
                    <paragraph>Child classes can use theme items defined for their parent class (<literal>Button</literal>
                        and its derivatives being a good example of that). In fact, every control can
                        use every theme item of any theme type, if it needs to (but for the clarity and
                        predictability we try to avoid that in the engine).</paragraph>
                    <paragraph>It is important to remember that for child classes that process is automated.
                        Whenever a built-in control requests a theme item from the theme it can omit
                        the theme type, and its class name will be used instead. On top of that,
                        the class names of its parent classes will also be used in turn. This allows
                        changes to the parent class, such as <literal>Button</literal>, to affect all derived
                        classes without the need to customize every one of them.</paragraph>
                </note>
                <paragraph>You can also define your own theme types, and additionally customize both built-in
                    controls and your own controls. Because built-in controls have no knowledge of
                    your custom theme types, you must utilize scripts to access those items. All control
                    nodes have several methods that allow you to fetch theme items from the theme that
                    is applied to them. Those methods accept the theme type as one of the arguments.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var accent_color = get_theme_color("accent_color", "MyType")
label.add_theme_color_override("font_color", accent_color)</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Color accentColor = GetThemeColor("accent_color", "MyType");
label.AddThemeColorOverride("font_color", accentColor);</literal_block>
                    </div>
                </container>
                <paragraph>To give more customization opportunities types can also be linked together as
                    type variations. This is another use-case for custom theme types. For example,
                    a theme can contain a type <literal>Header</literal> which can be marked as a variation of
                    the base <literal>Label</literal> type. An individual <literal>Label</literal> control can then be set to
                    use the <literal>Header</literal> variation for its type, and every time a theme item is
                    requested from a theme this variation will be used before any other type. This
                    allows to store various presets of theme items for the same class of the
                    control node in the single <literal>Theme</literal> resource.</paragraph>
                <warning>
                    <paragraph>Only variations available from the default theme or defined in the custom
                        project theme are shown in the Inspector dock as options. You can still
                        input manually the name of a variation that is defined outside of those
                        two places, but it is recommended to keep all variations to the project theme.</paragraph>
                </warning>
                <paragraph>You can learn more about creating and using theme type variations in a
                    <reference internal="True" refuri="gui_theme_type_variations#doc-gui-theme-type-variations"><inline classes="std std-ref">dedicated article</inline></reference>.</paragraph>
            </section>
        </section>
        <section ids="customizing-a-control" names="customizing\ a\ control">
            <title>Customizing a control</title>
            <paragraph>Each control node can be customized directly without the use of themes. This
                is called local overrides. Every theme property from the control's class
                reference can be overridden directly on the control itself, using either
                the Inspector dock, or scripts. This allows to make granular changes to a
                particular part of the UI, while not affecting anything else in the project,
                including this control's children.</paragraph>
            <figure align="center">
                <image candidates="{'*': 'tutorials/ui/img/themecheck.webp'}" original_uri="img/themecheck.webp" uri="tutorials/ui/img/themecheck.webp"></image>
            </figure>
            <paragraph>Local overrides are less useful for the visual flair of your user interface,
                especially if you aim for consistency. However, for layout nodes these are
                essential. Nodes such as <reference internal="True" refuri="../../classes/class_boxcontainer#class-boxcontainer"><inline classes="std std-ref">BoxContainer</inline></reference> and
                <reference internal="True" refuri="../../classes/class_gridcontainer#class-gridcontainer"><inline classes="std std-ref">GridContainer</inline></reference> use theme constants for defining
                separation between their children, and <reference internal="True" refuri="../../classes/class_margincontainer#class-margincontainer"><inline classes="std std-ref">MarginContainer</inline></reference>
                stores its customizable margins in its theme items.</paragraph>
            <paragraph>Whenever a control has a local theme item override, this is the value that
                it uses. Values provided by the theme are ignored.</paragraph>
            <target refid="doc-gui-theme-in-project"></target>
        </section>
        <section ids="customizing-a-project doc-gui-theme-in-project" names="customizing\ a\ project doc_gui_theme_in_project">
            <title>Customizing a project</title>
            <paragraph>Out of the box each project adopts the default project theme provided by Godot. The
                default theme itself is constant and cannot be changed, but its items can be overridden
                with a custom theme. Custom themes can be applied in two ways: as a project setting,
                and as a node property throughout the tree of control nodes.</paragraph>
            <paragraph>There are two project settings that can be adjusted to affect your entire project:
                <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-gui-theme-custom"><inline classes="std std-ref">GUI &gt; Theme &gt; Custom</inline></reference> allows you to
                set a custom project-wide theme, and <reference internal="True" refuri="../../classes/class_projectsettings#class-projectsettings-property-gui-theme-custom-font"><inline classes="std std-ref">GUI &gt; Theme &gt; Custom Font</inline></reference>
                does the same to the default fallback font. When a theme item is requested by a control
                node the custom project theme, if present, is checked first. Only if it doesn't have
                the item the default theme is checked.</paragraph>
            <paragraph>This allows you to configure the default look of every Godot control with a single
                theme resource, but you can go more granular than that. Every control node also has
                a <reference internal="True" refuri="../../classes/class_control#class-control-property-theme"><inline classes="std std-ref">theme</inline></reference> property, which allows you to set a
                custom theme for the branch of nodes starting with that control. This means that the
                control and all of its children, and their children in turn, would first check that
                custom theme resource before falling back on the project and the default themes.</paragraph>
            <note>
                <paragraph>Instead of changing the project setting you can set the custom theme resource to the
                    root-most control node of your entire UI branch to almost the same effect. While in the
                    running project it will behave as expected, individual scenes will still display
                    using the default theme when previewing or running them directly. To fix that you
                    can set the same theme resource to the root control of each individual scene.</paragraph>
            </note>
            <paragraph>For example, you can have a certain style for buttons in your project theme, but want
                a different look for buttons inside of a popup dialog. You can set a custom theme
                resource to the root control of your popup and define a different style for buttons
                within that resource. As long as the chain of control nodes between the root of
                the popup and the buttons is uninterrupted, those buttons will use the styles defined
                in the theme resource that is closest to them. All other controls will still be styled
                using the project-wide theme and the default theme styles.</paragraph>
            <paragraph>To sum it up, for an arbitrary control its theme item lookup would look something
                like this:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Check for local overrides of the same data type and name.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Using control's type variation, class name and parent class names:</paragraph>
                    <enumerated_list enumtype="loweralpha" prefix="" suffix=".">
                        <list_item>
                            <paragraph>Check every control starting from itself and see if it has a theme property set;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>If it does, check that theme for the matching item of the same name, data and theme type;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>If there is no custom theme or it doesn't have the item, move to the parent control;</paragraph>
                        </list_item>
                        <list_item>
                            <paragraph>Repeat steps a-c. until the root of the tree is reached, or a non-control node is reached.</paragraph>
                        </list_item>
                    </enumerated_list>
                </list_item>
                <list_item>
                    <paragraph>Using control's type variation, class name and parent class names check the project-wide theme, if it's present.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Using control's type variation, class name and parent class names check the default theme.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>Even if the item doesn't exist in any theme, a corresponding default value for that
                data type will be returned.</paragraph>
        </section>
        <section ids="beyond-controls" names="beyond\ controls">
            <title>Beyond controls</title>
            <paragraph>Naturally, themes are an ideal type of resource for storing configuration for
                something visual. While the support for theming is built into control nodes,
                other nodes can use them as well, just like any other resource.</paragraph>
            <paragraph>An example of using themes for something beyond controls can be a modulation
                of sprites for the same units on different teams in a strategy game. A theme
                resource can define a collection of colors, and sprites (with a help from scripts)
                can use those colors to draw the texture. The main benefit being that you
                could make different themes using the same theme items for red, blue, and
                green teams, and swap them with a single resource change.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
