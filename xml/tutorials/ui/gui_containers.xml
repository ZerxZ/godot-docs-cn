<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/ui/gui_containers.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-gui-containers"></target>
    <section ids="using-containers doc-gui-containers" names="using\ containers doc_gui_containers">
        <title>Using Containers</title>
        <paragraph><reference internal="True" refuri="size_and_anchors#doc-size-and-anchors"><inline classes="std std-ref">Anchors</inline></reference> are an efficient way to handle
            different aspect ratios for basic multiple resolution handling in GUIs.</paragraph>
        <paragraph>For more complex user interfaces, they can become difficult to use.</paragraph>
        <paragraph>This is often the case of games, such as RPGs, online chats, tycoons or simulations. Another
            common case where more advanced layout features may be required is in-game tools (or simply just tools).</paragraph>
        <paragraph>All these situations require a more capable OS-like user interface, with advanced layout and formatting.
            For that, <reference internal="True" refuri="../../classes/class_container#class-container"><inline classes="std std-ref">Containers</inline></reference> are more useful.</paragraph>
        <section ids="container-layout" names="container\ layout">
            <title>Container layout</title>
            <paragraph>Containers provide a huge amount of layout power (as an example, the Godot editor user interface is entirely done using them):</paragraph>
            <block_quote>
                <image candidates="{'*': 'tutorials/ui/img/godot_containers.png'}" original_uri="img/godot_containers.png" uri="tutorials/ui/img/godot_containers.png"></image>
            </block_quote>
            <paragraph>When a <reference internal="True" refuri="../../classes/class_container#class-container"><inline classes="std std-ref">Container</inline></reference>-derived node is used, all children <reference internal="True" refuri="../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference> nodes give up their
                own positioning ability. This means the <emphasis>Container</emphasis> will control their positioning and any attempt to manually alter these
                nodes will be either ignored or invalidated the next time their parent is resized.</paragraph>
            <paragraph>Likewise, when a <emphasis>Container</emphasis> derived node is resized, all its children will be re-positioned according to it,
                with a behavior based on the type of container used:</paragraph>
            <block_quote>
                <image candidates="{'*': 'tutorials/ui/img/container_example.gif'}" original_uri="img/container_example.gif" uri="tutorials/ui/img/container_example.gif"></image>
            </block_quote>
            <paragraph>Example of <emphasis>HBoxContainer</emphasis> resizing children buttons.</paragraph>
            <paragraph>The real strength of containers is that they can be nested (as nodes), allowing the creation of very complex layouts that resize effortlessly.</paragraph>
        </section>
        <section ids="sizing-options" names="sizing\ options">
            <title>Sizing options</title>
            <paragraph>When adding a node to a container, the way the container treats each child depends mainly on their <emphasis>container sizing options</emphasis>. These options
                can be found by inspecting the layout of any <emphasis>Control</emphasis> that is a child of a <emphasis>Container</emphasis>.</paragraph>
            <block_quote>
                <image candidates="{'*': 'tutorials/ui/img/container_sizing_options.webp'}" original_uri="img/container_sizing_options.webp" uri="tutorials/ui/img/container_sizing_options.webp"></image>
            </block_quote>
            <paragraph>Sizing options are independent for vertical and horizontal sizing and not all containers make use of them (but most do):</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph><strong>Fill</strong>: Ensures the control <emphasis>fills</emphasis> the designated area within the container. No matter if
                        a control <emphasis>expands</emphasis> or not (see below), it will only <emphasis>fill</emphasis> the designated area when this is toggled on (it is by default).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Expand</strong>: Attempts to use as much space as possible in the parent container (in each axis).
                        Controls that don't expand will be pushed away by those that do. Between expanding controls, the
                        amount of space they take from each other is determined by the <emphasis>Stretch Ratio</emphasis> (see below).
                        This option is only available when the parent Container is of the right type, for example the <emphasis>HBoxContainer</emphasis> has this option
                        for horizontal sizing.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Shrink Begin</strong> When expanding, try to remain at the left or top of the expanded
                        area.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Shrink Center</strong> When expanding, try to remain at the center of the expanded
                        area.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Shrink End</strong> When expanding, try to remain at the right or bottom of the expanded
                        area.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Stretch Ratio</strong>: The ratio of how much expanded controls take up the available space in relation to each
                        other. A control with "2", will take up twice as much available space as one with "1".</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Experimenting with these flags and different containers is recommended to get a better grasp on how they work.</paragraph>
        </section>
        <section ids="container-types" names="container\ types">
            <title>Container types</title>
            <paragraph>Godot provides several container types out of the box as they serve different purposes:</paragraph>
            <section ids="box-containers" names="box\ containers">
                <title>Box Containers</title>
                <paragraph>Arranges child controls vertically or horizontally (via <reference internal="True" refuri="../../classes/class_hboxcontainer#class-hboxcontainer"><inline classes="std std-ref">HBoxContainer</inline></reference> and
                    <reference internal="True" refuri="../../classes/class_vboxcontainer#class-vboxcontainer"><inline classes="std std-ref">VBoxContainer</inline></reference>). In the opposite of the designated direction
                    (as in, vertical for a horizontal container), it just expands the children.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_box.png'}" original_uri="img/containers_box.png" uri="tutorials/ui/img/containers_box.png"></image>
                </block_quote>
                <paragraph>These containers make use of the <emphasis>Stretch Ratio</emphasis> property for children with the <emphasis>Expand</emphasis> flag set.</paragraph>
            </section>
            <section ids="grid-container" names="grid\ container">
                <title>Grid Container</title>
                <paragraph>Arranges child controls in a grid layout (via <reference internal="True" refuri="../../classes/class_gridcontainer#class-gridcontainer"><inline classes="std std-ref">GridContainer</inline></reference>, amount
                    of columns must be specified). Uses both the vertical and horizontal expand flags.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_grid.png'}" original_uri="img/containers_grid.png" uri="tutorials/ui/img/containers_grid.png"></image>
                </block_quote>
            </section>
            <section ids="margin-container" names="margin\ container">
                <title>Margin Container</title>
                <paragraph>Child controls are expanded towards the bounds of this control (via
                    <reference internal="True" refuri="../../classes/class_margincontainer#class-margincontainer"><inline classes="std std-ref">MarginContainer</inline></reference>). Padding will be added on the margins
                    depending on the theme configuration.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_margin.png'}" original_uri="img/containers_margin.png" uri="tutorials/ui/img/containers_margin.png"></image>
                </block_quote>
                <paragraph>Again, keep in mind that the margins are a <emphasis>Theme</emphasis> value, so they need to be edited from the
                    constants overrides section of each control:</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_margin_constants.png'}" original_uri="img/containers_margin_constants.png" uri="tutorials/ui/img/containers_margin_constants.png"></image>
                </block_quote>
            </section>
            <section ids="tab-container" names="tab\ container">
                <title>Tab Container</title>
                <paragraph>Allows you to place several child controls stacked on top of each other (via
                    <reference internal="True" refuri="../../classes/class_tabcontainer#class-tabcontainer"><inline classes="std std-ref">TabContainer</inline></reference>), with only the <emphasis>current</emphasis> one visible.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_tab.png'}" original_uri="img/containers_tab.png" uri="tutorials/ui/img/containers_tab.png"></image>
                </block_quote>
                <paragraph>Changing the <emphasis>current</emphasis> one is done via tabs located at the top of the container, via clicking:</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_tab_click.gif'}" original_uri="img/containers_tab_click.gif" uri="tutorials/ui/img/containers_tab_click.gif"></image>
                </block_quote>
                <paragraph>The titles are generated from the node names by default (although they can be overridden via <emphasis>TabContainer</emphasis> API).</paragraph>
                <paragraph>Settings such as tab placement and <emphasis>StyleBox</emphasis> can be modified in the <emphasis>TabContainer</emphasis> theme overrides.</paragraph>
            </section>
            <section ids="split-container" names="split\ container">
                <title>Split Container</title>
                <paragraph>Accepts only one or two children controls, then places them side to side with a divisor
                    (via <reference internal="True" refuri="../../classes/class_hsplitcontainer#class-hsplitcontainer"><inline classes="std std-ref">HSplitContainer</inline></reference> and <reference internal="True" refuri="../../classes/class_vsplitcontainer#class-vsplitcontainer"><inline classes="std std-ref">VSplitContainer</inline></reference>).
                    Respects both horizontal and vertical flags, as well as <emphasis>Ratio</emphasis>.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_split.png'}" original_uri="img/containers_split.png" uri="tutorials/ui/img/containers_split.png"></image>
                </block_quote>
                <paragraph>The divisor can be dragged around to change the size relation between both children:</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_split_drag.gif'}" original_uri="img/containers_split_drag.gif" uri="tutorials/ui/img/containers_split_drag.gif"></image>
                </block_quote>
            </section>
            <section ids="panelcontainer" names="panelcontainer">
                <title>PanelContainer</title>
                <paragraph>A container that draws a <emphasis>StyleBox</emphasis>, then expands children to cover its whole area
                    (via <reference internal="True" refuri="../../classes/class_panelcontainer#class-panelcontainer"><inline classes="std std-ref">PanelContainer</inline></reference>, respecting the <emphasis>StyleBox</emphasis> margins).
                    It respects both the horizontal and vertical sizing options.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_panel.png'}" original_uri="img/containers_panel.png" uri="tutorials/ui/img/containers_panel.png"></image>
                </block_quote>
                <paragraph>This container is useful as a top-level control, or just to add custom backgrounds to sections of a layout.</paragraph>
            </section>
            <section ids="foldablecontainer" names="foldablecontainer">
                <title>FoldableContainer</title>
                <paragraph>A container that can be expanded/collapsed
                    (via <reference internal="True" refuri="../../classes/class_foldablecontainer#class-foldablecontainer"><inline classes="std std-ref">FoldableContainer</inline></reference>).
                    Child controls are hidden when it is collapsed.</paragraph>
            </section>
            <section ids="scrollcontainer" names="scrollcontainer">
                <title>ScrollContainer</title>
                <paragraph>Accepts a single child node. If the child node is bigger than the container, scrollbars will be added
                    to allow panning the node around (via <reference internal="True" refuri="../../classes/class_scrollcontainer#class-scrollcontainer"><inline classes="std std-ref">ScrollContainer</inline></reference>). Both
                    vertical and horizontal size options are respected, and the behavior can be turned on or off
                    per axis in the properties.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_scroll.png'}" original_uri="img/containers_scroll.png" uri="tutorials/ui/img/containers_scroll.png"></image>
                </block_quote>
                <paragraph>Mouse wheel and touch drag (when touch is available) are also valid ways to pan the child control around.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_center_pan.gif'}" original_uri="img/containers_center_pan.gif" uri="tutorials/ui/img/containers_center_pan.gif"></image>
                </block_quote>
                <paragraph>As in the example above, one of the most common ways to use this container is together with a <emphasis>VBoxContainer</emphasis> as child.</paragraph>
            </section>
            <section ids="aspectratiocontainer" names="aspectratiocontainer">
                <title>AspectRatioContainer</title>
                <paragraph>A container type that arranges its child controls in a way that preserves their proportions
                    automatically when the container is resized.
                    (via <reference internal="True" refuri="../../classes/class_aspectratiocontainer#class-aspectratiocontainer"><inline classes="std std-ref">AspectRatioContainer</inline></reference>).
                    It has multiple stretch modes, providing options for adjusting the child controls' sizes concerning the container:
                    "fill," "width control height," "height control width," and "cover."</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_aspectratio.webp'}" original_uri="img/containers_aspectratio.webp" uri="tutorials/ui/img/containers_aspectratio.webp"></image>
                </block_quote>
                <paragraph>It is useful when you have a container that needs to be dynamic and responsive to different screen sizes,
                    and you want the child elements to scale proportionally without losing their intended shapes.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_aspectratio_drag.webp'}" original_uri="img/containers_aspectratio_drag.webp" uri="tutorials/ui/img/containers_aspectratio_drag.webp"></image>
                </block_quote>
            </section>
            <section ids="flowcontainer" names="flowcontainer">
                <title>FlowContainer</title>
                <paragraph>FlowContainer is a container that arranges its child controls either horizontally or vertically
                    (via <reference internal="True" refuri="../../classes/class_hflowcontainer#class-hflowcontainer"><inline classes="std std-ref">HFlowContainer</inline></reference> and via <reference internal="True" refuri="../../classes/class_vflowcontainer#class-vflowcontainer"><inline classes="std std-ref">VFlowContainer</inline></reference>).
                    When the available space runs out, it wraps the children to the next line or column, similar to how text wraps in a book.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_hflow.webp'}" original_uri="img/containers_hflow.webp" uri="tutorials/ui/img/containers_hflow.webp"></image>
                </block_quote>
                <paragraph>It is useful for creating flexible layouts where the child controls adjust automatically to the available space without overlapping.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_hflow_drag.webp'}" original_uri="img/containers_hflow_drag.webp" uri="tutorials/ui/img/containers_hflow_drag.webp"></image>
                </block_quote>
            </section>
            <section ids="centercontainer" names="centercontainer">
                <title>CenterContainer</title>
                <paragraph>CenterContainer is a container that automatically keeps all of its child controls centered within it at their minimum size.
                    It ensures that the child controls are always aligned to the center, making it easier to create centered layouts without manual positioning
                    (via <reference internal="True" refuri="../../classes/class_centercontainer#class-centercontainer"><inline classes="std std-ref">CenterContainer</inline></reference>).</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_center.webp'}" original_uri="img/containers_center.webp" uri="tutorials/ui/img/containers_center.webp"></image>
                    <image candidates="{'*': 'tutorials/ui/img/containers_center_drag.webp'}" original_uri="img/containers_center_drag.webp" uri="tutorials/ui/img/containers_center_drag.webp"></image>
                </block_quote>
            </section>
            <section ids="subviewportcontainer" names="subviewportcontainer">
                <title>SubViewportContainer</title>
                <paragraph>This is a special control that will only accept a single <emphasis>Viewport</emphasis> node as child, and it will display
                    it as if it was an image (via <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainer</inline></reference>).</paragraph>
            </section>
        </section>
        <section ids="creating-custom-containers" names="creating\ custom\ containers">
            <title>Creating custom Containers</title>
            <paragraph>It is possible to create a custom container using a script.
                Here is an example of a container that fits children to its size:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Container

func _notification(what):
    if what == NOTIFICATION_SORT_CHILDREN:
        # Must re-sort the children
        for c in get_children():
            # Fit to own size
            fit_child_in_rect(c, Rect2(Vector2(), size))

func set_some_setting():
    # Some setting changed, ask for children re-sort.
    queue_sort()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class CustomContainer : Container
{
    public override void _Notification(int what)
    {
        if (what == NotificationSortChildren)
        {
            // Must re-sort the children
            foreach (Control c in GetChildren())
            {
                // Fit to own size
                FitChildInRect(c, new Rect2(new Vector2(), Size));
            }
        }
    }

    public void SetSomeSetting()
    {
        // Some setting changed, ask for children re-sort.
        QueueSort();
    }
}</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
