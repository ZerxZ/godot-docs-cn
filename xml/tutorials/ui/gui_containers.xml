<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/tutorials/ui/gui_containers.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-gui-containers"></target>
    <section ids="using-containers doc-gui-containers" names="using\ containers 使用容器 doc_gui_containers">
        <title>使用容器</title>
        <paragraph><reference internal="True" refuri="size_and_anchors#doc-size-and-anchors"><inline classes="std std-ref">Anchors</inline></reference> 是 GUI 中处理基本多分辨率时应对不同纵横比的有效方法。</paragraph>
        <paragraph>对于更复杂的用户界面, 它们可能会变得难以使用.</paragraph>
        <paragraph>这通常是游戏的情况下, 如角色扮演类, 在线聊天, 大富翁类或模拟类游戏. 另一个需要更高级布局功能的常见情况是游戏内工具(或者仅仅是工具).</paragraph>
        <paragraph>这些情况需要一个更强大的类似操作系统的用户界面，具有先进的布局和格式。用 <reference internal="True" refuri="../../classes/class_container#class-container"><inline classes="std std-ref">Container</inline></reference> 会更方便。</paragraph>
        <section ids="container-layout" names="container\ layout 容器布局">
            <title>容器布局</title>
            <paragraph>容器提供了巨大的布局能力(例如,Godot编辑器的用户界面就是完全使用它们完成的):</paragraph>
            <block_quote>
                <image candidates="{'*': 'tutorials/ui/img/godot_containers.png'}" uri="tutorials/ui/img/godot_containers.png"></image>
            </block_quote>
            <paragraph>当使用 <reference internal="True" refuri="../../classes/class_container#class-container"><inline classes="std std-ref">Container</inline></reference> 派生的节点时，所有作为子项的 <reference internal="True" refuri="../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 节点都会放弃自我定位能力。这意味着<emphasis>容器</emphasis>将控制它们的位置，任何手动更改这些节点的尝试，都将在它们的父节点下一次调整大小时被忽略或失效。</paragraph>
            <paragraph>同样，调整 <emphasis>Container</emphasis> 派生节点的大小时，它的所有子节点都将根据它重新定位，其行为基于所用的容器类型：</paragraph>
            <block_quote>
                <image candidates="{'*': 'tutorials/ui/img/container_example.gif'}" uri="tutorials/ui/img/container_example.gif"></image>
            </block_quote>
            <paragraph><emphasis>HBoxContainer</emphasis> 调整子按钮大小的例子。</paragraph>
            <paragraph>容器的真正优势在于它们可以嵌套(作为节点), 允许创建非常复杂的布局, 调整毫不费力.</paragraph>
        </section>
        <section ids="sizing-options" names="sizing\ options 大小选项">
            <title>大小选项</title>
            <paragraph>When adding a node to a container, the way the container treats each child depends mainly on their <emphasis>container sizing options</emphasis>. These options
                can be found by inspecting the layout of any <emphasis>Control</emphasis> that is a child of a <emphasis>Container</emphasis>.</paragraph>
            <block_quote>
                <image candidates="{'*': 'tutorials/ui/img/container_sizing_options.webp'}" uri="tutorials/ui/img/container_sizing_options.webp"></image>
            </block_quote>
            <paragraph>Sizing options are independent for vertical and horizontal sizing and not all containers make use of them (but most do):</paragraph>
            <bullet_list bullet="*">
                <list_item>
                    <paragraph><strong>Fill填充</strong> : 确保控件 <emphasis>fills填充</emphasis> 容器内指定的区域. 无论控件是否 <emphasis>expands扩展</emphasis> (见下面), 当此选项被选中时(默认情况), 只 <emphasis>填充</emphasis> 指定区域.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Expand</strong>: Attempts to use as much space as possible in the parent container (in each axis).
                        Controls that don't expand will be pushed away by those that do. Between expanding controls, the
                        amount of space they take from each other is determined by the <emphasis>Stretch Ratio</emphasis> (see below).
                        This option is only available when the parent Container is of the right type, for example the <emphasis>HBoxContainer</emphasis> has this option
                        for horizontal sizing.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Shrink Begin</strong> When expanding, try to remain at the left or top of the expanded
                        area.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Shrink Center</strong> When expanding, try to remain at the center of the expanded
                        area.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Shrink End</strong> When expanding, try to remain at the right or bottom of the expanded
                        area.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Stretch Ratio</strong>: The ratio of how much expanded controls take up the available space in relation to each
                        other. A control with "2", will take up twice as much available space as one with "1".</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>建议使用这些标记和不同的容器进行试验, 以便更好地了解它们是如何工作的.</paragraph>
        </section>
        <section ids="container-types" names="container\ types 容器类型">
            <title>容器类型</title>
            <paragraph>Godot提供了几种开箱即用的容器类型, 因为它们有不同的用途:</paragraph>
            <section ids="box-containers" names="box\ containers 盒式容器">
                <title>盒式容器</title>
                <paragraph>将子控件垂直或者水平排列（使用 <reference internal="True" refuri="../../classes/class_hboxcontainer#class-hboxcontainer"><inline classes="std std-ref">HBoxContainer</inline></reference> 和 <reference internal="True" refuri="../../classes/class_vboxcontainer#class-vboxcontainer"><inline classes="std std-ref">VBoxContainer</inline></reference> ）。而在相对方向上（比如水平容器的垂直方向），子节点会被扩展。</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_box.png'}" uri="tutorials/ui/img/containers_box.png"></image>
                </block_quote>
                <paragraph>这些容器会用到设置了 <emphasis>Expand（扩展）</emphasis> 选项的子节点的 <emphasis>Ratio（比例）</emphasis> 属性。</paragraph>
            </section>
            <section ids="grid-container" names="grid\ container 网格容器">
                <title>网格容器</title>
                <paragraph>将子控件按照网格排列（使用 <reference internal="True" refuri="../../classes/class_gridcontainer#class-gridcontainer"><inline classes="std std-ref">GridContainer</inline></reference> ，必须指定列数），会同时用到垂直和水平扩展选项。</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_grid.png'}" uri="tutorials/ui/img/containers_grid.png"></image>
                </block_quote>
            </section>
            <section ids="margin-container" names="margin\ container 边距容器">
                <title>边距容器</title>
                <paragraph>将子节点扩展到该控件的边界（使用 <reference internal="True" refuri="../../classes/class_margincontainer#class-margincontainer"><inline classes="std std-ref">MarginContainer</inline></reference> ），会根据主题的设置来添加不同大小的边距。</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_margin.png'}" uri="tutorials/ui/img/containers_margin.png"></image>
                </block_quote>
                <paragraph>同样, 请记住, 边距是一个 <emphasis>Theme</emphasis> 值, 所以它们需要从每个控件的常量重写部分进行编辑:</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_margin_constants.png'}" uri="tutorials/ui/img/containers_margin_constants.png"></image>
                </block_quote>
            </section>
            <section ids="tab-container" names="tab\ container 选项卡容器">
                <title>选项卡容器</title>
                <paragraph>允许你将多个子控件堆叠在一起（使用 <reference internal="True" refuri="../../classes/class_tabcontainer#class-tabcontainer"><inline classes="std std-ref">TabContainer</inline></reference> ），只会显示 <emphasis>当前</emphasis> 控件。</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_tab.png'}" uri="tutorials/ui/img/containers_tab.png"></image>
                </block_quote>
                <paragraph>点击容器顶部的选项卡可以更改 <emphasis>当前</emphasis> 控件：</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_tab_click.gif'}" uri="tutorials/ui/img/containers_tab_click.gif"></image>
                </block_quote>
                <paragraph>标题默认是根据节点名称生成的（尽管可以通过 <emphasis>TabContainer</emphasis> 的 API 重写）。</paragraph>
                <paragraph>可以在 <emphasis>TabContainer</emphasis> 的主题覆盖项中修改类似选项卡位置和 <emphasis>StyleBox</emphasis> 等设置。</paragraph>
            </section>
            <section ids="split-container" names="split\ container 拆分容器">
                <title>拆分容器</title>
                <paragraph>只接受单个或者两个子控件，会将它们相邻放置，中间是分隔线（使用 <reference internal="True" refuri="../../classes/class_hsplitcontainer#class-hsplitcontainer"><inline classes="std std-ref">HSplitContainer</inline></reference> 和 <reference internal="True" refuri="../../classes/class_vsplitcontainer#class-vsplitcontainer"><inline classes="std std-ref">VSplitContainer</inline></reference> ），会使用到水平和垂直选项以及 <emphasis>Ratio</emphasis> 属性。</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_split.png'}" uri="tutorials/ui/img/containers_split.png"></image>
                </block_quote>
                <paragraph>可以通过拖动分隔线来调整两个子节点所占区域的大小：</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_split_drag.gif'}" uri="tutorials/ui/img/containers_split_drag.gif"></image>
                </block_quote>
            </section>
            <section ids="panelcontainer" names="panelcontainer">
                <title>PanelContainer</title>
                <paragraph>A container that draws a <emphasis>StyleBox</emphasis>, then expands children to cover its whole area
                    (via <reference internal="True" refuri="../../classes/class_panelcontainer#class-panelcontainer"><inline classes="std std-ref">PanelContainer</inline></reference>, respecting the <emphasis>StyleBox</emphasis> margins).
                    It respects both the horizontal and vertical sizing options.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_panel.png'}" uri="tutorials/ui/img/containers_panel.png"></image>
                </block_quote>
                <paragraph>这个容器作为顶层非常有用, 或者只是为布局各个部分添加自定义背景.</paragraph>
            </section>
            <section ids="scrollcontainer" names="scrollcontainer">
                <title>ScrollContainer</title>
                <paragraph>Accepts a single child node. If this node is bigger than the container, scrollbars will be added
                    to allow panning the node around (via <reference internal="True" refuri="../../classes/class_scrollcontainer#class-scrollcontainer"><inline classes="std std-ref">ScrollContainer</inline></reference>). Both
                    vertical and horizontal size options are respected, and the behavior can be turned on or off
                    per axis in the properties.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_scroll.png'}" uri="tutorials/ui/img/containers_scroll.png"></image>
                </block_quote>
                <paragraph>鼠标滚轮和触摸拖动(当触摸可用时)也是平移子控件的有效方法.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_center_pan.gif'}" uri="tutorials/ui/img/containers_center_pan.gif"></image>
                </block_quote>
                <paragraph>正如上面的例子中所展示的，使用此容器最常见的方法之一，是将 <emphasis>VBoxContainer</emphasis> 作为子容器一起使用。</paragraph>
            </section>
            <section ids="aspectratiocontainer" names="aspectratiocontainer">
                <title>AspectRatioContainer</title>
                <paragraph>A container type that arranges its child controls in a way that preserves their proportions
                    automatically when the container is resized.
                    (via <reference internal="True" refuri="../../classes/class_aspectratiocontainer#class-aspectratiocontainer"><inline classes="std std-ref">AspectRatioContainer</inline></reference>).
                    It has multiple stretch modes, providing options for adjusting the child controls' sizes concerning the container:
                    "fill," "width control height," "height control width," and "cover."</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_aspectratio.webp'}" uri="tutorials/ui/img/containers_aspectratio.webp"></image>
                </block_quote>
                <paragraph>useful when you have a container that needs to be dynamic and responsive to different screen sizes,
                    and you want the child elements to scale proportionally without losing their intended shapes.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_aspectratio_drag.webp'}" uri="tutorials/ui/img/containers_aspectratio_drag.webp"></image>
                </block_quote>
            </section>
            <section ids="flowcontainer" names="flowcontainer">
                <title>FlowContainer</title>
                <paragraph>FlowContainer is a container that arranges its child controls either horizontally or vertically,
                    (via <reference internal="True" refuri="../../classes/class_hflowcontainer#class-hflowcontainer"><inline classes="std std-ref">HFlowContainer</inline></reference> and via <reference internal="True" refuri="../../classes/class_vflowcontainer#class-vflowcontainer"><inline classes="std std-ref">VFlowContainer</inline></reference>).
                    and when the available space runs out, it wraps the children to the next line or column, similar to how text wraps in a book.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_hflow.webp'}" uri="tutorials/ui/img/containers_hflow.webp"></image>
                </block_quote>
                <paragraph>useful for creating flexible layouts where the child controls adjust automatically to the available space without overlapping.</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_hflow_drag.webp'}" uri="tutorials/ui/img/containers_hflow_drag.webp"></image>
                </block_quote>
            </section>
            <section ids="centercontainer" names="centercontainer">
                <title>CenterContainer</title>
                <paragraph>CenterContainer is a container that automatically keeps all of its child controls centered within it at their minimum size.
                    It ensures that the child controls are always aligned to the center, making it easier to create centered layouts without manual positioning.
                    (via <reference internal="True" refuri="../../classes/class_centercontainer#class-centercontainer"><inline classes="std std-ref">CenterContainer</inline></reference>).</paragraph>
                <block_quote>
                    <image candidates="{'*': 'tutorials/ui/img/containers_center.webp'}" uri="tutorials/ui/img/containers_center.webp"></image>
                    <image candidates="{'*': 'tutorials/ui/img/containers_center_drag.webp'}" uri="tutorials/ui/img/containers_center_drag.webp"></image>
                </block_quote>
            </section>
            <section ids="subviewportcontainer" names="subviewportcontainer">
                <title>SubViewportContainer</title>
                <paragraph>This is a special control that will only accept a single <emphasis>Viewport</emphasis> node as child, and it will display
                    it as if it was an image (via <reference internal="True" refuri="../../classes/class_subviewportcontainer#class-subviewportcontainer"><inline classes="std std-ref">SubViewportContainer</inline></reference>).</paragraph>
            </section>
        </section>
        <section ids="creating-custom-containers" names="creating\ custom\ containers 创建自定义容器">
            <title>创建自定义容器</title>
            <paragraph>It is possible to create a custom container using a script.
                Here is an example of a container that fits children to its rect size:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Container

func _notification(what):
    if what == NOTIFICATION_SORT_CHILDREN:
        # Must re-sort the children
        for c in get_children():
            # Fit to own size
            fit_child_in_rect(c, Rect2(Vector2(), rect_size))

func set_some_setting():
    # Some setting changed, ask for children re-sort.
    queue_sort()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class CustomContainer : Container
{
    public override void _Notification(int what)
    {
        if (what == NotificationSortChildren)
        {
            // Must re-sort the children
            foreach (Control c in GetChildren())
            {
                // Fit to own size
                FitChildInRect(c, new Rect2(new Vector2(), RectSize));
            }
        }
    }

    public void SetSomeSetting()
    {
        // Some setting changed, ask for children re-sort.
        QueueSort();
    }
}</literal_block>
                </div>
            </container>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
