<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_signal.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/master/doc/classes/Signal.xml.</comment>
    <target refid="class-signal"></target>
    <section ids="signal class-signal" names="signal class_signal">
        <title>Signal</title>
        <paragraph>A built-in type representing a signal of an <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference>.</paragraph>
        <section classes="classref-introduction-group" ids="description" names="description">
            <title>Description</title>
            <paragraph><strong>Signal</strong> is a built-in <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> type that represents a signal of an <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference> instance. Like all <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> types, it can be stored in variables and passed to functions. Signals allow all connected <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>s (and by extension their respective objects) to listen and react to events, without directly referencing one another. This keeps the code flexible and easier to manage. You can check whether an <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference> has a given signal name using <reference internal="True" refuri="class_object#class-object-method-has-signal"><inline classes="std std-ref">Object.has_signal()</inline></reference>.</paragraph>
            <paragraph>In GDScript, signals can be declared with the <literal>signal</literal> keyword. In C#, you may use the <literal>[Signal]</literal> attribute on a delegate.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">signal attacked

# Additional arguments may be declared.
# These arguments must be passed when the signal is emitted.
signal item_dropped(item_name, amount)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Signal]
delegate void AttackedEventHandler();

// Additional arguments may be declared.
// These arguments must be passed when the signal is emitted.
[Signal]
delegate void ItemDroppedEventHandler(string itemName, int amount);</literal_block>
                </div>
            </container>
            <paragraph>Connecting signals is one of the most common operations in Godot and the API gives many options to do so, which are described further down. The code block below shows the recommended approach.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    var button = Button.new()
    # `button_down` here is a Signal Variant type. We therefore call the Signal.connect() method, not Object.connect().
    # See discussion below for a more in-depth overview of the API.
    button.button_down.connect(_on_button_down)

    # This assumes that a `Player` class exists, which defines a `hit` signal.
    var player = Player.new()
    # We use Signal.connect() again, and we also use the Callable.bind() method,
    # which returns a new Callable with the parameter binds.
    player.hit.connect(_on_player_hit.bind("sword", 100))

func _on_button_down():
    print("Button down!")

func _on_player_hit(weapon_type, damage):
    print("Hit with weapon %s for %d damage." % [weapon_type, damage])</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    var button = new Button();
    // C# supports passing signals as events, so we can use this idiomatic construct:
    button.ButtonDown += OnButtonDown;

    // This assumes that a `Player` class exists, which defines a `Hit` signal.
    var player = new Player();
    // We can use lambdas when we need to bind additional parameters.
    player.Hit += () =&gt; OnPlayerHit("sword", 100);
}

private void OnButtonDown()
{
    GD.Print("Button down!");
}

private void OnPlayerHit(string weaponType, int damage)
{
    GD.Print($"Hit with weapon {weaponType} for {damage} damage.");
}</literal_block>
                </div>
            </container>
            <paragraph><strong>``Object.connect()`` or ``Signal.connect()``?</strong></paragraph>
            <paragraph>As seen above, the recommended method to connect signals is not <reference internal="True" refuri="class_object#class-object-method-connect"><inline classes="std std-ref">Object.connect()</inline></reference>. The code block below shows the four options for connecting signals, using either this legacy method or the recommended <reference internal="True" refid="class-signal-method-connect"><inline classes="std std-ref">connect()</inline></reference>, and using either an implicit <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> or a manually defined one.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    var button = Button.new()
    # Option 1: Object.connect() with an implicit Callable for the defined function.
    button.connect("button_down", _on_button_down)
    # Option 2: Object.connect() with a constructed Callable using a target object and method name.
    button.connect("button_down", Callable(self, "_on_button_down"))
    # Option 3: Signal.connect() with an implicit Callable for the defined function.
    button.button_down.connect(_on_button_down)
    # Option 4: Signal.connect() with a constructed Callable using a target object and method name.
    button.button_down.connect(Callable(self, "_on_button_down"))

func _on_button_down():
    print("Button down!")</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    var button = new Button();
    // Option 1: In C#, we can use signals as events and connect with this idiomatic syntax:
    button.ButtonDown += OnButtonDown;
    // Option 2: GodotObject.Connect() with a constructed Callable from a method group.
    button.Connect(Button.SignalName.ButtonDown, Callable.From(OnButtonDown));
    // Option 3: GodotObject.Connect() with a constructed Callable using a target object and method name.
    button.Connect(Button.SignalName.ButtonDown, new Callable(this, MethodName.OnButtonDown));
}

private void OnButtonDown()
{
    GD.Print("Button down!");
}</literal_block>
                </div>
            </container>
            <paragraph>While all options have the same outcome (<literal>button</literal>'s <reference internal="True" refuri="class_basebutton#class-basebutton-signal-button-down"><inline classes="std std-ref">BaseButton.button_down</inline></reference> signal will be connected to <literal>_on_button_down</literal>), <strong>option 3</strong> offers the best validation: it will print a compile-time error if either the <literal>button_down</literal> <strong>Signal</strong> or the <literal>_on_button_down</literal> <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> are not defined. On the other hand, <strong>option 2</strong> only relies on string names and will only be able to validate either names at runtime: it will generate an error at runtime if <literal>"button_down"</literal> is not a signal, or if <literal>"_on_button_down"</literal> is not a method in the object <literal>self</literal>. The main reason for using options 1, 2, or 4 would be if you actually need to use strings (e.g. to connect signals programmatically based on strings read from a configuration file). Otherwise, option 3 is the recommended (and fastest) method.</paragraph>
            <paragraph><strong>Binding and passing parameters:</strong></paragraph>
            <paragraph>The syntax to bind parameters is through <reference internal="True" refuri="class_callable#class-callable-method-bind"><inline classes="std std-ref">Callable.bind()</inline></reference>, which returns a copy of the <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> with its parameters bound.</paragraph>
            <paragraph>When calling <reference internal="True" refid="class-signal-method-emit"><inline classes="std std-ref">emit()</inline></reference> or <reference internal="True" refuri="class_object#class-object-method-emit-signal"><inline classes="std std-ref">Object.emit_signal()</inline></reference>, the signal parameters can be also passed. The examples below show the relationship between these signal parameters and bound parameters.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    # This assumes that a `Player` class exists, which defines a `hit` signal.
    var player = Player.new()
    # Using Callable.bind().
    player.hit.connect(_on_player_hit.bind("sword", 100))

    # Parameters added when emitting the signal are passed first.
    player.hit.emit("Dark lord", 5)

# We pass two arguments when emitting (`hit_by`, `level`),
# and bind two more arguments when connecting (`weapon_type`, `damage`).
func _on_player_hit(hit_by, level, weapon_type, damage):
    print("Hit by %s (level %d) with weapon %s for %d damage." % [hit_by, level, weapon_type, damage])</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    // This assumes that a `Player` class exists, which defines a `Hit` signal.
    var player = new Player();
    // Using lambda expressions that create a closure that captures the additional parameters.
    // The lambda only receives the parameters defined by the signal's delegate.
    player.Hit += (hitBy, level) =&gt; OnPlayerHit(hitBy, level, "sword", 100);

    // Parameters added when emitting the signal are passed first.
    player.EmitSignal(SignalName.Hit, "Dark lord", 5);
}

// We pass two arguments when emitting (`hit_by`, `level`),
// and bind two more arguments when connecting (`weapon_type`, `damage`).
private void OnPlayerHit(string hitBy, int level, string weaponType, int damage)
{
    GD.Print($"Hit by {hitBy} (level {level}) with weapon {weaponType} for {damage} damage.");
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph>There are notable differences when using this API with C#. See <reference internal="True" refuri="../tutorials/scripting/c_sharp/c_sharp_differences#doc-c-sharp-differences"><inline classes="std std-ref">C# API differences to GDScript</inline></reference> for more information.</paragraph>
            </note>
        </section>
        <section classes="classref-introduction-group" ids="tutorials" names="tutorials">
            <title>Tutorials</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../getting_started/step_by_step/signals"><inline classes="doc">Using Signals</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="GDScript Basics" refuri="../tutorials/scripting/gdscript/gdscript_basics.html#signals">GDScript Basics</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section classes="classref-reftable-group" ids="constructors" names="constructors">
            <title>Constructors</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="29"></colspec>
                    <colspec colwidth="138"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal"><inline classes="std std-ref">Signal</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-constructor-signal"><inline classes="std std-ref">Signal</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal"><inline classes="std std-ref">Signal</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-constructor-signal"><inline classes="std std-ref">Signal</inline></reference>(from: <reference internal="True" refid="class-signal"><inline classes="std std-ref">Signal</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal"><inline classes="std std-ref">Signal</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-constructor-signal"><inline classes="std std-ref">Signal</inline></reference>(object: <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference>, signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="methods" names="methods">
            <title>Methods</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="37"></colspec>
                    <colspec colwidth="130"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-method-connect"><inline classes="std std-ref">connect</inline></reference>(callable: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, flags: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-method-disconnect"><inline classes="std std-ref">disconnect</inline></reference>(callable: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-method-emit"><inline classes="std std-ref">emit</inline></reference>(...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-method-get-connections"><inline classes="std std-ref">get_connections</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-method-get-name"><inline classes="std std-ref">get_name</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-method-get-object"><inline classes="std std-ref">get_object</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-method-get-object-id"><inline classes="std std-ref">get_object_id</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-method-has-connections"><inline classes="std std-ref">has_connections</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-method-is-connected"><inline classes="std std-ref">is_connected</inline></reference>(callable: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-method-is-null"><inline classes="std std-ref">is_null</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="operators" names="operators">
            <title>Operators</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="25"></colspec>
                    <colspec colwidth="97"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-operator-neq-signal"><inline classes="std std-ref">operator !=</inline></reference>(right: <reference internal="True" refid="class-signal"><inline classes="std std-ref">Signal</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-signal-operator-eq-signal"><inline classes="std std-ref">operator ==</inline></reference>(right: <reference internal="True" refid="class-signal"><inline classes="std std-ref">Signal</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="constructor-descriptions" names="constructor\ descriptions">
            <title>Constructor Descriptions</title>
            <target refid="class-signal-constructor-signal"></target>
            <paragraph classes="classref-constructor" ids="class-signal-constructor-signal" names="class_signal_constructor_signal"><reference internal="True" refid="class-signal"><inline classes="std std-ref">Signal</inline></reference> <strong>Signal</strong>() <reference internal="True" refid="class-signal-constructor-signal"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Constructs an empty <strong>Signal</strong> with no object nor signal name bound.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-signal"><inline classes="std std-ref">Signal</inline></reference> <strong>Signal</strong>(from: <reference internal="True" refid="class-signal"><inline classes="std std-ref">Signal</inline></reference>)</paragraph>
            <paragraph>Constructs a <strong>Signal</strong> as a copy of the given <strong>Signal</strong>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-signal"><inline classes="std std-ref">Signal</inline></reference> <strong>Signal</strong>(object: <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference>, signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
            <paragraph>Creates a <strong>Signal</strong> object referencing a signal named <literal>signal</literal> in the specified <literal>object</literal>.</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="method-descriptions" names="method\ descriptions">
            <title>Method Descriptions</title>
            <target refid="class-signal-method-connect"></target>
            <paragraph classes="classref-method" ids="class-signal-method-connect" names="class_signal_method_connect"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>connect</strong>(callable: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, flags: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <reference internal="True" refid="class-signal-method-connect"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Connects this signal to the specified <literal>callable</literal>. Optional <literal>flags</literal> can be also added to configure the connection's behavior (see <reference internal="True" refuri="class_object#enum-object-connectflags"><inline classes="std std-ref">ConnectFlags</inline></reference> constants). You can provide additional arguments to the connected <literal>callable</literal> by using <reference internal="True" refuri="class_callable#class-callable-method-bind"><inline classes="std std-ref">Callable.bind()</inline></reference>.</paragraph>
            <paragraph>A signal can only be connected once to the same <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>. If the signal is already connected, this method returns <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-invalid-parameter"><inline classes="std std-ref">@GlobalScope.ERR_INVALID_PARAMETER</inline></reference> and generates an error, unless the signal is connected with <reference internal="True" refuri="class_object#class-object-constant-connect-reference-counted"><inline classes="std std-ref">Object.CONNECT_REFERENCE_COUNTED</inline></reference>. To prevent this, use <reference internal="True" refid="class-signal-method-is-connected"><inline classes="std std-ref">is_connected()</inline></reference> first to check for existing connections.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for button in $Buttons.get_children():
    button.pressed.connect(_on_pressed.bind(button))

func _on_pressed(button):
    print(button.name, " was pressed")</literal_block>
            <paragraph><strong>Note:</strong> If the <literal>callable</literal>'s object is freed, the connection will be lost.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-signal-method-disconnect"></target>
            <paragraph classes="classref-method" ids="class-signal-method-disconnect" names="class_signal_method_disconnect"><abbreviation explanation="No return value.">void</abbreviation> <strong>disconnect</strong>(callable: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <reference internal="True" refid="class-signal-method-disconnect"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Disconnects this signal from the specified <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>. If the connection does not exist, generates an error. Use <reference internal="True" refid="class-signal-method-is-connected"><inline classes="std std-ref">is_connected()</inline></reference> to make sure that the connection exists.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-signal-method-emit"></target>
            <paragraph classes="classref-method" ids="class-signal-method-emit" names="class_signal_method_emit"><abbreviation explanation="No return value.">void</abbreviation> <strong>emit</strong>(...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-signal-method-emit"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Emits this signal. All <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>s connected to this signal will be triggered. This method supports a variable number of arguments, so parameters can be passed as a comma separated list.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-signal-method-get-connections"></target>
            <paragraph classes="classref-method" ids="class-signal-method-get-connections" names="class_signal_method_get_connections"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> <strong>get_connections</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-signal-method-get-connections"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns an <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> of connections for this signal. Each connection is represented as a <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> that contains three entries:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>signal</literal> is a reference to this signal;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>callable</literal> is a reference to the connected <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>flags</literal> is a combination of <reference internal="True" refuri="class_object#enum-object-connectflags"><inline classes="std std-ref">ConnectFlags</inline></reference>.</paragraph>
                </list_item>
            </bullet_list>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-signal-method-get-name"></target>
            <paragraph classes="classref-method" ids="class-signal-method-get-name" names="class_signal_method_get_name"><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>get_name</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-signal-method-get-name"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the name of this signal.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-signal-method-get-object"></target>
            <paragraph classes="classref-method" ids="class-signal-method-get-object" names="class_signal_method_get_object"><reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference> <strong>get_object</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-signal-method-get-object"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the object emitting this signal.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-signal-method-get-object-id"></target>
            <paragraph classes="classref-method" ids="class-signal-method-get-object-id" names="class_signal_method_get_object_id"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_object_id</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-signal-method-get-object-id"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the ID of the object emitting this signal (see <reference internal="True" refuri="class_object#class-object-method-get-instance-id"><inline classes="std std-ref">Object.get_instance_id()</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-signal-method-has-connections"></target>
            <paragraph classes="classref-method" ids="class-signal-method-has-connections" names="class_signal_method_has_connections"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>has_connections</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-signal-method-has-connections"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if any <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> is connected to this signal.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-signal-method-is-connected"></target>
            <paragraph classes="classref-method" ids="class-signal-method-is-connected" names="class_signal_method_is_connected"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_connected</strong>(callable: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-signal-method-is-connected"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the specified <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> is connected to this signal.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-signal-method-is-null"></target>
            <paragraph classes="classref-method" ids="class-signal-method-is-null" names="class_signal_method_is_null"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_null</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-signal-method-is-null"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if this <strong>Signal</strong> has no object and the signal name is empty. Equivalent to <literal>signal == Signal()</literal>.</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="operator-descriptions" names="operator\ descriptions">
            <title>Operator Descriptions</title>
            <target refid="class-signal-operator-neq-signal"></target>
            <paragraph classes="classref-operator" ids="class-signal-operator-neq-signal" names="class_signal_operator_neq_signal"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong>(right: <reference internal="True" refid="class-signal"><inline classes="std std-ref">Signal</inline></reference>) <reference internal="True" refid="class-signal-operator-neq-signal"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the signals do not share the same object and name.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-signal-operator-eq-signal"></target>
            <paragraph classes="classref-operator" ids="class-signal-operator-eq-signal" names="class_signal_operator_eq_signal"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong>(right: <reference internal="True" refid="class-signal"><inline classes="std std-ref">Signal</inline></reference>) <reference internal="True" refid="class-signal-operator-eq-signal"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if both signals share the same object and name.</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></substitution_definition>
            <substitution_definition names="required"><abbreviation explanation="This method is required to be overridden when extending its base class.">required</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="This method is used to construct a type.">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="This method describes a valid operator to use with this type as left-hand operand.">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="This value is an integer composed as a bitmask of the following flags.">BitField</abbreviation></substitution_definition>
            <substitution_definition names="void"><abbreviation explanation="No return value.">void</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
