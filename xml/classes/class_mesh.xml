<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_mesh.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/4.2/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/4.2/doc/classes/Mesh.xml.</comment>
    <target refid="class-mesh"></target>
    <section ids="mesh class-mesh" names="mesh class_mesh">
        <title>Mesh</title>
        <paragraph><strong>继承：</strong> <reference internal="True" refuri="class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> <strong>&lt;</strong> <reference internal="True" refuri="class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> <strong>&lt;</strong> <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference></paragraph>
        <paragraph><strong>派生：</strong> <reference internal="True" refuri="class_arraymesh#class-arraymesh"><inline classes="std std-ref">ArrayMesh</inline></reference>, <reference internal="True" refuri="class_immediatemesh#class-immediatemesh"><inline classes="std std-ref">ImmediateMesh</inline></reference>, <reference internal="True" refuri="class_placeholdermesh#class-placeholdermesh"><inline classes="std std-ref">PlaceholderMesh</inline></reference>, <reference internal="True" refuri="class_primitivemesh#class-primitivemesh"><inline classes="std std-ref">PrimitiveMesh</inline></reference></paragraph>
        <paragraph>一种包含基于顶点数组的几何资源。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>网格是一种包含了基于顶点数组的几何资源。网格被分为各种<emphasis>平面</emphasis>，每一个平面包含了一个完整的、单独的顶点数组和材质用来绘制它。通过明智的设计，一个由多个面组成的网格胜过单个面的，这是因为在3D编辑软件中，一个物体通常包含多种材质。</paragraph>
        </section>
        <section classes="classref-introduction-group" ids="id2" names="教程">
            <title>教程</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="3D 材质测试演示" refuri="https://godotengine.org/asset-library/asset/123">3D 材质测试演示</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="3D 动力学角色演示" refuri="https://godotengine.org/asset-library/asset/126">3D 动力学角色演示</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="3D 平台跳跃演示" refuri="https://godotengine.org/asset-library/asset/125">3D 平台跳跃演示</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="第三人称射击演示" refuri="https://godotengine.org/asset-library/asset/678">第三人称射击演示</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="属性">
            <title>属性</title>
            <table classes="colwidths-auto">
                <tgroup cols="3">
                    <colspec colwidth="33"></colspec>
                    <colspec colwidth="67"></colspec>
                    <colspec colwidth="20"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector2i#class-vector2i"><inline classes="std std-ref">Vector2i</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-property-lightmap-size-hint"><inline classes="std std-ref">lightmap_size_hint</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector2i(0, 0)</literal></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id4" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="59"></colspec>
                    <colspec colwidth="171"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_aabb#class-aabb"><inline classes="std std-ref">AABB</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-private-method-get-aabb"><inline classes="std std-ref">_get_aabb</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-private-method-get-blend-shape-count"><inline classes="std std-ref">_get_blend_shape_count</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-private-method-get-blend-shape-name"><inline classes="std std-ref">_get_blend_shape_name</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-private-method-get-surface-count"><inline classes="std std-ref">_get_surface_count</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-private-method-set-blend-shape-name"><inline classes="std std-ref">_set_blend_shape_name</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index, <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> name <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-private-method-surface-get-array-index-len"><inline classes="std std-ref">_surface_get_array_index_len</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-private-method-surface-get-array-len"><inline classes="std std-ref">_surface_get_array_len</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-private-method-surface-get-arrays"><inline classes="std std-ref">_surface_get_arrays</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array[]</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-private-method-surface-get-blend-shape-arrays"><inline classes="std std-ref">_surface_get_blend_shape_arrays</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-private-method-surface-get-format"><inline classes="std std-ref">_surface_get_format</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-private-method-surface-get-lods"><inline classes="std std-ref">_surface_get_lods</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_material#class-material"><inline classes="std std-ref">Material</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-private-method-surface-get-material"><inline classes="std std-ref">_surface_get_material</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-private-method-surface-get-primitive-type"><inline classes="std std-ref">_surface_get_primitive_type</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-private-method-surface-set-material"><inline classes="std std-ref">_surface_set_material</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index, <reference internal="True" refuri="class_material#class-material"><inline classes="std std-ref">Material</inline></reference> material <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_convexpolygonshape3d#class-convexpolygonshape3d"><inline classes="std std-ref">ConvexPolygonShape3D</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-method-create-convex-shape"><inline classes="std std-ref">create_convex_shape</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> clean=true, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> simplify=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh"><inline classes="std std-ref">Mesh</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-method-create-outline"><inline classes="std std-ref">create_outline</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> margin <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-method-create-placeholder"><inline classes="std std-ref">create_placeholder</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_concavepolygonshape3d#class-concavepolygonshape3d"><inline classes="std std-ref">ConcavePolygonShape3D</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-method-create-trimesh-shape"><inline classes="std std-ref">create_trimesh_shape</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_trianglemesh#class-trianglemesh"><inline classes="std std-ref">TriangleMesh</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-method-generate-triangle-mesh"><inline classes="std std-ref">generate_triangle_mesh</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_aabb#class-aabb"><inline classes="std std-ref">AABB</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-method-get-aabb"><inline classes="std std-ref">get_aabb</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-method-get-faces"><inline classes="std std-ref">get_faces</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-method-get-surface-count"><inline classes="std std-ref">get_surface_count</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-method-surface-get-arrays"><inline classes="std std-ref">surface_get_arrays</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> surf_idx <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array[]</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-method-surface-get-blend-shape-arrays"><inline classes="std std-ref">surface_get_blend_shape_arrays</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> surf_idx <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_material#class-material"><inline classes="std std-ref">Material</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-method-surface-get-material"><inline classes="std std-ref">surface_get_material</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> surf_idx <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-mesh-method-surface-set-material"><inline classes="std std-ref">surface_set_material</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> surf_idx, <reference internal="True" refuri="class_material#class-material"><inline classes="std std-ref">Material</inline></reference> material <strong>)</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id5" names="枚举">
            <title>枚举</title>
            <target refid="enum-mesh-primitivetype"></target>
            <paragraph classes="classref-enumeration" ids="enum-mesh-primitivetype" names="enum_mesh_primitivetype">enum <strong>PrimitiveType</strong>:</paragraph>
            <target refid="class-mesh-constant-primitive-points"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-primitive-points" names="class_mesh_constant_primitive_points"><reference internal="True" refid="enum-mesh-primitivetype"><inline classes="std std-ref">PrimitiveType</inline></reference> <strong>PRIMITIVE_POINTS</strong> = <literal>0</literal></paragraph>
            <paragraph>将数组渲染为点（一个顶点对应一个点）。</paragraph>
            <target refid="class-mesh-constant-primitive-lines"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-primitive-lines" names="class_mesh_constant_primitive_lines"><reference internal="True" refid="enum-mesh-primitivetype"><inline classes="std std-ref">PrimitiveType</inline></reference> <strong>PRIMITIVE_LINES</strong> = <literal>1</literal></paragraph>
            <paragraph>将数组渲染为线（每两个顶点创建一条连线）。</paragraph>
            <target refid="class-mesh-constant-primitive-line-strip"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-primitive-line-strip" names="class_mesh_constant_primitive_line_strip"><reference internal="True" refid="enum-mesh-primitivetype"><inline classes="std std-ref">PrimitiveType</inline></reference> <strong>PRIMITIVE_LINE_STRIP</strong> = <literal>2</literal></paragraph>
            <paragraph>将数组渲染为线条。</paragraph>
            <target refid="class-mesh-constant-primitive-triangles"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-primitive-triangles" names="class_mesh_constant_primitive_triangles"><reference internal="True" refid="enum-mesh-primitivetype"><inline classes="std std-ref">PrimitiveType</inline></reference> <strong>PRIMITIVE_TRIANGLES</strong> = <literal>3</literal></paragraph>
            <paragraph>将数组渲染为三角形（每三个顶点创建一个三角形）。</paragraph>
            <target refid="class-mesh-constant-primitive-triangle-strip"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-primitive-triangle-strip" names="class_mesh_constant_primitive_triangle_strip"><reference internal="True" refid="enum-mesh-primitivetype"><inline classes="std std-ref">PrimitiveType</inline></reference> <strong>PRIMITIVE_TRIANGLE_STRIP</strong> = <literal>4</literal></paragraph>
            <paragraph>将数组渲染为三角形条。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-mesh-arraytype"></target>
            <paragraph classes="classref-enumeration" ids="enum-mesh-arraytype" names="enum_mesh_arraytype">enum <strong>ArrayType</strong>:</paragraph>
            <target refid="class-mesh-constant-array-vertex"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-vertex" names="class_mesh_constant_array_vertex"><reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> <strong>ARRAY_VERTEX</strong> = <literal>0</literal></paragraph>
            <paragraph>顶点位置的 <reference internal="True" refuri="class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference>、<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference> 或 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-normal"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-normal" names="class_mesh_constant_array_normal"><reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> <strong>ARRAY_NORMAL</strong> = <literal>1</literal></paragraph>
            <paragraph>顶点法线的 <reference internal="True" refuri="class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-tangent"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-tangent" names="class_mesh_constant_array_tangent"><reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> <strong>ARRAY_TANGENT</strong> = <literal>2</literal></paragraph>
            <paragraph>顶点切线的 <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference>。4 个浮点数为一组表示一个元素，前 3 个浮点数确定切线，最后一个是为 -1 或 1 的副法线方向。</paragraph>
            <target refid="class-mesh-constant-array-color"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-color" names="class_mesh_constant_array_color"><reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> <strong>ARRAY_COLOR</strong> = <literal>3</literal></paragraph>
            <paragraph>顶点颜色的 <reference internal="True" refuri="class_packedcolorarray#class-packedcolorarray"><inline classes="std std-ref">PackedColorArray</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-tex-uv"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-tex-uv" names="class_mesh_constant_array_tex_uv"><reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> <strong>ARRAY_TEX_UV</strong> = <literal>4</literal></paragraph>
            <paragraph>UV 坐标的 <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-tex-uv2"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-tex-uv2" names="class_mesh_constant_array_tex_uv2"><reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> <strong>ARRAY_TEX_UV2</strong> = <literal>5</literal></paragraph>
            <paragraph>第二 UV 坐标的 <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-custom0"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-custom0" names="class_mesh_constant_array_custom0"><reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> <strong>ARRAY_CUSTOM0</strong> = <literal>6</literal></paragraph>
            <paragraph>包含自定义颜色通道 0。如果 <literal>(format &gt;&gt; Mesh.ARRAY_FORMAT_CUSTOM0_SHIFT) &amp; Mesh.ARRAY_FORMAT_CUSTOM_MASK</literal> 为 <reference internal="True" refid="class-mesh-constant-array-custom-rgba8-unorm"><inline classes="std std-ref">ARRAY_CUSTOM_RGBA8_UNORM</inline></reference>、<reference internal="True" refid="class-mesh-constant-array-custom-rgba8-unorm"><inline classes="std std-ref">ARRAY_CUSTOM_RGBA8_UNORM</inline></reference>、<reference internal="True" refid="class-mesh-constant-array-custom-rg-half"><inline classes="std std-ref">ARRAY_CUSTOM_RG_HALF</inline></reference> 或 <reference internal="True" refid="class-mesh-constant-array-custom-rgba-half"><inline classes="std std-ref">ARRAY_CUSTOM_RGBA_HALF</inline></reference>，则为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。否则为 <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-custom1"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-custom1" names="class_mesh_constant_array_custom1"><reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> <strong>ARRAY_CUSTOM1</strong> = <literal>7</literal></paragraph>
            <paragraph>包含自定义颜色通道 1。如果 <literal>(format &gt;&gt; Mesh.ARRAY_FORMAT_CUSTOM1_SHIFT) &amp; Mesh.ARRAY_FORMAT_CUSTOM_MASK</literal> 为 <reference internal="True" refid="class-mesh-constant-array-custom-rgba8-unorm"><inline classes="std std-ref">ARRAY_CUSTOM_RGBA8_UNORM</inline></reference>、<reference internal="True" refid="class-mesh-constant-array-custom-rgba8-unorm"><inline classes="std std-ref">ARRAY_CUSTOM_RGBA8_UNORM</inline></reference>、<reference internal="True" refid="class-mesh-constant-array-custom-rg-half"><inline classes="std std-ref">ARRAY_CUSTOM_RG_HALF</inline></reference> 或 <reference internal="True" refid="class-mesh-constant-array-custom-rgba-half"><inline classes="std std-ref">ARRAY_CUSTOM_RGBA_HALF</inline></reference>，则为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。否则为 <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-custom2"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-custom2" names="class_mesh_constant_array_custom2"><reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> <strong>ARRAY_CUSTOM2</strong> = <literal>8</literal></paragraph>
            <paragraph>包含自定义颜色通道 2。如果 <literal>(format &gt;&gt; Mesh.ARRAY_FORMAT_CUSTOM2_SHIFT) &amp; Mesh.ARRAY_FORMAT_CUSTOM_MASK</literal> 为 <reference internal="True" refid="class-mesh-constant-array-custom-rgba8-unorm"><inline classes="std std-ref">ARRAY_CUSTOM_RGBA8_UNORM</inline></reference>、<reference internal="True" refid="class-mesh-constant-array-custom-rgba8-unorm"><inline classes="std std-ref">ARRAY_CUSTOM_RGBA8_UNORM</inline></reference>、<reference internal="True" refid="class-mesh-constant-array-custom-rg-half"><inline classes="std std-ref">ARRAY_CUSTOM_RG_HALF</inline></reference> 或 <reference internal="True" refid="class-mesh-constant-array-custom-rgba-half"><inline classes="std std-ref">ARRAY_CUSTOM_RGBA_HALF</inline></reference>，则为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。否则为 <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-custom3"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-custom3" names="class_mesh_constant_array_custom3"><reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> <strong>ARRAY_CUSTOM3</strong> = <literal>9</literal></paragraph>
            <paragraph>包含自定义颜色通道 3。如果 <literal>(format &gt;&gt; Mesh.ARRAY_FORMAT_CUSTOM3_SHIFT) &amp; Mesh.ARRAY_FORMAT_CUSTOM_MASK</literal> 为 <reference internal="True" refid="class-mesh-constant-array-custom-rgba8-unorm"><inline classes="std std-ref">ARRAY_CUSTOM_RGBA8_UNORM</inline></reference>、<reference internal="True" refid="class-mesh-constant-array-custom-rgba8-unorm"><inline classes="std std-ref">ARRAY_CUSTOM_RGBA8_UNORM</inline></reference>、<reference internal="True" refid="class-mesh-constant-array-custom-rg-half"><inline classes="std std-ref">ARRAY_CUSTOM_RG_HALF</inline></reference> 或 <reference internal="True" refid="class-mesh-constant-array-custom-rgba-half"><inline classes="std std-ref">ARRAY_CUSTOM_RGBA_HALF</inline></reference>，则为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。否则为 <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-bones"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-bones" names="class_mesh_constant_array_bones"><reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> <strong>ARRAY_BONES</strong> = <literal>10</literal></paragraph>
            <paragraph>骨骼索引的 <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference> 或 <reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference>。每个顶点包含 4 个还是 8 个数字取决于是否存在 <reference internal="True" refid="class-mesh-constant-array-flag-use-8-bone-weights"><inline classes="std std-ref">ARRAY_FLAG_USE_8_BONE_WEIGHTS</inline></reference> 标志。</paragraph>
            <target refid="class-mesh-constant-array-weights"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-weights" names="class_mesh_constant_array_weights"><reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> <strong>ARRAY_WEIGHTS</strong> = <literal>11</literal></paragraph>
            <paragraph>骨骼权重的 <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference> 或 <reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference>，取值范围为 <literal>0.0</literal> 到 <literal>1.0</literal>（闭区间）。每个顶点包含 4 个还是 8 个数字取决于是否存在 <reference internal="True" refid="class-mesh-constant-array-flag-use-8-bone-weights"><inline classes="std std-ref">ARRAY_FLAG_USE_8_BONE_WEIGHTS</inline></reference> 标志。</paragraph>
            <target refid="class-mesh-constant-array-index"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-index" names="class_mesh_constant_array_index"><reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> <strong>ARRAY_INDEX</strong> = <literal>12</literal></paragraph>
            <paragraph>整数的 <reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference>，用作引用顶点、颜色、法线、切线、和纹理的索引。所有这些数组必须具有与顶点数组相同数量的元素。任何索引都不能超过顶点数组的大小。当该索引数组存在时，它会将函数置于“索引模式”，其中索引选择第 <emphasis>i</emphasis> 个顶点、法线、切线、颜色、UV 等。这意味着，如果想要沿着一条边有不同的法线或颜色，则必须复制这些顶点。</paragraph>
            <paragraph>对于三角形，索引数组被解释为三元组，指代每个三角形的顶点。对于线条，索引数组成对表示每条线的开始和结束。</paragraph>
            <target refid="class-mesh-constant-array-max"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-max" names="class_mesh_constant_array_max"><reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> <strong>ARRAY_MAX</strong> = <literal>13</literal></paragraph>
            <paragraph>代表 <reference internal="True" refid="enum-mesh-arraytype"><inline classes="std std-ref">ArrayType</inline></reference> 枚举的大小。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-mesh-arraycustomformat"></target>
            <paragraph classes="classref-enumeration" ids="enum-mesh-arraycustomformat" names="enum_mesh_arraycustomformat">enum <strong>ArrayCustomFormat</strong>:</paragraph>
            <target refid="class-mesh-constant-array-custom-rgba8-unorm"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-custom-rgba8-unorm" names="class_mesh_constant_array_custom_rgba8_unorm"><reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference> <strong>ARRAY_CUSTOM_RGBA8_UNORM</strong> = <literal>0</literal></paragraph>
            <paragraph>表示该自定义通道包含的是无符号归一化字节颜色，范围为 0 到 1，编码为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-custom-rgba8-snorm"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-custom-rgba8-snorm" names="class_mesh_constant_array_custom_rgba8_snorm"><reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference> <strong>ARRAY_CUSTOM_RGBA8_SNORM</strong> = <literal>1</literal></paragraph>
            <paragraph>表示该自定义通道包含的是有符号归一化字节颜色，范围为 -1 到 1，编码为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-custom-rg-half"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-custom-rg-half" names="class_mesh_constant_array_custom_rg_half"><reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference> <strong>ARRAY_CUSTOM_RG_HALF</strong> = <literal>2</literal></paragraph>
            <paragraph>表示该自定义通道包含的是半精度浮点数颜色，编码为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。仅使用红、绿通道。</paragraph>
            <target refid="class-mesh-constant-array-custom-rgba-half"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-custom-rgba-half" names="class_mesh_constant_array_custom_rgba_half"><reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference> <strong>ARRAY_CUSTOM_RGBA_HALF</strong> = <literal>3</literal></paragraph>
            <paragraph>表示该自定义通道包含的是半精度浮点数颜色，编码为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-custom-r-float"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-custom-r-float" names="class_mesh_constant_array_custom_r_float"><reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference> <strong>ARRAY_CUSTOM_R_FLOAT</strong> = <literal>4</literal></paragraph>
            <paragraph>表示该自定义通道包含的是全精度浮点数颜色，使用 <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference>。仅使用红色通道。</paragraph>
            <target refid="class-mesh-constant-array-custom-rg-float"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-custom-rg-float" names="class_mesh_constant_array_custom_rg_float"><reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference> <strong>ARRAY_CUSTOM_RG_FLOAT</strong> = <literal>5</literal></paragraph>
            <paragraph>表示该自定义通道包含的是全精度浮点数颜色，使用 <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference>。仅使用红、绿通道。</paragraph>
            <target refid="class-mesh-constant-array-custom-rgb-float"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-custom-rgb-float" names="class_mesh_constant_array_custom_rgb_float"><reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference> <strong>ARRAY_CUSTOM_RGB_FLOAT</strong> = <literal>6</literal></paragraph>
            <paragraph>表示该自定义通道包含的是全精度浮点数颜色，使用 <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference>。仅使用红、绿、蓝通道。</paragraph>
            <target refid="class-mesh-constant-array-custom-rgba-float"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-custom-rgba-float" names="class_mesh_constant_array_custom_rgba_float"><reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference> <strong>ARRAY_CUSTOM_RGBA_FLOAT</strong> = <literal>7</literal></paragraph>
            <paragraph>表示该自定义通道包含的是全精度浮点数颜色，使用 <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-custom-max"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-custom-max" names="class_mesh_constant_array_custom_max"><reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference> <strong>ARRAY_CUSTOM_MAX</strong> = <literal>8</literal></paragraph>
            <paragraph>代表 <reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference> 枚举的大小。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-mesh-arrayformat"></target>
            <paragraph classes="classref-enumeration" ids="enum-mesh-arrayformat" names="enum_mesh_arrayformat">flags <strong>ArrayFormat</strong>:</paragraph>
            <target refid="class-mesh-constant-array-format-vertex"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-vertex" names="class_mesh_constant_array_format_vertex"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_VERTEX</strong> = <literal>1</literal></paragraph>
            <paragraph>网格数组包含顶点。所有网格都需要有顶点数组，所以这应该始终存在。</paragraph>
            <target refid="class-mesh-constant-array-format-normal"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-normal" names="class_mesh_constant_array_format_normal"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_NORMAL</strong> = <literal>2</literal></paragraph>
            <paragraph>网格数组包含法线。</paragraph>
            <target refid="class-mesh-constant-array-format-tangent"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-tangent" names="class_mesh_constant_array_format_tangent"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_TANGENT</strong> = <literal>4</literal></paragraph>
            <paragraph>网格数组包含切线。</paragraph>
            <target refid="class-mesh-constant-array-format-color"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-color" names="class_mesh_constant_array_format_color"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_COLOR</strong> = <literal>8</literal></paragraph>
            <paragraph>网格数组包含颜色。</paragraph>
            <target refid="class-mesh-constant-array-format-tex-uv"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-tex-uv" names="class_mesh_constant_array_format_tex_uv"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_TEX_UV</strong> = <literal>16</literal></paragraph>
            <paragraph>网格数组包含 UV。</paragraph>
            <target refid="class-mesh-constant-array-format-tex-uv2"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-tex-uv2" names="class_mesh_constant_array_format_tex_uv2"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_TEX_UV2</strong> = <literal>32</literal></paragraph>
            <paragraph>网格数组包含第二套 UV。</paragraph>
            <target refid="class-mesh-constant-array-format-custom0"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-custom0" names="class_mesh_constant_array_format_custom0"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_CUSTOM0</strong> = <literal>64</literal></paragraph>
            <paragraph>网格数组包含自定义通道索引 0。</paragraph>
            <target refid="class-mesh-constant-array-format-custom1"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-custom1" names="class_mesh_constant_array_format_custom1"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_CUSTOM1</strong> = <literal>128</literal></paragraph>
            <paragraph>网格数组包含自定义通道索引 1。</paragraph>
            <target refid="class-mesh-constant-array-format-custom2"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-custom2" names="class_mesh_constant_array_format_custom2"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_CUSTOM2</strong> = <literal>256</literal></paragraph>
            <paragraph>网格数组包含自定义通道索引 2。</paragraph>
            <target refid="class-mesh-constant-array-format-custom3"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-custom3" names="class_mesh_constant_array_format_custom3"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_CUSTOM3</strong> = <literal>512</literal></paragraph>
            <paragraph>网格数组包含自定义通道索引 3。</paragraph>
            <target refid="class-mesh-constant-array-format-bones"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-bones" names="class_mesh_constant_array_format_bones"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_BONES</strong> = <literal>1024</literal></paragraph>
            <paragraph>网格数组包含骨骼。</paragraph>
            <target refid="class-mesh-constant-array-format-weights"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-weights" names="class_mesh_constant_array_format_weights"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_WEIGHTS</strong> = <literal>2048</literal></paragraph>
            <paragraph>网格数组包含骨骼权重。</paragraph>
            <target refid="class-mesh-constant-array-format-index"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-index" names="class_mesh_constant_array_format_index"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_INDEX</strong> = <literal>4096</literal></paragraph>
            <paragraph>网格数组使用索引。</paragraph>
            <target refid="class-mesh-constant-array-format-blend-shape-mask"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-blend-shape-mask" names="class_mesh_constant_array_format_blend_shape_mask"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_BLEND_SHAPE_MASK</strong> = <literal>7</literal></paragraph>
            <paragraph>混合形状中允许使用的网格通道的掩码。</paragraph>
            <target refid="class-mesh-constant-array-format-custom-base"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-custom-base" names="class_mesh_constant_array_format_custom_base"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_CUSTOM_BASE</strong> = <literal>13</literal></paragraph>
            <paragraph>第一个自定义通道的移位量。</paragraph>
            <target refid="class-mesh-constant-array-format-custom-bits"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-custom-bits" names="class_mesh_constant_array_format_custom_bits"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_CUSTOM_BITS</strong> = <literal>3</literal></paragraph>
            <paragraph>每个自定义通道的格式位数。请参阅 <reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-format-custom0-shift"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-custom0-shift" names="class_mesh_constant_array_format_custom0_shift"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_CUSTOM0_SHIFT</strong> = <literal>13</literal></paragraph>
            <paragraph>自定义通道索引 0 需要对 <reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference> 进行的按位移动量。</paragraph>
            <target refid="class-mesh-constant-array-format-custom1-shift"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-custom1-shift" names="class_mesh_constant_array_format_custom1_shift"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_CUSTOM1_SHIFT</strong> = <literal>16</literal></paragraph>
            <paragraph>自定义通道索引 1 需要对 <reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference> 进行的按位移动量。</paragraph>
            <target refid="class-mesh-constant-array-format-custom2-shift"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-custom2-shift" names="class_mesh_constant_array_format_custom2_shift"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_CUSTOM2_SHIFT</strong> = <literal>19</literal></paragraph>
            <paragraph>自定义通道索引 2 需要对 <reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference> 进行的按位移动量。</paragraph>
            <target refid="class-mesh-constant-array-format-custom3-shift"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-custom3-shift" names="class_mesh_constant_array_format_custom3_shift"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_CUSTOM3_SHIFT</strong> = <literal>22</literal></paragraph>
            <paragraph>自定义通道索引 3 需要对 <reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference> 进行的按位移动量。</paragraph>
            <target refid="class-mesh-constant-array-format-custom-mask"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-format-custom-mask" names="class_mesh_constant_array_format_custom_mask"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FORMAT_CUSTOM_MASK</strong> = <literal>7</literal></paragraph>
            <paragraph>每个自定义通道的自定义格式位掩码。必须按 SHIFT 常量之一进行移位。请参阅 <reference internal="True" refid="enum-mesh-arraycustomformat"><inline classes="std std-ref">ArrayCustomFormat</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-compress-flags-base"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-compress-flags-base" names="class_mesh_constant_array_compress_flags_base"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_COMPRESS_FLAGS_BASE</strong> = <literal>25</literal></paragraph>
            <paragraph>第一个压缩标志的移位。压缩标志应该被传递给 <reference internal="True" refuri="class_arraymesh#class-arraymesh-method-add-surface-from-arrays"><inline classes="std std-ref">ArrayMesh.add_surface_from_arrays</inline></reference> 和 <reference internal="True" refuri="class_surfacetool#class-surfacetool-method-commit"><inline classes="std std-ref">SurfaceTool.commit</inline></reference>。</paragraph>
            <target refid="class-mesh-constant-array-flag-use-2d-vertices"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-flag-use-2d-vertices" names="class_mesh_constant_array_flag_use_2d_vertices"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FLAG_USE_2D_VERTICES</strong> = <literal>33554432</literal></paragraph>
            <paragraph>用于标记包含 2D 顶点的数组的标志。</paragraph>
            <target refid="class-mesh-constant-array-flag-use-dynamic-update"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-flag-use-dynamic-update" names="class_mesh_constant_array_flag_use_dynamic_update"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FLAG_USE_DYNAMIC_UPDATE</strong> = <literal>67108864</literal></paragraph>
            <paragraph>网格数据将在 GLES 上使用 <literal>GL_DYNAMIC_DRAW</literal> 的标记索引。在 Vulkan 上未被使用。</paragraph>
            <target refid="class-mesh-constant-array-flag-use-8-bone-weights"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-flag-use-8-bone-weights" names="class_mesh_constant_array_flag_use_8_bone_weights"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FLAG_USE_8_BONE_WEIGHTS</strong> = <literal>134217728</literal></paragraph>
            <paragraph>用于标记网格每个顶点最多包含 8 个骨骼影响的标志。该标志表示 <reference internal="True" refid="class-mesh-constant-array-bones"><inline classes="std std-ref">ARRAY_BONES</inline></reference> 和 <reference internal="True" refid="class-mesh-constant-array-weights"><inline classes="std std-ref">ARRAY_WEIGHTS</inline></reference> 元素将具有双倍长度。</paragraph>
            <target refid="class-mesh-constant-array-flag-uses-empty-vertex-array"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-flag-uses-empty-vertex-array" names="class_mesh_constant_array_flag_uses_empty_vertex_array"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY</strong> = <literal>268435456</literal></paragraph>
            <paragraph>用于标记网格有意不包含顶点数组的标志。</paragraph>
            <target refid="class-mesh-constant-array-flag-compress-attributes"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-array-flag-compress-attributes" names="class_mesh_constant_array_flag_compress_attributes"><reference internal="True" refid="enum-mesh-arrayformat"><inline classes="std std-ref">ArrayFormat</inline></reference> <strong>ARRAY_FLAG_COMPRESS_ATTRIBUTES</strong> = <literal>536870912</literal></paragraph>
            <paragraph>用于标记网格正在使用的压缩的属性（顶点、法线、切线、UV）的标志。启用这种形式的压缩后，顶点位置将被打包到 RGBA16UNORM 属性中，并在顶点着色器中进行缩放。法线和切线将被打包到表示一个轴的 RG16UNORM 中，并在顶点的 A 通道中存储一个 16 位浮点数。UV 将使用 16 位标准化浮点数而不是完整的 32 位有符号浮点数。使用该压缩模式时，必须使用顶点、法线、和切线或仅使用顶点。你无法使用没有切线的法线。如果可以的话，导入器将自动启用这种压缩。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-mesh-blendshapemode"></target>
            <paragraph classes="classref-enumeration" ids="enum-mesh-blendshapemode" names="enum_mesh_blendshapemode">enum <strong>BlendShapeMode</strong>:</paragraph>
            <target refid="class-mesh-constant-blend-shape-mode-normalized"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-blend-shape-mode-normalized" names="class_mesh_constant_blend_shape_mode_normalized"><reference internal="True" refid="enum-mesh-blendshapemode"><inline classes="std std-ref">BlendShapeMode</inline></reference> <strong>BLEND_SHAPE_MODE_NORMALIZED</strong> = <literal>0</literal></paragraph>
            <paragraph>混合形状是被归一化了的。</paragraph>
            <target refid="class-mesh-constant-blend-shape-mode-relative"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-mesh-constant-blend-shape-mode-relative" names="class_mesh_constant_blend_shape_mode_relative"><reference internal="True" refid="enum-mesh-blendshapemode"><inline classes="std std-ref">BlendShapeMode</inline></reference> <strong>BLEND_SHAPE_MODE_RELATIVE</strong> = <literal>1</literal></paragraph>
            <paragraph>混合形状是相对于基础的权重。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id6" names="属性说明">
            <title>属性说明</title>
            <target refid="class-mesh-property-lightmap-size-hint"></target>
            <paragraph classes="classref-property" ids="class-mesh-property-lightmap-size-hint" names="class_mesh_property_lightmap_size_hint"><reference internal="True" refuri="class_vector2i#class-vector2i"><inline classes="std std-ref">Vector2i</inline></reference> <strong>lightmap_size_hint</strong> = <literal>Vector2i(0, 0)</literal></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph>void <strong>set_lightmap_size_hint</strong> <strong>(</strong> <reference internal="True" refuri="class_vector2i#class-vector2i"><inline classes="std std-ref">Vector2i</inline></reference> value <strong>)</strong></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_vector2i#class-vector2i"><inline classes="std std-ref">Vector2i</inline></reference> <strong>get_lightmap_size_hint</strong> <strong>(</strong> <strong>)</strong></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>设置用于光照贴图分辨率的提示。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id7" names="方法说明">
            <title>方法说明</title>
            <target refid="class-mesh-private-method-get-aabb"></target>
            <paragraph classes="classref-method" ids="class-mesh-private-method-get-aabb" names="class_mesh_private_method__get_aabb"><reference internal="True" refuri="class_aabb#class-aabb"><inline classes="std std-ref">AABB</inline></reference> <strong>_get_aabb</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>虚方法，能够为扩展自 <strong>Mesh</strong> 的自定义类覆盖 <reference internal="True" refuri="class_aabb#class-aabb"><inline classes="std std-ref">AABB</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-private-method-get-blend-shape-count"></target>
            <paragraph classes="classref-method" ids="class-mesh-private-method-get-blend-shape-count" names="class_mesh_private_method__get_blend_shape_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>_get_blend_shape_count</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>虚方法，能够为扩展自 <strong>Mesh</strong> 的自定义类覆盖混合形状的数量。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-private-method-get-blend-shape-name"></target>
            <paragraph classes="classref-method" ids="class-mesh-private-method-get-blend-shape-name" names="class_mesh_private_method__get_blend_shape_name"><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>_get_blend_shape_name</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>虚方法，能够为扩展自 <strong>Mesh</strong> 的自定义类覆盖混合形状名称的获取过程。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-private-method-get-surface-count"></target>
            <paragraph classes="classref-method" ids="class-mesh-private-method-get-surface-count" names="class_mesh_private_method__get_surface_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>_get_surface_count</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>虚方法，能够为扩展自 <strong>Mesh</strong> 的自定义类覆盖表面的数量。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-private-method-set-blend-shape-name"></target>
            <paragraph classes="classref-method" ids="class-mesh-private-method-set-blend-shape-name" names="class_mesh_private_method__set_blend_shape_name">void <strong>_set_blend_shape_name</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index, <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> name <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
            <paragraph>虚方法，能够为扩展自 <strong>Mesh</strong> 的自定义类覆盖混合形状的名称。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-private-method-surface-get-array-index-len"></target>
            <paragraph classes="classref-method" ids="class-mesh-private-method-surface-get-array-index-len" names="class_mesh_private_method__surface_get_array_index_len"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>_surface_get_array_index_len</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>虚方法，能够为扩展自 <strong>Mesh</strong> 的自定义类覆盖表面数组索引的长度。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-private-method-surface-get-array-len"></target>
            <paragraph classes="classref-method" ids="class-mesh-private-method-surface-get-array-len" names="class_mesh_private_method__surface_get_array_len"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>_surface_get_array_len</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>虚方法，能够为扩展自 <strong>Mesh</strong> 的自定义类覆盖表面数组的长度。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-private-method-surface-get-arrays"></target>
            <paragraph classes="classref-method" ids="class-mesh-private-method-surface-get-arrays" names="class_mesh_private_method__surface_get_arrays"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> <strong>_surface_get_arrays</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>虚方法，能够为扩展自 <strong>Mesh</strong> 的自定义类覆盖表面数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-private-method-surface-get-blend-shape-arrays"></target>
            <paragraph classes="classref-method" ids="class-mesh-private-method-surface-get-blend-shape-arrays" names="class_mesh_private_method__surface_get_blend_shape_arrays"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array[]</inline></reference> <strong>_surface_get_blend_shape_arrays</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>虚方法，能够为扩展自 <strong>Mesh</strong> 的自定义类覆盖混合形状数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-private-method-surface-get-format"></target>
            <paragraph classes="classref-method" ids="class-mesh-private-method-surface-get-format" names="class_mesh_private_method__surface_get_format"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>_surface_get_format</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>虚方法，能够为扩展自 <strong>Mesh</strong> 的自定义类覆盖表面格式。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-private-method-surface-get-lods"></target>
            <paragraph classes="classref-method" ids="class-mesh-private-method-surface-get-lods" names="class_mesh_private_method__surface_get_lods"><reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> <strong>_surface_get_lods</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>虚方法，能够为扩展自 <strong>Mesh</strong> 的自定义类覆盖表面 LOD。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-private-method-surface-get-material"></target>
            <paragraph classes="classref-method" ids="class-mesh-private-method-surface-get-material" names="class_mesh_private_method__surface_get_material"><reference internal="True" refuri="class_material#class-material"><inline classes="std std-ref">Material</inline></reference> <strong>_surface_get_material</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>虚方法，能够为扩展自 <strong>Mesh</strong> 的自定义类覆盖表面材质。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-private-method-surface-get-primitive-type"></target>
            <paragraph classes="classref-method" ids="class-mesh-private-method-surface-get-primitive-type" names="class_mesh_private_method__surface_get_primitive_type"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>_surface_get_primitive_type</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>虚方法，能够为扩展自 <strong>Mesh</strong> 的自定义类覆盖表面图元类型。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-private-method-surface-set-material"></target>
            <paragraph classes="classref-method" ids="class-mesh-private-method-surface-set-material" names="class_mesh_private_method__surface_set_material">void <strong>_surface_set_material</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index, <reference internal="True" refuri="class_material#class-material"><inline classes="std std-ref">Material</inline></reference> material <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
            <paragraph>虚方法，能够为扩展自 <strong>Mesh</strong> 的自定义类覆盖索引为 <literal>index</literal> 的材质 <literal>material</literal> 的设置。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-method-create-convex-shape"></target>
            <paragraph classes="classref-method" ids="class-mesh-method-create-convex-shape" names="class_mesh_method_create_convex_shape"><reference internal="True" refuri="class_convexpolygonshape3d#class-convexpolygonshape3d"><inline classes="std std-ref">ConvexPolygonShape3D</inline></reference> <strong>create_convex_shape</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> clean=true, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> simplify=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>从网格计算 <reference internal="True" refuri="class_convexpolygonshape3d#class-convexpolygonshape3d"><inline classes="std std-ref">ConvexPolygonShape3D</inline></reference>。</paragraph>
            <paragraph>如果 <literal>clean</literal> 为 <literal>true</literal>（默认值），则自动移除重复顶点和内部顶点。如果不需要如此的化话，可以将其设置为 <literal>false</literal> 以加快处理速度。</paragraph>
            <paragraph>如果 <literal>simplify</literal> 为 <literal>true</literal>，则可以进一步简化几何体以减少顶点数。默认情况下是禁用的。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-method-create-outline"></target>
            <paragraph classes="classref-method" ids="class-mesh-method-create-outline" names="class_mesh_method_create_outline"><reference internal="True" refid="class-mesh"><inline classes="std std-ref">Mesh</inline></reference> <strong>create_outline</strong> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> margin <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>以一定的偏移量（边距)，计算出该网格的外轮廓。</paragraph>
            <paragraph><strong>注意：</strong>这个方法实际上反序返回顶点（例如输入顺时针，返回逆时针）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-method-create-placeholder"></target>
            <paragraph classes="classref-method" ids="class-mesh-method-create-placeholder" names="class_mesh_method_create_placeholder"><reference internal="True" refuri="class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> <strong>create_placeholder</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>创建该资源的占位符版本（<reference internal="True" refuri="class_placeholdermesh#class-placeholdermesh"><inline classes="std std-ref">PlaceholderMesh</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-method-create-trimesh-shape"></target>
            <paragraph classes="classref-method" ids="class-mesh-method-create-trimesh-shape" names="class_mesh_method_create_trimesh_shape"><reference internal="True" refuri="class_concavepolygonshape3d#class-concavepolygonshape3d"><inline classes="std std-ref">ConcavePolygonShape3D</inline></reference> <strong>create_trimesh_shape</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>从该网格计算出 <reference internal="True" refuri="class_concavepolygonshape3d#class-concavepolygonshape3d"><inline classes="std std-ref">ConcavePolygonShape3D</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-method-generate-triangle-mesh"></target>
            <paragraph classes="classref-method" ids="class-mesh-method-generate-triangle-mesh" names="class_mesh_method_generate_triangle_mesh"><reference internal="True" refuri="class_trianglemesh#class-trianglemesh"><inline classes="std std-ref">TriangleMesh</inline></reference> <strong>generate_triangle_mesh</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>从网格生成 <reference internal="True" refuri="class_trianglemesh#class-trianglemesh"><inline classes="std std-ref">TriangleMesh</inline></reference>。仅考虑使用以下图元类型的表面：<reference internal="True" refid="class-mesh-constant-primitive-triangles"><inline classes="std std-ref">PRIMITIVE_TRIANGLES</inline></reference>、<reference internal="True" refid="class-mesh-constant-primitive-triangle-strip"><inline classes="std std-ref">PRIMITIVE_TRIANGLE_STRIP</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-method-get-aabb"></target>
            <paragraph classes="classref-method" ids="class-mesh-method-get-aabb" names="class_mesh_method_get_aabb"><reference internal="True" refuri="class_aabb#class-aabb"><inline classes="std std-ref">AABB</inline></reference> <strong>get_aabb</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回局部空间中包围这个网格的最小 <reference internal="True" refuri="class_aabb#class-aabb"><inline classes="std std-ref">AABB</inline></reference>。不受 <literal>custom_aabb</literal> 的影响。</paragraph>
            <paragraph><strong>注意：</strong>只针对 <reference internal="True" refuri="class_arraymesh#class-arraymesh"><inline classes="std std-ref">ArrayMesh</inline></reference> 和 <reference internal="True" refuri="class_primitivemesh#class-primitivemesh"><inline classes="std std-ref">PrimitiveMesh</inline></reference> 进行了实现。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-method-get-faces"></target>
            <paragraph classes="classref-method" ids="class-mesh-method-get-faces" names="class_mesh_method_get_faces"><reference internal="True" refuri="class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference> <strong>get_faces</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回网格中所有构成面的顶点。每三个顶点代表一个三角形。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-method-get-surface-count"></target>
            <paragraph classes="classref-method" ids="class-mesh-method-get-surface-count" names="class_mesh_method_get_surface_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_surface_count</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回 <strong>Mesh</strong> 中存放的表面的数量。相当于 <reference internal="True" refuri="class_meshinstance3d#class-meshinstance3d-method-get-surface-override-material-count"><inline classes="std std-ref">MeshInstance3D.get_surface_override_material_count</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-method-surface-get-arrays"></target>
            <paragraph classes="classref-method" ids="class-mesh-method-surface-get-arrays" names="class_mesh_method_surface_get_arrays"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> <strong>surface_get_arrays</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> surf_idx <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回构成请求表面的顶点、法线、UV 等数组。（见 <reference internal="True" refuri="class_arraymesh#class-arraymesh-method-add-surface-from-arrays"><inline classes="std std-ref">ArrayMesh.add_surface_from_arrays</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-method-surface-get-blend-shape-arrays"></target>
            <paragraph classes="classref-method" ids="class-mesh-method-surface-get-blend-shape-arrays" names="class_mesh_method_surface_get_blend_shape_arrays"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array[]</inline></reference> <strong>surface_get_blend_shape_arrays</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> surf_idx <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回请求表面的混合形状数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-method-surface-get-material"></target>
            <paragraph classes="classref-method" ids="class-mesh-method-surface-get-material" names="class_mesh_method_surface_get_material"><reference internal="True" refuri="class_material#class-material"><inline classes="std std-ref">Material</inline></reference> <strong>surface_get_material</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> surf_idx <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回给定表面中的 <reference internal="True" refuri="class_material#class-material"><inline classes="std std-ref">Material</inline></reference>。表面是使用该材质渲染的。</paragraph>
            <paragraph><strong>注意：</strong>这将返回 <strong>Mesh</strong> 资源中的材质，而不是与 <reference internal="True" refuri="class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> 的表面材质覆盖属性关联的 <reference internal="True" refuri="class_material#class-material"><inline classes="std std-ref">Material</inline></reference>。要获取与 <reference internal="True" refuri="class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> 的表面材质覆盖属性关联的 <reference internal="True" refuri="class_material#class-material"><inline classes="std std-ref">Material</inline></reference>，请改用 <reference internal="True" refuri="class_meshinstance3d#class-meshinstance3d-method-get-surface-override-material"><inline classes="std std-ref">MeshInstance3D.get_surface_override_material</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-mesh-method-surface-set-material"></target>
            <paragraph classes="classref-method" ids="class-mesh-method-surface-set-material" names="class_mesh_method_surface_set_material">void <strong>surface_set_material</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> surf_idx, <reference internal="True" refuri="class_material#class-material"><inline classes="std std-ref">Material</inline></reference> material <strong>)</strong></paragraph>
            <paragraph>为给定表面设置 <reference internal="True" refuri="class_material#class-material"><inline classes="std std-ref">Material</inline></reference>。表面将使用该材质进行渲染。</paragraph>
            <paragraph><strong>注意：</strong>这会分配 <strong>Mesh</strong> 资源中的材质，而不是与 <reference internal="True" refuri="class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> 的表面材质覆盖属性关联的 <reference internal="True" refuri="class_material#class-material"><inline classes="std std-ref">Material</inline></reference>。要设置与 <reference internal="True" refuri="class_meshinstance3d#class-meshinstance3d"><inline classes="std std-ref">MeshInstance3D</inline></reference> 的表面材质覆盖属性关联的 <reference internal="True" refuri="class_material#class-material"><inline classes="std std-ref">Material</inline></reference>，请改用 <reference internal="True" refuri="class_meshinstance3d#class-meshinstance3d-method-set-surface-override-material"><inline classes="std std-ref">MeshInstance3D.set_surface_override_material</inline></reference>。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
