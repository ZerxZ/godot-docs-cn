<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_plane.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/4.2/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/4.2/doc/classes/Plane.xml.</comment>
    <target refid="class-plane"></target>
    <section ids="plane class-plane" names="plane class_plane">
        <title>Plane</title>
        <paragraph>使用黑塞范式的平面。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>代表归一化的平面方程。<reference internal="True" refid="class-plane-property-normal"><inline classes="std std-ref">normal</inline></reference> 是平面的法线（归一化的 a、b、c），而 <reference internal="True" refid="class-plane-property-d"><inline classes="std std-ref">d</inline></reference> 是原点到平面的距离（沿“法线”方向）。平面的“上方”是平面朝向法线方向的一面。</paragraph>
        </section>
        <section classes="classref-introduction-group" ids="id2" names="教程">
            <title>教程</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/math/index"><inline classes="doc">数学文档索引</inline></reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="属性">
            <title>属性</title>
            <table classes="colwidths-auto">
                <tgroup cols="3">
                    <colspec colwidth="31"></colspec>
                    <colspec colwidth="44"></colspec>
                    <colspec colwidth="22"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-property-d"><inline classes="std std-ref">d</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>0.0</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-property-normal"><inline classes="std std-ref">normal</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector3(0, 0, 0)</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-property-x"><inline classes="std std-ref">x</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>0.0</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-property-y"><inline classes="std std-ref">y</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>0.0</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-property-z"><inline classes="std std-ref">z</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>0.0</literal></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id4" names="构造函数">
            <title>构造函数</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="27"></colspec>
                    <colspec colwidth="172"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-constructor-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-constructor-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>(</strong> <reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> from <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-constructor-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> a, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> b, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> c, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> d <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-constructor-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> normal <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-constructor-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> normal, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> d <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-constructor-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> normal, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-constructor-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point1, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point2, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point3 <strong>)</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id5" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="31"></colspec>
                    <colspec colwidth="155"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-method-distance-to"><inline classes="std std-ref">distance_to</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-method-get-center"><inline classes="std std-ref">get_center</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-method-has-point"><inline classes="std std-ref">has_point</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> tolerance=1e-05 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-method-intersect-3"><inline classes="std std-ref">intersect_3</inline></reference> <strong>(</strong> <reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> b, <reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> c <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-method-intersects-ray"><inline classes="std std-ref">intersects_ray</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> from, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> dir <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-method-intersects-segment"><inline classes="std std-ref">intersects_segment</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> from, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> to <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-method-is-equal-approx"><inline classes="std std-ref">is_equal_approx</inline></reference> <strong>(</strong> <reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> to_plane <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-method-is-finite"><inline classes="std std-ref">is_finite</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-method-is-point-over"><inline classes="std std-ref">is_point_over</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-method-normalized"><inline classes="std std-ref">normalized</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-method-project"><inline classes="std std-ref">project</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id6" names="操作符">
            <title>操作符</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="27"></colspec>
                    <colspec colwidth="113"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-operator-neq-plane"><inline classes="std std-ref">operator !=</inline></reference> <strong>(</strong> <reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-operator-mul-transform3d"><inline classes="std std-ref">operator *</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-operator-eq-plane"><inline classes="std std-ref">operator ==</inline></reference> <strong>(</strong> <reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-operator-unplus"><inline classes="std std-ref">operator unary+</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-plane-operator-unminus"><inline classes="std std-ref">operator unary-</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id7" names="常量">
            <title>常量</title>
            <target refid="class-plane-constant-plane-yz"></target>
            <paragraph classes="classref-constant" ids="class-plane-constant-plane-yz" names="class_plane_constant_plane_yz"><strong>PLANE_YZ</strong> = <literal>Plane(1, 0, 0, 0)</literal></paragraph>
            <paragraph>在 Y 轴和 Z 轴上延伸的平面（法向量指向 +X）。</paragraph>
            <target refid="class-plane-constant-plane-xz"></target>
            <paragraph classes="classref-constant" ids="class-plane-constant-plane-xz" names="class_plane_constant_plane_xz"><strong>PLANE_XZ</strong> = <literal>Plane(0, 1, 0, 0)</literal></paragraph>
            <paragraph>在 X 轴和 Z 轴上延伸的平面（法向量朝向 +Y）。</paragraph>
            <target refid="class-plane-constant-plane-xy"></target>
            <paragraph classes="classref-constant" ids="class-plane-constant-plane-xy" names="class_plane_constant_plane_xy"><strong>PLANE_XY</strong> = <literal>Plane(0, 0, 1, 0)</literal></paragraph>
            <paragraph>在 X 轴和 Y 轴上延伸的平面（法向量朝向 +Z）。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id8" names="属性说明">
            <title>属性说明</title>
            <target refid="class-plane-property-d"></target>
            <paragraph classes="classref-property" ids="class-plane-property-d" names="class_plane_property_d"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>d</strong> = <literal>0.0</literal></paragraph>
            <paragraph>从原点到平面的距离，按照 <reference internal="True" refid="class-plane-property-normal"><inline classes="std std-ref">normal</inline></reference> 取值（根据其方向和长度）。原点与平面的实际绝对距离可以通过 <literal>abs(d) / normal.length()</literal> 计算（如果 <reference internal="True" refid="class-plane-property-normal"><inline classes="std std-ref">normal</inline></reference> 长度为零，则该 <strong>Plane</strong> 表示的不是有效平面）。</paragraph>
            <paragraph>在平面 <literal>ax + by + cz = d</literal> 的标量方程中，这是 <literal>d</literal>，而 <literal>(a, b, c)</literal> 坐标由 <reference internal="True" refid="class-plane-property-normal"><inline classes="std std-ref">normal</inline></reference> 属性表示。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-property-normal"></target>
            <paragraph classes="classref-property" ids="class-plane-property-normal" names="class_plane_property_normal"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>normal</strong> = <literal>Vector3(0, 0, 0)</literal></paragraph>
            <paragraph>该平面的法线，通常为单位向量。不应该为零向量，因为 <reference internal="True" refid="class-plane-property-normal"><inline classes="std std-ref">normal</inline></reference> 为零的 <strong>Plane</strong> 代表的不是有效平面。</paragraph>
            <paragraph>在平面 <literal>ax + by + cz = d</literal> 的标量方程中，这是向量 <literal>(a, b, c)</literal>，其中 <literal>d</literal> 是 <reference internal="True" refid="class-plane-property-d"><inline classes="std std-ref">d</inline></reference> 属性。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-property-x"></target>
            <paragraph classes="classref-property" ids="class-plane-property-x" names="class_plane_property_x"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>x</strong> = <literal>0.0</literal></paragraph>
            <paragraph>平面法向量 <reference internal="True" refid="class-plane-property-normal"><inline classes="std std-ref">normal</inline></reference> 的 X 分量。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-property-y"></target>
            <paragraph classes="classref-property" ids="class-plane-property-y" names="class_plane_property_y"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>y</strong> = <literal>0.0</literal></paragraph>
            <paragraph>平面法向量 <reference internal="True" refid="class-plane-property-normal"><inline classes="std std-ref">normal</inline></reference> 的 Y 分量。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-property-z"></target>
            <paragraph classes="classref-property" ids="class-plane-property-z" names="class_plane_property_z"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>z</strong> = <literal>0.0</literal></paragraph>
            <paragraph>平面法向量 <reference internal="True" refid="class-plane-property-normal"><inline classes="std std-ref">normal</inline></reference> 的 Z 分量。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id9" names="构造函数说明">
            <title>构造函数说明</title>
            <target refid="class-plane-constructor-plane"></target>
            <paragraph classes="classref-constructor" ids="class-plane-constructor-plane" names="class_plane_constructor_plane"><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>Plane</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>构造默认初始化的 <strong>Plane</strong>，所有分量都设置为 <literal>0</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>Plane</strong> <strong>(</strong> <reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> from <strong>)</strong></paragraph>
            <paragraph>构造给定 <strong>Plane</strong> 的副本。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>Plane</strong> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> a, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> b, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> c, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> d <strong>)</strong></paragraph>
            <paragraph>根据四个参数创建一个平面。产生的平面的 <reference internal="True" refid="class-plane-property-normal"><inline classes="std std-ref">normal</inline></reference> 的三个分量是 <literal>a</literal>、<literal>b</literal>、和 <literal>c</literal>，且该平面与原点的距离为 <literal>d</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>Plane</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> normal <strong>)</strong></paragraph>
            <paragraph>根据法向量创建一个平面。该平面将与原点相交。</paragraph>
            <paragraph>该平面的 <literal>normal</literal> 必须是一个单位向量。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>Plane</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> normal, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> d <strong>)</strong></paragraph>
            <paragraph>根据法向量和平面与原点的距离创建一个平面。</paragraph>
            <paragraph>平面的 <literal>normal</literal> 必须是一个单位向量。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>Plane</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> normal, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point <strong>)</strong></paragraph>
            <paragraph>从法向量和平面上的一个点创建一个平面。</paragraph>
            <paragraph>平面的 <literal>normal</literal> 必须是一个单位向量。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>Plane</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point1, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point2, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point3 <strong>)</strong></paragraph>
            <paragraph>根据顺时针顺序给出的三个点创建一个平面。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id10" names="方法说明">
            <title>方法说明</title>
            <target refid="class-plane-method-distance-to"></target>
            <paragraph classes="classref-method" ids="class-plane-method-distance-to" names="class_plane_method_distance_to"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>distance_to</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回从该平面到位置 <literal>point</literal> 的最短距离。如果该点在平面上方，则距离将为正。如果在下方，则距离将为负。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-method-get-center"></target>
            <paragraph classes="classref-method" ids="class-plane-method-get-center" names="class_plane_method_get_center"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>get_center</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回平面的中心。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-method-has-point"></target>
            <paragraph classes="classref-method" ids="class-plane-method-has-point" names="class_plane_method_has_point"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>has_point</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> tolerance=1e-05 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果 <literal>point</literal> 在该平面内，则返回 <literal>true</literal>。比较将使用一个自定义的最小 <literal>tolerance</literal> 阈值。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-method-intersect-3"></target>
            <paragraph classes="classref-method" ids="class-plane-method-intersect-3" names="class_plane_method_intersect_3"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>intersect_3</strong> <strong>(</strong> <reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> b, <reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> c <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回 <literal>b</literal>、<literal>c</literal>、该平面这三个平面的交点。如果没有找到交点，则返回 <literal>null</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-method-intersects-ray"></target>
            <paragraph classes="classref-method" ids="class-plane-method-intersects-ray" names="class_plane_method_intersects_ray"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>intersects_ray</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> from, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> dir <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回由位置 <literal>from</literal> 和方向法线 <literal>dir</literal> 组成的射线与该平面的交点。如果没有找到交点，则返回 <literal>null</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-method-intersects-segment"></target>
            <paragraph classes="classref-method" ids="class-plane-method-intersects-segment" names="class_plane_method_intersects_segment"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>intersects_segment</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> from, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> to <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回从位置 <literal>from</literal> 到位置 <literal>to</literal> 的线段与该平面的交点。如果没有找到交点，则返回 <literal>null</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-method-is-equal-approx"></target>
            <paragraph classes="classref-method" ids="class-plane-method-is-equal-approx" names="class_plane_method_is_equal_approx"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_equal_approx</strong> <strong>(</strong> <reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> to_plane <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该平面和 <literal>to_plane</literal> 近似相等，则返回 <literal>true</literal>，判断近似相等的方法是通过在每个分量上运行 <reference internal="True" refuri="class_@globalscope#class-globalscope-method-is-equal-approx"><inline classes="std std-ref">@GlobalScope.is_equal_approx</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-method-is-finite"></target>
            <paragraph classes="classref-method" ids="class-plane-method-is-finite" names="class_plane_method_is_finite"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_finite</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该平面是有限的，则返回 <literal>true</literal>，判断方法是在每个分量上调用 <reference internal="True" refuri="class_@globalscope#class-globalscope-method-is-finite"><inline classes="std std-ref">@GlobalScope.is_finite</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-method-is-point-over"></target>
            <paragraph classes="classref-method" ids="class-plane-method-is-point-over" names="class_plane_method_is_point_over"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_point_over</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果 <literal>point</literal> 位于平面上方，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-method-normalized"></target>
            <paragraph classes="classref-method" ids="class-plane-method-normalized" names="class_plane_method_normalized"><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>normalized</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该平面归一化 <reference internal="True" refid="class-plane-property-normal"><inline classes="std std-ref">normal</inline></reference> 后的副本（法线成为单位向量）。如果 <reference internal="True" refid="class-plane-property-normal"><inline classes="std std-ref">normal</inline></reference> 无法归一化（长度为零），则返回 <literal>Plane(0, 0, 0, 0)</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-method-project"></target>
            <paragraph classes="classref-method" ids="class-plane-method-project" names="class_plane_method_project"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>project</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> point <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回 <literal>point</literal> 在该平面中的正交投影。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id11" names="操作符说明">
            <title>操作符说明</title>
            <target refid="class-plane-operator-neq-plane"></target>
            <paragraph classes="classref-operator" ids="class-plane-operator-neq-plane" names="class_plane_operator_neq_plane"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong> <strong>(</strong> <reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果平面不相等，则返回 <literal>true</literal>。</paragraph>
            <paragraph><strong>注意：</strong>由于浮点数精度误差，请考虑改用 <reference internal="True" refid="class-plane-method-is-equal-approx"><inline classes="std std-ref">is_equal_approx</inline></reference>，会更可靠。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-operator-mul-transform3d"></target>
            <paragraph classes="classref-operator" ids="class-plane-operator-mul-transform3d" names="class_plane_operator_mul_transform3d"><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>operator *</strong> <strong>(</strong> <reference internal="True" refuri="class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>将 <strong>Plane</strong> 逆向变换（乘以）给定的 <reference internal="True" refuri="class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference> 变换矩阵。</paragraph>
            <paragraph><literal>plane * transform</literal> 相当于 <literal>transform.affine_inverse() * plane</literal>。请参阅 <reference internal="True" refuri="class_transform3d#class-transform3d-method-affine-inverse"><inline classes="std std-ref">Transform3D.affine_inverse</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-operator-eq-plane"></target>
            <paragraph classes="classref-operator" ids="class-plane-operator-eq-plane" names="class_plane_operator_eq_plane"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong> <strong>(</strong> <reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果平面完全相等，则返回 <literal>true</literal>。</paragraph>
            <paragraph><strong>注意：</strong>由于浮点数精度误差，请考虑改用 <reference internal="True" refid="class-plane-method-is-equal-approx"><inline classes="std std-ref">is_equal_approx</inline></reference>，会更可靠。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-operator-unplus"></target>
            <paragraph classes="classref-operator" ids="class-plane-operator-unplus" names="class_plane_operator_unplus"><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>operator unary+</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>返回与 <literal>+</literal> 不存在时相同的值。单目 <literal>+</literal> 没有作用，但有时可以使你的代码更具可读性。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-plane-operator-unminus"></target>
            <paragraph classes="classref-operator" ids="class-plane-operator-unminus" names="class_plane_operator_unminus"><reference internal="True" refid="class-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>operator unary-</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>返回该 <strong>Plane</strong> 的负值。和写 <literal>Plane(-p.normal, -p.d)</literal> 相同。该操作翻转了法线向量的方向，也翻转了距离值，得到的 Plane 位于同一个位置，但是朝向相反的方向。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
