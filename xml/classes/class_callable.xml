<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_callable.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/master/doc/classes/Callable.xml.</comment>
    <target refid="class-callable"></target>
    <section ids="callable class-callable" names="callable class_callable">
        <title>Callable</title>
        <paragraph>A built-in type representing a method or a standalone function.</paragraph>
        <section classes="classref-introduction-group" ids="description" names="description">
            <title>Description</title>
            <paragraph><strong>Callable</strong> is a built-in <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> type that represents a function. It can either be a method within an <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference> instance, or a custom callable used for different purposes (see <reference internal="True" refid="class-callable-method-is-custom"><inline classes="std std-ref">is_custom()</inline></reference>). Like all <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> types, it can be stored in variables and passed to other functions. It is most commonly used for signal callbacks.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func print_args(arg1, arg2, arg3 = ""):
    prints(arg1, arg2, arg3)

func test():
    var callable = Callable(self, "print_args")
    callable.call("hello", "world")  # Prints "hello world ".
    callable.call(Vector2.UP, 42, callable)  # Prints "(0.0, -1.0) 42 Node(node.gd)::print_args"
    callable.call("invalid")  # Invalid call, should have at least 2 arguments.</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Default parameter values are not supported.
public void PrintArgs(Variant arg1, Variant arg2, Variant arg3 = default)
{
    GD.PrintS(arg1, arg2, arg3);
}

public void Test()
{
    // Invalid calls fail silently.
    Callable callable = new Callable(this, MethodName.PrintArgs);
    callable.Call("hello", "world"); // Default parameter values are not supported, should have 3 arguments.
    callable.Call(Vector2.Up, 42, callable); // Prints "(0, -1) 42 Node(Node.cs)::PrintArgs"
    callable.Call("invalid"); // Invalid call, should have 3 arguments.
}</literal_block>
                </div>
            </container>
            <paragraph>In GDScript, it's possible to create lambda functions within a method. Lambda functions are custom callables that are not associated with an <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference> instance. Optionally, lambda functions can also be named. The name will be displayed in the debugger, or when calling <reference internal="True" refid="class-callable-method-get-method"><inline classes="std std-ref">get_method()</inline></reference>.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _init():
    var my_lambda = func (message):
        print(message)

    # Prints "Hello everyone!"
    my_lambda.call("Hello everyone!")

    # Prints "Attack!", when the button_pressed signal is emitted.
    button_pressed.connect(func(): print("Attack!"))</literal_block>
            <paragraph>In GDScript, you can access methods and global functions as <strong>Callable</strong>s:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">tween.tween_callback(node.queue_free)  # Object methods.
tween.tween_callback(array.clear)  # Methods of built-in types.
tween.tween_callback(print.bind("Test"))  # Global functions.</literal_block>
            <paragraph><strong>Note:</strong> <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> does not support the above due to ambiguity with keys.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var dictionary = { "hello": "world" }

# This will not work, `clear` is treated as a key.
tween.tween_callback(dictionary.clear)

# This will work.
tween.tween_callback(Callable.create(dictionary, "clear"))</literal_block>
            <note>
                <paragraph>There are notable differences when using this API with C#. See <reference internal="True" refuri="../tutorials/scripting/c_sharp/c_sharp_differences#doc-c-sharp-differences"><inline classes="std std-ref">C# API differences to GDScript</inline></reference> for more information.</paragraph>
            </note>
        </section>
        <section classes="classref-reftable-group" ids="constructors" names="constructors">
            <title>Constructors</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="33"></colspec>
                    <colspec colwidth="144"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-constructor-callable"><inline classes="std std-ref">Callable</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-constructor-callable"><inline classes="std std-ref">Callable</inline></reference>(from: <reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-constructor-callable"><inline classes="std std-ref">Callable</inline></reference>(object: <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference>, method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="methods" names="methods">
            <title>Methods</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="37"></colspec>
                    <colspec colwidth="147"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-bind"><inline classes="std std-ref">bind</inline></reference>(...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-bindv"><inline classes="std std-ref">bindv</inline></reference>(arguments: <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-call"><inline classes="std std-ref">call</inline></reference>(...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-call-deferred"><inline classes="std std-ref">call_deferred</inline></reference>(...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-callv"><inline classes="std std-ref">callv</inline></reference>(arguments: <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-create"><inline classes="std std-ref">create</inline></reference>(variant: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-get-argument-count"><inline classes="std std-ref">get_argument_count</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-get-bound-arguments"><inline classes="std std-ref">get_bound_arguments</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-get-bound-arguments-count"><inline classes="std std-ref">get_bound_arguments_count</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-get-method"><inline classes="std std-ref">get_method</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-get-object"><inline classes="std std-ref">get_object</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-get-object-id"><inline classes="std std-ref">get_object_id</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-get-unbound-arguments-count"><inline classes="std std-ref">get_unbound_arguments_count</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-hash"><inline classes="std std-ref">hash</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-is-custom"><inline classes="std std-ref">is_custom</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-is-null"><inline classes="std std-ref">is_null</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-is-standard"><inline classes="std std-ref">is_standard</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-is-valid"><inline classes="std std-ref">is_valid</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-rpc"><inline classes="std std-ref">rpc</inline></reference>(...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-rpc-id"><inline classes="std std-ref">rpc_id</inline></reference>(peer_id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, ...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-unbind"><inline classes="std std-ref">unbind</inline></reference>(argcount: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="operators" names="operators">
            <title>Operators</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="25"></colspec>
                    <colspec colwidth="105"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-operator-neq-callable"><inline classes="std std-ref">operator !=</inline></reference>(right: <reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-operator-eq-callable"><inline classes="std std-ref">operator ==</inline></reference>(right: <reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="constructor-descriptions" names="constructor\ descriptions">
            <title>Constructor Descriptions</title>
            <target refid="class-callable-constructor-callable"></target>
            <paragraph classes="classref-constructor" ids="class-callable-constructor-callable" names="class_callable_constructor_callable"><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>Callable</strong>() <reference internal="True" refid="class-callable-constructor-callable"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Constructs an empty <strong>Callable</strong>, with no object nor method bound.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>Callable</strong>(from: <reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference>)</paragraph>
            <paragraph>Constructs a <strong>Callable</strong> as a copy of the given <strong>Callable</strong>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>Callable</strong>(object: <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference>, method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
            <paragraph>Creates a new <strong>Callable</strong> for the method named <literal>method</literal> in the specified <literal>object</literal>.</paragraph>
            <paragraph><strong>Note:</strong> For methods of built-in <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> types, use <reference internal="True" refid="class-callable-method-create"><inline classes="std std-ref">create()</inline></reference> instead.</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="method-descriptions" names="method\ descriptions">
            <title>Method Descriptions</title>
            <target refid="class-callable-method-bind"></target>
            <paragraph classes="classref-method" ids="class-callable-method-bind" names="class_callable_method_bind"><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>bind</strong>(...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-bind"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns a copy of this <strong>Callable</strong> with one or more arguments bound. When called, the bound arguments are passed <emphasis>after</emphasis> the arguments supplied by <reference internal="True" refid="class-callable-method-call"><inline classes="std std-ref">call()</inline></reference>. See also <reference internal="True" refid="class-callable-method-unbind"><inline classes="std std-ref">unbind()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-bindv"></target>
            <paragraph classes="classref-method" ids="class-callable-method-bindv" names="class_callable_method_bindv"><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>bindv</strong>(arguments: <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-callable-method-bindv"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns a copy of this <strong>Callable</strong> with one or more arguments bound, reading them from an array. When called, the bound arguments are passed <emphasis>after</emphasis> the arguments supplied by <reference internal="True" refid="class-callable-method-call"><inline classes="std std-ref">call()</inline></reference>. See also <reference internal="True" refid="class-callable-method-unbind"><inline classes="std std-ref">unbind()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-call"></target>
            <paragraph classes="classref-method" ids="class-callable-method-call" names="class_callable_method_call"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>call</strong>(...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-call"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Calls the method represented by this <strong>Callable</strong>. Arguments can be passed and should match the method's signature.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-call-deferred"></target>
            <paragraph classes="classref-method" ids="class-callable-method-call-deferred" names="class_callable_method_call_deferred"><abbreviation explanation="No return value.">void</abbreviation> <strong>call_deferred</strong>(...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-call-deferred"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Calls the method represented by this <strong>Callable</strong> in deferred mode, i.e. at the end of the current frame. Arguments can be passed and should match the method's signature.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    grab_focus.call_deferred()</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    Callable.From(GrabFocus).CallDeferred();
}</literal_block>
                </div>
            </container>
            <paragraph><strong>Note:</strong> Deferred calls are processed at idle time. Idle time happens mainly at the end of process and physics frames. In it, deferred calls will be run until there are none left, which means you can defer calls from other deferred calls and they'll still be run in the current idle time cycle. This means you should not call a method deferred from itself (or from a method called by it), as this causes infinite recursion the same way as if you had called the method directly.</paragraph>
            <paragraph>See also <reference internal="True" refuri="class_object#class-object-method-call-deferred"><inline classes="std std-ref">Object.call_deferred()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-callv"></target>
            <paragraph classes="classref-method" ids="class-callable-method-callv" names="class_callable_method_callv"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>callv</strong>(arguments: <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-callv"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Calls the method represented by this <strong>Callable</strong>. Unlike <reference internal="True" refid="class-callable-method-call"><inline classes="std std-ref">call()</inline></reference>, this method expects all arguments to be contained inside the <literal>arguments</literal> <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-create"></target>
            <paragraph classes="classref-method" ids="class-callable-method-create" names="class_callable_method_create"><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>create</strong>(variant: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation> <reference internal="True" refid="class-callable-method-create"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Creates a new <strong>Callable</strong> for the method named <literal>method</literal> in the specified <literal>variant</literal>. To represent a method of a built-in <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> type, a custom callable is used (see <reference internal="True" refid="class-callable-method-is-custom"><inline classes="std std-ref">is_custom()</inline></reference>). If <literal>variant</literal> is <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference>, then a standard callable will be created instead.</paragraph>
            <paragraph><strong>Note:</strong> This method is always necessary for the <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> type, as property syntax is used to access its entries. You may also use this method when <literal>variant</literal>'s type is not known in advance (for polymorphism).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-get-argument-count"></target>
            <paragraph classes="classref-method" ids="class-callable-method-get-argument-count" names="class_callable_method_get_argument_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_argument_count</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-get-argument-count"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the total number of arguments this <strong>Callable</strong> should take, including optional arguments. This means that any arguments bound with <reference internal="True" refid="class-callable-method-bind"><inline classes="std std-ref">bind()</inline></reference> are <emphasis>subtracted</emphasis> from the result, and any arguments unbound with <reference internal="True" refid="class-callable-method-unbind"><inline classes="std std-ref">unbind()</inline></reference> are <emphasis>added</emphasis> to the result.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-get-bound-arguments"></target>
            <paragraph classes="classref-method" ids="class-callable-method-get-bound-arguments" names="class_callable_method_get_bound_arguments"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> <strong>get_bound_arguments</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-get-bound-arguments"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the array of arguments bound via successive <reference internal="True" refid="class-callable-method-bind"><inline classes="std std-ref">bind()</inline></reference> or <reference internal="True" refid="class-callable-method-unbind"><inline classes="std std-ref">unbind()</inline></reference> calls. These arguments will be added <emphasis>after</emphasis> the arguments passed to the call, from which <reference internal="True" refid="class-callable-method-get-unbound-arguments-count"><inline classes="std std-ref">get_unbound_arguments_count()</inline></reference> arguments on the right have been previously excluded.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func get_effective_arguments(callable, call_args):
    assert(call_args.size() - callable.get_unbound_arguments_count() &gt;= 0)
    var result = call_args.slice(0, call_args.size() - callable.get_unbound_arguments_count())
    result.append_array(callable.get_bound_arguments())
    return result</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-get-bound-arguments-count"></target>
            <paragraph classes="classref-method" ids="class-callable-method-get-bound-arguments-count" names="class_callable_method_get_bound_arguments_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_bound_arguments_count</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-get-bound-arguments-count"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the total amount of arguments bound via successive <reference internal="True" refid="class-callable-method-bind"><inline classes="std std-ref">bind()</inline></reference> or <reference internal="True" refid="class-callable-method-unbind"><inline classes="std std-ref">unbind()</inline></reference> calls. This is the same as the size of the array returned by <reference internal="True" refid="class-callable-method-get-bound-arguments"><inline classes="std std-ref">get_bound_arguments()</inline></reference>. See <reference internal="True" refid="class-callable-method-get-bound-arguments"><inline classes="std std-ref">get_bound_arguments()</inline></reference> for details.</paragraph>
            <paragraph><strong>Note:</strong> The <reference internal="True" refid="class-callable-method-get-bound-arguments-count"><inline classes="std std-ref">get_bound_arguments_count()</inline></reference> and <reference internal="True" refid="class-callable-method-get-unbound-arguments-count"><inline classes="std std-ref">get_unbound_arguments_count()</inline></reference> methods can both return positive values.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-get-method"></target>
            <paragraph classes="classref-method" ids="class-callable-method-get-method" names="class_callable_method_get_method"><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>get_method</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-get-method"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the name of the method represented by this <strong>Callable</strong>. If the callable is a GDScript lambda function, returns the function's name or <literal>"&lt;anonymous lambda&gt;"</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-get-object"></target>
            <paragraph classes="classref-method" ids="class-callable-method-get-object" names="class_callable_method_get_object"><reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference> <strong>get_object</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-get-object"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the object on which this <strong>Callable</strong> is called.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-get-object-id"></target>
            <paragraph classes="classref-method" ids="class-callable-method-get-object-id" names="class_callable_method_get_object_id"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_object_id</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-get-object-id"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the ID of this <strong>Callable</strong>'s object (see <reference internal="True" refuri="class_object#class-object-method-get-instance-id"><inline classes="std std-ref">Object.get_instance_id()</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-get-unbound-arguments-count"></target>
            <paragraph classes="classref-method" ids="class-callable-method-get-unbound-arguments-count" names="class_callable_method_get_unbound_arguments_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_unbound_arguments_count</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-get-unbound-arguments-count"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the total amount of arguments unbound via successive <reference internal="True" refid="class-callable-method-bind"><inline classes="std std-ref">bind()</inline></reference> or <reference internal="True" refid="class-callable-method-unbind"><inline classes="std std-ref">unbind()</inline></reference> calls. See <reference internal="True" refid="class-callable-method-get-bound-arguments"><inline classes="std std-ref">get_bound_arguments()</inline></reference> for details.</paragraph>
            <paragraph><strong>Note:</strong> The <reference internal="True" refid="class-callable-method-get-bound-arguments-count"><inline classes="std std-ref">get_bound_arguments_count()</inline></reference> and <reference internal="True" refid="class-callable-method-get-unbound-arguments-count"><inline classes="std std-ref">get_unbound_arguments_count()</inline></reference> methods can both return positive values.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-hash"></target>
            <paragraph classes="classref-method" ids="class-callable-method-hash" names="class_callable_method_hash"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>hash</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-hash"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the 32-bit hash value of this <strong>Callable</strong>'s object.</paragraph>
            <paragraph><strong>Note:</strong> <strong>Callable</strong>s with equal content will always produce identical hash values. However, the reverse is not true. Returning identical hash values does <emphasis>not</emphasis> imply the callables are equal, because different callables can have identical hash values due to hash collisions. The engine uses a 32-bit hash algorithm for <reference internal="True" refid="class-callable-method-hash"><inline classes="std std-ref">hash()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-is-custom"></target>
            <paragraph classes="classref-method" ids="class-callable-method-is-custom" names="class_callable_method_is_custom"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_custom</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-is-custom"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if this <strong>Callable</strong> is a custom callable. Custom callables are used:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>for binding/unbinding arguments (see <reference internal="True" refid="class-callable-method-bind"><inline classes="std std-ref">bind()</inline></reference> and <reference internal="True" refid="class-callable-method-unbind"><inline classes="std std-ref">unbind()</inline></reference>);</paragraph>
                </list_item>
                <list_item>
                    <paragraph>for representing methods of built-in <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> types (see <reference internal="True" refid="class-callable-method-create"><inline classes="std std-ref">create()</inline></reference>);</paragraph>
                </list_item>
                <list_item>
                    <paragraph>for representing global, lambda, and RPC functions in GDScript;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>for other purposes in the core, GDExtension, and C#.</paragraph>
                </list_item>
            </bullet_list>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-is-null"></target>
            <paragraph classes="classref-method" ids="class-callable-method-is-null" names="class_callable_method_is_null"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_null</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-is-null"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if this <strong>Callable</strong> has no target to call the method on. Equivalent to <literal>callable == Callable()</literal>.</paragraph>
            <paragraph><strong>Note:</strong> This is <emphasis>not</emphasis> the same as <literal>not is_valid()</literal> and using <literal>not is_null()</literal> will <emphasis>not</emphasis> guarantee that this callable can be called. Use <reference internal="True" refid="class-callable-method-is-valid"><inline classes="std std-ref">is_valid()</inline></reference> instead.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-is-standard"></target>
            <paragraph classes="classref-method" ids="class-callable-method-is-standard" names="class_callable_method_is_standard"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_standard</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-is-standard"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if this <strong>Callable</strong> is a standard callable. This method is the opposite of <reference internal="True" refid="class-callable-method-is-custom"><inline classes="std std-ref">is_custom()</inline></reference>. Returns <literal>false</literal> if this callable is a lambda function.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-is-valid"></target>
            <paragraph classes="classref-method" ids="class-callable-method-is-valid" names="class_callable_method_is_valid"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-is-valid"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the callable's object exists and has a valid method name assigned, or is a custom callable.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-rpc"></target>
            <paragraph classes="classref-method" ids="class-callable-method-rpc" names="class_callable_method_rpc"><abbreviation explanation="No return value.">void</abbreviation> <strong>rpc</strong>(...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-rpc"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Perform an RPC (Remote Procedure Call) on all connected peers. This is used for multiplayer and is normally not available, unless the function being called has been marked as <emphasis>RPC</emphasis> (using <reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-rpc"><inline classes="std std-ref">@GDScript.@rpc</inline></reference> or <reference internal="True" refuri="class_node#class-node-method-rpc-config"><inline classes="std std-ref">Node.rpc_config()</inline></reference>). Calling this method on unsupported functions will result in an error. See <reference internal="True" refuri="class_node#class-node-method-rpc"><inline classes="std std-ref">Node.rpc()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-rpc-id"></target>
            <paragraph classes="classref-method" ids="class-callable-method-rpc-id" names="class_callable_method_rpc_id"><abbreviation explanation="No return value.">void</abbreviation> <strong>rpc_id</strong>(peer_id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, ...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-rpc-id"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Perform an RPC (Remote Procedure Call) on a specific peer ID (see multiplayer documentation for reference). This is used for multiplayer and is normally not available unless the function being called has been marked as <emphasis>RPC</emphasis> (using <reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-rpc"><inline classes="std std-ref">@GDScript.@rpc</inline></reference> or <reference internal="True" refuri="class_node#class-node-method-rpc-config"><inline classes="std std-ref">Node.rpc_config()</inline></reference>). Calling this method on unsupported functions will result in an error. See <reference internal="True" refuri="class_node#class-node-method-rpc-id"><inline classes="std std-ref">Node.rpc_id()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-unbind"></target>
            <paragraph classes="classref-method" ids="class-callable-method-unbind" names="class_callable_method_unbind"><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>unbind</strong>(argcount: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-callable-method-unbind"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns a copy of this <strong>Callable</strong> with a number of arguments unbound. In other words, when the new callable is called the last few arguments supplied by the user are ignored, according to <literal>argcount</literal>. The remaining arguments are passed to the callable. This allows to use the original callable in a context that attempts to pass more arguments than this callable can handle, e.g. a signal with a fixed number of arguments. See also <reference internal="True" refid="class-callable-method-bind"><inline classes="std std-ref">bind()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    foo.unbind(1).call(1, 2) # Calls foo(1).
    foo.bind(3, 4).unbind(1).call(1, 2) # Calls foo(1, 3, 4), note that it does not change the arguments from bind.</literal_block>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="operator-descriptions" names="operator\ descriptions">
            <title>Operator Descriptions</title>
            <target refid="class-callable-operator-neq-callable"></target>
            <paragraph classes="classref-operator" ids="class-callable-operator-neq-callable" names="class_callable_operator_neq_callable"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong>(right: <reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference>) <reference internal="True" refid="class-callable-operator-neq-callable"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if both <strong>Callable</strong>s invoke different targets.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-operator-eq-callable"></target>
            <paragraph classes="classref-operator" ids="class-callable-operator-eq-callable" names="class_callable_operator_eq_callable"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong>(right: <reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference>) <reference internal="True" refid="class-callable-operator-eq-callable"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if both <strong>Callable</strong>s invoke the same custom target.</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></substitution_definition>
            <substitution_definition names="required"><abbreviation explanation="This method is required to be overridden when extending its base class.">required</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="This method is used to construct a type.">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="This method describes a valid operator to use with this type as left-hand operand.">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="This value is an integer composed as a bitmask of the following flags.">BitField</abbreviation></substitution_definition>
            <substitution_definition names="void"><abbreviation explanation="No return value.">void</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
