<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_callable.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/4.2/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/4.2/doc/classes/Callable.xml.</comment>
    <target refid="class-callable"></target>
    <section ids="callable class-callable" names="callable class_callable">
        <title>Callable</title>
        <paragraph>代表一个方法或一个独立函数的内置类型。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>可调用体 <strong>Callable</strong> 是内置的 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> 类型，代表某个函数。可以是 <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference> 实例中的某个方法，也可以是与对象无关的独立函数，比如 lambda 函数。和所有 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> 类型一样可以保存在变量里，传递给其他函数。最常用于信号回调。</paragraph>
            <paragraph><strong>示例：</strong></paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func print_args(arg1, arg2, arg3 = ""):
    prints(arg1, arg2, arg3)

func test():
    var callable = Callable(self, "print_args")
    callable.call("hello", "world")  # 输出 "hello world ".
    callable.call(Vector2.UP, 42, callable)  # 输出 "(0, -1) 42 Node(node.gd)::print_args".
    callable.call("invalid")  # 无效调用，应当至少有 2 个参数。</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// 不支持参数默认值。
public void PrintArgs(Variant arg1, Variant arg2, Variant arg3 = default)
{
    GD.PrintS(arg1, arg2, arg3);
}

public void Test()
{
    // Invalid calls fail silently.
    Callable callable = new Callable(this, MethodName.PrintArgs);
    callable.Call("hello", "world"); // 不支持参数默认值，应当有 3 个参数。
    callable.Call(Vector2.Up, 42, callable); // 输出 "(0, -1) 42 Node(Node.cs)::PrintArgs".
    callable.Call("invalid"); // 无效调用，应当有 3 个参数。
}</literal_block>
                </div>
            </container>
            <paragraph>GDScript 中可以在方法里创建 lambda 函数。Lambda 函数是自定义的可调用体，不与 <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference> 实例关联。也可以为 Lambda 函数命名。该名称会显示在调试器中，也会在 <reference internal="True" refid="class-callable-method-get-method"><inline classes="std std-ref">get_method</inline></reference> 中使用。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _init():
    var my_lambda = func (message):
        print(message)

    # 输出 大家好呀！
    my_lambda.call("大家好呀！")

    # 发出 button_pressed 信号时输出 "全军出击！"。
    button_pressed.connect(func(): print("全军出击！"))</literal_block>
            <paragraph><strong>注意：</strong><reference internal="True" refuri="class_signal#class-signal"><inline classes="std std-ref">Signal</inline></reference>、<reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>、<reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> 等原生类型的方法不是 <strong>Callable</strong> 类型，这是为了避免不必要的开销。如果你需要将这些方法作为 <strong>Callable</strong> 传递，请使用 Lambda 函数进行封装。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _init():
    var my_dictionary = { "hello": "world" }

    # 不可行，因为`clear` 不是可调用体。
    create_tween().tween_callback(my_dictionary.clear)

    # 可行，因为 Lambda 是自定义可调用体。
    create_tween().tween_callback(func(): my_dictionary.clear())</literal_block>
            <note>
                <paragraph>通过 C# 使用这个 API 时有显著的不同。详见 <reference internal="True" refuri="../tutorials/scripting/c_sharp/c_sharp_differences#doc-c-sharp-differences"><inline classes="std std-ref">C# API 与 GDScript 的差异</inline></reference>。</paragraph>
            </note>
        </section>
        <section classes="classref-reftable-group" ids="id2" names="构造函数">
            <title>构造函数</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="33"></colspec>
                    <colspec colwidth="145"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-constructor-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-constructor-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>(</strong> <reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> from <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-constructor-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference> object, <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> method <strong>)</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="37"></colspec>
                    <colspec colwidth="109"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-bind"><inline classes="std std-ref">bind</inline></reference> <strong>(</strong> ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-bindv"><inline classes="std std-ref">bindv</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> arguments <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-call"><inline classes="std std-ref">call</inline></reference> <strong>(</strong> ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-call-deferred"><inline classes="std std-ref">call_deferred</inline></reference> <strong>(</strong> ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-callv"><inline classes="std std-ref">callv</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> arguments <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-get-bound-arguments"><inline classes="std std-ref">get_bound_arguments</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-get-bound-arguments-count"><inline classes="std std-ref">get_bound_arguments_count</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-get-method"><inline classes="std std-ref">get_method</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-get-object"><inline classes="std std-ref">get_object</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-get-object-id"><inline classes="std std-ref">get_object_id</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-hash"><inline classes="std std-ref">hash</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-is-custom"><inline classes="std std-ref">is_custom</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-is-null"><inline classes="std std-ref">is_null</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-is-standard"><inline classes="std std-ref">is_standard</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-is-valid"><inline classes="std std-ref">is_valid</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-rpc"><inline classes="std std-ref">rpc</inline></reference> <strong>(</strong> ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-rpc-id"><inline classes="std std-ref">rpc_id</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> peer_id, ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-method-unbind"><inline classes="std std-ref">unbind</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> argcount <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id4" names="操作符">
            <title>操作符</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="25"></colspec>
                    <colspec colwidth="108"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-operator-neq-callable"><inline classes="std std-ref">operator !=</inline></reference> <strong>(</strong> <reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-callable-operator-eq-callable"><inline classes="std std-ref">operator ==</inline></reference> <strong>(</strong> <reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id5" names="构造函数说明">
            <title>构造函数说明</title>
            <target refid="class-callable-constructor-callable"></target>
            <paragraph classes="classref-constructor" ids="class-callable-constructor-callable" names="class_callable_constructor_callable"><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>Callable</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>构造空的 <strong>Callable</strong>，没有绑定对象和方法。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>Callable</strong> <strong>(</strong> <reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> from <strong>)</strong></paragraph>
            <paragraph>构造给定 <strong>Callable</strong> 的副本。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>Callable</strong> <strong>(</strong> <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference> object, <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> method <strong>)</strong></paragraph>
            <paragraph>创建新的 <strong>Callable</strong>，使用指定对象 <literal>object</literal> 中名为 <literal>method</literal> 的方法。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id6" names="方法说明">
            <title>方法说明</title>
            <target refid="class-callable-method-bind"></target>
            <paragraph classes="classref-method" ids="class-callable-method-bind" names="class_callable_method_bind"><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>bind</strong> <strong>(</strong> ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该 <strong>Callable</strong> 的副本，绑定其中的一个或多个参数。调用时，被绑定的参数在提供给 <reference internal="True" refid="class-callable-method-call"><inline classes="std std-ref">call</inline></reference> 的参数<emphasis>之后</emphasis>传递。另见 <reference internal="True" refid="class-callable-method-unbind"><inline classes="std std-ref">unbind</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>这个方法与其他类似方法链式调用时，参数列表的修改顺序是从右至左的。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-bindv"></target>
            <paragraph classes="classref-method" ids="class-callable-method-bindv" names="class_callable_method_bindv"><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>bindv</strong> <strong>(</strong> <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> arguments <strong>)</strong></paragraph>
            <paragraph>返回该 <strong>Callable</strong> 的副本，绑定其中的一个或多个参数，参数从数组中读取。调用时，被绑定的参数在提供给 <reference internal="True" refid="class-callable-method-call"><inline classes="std std-ref">call</inline></reference> 的参数<emphasis>之后</emphasis>传递。另见 <reference internal="True" refid="class-callable-method-unbind"><inline classes="std std-ref">unbind</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>这个方法与其他类似方法链式调用时，参数列表的修改顺序是从右至左的。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-call"></target>
            <paragraph classes="classref-method" ids="class-callable-method-call" names="class_callable_method_call"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>call</strong> <strong>(</strong> ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>调用该 <strong>Callable</strong> 所代表的方法。可以传递参数，必须与该方法的签名相匹配。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-call-deferred"></target>
            <paragraph classes="classref-method" ids="class-callable-method-call-deferred" names="class_callable_method_call_deferred">void <strong>call_deferred</strong> <strong>(</strong> ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>使用延迟模式调用该 <strong>Callable</strong> 所代表的方法，即在当前帧的末尾调用。可以传递参数，必须与该方法的签名相匹配。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    grab_focus.call_deferred()</literal_block>
            <paragraph>另见 <reference internal="True" refuri="class_object#class-object-method-call-deferred"><inline classes="std std-ref">Object.call_deferred</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-callv"></target>
            <paragraph classes="classref-method" ids="class-callable-method-callv" names="class_callable_method_callv"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>callv</strong> <strong>(</strong> <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> arguments <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>调用该 <strong>Callable</strong> 所代表的方法。与 <reference internal="True" refid="class-callable-method-call"><inline classes="std std-ref">call</inline></reference> 不同，这个方法需要所有参数都放在 <literal>arguments</literal> <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> 之中。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-get-bound-arguments"></target>
            <paragraph classes="classref-method" ids="class-callable-method-get-bound-arguments" names="class_callable_method_get_bound_arguments"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> <strong>get_bound_arguments</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回绑定的参数（只要 <reference internal="True" refid="class-callable-method-get-bound-arguments-count"><inline classes="std std-ref">get_bound_arguments_count</inline></reference> 大于零）或者空数组（如果 <reference internal="True" refid="class-callable-method-get-bound-arguments-count"><inline classes="std std-ref">get_bound_arguments_count</inline></reference> 小于等于零）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-get-bound-arguments-count"></target>
            <paragraph classes="classref-method" ids="class-callable-method-get-bound-arguments-count" names="class_callable_method_get_bound_arguments_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_bound_arguments_count</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回通过成功调用 <reference internal="True" refid="class-callable-method-bind"><inline classes="std std-ref">bind</inline></reference> 或 <reference internal="True" refid="class-callable-method-unbind"><inline classes="std std-ref">unbind</inline></reference> 绑定（或解绑）参数的总数。如果解绑参数的总数比绑定参数大，则这个函数的返回值小于零。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-get-method"></target>
            <paragraph classes="classref-method" ids="class-callable-method-get-method" names="class_callable_method_get_method"><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>get_method</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该 <strong>Callable</strong> 所代表的方法的名称。如果该可调用体是 GDScript lambda 函数，则返回该函数的名称或 <literal>"&lt;anonymous lambda&gt;"</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-get-object"></target>
            <paragraph classes="classref-method" ids="class-callable-method-get-object" names="class_callable_method_get_object"><reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference> <strong>get_object</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该 <strong>Callable</strong> 所调用的对象。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-get-object-id"></target>
            <paragraph classes="classref-method" ids="class-callable-method-get-object-id" names="class_callable_method_get_object_id"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_object_id</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该 <strong>Callable</strong> 中对象的 ID（见 <reference internal="True" refuri="class_object#class-object-method-get-instance-id"><inline classes="std std-ref">Object.get_instance_id</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-hash"></target>
            <paragraph classes="classref-method" ids="class-callable-method-hash" names="class_callable_method_hash"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>hash</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该 <strong>Callable</strong> 对象的 32 位哈希值。</paragraph>
            <paragraph><strong>注意：</strong>内容相同的 <strong>Callable</strong> 哈希值始终相同。反之则不然，返回的哈希值相同<emphasis>并不</emphasis>意味着可调用体相等，因为不同的可调用体可能由于哈希冲突而具有相同的哈希值。引擎在 <reference internal="True" refid="class-callable-method-hash"><inline classes="std std-ref">hash</inline></reference> 中使用 32 位哈希算法。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-is-custom"></target>
            <paragraph classes="classref-method" ids="class-callable-method-is-custom" names="class_callable_method_is_custom"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_custom</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该 <strong>Callable</strong> 为自定义可调用体，则返回 <literal>true</literal>。自定义可调用体是由 <reference internal="True" refid="class-callable-method-bind"><inline classes="std std-ref">bind</inline></reference> 或 <reference internal="True" refid="class-callable-method-unbind"><inline classes="std std-ref">unbind</inline></reference> 创建的。在 GDScript 中，lambda 函数也是自定义可调用体。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-is-null"></target>
            <paragraph classes="classref-method" ids="class-callable-method-is-null" names="class_callable_method_is_null"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_null</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该 <strong>Callable</strong> 没有调用方法的目标，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-is-standard"></target>
            <paragraph classes="classref-method" ids="class-callable-method-is-standard" names="class_callable_method_is_standard"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_standard</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该 <strong>Callable</strong> 为标准可调用体，则返回 <literal>true</literal>。这个方法与 <reference internal="True" refid="class-callable-method-is-custom"><inline classes="std std-ref">is_custom</inline></reference> 相对。如果该可调用体为 lambda 函数，则返回 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-is-valid"></target>
            <paragraph classes="classref-method" ids="class-callable-method-is-valid" names="class_callable_method_is_valid"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该可调用体的对象存在，且分配了有效的方法名，或者为自定义可调用体，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-rpc"></target>
            <paragraph classes="classref-method" ids="class-callable-method-rpc" names="class_callable_method_rpc">void <strong>rpc</strong> <strong>(</strong> ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>在所有已连接的对等体上执行 RPC（Remote Procedure Call，远程过程调用）。用于多人游戏，一般不可用，除非所调用的函数有 <emphasis>RPC</emphasis> 标记（使用 <reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-rpc"><inline classes="std std-ref">@GDScript.@rpc</inline></reference> 或 <reference internal="True" refuri="class_node#class-node-method-rpc-config"><inline classes="std std-ref">Node.rpc_config</inline></reference>）。在不支持的方法上调用该方法会导致出错。见 <reference internal="True" refuri="class_node#class-node-method-rpc"><inline classes="std std-ref">Node.rpc</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-rpc-id"></target>
            <paragraph classes="classref-method" ids="class-callable-method-rpc-id" names="class_callable_method_rpc_id">void <strong>rpc_id</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> peer_id, ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>在指定的对等体 ID（请参阅多人游戏文档）上执行 RPC（Remote Procedure Call，远程过程调用）。用于多人游戏，一般不可用，除非所调用的函数有 <emphasis>RPC</emphasis> 标记（使用 <reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-rpc"><inline classes="std std-ref">@GDScript.@rpc</inline></reference> 或 <reference internal="True" refuri="class_node#class-node-method-rpc-config"><inline classes="std std-ref">Node.rpc_config</inline></reference>）。在不支持的方法上调用该方法会导致出错。见 <reference internal="True" refuri="class_node#class-node-method-rpc-id"><inline classes="std std-ref">Node.rpc_id</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-method-unbind"></target>
            <paragraph classes="classref-method" ids="class-callable-method-unbind" names="class_callable_method_unbind"><reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> <strong>unbind</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> argcount <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回这个 <strong>Callable</strong> 的副本，解绑了一些参数。换句话说，调用新的可调用体时，用户提供的最后几个参数会被忽略，忽略几个由 <literal>argcount</literal> 决定。剩余的参数会被传递给该可调用体。这样传入的参数就能够比原本可调用体所能处理的参数要多，例如带有固定数量参数的信号。另见 <reference internal="True" refid="class-callable-method-bind"><inline classes="std std-ref">bind</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>这个方法与其他类似方法链式调用时，参数列表的修改顺序是从右至左的。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    foo.unbind(1).call(1, 2) # 调用 foo(1).
    foo.bind(3, 4).unbind(1).call(1, 2) # 调用 foo(1, 3, 4)，注意改动的不是 bind 中的参数。</literal_block>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id7" names="操作符说明">
            <title>操作符说明</title>
            <target refid="class-callable-operator-neq-callable"></target>
            <paragraph classes="classref-operator" ids="class-callable-operator-neq-callable" names="class_callable_operator_neq_callable"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong> <strong>(</strong> <reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果两个 <strong>Callable</strong> 调用的目标不同，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-callable-operator-eq-callable"></target>
            <paragraph classes="classref-operator" ids="class-callable-operator-eq-callable" names="class_callable_operator_eq_callable"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong> <strong>(</strong> <reference internal="True" refid="class-callable"><inline classes="std std-ref">Callable</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果两个 <strong>Callable</strong> 调用的自定义目标相同，则返回 <literal>true</literal>。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
