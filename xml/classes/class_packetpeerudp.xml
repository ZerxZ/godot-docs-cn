<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_packetpeerudp.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/4.2/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/4.2/doc/classes/PacketPeerUDP.xml.</comment>
    <target refid="class-packetpeerudp"></target>
    <section ids="packetpeerudp class-packetpeerudp" names="packetpeerudp class_packetpeerudp">
        <title>PacketPeerUDP</title>
        <paragraph><strong>继承：</strong> <reference internal="True" refuri="class_packetpeer#class-packetpeer"><inline classes="std std-ref">PacketPeer</inline></reference> <strong>&lt;</strong> <reference internal="True" refuri="class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> <strong>&lt;</strong> <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference></paragraph>
        <paragraph>UDP 数据包客户端。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>UDP 数据包对等体。可用于发送原始 UDP 数据包，也可以发送 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>导出到安卓时，在导出项目、或使用一键部署之前，请务必在安卓导出预设中，开启 <literal>INTERNET</literal> 权限。否则，任何类型的网络通信，都将被 Android 阻止。</paragraph>
        </section>
        <section classes="classref-reftable-group" ids="id2" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="39"></colspec>
                    <colspec colwidth="182"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeerudp-method-bind"><inline classes="std std-ref">bind</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> port, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> bind_address="*", <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> recv_buf_size=65536 <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeerudp-method-close"><inline classes="std std-ref">close</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeerudp-method-connect-to-host"><inline classes="std std-ref">connect_to_host</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> host, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> port <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeerudp-method-get-local-port"><inline classes="std std-ref">get_local_port</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeerudp-method-get-packet-ip"><inline classes="std std-ref">get_packet_ip</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeerudp-method-get-packet-port"><inline classes="std std-ref">get_packet_port</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeerudp-method-is-bound"><inline classes="std std-ref">is_bound</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeerudp-method-is-socket-connected"><inline classes="std std-ref">is_socket_connected</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeerudp-method-join-multicast-group"><inline classes="std std-ref">join_multicast_group</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> multicast_address, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> interface_name <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeerudp-method-leave-multicast-group"><inline classes="std std-ref">leave_multicast_group</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> multicast_address, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> interface_name <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeerudp-method-set-broadcast-enabled"><inline classes="std std-ref">set_broadcast_enabled</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enabled <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeerudp-method-set-dest-address"><inline classes="std std-ref">set_dest_address</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> host, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> port <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeerudp-method-wait"><inline classes="std std-ref">wait</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id3" names="方法说明">
            <title>方法说明</title>
            <target refid="class-packetpeerudp-method-bind"></target>
            <paragraph classes="classref-method" ids="class-packetpeerudp-method-bind" names="class_packetpeerudp_method_bind"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>bind</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> port, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> bind_address="*", <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> recv_buf_size=65536 <strong>)</strong></paragraph>
            <paragraph>将该 <strong>PacketPeerUDP</strong> 绑定到指定的 <literal>port</literal> 和 <literal>bind_address</literal>，其缓冲区大小为 <literal>recv_buf_size</literal>，允许它接收传入的数据包。</paragraph>
            <paragraph>如果 <literal>bind_address</literal> 被设置为 <literal>"*"</literal>（默认），对等体将被绑定到所有可用地址（IPv4 和 IPv6）。</paragraph>
            <paragraph>如果 <literal>bind_address</literal> 被设置为 <literal>"0.0.0.0"</literal>（对于 IPv4）或 <literal>"::"</literal>（对于 IPv6），对等体将被绑定到匹配该 IP 类型的所有可用地址。</paragraph>
            <paragraph>如果 <literal>bind_address</literal> 被设置为任何有效地址（例如 <literal>"192.168.1.101"</literal>、<literal>"::1"</literal> 等），对等体将只被绑定到该地址的接口（如果不存在具有给定地址的接口，则失败）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeerudp-method-close"></target>
            <paragraph classes="classref-method" ids="class-packetpeerudp-method-close" names="class_packetpeerudp_method_close">void <strong>close</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>关闭该 <strong>PacketPeerUDP</strong> 底层 UDP 套接字。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeerudp-method-connect-to-host"></target>
            <paragraph classes="classref-method" ids="class-packetpeerudp-method-connect-to-host" names="class_packetpeerudp_method_connect_to_host"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>connect_to_host</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> host, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> port <strong>)</strong></paragraph>
            <paragraph>调用该方法将该 UDP 对等体连接到给定的 <literal>host</literal>/<literal>port</literal> 对。UDP 实际上是无连接的，因此该选项仅意味着自动丢弃来自不同地址的传入数据包，并且传出的数据包始终发送到连接的地址（不允许将来调用 <reference internal="True" refid="class-packetpeerudp-method-set-dest-address"><inline classes="std std-ref">set_dest_address</inline></reference>）。该方法不会向远程对等体发送任何数据，要发送数据，请像往常一样使用 <reference internal="True" refuri="class_packetpeer#class-packetpeer-method-put-var"><inline classes="std std-ref">PacketPeer.put_var</inline></reference> 或 <reference internal="True" refuri="class_packetpeer#class-packetpeer-method-put-packet"><inline classes="std std-ref">PacketPeer.put_packet</inline></reference>。另请参阅 <reference internal="True" refuri="class_udpserver#class-udpserver"><inline classes="std std-ref">UDPServer</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>连接到远程对等体并不能防止 IP 欺骗等恶意攻击。如果你觉得你的应用程序正在传输敏感信息，可以考虑使用 TLS 或 DTLS 等加密技术。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeerudp-method-get-local-port"></target>
            <paragraph classes="classref-method" ids="class-packetpeerudp-method-get-local-port" names="class_packetpeerudp_method_get_local_port"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_local_port</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该对等体绑定到的本地端口。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeerudp-method-get-packet-ip"></target>
            <paragraph classes="classref-method" ids="class-packetpeerudp-method-get-packet-ip" names="class_packetpeerudp_method_get_packet_ip"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_packet_ip</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回发送最后一个数据包（通过 <reference internal="True" refuri="class_packetpeer#class-packetpeer-method-get-packet"><inline classes="std std-ref">PacketPeer.get_packet</inline></reference> 或 <reference internal="True" refuri="class_packetpeer#class-packetpeer-method-get-var"><inline classes="std std-ref">PacketPeer.get_var</inline></reference> 接收）的远程对等体的 IP。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeerudp-method-get-packet-port"></target>
            <paragraph classes="classref-method" ids="class-packetpeerudp-method-get-packet-port" names="class_packetpeerudp_method_get_packet_port"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_packet_port</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回发送最后一个数据包（通过 <reference internal="True" refuri="class_packetpeer#class-packetpeer-method-get-packet"><inline classes="std std-ref">PacketPeer.get_packet</inline></reference> 或 <reference internal="True" refuri="class_packetpeer#class-packetpeer-method-get-var"><inline classes="std std-ref">PacketPeer.get_var</inline></reference> 接收）的远程对等方的端口。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeerudp-method-is-bound"></target>
            <paragraph classes="classref-method" ids="class-packetpeerudp-method-is-bound" names="class_packetpeerudp_method_is_bound"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_bound</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该 <strong>PacketPeerUDP</strong> 是否被绑定到某个地址上，并且可以接收数据包。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeerudp-method-is-socket-connected"></target>
            <paragraph classes="classref-method" ids="class-packetpeerudp-method-is-socket-connected" names="class_packetpeerudp_method_is_socket_connected"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_socket_connected</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果 UDP 套接字已打开并已连接到远程地址，则返回 <literal>true</literal>。见 <reference internal="True" refid="class-packetpeerudp-method-connect-to-host"><inline classes="std std-ref">connect_to_host</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeerudp-method-join-multicast-group"></target>
            <paragraph classes="classref-method" ids="class-packetpeerudp-method-join-multicast-group" names="class_packetpeerudp_method_join_multicast_group"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>join_multicast_group</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> multicast_address, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> interface_name <strong>)</strong></paragraph>
            <paragraph>使用由 <literal>interface_name</literal> 标识的接口加入由 <literal>multicast_address</literal> 指定的多播组。</paragraph>
            <paragraph>可以使用多个接口加入同一个多播组。使用 <reference internal="True" refuri="class_ip#class-ip-method-get-local-interfaces"><inline classes="std std-ref">IP.get_local_interfaces</inline></reference> 了解哪些接口可用。</paragraph>
            <paragraph><strong>注意：</strong>某些 Android 设备可能需要 <literal>CHANGE_WIFI_MULTICAST_STATE</literal> 权限才能进行多播。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeerudp-method-leave-multicast-group"></target>
            <paragraph classes="classref-method" ids="class-packetpeerudp-method-leave-multicast-group" names="class_packetpeerudp_method_leave_multicast_group"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>leave_multicast_group</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> multicast_address, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> interface_name <strong>)</strong></paragraph>
            <paragraph>从 <literal>multicast_address</literal> 指定的组播组中移除 <literal>interface_name</literal> 标识的接口。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeerudp-method-set-broadcast-enabled"></target>
            <paragraph classes="classref-method" ids="class-packetpeerudp-method-set-broadcast-enabled" names="class_packetpeerudp_method_set_broadcast_enabled">void <strong>set_broadcast_enabled</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enabled <strong>)</strong></paragraph>
            <paragraph>启用或禁用广播数据包的发送（例如：<literal>set_dest_address("255.255.255.255", 4343)</literal>。这个选项在默认情况下是禁用的。</paragraph>
            <paragraph><strong>注意：</strong>一些 Android 设备可能需要 <literal>CHANGE_WIFI_MULTICAST_STATE</literal> 权限和本选项被启用来接收广播包。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeerudp-method-set-dest-address"></target>
            <paragraph classes="classref-method" ids="class-packetpeerudp-method-set-dest-address" names="class_packetpeerudp_method_set_dest_address"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>set_dest_address</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> host, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> port <strong>)</strong></paragraph>
            <paragraph>设置发送数据包和变量的目标地址和端口。如果需要，将使用 DNS 解析主机名。</paragraph>
            <paragraph><strong>注意：</strong>在向广播地址（例如：<literal>255.255.255.255</literal>）发送数据包之前，必须启用 <reference internal="True" refid="class-packetpeerudp-method-set-broadcast-enabled"><inline classes="std std-ref">set_broadcast_enabled</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeerudp-method-wait"></target>
            <paragraph classes="classref-method" ids="class-packetpeerudp-method-wait" names="class_packetpeerudp_method_wait"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>wait</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>等待数据包到达绑定的地址。见 <reference internal="True" refid="class-packetpeerudp-method-bind"><inline classes="std std-ref">bind</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong><reference internal="True" refid="class-packetpeerudp-method-wait"><inline classes="std std-ref">wait</inline></reference> 一旦被调用就无法中断。解决方法是让对方发送一个特定的“毒药”数据包，如下所示：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">socket = PacketPeerUDP.new()
# 服务端
socket.set_dest_address("127.0.0.1", 789)
socket.put_packet("Time to stop".to_ascii_buffer())

# 客户端
while socket.wait() == OK:
    var data = socket.get_packet().get_string_from_ascii()
    if data == "Time to stop":
        return</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var socket = new PacketPeerUDP();
// 服务端
socket.SetDestAddress("127.0.0.1", 789);
socket.PutPacket("Time to stop".ToAsciiBuffer());

// 客户端
while (socket.Wait() == OK)
{
    string data = socket.GetPacket().GetStringFromASCII();
    if (data == "Time to stop")
    {
        return;
    }
}</literal_block>
                </div>
            </container>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
