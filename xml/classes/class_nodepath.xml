<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_nodepath.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/master/doc/classes/NodePath.xml.</comment>
    <target refid="class-nodepath"></target>
    <section ids="nodepath class-nodepath" names="nodepath class_nodepath">
        <title>NodePath</title>
        <paragraph>预先解析的场景树路径。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>The <strong>NodePath</strong> built-in <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> type represents a path to a node or property in a hierarchy of nodes. It is designed to be efficiently passed into many built-in methods (such as <reference internal="True" refuri="class_node#class-node-method-get-node"><inline classes="std std-ref">Node.get_node</inline></reference>, <reference internal="True" refuri="class_object#class-object-method-set-indexed"><inline classes="std std-ref">Object.set_indexed</inline></reference>, <reference internal="True" refuri="class_tween#class-tween-method-tween-property"><inline classes="std std-ref">Tween.tween_property</inline></reference>, etc.) without a hard dependence on the node or property they point to.</paragraph>
            <paragraph>A node path is represented as a <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> composed of slash-separated (<literal>/</literal>) node names and colon-separated (<literal>:</literal>) property names (also called "subnames"). Similar to a filesystem path, <literal>".."</literal> and <literal>"."</literal> are special node names. They refer to the parent node and the current node, respectively.</paragraph>
            <paragraph>The following examples are paths relative to the current node:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">^"A"     # Points to the direct child A.
^"A/B"   # Points to A's child B.
^"."     # Points to the current node.
^".."    # Points to the parent node.
^"../C"  # Points to the sibling node C.
^"../.." # Points to the grandparent node.</literal_block>
            <paragraph>A leading slash means the path is absolute, and begins from the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">^"/root"            # Points to the SceneTree's root Window.
^"/root/Title"      # May point to the main scene's root node named "Title".
^"/root/Global"     # May point to an autoloaded node or scene named "Global".</literal_block>
            <paragraph>Despite their name, node paths may also point to a property:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">^":position"           # Points to this object's position.
^":position:x"         # Points to this object's position in the x axis.
^"Camera3D:rotation:y" # Points to the child Camera3D and its y rotation.
^"/root:size:x"        # Points to the root Window and its width.</literal_block>
            <paragraph>In some situations, it's possible to omit the leading <literal>:</literal> when pointing to an object's property. As an example, this is the case with <reference internal="True" refuri="class_object#class-object-method-set-indexed"><inline classes="std std-ref">Object.set_indexed</inline></reference> and <reference internal="True" refuri="class_tween#class-tween-method-tween-property"><inline classes="std std-ref">Tween.tween_property</inline></reference>, as those methods call <reference internal="True" refid="class-nodepath-method-get-as-property-path"><inline classes="std std-ref">get_as_property_path</inline></reference> under the hood. However, it's generally recommended to keep the <literal>:</literal> prefix.</paragraph>
            <paragraph>Node paths cannot check whether they are valid and may point to nodes or properties that do not exist. Their meaning depends entirely on the context in which they're used.</paragraph>
            <paragraph>You usually do not have to worry about the <strong>NodePath</strong> type, as strings are automatically converted to the type when necessary. There are still times when defining node paths is useful. For example, exported <strong>NodePath</strong> properties allow you to easily select any node within the currently edited scene. They are also automatically updated when moving, renaming or deleting nodes in the scene tree editor. See also <reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-export-node-path"><inline classes="std std-ref">@GDScript.@export_node_path</inline></reference>.</paragraph>
            <paragraph>See also <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, which is a similar type designed for optimized strings.</paragraph>
            <paragraph><strong>Note:</strong> In a boolean context, a <strong>NodePath</strong> will evaluate to <literal>false</literal> if it is empty (<literal>NodePath("")</literal>). Otherwise, a <strong>NodePath</strong> will always evaluate to <literal>true</literal>.</paragraph>
            <note>
                <paragraph>通过 C# 使用该 API 时会有显著不同，详见 <reference internal="True" refuri="../tutorials/scripting/c_sharp/c_sharp_differences#doc-c-sharp-differences"><inline classes="std std-ref">C# API 与 GDScript 的差异</inline></reference>。</paragraph>
            </note>
        </section>
        <section classes="classref-introduction-group" ids="id2" names="教程">
            <title>教程</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="2D 角色扮演游戏（RPG）演示" refuri="https://godotengine.org/asset-library/asset/2729">2D 角色扮演游戏（RPG）演示</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="构造函数">
            <title>构造函数</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="33"></colspec>
                    <colspec colwidth="100"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-constructor-nodepath"><inline classes="std std-ref">NodePath</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-constructor-nodepath"><inline classes="std std-ref">NodePath</inline></reference>(from: <reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-constructor-nodepath"><inline classes="std std-ref">NodePath</inline></reference>(from: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id4" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="37"></colspec>
                    <colspec colwidth="130"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-method-get-as-property-path"><inline classes="std std-ref">get_as_property_path</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-method-get-concatenated-names"><inline classes="std std-ref">get_concatenated_names</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-method-get-concatenated-subnames"><inline classes="std std-ref">get_concatenated_subnames</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-method-get-name"><inline classes="std std-ref">get_name</inline></reference>(idx: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-method-get-name-count"><inline classes="std std-ref">get_name_count</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-method-get-subname"><inline classes="std std-ref">get_subname</inline></reference>(idx: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-method-get-subname-count"><inline classes="std std-ref">get_subname_count</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-method-hash"><inline classes="std std-ref">hash</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-method-is-absolute"><inline classes="std std-ref">is_absolute</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-method-is-empty"><inline classes="std std-ref">is_empty</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-method-slice"><inline classes="std std-ref">slice</inline></reference>(begin: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, end: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 2147483647) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id5" names="运算符">
            <title>运算符</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="25"></colspec>
                    <colspec colwidth="105"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-operator-neq-nodepath"><inline classes="std std-ref">operator !=</inline></reference>(right: <reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-nodepath-operator-eq-nodepath"><inline classes="std std-ref">operator ==</inline></reference>(right: <reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id6" names="构造函数说明">
            <title>构造函数说明</title>
            <target refid="class-nodepath-constructor-nodepath"></target>
            <paragraph classes="classref-constructor" ids="class-nodepath-constructor-nodepath" names="class_nodepath_constructor_nodepath"><reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> <strong>NodePath</strong>() <reference internal="True" refid="class-nodepath-constructor-nodepath"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>构造空的 <strong>NodePath</strong>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> <strong>NodePath</strong>(from: <reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>)</paragraph>
            <paragraph>构造一个 <strong>NodePath</strong> 作为给定 <strong>NodePath</strong> 的副本。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> <strong>NodePath</strong>(from: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> 构造 <strong>NodePath</strong>。如果以斜杠为前缀，则创建的路径是绝对路径（请参阅 <reference internal="True" refid="class-nodepath-method-is-absolute"><inline classes="std std-ref">is_absolute</inline></reference>）。</paragraph>
            <paragraph>在到目标节点的路径后可以选择包含“子名称”，它可以指向属性，也可以被嵌套。</paragraph>
            <paragraph>可以作为节点路径的字符串的示例：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># 指向 Sprite2D 节点。
"Level/RigidBody2D/Sprite2D"

# 指向 Sprite2D 节点及其“纹理（texture）”资源。
# get_node() 将检索 Sprite2D，而 get_node_and_resource()
# 将同时检索该 Sprite2D 节点和其“纹理（texture）”资源。
"Level/RigidBody2D/Sprite2D:texture"

# 指向 Sprite2D 节点及其“位置（position）”属性。
"Level/RigidBody2D/Sprite2D:position"

# 指向 Sprite2D 节点及其“位置（position）”属性的 “x” 分量。
"Level/RigidBody2D/Sprite2D:position:x"

# 指向 RigidBody2D 节点作为从 SceneTree 开始的绝对路径。
"/root/Level/RigidBody2D"</literal_block>
            <paragraph><strong>注意：</strong>在 GDScript 中，也可以通过在常量字符串前面加上 <literal>^</literal> 前缀，来将常量字符串转换为节点路径。<literal>^"path/to/node"</literal> 相当于 <literal>NodePath("path/to/node")</literal>。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id7" names="方法说明">
            <title>方法说明</title>
            <target refid="class-nodepath-method-get-as-property-path"></target>
            <paragraph classes="classref-method" ids="class-nodepath-method-get-as-property-path" names="class_nodepath_method_get_as_property_path"><reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> <strong>get_as_property_path</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-nodepath-method-get-as-property-path"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该节点路径带有冒号字符（<literal>:</literal>）前缀的副本，将其转换为没有节点名称的纯属性路径（相对于当前节点）。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># node_path 指向名为 “position” 的子节点的 “x” 属性。
var node_path = ^"position:x"

# property_path 指向该节点在 “x” 轴上的 “position”。
var property_path = node_path.get_as_property_path()
print(property_path) # 打印 “:position:x”</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// node_path 指向名为 “position” 的子节点的 “x” 属性。
var nodePath = new NodePath("position:x");

// property_path 指向该节点在 “x” 轴上的 “position”。
NodePath propertyPath = nodePath.GetAsPropertyPath();
GD.Print(propertyPath); // 打印 “:position:x”。</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-nodepath-method-get-concatenated-names"></target>
            <paragraph classes="classref-method" ids="class-nodepath-method-get-concatenated-names" names="class_nodepath_method_get_concatenated_names"><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>get_concatenated_names</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-nodepath-method-get-concatenated-names"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将与斜杠字符（<literal>/</literal>）连接的所有节点名称作为单个 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> 返回。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-nodepath-method-get-concatenated-subnames"></target>
            <paragraph classes="classref-method" ids="class-nodepath-method-get-concatenated-subnames" names="class_nodepath_method_get_concatenated_subnames"><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>get_concatenated_subnames</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-nodepath-method-get-concatenated-subnames"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将与冒号字符（<literal>:</literal>）连接的所有属性子名称作为单个 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> 返回。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var node_path = ^"Sprite2D:texture:resource_name"
print(node_path.get_concatenated_subnames()) # 打印 “texture:resource_name”。</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var nodePath = new NodePath("Sprite2D:texture:resource_name");
GD.Print(nodePath.GetConcatenatedSubnames()); // 打印 “texture:resource_name”。</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-nodepath-method-get-name"></target>
            <paragraph classes="classref-method" ids="class-nodepath-method-get-name" names="class_nodepath_method_get_name"><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>get_name</strong>(idx: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-nodepath-method-get-name"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回由从 0 开始的 <literal>idx</literal> 指示的节点名称。如果 <literal>idx</literal> 超出范围，则会生成错误。另请参阅 <reference internal="True" refid="class-nodepath-method-get-subname-count"><inline classes="std std-ref">get_subname_count</inline></reference> 和 <reference internal="True" refid="class-nodepath-method-get-name-count"><inline classes="std std-ref">get_name_count</inline></reference>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var sprite_path = NodePath("../RigidBody2D/Sprite2D")
print(sprite_path.get_name(0)) # 打印 “..”。
print(sprite_path.get_name(1)) # 打印 “RigidBody2D”。
print(sprite_path.get_name(2)) # 打印 “Sprite”。</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var spritePath = new NodePath("../RigidBody2D/Sprite2D");
GD.Print(spritePath.GetName(0)); // 打印 “..”。
GD.Print(spritePath.GetName(1)); // 打印 “PathFollow2D”。
GD.Print(spritePath.GetName(2)); // 打印 “Sprite”。</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-nodepath-method-get-name-count"></target>
            <paragraph classes="classref-method" ids="class-nodepath-method-get-name-count" names="class_nodepath_method_get_name_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_name_count</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-nodepath-method-get-name-count"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回路径中节点名称的数量。不包括属性子名称。</paragraph>
            <paragraph>例如，<literal>"../RigidBody2D/Sprite2D:texture"</literal> 包含 3 个节点名称。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-nodepath-method-get-subname"></target>
            <paragraph classes="classref-method" ids="class-nodepath-method-get-subname" names="class_nodepath_method_get_subname"><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>get_subname</strong>(idx: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-nodepath-method-get-subname"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回由从 0 开始的 <literal>idx</literal> 指示的属性名称。如果 <literal>idx</literal> 超出范围，则会生成错误。另请参阅 <reference internal="True" refid="class-nodepath-method-get-subname-count"><inline classes="std std-ref">get_subname_count</inline></reference>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var path_to_name = NodePath("Sprite2D:texture:resource_name")
print(path_to_name.get_subname(0)) # 打印 “texture”。
print(path_to_name.get_subname(1)) # 打印 “resource_name”。</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var pathToName = new NodePath("Sprite2D:texture:resource_name");
GD.Print(pathToName.GetSubname(0)); // 打印 “texture”。
GD.Print(pathToName.GetSubname(1)); // 打印 “resource_name”。</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-nodepath-method-get-subname-count"></target>
            <paragraph classes="classref-method" ids="class-nodepath-method-get-subname-count" names="class_nodepath_method_get_subname_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_subname_count</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-nodepath-method-get-subname-count"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回路径中属性名称（“子名称”）的数量。节点路径中的每个子名称都列在冒号字符（<literal>:</literal>）之后。</paragraph>
            <paragraph>例如，<literal>"Level/RigidBody2D/Sprite2D:texture:resource_name"</literal> 包含 2 个子名称。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-nodepath-method-hash"></target>
            <paragraph classes="classref-method" ids="class-nodepath-method-hash" names="class_nodepath_method_hash"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>hash</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-nodepath-method-hash"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回代表该节点路径内容的 32 位哈希值。</paragraph>
            <paragraph><strong>注意：</strong>由于哈希冲突，具有相等哈希值的节点路径<emphasis>无法</emphasis>保证相同。不同哈希值的节点路径保证是不同的。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-nodepath-method-is-absolute"></target>
            <paragraph classes="classref-method" ids="class-nodepath-method-is-absolute" names="class_nodepath_method_is_absolute"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_absolute</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-nodepath-method-is-absolute"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果节点路径是绝对路径，则返回 <literal>true</literal>。与相对路径不同，绝对路径由前导斜杠字符（<literal>/</literal>）表示，并且始终从 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 开始。它可用于从根节点可靠地访问节点（例如，如果存在名为 “Global” 的自动加载，则 <literal>"/root/Global"</literal>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-nodepath-method-is-empty"></target>
            <paragraph classes="classref-method" ids="class-nodepath-method-is-empty" names="class_nodepath_method_is_empty"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_empty</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-nodepath-method-is-empty"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果节点路径是从空的 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>（<literal>""</literal>）构造的，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-nodepath-method-slice"></target>
            <paragraph classes="classref-method" ids="class-nodepath-method-slice" names="class_nodepath_method_slice"><reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> <strong>slice</strong>(begin: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, end: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 2147483647) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-nodepath-method-slice"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该 <strong>NodePath</strong> 的切片，是从 <literal>begin</literal>（含）到 <literal>end</literal>（不含）的全新 <strong>NodePath</strong>。</paragraph>
            <paragraph><literal>begin</literal> 和 <literal>end</literal> 的绝对值将被限制为 <reference internal="True" refid="class-nodepath-method-get-name-count"><inline classes="std std-ref">get_name_count</inline></reference> 和 <reference internal="True" refid="class-nodepath-method-get-subname-count"><inline classes="std std-ref">get_subname_count</inline></reference> 的总和，因此 <literal>end</literal> 的默认值默认会使其切片到 <strong>NodePath</strong> 的末尾（即 <literal>path.slice(1)</literal> 是 <literal>path.slice(1, path.get_name_count() + path.get_subname_count())</literal> 的简写）。</paragraph>
            <paragraph>如果 <literal>begin</literal> 或 <literal>end</literal> 为负，则表示相对于 <strong>NodePath</strong> 的末尾（即 <literal>path.slice(0, -2)</literal> 是 <literal>path.slice(0, path.get_name_count() + path.get_subname_count() - 2)</literal> 的简写）。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id8" names="运算符说明">
            <title>运算符说明</title>
            <target refid="class-nodepath-operator-neq-nodepath"></target>
            <paragraph classes="classref-operator" ids="class-nodepath-operator-neq-nodepath" names="class_nodepath_operator_neq_nodepath"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong>(right: <reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>) <reference internal="True" refid="class-nodepath-operator-neq-nodepath"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果两个节点路径不相等，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-nodepath-operator-eq-nodepath"></target>
            <paragraph classes="classref-operator" ids="class-nodepath-operator-eq-nodepath" names="class_nodepath_operator_eq_nodepath"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong>(right: <reference internal="True" refid="class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>) <reference internal="True" refid="class-nodepath-operator-eq-nodepath"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果两个节点路径相等，即它们由相同的节点名称和子名称按相同的顺序组成，则返回 <literal>true</literal>。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了能接受在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效运算符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列位标志构成位掩码的整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="void"><abbreviation explanation="无返回值。">void</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
