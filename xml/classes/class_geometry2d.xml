<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_geometry2d.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/master/doc/classes/Geometry2D.xml.</comment>
    <target refid="class-geometry2d"></target>
    <section ids="geometry2d class-geometry2d" names="geometry2d class_geometry2d">
        <title>Geometry2D</title>
        <paragraph><strong>Inherits:</strong> <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference></paragraph>
        <paragraph>Provides methods for some common 2D geometric operations.</paragraph>
        <section classes="classref-introduction-group" ids="description" names="description">
            <title>Description</title>
            <paragraph>Provides a set of helper functions to create geometric shapes, compute intersections between shapes, and process various other geometric operations in 2D.</paragraph>
        </section>
        <section classes="classref-reftable-group" ids="methods" names="methods">
            <title>Methods</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="82"></colspec>
                    <colspec colwidth="301"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_vector2i#class-vector2i"><inline classes="std std-ref">Vector2i</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-bresenham-line"><inline classes="std std-ref">bresenham_line</inline></reference>(from: <reference internal="True" refuri="class_vector2i#class-vector2i"><inline classes="std std-ref">Vector2i</inline></reference>, to: <reference internal="True" refuri="class_vector2i#class-vector2i"><inline classes="std std-ref">Vector2i</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-clip-polygons"><inline classes="std std-ref">clip_polygons</inline></reference>(polygon_a: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, polygon_b: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-clip-polyline-with-polygon"><inline classes="std std-ref">clip_polyline_with_polygon</inline></reference>(polyline: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, polygon: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-convex-hull"><inline classes="std std-ref">convex_hull</inline></reference>(points: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-decompose-polygon-in-convex"><inline classes="std std-ref">decompose_polygon_in_convex</inline></reference>(polygon: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-exclude-polygons"><inline classes="std std-ref">exclude_polygons</inline></reference>(polygon_a: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, polygon_b: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-get-closest-point-to-segment"><inline classes="std std-ref">get_closest_point_to_segment</inline></reference>(point: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, s1: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, s2: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-get-closest-point-to-segment-uncapped"><inline classes="std std-ref">get_closest_point_to_segment_uncapped</inline></reference>(point: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, s1: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, s2: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-get-closest-points-between-segments"><inline classes="std std-ref">get_closest_points_between_segments</inline></reference>(p1: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, q1: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, p2: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, q2: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-intersect-polygons"><inline classes="std std-ref">intersect_polygons</inline></reference>(polygon_a: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, polygon_b: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-intersect-polyline-with-polygon"><inline classes="std std-ref">intersect_polyline_with_polygon</inline></reference>(polyline: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, polygon: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-is-point-in-circle"><inline classes="std std-ref">is_point_in_circle</inline></reference>(point: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, circle_position: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, circle_radius: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-is-point-in-polygon"><inline classes="std std-ref">is_point_in_polygon</inline></reference>(point: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, polygon: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-is-polygon-clockwise"><inline classes="std std-ref">is_polygon_clockwise</inline></reference>(polygon: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-line-intersects-line"><inline classes="std std-ref">line_intersects_line</inline></reference>(from_a: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, dir_a: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, from_b: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, dir_b: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-make-atlas"><inline classes="std std-ref">make_atlas</inline></reference>(sizes: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-merge-polygons"><inline classes="std std-ref">merge_polygons</inline></reference>(polygon_a: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, polygon_b: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-offset-polygon"><inline classes="std std-ref">offset_polygon</inline></reference>(polygon: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, delta: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>, join_type: <reference internal="True" refid="enum-geometry2d-polyjointype"><inline classes="std std-ref">PolyJoinType</inline></reference> = 0)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-offset-polyline"><inline classes="std std-ref">offset_polyline</inline></reference>(polyline: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, delta: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>, join_type: <reference internal="True" refid="enum-geometry2d-polyjointype"><inline classes="std std-ref">PolyJoinType</inline></reference> = 0, end_type: <reference internal="True" refid="enum-geometry2d-polyendtype"><inline classes="std std-ref">PolyEndType</inline></reference> = 3)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-point-is-inside-triangle"><inline classes="std std-ref">point_is_inside_triangle</inline></reference>(point: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, a: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, b: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, c: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-segment-intersects-circle"><inline classes="std std-ref">segment_intersects_circle</inline></reference>(segment_from: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, segment_to: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, circle_position: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, circle_radius: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-segment-intersects-segment"><inline classes="std std-ref">segment_intersects_segment</inline></reference>(from_a: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, to_a: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, from_b: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, to_b: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-triangulate-delaunay"><inline classes="std std-ref">triangulate_delaunay</inline></reference>(points: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-geometry2d-method-triangulate-polygon"><inline classes="std std-ref">triangulate_polygon</inline></reference>(polygon: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="enumerations" names="enumerations">
            <title>Enumerations</title>
            <target refid="enum-geometry2d-polybooleanoperation"></target>
            <paragraph classes="classref-enumeration" ids="enum-geometry2d-polybooleanoperation" names="enum_geometry2d_polybooleanoperation">enum <strong>PolyBooleanOperation</strong>: <reference internal="True" refid="enum-geometry2d-polybooleanoperation"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <target refid="class-geometry2d-constant-operation-union"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-geometry2d-constant-operation-union" names="class_geometry2d_constant_operation_union"><reference internal="True" refid="enum-geometry2d-polybooleanoperation"><inline classes="std std-ref">PolyBooleanOperation</inline></reference> <strong>OPERATION_UNION</strong> = <literal>0</literal></paragraph>
            <paragraph>Create regions where either subject or clip polygons (or both) are filled.</paragraph>
            <target refid="class-geometry2d-constant-operation-difference"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-geometry2d-constant-operation-difference" names="class_geometry2d_constant_operation_difference"><reference internal="True" refid="enum-geometry2d-polybooleanoperation"><inline classes="std std-ref">PolyBooleanOperation</inline></reference> <strong>OPERATION_DIFFERENCE</strong> = <literal>1</literal></paragraph>
            <paragraph>Create regions where subject polygons are filled except where clip polygons are filled.</paragraph>
            <target refid="class-geometry2d-constant-operation-intersection"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-geometry2d-constant-operation-intersection" names="class_geometry2d_constant_operation_intersection"><reference internal="True" refid="enum-geometry2d-polybooleanoperation"><inline classes="std std-ref">PolyBooleanOperation</inline></reference> <strong>OPERATION_INTERSECTION</strong> = <literal>2</literal></paragraph>
            <paragraph>Create regions where both subject and clip polygons are filled.</paragraph>
            <target refid="class-geometry2d-constant-operation-xor"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-geometry2d-constant-operation-xor" names="class_geometry2d_constant_operation_xor"><reference internal="True" refid="enum-geometry2d-polybooleanoperation"><inline classes="std std-ref">PolyBooleanOperation</inline></reference> <strong>OPERATION_XOR</strong> = <literal>3</literal></paragraph>
            <paragraph>Create regions where either subject or clip polygons are filled but not where both are filled.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-geometry2d-polyjointype"></target>
            <paragraph classes="classref-enumeration" ids="enum-geometry2d-polyjointype" names="enum_geometry2d_polyjointype">enum <strong>PolyJoinType</strong>: <reference internal="True" refid="enum-geometry2d-polyjointype"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <target refid="class-geometry2d-constant-join-square"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-geometry2d-constant-join-square" names="class_geometry2d_constant_join_square"><reference internal="True" refid="enum-geometry2d-polyjointype"><inline classes="std std-ref">PolyJoinType</inline></reference> <strong>JOIN_SQUARE</strong> = <literal>0</literal></paragraph>
            <paragraph>Squaring is applied uniformally at all convex edge joins at <literal>1 * delta</literal>.</paragraph>
            <target refid="class-geometry2d-constant-join-round"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-geometry2d-constant-join-round" names="class_geometry2d_constant_join_round"><reference internal="True" refid="enum-geometry2d-polyjointype"><inline classes="std std-ref">PolyJoinType</inline></reference> <strong>JOIN_ROUND</strong> = <literal>1</literal></paragraph>
            <paragraph>While flattened paths can never perfectly trace an arc, they are approximated by a series of arc chords.</paragraph>
            <target refid="class-geometry2d-constant-join-miter"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-geometry2d-constant-join-miter" names="class_geometry2d_constant_join_miter"><reference internal="True" refid="enum-geometry2d-polyjointype"><inline classes="std std-ref">PolyJoinType</inline></reference> <strong>JOIN_MITER</strong> = <literal>2</literal></paragraph>
            <paragraph>There's a necessary limit to mitered joins since offsetting edges that join at very acute angles will produce excessively long and narrow "spikes". For any given edge join, when miter offsetting would exceed that maximum distance, "square" joining is applied.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-geometry2d-polyendtype"></target>
            <paragraph classes="classref-enumeration" ids="enum-geometry2d-polyendtype" names="enum_geometry2d_polyendtype">enum <strong>PolyEndType</strong>: <reference internal="True" refid="enum-geometry2d-polyendtype"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <target refid="class-geometry2d-constant-end-polygon"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-geometry2d-constant-end-polygon" names="class_geometry2d_constant_end_polygon"><reference internal="True" refid="enum-geometry2d-polyendtype"><inline classes="std std-ref">PolyEndType</inline></reference> <strong>END_POLYGON</strong> = <literal>0</literal></paragraph>
            <paragraph>Endpoints are joined using the <reference internal="True" refid="enum-geometry2d-polyjointype"><inline classes="std std-ref">PolyJoinType</inline></reference> value and the path filled as a polygon.</paragraph>
            <target refid="class-geometry2d-constant-end-joined"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-geometry2d-constant-end-joined" names="class_geometry2d_constant_end_joined"><reference internal="True" refid="enum-geometry2d-polyendtype"><inline classes="std std-ref">PolyEndType</inline></reference> <strong>END_JOINED</strong> = <literal>1</literal></paragraph>
            <paragraph>Endpoints are joined using the <reference internal="True" refid="enum-geometry2d-polyjointype"><inline classes="std std-ref">PolyJoinType</inline></reference> value and the path filled as a polyline.</paragraph>
            <target refid="class-geometry2d-constant-end-butt"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-geometry2d-constant-end-butt" names="class_geometry2d_constant_end_butt"><reference internal="True" refid="enum-geometry2d-polyendtype"><inline classes="std std-ref">PolyEndType</inline></reference> <strong>END_BUTT</strong> = <literal>2</literal></paragraph>
            <paragraph>Endpoints are squared off with no extension.</paragraph>
            <target refid="class-geometry2d-constant-end-square"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-geometry2d-constant-end-square" names="class_geometry2d_constant_end_square"><reference internal="True" refid="enum-geometry2d-polyendtype"><inline classes="std std-ref">PolyEndType</inline></reference> <strong>END_SQUARE</strong> = <literal>3</literal></paragraph>
            <paragraph>Endpoints are squared off and extended by <literal>delta</literal> units.</paragraph>
            <target refid="class-geometry2d-constant-end-round"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-geometry2d-constant-end-round" names="class_geometry2d_constant_end_round"><reference internal="True" refid="enum-geometry2d-polyendtype"><inline classes="std std-ref">PolyEndType</inline></reference> <strong>END_ROUND</strong> = <literal>4</literal></paragraph>
            <paragraph>Endpoints are rounded off and extended by <literal>delta</literal> units.</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="method-descriptions" names="method\ descriptions">
            <title>Method Descriptions</title>
            <target refid="class-geometry2d-method-bresenham-line"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-bresenham-line" names="class_geometry2d_method_bresenham_line"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_vector2i#class-vector2i"><inline classes="std std-ref">Vector2i</inline></reference>] <strong>bresenham_line</strong>(from: <reference internal="True" refuri="class_vector2i#class-vector2i"><inline classes="std std-ref">Vector2i</inline></reference>, to: <reference internal="True" refuri="class_vector2i#class-vector2i"><inline classes="std std-ref">Vector2i</inline></reference>) <reference internal="True" refid="class-geometry2d-method-bresenham-line"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the <reference name="Bresenham line" refuri="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Bresenham line</reference> between the <literal>from</literal> and <literal>to</literal> points. A Bresenham line is a series of pixels that draws a line and is always 1-pixel thick on every row and column of the drawing (never more, never less).</paragraph>
            <paragraph>Example code to draw a line between two <reference internal="True" refuri="class_marker2d#class-marker2d"><inline classes="std std-ref">Marker2D</inline></reference> nodes using a series of <reference internal="True" refuri="class_canvasitem#class-canvasitem-method-draw-rect"><inline classes="std std-ref">CanvasItem.draw_rect()</inline></reference> calls:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _draw():
    for pixel in Geometry2D.bresenham_line($MarkerA.position, $MarkerB.position):
        draw_rect(Rect2(pixel, Vector2.ONE), Color.WHITE)</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-clip-polygons"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-clip-polygons" names="class_geometry2d_method_clip_polygons"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>] <strong>clip_polygons</strong>(polygon_a: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, polygon_b: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>) <reference internal="True" refid="class-geometry2d-method-clip-polygons"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Clips <literal>polygon_a</literal> against <literal>polygon_b</literal> and returns an array of clipped polygons. This performs <reference internal="True" refid="class-geometry2d-constant-operation-difference"><inline classes="std std-ref">OPERATION_DIFFERENCE</inline></reference> between polygons. Returns an empty array if <literal>polygon_b</literal> completely overlaps <literal>polygon_a</literal>.</paragraph>
            <paragraph>If <literal>polygon_b</literal> is enclosed by <literal>polygon_a</literal>, returns an outer polygon (boundary) and inner polygon (hole) which could be distinguished by calling <reference internal="True" refid="class-geometry2d-method-is-polygon-clockwise"><inline classes="std std-ref">is_polygon_clockwise()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-clip-polyline-with-polygon"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-clip-polyline-with-polygon" names="class_geometry2d_method_clip_polyline_with_polygon"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>] <strong>clip_polyline_with_polygon</strong>(polyline: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, polygon: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>) <reference internal="True" refid="class-geometry2d-method-clip-polyline-with-polygon"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Clips <literal>polyline</literal> against <literal>polygon</literal> and returns an array of clipped polylines. This performs <reference internal="True" refid="class-geometry2d-constant-operation-difference"><inline classes="std std-ref">OPERATION_DIFFERENCE</inline></reference> between the polyline and the polygon. This operation can be thought of as cutting a line with a closed shape.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-convex-hull"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-convex-hull" names="class_geometry2d_method_convex_hull"><reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference> <strong>convex_hull</strong>(points: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>) <reference internal="True" refid="class-geometry2d-method-convex-hull"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Given an array of <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>s, returns the convex hull as a list of points in counterclockwise order. The last point is the same as the first one.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-decompose-polygon-in-convex"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-decompose-polygon-in-convex" names="class_geometry2d_method_decompose_polygon_in_convex"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>] <strong>decompose_polygon_in_convex</strong>(polygon: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>) <reference internal="True" refid="class-geometry2d-method-decompose-polygon-in-convex"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Decomposes the <literal>polygon</literal> into multiple convex hulls and returns an array of <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-exclude-polygons"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-exclude-polygons" names="class_geometry2d_method_exclude_polygons"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>] <strong>exclude_polygons</strong>(polygon_a: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, polygon_b: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>) <reference internal="True" refid="class-geometry2d-method-exclude-polygons"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Mutually excludes common area defined by intersection of <literal>polygon_a</literal> and <literal>polygon_b</literal> (see <reference internal="True" refid="class-geometry2d-method-intersect-polygons"><inline classes="std std-ref">intersect_polygons()</inline></reference>) and returns an array of excluded polygons. This performs <reference internal="True" refid="class-geometry2d-constant-operation-xor"><inline classes="std std-ref">OPERATION_XOR</inline></reference> between polygons. In other words, returns all but common area between polygons.</paragraph>
            <paragraph>The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling <reference internal="True" refid="class-geometry2d-method-is-polygon-clockwise"><inline classes="std std-ref">is_polygon_clockwise()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-get-closest-point-to-segment"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-get-closest-point-to-segment" names="class_geometry2d_method_get_closest_point_to_segment"><reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> <strong>get_closest_point_to_segment</strong>(point: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, s1: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, s2: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>) <reference internal="True" refid="class-geometry2d-method-get-closest-point-to-segment"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the 2D point on the 2D segment (<literal>s1</literal>, <literal>s2</literal>) that is closest to <literal>point</literal>. The returned point will always be inside the specified segment.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-get-closest-point-to-segment-uncapped"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-get-closest-point-to-segment-uncapped" names="class_geometry2d_method_get_closest_point_to_segment_uncapped"><reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> <strong>get_closest_point_to_segment_uncapped</strong>(point: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, s1: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, s2: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>) <reference internal="True" refid="class-geometry2d-method-get-closest-point-to-segment-uncapped"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the 2D point on the 2D line defined by (<literal>s1</literal>, <literal>s2</literal>) that is closest to <literal>point</literal>. The returned point can be inside the segment (<literal>s1</literal>, <literal>s2</literal>) or outside of it, i.e. somewhere on the line extending from the segment.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-get-closest-points-between-segments"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-get-closest-points-between-segments" names="class_geometry2d_method_get_closest_points_between_segments"><reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference> <strong>get_closest_points_between_segments</strong>(p1: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, q1: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, p2: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, q2: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>) <reference internal="True" refid="class-geometry2d-method-get-closest-points-between-segments"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Given the two 2D segments (<literal>p1</literal>, <literal>q1</literal>) and (<literal>p2</literal>, <literal>q2</literal>), finds those two points on the two segments that are closest to each other. Returns a <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference> that contains this point on (<literal>p1</literal>, <literal>q1</literal>) as well the accompanying point on (<literal>p2</literal>, <literal>q2</literal>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-intersect-polygons"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-intersect-polygons" names="class_geometry2d_method_intersect_polygons"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>] <strong>intersect_polygons</strong>(polygon_a: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, polygon_b: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>) <reference internal="True" refid="class-geometry2d-method-intersect-polygons"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Intersects <literal>polygon_a</literal> with <literal>polygon_b</literal> and returns an array of intersected polygons. This performs <reference internal="True" refid="class-geometry2d-constant-operation-intersection"><inline classes="std std-ref">OPERATION_INTERSECTION</inline></reference> between polygons. In other words, returns common area shared by polygons. Returns an empty array if no intersection occurs.</paragraph>
            <paragraph>The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling <reference internal="True" refid="class-geometry2d-method-is-polygon-clockwise"><inline classes="std std-ref">is_polygon_clockwise()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-intersect-polyline-with-polygon"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-intersect-polyline-with-polygon" names="class_geometry2d_method_intersect_polyline_with_polygon"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>] <strong>intersect_polyline_with_polygon</strong>(polyline: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, polygon: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>) <reference internal="True" refid="class-geometry2d-method-intersect-polyline-with-polygon"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Intersects <literal>polyline</literal> with <literal>polygon</literal> and returns an array of intersected polylines. This performs <reference internal="True" refid="class-geometry2d-constant-operation-intersection"><inline classes="std std-ref">OPERATION_INTERSECTION</inline></reference> between the polyline and the polygon. This operation can be thought of as chopping a line with a closed shape.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-is-point-in-circle"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-is-point-in-circle" names="class_geometry2d_method_is_point_in_circle"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_point_in_circle</strong>(point: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, circle_position: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, circle_radius: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <reference internal="True" refid="class-geometry2d-method-is-point-in-circle"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if <literal>point</literal> is inside the circle or if it's located exactly <emphasis>on</emphasis> the circle's boundary, otherwise returns <literal>false</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-is-point-in-polygon"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-is-point-in-polygon" names="class_geometry2d_method_is_point_in_polygon"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_point_in_polygon</strong>(point: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, polygon: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>) <reference internal="True" refid="class-geometry2d-method-is-point-in-polygon"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if <literal>point</literal> is inside <literal>polygon</literal> or if it's located exactly <emphasis>on</emphasis> polygon's boundary, otherwise returns <literal>false</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-is-polygon-clockwise"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-is-polygon-clockwise" names="class_geometry2d_method_is_polygon_clockwise"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_polygon_clockwise</strong>(polygon: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>) <reference internal="True" refid="class-geometry2d-method-is-polygon-clockwise"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if <literal>polygon</literal>'s vertices are ordered in clockwise order, otherwise returns <literal>false</literal>.</paragraph>
            <paragraph><strong>Note:</strong> Assumes a Cartesian coordinate system where <literal>+x</literal> is right and <literal>+y</literal> is up. If using screen coordinates (<literal>+y</literal> is down), the result will need to be flipped (i.e. a <literal>true</literal> result will indicate counter-clockwise).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-line-intersects-line"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-line-intersects-line" names="class_geometry2d_method_line_intersects_line"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>line_intersects_line</strong>(from_a: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, dir_a: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, from_b: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, dir_b: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>) <reference internal="True" refid="class-geometry2d-method-line-intersects-line"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the point of intersection between the two lines (<literal>from_a</literal>, <literal>dir_a</literal>) and (<literal>from_b</literal>, <literal>dir_b</literal>). Returns a <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, or <literal>null</literal> if the lines are parallel.</paragraph>
            <paragraph><literal>from</literal> and <literal>dir</literal> are <emphasis>not</emphasis> endpoints of a line segment or ray but the slope (<literal>dir</literal>) and a known point (<literal>from</literal>) on that line.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var from_a = Vector2.ZERO
var dir_a = Vector2.RIGHT
var from_b = Vector2.DOWN

# Returns Vector2(1, 0)
Geometry2D.line_intersects_line(from_a, dir_a, from_b, Vector2(1, -1))
# Returns Vector2(-1, 0)
Geometry2D.line_intersects_line(from_a, dir_a, from_b, Vector2(-1, -1))
# Returns null
Geometry2D.line_intersects_line(from_a, dir_a, from_b, Vector2.RIGHT)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var fromA = Vector2.Zero;
var dirA = Vector2.Right;
var fromB = Vector2.Down;

// Returns new Vector2(1, 0)
Geometry2D.LineIntersectsLine(fromA, dirA, fromB, new Vector2(1, -1));
// Returns new Vector2(-1, 0)
Geometry2D.LineIntersectsLine(fromA, dirA, fromB, new Vector2(-1, -1));
// Returns null
Geometry2D.LineIntersectsLine(fromA, dirA, fromB, Vector2.Right);</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-make-atlas"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-make-atlas" names="class_geometry2d_method_make_atlas"><reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> <strong>make_atlas</strong>(sizes: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>) <reference internal="True" refid="class-geometry2d-method-make-atlas"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Given an array of <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>s representing tiles, builds an atlas. The returned dictionary has two keys: <literal>points</literal> is a <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference> that specifies the positions of each tile, <literal>size</literal> contains the overall size of the whole atlas as <reference internal="True" refuri="class_vector2i#class-vector2i"><inline classes="std std-ref">Vector2i</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-merge-polygons"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-merge-polygons" names="class_geometry2d_method_merge_polygons"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>] <strong>merge_polygons</strong>(polygon_a: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, polygon_b: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>) <reference internal="True" refid="class-geometry2d-method-merge-polygons"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Merges (combines) <literal>polygon_a</literal> and <literal>polygon_b</literal> and returns an array of merged polygons. This performs <reference internal="True" refid="class-geometry2d-constant-operation-union"><inline classes="std std-ref">OPERATION_UNION</inline></reference> between polygons.</paragraph>
            <paragraph>The operation may result in an outer polygon (boundary) and multiple inner polygons (holes) produced which could be distinguished by calling <reference internal="True" refid="class-geometry2d-method-is-polygon-clockwise"><inline classes="std std-ref">is_polygon_clockwise()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-offset-polygon"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-offset-polygon" names="class_geometry2d_method_offset_polygon"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>] <strong>offset_polygon</strong>(polygon: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, delta: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>, join_type: <reference internal="True" refid="enum-geometry2d-polyjointype"><inline classes="std std-ref">PolyJoinType</inline></reference> = 0) <reference internal="True" refid="class-geometry2d-method-offset-polygon"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Inflates or deflates <literal>polygon</literal> by <literal>delta</literal> units (pixels). If <literal>delta</literal> is positive, makes the polygon grow outward. If <literal>delta</literal> is negative, shrinks the polygon inward. Returns an array of polygons because inflating/deflating may result in multiple discrete polygons. Returns an empty array if <literal>delta</literal> is negative and the absolute value of it approximately exceeds the minimum bounding rectangle dimensions of the polygon.</paragraph>
            <paragraph>Each polygon's vertices will be rounded as determined by <literal>join_type</literal>.</paragraph>
            <paragraph>The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling <reference internal="True" refid="class-geometry2d-method-is-polygon-clockwise"><inline classes="std std-ref">is_polygon_clockwise()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> To translate the polygon's vertices specifically, multiply them to a <reference internal="True" refuri="class_transform2d#class-transform2d"><inline classes="std std-ref">Transform2D</inline></reference>:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var polygon = PackedVector2Array([Vector2(0, 0), Vector2(100, 0), Vector2(100, 100), Vector2(0, 100)])
var offset = Vector2(50, 50)
polygon = Transform2D(0, offset) * polygon
print(polygon) # Prints [(50.0, 50.0), (150.0, 50.0), (150.0, 150.0), (50.0, 150.0)]</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Vector2[] polygon = [new Vector2(0, 0), new Vector2(100, 0), new Vector2(100, 100), new Vector2(0, 100)];
var offset = new Vector2(50, 50);
polygon = new Transform2D(0, offset) * polygon;
GD.Print((Variant)polygon); // Prints [(50, 50), (150, 50), (150, 150), (50, 150)]</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-offset-polyline"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-offset-polyline" names="class_geometry2d_method_offset_polyline"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>] <strong>offset_polyline</strong>(polyline: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>, delta: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>, join_type: <reference internal="True" refid="enum-geometry2d-polyjointype"><inline classes="std std-ref">PolyJoinType</inline></reference> = 0, end_type: <reference internal="True" refid="enum-geometry2d-polyendtype"><inline classes="std std-ref">PolyEndType</inline></reference> = 3) <reference internal="True" refid="class-geometry2d-method-offset-polyline"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Inflates or deflates <literal>polyline</literal> by <literal>delta</literal> units (pixels), producing polygons. If <literal>delta</literal> is positive, makes the polyline grow outward. Returns an array of polygons because inflating/deflating may result in multiple discrete polygons. If <literal>delta</literal> is negative, returns an empty array.</paragraph>
            <paragraph>Each polygon's vertices will be rounded as determined by <literal>join_type</literal>.</paragraph>
            <paragraph>Each polygon's endpoints will be rounded as determined by <literal>end_type</literal>.</paragraph>
            <paragraph>The operation may result in an outer polygon (boundary) and inner polygon (hole) produced which could be distinguished by calling <reference internal="True" refid="class-geometry2d-method-is-polygon-clockwise"><inline classes="std std-ref">is_polygon_clockwise()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-point-is-inside-triangle"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-point-is-inside-triangle" names="class_geometry2d_method_point_is_inside_triangle"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>point_is_inside_triangle</strong>(point: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, a: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, b: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, c: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-geometry2d-method-point-is-inside-triangle"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns if <literal>point</literal> is inside the triangle specified by <literal>a</literal>, <literal>b</literal> and <literal>c</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-segment-intersects-circle"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-segment-intersects-circle" names="class_geometry2d_method_segment_intersects_circle"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>segment_intersects_circle</strong>(segment_from: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, segment_to: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, circle_position: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, circle_radius: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <reference internal="True" refid="class-geometry2d-method-segment-intersects-circle"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Given the 2D segment (<literal>segment_from</literal>, <literal>segment_to</literal>), returns the position on the segment (as a number between 0 and 1) at which the segment hits the circle that is located at position <literal>circle_position</literal> and has radius <literal>circle_radius</literal>. If the segment does not intersect the circle, -1 is returned (this is also the case if the line extending the segment would intersect the circle, but the segment does not).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-segment-intersects-segment"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-segment-intersects-segment" names="class_geometry2d_method_segment_intersects_segment"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>segment_intersects_segment</strong>(from_a: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, to_a: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, from_b: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>, to_b: <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>) <reference internal="True" refid="class-geometry2d-method-segment-intersects-segment"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Checks if the two segments (<literal>from_a</literal>, <literal>to_a</literal>) and (<literal>from_b</literal>, <literal>to_b</literal>) intersect. If yes, return the point of intersection as <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference>. If no intersection takes place, returns <literal>null</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-triangulate-delaunay"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-triangulate-delaunay" names="class_geometry2d_method_triangulate_delaunay"><reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference> <strong>triangulate_delaunay</strong>(points: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>) <reference internal="True" refid="class-geometry2d-method-triangulate-delaunay"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Triangulates the area specified by discrete set of <literal>points</literal> such that no point is inside the circumcircle of any resulting triangle. Returns a <reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference> where each triangle consists of three consecutive point indices into <literal>points</literal> (i.e. the returned array will have <literal>n * 3</literal> elements, with <literal>n</literal> being the number of found triangles). If the triangulation did not succeed, an empty <reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference> is returned.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-geometry2d-method-triangulate-polygon"></target>
            <paragraph classes="classref-method" ids="class-geometry2d-method-triangulate-polygon" names="class_geometry2d_method_triangulate_polygon"><reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference> <strong>triangulate_polygon</strong>(polygon: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>) <reference internal="True" refid="class-geometry2d-method-triangulate-polygon"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Triangulates the polygon specified by the points in <literal>polygon</literal>. Returns a <reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference> where each triangle consists of three consecutive point indices into <literal>polygon</literal> (i.e. the returned array will have <literal>n * 3</literal> elements, with <literal>n</literal> being the number of found triangles). Output triangles will always be counter clockwise, and the contour will be flipped if it's clockwise. If the triangulation did not succeed, an empty <reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference> is returned.</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></substitution_definition>
            <substitution_definition names="required"><abbreviation explanation="This method is required to be overridden when extending its base class.">required</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="This method is used to construct a type.">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="This method describes a valid operator to use with this type as left-hand operand.">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="This value is an integer composed as a bitmask of the following flags.">BitField</abbreviation></substitution_definition>
            <substitution_definition names="void"><abbreviation explanation="No return value.">void</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
