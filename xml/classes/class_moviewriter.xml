<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_moviewriter.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/4.2/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/4.2/doc/classes/MovieWriter.xml.</comment>
    <target refid="class-moviewriter"></target>
    <section ids="moviewriter class-moviewriter" names="moviewriter class_moviewriter">
        <title>MovieWriter</title>
        <paragraph><strong>继承：</strong> <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference></paragraph>
        <paragraph>非实时视频录制编码器的抽象类。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>Godot 能够使用非实时模拟技术录制视频。与 <literal>--fixed-fps</literal> <reference internal="True" refuri="../tutorials/editor/command_line_tutorial"><inline classes="doc">命令行参数</inline></reference>类似，会强制让 <reference internal="True" refuri="class_node#class-node-private-method-process"><inline classes="std std-ref">Node._process</inline></reference> 等函数每一帧都收到相同的 <literal>delta</literal>，无论实际渲染花费了多长的时间。这个技术可用于录制高画质的视频，无论你的硬件性能如何，帧率始终都是恒定的。</paragraph>
            <paragraph>Godot 内置的 <strong>MovieWriter</strong> 有两个：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>使用 MJPEG 视频和未压缩音频的 AVI 容器（文件扩展名为 <literal>.avi</literal>）。有损压缩、文件大小中等、编码速度较快。有损压缩质量可以通过修改 <reference internal="True" refuri="class_projectsettings#class-projectsettings-property-editor-movie-writer-mjpeg-quality"><inline classes="std std-ref">ProjectSettings.editor/movie_writer/mjpeg_quality</inline></reference> 来调整。生成的文件可以使用大多数视频播放器查看，但如果要在 Web 上查看或者用 Godot 的 <reference internal="True" refuri="class_videostreamplayer#class-videostreamplayer"><inline classes="std std-ref">VideoStreamPlayer</inline></reference> 查看，则必须先进行格式的转换。MJPEG 不支持透明度。AVI 输出的文件目前最多为 4 GB 大小。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>视频使用 PNG 图像序列、音频使用 WAV（文件扩展名为 <literal>.png</literal>）。无损压缩、文件大小较大、编码速度较慢。旨在录制后使用 <reference name="FFmpeg" refuri="https://ffmpeg.org/">FFmpeg</reference> 等其他工具编码为视频文件。目前不支持透明度，即便将根视口设为透明。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>如果你需要编码为其他格式，或者将流导入到第三方软件中，你可以扩展 <strong>MovieWriter</strong> 类，创建自己的影片写入器。出于性能考虑，一般应该使用 GDExtension 实现。</paragraph>
            <paragraph><strong>编辑器使用：</strong>默认影片文件路径可以在 <reference internal="True" refuri="class_projectsettings#class-projectsettings-property-editor-movie-writer-movie-file"><inline classes="std std-ref">ProjectSettings.editor/movie_writer/movie_file</inline></reference> 指定。或者在运行单个场景时，也可以在根节点上添加元数据 <literal>movie_file</literal>，可以指定录制该场景时所使用的影片文件路径。设置路径后，请点击编辑器右上角的电影胶卷图标，启动 Movie Maker 模式，然后和平常一样运行场景即可。引擎会在启动画面结束后开始录制，只会在引擎退出时停止录制。再次点击电影胶卷图标可以禁用 Movie Maker 模式。请注意，Movie Maker 模式的开关不会影响正在运行的项目实例。</paragraph>
            <paragraph><strong>注意：</strong>MovieWriter 既可以在编辑器中使用，也可以在导出的项目中使用，但这个功能<emphasis>不应</emphasis>用来让最终用户录制游戏视频。希望录制游戏视频的玩家应该安装 <reference name="OBS Studio" refuri="https://obsproject.com/">OBS Studio</reference> 或 <reference name="SimpleScreenRecorder" refuri="https://www.maartenbaert.be/simplescreenrecorder/">SimpleScreenRecorder</reference> 等工具。</paragraph>
        </section>
        <section classes="classref-reftable-group" ids="id2" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="50"></colspec>
                    <colspec colwidth="199"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-moviewriter-private-method-get-audio-mix-rate"><inline classes="std std-ref">_get_audio_mix_rate</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_audioserver#enum-audioserver-speakermode"><inline classes="std std-ref">SpeakerMode</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-moviewriter-private-method-get-audio-speaker-mode"><inline classes="std std-ref">_get_audio_speaker_mode</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-moviewriter-private-method-handles-file"><inline classes="std std-ref">_handles_file</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> path <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-moviewriter-private-method-write-begin"><inline classes="std std-ref">_write_begin</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector2i#class-vector2i"><inline classes="std std-ref">Vector2i</inline></reference> movie_size, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> fps, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> base_path <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-moviewriter-private-method-write-end"><inline classes="std std-ref">_write_end</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-moviewriter-private-method-write-frame"><inline classes="std std-ref">_write_frame</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_image#class-image"><inline classes="std std-ref">Image</inline></reference> frame_image, const void* audio_frame_block <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-moviewriter-method-add-writer"><inline classes="std std-ref">add_writer</inline></reference> <strong>(</strong> <reference internal="True" refid="class-moviewriter"><inline classes="std std-ref">MovieWriter</inline></reference> writer <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id3" names="方法说明">
            <title>方法说明</title>
            <target refid="class-moviewriter-private-method-get-audio-mix-rate"></target>
            <paragraph classes="classref-method" ids="class-moviewriter-private-method-get-audio-mix-rate" names="class_moviewriter_private_method__get_audio_mix_rate"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>_get_audio_mix_rate</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>当引擎请求用于录制音频的音频采样率时调用。返回的值必须以 Hz 为单位指定。如果 <reference internal="True" refid="class-moviewriter-private-method-get-audio-mix-rate"><inline classes="std std-ref">_get_audio_mix_rate</inline></reference> 未被重写，则默认为 48000 Hz。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-moviewriter-private-method-get-audio-speaker-mode"></target>
            <paragraph classes="classref-method" ids="class-moviewriter-private-method-get-audio-speaker-mode" names="class_moviewriter_private_method__get_audio_speaker_mode"><reference internal="True" refuri="class_audioserver#enum-audioserver-speakermode"><inline classes="std std-ref">SpeakerMode</inline></reference> <strong>_get_audio_speaker_mode</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>当引擎请求用于录制音频的音频扬声器模式时调用。这可能会影响生成的音频文件/流中的输出通道数。如果 <reference internal="True" refid="class-moviewriter-private-method-get-audio-speaker-mode"><inline classes="std std-ref">_get_audio_speaker_mode</inline></reference> 未被重写，则默认为 <reference internal="True" refuri="class_audioserver#class-audioserver-constant-speaker-mode-stereo"><inline classes="std std-ref">AudioServer.SPEAKER_MODE_STEREO</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-moviewriter-private-method-handles-file"></target>
            <paragraph classes="classref-method" ids="class-moviewriter-private-method-handles-file" names="class_moviewriter_private_method__handles_file"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>_handles_file</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> path <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>当引擎确定该 <strong>MovieWriter</strong> 是否能够处理位于 <literal>path</literal> 的文件时调用。如果该 <strong>MovieWriter</strong> 能够处理给定的文件路径，则必须返回 <literal>true</literal>，否则返回 <literal>false</literal>。通常，<reference internal="True" refid="class-moviewriter-private-method-handles-file"><inline classes="std std-ref">_handles_file</inline></reference> 如下被重写，以允许用户使用给定文件扩展名，在任何路径下记录一个文件：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _handles_file(path):
    # 允许指定一个带有 `.mkv` 文件扩展名（不区分大小写）的输出文件，
    # 在项目设置中或使用 `--write-movie &lt;path&gt;` 命令行参数。
    return path.get_extension().to_lower() == "mkv"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-moviewriter-private-method-write-begin"></target>
            <paragraph classes="classref-method" ids="class-moviewriter-private-method-write-begin" names="class_moviewriter_private_method__write_begin"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>_write_begin</strong> <strong>(</strong> <reference internal="True" refuri="class_vector2i#class-vector2i"><inline classes="std std-ref">Vector2i</inline></reference> movie_size, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> fps, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> base_path <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
            <paragraph>在引擎开始写入视频和音频数据之前调用一次。<literal>movie_size</literal> 是要保存的视频的宽度和高度。<literal>fps</literal> 是指定的每秒帧数，在项目设置中、或使用 <literal>--fixed-fps &lt;fps&gt;</literal><reference internal="True" refuri="../tutorials/editor/command_line_tutorial"><inline classes="doc">《命令行参数》</inline></reference>指定。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-moviewriter-private-method-write-end"></target>
            <paragraph classes="classref-method" ids="class-moviewriter-private-method-write-end" names="class_moviewriter_private_method__write_end">void <strong>_write_end</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
            <paragraph>当引擎完成写入时调用。当引擎通过按下窗口管理器的关闭按钮退出时，或调用 <reference internal="True" refuri="class_scenetree#class-scenetree-method-quit"><inline classes="std std-ref">SceneTree.quit</inline></reference> 时，会发生这种情况。</paragraph>
            <paragraph><strong>注意：</strong>在运行编辑器/项目的终端上，按 <literal classes="kbd">Ctrl + C</literal>，<emphasis>不会</emphasis>导致 <reference internal="True" refid="class-moviewriter-private-method-write-end"><inline classes="std std-ref">_write_end</inline></reference> 被调用。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-moviewriter-private-method-write-frame"></target>
            <paragraph classes="classref-method" ids="class-moviewriter-private-method-write-frame" names="class_moviewriter_private_method__write_frame"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>_write_frame</strong> <strong>(</strong> <reference internal="True" refuri="class_image#class-image"><inline classes="std std-ref">Image</inline></reference> frame_image, const void* audio_frame_block <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
            <paragraph>在每个渲染的帧结束时被调用。应写入 <literal>frame_image</literal> 和 <literal>audio_frame_block</literal> 函数参数。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-moviewriter-method-add-writer"></target>
            <paragraph classes="classref-method" ids="class-moviewriter-method-add-writer" names="class_moviewriter_method_add_writer">void <strong>add_writer</strong> <strong>(</strong> <reference internal="True" refid="class-moviewriter"><inline classes="std std-ref">MovieWriter</inline></reference> writer <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>添加一个可供引擎使用的编写器。可以通过重写 <reference internal="True" refid="class-moviewriter-private-method-handles-file"><inline classes="std std-ref">_handles_file</inline></reference>，来设置支持的文件扩展名。</paragraph>
            <paragraph><strong>注意：</strong><reference internal="True" refid="class-moviewriter-method-add-writer"><inline classes="std std-ref">add_writer</inline></reference> 必须在引擎初始化期间尽早调用才能工作，因为电影编写被设计为与引擎的其余部分同时启动。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
