<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_workerthreadpool.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/master/doc/classes/WorkerThreadPool.xml.</comment>
    <target refid="class-workerthreadpool"></target>
    <section ids="workerthreadpool class-workerthreadpool" names="workerthreadpool class_workerthreadpool">
        <title>WorkerThreadPool</title>
        <paragraph><strong>继承：</strong> <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference></paragraph>
        <paragraph>单例，启动时会分配一些 <reference internal="True" refuri="class_thread#class-thread"><inline classes="std std-ref">Thread</inline></reference>，可以将任务卸载到这些线程中执行。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph><strong>WorkerThreadPool</strong> 单例在项目启动时会分配一组 <reference internal="True" refuri="class_thread#class-thread"><inline classes="std std-ref">Thread</inline></reference>（称作工作线程）并提供将任务卸载至这些线程上执行的方法。这样就能够简化多线程的使用，不必创建 <reference internal="True" refuri="class_thread#class-thread"><inline classes="std std-ref">Thread</inline></reference>。</paragraph>
            <paragraph>任务里放置的是要让线程执行的 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>。<strong>WorkerThreadPool</strong> 既可以创建常规任务也可以创建分组任务，常规任务由单个工作线程执行，而分组任务可以分布在多个工作线程执行。分组任务会多次执行同一个 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>，可用于遍历大量的元素，例如场景中的敌人。</paragraph>
            <paragraph>以下是将开销很大的函数卸载到工作线程执行的例子：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var enemies = [] # 用敌人填充的数组。

func process_enemy_ai(enemy_index):
    var processed_enemy = enemies[enemy_index]
    # 开销很大的逻辑……

func _process(delta):
    var task_id = WorkerThreadPool.add_group_task(process_enemy_ai, enemies.size())
    # 其他代码……
    WorkerThreadPool.wait_for_group_task_completion(task_id)
    # 要求敌人 AI 已经处理完毕的其他代码。</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private List&lt;Node&gt; _enemies = new List&lt;Node&gt;(); // 用敌人填充的数组。

private void ProcessEnemyAI(int enemyIndex)
{
    Node processedEnemy = _enemies[enemyIndex];
    // 开销很大的逻辑……
}

public override void _Process(double delta)
{
    long taskId = WorkerThreadPool.AddGroupTask(Callable.From&lt;int&gt;(ProcessEnemyAI), _enemies.Count);
    // 其他代码……
    WorkerThreadPool.WaitForGroupTaskCompletion(taskId);
    // 要求敌人 AI 已经处理完毕的其他代码。
}</literal_block>
                </div>
            </container>
            <paragraph>以上代码要求 <literal>enemies</literal> 数组中的元素个数在多线程部分执行时保持不变。</paragraph>
            <paragraph><strong>注意：</strong>如果分布到多个线程执行的任务在计算方面的开销并不大，那么使用这个单例可能对性能有负面影响。</paragraph>
        </section>
        <section classes="classref-introduction-group" ids="id2" names="教程">
            <title>教程</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/performance/using_multiple_threads"><inline classes="doc">使用多线程</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/performance/thread_safe_apis"><inline classes="doc">线程安全的 API</inline></reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="39"></colspec>
                    <colspec colwidth="291"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-workerthreadpool-method-add-group-task"><inline classes="std std-ref">add_group_task</inline></reference>(action: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, elements: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, tasks_needed: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = -1, high_priority: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false, description: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> = "")</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-workerthreadpool-method-add-task"><inline classes="std std-ref">add_task</inline></reference>(action: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, high_priority: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false, description: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> = "")</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-workerthreadpool-method-get-group-processed-element-count"><inline classes="std std-ref">get_group_processed_element_count</inline></reference>(group_id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-workerthreadpool-method-is-group-task-completed"><inline classes="std std-ref">is_group_task_completed</inline></reference>(group_id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-workerthreadpool-method-is-task-completed"><inline classes="std std-ref">is_task_completed</inline></reference>(task_id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-workerthreadpool-method-wait-for-group-task-completion"><inline classes="std std-ref">wait_for_group_task_completion</inline></reference>(group_id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-workerthreadpool-method-wait-for-task-completion"><inline classes="std std-ref">wait_for_task_completion</inline></reference>(task_id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id4" names="方法说明">
            <title>方法说明</title>
            <target refid="class-workerthreadpool-method-add-group-task"></target>
            <paragraph classes="classref-method" ids="class-workerthreadpool-method-add-group-task" names="class_workerthreadpool_method_add_group_task"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>add_group_task</strong>(action: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, elements: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, tasks_needed: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = -1, high_priority: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false, description: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> = "") <reference internal="True" refid="class-workerthreadpool-method-add-group-task"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将 <literal>action</literal> 添加为分组任务，让多个工作线程执行。该 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> 的调用次数由 <literal>elements</literal> 决定，第一个调用的线程使用 <literal>0</literal> 作为参数，后续执行时会将其加 1，直到变为 <literal>element - 1</literal>。</paragraph>
            <paragraph>任务分布的线程数由 <literal>tasks_needed</literal> 定义，默认值 <literal>-1</literal> 表示分布到所有工作线程。<literal>high_priority</literal> 决定的是任务具有高优先级还是低优先级（默认）。你还可以选择提供 <literal>description</literal> 作为描述信息，方便调试。</paragraph>
            <paragraph>返回分组任务 ID，可用于其他方法。</paragraph>
            <paragraph><strong>警告：</strong>每个任务都必须在某处使用 <reference internal="True" refid="class-workerthreadpool-method-wait-for-task-completion"><inline classes="std std-ref">wait_for_task_completion</inline></reference> 或 <reference internal="True" refid="class-workerthreadpool-method-wait-for-group-task-completion"><inline classes="std std-ref">wait_for_group_task_completion</inline></reference> 等待完成，从而清理任务中分配的资源。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-workerthreadpool-method-add-task"></target>
            <paragraph classes="classref-method" ids="class-workerthreadpool-method-add-task" names="class_workerthreadpool_method_add_task"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>add_task</strong>(action: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, high_priority: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false, description: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> = "") <reference internal="True" refid="class-workerthreadpool-method-add-task"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将 <literal>action</literal> 添加为分组任务，让单个工作线程执行。<literal>high_priority</literal> 决定的是任务具有高优先级还是低优先级（默认）。你还可以选择提供 <literal>description</literal> 作为描述信息，方便调试。</paragraph>
            <paragraph>返回任务 ID，可用于其他方法。</paragraph>
            <paragraph><strong>警告：</strong>每个任务都必须在某处使用 <reference internal="True" refid="class-workerthreadpool-method-wait-for-task-completion"><inline classes="std std-ref">wait_for_task_completion</inline></reference> 或 <reference internal="True" refid="class-workerthreadpool-method-wait-for-group-task-completion"><inline classes="std std-ref">wait_for_group_task_completion</inline></reference> 等待完成，从而清理任务中分配的资源。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-workerthreadpool-method-get-group-processed-element-count"></target>
            <paragraph classes="classref-method" ids="class-workerthreadpool-method-get-group-processed-element-count" names="class_workerthreadpool_method_get_group_processed_element_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_group_processed_element_count</strong>(group_id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-workerthreadpool-method-get-group-processed-element-count"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回具有给定 ID 的分组任务的 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> 已经被工作线程执行的次数。</paragraph>
            <paragraph><strong>注意：</strong>线程已经开始执行 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> 但尚未完成的情况不计算在内。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-workerthreadpool-method-is-group-task-completed"></target>
            <paragraph classes="classref-method" ids="class-workerthreadpool-method-is-group-task-completed" names="class_workerthreadpool_method_is_group_task_completed"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_group_task_completed</strong>(group_id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-workerthreadpool-method-is-group-task-completed"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果 ID 对应的分组任务已完成，则返回 <literal>true</literal>。</paragraph>
            <paragraph><strong>注意：</strong>只应该在添加分组任务之后、等待完成之前调用该方法。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-workerthreadpool-method-is-task-completed"></target>
            <paragraph classes="classref-method" ids="class-workerthreadpool-method-is-task-completed" names="class_workerthreadpool_method_is_task_completed"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_task_completed</strong>(task_id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-workerthreadpool-method-is-task-completed"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果 ID 对应的任务已完成，则返回 <literal>true</literal>。</paragraph>
            <paragraph><strong>注意：</strong>只应该在添加分组任务之后、等待完成之前调用该方法。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-workerthreadpool-method-wait-for-group-task-completion"></target>
            <paragraph classes="classref-method" ids="class-workerthreadpool-method-wait-for-group-task-completion" names="class_workerthreadpool_method_wait_for_group_task_completion"><abbreviation explanation="无返回值。">void</abbreviation> <strong>wait_for_group_task_completion</strong>(group_id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-workerthreadpool-method-wait-for-group-task-completion"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>在具有给定 ID 的分组任务完成前暂停调用这个方法的线程。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-workerthreadpool-method-wait-for-task-completion"></target>
            <paragraph classes="classref-method" ids="class-workerthreadpool-method-wait-for-task-completion" names="class_workerthreadpool_method_wait_for_task_completion"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>wait_for_task_completion</strong>(task_id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-workerthreadpool-method-wait-for-task-completion"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>暂停调用该方法的线程，直到给定 ID 对应的任务完成。</paragraph>
            <paragraph>如果能够成功等待任务，则返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-ok"><inline classes="std std-ref">@GlobalScope.OK</inline></reference>。</paragraph>
            <paragraph>如果不存在与传入 ID 对应的任务（可能已被等待或处理），则返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-invalid-parameter"><inline classes="std std-ref">@GlobalScope.ERR_INVALID_PARAMETER</inline></reference>。</paragraph>
            <paragraph>如果其他正在执行的任务调用了该方法，并且由于任务调度的原因，存在死锁的可能性（例如，要等待的任务可能位于调用堆栈中的较低级别，因此不能继续），则返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-busy"><inline classes="std std-ref">@GlobalScope.ERR_BUSY</inline></reference>。这是比较高级的情况，只有任务之间存在依赖关系（在当前实现中，棘手的情况是尝试等待较旧任务的任务）时才会出现。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了能接受在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="void"><abbreviation explanation="无返回值。">void</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
