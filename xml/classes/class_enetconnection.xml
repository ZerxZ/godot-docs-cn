<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_enetconnection.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/4.2/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/4.2/modules/enet/doc_classes/ENetConnection.xml.</comment>
    <target refid="class-enetconnection"></target>
    <section ids="enetconnection class-enetconnection" names="enetconnection class_enetconnection">
        <title>ENetConnection</title>
        <paragraph><strong>继承：</strong> <reference internal="True" refuri="class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> <strong>&lt;</strong> <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference></paragraph>
        <paragraph><reference name="ENetHost" refuri="http://enet.bespin.org/group__host.html">ENetHost</reference> 的包装类。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>ENet 的目的是在 UDP（用户数据报协议）之上，提供一个相对轻便、简单和健壮的网络通信层。</paragraph>
        </section>
        <section classes="classref-introduction-group" ids="id2" names="教程">
            <title>教程</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="ENet 网站上的 API 文档" refuri="http://enet.bespin.org/usergroup0.html">ENet 网站上的 API 文档</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="47"></colspec>
                    <colspec colwidth="310"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-bandwidth-limit"><inline classes="std std-ref">bandwidth_limit</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> in_bandwidth=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> out_bandwidth=0 <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-broadcast"><inline classes="std std-ref">broadcast</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> channel, <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> packet, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> flags <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-channel-limit"><inline classes="std std-ref">channel_limit</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> limit <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-compress"><inline classes="std std-ref">compress</inline></reference> <strong>(</strong> <reference internal="True" refid="enum-enetconnection-compressionmode"><inline classes="std std-ref">CompressionMode</inline></reference> mode <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_enetpacketpeer#class-enetpacketpeer"><inline classes="std std-ref">ENetPacketPeer</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-connect-to-host"><inline classes="std std-ref">connect_to_host</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> address, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> port, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> channels=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> data=0 <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-create-host"><inline classes="std std-ref">create_host</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> max_peers=32, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> max_channels=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> in_bandwidth=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> out_bandwidth=0 <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-create-host-bound"><inline classes="std std-ref">create_host_bound</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> bind_address, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> bind_port, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> max_peers=32, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> max_channels=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> in_bandwidth=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> out_bandwidth=0 <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-destroy"><inline classes="std std-ref">destroy</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-dtls-client-setup"><inline classes="std std-ref">dtls_client_setup</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> hostname, <reference internal="True" refuri="class_tlsoptions#class-tlsoptions"><inline classes="std std-ref">TLSOptions</inline></reference> client_options=null <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-dtls-server-setup"><inline classes="std std-ref">dtls_server_setup</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_tlsoptions#class-tlsoptions"><inline classes="std std-ref">TLSOptions</inline></reference> server_options <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-flush"><inline classes="std std-ref">flush</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-get-local-port"><inline classes="std std-ref">get_local_port</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-get-max-channels"><inline classes="std std-ref">get_max_channels</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_enetpacketpeer#class-enetpacketpeer"><inline classes="std std-ref">ENetPacketPeer[]</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-get-peers"><inline classes="std std-ref">get_peers</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-pop-statistic"><inline classes="std std-ref">pop_statistic</inline></reference> <strong>(</strong> <reference internal="True" refid="enum-enetconnection-hoststatistic"><inline classes="std std-ref">HostStatistic</inline></reference> statistic <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-refuse-new-connections"><inline classes="std std-ref">refuse_new_connections</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> refuse <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-service"><inline classes="std std-ref">service</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> timeout=0 <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-enetconnection-method-socket-send"><inline classes="std std-ref">socket_send</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> destination_address, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> destination_port, <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> packet <strong>)</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id4" names="枚举">
            <title>枚举</title>
            <target refid="enum-enetconnection-compressionmode"></target>
            <paragraph classes="classref-enumeration" ids="enum-enetconnection-compressionmode" names="enum_enetconnection_compressionmode">enum <strong>CompressionMode</strong>:</paragraph>
            <target refid="class-enetconnection-constant-compress-none"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-enetconnection-constant-compress-none" names="class_enetconnection_constant_compress_none"><reference internal="True" refid="enum-enetconnection-compressionmode"><inline classes="std std-ref">CompressionMode</inline></reference> <strong>COMPRESS_NONE</strong> = <literal>0</literal></paragraph>
            <paragraph>无压缩。这使用最多的带宽，但具有占用最少 CPU 资源的好处。这个选项可以用于 Wireshark 等工具使用，更容易进行网络调试。</paragraph>
            <target refid="class-enetconnection-constant-compress-range-coder"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-enetconnection-constant-compress-range-coder" names="class_enetconnection_constant_compress_range_coder"><reference internal="True" refid="enum-enetconnection-compressionmode"><inline classes="std std-ref">CompressionMode</inline></reference> <strong>COMPRESS_RANGE_CODER</strong> = <literal>1</literal></paragraph>
            <paragraph>ENet 的内置范围编码。适用于小数据包，但对于大于 4 KB 的数据包不是最有效的算法。</paragraph>
            <target refid="class-enetconnection-constant-compress-fastlz"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-enetconnection-constant-compress-fastlz" names="class_enetconnection_constant_compress_fastlz"><reference internal="True" refid="enum-enetconnection-compressionmode"><inline classes="std std-ref">CompressionMode</inline></reference> <strong>COMPRESS_FASTLZ</strong> = <literal>2</literal></paragraph>
            <paragraph><reference name="FastLZ" refuri="https://fastlz.org/">FastLZ</reference> 压缩。与 <reference internal="True" refid="class-enetconnection-constant-compress-zlib"><inline classes="std std-ref">COMPRESS_ZLIB</inline></reference> 相比，此选项使用的 CPU 资源更少，代价是使用更多的带宽。</paragraph>
            <target refid="class-enetconnection-constant-compress-zlib"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-enetconnection-constant-compress-zlib" names="class_enetconnection_constant_compress_zlib"><reference internal="True" refid="enum-enetconnection-compressionmode"><inline classes="std std-ref">CompressionMode</inline></reference> <strong>COMPRESS_ZLIB</strong> = <literal>3</literal></paragraph>
            <paragraph><reference name="Zlib" refuri="https://www.zlib.net/">Zlib</reference> 压缩。与 <reference internal="True" refid="class-enetconnection-constant-compress-fastlz"><inline classes="std std-ref">COMPRESS_FASTLZ</inline></reference> 相比，此选项使用的带宽更少，代价是使用更多的 CPU 资源。</paragraph>
            <target refid="class-enetconnection-constant-compress-zstd"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-enetconnection-constant-compress-zstd" names="class_enetconnection_constant_compress_zstd"><reference internal="True" refid="enum-enetconnection-compressionmode"><inline classes="std std-ref">CompressionMode</inline></reference> <strong>COMPRESS_ZSTD</strong> = <literal>4</literal></paragraph>
            <paragraph><reference name="Zstandard" refuri="https://facebook.github.io/zstd/">Zstandard</reference> 压缩。请注意，此算法对小于 4 KB 的数据包效率不高。因此，建议在大多数情况下使用其他压缩算法。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-enetconnection-eventtype"></target>
            <paragraph classes="classref-enumeration" ids="enum-enetconnection-eventtype" names="enum_enetconnection_eventtype">enum <strong>EventType</strong>:</paragraph>
            <target refid="class-enetconnection-constant-event-error"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-enetconnection-constant-event-error" names="class_enetconnection_constant_event_error"><reference internal="True" refid="enum-enetconnection-eventtype"><inline classes="std std-ref">EventType</inline></reference> <strong>EVENT_ERROR</strong> = <literal>-1</literal></paragraph>
            <paragraph><reference internal="True" refid="class-enetconnection-method-service"><inline classes="std std-ref">service</inline></reference> 期间发生错误。你可能需要 <reference internal="True" refid="class-enetconnection-method-destroy"><inline classes="std std-ref">destroy</inline></reference> 主机并重新创建。</paragraph>
            <target refid="class-enetconnection-constant-event-none"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-enetconnection-constant-event-none" names="class_enetconnection_constant_event_none"><reference internal="True" refid="enum-enetconnection-eventtype"><inline classes="std std-ref">EventType</inline></reference> <strong>EVENT_NONE</strong> = <literal>0</literal></paragraph>
            <paragraph>在指定的时间限制内没有事件发生。</paragraph>
            <target refid="class-enetconnection-constant-event-connect"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-enetconnection-constant-event-connect" names="class_enetconnection_constant_event_connect"><reference internal="True" refid="enum-enetconnection-eventtype"><inline classes="std std-ref">EventType</inline></reference> <strong>EVENT_CONNECT</strong> = <literal>1</literal></paragraph>
            <paragraph>由 enet_host_connect 发起的连接请求已完成。该数组将包含成功连接的对等体。</paragraph>
            <target refid="class-enetconnection-constant-event-disconnect"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-enetconnection-constant-event-disconnect" names="class_enetconnection_constant_event_disconnect"><reference internal="True" refid="enum-enetconnection-eventtype"><inline classes="std std-ref">EventType</inline></reference> <strong>EVENT_DISCONNECT</strong> = <literal>2</literal></paragraph>
            <paragraph>对等体已断开连接。如果对等体超时，或者由 <reference internal="True" refid="class-enetconnection-method-connect-to-host"><inline classes="std std-ref">connect_to_host</inline></reference> 初始化的连接请求超时，则在由 <reference internal="True" refuri="class_enetpacketpeer#class-enetpacketpeer-method-peer-disconnect"><inline classes="std std-ref">ENetPacketPeer.peer_disconnect</inline></reference> 发起的断开连接成功完成时，生成该事件。该数组将包含断开连接的对等体。数据字段包含用户提供的描述断开连接的数据，如果没有可用的数据，则为 0。</paragraph>
            <target refid="class-enetconnection-constant-event-receive"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-enetconnection-constant-event-receive" names="class_enetconnection_constant_event_receive"><reference internal="True" refid="enum-enetconnection-eventtype"><inline classes="std std-ref">EventType</inline></reference> <strong>EVENT_RECEIVE</strong> = <literal>3</literal></paragraph>
            <paragraph>已从对等体接收到一个数据包。该数组将包含发送数据包的对等体和接收数据包的通道号。接收到的数据包将被排队到关联的 <reference internal="True" refuri="class_enetpacketpeer#class-enetpacketpeer"><inline classes="std std-ref">ENetPacketPeer</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-enetconnection-hoststatistic"></target>
            <paragraph classes="classref-enumeration" ids="enum-enetconnection-hoststatistic" names="enum_enetconnection_hoststatistic">enum <strong>HostStatistic</strong>:</paragraph>
            <target refid="class-enetconnection-constant-host-total-sent-data"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-enetconnection-constant-host-total-sent-data" names="class_enetconnection_constant_host_total_sent_data"><reference internal="True" refid="enum-enetconnection-hoststatistic"><inline classes="std std-ref">HostStatistic</inline></reference> <strong>HOST_TOTAL_SENT_DATA</strong> = <literal>0</literal></paragraph>
            <paragraph>发送数据的总数。</paragraph>
            <target refid="class-enetconnection-constant-host-total-sent-packets"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-enetconnection-constant-host-total-sent-packets" names="class_enetconnection_constant_host_total_sent_packets"><reference internal="True" refid="enum-enetconnection-hoststatistic"><inline classes="std std-ref">HostStatistic</inline></reference> <strong>HOST_TOTAL_SENT_PACKETS</strong> = <literal>1</literal></paragraph>
            <paragraph>发送 UDP 数据包的总数。</paragraph>
            <target refid="class-enetconnection-constant-host-total-received-data"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-enetconnection-constant-host-total-received-data" names="class_enetconnection_constant_host_total_received_data"><reference internal="True" refid="enum-enetconnection-hoststatistic"><inline classes="std std-ref">HostStatistic</inline></reference> <strong>HOST_TOTAL_RECEIVED_DATA</strong> = <literal>2</literal></paragraph>
            <paragraph>接收数据的总数。</paragraph>
            <target refid="class-enetconnection-constant-host-total-received-packets"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-enetconnection-constant-host-total-received-packets" names="class_enetconnection_constant_host_total_received_packets"><reference internal="True" refid="enum-enetconnection-hoststatistic"><inline classes="std std-ref">HostStatistic</inline></reference> <strong>HOST_TOTAL_RECEIVED_PACKETS</strong> = <literal>3</literal></paragraph>
            <paragraph>接收 UDP 数据包的总数。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id5" names="方法说明">
            <title>方法说明</title>
            <target refid="class-enetconnection-method-bandwidth-limit"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-bandwidth-limit" names="class_enetconnection_method_bandwidth_limit">void <strong>bandwidth_limit</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> in_bandwidth=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> out_bandwidth=0 <strong>)</strong></paragraph>
            <paragraph>调整主机的带宽限制。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-broadcast"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-broadcast" names="class_enetconnection_method_broadcast">void <strong>broadcast</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> channel, <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> packet, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> flags <strong>)</strong></paragraph>
            <paragraph>将一个 <literal>packet</literal> 加入队列，以便将其通过指定的 <literal>channel</literal> 发送到与主机关联的所有对等体。请参阅 <reference internal="True" refuri="class_enetpacketpeer#class-enetpacketpeer"><inline classes="std std-ref">ENetPacketPeer</inline></reference> 中的 <literal>FLAG_*</literal> 常量以了解可用的数据包标志。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-channel-limit"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-channel-limit" names="class_enetconnection_method_channel_limit">void <strong>channel_limit</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> limit <strong>)</strong></paragraph>
            <paragraph>限制未来传入连接的最大允许通道数。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-compress"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-compress" names="class_enetconnection_method_compress">void <strong>compress</strong> <strong>(</strong> <reference internal="True" refid="enum-enetconnection-compressionmode"><inline classes="std std-ref">CompressionMode</inline></reference> mode <strong>)</strong></paragraph>
            <paragraph>设置用于网络数据包的压缩方法。这些在压缩速度与带宽之间有不同的权衡，如果需要使用压缩，可能需要测试哪一种最适合你的用例。</paragraph>
            <paragraph><strong>注意：</strong>大多数游戏的网络设计，都涉及频繁发送许多小数据包（每个小于 4 KB）。如果有疑问，建议保留默认压缩算法，因为它最适合这些小数据包。</paragraph>
            <paragraph><strong>注意：</strong>压缩模式必须在服务端及其所有客户端上设置为相同的值。如果客户端上设置的压缩模式与服务端上设置的不同，则客户端将无法连接。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-connect-to-host"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-connect-to-host" names="class_enetconnection_method_connect_to_host"><reference internal="True" refuri="class_enetpacketpeer#class-enetpacketpeer"><inline classes="std std-ref">ENetPacketPeer</inline></reference> <strong>connect_to_host</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> address, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> port, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> channels=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> data=0 <strong>)</strong></paragraph>
            <paragraph>使用指定的端口 <literal>port</literal> 并分配所需的通道 <literal>channels</literal>，向外部地址 <literal>address</literal> 建立连接。可以在连接期间可以传递数据 <literal>data</literal> ，形式为 32 位整数。</paragraph>
            <paragraph><strong>注意：</strong>在调用此方法之前，必须先调用 <reference internal="True" refid="class-enetconnection-method-create-host"><inline classes="std std-ref">create_host</inline></reference> 或 <reference internal="True" refid="class-enetconnection-method-create-host-bound"><inline classes="std std-ref">create_host_bound</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-create-host"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-create-host" names="class_enetconnection_method_create_host"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>create_host</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> max_peers=32, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> max_channels=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> in_bandwidth=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> out_bandwidth=0 <strong>)</strong></paragraph>
            <paragraph>创建一个 ENetHost，最多允许 <literal>max_peers</literal> 个连接的对等体，每个连接最多分配 <literal>max_channels</literal> 个通道，可选择将带宽限制为 <literal>in_bandwidth</literal> 和 <literal>out_bandwidth</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-create-host-bound"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-create-host-bound" names="class_enetconnection_method_create_host_bound"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>create_host_bound</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> bind_address, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> bind_port, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> max_peers=32, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> max_channels=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> in_bandwidth=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> out_bandwidth=0 <strong>)</strong></paragraph>
            <paragraph>创建一个类似 <reference internal="True" refid="class-enetconnection-method-create-host"><inline classes="std std-ref">create_host</inline></reference> 的 ENetHost，它还被绑定到给定的 <literal>bind_address</literal> 和 <literal>bind_port</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-destroy"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-destroy" names="class_enetconnection_method_destroy">void <strong>destroy</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>销毁主机和与其关联的所有资源。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-dtls-client-setup"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-dtls-client-setup" names="class_enetconnection_method_dtls_client_setup"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>dtls_client_setup</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> hostname, <reference internal="True" refuri="class_tlsoptions#class-tlsoptions"><inline classes="std std-ref">TLSOptions</inline></reference> client_options=null <strong>)</strong></paragraph>
            <paragraph>配置此 ENetHost 以使用允许对 ENet 客户端进行 DTLS 加密的自定义 Godot 扩展。在 <reference internal="True" refid="class-enetconnection-method-connect-to-host"><inline classes="std std-ref">connect_to_host</inline></reference> 之前调用它，让 ENet 连接使用 DTLS 根据 <literal>hostname</literal> 验证服务器证书。可以通过可选的 <literal>client_options</literal> 参数来自定义受信任的证书颁发机构，或禁用通用名称验证。见 <reference internal="True" refuri="class_tlsoptions#class-tlsoptions-method-client"><inline classes="std std-ref">TLSOptions.client</inline></reference> 和 <reference internal="True" refuri="class_tlsoptions#class-tlsoptions-method-client-unsafe"><inline classes="std std-ref">TLSOptions.client_unsafe</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-dtls-server-setup"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-dtls-server-setup" names="class_enetconnection_method_dtls_server_setup"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>dtls_server_setup</strong> <strong>(</strong> <reference internal="True" refuri="class_tlsoptions#class-tlsoptions"><inline classes="std std-ref">TLSOptions</inline></reference> server_options <strong>)</strong></paragraph>
            <paragraph>配置该 ENetHost 以使用允许对 ENet 服务器进行 DTLS 加密的自定义 Godot 扩展。在 <reference internal="True" refid="class-enetconnection-method-create-host-bound"><inline classes="std std-ref">create_host_bound</inline></reference> 之后立即调用该方法，以让 ENet 期望对等体使用 DTLS 进行连接。请参阅 <reference internal="True" refuri="class_tlsoptions#class-tlsoptions-method-server"><inline classes="std std-ref">TLSOptions.server</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-flush"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-flush" names="class_enetconnection_method_flush">void <strong>flush</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>将指定主机上所有被队列的数据包发送到其指定的对等体。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-get-local-port"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-get-local-port" names="class_enetconnection_method_get_local_port"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_local_port</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该对等体绑定到的本地端口。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-get-max-channels"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-get-max-channels" names="class_enetconnection_method_get_max_channels"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_max_channels</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回连接的对等体所允许的最大通道数。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-get-peers"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-get-peers" names="class_enetconnection_method_get_peers"><reference internal="True" refuri="class_enetpacketpeer#class-enetpacketpeer"><inline classes="std std-ref">ENetPacketPeer[]</inline></reference> <strong>get_peers</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>返回与该主机关联的对等体列表。</paragraph>
            <paragraph><strong>注意：</strong>该列表可能包含一些未完全连接或仍在断开连接的对等体。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-pop-statistic"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-pop-statistic" names="class_enetconnection_method_pop_statistic"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>pop_statistic</strong> <strong>(</strong> <reference internal="True" refid="enum-enetconnection-hoststatistic"><inline classes="std std-ref">HostStatistic</inline></reference> statistic <strong>)</strong></paragraph>
            <paragraph>返回并重置主机统计信息。详情见 <reference internal="True" refid="enum-enetconnection-hoststatistic"><inline classes="std std-ref">HostStatistic</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-refuse-new-connections"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-refuse-new-connections" names="class_enetconnection_method_refuse_new_connections">void <strong>refuse_new_connections</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> refuse <strong>)</strong></paragraph>
            <paragraph>将 DTLS 服务端配置为自动断开新连接。</paragraph>
            <paragraph><strong>注意：</strong>这个方法只有在调用了 <reference internal="True" refid="class-enetconnection-method-dtls-server-setup"><inline classes="std std-ref">dtls_server_setup</inline></reference> 后才有用。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-service"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-service" names="class_enetconnection_method_service"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> <strong>service</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> timeout=0 <strong>)</strong></paragraph>
            <paragraph>等待指定主机上的事件，并在主机与其对等体之间传送数据包。返回的 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> 将有 4 个元素。<reference internal="True" refid="enum-enetconnection-eventtype"><inline classes="std std-ref">EventType</inline></reference>、生成事件的 <reference internal="True" refuri="class_enetpacketpeer#class-enetpacketpeer"><inline classes="std std-ref">ENetPacketPeer</inline></reference>、事件关联的数据（如果有）、事件关联的通道（如果有）。如果生成的事件是 <reference internal="True" refid="class-enetconnection-constant-event-receive"><inline classes="std std-ref">EVENT_RECEIVE</inline></reference>，则接收到的数据包，将被队列到关联的 <reference internal="True" refuri="class_enetpacketpeer#class-enetpacketpeer"><inline classes="std std-ref">ENetPacketPeer</inline></reference>。</paragraph>
            <paragraph>定期调用该函数来处理连接、断开连接、和接收新数据包。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-enetconnection-method-socket-send"></target>
            <paragraph classes="classref-method" ids="class-enetconnection-method-socket-send" names="class_enetconnection_method_socket_send">void <strong>socket_send</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> destination_address, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> destination_port, <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> packet <strong>)</strong></paragraph>
            <paragraph>向目标发送数据包 <literal>packet</literal>，发送方是该 ENetConnection 实例当前绑定的地址和端口。</paragraph>
            <paragraph>这样能够在该绑定实例和公共互联网之间的所有设备的 NAT 路由表中建立相关条目，因此非常有用，能够让潜在客户端的连接数据包能够通过公共互联网和该主机之间的 NAT 设备进行反向路由。</paragraph>
            <paragraph>要求在 NAT 设备处理连接请求后，预先了解公共互联网所看到的潜在客户端的地址和通信端口。这一信息可以通过 <reference name="STUN" refuri="https://zh.wikipedia.org/wiki/STUN">STUN</reference> 服务获取，必须由非潜在客户端的实体交给你的主机。由于对称 NAT 路由算法的性质，这种方法对于对称 NAT 之后的客户端无效，因为无法提前得知他们的 IP 和端口。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
