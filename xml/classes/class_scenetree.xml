<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_scenetree.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/master/doc/classes/SceneTree.xml.</comment>
    <target refid="class-scenetree"></target>
    <section ids="scenetree class-scenetree" names="scenetree class_scenetree">
        <title>SceneTree</title>
        <paragraph><strong>Inherits:</strong> <reference internal="True" refuri="class_mainloop#class-mainloop"><inline classes="std std-ref">MainLoop</inline></reference> <strong>&lt;</strong> <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference></paragraph>
        <paragraph>Manages the game loop via a hierarchy of nodes.</paragraph>
        <section classes="classref-introduction-group" ids="description" names="description">
            <title>Description</title>
            <paragraph>As one of the most important classes, the <strong>SceneTree</strong> manages the hierarchy of nodes in a scene, as well as scenes themselves. Nodes can be added, fetched and removed. The whole scene tree (and thus the current scene) can be paused. Scenes can be loaded, switched and reloaded.</paragraph>
            <paragraph>You can also use the <strong>SceneTree</strong> to organize your nodes into <strong>groups</strong>: every node can be added to as many groups as you want to create, e.g. an "enemy" group. You can then iterate these groups or even call methods and set properties on all the nodes belonging to any given group.</paragraph>
            <paragraph><strong>SceneTree</strong> is the default <reference internal="True" refuri="class_mainloop#class-mainloop"><inline classes="std std-ref">MainLoop</inline></reference> implementation used by the engine, and is thus in charge of the game loop.</paragraph>
        </section>
        <section classes="classref-introduction-group" ids="tutorials" names="tutorials">
            <title>Tutorials</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/scripting/scene_tree"><inline classes="doc">SceneTree</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/rendering/multiple_resolutions"><inline classes="doc">Multiple resolutions</inline></reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section classes="classref-reftable-group" ids="properties" names="properties">
            <title>Properties</title>
            <table classes="colwidths-auto">
                <tgroup cols="3">
                    <colspec colwidth="29"></colspec>
                    <colspec colwidth="78"></colspec>
                    <colspec colwidth="11"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-property-auto-accept-quit"><inline classes="std std-ref">auto_accept_quit</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>true</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-property-current-scene"><inline classes="std std-ref">current_scene</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-property-debug-collisions-hint"><inline classes="std std-ref">debug_collisions_hint</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>false</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-property-debug-navigation-hint"><inline classes="std std-ref">debug_navigation_hint</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>false</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-property-debug-paths-hint"><inline classes="std std-ref">debug_paths_hint</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>false</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-property-edited-scene-root"><inline classes="std std-ref">edited_scene_root</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-property-multiplayer-poll"><inline classes="std std-ref">multiplayer_poll</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>true</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-property-paused"><inline classes="std std-ref">paused</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>false</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-property-physics-interpolation"><inline classes="std std-ref">physics_interpolation</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>false</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-property-quit-on-go-back"><inline classes="std std-ref">quit_on_go_back</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>true</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-property-root"><inline classes="std std-ref">root</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="methods" names="methods">
            <title>Methods</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="56"></colspec>
                    <colspec colwidth="258"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-call-group"><inline classes="std std-ref">call_group</inline></reference>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-call-group-flags"><inline classes="std std-ref">call_group_flags</inline></reference>(flags: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-change-scene-to-file"><inline classes="std std-ref">change_scene_to_file</inline></reference>(path: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-change-scene-to-node"><inline classes="std std-ref">change_scene_to_node</inline></reference>(node: <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-change-scene-to-packed"><inline classes="std std-ref">change_scene_to_packed</inline></reference>(packed_scene: <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_scenetreetimer#class-scenetreetimer"><inline classes="std std-ref">SceneTreeTimer</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-create-timer"><inline classes="std std-ref">create_timer</inline></reference>(time_sec: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>, process_always: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true, process_in_physics: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false, ignore_time_scale: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-create-tween"><inline classes="std std-ref">create_tween</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-get-first-node-in-group"><inline classes="std std-ref">get_first_node_in_group</inline></reference>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-get-frame"><inline classes="std std-ref">get_frame</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-get-multiplayer"><inline classes="std std-ref">get_multiplayer</inline></reference>(for_path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> = NodePath("")) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-get-node-count"><inline classes="std std-ref">get_node_count</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-get-node-count-in-group"><inline classes="std std-ref">get_node_count_in_group</inline></reference>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-get-nodes-in-group"><inline classes="std std-ref">get_nodes_in_group</inline></reference>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-get-processed-tweens"><inline classes="std std-ref">get_processed_tweens</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-has-group"><inline classes="std std-ref">has_group</inline></reference>(name: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-is-accessibility-enabled"><inline classes="std std-ref">is_accessibility_enabled</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-is-accessibility-supported"><inline classes="std std-ref">is_accessibility_supported</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-notify-group"><inline classes="std std-ref">notify_group</inline></reference>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, notification: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-notify-group-flags"><inline classes="std std-ref">notify_group_flags</inline></reference>(call_flags: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, notification: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-queue-delete"><inline classes="std std-ref">queue_delete</inline></reference>(obj: <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-quit"><inline classes="std std-ref">quit</inline></reference>(exit_code: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-reload-current-scene"><inline classes="std std-ref">reload_current_scene</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-set-group"><inline classes="std std-ref">set_group</inline></reference>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, property: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-set-group-flags"><inline classes="std std-ref">set_group_flags</inline></reference>(call_flags: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, property: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-set-multiplayer"><inline classes="std std-ref">set_multiplayer</inline></reference>(multiplayer: <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference>, root_path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> = NodePath(""))</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-scenetree-method-unload-current-scene"><inline classes="std std-ref">unload_current_scene</inline></reference>()</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="signals" names="signals">
            <title>Signals</title>
            <target refid="class-scenetree-signal-node-added"></target>
            <paragraph classes="classref-signal" ids="class-scenetree-signal-node-added" names="class_scenetree_signal_node_added"><strong>node_added</strong>(node: <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>) <reference internal="True" refid="class-scenetree-signal-node-added"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Emitted when the <literal>node</literal> enters this tree.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-signal-node-configuration-warning-changed"></target>
            <paragraph classes="classref-signal" ids="class-scenetree-signal-node-configuration-warning-changed" names="class_scenetree_signal_node_configuration_warning_changed"><strong>node_configuration_warning_changed</strong>(node: <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>) <reference internal="True" refid="class-scenetree-signal-node-configuration-warning-changed"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Emitted when the <literal>node</literal>'s <reference internal="True" refuri="class_node#class-node-method-update-configuration-warnings"><inline classes="std std-ref">Node.update_configuration_warnings()</inline></reference> is called. Only emitted in the editor.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-signal-node-removed"></target>
            <paragraph classes="classref-signal" ids="class-scenetree-signal-node-removed" names="class_scenetree_signal_node_removed"><strong>node_removed</strong>(node: <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>) <reference internal="True" refid="class-scenetree-signal-node-removed"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Emitted when the <literal>node</literal> exits this tree.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-signal-node-renamed"></target>
            <paragraph classes="classref-signal" ids="class-scenetree-signal-node-renamed" names="class_scenetree_signal_node_renamed"><strong>node_renamed</strong>(node: <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>) <reference internal="True" refid="class-scenetree-signal-node-renamed"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Emitted when the <literal>node</literal>'s <reference internal="True" refuri="class_node#class-node-property-name"><inline classes="std std-ref">Node.name</inline></reference> is changed.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-signal-physics-frame"></target>
            <paragraph classes="classref-signal" ids="class-scenetree-signal-physics-frame" names="class_scenetree_signal_physics_frame"><strong>physics_frame</strong>() <reference internal="True" refid="class-scenetree-signal-physics-frame"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Emitted immediately before <reference internal="True" refuri="class_node#class-node-private-method-physics-process"><inline classes="std std-ref">Node._physics_process()</inline></reference> is called on every node in this tree.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-signal-process-frame"></target>
            <paragraph classes="classref-signal" ids="class-scenetree-signal-process-frame" names="class_scenetree_signal_process_frame"><strong>process_frame</strong>() <reference internal="True" refid="class-scenetree-signal-process-frame"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Emitted immediately before <reference internal="True" refuri="class_node#class-node-private-method-process"><inline classes="std std-ref">Node._process()</inline></reference> is called on every node in this tree.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-signal-scene-changed"></target>
            <paragraph classes="classref-signal" ids="class-scenetree-signal-scene-changed" names="class_scenetree_signal_scene_changed"><strong>scene_changed</strong>() <reference internal="True" refid="class-scenetree-signal-scene-changed"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Emitted after the new scene is added to scene tree and initialized. Can be used to reliably access <reference internal="True" refid="class-scenetree-property-current-scene"><inline classes="std std-ref">current_scene</inline></reference> when changing scenes.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># This code should be inside an autoload.
get_tree().change_scene_to_file(other_scene_path)
await get_tree().scene_changed
print(get_tree().current_scene) # Prints the new scene.</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-signal-tree-changed"></target>
            <paragraph classes="classref-signal" ids="class-scenetree-signal-tree-changed" names="class_scenetree_signal_tree_changed"><strong>tree_changed</strong>() <reference internal="True" refid="class-scenetree-signal-tree-changed"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Emitted any time the tree's hierarchy changes (nodes being moved, renamed, etc.).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-signal-tree-process-mode-changed"></target>
            <paragraph classes="classref-signal" ids="class-scenetree-signal-tree-process-mode-changed" names="class_scenetree_signal_tree_process_mode_changed"><strong>tree_process_mode_changed</strong>() <reference internal="True" refid="class-scenetree-signal-tree-process-mode-changed"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Emitted when the <reference internal="True" refuri="class_node#class-node-property-process-mode"><inline classes="std std-ref">Node.process_mode</inline></reference> of any node inside the tree is changed. Only emitted in the editor, to update the visibility of disabled nodes.</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="enumerations" names="enumerations">
            <title>Enumerations</title>
            <target refid="enum-scenetree-groupcallflags"></target>
            <paragraph classes="classref-enumeration" ids="enum-scenetree-groupcallflags" names="enum_scenetree_groupcallflags">enum <strong>GroupCallFlags</strong>: <reference internal="True" refid="enum-scenetree-groupcallflags"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <target refid="class-scenetree-constant-group-call-default"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-scenetree-constant-group-call-default" names="class_scenetree_constant_group_call_default"><reference internal="True" refid="enum-scenetree-groupcallflags"><inline classes="std std-ref">GroupCallFlags</inline></reference> <strong>GROUP_CALL_DEFAULT</strong> = <literal>0</literal></paragraph>
            <paragraph>Call nodes within a group with no special behavior (default).</paragraph>
            <target refid="class-scenetree-constant-group-call-reverse"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-scenetree-constant-group-call-reverse" names="class_scenetree_constant_group_call_reverse"><reference internal="True" refid="enum-scenetree-groupcallflags"><inline classes="std std-ref">GroupCallFlags</inline></reference> <strong>GROUP_CALL_REVERSE</strong> = <literal>1</literal></paragraph>
            <paragraph>Call nodes within a group in reverse tree hierarchy order (all nested children are called before their respective parent nodes).</paragraph>
            <target refid="class-scenetree-constant-group-call-deferred"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-scenetree-constant-group-call-deferred" names="class_scenetree_constant_group_call_deferred"><reference internal="True" refid="enum-scenetree-groupcallflags"><inline classes="std std-ref">GroupCallFlags</inline></reference> <strong>GROUP_CALL_DEFERRED</strong> = <literal>2</literal></paragraph>
            <paragraph>Call nodes within a group at the end of the current frame (can be either process or physics frame), similar to <reference internal="True" refuri="class_object#class-object-method-call-deferred"><inline classes="std std-ref">Object.call_deferred()</inline></reference>.</paragraph>
            <target refid="class-scenetree-constant-group-call-unique"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-scenetree-constant-group-call-unique" names="class_scenetree_constant_group_call_unique"><reference internal="True" refid="enum-scenetree-groupcallflags"><inline classes="std std-ref">GroupCallFlags</inline></reference> <strong>GROUP_CALL_UNIQUE</strong> = <literal>4</literal></paragraph>
            <paragraph>Call nodes within a group only once, even if the call is executed many times in the same frame. Must be combined with <reference internal="True" refid="class-scenetree-constant-group-call-deferred"><inline classes="std std-ref">GROUP_CALL_DEFERRED</inline></reference> to work.</paragraph>
            <paragraph><strong>Note:</strong> Different arguments are not taken into account. Therefore, when the same call is executed with different arguments, only the first call will be performed.</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="property-descriptions" names="property\ descriptions">
            <title>Property Descriptions</title>
            <target refid="class-scenetree-property-auto-accept-quit"></target>
            <paragraph classes="classref-property" ids="class-scenetree-property-auto-accept-quit" names="class_scenetree_property_auto_accept_quit"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>auto_accept_quit</strong> = <literal>true</literal> <reference internal="True" refid="class-scenetree-property-auto-accept-quit"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_auto_accept_quit</strong>(value: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_auto_accept_quit</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If <literal>true</literal>, the application automatically accepts quitting requests.</paragraph>
            <paragraph>For mobile platforms, see <reference internal="True" refid="class-scenetree-property-quit-on-go-back"><inline classes="std std-ref">quit_on_go_back</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-property-current-scene"></target>
            <paragraph classes="classref-property" ids="class-scenetree-property-current-scene" names="class_scenetree_property_current_scene"><reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference> <strong>current_scene</strong> <reference internal="True" refid="class-scenetree-property-current-scene"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_current_scene</strong>(value: <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference> <strong>get_current_scene</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The root node of the currently loaded main scene, usually as a direct child of <reference internal="True" refid="class-scenetree-property-root"><inline classes="std std-ref">root</inline></reference>. See also <reference internal="True" refid="class-scenetree-method-change-scene-to-file"><inline classes="std std-ref">change_scene_to_file()</inline></reference>, <reference internal="True" refid="class-scenetree-method-change-scene-to-packed"><inline classes="std std-ref">change_scene_to_packed()</inline></reference>, and <reference internal="True" refid="class-scenetree-method-reload-current-scene"><inline classes="std std-ref">reload_current_scene()</inline></reference>.</paragraph>
            <paragraph><strong>Warning:</strong> Setting this property directly may not work as expected, as it does <emphasis>not</emphasis> add or remove any nodes from this tree.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-property-debug-collisions-hint"></target>
            <paragraph classes="classref-property" ids="class-scenetree-property-debug-collisions-hint" names="class_scenetree_property_debug_collisions_hint"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>debug_collisions_hint</strong> = <literal>false</literal> <reference internal="True" refid="class-scenetree-property-debug-collisions-hint"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_debug_collisions_hint</strong>(value: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_debugging_collisions_hint</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If <literal>true</literal>, collision shapes will be visible when running the game from the editor for debugging purposes.</paragraph>
            <paragraph><strong>Note:</strong> This property is not designed to be changed at run-time. Changing the value of <reference internal="True" refid="class-scenetree-property-debug-collisions-hint"><inline classes="std std-ref">debug_collisions_hint</inline></reference> while the project is running will not have the desired effect.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-property-debug-navigation-hint"></target>
            <paragraph classes="classref-property" ids="class-scenetree-property-debug-navigation-hint" names="class_scenetree_property_debug_navigation_hint"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>debug_navigation_hint</strong> = <literal>false</literal> <reference internal="True" refid="class-scenetree-property-debug-navigation-hint"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_debug_navigation_hint</strong>(value: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_debugging_navigation_hint</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If <literal>true</literal>, navigation polygons will be visible when running the game from the editor for debugging purposes.</paragraph>
            <paragraph><strong>Note:</strong> This property is not designed to be changed at run-time. Changing the value of <reference internal="True" refid="class-scenetree-property-debug-navigation-hint"><inline classes="std std-ref">debug_navigation_hint</inline></reference> while the project is running will not have the desired effect.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-property-debug-paths-hint"></target>
            <paragraph classes="classref-property" ids="class-scenetree-property-debug-paths-hint" names="class_scenetree_property_debug_paths_hint"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>debug_paths_hint</strong> = <literal>false</literal> <reference internal="True" refid="class-scenetree-property-debug-paths-hint"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_debug_paths_hint</strong>(value: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_debugging_paths_hint</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If <literal>true</literal>, curves from <reference internal="True" refuri="class_path2d#class-path2d"><inline classes="std std-ref">Path2D</inline></reference> and <reference internal="True" refuri="class_path3d#class-path3d"><inline classes="std std-ref">Path3D</inline></reference> nodes will be visible when running the game from the editor for debugging purposes.</paragraph>
            <paragraph><strong>Note:</strong> This property is not designed to be changed at run-time. Changing the value of <reference internal="True" refid="class-scenetree-property-debug-paths-hint"><inline classes="std std-ref">debug_paths_hint</inline></reference> while the project is running will not have the desired effect.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-property-edited-scene-root"></target>
            <paragraph classes="classref-property" ids="class-scenetree-property-edited-scene-root" names="class_scenetree_property_edited_scene_root"><reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference> <strong>edited_scene_root</strong> <reference internal="True" refid="class-scenetree-property-edited-scene-root"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_edited_scene_root</strong>(value: <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference> <strong>get_edited_scene_root</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The root of the scene currently being edited in the editor. This is usually a direct child of <reference internal="True" refid="class-scenetree-property-root"><inline classes="std std-ref">root</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This property does nothing in release builds.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-property-multiplayer-poll"></target>
            <paragraph classes="classref-property" ids="class-scenetree-property-multiplayer-poll" names="class_scenetree_property_multiplayer_poll"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>multiplayer_poll</strong> = <literal>true</literal> <reference internal="True" refid="class-scenetree-property-multiplayer-poll"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_multiplayer_poll_enabled</strong>(value: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_multiplayer_poll_enabled</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If <literal>true</literal> (default value), enables automatic polling of the <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> for this SceneTree during <reference internal="True" refid="class-scenetree-signal-process-frame"><inline classes="std std-ref">process_frame</inline></reference>.</paragraph>
            <paragraph>If <literal>false</literal>, you need to manually call <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi-method-poll"><inline classes="std std-ref">MultiplayerAPI.poll()</inline></reference> to process network packets and deliver RPCs. This allows running RPCs in a different loop (e.g. physics, thread, specific time step) and for manual <reference internal="True" refuri="class_mutex#class-mutex"><inline classes="std std-ref">Mutex</inline></reference> protection when accessing the <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> from threads.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-property-paused"></target>
            <paragraph classes="classref-property" ids="class-scenetree-property-paused" names="class_scenetree_property_paused"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>paused</strong> = <literal>false</literal> <reference internal="True" refid="class-scenetree-property-paused"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_pause</strong>(value: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_paused</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If <literal>true</literal>, the scene tree is considered paused. This causes the following behavior:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>2D and 3D physics will be stopped, as well as collision detection and related signals.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Depending on each node's <reference internal="True" refuri="class_node#class-node-property-process-mode"><inline classes="std std-ref">Node.process_mode</inline></reference>, their <reference internal="True" refuri="class_node#class-node-private-method-process"><inline classes="std std-ref">Node._process()</inline></reference>, <reference internal="True" refuri="class_node#class-node-private-method-physics-process"><inline classes="std std-ref">Node._physics_process()</inline></reference> and <reference internal="True" refuri="class_node#class-node-private-method-input"><inline classes="std std-ref">Node._input()</inline></reference> callback methods may not called anymore.</paragraph>
                </list_item>
            </bullet_list>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-property-physics-interpolation"></target>
            <paragraph classes="classref-property" ids="class-scenetree-property-physics-interpolation" names="class_scenetree_property_physics_interpolation"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>physics_interpolation</strong> = <literal>false</literal> <reference internal="True" refid="class-scenetree-property-physics-interpolation"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_physics_interpolation_enabled</strong>(value: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_physics_interpolation_enabled</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If <literal>true</literal>, the renderer will interpolate the transforms of objects (both physics and non-physics) between the last two transforms, so that smooth motion is seen even when physics ticks do not coincide with rendered frames.</paragraph>
            <paragraph>The default value of this property is controlled by <reference internal="True" refuri="class_projectsettings#class-projectsettings-property-physics-common-physics-interpolation"><inline classes="std std-ref">ProjectSettings.physics/common/physics_interpolation</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> Although this is a global setting, finer control of individual branches of the <strong>SceneTree</strong> is possible using <reference internal="True" refuri="class_node#class-node-property-physics-interpolation-mode"><inline classes="std std-ref">Node.physics_interpolation_mode</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-property-quit-on-go-back"></target>
            <paragraph classes="classref-property" ids="class-scenetree-property-quit-on-go-back" names="class_scenetree_property_quit_on_go_back"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>quit_on_go_back</strong> = <literal>true</literal> <reference internal="True" refid="class-scenetree-property-quit-on-go-back"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_quit_on_go_back</strong>(value: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_quit_on_go_back</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If <literal>true</literal>, the application quits automatically when navigating back (e.g. using the system "Back" button on Android).</paragraph>
            <paragraph>To handle 'Go Back' button when this option is disabled, use <reference internal="True" refuri="class_displayserver#class-displayserver-constant-window-event-go-back-request"><inline classes="std std-ref">DisplayServer.WINDOW_EVENT_GO_BACK_REQUEST</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-property-root"></target>
            <paragraph classes="classref-property" ids="class-scenetree-property-root" names="class_scenetree_property_root"><reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> <strong>root</strong> <reference internal="True" refid="class-scenetree-property-root"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> <strong>get_root</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The tree's root <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference>. This is top-most <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference> of the scene tree, and is always present. An absolute <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> always starts from this node. Children of the root node may include the loaded <reference internal="True" refid="class-scenetree-property-current-scene"><inline classes="std std-ref">current_scene</inline></reference>, as well as any <reference internal="True" refuri="../tutorials/scripting/singletons_autoload"><inline classes="doc">AutoLoad</inline></reference> configured in the Project Settings.</paragraph>
            <paragraph><strong>Warning:</strong> Do not delete this node. This will result in unstable behavior, followed by a crash.</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="method-descriptions" names="method\ descriptions">
            <title>Method Descriptions</title>
            <target refid="class-scenetree-method-call-group"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-call-group" names="class_scenetree_method_call_group"><abbreviation explanation="No return value.">void</abbreviation> <strong>call_group</strong>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <reference internal="True" refid="class-scenetree-method-call-group"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Calls <literal>method</literal> on each node inside this tree added to the given <literal>group</literal>. You can pass arguments to <literal>method</literal> by specifying them at the end of this method call. Nodes that cannot call <literal>method</literal> (either because the method doesn't exist or the arguments do not match) are ignored. See also <reference internal="True" refid="class-scenetree-method-set-group"><inline classes="std std-ref">set_group()</inline></reference> and <reference internal="True" refid="class-scenetree-method-notify-group"><inline classes="std std-ref">notify_group()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This method acts immediately on all selected nodes at once, which may cause stuttering in some performance-intensive situations.</paragraph>
            <paragraph><strong>Note:</strong> In C#, <literal>method</literal> must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the <literal>MethodName</literal> class to avoid allocating a new <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> on each call.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-call-group-flags"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-call-group-flags" names="class_scenetree_method_call_group_flags"><abbreviation explanation="No return value.">void</abbreviation> <strong>call_group_flags</strong>(flags: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <reference internal="True" refid="class-scenetree-method-call-group-flags"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Calls the given <literal>method</literal> on each node inside this tree added to the given <literal>group</literal>. Use <literal>flags</literal> to customize this method's behavior (see <reference internal="True" refid="enum-scenetree-groupcallflags"><inline classes="std std-ref">GroupCallFlags</inline></reference>). Additional arguments for <literal>method</literal> can be passed at the end of this method. Nodes that cannot call <literal>method</literal> (either because the method doesn't exist or the arguments do not match) are ignored.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Calls "hide" to all nodes of the "enemies" group, at the end of the frame and in reverse tree order.
get_tree().call_group_flags(
        SceneTree.GROUP_CALL_DEFERRED | SceneTree.GROUP_CALL_REVERSE,
        "enemies", "hide")</literal_block>
            <paragraph><strong>Note:</strong> In C#, <literal>method</literal> must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the <literal>MethodName</literal> class to avoid allocating a new <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> on each call.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-change-scene-to-file"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-change-scene-to-file" names="class_scenetree_method_change_scene_to_file"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>change_scene_to_file</strong>(path: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>) <reference internal="True" refid="class-scenetree-method-change-scene-to-file"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Changes the running scene to the one at the given <literal>path</literal>, after loading it into a <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference> and creating a new instance.</paragraph>
            <paragraph>Returns <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-ok"><inline classes="std std-ref">@GlobalScope.OK</inline></reference> on success, <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-cant-open"><inline classes="std std-ref">@GlobalScope.ERR_CANT_OPEN</inline></reference> if the <literal>path</literal> cannot be loaded into a <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference>, or <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-cant-create"><inline classes="std std-ref">@GlobalScope.ERR_CANT_CREATE</inline></reference> if that scene cannot be instantiated.</paragraph>
            <paragraph><strong>Note:</strong> See <reference internal="True" refid="class-scenetree-method-change-scene-to-node"><inline classes="std std-ref">change_scene_to_node()</inline></reference> for details on the order of operations.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-change-scene-to-node"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-change-scene-to-node" names="class_scenetree_method_change_scene_to_node"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>change_scene_to_node</strong>(node: <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>) <reference internal="True" refid="class-scenetree-method-change-scene-to-node"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Changes the running scene to the provided <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>. Useful when you want to set up the new scene before changing.</paragraph>
            <paragraph>Returns <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-ok"><inline classes="std std-ref">@GlobalScope.OK</inline></reference> on success, <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-invalid-parameter"><inline classes="std std-ref">@GlobalScope.ERR_INVALID_PARAMETER</inline></reference> if the <literal>node</literal> is <literal>null</literal>, or <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-unconfigured"><inline classes="std std-ref">@GlobalScope.ERR_UNCONFIGURED</inline></reference> if the <literal>node</literal> is already inside the scene tree.</paragraph>
            <paragraph><strong>Note:</strong> Operations happen in the following order when <reference internal="True" refid="class-scenetree-method-change-scene-to-node"><inline classes="std std-ref">change_scene_to_node()</inline></reference> is called:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>The current scene node is immediately removed from the tree. From that point, <reference internal="True" refuri="class_node#class-node-method-get-tree"><inline classes="std std-ref">Node.get_tree()</inline></reference> called on the current (outgoing) scene will return <literal>null</literal>. <reference internal="True" refid="class-scenetree-property-current-scene"><inline classes="std std-ref">current_scene</inline></reference> will be <literal>null</literal> too, because the new scene is not available yet.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>At the end of the frame, the formerly current scene, already removed from the tree, will be deleted (freed from memory) and then the new scene node will be added to the tree. <reference internal="True" refuri="class_node#class-node-method-get-tree"><inline classes="std std-ref">Node.get_tree()</inline></reference> and <reference internal="True" refid="class-scenetree-property-current-scene"><inline classes="std std-ref">current_scene</inline></reference> will be back to working as usual.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>This ensures that both scenes aren't running at the same time, while still freeing the previous scene in a safe way similar to <reference internal="True" refuri="class_node#class-node-method-queue-free"><inline classes="std std-ref">Node.queue_free()</inline></reference>.</paragraph>
            <paragraph>If you want to reliably access the new scene, await the <reference internal="True" refid="class-scenetree-signal-scene-changed"><inline classes="std std-ref">scene_changed</inline></reference> signal.</paragraph>
            <paragraph><strong>Warning:</strong> After using this method, the <strong>SceneTree</strong> will take ownership of the node and will free it automatically when changing scene again. Any references you had to that node will become invalid.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-change-scene-to-packed"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-change-scene-to-packed" names="class_scenetree_method_change_scene_to_packed"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>change_scene_to_packed</strong>(packed_scene: <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference>) <reference internal="True" refid="class-scenetree-method-change-scene-to-packed"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Changes the running scene to a new instance of the given <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference> (which must be valid).</paragraph>
            <paragraph>Returns <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-ok"><inline classes="std std-ref">@GlobalScope.OK</inline></reference> on success, <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-cant-create"><inline classes="std std-ref">@GlobalScope.ERR_CANT_CREATE</inline></reference> if the scene cannot be instantiated, or <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-invalid-parameter"><inline classes="std std-ref">@GlobalScope.ERR_INVALID_PARAMETER</inline></reference> if the scene is invalid.</paragraph>
            <paragraph><strong>Note:</strong> See <reference internal="True" refid="class-scenetree-method-change-scene-to-node"><inline classes="std std-ref">change_scene_to_node()</inline></reference> for details on the order of operations.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-create-timer"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-create-timer" names="class_scenetree_method_create_timer"><reference internal="True" refuri="class_scenetreetimer#class-scenetreetimer"><inline classes="std std-ref">SceneTreeTimer</inline></reference> <strong>create_timer</strong>(time_sec: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>, process_always: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true, process_in_physics: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false, ignore_time_scale: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <reference internal="True" refid="class-scenetree-method-create-timer"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns a new <reference internal="True" refuri="class_scenetreetimer#class-scenetreetimer"><inline classes="std std-ref">SceneTreeTimer</inline></reference>. After <literal>time_sec</literal> in seconds have passed, the timer will emit <reference internal="True" refuri="class_scenetreetimer#class-scenetreetimer-signal-timeout"><inline classes="std std-ref">SceneTreeTimer.timeout</inline></reference> and will be automatically freed.</paragraph>
            <paragraph>If <literal>process_always</literal> is <literal>false</literal>, the timer will be paused when setting <reference internal="True" refid="class-scenetree-property-paused"><inline classes="std std-ref">paused</inline></reference> to <literal>true</literal>.</paragraph>
            <paragraph>If <literal>process_in_physics</literal> is <literal>true</literal>, the timer will update at the end of the physics frame, instead of the process frame.</paragraph>
            <paragraph>If <literal>ignore_time_scale</literal> is <literal>true</literal>, the timer will ignore <reference internal="True" refuri="class_engine#class-engine-property-time-scale"><inline classes="std std-ref">Engine.time_scale</inline></reference> and update with the real, elapsed time.</paragraph>
            <paragraph>This method is commonly used to create a one-shot delay timer, as in the following example:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func some_function():
    print("start")
    await get_tree().create_timer(1.0).timeout
    print("end")</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public async Task SomeFunction()
{
    GD.Print("start");
    await ToSignal(GetTree().CreateTimer(1.0f), SceneTreeTimer.SignalName.Timeout);
    GD.Print("end");
}</literal_block>
                </div>
            </container>
            <paragraph><strong>Note:</strong> The timer is always updated <emphasis>after</emphasis> all of the nodes in the tree. A node's <reference internal="True" refuri="class_node#class-node-private-method-process"><inline classes="std std-ref">Node._process()</inline></reference> method would be called before the timer updates (or <reference internal="True" refuri="class_node#class-node-private-method-physics-process"><inline classes="std std-ref">Node._physics_process()</inline></reference> if <literal>process_in_physics</literal> is set to <literal>true</literal>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-create-tween"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-create-tween" names="class_scenetree_method_create_tween"><reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference> <strong>create_tween</strong>() <reference internal="True" refid="class-scenetree-method-create-tween"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Creates and returns a new <reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference> processed in this tree. The Tween will start automatically on the next process frame or physics frame (depending on its <reference internal="True" refuri="class_tween#enum-tween-tweenprocessmode"><inline classes="std std-ref">TweenProcessMode</inline></reference>).</paragraph>
            <paragraph><strong>Note:</strong> A <reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference> created using this method is not bound to any <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>. It may keep working until there is nothing left to animate. If you want the <reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference> to be automatically killed when the <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference> is freed, use <reference internal="True" refuri="class_node#class-node-method-create-tween"><inline classes="std std-ref">Node.create_tween()</inline></reference> or <reference internal="True" refuri="class_tween#class-tween-method-bind-node"><inline classes="std std-ref">Tween.bind_node()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-get-first-node-in-group"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-get-first-node-in-group" names="class_scenetree_method_get_first_node_in_group"><reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference> <strong>get_first_node_in_group</strong>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <reference internal="True" refid="class-scenetree-method-get-first-node-in-group"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the first <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference> found inside the tree, that has been added to the given <literal>group</literal>, in scene hierarchy order. Returns <literal>null</literal> if no match is found. See also <reference internal="True" refid="class-scenetree-method-get-nodes-in-group"><inline classes="std std-ref">get_nodes_in_group()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-get-frame"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-get-frame" names="class_scenetree_method_get_frame"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_frame</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-scenetree-method-get-frame"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns how many physics process steps have been processed, since the application started. This is <emphasis>not</emphasis> a measurement of elapsed time. See also <reference internal="True" refid="class-scenetree-signal-physics-frame"><inline classes="std std-ref">physics_frame</inline></reference>. For the number of frames rendered, see <reference internal="True" refuri="class_engine#class-engine-method-get-process-frames"><inline classes="std std-ref">Engine.get_process_frames()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-get-multiplayer"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-get-multiplayer" names="class_scenetree_method_get_multiplayer"><reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> <strong>get_multiplayer</strong>(for_path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> = NodePath("")) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-scenetree-method-get-multiplayer"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Searches for the <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> configured for the given path, if one does not exist it searches the parent paths until one is found. If the path is empty, or none is found, the default one is returned. See <reference internal="True" refid="class-scenetree-method-set-multiplayer"><inline classes="std std-ref">set_multiplayer()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-get-node-count"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-get-node-count" names="class_scenetree_method_get_node_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_node_count</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-scenetree-method-get-node-count"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the number of nodes inside this tree.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-get-node-count-in-group"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-get-node-count-in-group" names="class_scenetree_method_get_node_count_in_group"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_node_count_in_group</strong>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-scenetree-method-get-node-count-in-group"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the number of nodes assigned to the given group.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-get-nodes-in-group"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-get-nodes-in-group" names="class_scenetree_method_get_nodes_in_group"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>] <strong>get_nodes_in_group</strong>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <reference internal="True" refid="class-scenetree-method-get-nodes-in-group"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns an <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> containing all nodes inside this tree, that have been added to the given <literal>group</literal>, in scene hierarchy order.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-get-processed-tweens"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-get-processed-tweens" names="class_scenetree_method_get_processed_tweens"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference>] <strong>get_processed_tweens</strong>() <reference internal="True" refid="class-scenetree-method-get-processed-tweens"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns an <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> of currently existing <reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference>s in the tree, including paused tweens.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-has-group"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-has-group" names="class_scenetree_method_has_group"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>has_group</strong>(name: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-scenetree-method-has-group"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if a node added to the given group <literal>name</literal> exists in the tree.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-is-accessibility-enabled"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-is-accessibility-enabled" names="class_scenetree_method_is_accessibility_enabled"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_accessibility_enabled</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-scenetree-method-is-accessibility-enabled"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if accessibility features are enabled, and accessibility information updates are actively processed.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-is-accessibility-supported"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-is-accessibility-supported" names="class_scenetree_method_is_accessibility_supported"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_accessibility_supported</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-scenetree-method-is-accessibility-supported"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if accessibility features are supported by the OS and enabled in project settings.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-notify-group"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-notify-group" names="class_scenetree_method_notify_group"><abbreviation explanation="No return value.">void</abbreviation> <strong>notify_group</strong>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, notification: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-scenetree-method-notify-group"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Calls <reference internal="True" refuri="class_object#class-object-method-notification"><inline classes="std std-ref">Object.notification()</inline></reference> with the given <literal>notification</literal> to all nodes inside this tree added to the <literal>group</literal>. See also <reference internal="True" refuri="../tutorials/best_practices/godot_notifications"><inline classes="doc">Godot notifications</inline></reference> and <reference internal="True" refid="class-scenetree-method-call-group"><inline classes="std std-ref">call_group()</inline></reference> and <reference internal="True" refid="class-scenetree-method-set-group"><inline classes="std std-ref">set_group()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This method acts immediately on all selected nodes at once, which may cause stuttering in some performance-intensive situations.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-notify-group-flags"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-notify-group-flags" names="class_scenetree_method_notify_group_flags"><abbreviation explanation="No return value.">void</abbreviation> <strong>notify_group_flags</strong>(call_flags: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, notification: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-scenetree-method-notify-group-flags"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Calls <reference internal="True" refuri="class_object#class-object-method-notification"><inline classes="std std-ref">Object.notification()</inline></reference> with the given <literal>notification</literal> to all nodes inside this tree added to the <literal>group</literal>. Use <literal>call_flags</literal> to customize this method's behavior (see <reference internal="True" refid="enum-scenetree-groupcallflags"><inline classes="std std-ref">GroupCallFlags</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-queue-delete"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-queue-delete" names="class_scenetree_method_queue_delete"><abbreviation explanation="No return value.">void</abbreviation> <strong>queue_delete</strong>(obj: <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference>) <reference internal="True" refid="class-scenetree-method-queue-delete"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Queues the given <literal>obj</literal> to be deleted, calling its <reference internal="True" refuri="class_object#class-object-method-free"><inline classes="std std-ref">Object.free()</inline></reference> at the end of the current frame. This method is similar to <reference internal="True" refuri="class_node#class-node-method-queue-free"><inline classes="std std-ref">Node.queue_free()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-quit"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-quit" names="class_scenetree_method_quit"><abbreviation explanation="No return value.">void</abbreviation> <strong>quit</strong>(exit_code: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <reference internal="True" refid="class-scenetree-method-quit"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Quits the application at the end of the current iteration, with the given <literal>exit_code</literal>.</paragraph>
            <paragraph>By convention, an exit code of <literal>0</literal> indicates success, whereas any other exit code indicates an error. For portability reasons, it should be between <literal>0</literal> and <literal>125</literal> (inclusive).</paragraph>
            <paragraph><strong>Note:</strong> On iOS this method doesn't work. Instead, as recommended by the <reference name="iOS Human Interface Guidelines" refuri="https://developer.apple.com/library/archive/qa/qa1561/_index.html">iOS Human Interface Guidelines</reference>, the user is expected to close apps via the Home button.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-reload-current-scene"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-reload-current-scene" names="class_scenetree_method_reload_current_scene"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>reload_current_scene</strong>() <reference internal="True" refid="class-scenetree-method-reload-current-scene"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Reloads the currently active scene, replacing <reference internal="True" refid="class-scenetree-property-current-scene"><inline classes="std std-ref">current_scene</inline></reference> with a new instance of its original <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference>.</paragraph>
            <paragraph>Returns <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-ok"><inline classes="std std-ref">@GlobalScope.OK</inline></reference> on success, <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-unconfigured"><inline classes="std std-ref">@GlobalScope.ERR_UNCONFIGURED</inline></reference> if no <reference internal="True" refid="class-scenetree-property-current-scene"><inline classes="std std-ref">current_scene</inline></reference> is defined, <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-cant-open"><inline classes="std std-ref">@GlobalScope.ERR_CANT_OPEN</inline></reference> if <reference internal="True" refid="class-scenetree-property-current-scene"><inline classes="std std-ref">current_scene</inline></reference> cannot be loaded into a <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference>, or <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-cant-create"><inline classes="std std-ref">@GlobalScope.ERR_CANT_CREATE</inline></reference> if the scene cannot be instantiated.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-set-group"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-set-group" names="class_scenetree_method_set_group"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_group</strong>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, property: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-scenetree-method-set-group"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Sets the given <literal>property</literal> to <literal>value</literal> on all nodes inside this tree added to the given <literal>group</literal>. Nodes that do not have the <literal>property</literal> are ignored. See also <reference internal="True" refid="class-scenetree-method-call-group"><inline classes="std std-ref">call_group()</inline></reference> and <reference internal="True" refid="class-scenetree-method-notify-group"><inline classes="std std-ref">notify_group()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This method acts immediately on all selected nodes at once, which may cause stuttering in some performance-intensive situations.</paragraph>
            <paragraph><strong>Note:</strong> In C#, <literal>property</literal> must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the <literal>PropertyName</literal> class to avoid allocating a new <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> on each call.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-set-group-flags"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-set-group-flags" names="class_scenetree_method_set_group_flags"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_group_flags</strong>(call_flags: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, property: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-scenetree-method-set-group-flags"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Sets the given <literal>property</literal> to <literal>value</literal> on all nodes inside this tree added to the given <literal>group</literal>. Nodes that do not have the <literal>property</literal> are ignored. Use <literal>call_flags</literal> to customize this method's behavior (see <reference internal="True" refid="enum-scenetree-groupcallflags"><inline classes="std std-ref">GroupCallFlags</inline></reference>).</paragraph>
            <paragraph><strong>Note:</strong> In C#, <literal>property</literal> must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the <literal>PropertyName</literal> class to avoid allocating a new <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> on each call.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-set-multiplayer"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-set-multiplayer" names="class_scenetree_method_set_multiplayer"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_multiplayer</strong>(multiplayer: <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference>, root_path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> = NodePath("")) <reference internal="True" refid="class-scenetree-method-set-multiplayer"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Sets a custom <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> with the given <literal>root_path</literal> (controlling also the relative subpaths), or override the default one if <literal>root_path</literal> is empty.</paragraph>
            <paragraph><strong>Note:</strong> No <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> must be configured for the subpath containing <literal>root_path</literal>, nested custom multiplayers are not allowed. I.e. if one is configured for <literal>"/root/Foo"</literal> setting one for <literal>"/root/Foo/Bar"</literal> will cause an error.</paragraph>
            <paragraph><strong>Note:</strong> <reference internal="True" refid="class-scenetree-method-set-multiplayer"><inline classes="std std-ref">set_multiplayer()</inline></reference> should be called <emphasis>before</emphasis> the child nodes are ready at the given <literal>root_path</literal>. If multiplayer nodes like <reference internal="True" refuri="class_multiplayerspawner#class-multiplayerspawner"><inline classes="std std-ref">MultiplayerSpawner</inline></reference> or <reference internal="True" refuri="class_multiplayersynchronizer#class-multiplayersynchronizer"><inline classes="std std-ref">MultiplayerSynchronizer</inline></reference> are added to the tree before the custom multiplayer API is set, they will not work.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-scenetree-method-unload-current-scene"></target>
            <paragraph classes="classref-method" ids="class-scenetree-method-unload-current-scene" names="class_scenetree_method_unload_current_scene"><abbreviation explanation="No return value.">void</abbreviation> <strong>unload_current_scene</strong>() <reference internal="True" refid="class-scenetree-method-unload-current-scene"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>If a current scene is loaded, calling this method will unload it.</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></substitution_definition>
            <substitution_definition names="required"><abbreviation explanation="This method is required to be overridden when extending its base class.">required</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="This method is used to construct a type.">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="This method describes a valid operator to use with this type as left-hand operand.">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="This value is an integer composed as a bitmask of the following flags.">BitField</abbreviation></substitution_definition>
            <substitution_definition names="void"><abbreviation explanation="No return value.">void</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
