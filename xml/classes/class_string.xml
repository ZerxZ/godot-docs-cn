<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_string.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/master/doc/classes/String.xml.</comment>
    <target refid="class-string"></target>
    <section ids="string class-string" names="string class_string">
        <title>String</title>
        <paragraph>字符串内置类型。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>这是内置的字符串 Variant 类型（GDScript 使用的就是这个类型）。字符串中可以包含任意数量的 Unicode 字符，暴露的方法可用于字符串的操作和生成。字符串有引用计数，使用写时复制技术（每次对字符串的修改都会返回新的 <strong>String</strong>），所以传递字符串的资源损耗很小。</paragraph>
            <paragraph>部分字符串方法有对应的变体。后缀 <literal>n</literal> 的变体（<reference internal="True" refid="class-string-method-countn"><inline classes="std std-ref">countn</inline></reference>、<reference internal="True" refid="class-string-method-findn"><inline classes="std std-ref">findn</inline></reference>、<reference internal="True" refid="class-string-method-replacen"><inline classes="std std-ref">replacen</inline></reference> 等）<strong>大小写不敏感</strong>（不区分大写字符和小写字符）。前缀 <literal>r</literal> 的方法变体（<reference internal="True" refid="class-string-method-rfind"><inline classes="std std-ref">rfind</inline></reference>、<reference internal="True" refid="class-string-method-rsplit"><inline classes="std std-ref">rsplit</inline></reference> 等）是逆序的，会从字符串末尾开始，而不是从开头开始。</paragraph>
            <paragraph><strong>注意：</strong>在布尔语境下，空字符串（<literal>""</literal>）的求值结果为 <literal>false</literal>。否则字符串的求值结果始终为 <literal>true</literal>。无法使用 <literal>not</literal> 运算符。检查空字符串请使用 <reference internal="True" refid="class-string-method-is-empty"><inline classes="std std-ref">is_empty</inline></reference>。</paragraph>
            <note>
                <paragraph>通过 C# 使用该 API 时会有显著不同，详见 <reference internal="True" refuri="../tutorials/scripting/c_sharp/c_sharp_differences#doc-c-sharp-differences"><inline classes="std std-ref">C# API 与 GDScript 的差异</inline></reference>。</paragraph>
            </note>
        </section>
        <section classes="classref-introduction-group" ids="id2" names="教程">
            <title>教程</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/scripting/gdscript/gdscript_format_string"><inline classes="doc">GDScript 格式字符串</inline></reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="构造函数">
            <title>构造函数</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="29"></colspec>
                    <colspec colwidth="98"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-constructor-string"><inline classes="std std-ref">String</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-constructor-string"><inline classes="std std-ref">String</inline></reference>(from: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-constructor-string"><inline classes="std std-ref">String</inline></reference>(from: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-constructor-string"><inline classes="std std-ref">String</inline></reference>(from: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id4" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="53"></colspec>
                    <colspec colwidth="187"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-begins-with"><inline classes="std std-ref">begins_with</inline></reference>(text: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-bigrams"><inline classes="std std-ref">bigrams</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-bin-to-int"><inline classes="std std-ref">bin_to_int</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-c-escape"><inline classes="std std-ref">c_escape</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-c-unescape"><inline classes="std std-ref">c_unescape</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-capitalize"><inline classes="std std-ref">capitalize</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-casecmp-to"><inline classes="std std-ref">casecmp_to</inline></reference>(to: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-chr"><inline classes="std std-ref">chr</inline></reference>(char: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-contains"><inline classes="std std-ref">contains</inline></reference>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-containsn"><inline classes="std std-ref">containsn</inline></reference>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-count"><inline classes="std std-ref">count</inline></reference>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0, to: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-countn"><inline classes="std std-ref">countn</inline></reference>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0, to: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-dedent"><inline classes="std std-ref">dedent</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-ends-with"><inline classes="std std-ref">ends_with</inline></reference>(text: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-erase"><inline classes="std std-ref">erase</inline></reference>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, chars: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 1) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-filecasecmp-to"><inline classes="std std-ref">filecasecmp_to</inline></reference>(to: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-filenocasecmp-to"><inline classes="std std-ref">filenocasecmp_to</inline></reference>(to: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-find"><inline classes="std std-ref">find</inline></reference>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-findn"><inline classes="std std-ref">findn</inline></reference>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-format"><inline classes="std std-ref">format</inline></reference>(values: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, placeholder: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> = "{_}") <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-get-base-dir"><inline classes="std std-ref">get_base_dir</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-get-basename"><inline classes="std std-ref">get_basename</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-get-extension"><inline classes="std std-ref">get_extension</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-get-file"><inline classes="std std-ref">get_file</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-get-slice"><inline classes="std std-ref">get_slice</inline></reference>(delimiter: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, slice: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-get-slice-count"><inline classes="std std-ref">get_slice_count</inline></reference>(delimiter: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-get-slicec"><inline classes="std std-ref">get_slicec</inline></reference>(delimiter: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, slice: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-hash"><inline classes="std std-ref">hash</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-hex-decode"><inline classes="std std-ref">hex_decode</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-hex-to-int"><inline classes="std std-ref">hex_to_int</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-humanize-size"><inline classes="std std-ref">humanize_size</inline></reference>(size: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-indent"><inline classes="std std-ref">indent</inline></reference>(prefix: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-insert"><inline classes="std std-ref">insert</inline></reference>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-is-absolute-path"><inline classes="std std-ref">is_absolute_path</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-is-empty"><inline classes="std std-ref">is_empty</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-is-relative-path"><inline classes="std std-ref">is_relative_path</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-is-subsequence-of"><inline classes="std std-ref">is_subsequence_of</inline></reference>(text: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-is-subsequence-ofn"><inline classes="std std-ref">is_subsequence_ofn</inline></reference>(text: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-is-valid-filename"><inline classes="std std-ref">is_valid_filename</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-is-valid-float"><inline classes="std std-ref">is_valid_float</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-is-valid-hex-number"><inline classes="std std-ref">is_valid_hex_number</inline></reference>(with_prefix: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-is-valid-html-color"><inline classes="std std-ref">is_valid_html_color</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-is-valid-identifier"><inline classes="std std-ref">is_valid_identifier</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-is-valid-int"><inline classes="std std-ref">is_valid_int</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-is-valid-ip-address"><inline classes="std std-ref">is_valid_ip_address</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-join"><inline classes="std std-ref">join</inline></reference>(parts: <reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-json-escape"><inline classes="std std-ref">json_escape</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-left"><inline classes="std std-ref">left</inline></reference>(length: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-length"><inline classes="std std-ref">length</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-lpad"><inline classes="std std-ref">lpad</inline></reference>(min_length: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, character: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> = " ") <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-lstrip"><inline classes="std std-ref">lstrip</inline></reference>(chars: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-match"><inline classes="std std-ref">match</inline></reference>(expr: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-matchn"><inline classes="std std-ref">matchn</inline></reference>(expr: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-md5-buffer"><inline classes="std std-ref">md5_buffer</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-md5-text"><inline classes="std std-ref">md5_text</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-naturalcasecmp-to"><inline classes="std std-ref">naturalcasecmp_to</inline></reference>(to: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-naturalnocasecmp-to"><inline classes="std std-ref">naturalnocasecmp_to</inline></reference>(to: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-nocasecmp-to"><inline classes="std std-ref">nocasecmp_to</inline></reference>(to: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-num"><inline classes="std std-ref">num</inline></reference>(number: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>, decimals: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = -1) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-num-int64"><inline classes="std std-ref">num_int64</inline></reference>(number: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, base: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 10, capitalize_hex: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-num-scientific"><inline classes="std std-ref">num_scientific</inline></reference>(number: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-num-uint64"><inline classes="std std-ref">num_uint64</inline></reference>(number: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, base: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 10, capitalize_hex: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-pad-decimals"><inline classes="std std-ref">pad_decimals</inline></reference>(digits: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-pad-zeros"><inline classes="std std-ref">pad_zeros</inline></reference>(digits: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-path-join"><inline classes="std std-ref">path_join</inline></reference>(file: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-repeat"><inline classes="std std-ref">repeat</inline></reference>(count: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-replace"><inline classes="std std-ref">replace</inline></reference>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, forwhat: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-replacen"><inline classes="std std-ref">replacen</inline></reference>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, forwhat: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-reverse"><inline classes="std std-ref">reverse</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-rfind"><inline classes="std std-ref">rfind</inline></reference>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = -1) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-rfindn"><inline classes="std std-ref">rfindn</inline></reference>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = -1) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-right"><inline classes="std std-ref">right</inline></reference>(length: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-rpad"><inline classes="std std-ref">rpad</inline></reference>(min_length: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, character: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> = " ") <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-rsplit"><inline classes="std std-ref">rsplit</inline></reference>(delimiter: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> = "", allow_empty: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true, maxsplit: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-rstrip"><inline classes="std std-ref">rstrip</inline></reference>(chars: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-sha1-buffer"><inline classes="std std-ref">sha1_buffer</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-sha1-text"><inline classes="std std-ref">sha1_text</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-sha256-buffer"><inline classes="std std-ref">sha256_buffer</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-sha256-text"><inline classes="std std-ref">sha256_text</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-similarity"><inline classes="std std-ref">similarity</inline></reference>(text: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-simplify-path"><inline classes="std std-ref">simplify_path</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-split"><inline classes="std std-ref">split</inline></reference>(delimiter: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> = "", allow_empty: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true, maxsplit: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-split-floats"><inline classes="std std-ref">split_floats</inline></reference>(delimiter: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, allow_empty: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-strip-edges"><inline classes="std std-ref">strip_edges</inline></reference>(left: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true, right: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-strip-escapes"><inline classes="std std-ref">strip_escapes</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-substr"><inline classes="std std-ref">substr</inline></reference>(from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, len: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = -1) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-to-ascii-buffer"><inline classes="std std-ref">to_ascii_buffer</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-to-camel-case"><inline classes="std std-ref">to_camel_case</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-to-float"><inline classes="std std-ref">to_float</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-to-int"><inline classes="std std-ref">to_int</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-to-lower"><inline classes="std std-ref">to_lower</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-to-pascal-case"><inline classes="std std-ref">to_pascal_case</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-to-snake-case"><inline classes="std std-ref">to_snake_case</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-to-upper"><inline classes="std std-ref">to_upper</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-to-utf8-buffer"><inline classes="std std-ref">to_utf8_buffer</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-to-utf16-buffer"><inline classes="std std-ref">to_utf16_buffer</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-to-utf32-buffer"><inline classes="std std-ref">to_utf32_buffer</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-to-wchar-buffer"><inline classes="std std-ref">to_wchar_buffer</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-trim-prefix"><inline classes="std std-ref">trim_prefix</inline></reference>(prefix: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-trim-suffix"><inline classes="std std-ref">trim_suffix</inline></reference>(suffix: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-unicode-at"><inline classes="std std-ref">unicode_at</inline></reference>(at: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-uri-decode"><inline classes="std std-ref">uri_decode</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-uri-encode"><inline classes="std std-ref">uri_encode</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-validate-filename"><inline classes="std std-ref">validate_filename</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-validate-node-name"><inline classes="std std-ref">validate_node_name</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-xml-escape"><inline classes="std std-ref">xml_escape</inline></reference>(escape_quotes: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-method-xml-unescape"><inline classes="std std-ref">xml_unescape</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id5" names="运算符">
            <title>运算符</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="29"></colspec>
                    <colspec colwidth="109"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-operator-neq-string"><inline classes="std std-ref">operator !=</inline></reference>(right: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-operator-neq-stringname"><inline classes="std std-ref">operator !=</inline></reference>(right: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-operator-mod-variant"><inline classes="std std-ref">operator %</inline></reference>(right: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-operator-sum-string"><inline classes="std std-ref">operator +</inline></reference>(right: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-operator-sum-stringname"><inline classes="std std-ref">operator +</inline></reference>(right: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-operator-lt-string"><inline classes="std std-ref">operator &lt;</inline></reference>(right: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-operator-lte-string"><inline classes="std std-ref">operator &lt;=</inline></reference>(right: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-operator-eq-string"><inline classes="std std-ref">operator ==</inline></reference>(right: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-operator-eq-stringname"><inline classes="std std-ref">operator ==</inline></reference>(right: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-operator-gt-string"><inline classes="std std-ref">operator &gt;</inline></reference>(right: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-operator-gte-string"><inline classes="std std-ref">operator &gt;=</inline></reference>(right: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-string-operator-idx-int"><inline classes="std std-ref">operator []</inline></reference>(index: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id6" names="构造函数说明">
            <title>构造函数说明</title>
            <target refid="class-string-constructor-string"></target>
            <paragraph classes="classref-constructor" ids="class-string-constructor-string" names="class_string_constructor_string"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>String</strong>() <reference internal="True" refid="class-string-constructor-string"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>构造空的 <strong>String</strong>（<literal>""</literal>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>String</strong>(from: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>)</paragraph>
            <paragraph>构造给定 <strong>String</strong> 的副本。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>String</strong>(from: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>)</paragraph>
            <paragraph>从给定的 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> 构造新的 <strong>String</strong>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>String</strong>(from: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
            <paragraph>从给定的 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> 构造新 <strong>String</strong>。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id7" names="方法说明">
            <title>方法说明</title>
            <target refid="class-string-method-begins-with"></target>
            <paragraph classes="classref-method" ids="class-string-method-begins-with" names="class_string_method_begins_with"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>begins_with</strong>(text: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-begins-with"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串以给定的 <literal>text</literal> 开始，则返回 <literal>true</literal>。另见 <reference internal="True" refid="class-string-method-ends-with"><inline classes="std std-ref">ends_with</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-bigrams"></target>
            <paragraph classes="classref-method" ids="class-string-method-bigrams" names="class_string_method_bigrams"><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> <strong>bigrams</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-bigrams"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回包含该字符串的双字母组（连续字母的组合）的数组。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("Get up!".bigrams()) # 输出 ["Ge", "et", "t ", " u", "up", "p!"]</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-bin-to-int"></target>
            <paragraph classes="classref-method" ids="class-string-method-bin-to-int" names="class_string_method_bin_to_int"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>bin_to_int</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-bin-to-int"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将表示二进制数的字符串转换为 <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>。该字符串可以前缀 <literal>"0b"</literal>，负数可以前缀 <literal>-</literal>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">print("101".bin_to_int())   # 输出 5
print("0b101".bin_to_int()) # 输出 5
print("-0b10".bin_to_int()) # 输出 -2</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GD.Print("101".BinToInt());   // 输出 5
GD.Print("0b101".BinToInt()); // 输出 5
GD.Print("-0b10".BinToInt()); // 输出 -2</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-c-escape"></target>
            <paragraph classes="classref-method" ids="class-string-method-c-escape" names="class_string_method_c_escape"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>c_escape</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-c-escape"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串的副本，按照 C 语言标准对特殊字符进行转义。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-c-unescape"></target>
            <paragraph classes="classref-method" ids="class-string-method-c-unescape" names="class_string_method_c_unescape"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>c_unescape</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-c-unescape"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串的副本，转义字符均使用本义代替。支持的转义序列有 <literal>\'</literal>、<literal>\"</literal>、<literal>\\</literal>、<literal>\a</literal>、<literal>\b</literal>、<literal>\f</literal>、<literal>\n</literal>、<literal>\r</literal>、<literal>\t</literal>、<literal>\v</literal>。</paragraph>
            <paragraph><strong>注意：</strong>与 GDScript 解析器不同，这个方法不支持 <literal>\uXXXX</literal> 转义序列。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-capitalize"></target>
            <paragraph classes="classref-method" ids="class-string-method-capitalize" names="class_string_method_capitalize"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>capitalize</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-capitalize"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>改变字符串的外观：用空格代替下划线（<literal>_</literal>），在单词中间的大写字母前添加空格，将所有字母转换为小写，然后将第一个字母和空格后的每个字母转换为大写。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">"move_local_x".capitalize()   # 返回 "Move Local X"
"sceneFile_path".capitalize() # 返回 "Scene File Path"
"2D, FPS, PNG".capitalize()   # 返回 "2d, Fps, Png"</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">"move_local_x".Capitalize();   // 返回 "Move Local X"
"sceneFile_path".Capitalize(); // 返回 "Scene File Path"
"2D, FPS, PNG".Capitalize();   // 返回 "2d, Fps, Png"</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-casecmp-to"></target>
            <paragraph classes="classref-method" ids="class-string-method-casecmp-to" names="class_string_method_casecmp_to"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>casecmp_to</strong>(to: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-casecmp-to"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>与另一个字符串进行比较，区分大小写。小于时返回 <literal>-1</literal>、大于时返回 <literal>1</literal>、等于时返回 <literal>0</literal>。“小于”和“大于”比较的是字符串中的 <reference name="Unicode 码位" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 码位</reference>，大致与字母表顺序一致。</paragraph>
            <paragraph>如果字符串长度不同，这个字符串比 <literal>to</literal> 字符串长时返回 <literal>1</literal>，短时返回 <literal>-1</literal>。请注意空字符串的长度<emphasis>始终</emphasis>为 <literal>0</literal>。</paragraph>
            <paragraph>要从字符串比较中获得 <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> 结果，请改用 <literal>==</literal> 运算符。另请参阅 <reference internal="True" refid="class-string-method-nocasecmp-to"><inline classes="std std-ref">nocasecmp_to</inline></reference>、<reference internal="True" refid="class-string-method-filecasecmp-to"><inline classes="std std-ref">filecasecmp_to</inline></reference> 和 <reference internal="True" refid="class-string-method-naturalcasecmp-to"><inline classes="std std-ref">naturalcasecmp_to</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-chr"></target>
            <paragraph classes="classref-method" ids="class-string-method-chr" names="class_string_method_chr"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>chr</strong>(char: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation> <reference internal="True" refid="class-string-method-chr"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>根据十进制数 <literal>char</literal> 返回单一 Unicode 字符。你可以用 <reference name="unicodelookup.com" refuri="https://unicodelookup.com/">unicodelookup.com</reference> 和 <reference name="unicode.org" refuri="https://www.unicode.org/charts/">unicode.org</reference> 作为参考。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print(String.chr(65))     # 输出 "A"
print(String.chr(129302)) # 输出 "🤖"（机器人脸 Emoji）</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-contains"></target>
            <paragraph classes="classref-method" ids="class-string-method-contains" names="class_string_method_contains"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>contains</strong>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-contains"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串包含 <literal>what</literal>，则返回 <literal>true</literal>。在 GDScript 中对应 <literal>in</literal> 运算符。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">print("Node".contains("de")) # 输出 true
print("team".contains("I"))  # 输出 false
print("I" in "team")         # 输出 false</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GD.Print("Node".Contains("de")); // 输出 true
GD.Print("team".Contains("I"));  // 输出 false</literal_block>
                </div>
            </container>
            <paragraph>如果想要知道 <literal>what</literal> 在该字符串中的位置，请使用 <reference internal="True" refid="class-string-method-find"><inline classes="std std-ref">find</inline></reference>。另见 <reference internal="True" refid="class-string-method-containsn"><inline classes="std std-ref">containsn</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-containsn"></target>
            <paragraph classes="classref-method" ids="class-string-method-containsn" names="class_string_method_containsn"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>containsn</strong>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-containsn"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果<strong>忽略大小写</strong>，字符串包含 <literal>what</literal>，则返回 <literal>true</literal>。</paragraph>
            <paragraph>如果你需要知道 <literal>what</literal> 在字符串中的位置，请使用 <reference internal="True" refid="class-string-method-findn"><inline classes="std std-ref">findn</inline></reference>。另请参阅 <reference internal="True" refid="class-string-method-contains"><inline classes="std std-ref">contains</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-count"></target>
            <paragraph classes="classref-method" ids="class-string-method-count" names="class_string_method_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>count</strong>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0, to: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-count"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回子串 <literal>what</literal> 在 <literal>from</literal> 和 <literal>to</literal> 位置之间出现的次数。如果 <literal>to</literal> 为 0，会在剩余字符串中继续搜索。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-countn"></target>
            <paragraph classes="classref-method" ids="class-string-method-countn" names="class_string_method_countn"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>countn</strong>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0, to: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-countn"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回子串 <literal>what</literal> 在 <literal>from</literal> 和 <literal>to</literal> 位置之间出现的次数，<strong>忽略大小写</strong>。如果 <literal>to</literal> 为 0，会在剩余字符串中继续搜索。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-dedent"></target>
            <paragraph classes="classref-method" ids="class-string-method-dedent" names="class_string_method_dedent"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>dedent</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-dedent"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回删除了缩进（前导制表符和空格）的字符串副本。添加缩进请参阅 <reference internal="True" refid="class-string-method-indent"><inline classes="std std-ref">indent</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-ends-with"></target>
            <paragraph classes="classref-method" ids="class-string-method-ends-with" names="class_string_method_ends_with"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>ends_with</strong>(text: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-ends-with"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串以给定的 <literal>text</literal> 结束，则返回 <literal>true</literal>。另见 <reference internal="True" refid="class-string-method-begins-with"><inline classes="std std-ref">begins_with</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-erase"></target>
            <paragraph classes="classref-method" ids="class-string-method-erase" names="class_string_method_erase"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>erase</strong>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, chars: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 1) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-erase"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回从 <literal>position</literal> 开始擦除 <literal>chars</literal> 个字符后的字符串。如果在指定 <literal>position</literal> 的基础上 <literal>chars</literal> 超过字符串的长度，返回的字符串中擦除的字符数会少于请求的数量。如果 <literal>position</literal> 或 <literal>chars</literal> 为负数，则返回空字符串。如果 <literal>chars</literal> 为 <literal>0</literal> 则返回原字符串，不进行修改。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-filecasecmp-to"></target>
            <paragraph classes="classref-method" ids="class-string-method-filecasecmp-to" names="class_string_method_filecasecmp_to"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>filecasecmp_to</strong>(to: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-filecasecmp-to"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>与 <reference internal="True" refid="class-string-method-naturalcasecmp-to"><inline classes="std std-ref">naturalcasecmp_to</inline></reference> 类似，但优先考虑以句点（<literal>.</literal>）和下划线（<literal>_</literal>）开头的字符串，然后再考虑其他字符。在对文件夹或文件名进行排序时很有用。</paragraph>
            <paragraph>要从字符串比较中获取 <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> 结果，请改用 <literal>==</literal> 运算符。另请参阅 <reference internal="True" refid="class-string-method-filenocasecmp-to"><inline classes="std std-ref">filenocasecmp_to</inline></reference>、<reference internal="True" refid="class-string-method-naturalcasecmp-to"><inline classes="std std-ref">naturalcasecmp_to</inline></reference> 和 <reference internal="True" refid="class-string-method-casecmp-to"><inline classes="std std-ref">casecmp_to</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-filenocasecmp-to"></target>
            <paragraph classes="classref-method" ids="class-string-method-filenocasecmp-to" names="class_string_method_filenocasecmp_to"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>filenocasecmp_to</strong>(to: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-filenocasecmp-to"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>与 <reference internal="True" refid="class-string-method-naturalnocasecmp-to"><inline classes="std std-ref">naturalnocasecmp_to</inline></reference> 类似，但优先考虑以句点（<literal>.</literal>）和下划线（<literal>_</literal>）开头的字符串，然后再考虑其他字符。在对文件夹或文件名进行排序时很有用。</paragraph>
            <paragraph>要从字符串比较中获取 <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> 结果，请改用 <literal>==</literal> 运算符。另请参阅 <reference internal="True" refid="class-string-method-filecasecmp-to"><inline classes="std std-ref">filecasecmp_to</inline></reference>、<reference internal="True" refid="class-string-method-naturalnocasecmp-to"><inline classes="std std-ref">naturalnocasecmp_to</inline></reference> 和 <reference internal="True" refid="class-string-method-nocasecmp-to"><inline classes="std std-ref">nocasecmp_to</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-find"></target>
            <paragraph classes="classref-method" ids="class-string-method-find" names="class_string_method_find"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>find</strong>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-find"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回 <literal>what</literal> 在该字符串中<strong>第一次</strong>出现的索引，如果不存在则返回 <literal>-1</literal>。搜索的起点可以用 <literal>from</literal> 指定，持续到字符串结尾。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">print("Team".find("I")) # 输出 -1

print("Potato".find("t"))    # 输出 2
print("Potato".find("t", 3)) # 输出 4
print("Potato".find("t", 5)) # 输出 -1</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GD.Print("Team".Find("I")); // 输出 -1

GD.Print("Potato".Find("t"));    // 输出 2
GD.Print("Potato".Find("t", 3)); // 输出 4
GD.Print("Potato".Find("t", 5)); // 输出 -1</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>如果你只是想要知道该字符串中是否包含 <literal>what</literal>，请使用 <reference internal="True" refid="class-string-method-contains"><inline classes="std std-ref">contains</inline></reference>。在 GDScript 中，你还可以使用 <literal>in</literal> 运算符。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-findn"></target>
            <paragraph classes="classref-method" ids="class-string-method-findn" names="class_string_method_findn"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>findn</strong>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-findn"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回这个字符串中 <literal>what</literal> <strong>首次</strong>出现的索引，<strong>不区分大小写</strong>，不存在时则为 <literal>-1</literal>。搜索的起点可以用 <literal>from</literal> 指定，终点为该字符串的末尾。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-format"></target>
            <paragraph classes="classref-method" ids="class-string-method-format" names="class_string_method_format"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>format</strong>(values: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, placeholder: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> = "{_}") <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-format"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>通过将所有出现的 <literal>placeholder</literal> 替换为 <literal>values</literal> 的元素来格式化字符串。</paragraph>
            <paragraph><literal>values</literal> 可以是 <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> 或 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>。<literal>placeholder</literal> 中的任何下划线将被预先被替换为对应的键。数组元素使用它们的索引作为键。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># 输出：Waiting for Godot 是 Samuel Beckett 的戏剧，Godot 引擎由此得名。
var use_array_values = "Waiting for {0} 是 {1} 的戏剧，{0} 引擎由此得名。"
print(use_array_values.format(["Godot", "Samuel Beckett"]))

# 输出：第 42 号用户是 Godot。
print("第 {id} 号用户是 {name}。".format({"id": 42, "name": "Godot"}))</literal_block>
            <paragraph>当 <literal>values</literal> 是 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> 时还会执行一些额外的处理。 如果 <literal>placeholder</literal> 不包含下划线，则 <literal>values</literal> 数组的元素将用于按顺序替换出现的占位符；如果 <literal>values</literal> 的元素是另一个 2 元素数组，则它将被解释为键值对。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># 输出：第 42 号用户是 Godot。
print("第 {} 号用户是 {}。".format([42, "Godot"], "{}"))
print("第 {id} 号用户是 {name}。".format([["id", 42], ["name", "Godot"]]))</literal_block>
            <paragraph>另见 <reference internal="True" refuri="../tutorials/scripting/gdscript/gdscript_format_string"><inline classes="doc">GDScript 格式化字符串</inline></reference>教程。</paragraph>
            <paragraph><strong>注意：</strong>占位符的替换不是同时完成的，而是会按照传递的顺序进行替换，因此替换字符串中如果包含其他键，就也会被替换。这是一把双刃剑，不小心可能导致预料之外的结果。如果你不需要在替换字符串中进行替换，请确保替换中不包含占位符，这样才能得到稳定的结果。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("{0} {1}".format(["{1}", "x"]))                       # 输出 "x x"。
print("{0} {1}".format(["x", "{0}"]))                       # 输出 "x {0}"。
print("{foo} {bar}".format({"foo": "{bar}", "bar": "baz"})) # 输出 "baz baz"。
print("{foo} {bar}".format({"bar": "baz", "foo": "{bar}"})) # 输出 "{bar} baz"。</literal_block>
            <paragraph><strong>注意：</strong>在 C# 中推荐改为<reference name="使用“$”插入字符串" refuri="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated">使用“$”插入字符串</reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-get-base-dir"></target>
            <paragraph classes="classref-method" ids="class-string-method-get-base-dir" names="class_string_method_get_base_dir"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_base_dir</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-get-base-dir"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串是有效的文件路径，则返回基础目录名称。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var dir_path = "/path/to/file.txt".get_base_dir() # dir_path 为 "/path/to"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-get-basename"></target>
            <paragraph classes="classref-method" ids="class-string-method-get-basename" names="class_string_method_get_basename"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_basename</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-get-basename"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串是有效的文件路径，则返回完整文件路径，不包括扩展名。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var base = "/path/to/file.txt".get_basename() # base 为 "/path/to/file"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-get-extension"></target>
            <paragraph classes="classref-method" ids="class-string-method-get-extension" names="class_string_method_get_extension"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_extension</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-get-extension"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串是有效的文件名或路径，则返回该文件的扩展名，不含开头的点号（<literal>.</literal>）。否则返回空字符串。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a = "/path/to/file.txt".get_extension() # a 为 "txt"
var b = "cool.txt".get_extension()          # b 为 "txt"
var c = "cool.font.tres".get_extension()    # c 为 "tres"
var d = ".pack1".get_extension()            # d 为 "pack1"

var e = "file.txt.".get_extension()  # e 为 ""
var f = "file.txt..".get_extension() # f 为 ""
var g = "txt".get_extension()        # g 为 ""
var h = "".get_extension()           # h 为 ""</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-get-file"></target>
            <paragraph classes="classref-method" ids="class-string-method-get-file" names="class_string_method_get_file"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_file</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-get-file"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串是有效的文件路径，则返回文件名，包括扩展名。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var file = "/path/to/icon.png".get_file() # file 为 "icon.png"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-get-slice"></target>
            <paragraph classes="classref-method" ids="class-string-method-get-slice" names="class_string_method_get_slice"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_slice</strong>(delimiter: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, slice: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-get-slice"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>使用分隔符 <literal>delimiter</literal> 拆分该字符串，返回索引为 <literal>slice</literal> 的子串。如果字符串中不存在 <literal>delimiter</literal> 则返回原字符串。如果 <literal>slice</literal> 不存在则返回空字符串。</paragraph>
            <paragraph>只需要一个子串时这个方法比 <reference internal="True" refid="class-string-method-split"><inline classes="std std-ref">split</inline></reference> 快。</paragraph>
            <paragraph><strong>示例：</strong></paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("i/am/example/hi".get_slice("/", 2)) # 输出 "example"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-get-slice-count"></target>
            <paragraph classes="classref-method" ids="class-string-method-get-slice-count" names="class_string_method_get_slice_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_slice_count</strong>(delimiter: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-get-slice-count"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回使用给定的分隔符 <literal>delimiter</literal> 拆分该字符串后切片的总数（见 <reference internal="True" refid="class-string-method-split"><inline classes="std std-ref">split</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-get-slicec"></target>
            <paragraph classes="classref-method" ids="class-string-method-get-slicec" names="class_string_method_get_slicec"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_slicec</strong>(delimiter: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, slice: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-get-slicec"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>使用 Unicode 字符码分隔符 <literal>delimiter</literal> 拆分该字符串，返回索引为 <literal>slice</literal> 的子串。如果 <literal>slice</literal> 不存在则返回空字符串。</paragraph>
            <paragraph>只需要一个子串时这个方法比 <reference internal="True" refid="class-string-method-split"><inline classes="std std-ref">split</inline></reference> 快。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-hash"></target>
            <paragraph classes="classref-method" ids="class-string-method-hash" names="class_string_method_hash"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>hash</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-hash"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回代表该字符串内容的 32 位哈希值。</paragraph>
            <paragraph><strong>注意：</strong>由于哈希碰撞的缘故，哈希相同的字符串<emphasis>不一定</emphasis>相同。而相对的是，哈希不同的字符串一定不同。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-hex-decode"></target>
            <paragraph classes="classref-method" ids="class-string-method-hex-decode" names="class_string_method_hex_decode"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>hex_decode</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-hex-decode"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将十六进制字符串解码为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var text = "hello world"
var encoded = text.to_utf8_buffer().hex_encode() # 输出 "68656c6c6f20776f726c64"
print(buf.hex_decode().get_string_from_utf8())</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var text = "hello world";
var encoded = text.ToUtf8Buffer().HexEncode(); // 输出 "68656c6c6f20776f726c64"
GD.Print(buf.HexDecode().GetStringFromUtf8());</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-hex-to-int"></target>
            <paragraph classes="classref-method" ids="class-string-method-hex-to-int" names="class_string_method_hex_to_int"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>hex_to_int</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-hex-to-int"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将表示十六进制数的字符串转换为 <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>。该字符串可以前缀 <literal>"0x"</literal>，负数可以前缀 <literal>-</literal>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">print("0xff".hex_to_int()) # 输出 255
print("ab".hex_to_int())   # 输出 171</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GD.Print("0xff".HexToInt()); // 输出 255
GD.Print("ab".HexToInt());   // 输出 171</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-humanize-size"></target>
            <paragraph classes="classref-method" ids="class-string-method-humanize-size" names="class_string_method_humanize_size"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>humanize_size</strong>(size: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation> <reference internal="True" refid="class-string-method-humanize-size"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将表示字节数的 <literal>size</literal> 转换为人类可读的形式。</paragraph>
            <paragraph>结果使用 <reference name="IEC 词头" refuri="https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%80%B2%E4%BD%8D%E5%89%8D%E7%BD%AE%E8%A9%9E">IEC 词头</reference>，结尾可能是 <literal>"B"</literal>、<literal>"KiB"</literal>、<literal>"MiB"</literal>、<literal>"GiB"</literal>、<literal>"TiB"</literal>、<literal>"PiB"</literal> 或 <literal>"EiB"</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-indent"></target>
            <paragraph classes="classref-method" ids="class-string-method-indent" names="class_string_method_indent"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>indent</strong>(prefix: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-indent"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>使用前缀 <literal>prefix</literal> 将该字符串中的每一行进行缩进。空行不缩进。移除缩进请参阅 <reference internal="True" refid="class-string-method-dedent"><inline classes="std std-ref">dedent</inline></reference>。</paragraph>
            <paragraph>例如，该字符串可以用 <literal>"\t\t"</literal> 缩进两个制表位，用 <literal>"    "</literal> 缩进四个空格。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-insert"></target>
            <paragraph classes="classref-method" ids="class-string-method-insert" names="class_string_method_insert"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>insert</strong>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-insert"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>在该字符串中的 <literal>position</literal> 位置插入 <literal>what</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-is-absolute-path"></target>
            <paragraph classes="classref-method" ids="class-string-method-is-absolute-path" names="class_string_method_is_absolute_path"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_absolute_path</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-is-absolute-path"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串为文件或目录的路径，并且显式指定了起点，则返回 <literal>true</literal>。这个方法与 <reference internal="True" refid="class-string-method-is-relative-path"><inline classes="std std-ref">is_relative_path</inline></reference> 相反。</paragraph>
            <paragraph>包括以 <literal>"res://"</literal>、<literal>"user://"</literal>、<literal>"C:\"</literal>、<literal>"/"</literal> 等开头的路径。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-is-empty"></target>
            <paragraph classes="classref-method" ids="class-string-method-is-empty" names="class_string_method_is_empty"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_empty</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-is-empty"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串的长度为 <literal>0</literal>（<literal>""</literal>），则返回 <literal>true</literal>。另见 <reference internal="True" refid="class-string-method-length"><inline classes="std std-ref">length</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-is-relative-path"></target>
            <paragraph classes="classref-method" ids="class-string-method-is-relative-path" names="class_string_method_is_relative_path"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_relative_path</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-is-relative-path"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串为文件或目录的路径，并且起点依赖于上下文，则返回 <literal>true</literal>。路径可以是从当前目录开始，也可以是从当前 <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference> 开始（如果该字符串是从 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> 得到的），有时候也可以是使用了 <literal>"./"</literal> 前缀。这个方法与 <reference internal="True" refid="class-string-method-is-absolute-path"><inline classes="std std-ref">is_absolute_path</inline></reference> 相反。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-is-subsequence-of"></target>
            <paragraph classes="classref-method" ids="class-string-method-is-subsequence-of" names="class_string_method_is_subsequence_of"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_subsequence_of</strong>(text: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-is-subsequence-of"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果这个字符串中的所有字符都能在 <literal>text</literal> 中按照原始顺序找到，则返回 <literal>true</literal>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var text = "Wow, incredible!"

print("inedible".is_subsequence_of(text)) # 输出 true
print("Word!".is_subsequence_of(text))    # 输出 true
print("Window".is_subsequence_of(text))   # 输出 false
print("".is_subsequence_of(text))         # 输出 true</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-is-subsequence-ofn"></target>
            <paragraph classes="classref-method" ids="class-string-method-is-subsequence-ofn" names="class_string_method_is_subsequence_ofn"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_subsequence_ofn</strong>(text: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-is-subsequence-ofn"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果这个字符串中的所有字符都能在 <literal>text</literal> 中按照原始顺序找到，<strong>忽略大小写</strong>，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-is-valid-filename"></target>
            <paragraph classes="classref-method" ids="class-string-method-is-valid-filename" names="class_string_method_is_valid_filename"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid_filename</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-is-valid-filename"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串不包含文件名中不允许的字符，则返回 <literal>true</literal>（不允许的字符有：<literal>:</literal> <literal>/</literal> <literal>\</literal> <literal>?</literal> <literal>*</literal> <literal>"</literal> <literal>|</literal> <literal>%</literal> <literal>&lt;</literal> <literal>&gt;</literal>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-is-valid-float"></target>
            <paragraph classes="classref-method" ids="class-string-method-is-valid-float" names="class_string_method_is_valid_float"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid_float</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-is-valid-float"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串代表有效的浮点数，则返回 <literal>true</literal>。浮点数只能包含数字、一个小数点（<literal>.</literal>）以及指数字符（<literal>e</literal>）。还可以前缀正号（<literal>+</literal>）或负号（<literal>-</literal>）。有效的整数同时也是有效的浮点数（见 <reference internal="True" refid="class-string-method-is-valid-int"><inline classes="std std-ref">is_valid_int</inline></reference>）。另见 <reference internal="True" refid="class-string-method-to-float"><inline classes="std std-ref">to_float</inline></reference>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("1.7".is_valid_float())   # 输出 true
print("24".is_valid_float())    # 输出 true
print("7e3".is_valid_float())   # 输出 true
print("Hello".is_valid_float()) # 输出 false</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-is-valid-hex-number"></target>
            <paragraph classes="classref-method" ids="class-string-method-is-valid-hex-number" names="class_string_method_is_valid_hex_number"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid_hex_number</strong>(with_prefix: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-is-valid-hex-number"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串代表有效的十六进制数，则返回 <literal>true</literal>。有效的十六进制数只能包含数字或字母 <literal>A</literal> 到 <literal>F</literal>（大小写均可），还可以前缀正号（<literal>+</literal>）或负号（<literal>-</literal>）。</paragraph>
            <paragraph>如果 <literal>with_prefix</literal> 为 <literal>true</literal>，则十六进制数需要有 <literal>"0x"</literal> 前缀才算有效。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("A08E".is_valid_hex_number())    # 输出 true
print("-AbCdEf".is_valid_hex_number()) # 输出 true
print("2.5".is_valid_hex_number())     # 输出 false

print("0xDEADC0DE".is_valid_hex_number(true)) # 输出 true</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-is-valid-html-color"></target>
            <paragraph classes="classref-method" ids="class-string-method-is-valid-html-color" names="class_string_method_is_valid_html_color"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid_html_color</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-is-valid-html-color"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串是有效的十六进制 HTML 颜色标记，则返回 <literal>true</literal>。该字符串必须为 3 位、4 位、6 位或 8 位字符的十六进制值（见 <reference internal="True" refid="class-string-method-is-valid-hex-number"><inline classes="std std-ref">is_valid_hex_number</inline></reference>），也可以带有井号前缀（<literal>#</literal>）。名称、<literal>hsl()</literal> 等其他 HTML 颜色标记法无效。另见 <reference internal="True" refuri="class_color#class-color-method-html"><inline classes="std std-ref">Color.html</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-is-valid-identifier"></target>
            <paragraph classes="classref-method" ids="class-string-method-is-valid-identifier" names="class_string_method_is_valid_identifier"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid_identifier</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-is-valid-identifier"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串为有效的标识符，则返回 <literal>true</literal>。有效的标识符仅可以包含字母、数字和下划线（<literal>_</literal>），第一个字符不能为数字。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("node_2d".is_valid_identifier())    # 输出 true
print("TYPE_FLOAT".is_valid_identifier()) # 输出 true
print("1st_method".is_valid_identifier()) # 输出 false
print("MyMethod#2".is_valid_identifier()) # 输出 false</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-is-valid-int"></target>
            <paragraph classes="classref-method" ids="class-string-method-is-valid-int" names="class_string_method_is_valid_int"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid_int</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-is-valid-int"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串代表有效的整数，则返回 <literal>true</literal>。有效的整数仅可以包含数字，还可以前缀正号（<literal>+</literal>）或负号（<literal>-</literal>）。另见 <reference internal="True" refid="class-string-method-to-int"><inline classes="std std-ref">to_int</inline></reference>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("7".is_valid_int())    # 输出 true
print("1.65".is_valid_int()) # 输出 false
print("Hi".is_valid_int())   # 输出 false
print("+3".is_valid_int())   # 输出 true
print("-12".is_valid_int())  # 输出 true</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-is-valid-ip-address"></target>
            <paragraph classes="classref-method" ids="class-string-method-is-valid-ip-address" names="class_string_method_is_valid_ip_address"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid_ip_address</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-is-valid-ip-address"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串表示格式正确的 IPv4 或 IPv6 地址，则返回 <literal>true</literal>。这个方法认为 <literal>0.0.0.0</literal>、<literal>"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"</literal> 等<reference name="保留 IP 地址" refuri="https://zh.wikipedia.org/wiki/%E4%BF%9D%E7%95%99IP%E5%9C%B0%E5%9D%80">保留 IP 地址</reference>是有效的。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-join"></target>
            <paragraph classes="classref-method" ids="class-string-method-join" names="class_string_method_join"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>join</strong>(parts: <reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-join"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回将 <literal>parts</literal> 中的元素连接组成的字符串，元素间使用调用该方法的字符串进行分隔。该方法和 <reference internal="True" refid="class-string-method-split"><inline classes="std std-ref">split</inline></reference> 相反。</paragraph>
            <paragraph><strong>示例：</strong></paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var fruits = ["Apple", "Orange", "Pear", "Kiwi"]

print(", ".join(fruits))  # 输出 "Apple, Orange, Pear, Kiwi"
print("---".join(fruits)) # 输出 "Apple---Orange---Pear---Kiwi"</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var fruits = new string[] {"Apple", "Orange", "Pear", "Kiwi"};

// 这个方法在 C# 中是静态的。
GD.Print(string.Join(", ", fruits));   // 输出 "Apple, Orange, Pear, Kiwi"
GD.Print(string.Join("---", fruits)); // 输出 "Apple---Orange---Pear---Kiwi"</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-json-escape"></target>
            <paragraph classes="classref-method" ids="class-string-method-json-escape" names="class_string_method_json_escape"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>json_escape</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-json-escape"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串的副本，使用 JSON 标准对特殊字符进行转义。因为与 C 标准非常类似，所以需要时可以用 <reference internal="True" refid="class-string-method-c-unescape"><inline classes="std std-ref">c_unescape</inline></reference> 取消转义。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-left"></target>
            <paragraph classes="classref-method" ids="class-string-method-left" names="class_string_method_left"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>left</strong>(length: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-left"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串开头的前 <literal>length</literal> 个字符。如果 <literal>length</literal> 为负，则会从该字符串的末尾剥离最后 <literal>length</literal> 个字符。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("Hello World!".left(3))  # 输出 "Hel"
print("Hello World!".left(-4)) # 输出 "Hello Wo"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-length"></target>
            <paragraph classes="classref-method" ids="class-string-method-length" names="class_string_method_length"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>length</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-length"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串中的字符数。空字符串（<literal>""</literal>）始终返回 <literal>0</literal>。另见 <reference internal="True" refid="class-string-method-is-empty"><inline classes="std std-ref">is_empty</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-lpad"></target>
            <paragraph classes="classref-method" ids="class-string-method-lpad" names="class_string_method_lpad"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>lpad</strong>(min_length: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, character: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> = " ") <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-lpad"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>必要时在该字符串的左侧添加若干 <literal>character</literal> 字符，使其长度至少为 <literal>min_length</literal>。另见 <reference internal="True" refid="class-string-method-rpad"><inline classes="std std-ref">rpad</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-lstrip"></target>
            <paragraph classes="classref-method" ids="class-string-method-lstrip" names="class_string_method_lstrip"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>lstrip</strong>(chars: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-lstrip"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>从该字符串的开头移除 <literal>chars</literal> 中定义的字符。另见 <reference internal="True" refid="class-string-method-rstrip"><inline classes="std std-ref">rstrip</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong><literal>chars</literal> 不是前缀。如果要移除前缀而不是一组字符，请使用 <reference internal="True" refid="class-string-method-trim-prefix"><inline classes="std std-ref">trim_prefix</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-match"></target>
            <paragraph classes="classref-method" ids="class-string-method-match" names="class_string_method_match"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>match</strong>(expr: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-match"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>进行简单的表达式匹配（也叫“通配”），<literal>*</literal> 匹配零个或多个任意字符，<literal>?</literal> 匹配除英文句号外的任意字符（<literal>.</literal>）。使用空字符串或空表达式时始终为 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-matchn"></target>
            <paragraph classes="classref-method" ids="class-string-method-matchn" names="class_string_method_matchn"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>matchn</strong>(expr: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-matchn"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>进行简单的<strong>大小写不敏感</strong>表达式匹配（也叫“通配”），<literal>*</literal> 匹配零个或多个任意字符，<literal>?</literal> 匹配除英文句号外的任意字符（<literal>.</literal>）。使用空字符串或空表达式时始终为 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-md5-buffer"></target>
            <paragraph classes="classref-method" ids="class-string-method-md5-buffer" names="class_string_method_md5_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>md5_buffer</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-md5-buffer"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串的 <reference name="MD5 哈希" refuri="https://zh.wikipedia.org/wiki/MD5">MD5 哈希</reference>，类型为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-md5-text"></target>
            <paragraph classes="classref-method" ids="class-string-method-md5-text" names="class_string_method_md5_text"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>md5_text</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-md5-text"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串的 <reference name="MD5 哈希" refuri="https://zh.wikipedia.org/wiki/MD5">MD5 哈希</reference>，类型 <strong>String</strong>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-naturalcasecmp-to"></target>
            <paragraph classes="classref-method" ids="class-string-method-naturalcasecmp-to" names="class_string_method_naturalcasecmp_to"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>naturalcasecmp_to</strong>(to: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-naturalcasecmp-to"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>与另一个字符串进行<strong>不区分大小写</strong>的<emphasis>自然顺序</emphasis>比较。小于时返回 <literal>-1</literal>、大于时返回 <literal>1</literal>、等于时返回 <literal>0</literal>。“小于”和“大于”比较的是字符串中的 <reference name="Unicode 码位" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 码位</reference>，大致与字母表顺序一致。内部实现时，会将小写字符转换为大写后进行比较。</paragraph>
            <paragraph>使用自然顺序进行排序时，会和常见预期一样将连续的数字进行组合，而不是一个个数字进行比较。排序后的数列为 <literal>["1", "2", "3", ...]</literal> 而不是 <literal>["1", "10", "2", "3", ...]</literal>。</paragraph>
            <paragraph>如果字符串长度不同，这个字符串比 <literal>to</literal> 字符串长时返回 <literal>1</literal>，短时返回 <literal>-1</literal>。请注意空字符串的长度<emphasis>始终</emphasis>为 <literal>0</literal>。</paragraph>
            <paragraph>要从字符串比较中获得 <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> 结果，请改用 <literal>==</literal> 运算符。另请参阅 <reference internal="True" refid="class-string-method-naturalnocasecmp-to"><inline classes="std std-ref">naturalnocasecmp_to</inline></reference>、<reference internal="True" refid="class-string-method-filecasecmp-to"><inline classes="std std-ref">filecasecmp_to</inline></reference> 和 <reference internal="True" refid="class-string-method-nocasecmp-to"><inline classes="std std-ref">nocasecmp_to</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-naturalnocasecmp-to"></target>
            <paragraph classes="classref-method" ids="class-string-method-naturalnocasecmp-to" names="class_string_method_naturalnocasecmp_to"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>naturalnocasecmp_to</strong>(to: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-naturalnocasecmp-to"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>与另一个字符串进行<strong>不区分大小写</strong>的<emphasis>自然顺序</emphasis>比较。小于时返回 <literal>-1</literal>、大于时返回 <literal>1</literal>、等于时返回 <literal>0</literal>。“小于”和“大于”比较的是字符串中的 <reference name="Unicode 码位" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 码位</reference>，大致与字母表顺序一致。内部实现时，会将小写字符转换为大写后进行比较。</paragraph>
            <paragraph>使用自然顺序进行排序时，会和常见预期一样将连续的数字进行组合，而不是一个个数字进行比较。排序后的数列为 <literal>["1", "2", "3", ...]</literal> 而不是 <literal>["1", "10", "2", "3", ...]</literal>。</paragraph>
            <paragraph>如果字符串长度不同，这个字符串比 <literal>to</literal> 字符串长时返回 <literal>1</literal>，短时返回 <literal>-1</literal>。请注意空字符串的长度<emphasis>始终</emphasis>为 <literal>0</literal>。</paragraph>
            <paragraph>要从字符串比较中获得 <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> 结果，请改用 <literal>==</literal> 运算符。另请参阅 <reference internal="True" refid="class-string-method-naturalcasecmp-to"><inline classes="std std-ref">naturalcasecmp_to</inline></reference>、<reference internal="True" refid="class-string-method-filenocasecmp-to"><inline classes="std std-ref">filenocasecmp_to</inline></reference> 和 <reference internal="True" refid="class-string-method-casecmp-to"><inline classes="std std-ref">casecmp_to</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-nocasecmp-to"></target>
            <paragraph classes="classref-method" ids="class-string-method-nocasecmp-to" names="class_string_method_nocasecmp_to"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>nocasecmp_to</strong>(to: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-nocasecmp-to"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>与另一个字符串进行<strong>不区分大小写</strong>的比较。小于时返回 <literal>-1</literal>、大于时返回 <literal>1</literal>、等于时返回 <literal>0</literal>。“小于”和“大于”比较的是字符串中的 <reference name="Unicode 码位" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 码位</reference>，大致与字母表顺序一致。内部实现时，会将小写字符转换为大写后进行比较。</paragraph>
            <paragraph>如果字符串长度不同，这个字符串比 <literal>to</literal> 字符串长时返回 <literal>1</literal>，短时返回 <literal>-1</literal>。请注意空字符串的长度<emphasis>始终</emphasis>为 <literal>0</literal>。</paragraph>
            <paragraph>要从字符串比较中获得 <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> 结果，请改用 <literal>==</literal> 运算符。另请参阅 <reference internal="True" refid="class-string-method-casecmp-to"><inline classes="std std-ref">casecmp_to</inline></reference>、<reference internal="True" refid="class-string-method-filenocasecmp-to"><inline classes="std std-ref">filenocasecmp_to</inline></reference> 和 <reference internal="True" refid="class-string-method-naturalnocasecmp-to"><inline classes="std std-ref">naturalnocasecmp_to</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-num"></target>
            <paragraph classes="classref-method" ids="class-string-method-num" names="class_string_method_num"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>num</strong>(number: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>, decimals: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = -1) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation> <reference internal="True" refid="class-string-method-num"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将 <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> 转换为十进制小数的字符串表示，小数点位数由 <literal>decimals</literal> 指定。</paragraph>
            <paragraph>如果 <literal>decimals</literal> 为默认的 <literal>-1</literal>，该字符串表示可能最多只有 14 位有效数字，小数点前的数字优先于小数点后的数字。</paragraph>
            <paragraph>该字符串中不包含后缀的零。最后一位数字会四舍五入，而不是截断。</paragraph>
            <paragraph><strong>示例：</strong></paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">String.num(3.141593)     # 返回 "3.141593"
String.num(3.141593, 3)  # 返回 "3.142"
String.num(3.14159300)   # 返回 "3.141593"

# 此处的最后一位数字会进位，
# 数字位数会减少，因为后缀的零会被移除：
String.num(42.129999, 5) # 返回 "42.13"

# 如果没有指定 `decimals`，最大有效位数为 14：
String.num(-0.0000012345432123454321)     # 返回 "-0.00000123454321"
String.num(-10000.0000012345432123454321) # 返回 "-10000.0000012345"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-num-int64"></target>
            <paragraph classes="classref-method" ids="class-string-method-num-int64" names="class_string_method_num_int64"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>num_int64</strong>(number: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, base: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 10, capitalize_hex: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation> <reference internal="True" refid="class-string-method-num-int64"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将给定的数字 <literal>number</literal> 转换为字符串表示，进位制由 <literal>base</literal> 给定。</paragraph>
            <paragraph>默认情况下 <literal>base</literal> 为十进制（<literal>10</literal>）。编程中常见的进位制还有二进制（<literal>2</literal>）、<reference name="八进制" refuri="https://zh.wikipedia.org/wiki/%E5%85%AB%E8%BF%9B%E5%88%B6">八进制</reference>（<literal>8</literal>）、十六进制（<literal>16</literal>）。</paragraph>
            <paragraph>如果 <literal>capitalize_hex</literal> 为 <literal>true</literal>，比 9 大的数位会大写。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-num-scientific"></target>
            <paragraph classes="classref-method" ids="class-string-method-num-scientific" names="class_string_method_num_scientific"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>num_scientific</strong>(number: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation> <reference internal="True" refid="class-string-method-num-scientific"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将给定的数字 <literal>number</literal> 转换为字符串表示，使用科学记数法。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var n = -5.2e8
print(n)                        # 输出 -520000000
print(String.num_scientific(n)) # 输出 -5.2e+08</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// 这个方法没有在 C# 中实现。
// 请在 `string.ToString()` 中使用 "e" 来实现类似的结果。
var n = -5.2e8f;
GD.Print(n);                // 输出 -520000000
GD.Print(n.ToString("e1")); // 输出 -5.2e+008</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>这个方法没有在 C# 中实现。要实现类似的效果，见 C# 的<reference name="标准数字格式字符串" refuri="https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings">标准数字格式字符串</reference></paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-num-uint64"></target>
            <paragraph classes="classref-method" ids="class-string-method-num-uint64" names="class_string_method_num_uint64"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>num_uint64</strong>(number: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, base: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 10, capitalize_hex: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation> <reference internal="True" refid="class-string-method-num-uint64"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将给定的无符号 <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> 转换为字符串表示，进位制由 <literal>base</literal> 给定。</paragraph>
            <paragraph>默认情况下 <literal>base</literal> 为十进制（<literal>10</literal>）。编程中常见的进位制还有二进制（<literal>2</literal>）、<reference name="八进制" refuri="https://zh.wikipedia.org/wiki/%E5%85%AB%E8%BF%9B%E5%88%B6">八进制</reference>（<literal>8</literal>）、十六进制（<literal>16</literal>）。</paragraph>
            <paragraph>如果 <literal>capitalize_hex</literal> 为 <literal>true</literal>，比 9 大的数位会大写。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-pad-decimals"></target>
            <paragraph classes="classref-method" ids="class-string-method-pad-decimals" names="class_string_method_pad_decimals"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>pad_decimals</strong>(digits: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-pad-decimals"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>格式化表示数字的字符串，使其小数点<emphasis>后</emphasis>的位数为 <literal>digits</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-pad-zeros"></target>
            <paragraph classes="classref-method" ids="class-string-method-pad-zeros" names="class_string_method_pad_zeros"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>pad_zeros</strong>(digits: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-pad-zeros"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>格式化表示数字的字符串，使其小数点<emphasis>前</emphasis>的位数为 <literal>digits</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-path-join"></target>
            <paragraph classes="classref-method" ids="class-string-method-path-join" names="class_string_method_path_join"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>path_join</strong>(file: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-path-join"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将 <literal>file</literal> 作为子路径连接到该字符串的末尾，必要时会添加 <literal>/</literal>。</paragraph>
            <paragraph><strong>示例：</strong><literal>"this/is".path_join("path") == "this/is/path"</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-repeat"></target>
            <paragraph classes="classref-method" ids="class-string-method-repeat" names="class_string_method_repeat"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>repeat</strong>(count: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-repeat"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将该字符串重复若干次。次数 <literal>count</literal> 需要大于<literal>0</literal> 。否则返回空字符串。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-replace"></target>
            <paragraph classes="classref-method" ids="class-string-method-replace" names="class_string_method_replace"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>replace</strong>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, forwhat: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-replace"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将该字符串中出现的所有 <literal>what</literal> 都替换为给定的 <literal>forwhat</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-replacen"></target>
            <paragraph classes="classref-method" ids="class-string-method-replacen" names="class_string_method_replacen"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>replacen</strong>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, forwhat: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-replacen"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将该字符串中出现的所有 <literal>what</literal> 都替换为给定的 <literal>forwhat</literal>，<strong>大小写不敏感</strong>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-reverse"></target>
            <paragraph classes="classref-method" ids="class-string-method-reverse" names="class_string_method_reverse"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>reverse</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-reverse"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串的逆序的副本。该操作适用于 Unicode 代码点，而不是代码点序列，并且可能会破坏复合字母或表情符号等内容。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-rfind"></target>
            <paragraph classes="classref-method" ids="class-string-method-rfind" names="class_string_method_rfind"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>rfind</strong>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = -1) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-rfind"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回这个字符串中 <literal>what</literal> <strong>最后一次</strong>出现时的索引，不存在时则为 <literal>-1</literal>。搜索的起点可以用 <literal>from</literal> 指定，终点为该字符串的末尾。这个方法与 <reference internal="True" refid="class-string-method-find"><inline classes="std std-ref">find</inline></reference> 相对。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-rfindn"></target>
            <paragraph classes="classref-method" ids="class-string-method-rfindn" names="class_string_method_rfindn"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>rfindn</strong>(what: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = -1) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-rfindn"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回这个字符串中 <literal>what</literal> <strong>最后一次</strong>出现时的索引，<strong>不区分大小写</strong>，不存在时则为 <literal>-1</literal>。搜索的起点可以用 <literal>from</literal> 指定，终点为该字符串的末尾。这个方法与 <reference internal="True" refid="class-string-method-findn"><inline classes="std std-ref">findn</inline></reference> 相对。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-right"></target>
            <paragraph classes="classref-method" ids="class-string-method-right" names="class_string_method_right"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>right</strong>(length: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-right"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串末尾的最后 <literal>length</literal> 个字符。如果 <literal>length</literal> 为负，则会从该字符串的开头剥离前 <literal>length</literal> 个字符。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("Hello World!".right(3))  # 输出 "ld!"
print("Hello World!".right(-4)) # 输出 "o World!"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-rpad"></target>
            <paragraph classes="classref-method" ids="class-string-method-rpad" names="class_string_method_rpad"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>rpad</strong>(min_length: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, character: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> = " ") <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-rpad"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>必要时在该字符串的右侧添加若干 <literal>character</literal> 字符，使其长度至少为 <literal>min_length</literal>。另见 <reference internal="True" refid="class-string-method-lpad"><inline classes="std std-ref">lpad</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-rsplit"></target>
            <paragraph classes="classref-method" ids="class-string-method-rsplit" names="class_string_method_rsplit"><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> <strong>rsplit</strong>(delimiter: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> = "", allow_empty: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true, maxsplit: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-rsplit"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>使用分隔符 <literal>delimiter</literal> 将该字符串从末尾开始进行拆分，返回子字符串数组。返回的数组中，每部分的出现顺序与它们在原字符串中的出现顺序一致。如果 <literal>delimiter</literal> 为空，则子串为单个字符。</paragraph>
            <paragraph>如果 <literal>allow_empty</literal> 为 <literal>false</literal>，数组中会排除相邻分隔符之间的空字符串。</paragraph>
            <paragraph>如果 <literal>maxsplit</literal> 大于 <literal>0</literal>，则拆分次数不能超过 <literal>maxsplit</literal>。默认拆分整个字符串，基本与 <reference internal="True" refid="class-string-method-split"><inline classes="std std-ref">split</inline></reference> 一致。</paragraph>
            <paragraph><strong>示例：</strong></paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var some_string = "One,Two,Three,Four"
var some_array = some_string.rsplit(",", true, 1)

print(some_array.size()) # 输出 2
print(some_array[0])     # 输出 "One,Two,Three"
print(some_array[1])     # 输出 "Four"</literal_block>
                </div>
                <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// C# 中没有 String.RSplit() 方法。</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-rstrip"></target>
            <paragraph classes="classref-method" ids="class-string-method-rstrip" names="class_string_method_rstrip"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>rstrip</strong>(chars: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-rstrip"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>从该字符串的结尾移除 <literal>chars</literal> 中定义的字符。另见 <reference internal="True" refid="class-string-method-rstrip"><inline classes="std std-ref">rstrip</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong><literal>chars</literal> 不是后缀。如果要移除后缀而不是一组字符，请使用 <reference internal="True" refid="class-string-method-trim-suffix"><inline classes="std std-ref">trim_suffix</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-sha1-buffer"></target>
            <paragraph classes="classref-method" ids="class-string-method-sha1-buffer" names="class_string_method_sha1_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>sha1_buffer</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-sha1-buffer"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串的 <reference name="SHA-1" refuri="https://zh.wikipedia.org/wiki/SHA-1">SHA-1</reference> 哈希，类型为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-sha1-text"></target>
            <paragraph classes="classref-method" ids="class-string-method-sha1-text" names="class_string_method_sha1_text"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>sha1_text</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-sha1-text"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串的 <reference name="SHA-1" refuri="https://zh.wikipedia.org/wiki/SHA-1">SHA-1</reference> 哈希，类型为 <strong>String</strong>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-sha256-buffer"></target>
            <paragraph classes="classref-method" ids="class-string-method-sha256-buffer" names="class_string_method_sha256_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>sha256_buffer</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-sha256-buffer"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串的 <reference name="SHA-256" refuri="https://zh.wikipedia.org/wiki/SHA-2">SHA-256</reference> 哈希，类型为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-sha256-text"></target>
            <paragraph classes="classref-method" ids="class-string-method-sha256-text" names="class_string_method_sha256_text"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>sha256_text</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-sha256-text"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串的 <reference name="SHA-256" refuri="https://zh.wikipedia.org/wiki/SHA-2">SHA-256</reference> 哈希，类型为 <strong>String</strong>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-similarity"></target>
            <paragraph classes="classref-method" ids="class-string-method-similarity" names="class_string_method_similarity"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>similarity</strong>(text: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-similarity"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串与另一个字符串的相似指数（<reference name="索伦森-戴斯系数" refuri="https://zh.wikipedia.org/wiki/Dice%E7%B3%BB%E6%95%B0">索伦森-戴斯系数</reference>）。结果为 <literal>1.0</literal> 表示完全相似，<literal>0.0</literal> 表示完全不相似。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("ABC123".similarity("ABC123")) # 输出 1.0
print("ABC123".similarity("XYZ456")) # 输出 0.0
print("ABC123".similarity("123ABC")) # 输出 0.8
print("ABC123".similarity("abc123")) # 输出 0.4</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-simplify-path"></target>
            <paragraph classes="classref-method" ids="class-string-method-simplify-path" names="class_string_method_simplify_path"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>simplify_path</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-simplify-path"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该字符串为有效的文件路径，则将其转换为规范路径。规范路径是最短路径，不带 <literal>"./"</literal> 和所有不必要的 <literal>".."</literal> 和 <literal>"/"</literal>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var simple_path = "./path/to///../file".simplify_path()
print(simple_path) # 输出 "path/file"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-split"></target>
            <paragraph classes="classref-method" ids="class-string-method-split" names="class_string_method_split"><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> <strong>split</strong>(delimiter: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> = "", allow_empty: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true, maxsplit: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-split"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>使用分隔符 <literal>delimiter</literal> 将该字符串进行拆分，返回子字符串数组。如果 <literal>delimiter</literal> 为空，则子串为单个字符。这个方法与 <reference internal="True" refid="class-string-method-join"><inline classes="std std-ref">join</inline></reference> 相对。</paragraph>
            <paragraph>如果 <literal>allow_empty</literal> 为 <literal>false</literal>，数组中会排除相邻分隔符之间的空字符串。</paragraph>
            <paragraph>如果 <literal>maxsplit</literal> 大于 <literal>0</literal>，则拆分次数不能超过 <literal>maxsplit</literal>。默认拆分整个字符串。</paragraph>
            <paragraph><strong>示例：</strong></paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var some_array = "One,Two,Three,Four".split(",", true, 2)

print(some_array.size()) # 输出 3
print(some_array[0])     # 输出 "One"
print(some_array[1])     # 输出 "Two"
print(some_array[2])     # 输出 "Three,Four"</literal_block>
                </div>
                <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// C# 的 `Split()` 不支持 `maxsplit` 参数。
var someArray = "One,Two,Three".Split(",");

GD.Print(someArray[0]); // 输出 "One"
GD.Print(someArray[1]); // 输出 "Two"
GD.Print(someArray[2]); // 输出 "Three"</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>如果你只需要数组中的某一个子串，请考虑使用更快的 <reference internal="True" refid="class-string-method-get-slice"><inline classes="std std-ref">get_slice</inline></reference>。如果你需要用更复杂的规则来拆分字符串，请改用 <reference internal="True" refuri="class_regex#class-regex"><inline classes="std std-ref">RegEx</inline></reference> 类。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-split-floats"></target>
            <paragraph classes="classref-method" ids="class-string-method-split-floats" names="class_string_method_split_floats"><reference internal="True" refuri="class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference> <strong>split_floats</strong>(delimiter: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>, allow_empty: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-split-floats"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>使用分隔符 <literal>delimiter</literal> 将该字符串拆分为浮点数，返回 <reference internal="True" refuri="class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference>。</paragraph>
            <paragraph>如果 <literal>allow_empty</literal> 为 <literal>false</literal>，则会排除相邻分隔符之间为空或无法转换为 <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> 的内容。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a = "1,2,4.5".split_floats(",")         # a 为 [1.0, 2.0, 4.5]
var c = "1| ||4.5".split_floats("|")        # c 为 [1.0, 0.0, 0.0, 4.5]
var b = "1| ||4.5".split_floats("|", false) # b 为 [1.0, 4.5]</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-strip-edges"></target>
            <paragraph classes="classref-method" ids="class-string-method-strip-edges" names="class_string_method_strip_edges"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>strip_edges</strong>(left: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true, right: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-strip-edges"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>从该字符串的开头和结尾剥离所有不可打印的字符。其中包括空格、制表符（<literal>\t</literal>）以及换行符（<literal>\n</literal> <literal>\r</literal>）。</paragraph>
            <paragraph>如果 <literal>left</literal> 为 <literal>false</literal>，会忽略该字符串的开头。与此类似，如果 <literal>right</literal> 为 <literal>false</literal>，则会忽略该字符串的结尾。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-strip-escapes"></target>
            <paragraph classes="classref-method" ids="class-string-method-strip-escapes" names="class_string_method_strip_escapes"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>strip_escapes</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-strip-escapes"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>从该字符串中剥离所有转义字符。其中包括 ASCII 表第一页的所有不可打印控制字符（值为 0 到 32），例如制表符（C 中的 <literal>\t</literal>）和换行符（<literal>\n</literal> 和 <literal>]\r</literal>) 字符，但<emphasis>不包括</emphasis>空格。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-substr"></target>
            <paragraph classes="classref-method" ids="class-string-method-substr" names="class_string_method_substr"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>substr</strong>(from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, len: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = -1) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-substr"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串中的某一部分，位置从 <literal>from</literal> 开始，长度为 <literal>len</literal>。如果 <literal>len</literal> 为 <literal>-1</literal>（默认值），将返回开给定位置开始的剩余字符。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-to-ascii-buffer"></target>
            <paragraph classes="classref-method" ids="class-string-method-to-ascii-buffer" names="class_string_method_to_ascii_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>to_ascii_buffer</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-to-ascii-buffer"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将该字符串转换为 <reference name="ASCII" refuri="https://zh.wikipedia.org/wiki/ASCII">ASCII</reference>/Latin-1 编码的 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。这个方法比 <reference internal="True" refid="class-string-method-to-utf8-buffer"><inline classes="std std-ref">to_utf8_buffer</inline></reference> 稍快，但会把不支持的字符都替换为空格。这是 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray-method-get-string-from-ascii"><inline classes="std std-ref">PackedByteArray.get_string_from_ascii</inline></reference> 的逆运算。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-to-camel-case"></target>
            <paragraph classes="classref-method" ids="class-string-method-to-camel-case" names="class_string_method_to_camel_case"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>to_camel_case</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-to-camel-case"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回将该字符串转换为小驼峰命名 <literal>camelCase</literal> 的结果。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-to-float"></target>
            <paragraph classes="classref-method" ids="class-string-method-to-float" names="class_string_method_to_float"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>to_float</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-to-float"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将代表十进制数的字符串转换为 <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>。该方法会在首个非数字字符处停止，除非是首次遇到 <literal>.</literal>（小数点）以及表示指数的 <literal>e</literal>。另见 <reference internal="True" refid="class-string-method-is-valid-float"><inline classes="std std-ref">is_valid_float</inline></reference>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a = "12.35".to_float() # a 为 12.35
var b = "1.2.3".to_float() # b 为 1.2
var c = "12xy3".to_float() # c 为 12.0
var d = "1e3".to_float()   # d 为 1000.0
var e = "Hello!".to_float()  # e 为 0.0</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-to-int"></target>
            <paragraph classes="classref-method" ids="class-string-method-to-int" names="class_string_method_to_int"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>to_int</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-to-int"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将代表整数的字符串转换为 <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>。该方法会删除所有非数字字符，并在遇到 <literal>.</literal> 后停止。另见 <reference internal="True" refid="class-string-method-is-valid-int"><inline classes="std std-ref">is_valid_int</inline></reference>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a = "123".to_int()    # a 为 123
var b = "x1y2z3".to_int() # b 为 123
var c = "-1.2.3".to_int() # c 为 -1
var d = "Hello!".to_int() # d 为 0</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-to-lower"></target>
            <paragraph classes="classref-method" ids="class-string-method-to-lower" names="class_string_method_to_lower"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>to_lower</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-to-lower"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回将该字符串转换为小写 <literal>lowercase</literal> 的结果。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-to-pascal-case"></target>
            <paragraph classes="classref-method" ids="class-string-method-to-pascal-case" names="class_string_method_to_pascal_case"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>to_pascal_case</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-to-pascal-case"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回将该字符串转换为大驼峰命名 <literal>PascalCase</literal> 的结果。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-to-snake-case"></target>
            <paragraph classes="classref-method" ids="class-string-method-to-snake-case" names="class_string_method_to_snake_case"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>to_snake_case</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-to-snake-case"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回将该字符串转换为蛇形命名 <literal>snake_case</literal> 的结果。</paragraph>
            <paragraph><strong>注意：</strong>如果数字之后存在的是<emphasis>单个</emphasis>字符，则不会进行拆分，这是为了保证某些单词的连贯（例如“2D”）。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-10-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-10-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-10-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">"Node2D".to_snake_case()               # 返回 "node_2d"
"2nd place".to_snake_case()            # 返回 "2_nd_place"
"Texture3DAssetFolder".to_snake_case() # 返回 "texture_3d_asset_folder"</literal_block>
                </div>
                <div aria-labelledby="tab-10-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-10-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">"Node2D".ToSnakeCase();               // 返回 "node_2d"
"2nd place".ToSnakeCase();            // 返回 "2_nd_place"
"Texture3DAssetFolder".ToSnakeCase(); // 返回 "texture_3d_asset_folder"</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-to-upper"></target>
            <paragraph classes="classref-method" ids="class-string-method-to-upper" names="class_string_method_to_upper"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>to_upper</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-to-upper"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回将该字符串转换为大写 <literal>UPPERCASE</literal> 的结果。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-to-utf8-buffer"></target>
            <paragraph classes="classref-method" ids="class-string-method-to-utf8-buffer" names="class_string_method_to_utf8_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>to_utf8_buffer</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-to-utf8-buffer"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将该字符串转换为 <reference name="UTF-8" refuri="https://zh.wikipedia.org/wiki/UTF-8">UTF-8</reference> 编码的 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。这个方法比 <reference internal="True" refid="class-string-method-to-ascii-buffer"><inline classes="std std-ref">to_ascii_buffer</inline></reference> 稍慢，但支持所有 UTF-8 字符。大多数情况下请优先使用这个方法。这是 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray-method-get-string-from-utf8"><inline classes="std std-ref">PackedByteArray.get_string_from_utf8</inline></reference> 的逆运算。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-to-utf16-buffer"></target>
            <paragraph classes="classref-method" ids="class-string-method-to-utf16-buffer" names="class_string_method_to_utf16_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>to_utf16_buffer</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-to-utf16-buffer"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将该字符串转换为 <reference name="UTF-16" refuri="https://zh.wikipedia.org/wiki/UTF-16">UTF-16</reference> 编码的 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。这是 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray-method-get-string-from-utf16"><inline classes="std std-ref">PackedByteArray.get_string_from_utf16</inline></reference> 的逆运算。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-to-utf32-buffer"></target>
            <paragraph classes="classref-method" ids="class-string-method-to-utf32-buffer" names="class_string_method_to_utf32_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>to_utf32_buffer</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-to-utf32-buffer"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将该字符串转换为 <reference name="UTF-32" refuri="https://zh.wikipedia.org/wiki/UTF-32">UTF-32</reference> 编码的 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。这是 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray-method-get-string-from-utf32"><inline classes="std std-ref">PackedByteArray.get_string_from_utf32</inline></reference> 的逆运算。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-to-wchar-buffer"></target>
            <paragraph classes="classref-method" ids="class-string-method-to-wchar-buffer" names="class_string_method_to_wchar_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>to_wchar_buffer</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-to-wchar-buffer"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将该字符串转换为 <reference name="宽字符" refuri="https://zh.wikipedia.org/zh-cn/%E5%AF%AC%E5%AD%97%E5%85%83">宽字符</reference>（<literal>wchat_t</literal>，Windows 上为 UTF-16，其他平台上为 UTF-32）编码的 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。这是 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray-method-get-string-from-wchar"><inline classes="std std-ref">PackedByteArray.get_string_from_wchar</inline></reference> 的逆运算。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-trim-prefix"></target>
            <paragraph classes="classref-method" ids="class-string-method-trim-prefix" names="class_string_method_trim_prefix"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>trim_prefix</strong>(prefix: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-trim-prefix"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>移除该字符串开头的 <literal>prefix</literal> 前缀，否则原样返回该字符串。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-trim-suffix"></target>
            <paragraph classes="classref-method" ids="class-string-method-trim-suffix" names="class_string_method_trim_suffix"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>trim_suffix</strong>(suffix: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-trim-suffix"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>移除该字符串末尾的 <literal>suffix</literal> 后缀，否则原样返回该字符串。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-unicode-at"></target>
            <paragraph classes="classref-method" ids="class-string-method-unicode-at" names="class_string_method_unicode_at"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>unicode_at</strong>(at: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-unicode-at"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回位于 <literal>at</literal> 处的字符的代码。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-uri-decode"></target>
            <paragraph classes="classref-method" ids="class-string-method-uri-decode" names="class_string_method_uri_decode"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>uri_decode</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-uri-decode"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将该字符串从 URL 编码格式中解码。该方法的目的是在收到 HTTP 请求时正确解码 URL 中的参数。另见 <reference internal="True" refid="class-string-method-uri-encode"><inline classes="std std-ref">uri_encode</inline></reference>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-11-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-11-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-11-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var url = "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
print(url.uri_decode()) # 输出 "$DOCS_URL/?highlight=Godot Engine:docs"</literal_block>
                </div>
                <div aria-labelledby="tab-11-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-11-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var url = "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
GD.Print(url.URIDecode()) // 输出 "$DOCS_URL/?highlight=Godot Engine:docs"</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-uri-encode"></target>
            <paragraph classes="classref-method" ids="class-string-method-uri-encode" names="class_string_method_uri_encode"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>uri_encode</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-uri-encode"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将该字符串按照对 URL 友好的格式进行编码。该方法的目的是在发送 HTTP 请求时，正确编码 URL 中的参数。另见 <reference internal="True" refid="class-string-method-uri-decode"><inline classes="std std-ref">uri_decode</inline></reference>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-12-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-12-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-12-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-12-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-12-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-12-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var prefix = "$DOCS_URL/?highlight="
var url = prefix + "Godot Engine:docs".uri_encode()

print(url) # 输出 "$DOCS_URL/?highlight=Godot%20Engine%3%docs"</literal_block>
                </div>
                <div aria-labelledby="tab-12-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-12-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var prefix = "$DOCS_URL/?highlight=";
var url = prefix + "Godot Engine:docs".URIEncode();

GD.Print(url); // 输出 "$DOCS_URL/?highlight=Godot%20Engine%3%docs"</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-validate-filename"></target>
            <paragraph classes="classref-method" ids="class-string-method-validate-filename" names="class_string_method_validate_filename"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>validate_filename</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-validate-filename"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串的副本，所有 <reference internal="True" refid="class-string-method-is-valid-filename"><inline classes="std std-ref">is_valid_filename</inline></reference> 中不允许的字符都会被替换为下划线。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-validate-node-name"></target>
            <paragraph classes="classref-method" ids="class-string-method-validate-node-name" names="class_string_method_validate_node_name"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>validate_node_name</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-validate-node-name"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串的副本，所有 <reference internal="True" refuri="class_node#class-node-property-name"><inline classes="std std-ref">Node.name</inline></reference> 中不允许的字符都会被替换为下划线（<literal>.</literal> <literal>:</literal> <literal>@</literal> <literal>/</literal> <literal>"</literal> <literal>%</literal>)）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-xml-escape"></target>
            <paragraph classes="classref-method" ids="class-string-method-xml-escape" names="class_string_method_xml_escape"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>xml_escape</strong>(escape_quotes: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-xml-escape"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串的副本，使用 XML 标准对特殊字符进行转义。如果 <literal>escape_quotes</literal> 为 <literal>true</literal>，则单引号（<literal>'</literal>）和双引号（<literal>"</literal>）字符也会被转义。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-method-xml-unescape"></target>
            <paragraph classes="classref-method" ids="class-string-method-xml-unescape" names="class_string_method_xml_unescape"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>xml_unescape</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-string-method-xml-unescape"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该字符串的副本，转义字符均按照 XML 标准使用本义代替。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id8" names="运算符说明">
            <title>运算符说明</title>
            <target refid="class-string-operator-neq-string"></target>
            <paragraph classes="classref-operator" ids="class-string-operator-neq-string" names="class_string_operator_neq_string"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong>(right: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <reference internal="True" refid="class-string-operator-neq-string"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果两个字符串不以相同的字符序列开头，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-operator-neq-stringname"></target>
            <paragraph classes="classref-operator" ids="class-string-operator-neq-stringname" names="class_string_operator_neq_stringname"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong>(right: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <reference internal="True" refid="class-string-operator-neq-stringname"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该 <strong>String</strong> 与给定的 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> 不等价，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-operator-mod-variant"></target>
            <paragraph classes="classref-operator" ids="class-string-operator-mod-variant" names="class_string_operator_mod_variant"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>operator %</strong>(right: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-string-operator-mod-variant"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>格式化该 <strong>String</strong>，使用若干参数替换占位符。要传递多个参数，<literal>right</literal> 需要为 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("我捉到了 %d 条鱼！" % 2) # 输出 "我捉到了 2 条鱼！"

var my_message = "正在前往 %s，速度为 %2.2f km/h。"
var location = "深谷"
var speed = 40.3485
print(my_message % [location, speed]) # 输出 "正在前往深谷，速度为 40.35 km/h。"</literal_block>
            <paragraph>更多信息见<reference internal="True" refuri="../tutorials/scripting/gdscript/gdscript_format_string"><inline classes="doc">《GDScript 格式字符串》</inline></reference>教程。</paragraph>
            <paragraph><strong>注意：</strong>C# 中没有等价的运算符。见<reference name="如何使用“$”插入字符串" refuri="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated">如何使用“$”插入字符串</reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-operator-sum-string"></target>
            <paragraph classes="classref-operator" ids="class-string-operator-sum-string" names="class_string_operator_sum_string"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>operator +</strong>(right: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <reference internal="True" refid="class-string-operator-sum-string"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将 <literal>right</literal> 追加到该 <strong>String</strong> 的末尾，也称作字符串连接。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-operator-sum-stringname"></target>
            <paragraph classes="classref-operator" ids="class-string-operator-sum-stringname" names="class_string_operator_sum_stringname"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>operator +</strong>(right: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <reference internal="True" refid="class-string-operator-sum-stringname"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将 <literal>right</literal> 追加到该 <strong>String</strong> 的末尾，返回 <strong>String</strong>。也称作字符串连接。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-operator-lt-string"></target>
            <paragraph classes="classref-operator" ids="class-string-operator-lt-string" names="class_string_operator_lt_string"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &lt;</strong>(right: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <reference internal="True" refid="class-string-operator-lt-string"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果左侧的 <strong>String</strong> 比 <literal>right</literal> 靠前，则返回 <literal>true</literal>。使用的是 <reference name="Unicode 顺序" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 顺序</reference>，大致与字母表顺序一致。可用于排序。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-operator-lte-string"></target>
            <paragraph classes="classref-operator" ids="class-string-operator-lte-string" names="class_string_operator_lte_string"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &lt;=</strong>(right: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <reference internal="True" refid="class-string-operator-lte-string"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果左侧的 <strong>String</strong> 比 <literal>right</literal> 靠前，或两者相等，则返回 <literal>true</literal>。使用的是 <reference name="Unicode 顺序" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 顺序</reference>，大致与字母表顺序一致。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-operator-eq-string"></target>
            <paragraph classes="classref-operator" ids="class-string-operator-eq-string" names="class_string_operator_eq_string"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong>(right: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <reference internal="True" refid="class-string-operator-eq-string"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果两个字符串以相同的字符序列开头，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-operator-eq-stringname"></target>
            <paragraph classes="classref-operator" ids="class-string-operator-eq-stringname" names="class_string_operator_eq_stringname"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong>(right: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <reference internal="True" refid="class-string-operator-eq-stringname"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该 <strong>String</strong> 与给定的 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> 等价，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-operator-gt-string"></target>
            <paragraph classes="classref-operator" ids="class-string-operator-gt-string" names="class_string_operator_gt_string"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &gt;</strong>(right: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <reference internal="True" refid="class-string-operator-gt-string"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果左侧的 <strong>String</strong> 比 <literal>right</literal> 靠后，则返回 <literal>true</literal>。使用的是 <reference name="Unicode 顺序" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 顺序</reference>，大致与字母表顺序一致。可用于排序。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-operator-gte-string"></target>
            <paragraph classes="classref-operator" ids="class-string-operator-gte-string" names="class_string_operator_gte_string"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &gt;=</strong>(right: <reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference>) <reference internal="True" refid="class-string-operator-gte-string"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果左侧的 <strong>String</strong> 比 <literal>right</literal> 靠后，或两者相等，则返回 <literal>true</literal>。使用的是 <reference name="Unicode 顺序" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 顺序</reference>，大致与字母表顺序一致。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-string-operator-idx-int"></target>
            <paragraph classes="classref-operator" ids="class-string-operator-idx-int" names="class_string_operator_idx_int"><reference internal="True" refid="class-string"><inline classes="std std-ref">String</inline></reference> <strong>operator []</strong>(index: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-string-operator-idx-int"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回只包含索引为 <literal>index</literal> 的字符的新 <strong>String</strong>。索引从 <literal>0</literal> 开始。如果 <literal>index</literal> 大于等于 <literal>0</literal>，则字符是从该字符串的开头开始获取的。如果 <literal>index</literal> 为负，则从末尾开始获取。越界访问字符串会导致运行时错误，从编辑器中运行时会将项目暂停。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了能接受在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效运算符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列位标志构成位掩码的整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="void"><abbreviation explanation="无返回值。">void</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
