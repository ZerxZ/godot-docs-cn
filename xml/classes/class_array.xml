<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_array.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/master/doc/classes/Array.xml.</comment>
    <target refid="class-array"></target>
    <section ids="array class-array" names="array class_array">
        <title>Array</title>
        <paragraph>一种内置数据结构，包含一系列元素。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>数组数据类型，包含任意类型元素的序列。可以使用从 0 开始的索引号来访问元素。可以使用负的索引号从结尾开始计数（-1 表示倒数第一个元素、-2 表示倒数第二个元素，以此类推）。</paragraph>
            <paragraph><strong>示例：</strong></paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var array = ["One", 2, 3, "Four"]
print(array[0]) # One.
print(array[2]) # 3.
print(array[-1]) # Four.
array[2] = "Three"
print(array[-2]) # Three.</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var array = new Godot.Collections.Array{"One", 2, 3, "Four"};
GD.Print(array[0]); // One.
GD.Print(array[2]); // 3.
GD.Print(array[array.Count - 1]); // Four.
array[2] = "Three";
GD.Print(array[array.Count - 2]); // Three.</literal_block>
                </div>
            </container>
            <paragraph>可以使用 <literal>+</literal> 运算符连接数组：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var array1 = ["One", 2]
var array2 = [3, "Four"]
print(array1 + array2) # ["One", 2, 3, "Four"]</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// C# 数组无法连接，但是 Godot.Collections.Array 可以。
var array1 = new Godot.Collections.Array{"One", 2};
var array2 = new Godot.Collections.Array{3, "Four"};
GD.Print(array1 + array2); // Prints [One, 2, 3, Four]</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>数组始终按引用传递。如果要获取数组的副本，让改动独立于原始数组，请使用 <reference internal="True" refid="class-array-method-duplicate"><inline classes="std std-ref">duplicate</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong><strong>不支持</strong>在遍历数组元素时擦除元素，这样做可能造成预料之外的行为。</paragraph>
            <paragraph><strong>紧缩数组、类型数组、无类型数组：</strong>紧缩数组在遍历和修改时通常比同类型的类型数组要快（例如将 <reference internal="True" refuri="class_packedint64array#class-packedint64array"><inline classes="std std-ref">PackedInt64Array</inline></reference> 和 <literal>Array[int]</literal> 相比）。紧缩数组占据的内存也相对较少。但紧缩数组的缺点是不够灵活，因为没有提供 <reference internal="True" refid="class-array-method-map"><inline classes="std std-ref">map</inline></reference> 之类的便捷方法。相应地，类型数组在遍历和修改时要比无类型数组要快。</paragraph>
            <note>
                <paragraph>通过 C# 使用这个 API 时有显著的不同。详见 <reference internal="True" refuri="../tutorials/scripting/c_sharp/c_sharp_differences#doc-c-sharp-differences"><inline classes="std std-ref">C# API 与 GDScript 的差异</inline></reference>。</paragraph>
            </note>
        </section>
        <section classes="classref-reftable-group" ids="id2" names="构造函数">
            <title>构造函数</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="27"></colspec>
                    <colspec colwidth="205"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(base: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>, type: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, class_name: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, script: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedcolorarray#class-packedcolorarray"><inline classes="std std-ref">PackedColorArray</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedint64array#class-packedint64array"><inline classes="std std-ref">PackedInt64Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedvector4array#class-packedvector4array"><inline classes="std std-ref">PackedVector4Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="37"></colspec>
                    <colspec colwidth="201"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-all"><inline classes="std std-ref">all</inline></reference>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-any"><inline classes="std std-ref">any</inline></reference>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-append"><inline classes="std std-ref">append</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-append-array"><inline classes="std std-ref">append_array</inline></reference>(array: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-assign"><inline classes="std std-ref">assign</inline></reference>(array: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-back"><inline classes="std std-ref">back</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-bsearch"><inline classes="std std-ref">bsearch</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, before: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-bsearch-custom"><inline classes="std std-ref">bsearch_custom</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, func: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, before: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-clear"><inline classes="std std-ref">clear</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-count"><inline classes="std std-ref">count</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-duplicate"><inline classes="std std-ref">duplicate</inline></reference>(deep: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-erase"><inline classes="std std-ref">erase</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-fill"><inline classes="std std-ref">fill</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">filter</inline></reference>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-find"><inline classes="std std-ref">find</inline></reference>(what: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-front"><inline classes="std std-ref">front</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-get-typed-builtin"><inline classes="std std-ref">get_typed_builtin</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-get-typed-class-name"><inline classes="std std-ref">get_typed_class_name</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-get-typed-script"><inline classes="std std-ref">get_typed_script</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-has"><inline classes="std std-ref">has</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-hash"><inline classes="std std-ref">hash</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-insert"><inline classes="std std-ref">insert</inline></reference>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-is-empty"><inline classes="std std-ref">is_empty</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-is-read-only"><inline classes="std std-ref">is_read_only</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-is-same-typed"><inline classes="std std-ref">is_same_typed</inline></reference>(array: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-is-typed"><inline classes="std std-ref">is_typed</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-make-read-only"><inline classes="std std-ref">make_read_only</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-map"><inline classes="std std-ref">map</inline></reference>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-max"><inline classes="std std-ref">max</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-min"><inline classes="std std-ref">min</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-pick-random"><inline classes="std std-ref">pick_random</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-pop-at"><inline classes="std std-ref">pop_at</inline></reference>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-pop-back"><inline classes="std std-ref">pop_back</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-pop-front"><inline classes="std std-ref">pop_front</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-push-back"><inline classes="std std-ref">push_back</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-push-front"><inline classes="std std-ref">push_front</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-reduce"><inline classes="std std-ref">reduce</inline></reference>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, accum: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> = null) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-remove-at"><inline classes="std std-ref">remove_at</inline></reference>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-resize"><inline classes="std std-ref">resize</inline></reference>(size: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-reverse"><inline classes="std std-ref">reverse</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-rfind"><inline classes="std std-ref">rfind</inline></reference>(what: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = -1) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-shuffle"><inline classes="std std-ref">shuffle</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-size"><inline classes="std std-ref">size</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-slice"><inline classes="std std-ref">slice</inline></reference>(begin: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, end: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 2147483647, step: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 1, deep: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-sort"><inline classes="std std-ref">sort</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-sort-custom"><inline classes="std std-ref">sort_custom</inline></reference>(func: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id4" names="操作符">
            <title>操作符</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="31"></colspec>
                    <colspec colwidth="94"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-neq-array"><inline classes="std std-ref">operator !=</inline></reference>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-sum-array"><inline classes="std std-ref">operator +</inline></reference>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-lt-array"><inline classes="std std-ref">operator &lt;</inline></reference>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-lte-array"><inline classes="std std-ref">operator &lt;=</inline></reference>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-eq-array"><inline classes="std std-ref">operator ==</inline></reference>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-gt-array"><inline classes="std std-ref">operator &gt;</inline></reference>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-gte-array"><inline classes="std std-ref">operator &gt;=</inline></reference>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-idx-int"><inline classes="std std-ref">operator []</inline></reference>(index: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id5" names="构造函数说明">
            <title>构造函数说明</title>
            <target refid="class-array-constructor-array"></target>
            <paragraph classes="classref-constructor" ids="class-array-constructor-array" names="class_array_constructor_array"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>() <reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>构造空的 <strong>Array</strong>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(base: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>, type: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, class_name: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, script: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
            <paragraph>从<literal>base</literal>数组创建类型化数组。所有参数都是必需的。</paragraph>
            <paragraph>-<literal>type</literal>是作为<reference internal="True" refuri="class_@globalscope#enum-globalscope-variant-type"><inline classes="std std-ref">Variant.Type</inline></reference>常量的内置类型，例如<reference internal="True" refuri="class_@globalscope#class-globalscope-constant-type-int"><inline classes="std std-ref">@GlobalScope.TYPE_INT</inline></reference>。</paragraph>
            <paragraph>-<literal>class_name</literal>是 <strong>native</strong> 类名，例如<reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>。如果<literal>type</literal>不是<reference internal="True" refuri="class_@globalscope#class-globalscope-constant-type-object"><inline classes="std std-ref">@GlobalScope.TYPE_OBJECT</inline></reference>，则必须是空字符串。</paragraph>
            <paragraph>-<literal>script</literal>是关联的脚本。必须是<reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference>实例或<literal>null</literal>。</paragraph>
            <paragraph>示例：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">class_name MyNode
extends Node

class MyClass:
pass

func _ready():
var a = Array([], TYPE_INT, &amp;"", null) # Array[int]
var b = Array([], TYPE_OBJECT, &amp;"Node", null) # Array[Node]
var c = Array([], TYPE_OBJECT, &amp;"Node", MyNode) # Array[MyNode]
var d = Array([], TYPE_OBJECT, &amp;"RefCounted", MyClass) # Array[MyClass]</literal_block>
            <paragraph>** 注意：<problematic ids="id7" refid="id6">**</problematic>如果你想动态创建类型化数组，但不需要使用它，则此构造函数可能很有用。在GDScript中，你可以使用所需静态类型的临时变量，然后传递它：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _ready():
var a: Array[int] = []
some_func(a)</literal_block>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
            <paragraph>返回与 <literal>from</literal> 相同的数组。如果你需要一个数组的副本，请使用 <reference internal="True" refid="class-array-method-duplicate"><inline classes="std std-ref">duplicate</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedcolorarray#class-packedcolorarray"><inline classes="std std-ref">PackedColorArray</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedcolorarray#class-packedcolorarray"><inline classes="std std-ref">PackedColorArray</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedint64array#class-packedint64array"><inline classes="std std-ref">PackedInt64Array</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedint64array#class-packedint64array"><inline classes="std std-ref">PackedInt64Array</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedvector4array#class-packedvector4array"><inline classes="std std-ref">PackedVector4Array</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedvector4array#class-packedvector4array"><inline classes="std std-ref">PackedVector4Array</inline></reference> 构造一个数组。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id8" names="方法说明">
            <title>方法说明</title>
            <target refid="class-array-method-all"></target>
            <paragraph classes="classref-method" ids="class-array-method-all" names="class_array_method_all"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>all</strong>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-all"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>对数组中的每个元素调用提供的 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>，如果 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> 为数组中的 <emphasis>所有</emphasis> 元素返回 <literal>true</literal>，则返回 <literal>true</literal>。如果 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> 为一个或多个数组元素返回 <literal>false</literal>，则此方法返回 <literal>false</literal>。</paragraph>
            <paragraph>该可调用的方法应采用一个 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> 参数（当前数组元素）并返回一个布尔值。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    print([6, 10, 6].all(greater_than_5))  # 输出 True（3/3 元素评估为 `true`）。
    print([4, 10, 4].all(greater_than_5))  # 输出 False（1/3 元素评估为 `true`）。
    print([4, 4, 4].all(greater_than_5))  # 输出 False（0/3 元素评估为 `true`）。
    print([].all(greater_than_5))  # 输出 True（0/0 元素评估为 `true`）。

    print([6, 10, 6].all(func(number): return number &gt; 5))  # 输出 True。与上面的第一行相同，但使用 lambda 函数。

func greater_than_5(number):
    return number &gt; 5</literal_block>
            <paragraph>另请参见 <reference internal="True" refid="class-array-method-any"><inline classes="std std-ref">any</inline></reference>、<reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">filter</inline></reference>、<reference internal="True" refid="class-array-method-map"><inline classes="std std-ref">map</inline></reference> 和 <reference internal="True" refid="class-array-method-reduce"><inline classes="std std-ref">reduce</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>与依赖 <reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">filter</inline></reference> 返回的数组大小不同，此方法会尽可能早地返回以提高性能（尤其是对于大型数组）。</paragraph>
            <paragraph><strong>注意：</strong>对于空数组，此方法 <reference name="总是" refuri="https://en.wikipedia.org/wiki/Vacuous_truth">总是</reference> 返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-any"></target>
            <paragraph classes="classref-method" ids="class-array-method-any" names="class_array_method_any"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>any</strong>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-any"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>对数组中的每个元素调用提供的 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>，如果 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> 为数组中的* 一个或多个*元素返回 <literal>true</literal>，则返回 <literal>true</literal>。如果 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> 为数组中的所有元素返回 <literal>false</literal>，则此方法返回 <literal>false</literal>。</paragraph>
            <paragraph>可调用体的方法应接受一个 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> 参数（当前数组元素）并返回一个布尔值。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    print([6, 10, 6].any(greater_than_5))  # 输出 True（3 个元素评估为 `true`）。
    print([4, 10, 4].any(greater_than_5))  # 输出 True（1 个元素评估为 `true`）。
    print([4, 4, 4].any(greater_than_5))  # 输出 False（0 个元素评估为 `true`）。
    print([].any(greater_than_5))  # 输出 False（0 个元素评估为 `true`）。

    print([6, 10, 6].any(func(number): return number &gt; 5))  # 输出 True。与上面的第一行相同，但使用 lambda 函数。

func greater_than_5(number):
    return number &gt; 5</literal_block>
            <paragraph>另请参阅 <reference internal="True" refid="class-array-method-all"><inline classes="std std-ref">all</inline></reference>、<reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">filter</inline></reference>、<reference internal="True" refid="class-array-method-map"><inline classes="std std-ref">map</inline></reference> 和 <reference internal="True" refid="class-array-method-reduce"><inline classes="std std-ref">reduce</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>与依赖 <reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">filter</inline></reference> 返回的数组大小不同，此方法会尽可能早地返回以提高性能（尤其是对于大型数组）。</paragraph>
            <paragraph><strong>注意：</strong>对于一个空数组，这个方法总是返回 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-append"></target>
            <paragraph classes="classref-method" ids="class-array-method-append" names="class_array_method_append"><abbreviation explanation="无返回值。">void</abbreviation> <strong>append</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-array-method-append"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>向数组末尾追加一个元素（<reference internal="True" refid="class-array-method-push-back"><inline classes="std std-ref">push_back</inline></reference> 的别名）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-append-array"></target>
            <paragraph classes="classref-method" ids="class-array-method-append-array" names="class_array_method_append_array"><abbreviation explanation="无返回值。">void</abbreviation> <strong>append_array</strong>(array: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-method-append-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>在该数组的末尾追加其他数组。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var array1 = [1, 2, 3]
var array2 = [4, 5, 6]
array1.append_array(array2)
print(array1) # 输出 [1, 2, 3, 4, 5, 6].</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-assign"></target>
            <paragraph classes="classref-method" ids="class-array-method-assign" names="class_array_method_assign"><abbreviation explanation="无返回值。">void</abbreviation> <strong>assign</strong>(array: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-method-assign"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将另一个 <literal>array</literal> 的元素赋值到该数组中。调整数组大小以匹配 <literal>array</literal>。如果数组是有类型的，则执行类型转换。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-back"></target>
            <paragraph classes="classref-method" ids="class-array-method-back" names="class_array_method_back"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>back</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-back"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回数组的最后一个元素。如果数组为空，则打印一个错误并返回 <literal>null</literal>。</paragraph>
            <paragraph><strong>注意：</strong>调用这个函数与写入 <literal>array[-1]</literal> 不一样，如果数组是空的，当从编辑器运行时，按索引访问将暂停项目的执行。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-bsearch"></target>
            <paragraph classes="classref-method" ids="class-array-method-bsearch" names="class_array_method_bsearch"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>bsearch</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, before: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-bsearch"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>使用二分法查找已有值的索引（如果该值尚未存在于数组中，则为保持排序顺序的插入索引）。传递 <literal>before</literal> 说明符是可选的。如果该参数为 <literal>false</literal>，则返回的索引位于数组中该值的所有已有的条目之后。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var array = ["a", "b", "c", "c", "d", "e"]
print(array.bsearch("c", true))  # 输出 2，即第一个匹配元素。
print(array.bsearch("c", false)) # 输出 4，即最后一个匹配元素之后，指向“d”。</literal_block>
            <paragraph><strong>注意：</strong>在未排序的数组上调用 <reference internal="True" refid="class-array-method-bsearch"><inline classes="std std-ref">bsearch</inline></reference> 会产生预料之外的行为。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-bsearch-custom"></target>
            <paragraph classes="classref-method" ids="class-array-method-bsearch-custom" names="class_array_method_bsearch_custom"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>bsearch_custom</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, func: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, before: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-bsearch-custom"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>使用二分法和自定义比较方法查找已有值的索引（如果该值尚未存在于数组中，则为保持排序顺序的插入索引）。传递 <literal>before</literal> 说明符是可选的。如果该参数为 <literal>false</literal>，则返回的索引位于数组中该值的所有已有条目之后。自定义方法接收两个参数（数组中的一个元素和搜索到的值），如果第一个参数小于第二个参数，则必须返回 <literal>true</literal>，否则返回 <literal>false</literal>。</paragraph>
            <paragraph><strong>注意：</strong>自定义方法必须接受任意顺序的两个参数，不应假定第一个参数始终存在于数组中。</paragraph>
            <paragraph><strong>注意：</strong>在未排序的数组上调用 <reference internal="True" refid="class-array-method-bsearch-custom"><inline classes="std std-ref">bsearch_custom</inline></reference> 会产生预料之外的行为。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-clear"></target>
            <paragraph classes="classref-method" ids="class-array-method-clear" names="class_array_method_clear"><abbreviation explanation="无返回值。">void</abbreviation> <strong>clear</strong>() <reference internal="True" refid="class-array-method-clear"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>清空数组。相当于调用 <reference internal="True" refid="class-array-method-resize"><inline classes="std std-ref">resize</inline></reference> 时指定大小为 <literal>0</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-count"></target>
            <paragraph classes="classref-method" ids="class-array-method-count" names="class_array_method_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>count</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-count"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回元素在数组中出现的次数。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-duplicate"></target>
            <paragraph classes="classref-method" ids="class-array-method-duplicate" names="class_array_method_duplicate"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>duplicate</strong>(deep: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-duplicate"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该数组的副本。</paragraph>
            <paragraph><literal>deep</literal> 为 <literal>true</literal> 时会执行深拷贝：所有嵌套数组和字典都将被复制，且不会与原始数组共享。为 <literal>false</literal> 时则进行浅拷贝，并保留对原始嵌套数组和字典的引用，因此修改副本中的子数组或字典，也会影响源数组中引用的子数组或字典。请注意，无论 <literal>deep</literal> 如何设置，任何 <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference> 派生的元素都是浅拷贝的。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-erase"></target>
            <paragraph classes="classref-method" ids="class-array-method-erase" names="class_array_method_erase"><abbreviation explanation="无返回值。">void</abbreviation> <strong>erase</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-array-method-erase"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>从数组中移除第一个匹配的值。如果数组中不存在该值，则什么也不会发生。要通过索引移除元素，请改用 <reference internal="True" refid="class-array-method-remove-at"><inline classes="std std-ref">remove_at</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>这个方法是就地操作的，不返回修改后的数组。</paragraph>
            <paragraph><strong>注意：</strong>在大型数组上，如果移除的元素靠近数组的开头（索引 0），则此方法会较慢。这是因为所有放置在移除元素之后的元素都必须重新索引。</paragraph>
            <paragraph><strong>注意：</strong>在遍历数组时不要移除条目。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-fill"></target>
            <paragraph classes="classref-method" ids="class-array-method-fill" names="class_array_method_fill"><abbreviation explanation="无返回值。">void</abbreviation> <strong>fill</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-array-method-fill"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将该数组中的所有元素都设置为给定的值。通常与 <reference internal="True" refid="class-array-method-resize"><inline classes="std std-ref">resize</inline></reference> 一起使用，用于创建给定大小的数组并对其元素进行初始化：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var array = []
array.resize(10)
array.fill(0) # 将 10 个元素都初始化为 0。</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var array = new Godot.Collections.Array();
array.Resize(10);
array.Fill(0); // 将 10 个元素都初始化为 0。</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>如果 <literal>value</literal> 为引用类型（派生自 <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference>、<strong>Array</strong>、<reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> 等），那么会用同一个对象的引用填充该数组，即不会创建副本。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-filter"></target>
            <paragraph classes="classref-method" ids="class-array-method-filter" names="class_array_method_filter"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>filter</strong>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>在数组中的每个元素上调用提供的 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>，并返回一个新数组，其中包含调用方法后返回值为 <literal>true</literal> 的元素。</paragraph>
            <paragraph>可调用的方法应该采用一个 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> 参数（当前数组元素）并返回一个布尔值。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    print([1, 2, 3].filter(remove_1)) # 打印 [2, 3]。
    print([1, 2, 3].filter(func(number): return number != 1)) # 同上，但使用 lambda 函数。

func remove_1(number):
    return number != 1</literal_block>
            <paragraph>另请参见 <reference internal="True" refid="class-array-method-any"><inline classes="std std-ref">any</inline></reference>、<reference internal="True" refid="class-array-method-all"><inline classes="std std-ref">all</inline></reference>、<reference internal="True" refid="class-array-method-map"><inline classes="std std-ref">map</inline></reference> 和 <reference internal="True" refid="class-array-method-reduce"><inline classes="std std-ref">reduce</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-find"></target>
            <paragraph classes="classref-method" ids="class-array-method-find" names="class_array_method_find"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>find</strong>(what: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-find"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>在数组中搜索值并返回其索引，如果未找到则返回 <literal>-1</literal> 。可选地，可以传递起始搜索索引。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-front"></target>
            <paragraph classes="classref-method" ids="class-array-method-front" names="class_array_method_front"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>front</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-front"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回数组的第一个元素。如果数组为空，则打印错误并返回 <literal>null</literal>。</paragraph>
            <paragraph><strong>注意：</strong>调用这个函数和写 <literal>array[0]</literal> 是不一样的，如果数组为空，从编辑器运行时按索引访问将暂停项目执行。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-get-typed-builtin"></target>
            <paragraph classes="classref-method" ids="class-array-method-get-typed-builtin" names="class_array_method_get_typed_builtin"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_typed_builtin</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-get-typed-builtin"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将类型化数组的内置类型作为 <reference internal="True" refuri="class_@globalscope#enum-globalscope-variant-type"><inline classes="std std-ref">Variant.Type</inline></reference> 常量返回。如果该数组不是类型化的，则返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-type-nil"><inline classes="std std-ref">@GlobalScope.TYPE_NIL</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-get-typed-class-name"></target>
            <paragraph classes="classref-method" ids="class-array-method-get-typed-class-name" names="class_array_method_get_typed_class_name"><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>get_typed_class_name</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-get-typed-class-name"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果内置类型为 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-type-object"><inline classes="std std-ref">@GlobalScope.TYPE_OBJECT</inline></reference>，则返回类型化数组的 <strong>native</strong> 类名。否则，此方法将返回一个空字符串。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-get-typed-script"></target>
            <paragraph classes="classref-method" ids="class-array-method-get-typed-script" names="class_array_method_get_typed_script"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>get_typed_script</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-get-typed-script"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回与此类型化数组关联的脚本。该方法返回 <reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference> 实例或 <literal>null</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-has"></target>
            <paragraph classes="classref-method" ids="class-array-method-has" names="class_array_method_has"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>has</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-has"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该数组包含给定值，则返回 <literal>true</literal>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">print(["inside", 7].has("inside")) # 真
print(["inside", 7].has("outside")) # 假
print(["inside", 7].has(7)) # 真
print(["inside", 7].has("7")) # 假</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var arr = new Godot.Collections.Array { "inside", 7 };
// has 被改名为 Contains
GD.Print(arr.Contains("inside")); // 真
GD.Print(arr.Contains("outside")); // 假
GD.Print(arr.Contains(7)); // 真
GD.Print(arr.Contains("7")); // 假</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>这相当于使用 <literal>in</literal> 运算符，如下所示：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># 将评估为`true`。
if 2 in [2, 4, 6, 8]:
    print("包含！")</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// 由于 C# 中没有关键字“in”，因此必须使用 Contains
var array = new Godot.Collections.Array { 2, 4, 6, 8 };
if (array.Contains(2))
{
    GD.Print("包含！");
}</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-hash"></target>
            <paragraph classes="classref-method" ids="class-array-method-hash" names="class_array_method_hash"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>hash</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-hash"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回代表该数组及其内容的 32 位整数哈希值。</paragraph>
            <paragraph><strong>注意：</strong>内容相同的 <strong>Array</strong> 会得到一致的哈希值。反之则不然。返回一致的哈希值<emphasis>并不</emphasis>意味着数组相等，因为不同的数组可能因为哈希碰撞而得到一致的哈希值。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-insert"></target>
            <paragraph classes="classref-method" ids="class-array-method-insert" names="class_array_method_insert"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>insert</strong>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-array-method-insert"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>在给定的数组位置插入一个新值。位置必须合法，或者是在数组末尾（<literal>pos == size()</literal>）。操作成功时返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-ok"><inline classes="std std-ref">@GlobalScope.OK</inline></reference>，而如果操作失败则返回其他任意一个 <reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> 值。</paragraph>
            <paragraph><strong>注意：</strong>该方法在原地执行，不会返回修改过的数组。</paragraph>
            <paragraph><strong>注意：</strong>在较大的数组中，如果插入值的位置在数组偏前的位置，这个方法的运行速度会比较慢，因为在插入值后面所有的元素都要被重新索引。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-is-empty"></target>
            <paragraph classes="classref-method" ids="class-array-method-is-empty" names="class_array_method_is_empty"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_empty</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-is-empty"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>该数组为空时，返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-is-read-only"></target>
            <paragraph classes="classref-method" ids="class-array-method-is-read-only" names="class_array_method_is_read_only"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_read_only</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-is-read-only"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该数组只读，则返回 <literal>true</literal>。见 <reference internal="True" refid="class-array-method-make-read-only"><inline classes="std std-ref">make_read_only</inline></reference>。如果数组是用 <literal>const</literal> 关键字声明的，则自动只读。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-is-same-typed"></target>
            <paragraph classes="classref-method" ids="class-array-method-is-same-typed" names="class_array_method_is_same_typed"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_same_typed</strong>(array: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-is-same-typed"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该数组的类型与 <literal>array</literal> 相同，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-is-typed"></target>
            <paragraph classes="classref-method" ids="class-array-method-is-typed" names="class_array_method_is_typed"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_typed</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-is-typed"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该数组是类型化的，则返回 <literal>true</literal>。类型化数组只能存储与其关联类型的元素，能够为其 <literal>[]</literal> 运算符提供类型安全支持。类型化数组的方法仍然返回 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-make-read-only"></target>
            <paragraph classes="classref-method" ids="class-array-method-make-read-only" names="class_array_method_make_read_only"><abbreviation explanation="无返回值。">void</abbreviation> <strong>make_read_only</strong>() <reference internal="True" refid="class-array-method-make-read-only"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>使该数组只读，即禁止修改该数组的元素。不适用于嵌套的内容，例如嵌套数组的内容。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-map"></target>
            <paragraph classes="classref-method" ids="class-array-method-map" names="class_array_method_map"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>map</strong>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-map"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>为数组中的每个元素调用提供的 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> 并返回一个新数组，其中填充了该调用方法返回的值。</paragraph>
            <paragraph>可调用的方法应该采用一个 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> 参数（当前数组元素）并且可以返回任意 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    print([1, 2, 3].map(negate)) # 打印 [-1, -2, -3].
    print([1, 2, 3].map(func(number): return -number)) # 同上，但使用 lambda 函数。

func negate(number):
    return -number</literal_block>
            <paragraph>另请参见 <reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">filter</inline></reference>、<reference internal="True" refid="class-array-method-reduce"><inline classes="std std-ref">reduce</inline></reference>、<reference internal="True" refid="class-array-method-any"><inline classes="std std-ref">any</inline></reference> 和 <reference internal="True" refid="class-array-method-all"><inline classes="std std-ref">all</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-max"></target>
            <paragraph classes="classref-method" ids="class-array-method-max" names="class_array_method_max"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>max</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-max"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果数组中包含的所有元素都是可比较的类型，则返回其中的最大值。如果无法比较，则返回 <literal>null</literal>。</paragraph>
            <paragraph>要使用自定义比较器来查找最大值，可以使用 <reference internal="True" refid="class-array-method-reduce"><inline classes="std std-ref">reduce</inline></reference>。这个例子中会比较数组中的每个元素，并返回第一个最大值：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    var arr = [Vector2(0, 1), Vector2(2, 0), Vector2(1, 1), Vector2(1, 0), Vector2(0, 2)]
    # 这个例子中我们比较的是长度。
    print(arr.reduce(func(max, val): return val if is_length_greater(val, max) else max))

func is_length_greater(a, b):
    return a.length() &gt; b.length()</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-min"></target>
            <paragraph classes="classref-method" ids="class-array-method-min" names="class_array_method_min"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>min</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-min"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果数组中包含的所有元素都是可比较的类型，则返回其中的最小值。如果无法比较，则返回 <literal>null</literal>。</paragraph>
            <paragraph>使用自定义比较器的示例见 <reference internal="True" refid="class-array-method-max"><inline classes="std std-ref">max</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-pick-random"></target>
            <paragraph classes="classref-method" ids="class-array-method-pick-random" names="class_array_method_pick_random"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>pick_random</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-pick-random"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>从目标数组中返回一个随机值。如果数组为空，则打印一个错误并返回 <literal>null</literal>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var array: Array[int] = [1, 2, 3, 4]
print(array.pick_random())  # 打印四个数字中的任何一个。</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var array = new Godot.Collections.Array { 1, 2, 3, 4 };
GD.Print(array.PickRandom()); // 打印四个数字中的任何一个。</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-pop-at"></target>
            <paragraph classes="classref-method" ids="class-array-method-pop-at" names="class_array_method_pop_at"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>pop_at</strong>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-array-method-pop-at"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>移除并返回数组中位于 <literal>position</literal> 索引处的元素。如果 <literal>position</literal> 为负数，则认为是相对于该数组末尾的值。如果该数组为空或访问越界，则保持该数组不变并返回 <literal>null</literal>。数组访问越界时会输出错误消息，但如果数组为空时不会。</paragraph>
            <paragraph><strong>注意：</strong>在较大的数组上，这个方法会比 <reference internal="True" refid="class-array-method-pop-back"><inline classes="std std-ref">pop_back</inline></reference> 慢，因为会对移除元素后的数组元素重新进行索引。数组越大，或者移除元素的索引越小，<reference internal="True" refid="class-array-method-pop-at"><inline classes="std std-ref">pop_at</inline></reference> 就越慢。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-pop-back"></target>
            <paragraph classes="classref-method" ids="class-array-method-pop-back" names="class_array_method_pop_back"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>pop_back</strong>() <reference internal="True" refid="class-array-method-pop-back"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>移除并返回数组中的末尾元素。如果数组为空，则返回 <literal>null</literal>，而不打印错误消息。另见<reference internal="True" refid="class-array-method-pop-front"><inline classes="std std-ref">pop_front</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-pop-front"></target>
            <paragraph classes="classref-method" ids="class-array-method-pop-front" names="class_array_method_pop_front"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>pop_front</strong>() <reference internal="True" refid="class-array-method-pop-front"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>移除并返回数组的第一个元素。如果数组是空的，将不会输出任何错误信息并返回 <literal>null</literal>。另请参阅 <reference internal="True" refid="class-array-method-pop-back"><inline classes="std std-ref">pop_back</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>当数组元素很多时，由于 <reference internal="True" refid="class-array-method-pop-front"><inline classes="std std-ref">pop_front</inline></reference> 每次调用时都要重新寻找数组所有元素的索引，所以会比 <reference internal="True" refid="class-array-method-pop-back"><inline classes="std std-ref">pop_back</inline></reference> 慢很多。数组越大，<reference internal="True" refid="class-array-method-pop-front"><inline classes="std std-ref">pop_front</inline></reference> 越慢。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-push-back"></target>
            <paragraph classes="classref-method" ids="class-array-method-push-back" names="class_array_method_push_back"><abbreviation explanation="无返回值。">void</abbreviation> <strong>push_back</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-array-method-push-back"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>在数组的末端追加一个元素。另请参阅 <reference internal="True" refid="class-array-method-push-front"><inline classes="std std-ref">push_front</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-push-front"></target>
            <paragraph classes="classref-method" ids="class-array-method-push-front" names="class_array_method_push_front"><abbreviation explanation="无返回值。">void</abbreviation> <strong>push_front</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-array-method-push-front"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>在数组的开头添加一个元素。另请参阅 <reference internal="True" refid="class-array-method-push-back"><inline classes="std std-ref">push_back</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>在大数组中，这个方法比 <reference internal="True" refid="class-array-method-push-back"><inline classes="std std-ref">push_back</inline></reference> 慢得多，因为每次调用它都会重新索引所有数组的元素。数组越大，<reference internal="True" refid="class-array-method-push-front"><inline classes="std std-ref">push_front</inline></reference> 的速度就越慢。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-reduce"></target>
            <paragraph classes="classref-method" ids="class-array-method-reduce" names="class_array_method_reduce"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>reduce</strong>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, accum: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> = null) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-reduce"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>为数组中的每个元素调用给定的 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> 并将结果累积在 <literal>accum</literal> 中。</paragraph>
            <paragraph>该可调用体的方法接受两个参数：<literal>accum</literal> 的当前值，以及当前的数组元素。如果 <literal>accum</literal> 为 <literal>null</literal>（默认值），则会从第二个元素开始迭代，将第一个元素作为 <literal>accum</literal> 的初始值。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    print([1, 2, 3].reduce(sum, 10)) # 输出 16.
    print([1, 2, 3].reduce(func(accum, number): return accum + number, 10)) # 同上，但使用 lambda 函数。

func sum(accum, number):
    return accum + number</literal_block>
            <paragraph>另见 <reference internal="True" refid="class-array-method-map"><inline classes="std std-ref">map</inline></reference>、<reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">filter</inline></reference>、<reference internal="True" refid="class-array-method-any"><inline classes="std std-ref">any</inline></reference>、<reference internal="True" refid="class-array-method-all"><inline classes="std std-ref">all</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-remove-at"></target>
            <paragraph classes="classref-method" ids="class-array-method-remove-at" names="class_array_method_remove_at"><abbreviation explanation="无返回值。">void</abbreviation> <strong>remove_at</strong>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-array-method-remove-at"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>通过索引从数组中移除元素。如果索引在数组中不存在，则什么也不会发生。要通过搜索一个元素的值来移除，请改用 <reference internal="True" refid="class-array-method-erase"><inline classes="std std-ref">erase</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>这个方法是就地操作的，不返回修改后的数组。</paragraph>
            <paragraph><strong>注意：</strong>在大数组中，如果被删除的元素靠近数组的开头（索引 0），这个方法会比较慢。这是因为所有放置在被移除元素之后的元素都要被重新索引。</paragraph>
            <paragraph><strong>注意：</strong><literal>position</literal> 不能为负。要移除数组末尾的元素，请使用 <literal>arr.remove_at(arr.size() - (i + 1))</literal>。要移除数组末尾的元素并不返回值，请使用 <literal>arr.resize(arr.size() - 1)</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-resize"></target>
            <paragraph classes="classref-method" ids="class-array-method-resize" names="class_array_method_resize"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>resize</strong>(size: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-array-method-resize"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>调整数组的大小，让包含的元素数量发生变化。如果数组变小则清除多余元素，变大则新元素为 <literal>null</literal>。成功时返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-ok"><inline classes="std std-ref">@GlobalScope.OK</inline></reference>，操作失败时返回其他 <reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> 值。</paragraph>
            <paragraph>调用一次 <reference internal="True" refid="class-array-method-resize"><inline classes="std std-ref">resize</inline></reference> 并分配新值比逐个添加新元素要快。</paragraph>
            <paragraph><strong>注意：</strong>这个方法是就地操作的，不返回修改后的数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-reverse"></target>
            <paragraph classes="classref-method" ids="class-array-method-reverse" names="class_array_method_reverse"><abbreviation explanation="无返回值。">void</abbreviation> <strong>reverse</strong>() <reference internal="True" refid="class-array-method-reverse"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将数组中的元素逆序排列。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-rfind"></target>
            <paragraph classes="classref-method" ids="class-array-method-rfind" names="class_array_method_rfind"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>rfind</strong>(what: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = -1) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-rfind"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>逆序搜索数组。还可以传递起始搜索位置索引。如果为负，则起始索引被视为相对于数组的结尾。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-shuffle"></target>
            <paragraph classes="classref-method" ids="class-array-method-shuffle" names="class_array_method_shuffle"><abbreviation explanation="无返回值。">void</abbreviation> <strong>shuffle</strong>() <reference internal="True" refid="class-array-method-shuffle"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将数组打乱，元素随机排列。该方法使用全局随机数生成器，与 <reference internal="True" refuri="class_@globalscope#class-globalscope-method-randi"><inline classes="std std-ref">@GlobalScope.randi</inline></reference> 等方法一致。如果你想每次都使用新的种子，让打乱无法重现，则可以调用 <reference internal="True" refuri="class_@globalscope#class-globalscope-method-randomize"><inline classes="std std-ref">@GlobalScope.randomize</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-size"></target>
            <paragraph classes="classref-method" ids="class-array-method-size" names="class_array_method_size"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>size</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-size"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回数组中元素的个数。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-slice"></target>
            <paragraph classes="classref-method" ids="class-array-method-slice" names="class_array_method_slice"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>slice</strong>(begin: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, end: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 2147483647, step: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 1, deep: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-slice"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该 <strong>Array</strong> 的切片，是从 <literal>begin</literal>（含）到 <literal>end</literal>（不含）的全新 <strong>Array</strong>。</paragraph>
            <paragraph><literal>begin</literal> 和 <literal>end</literal> 的绝对值会按数组大小进行限制，所以 <literal>end</literal> 的默认值会切到数组大小为止（即 <literal>arr.slice(1)</literal> 是 <literal>arr.slice(1, arr.size())</literal> 的简写）。</paragraph>
            <paragraph>如果 <literal>begin</literal> 或 <literal>end</literal> 为负，则表示相对于数组的末尾（即 <literal>arr.slice(0, -2)</literal> 是 <literal>arr.slice(0, arr.size() - 2)</literal> 的简写）。</paragraph>
            <paragraph>如果指定了 <literal>step</literal>，则会用作原始元素的索引间距。这个参数可以为负，此时 <literal>begin</literal> 必须大于 <literal>end</literal>。例如，<literal>[0, 1, 2, 3, 4, 5].slice(5, 1, -2)</literal> 会返回 <literal>[5, 3]</literal>。</paragraph>
            <paragraph>如果 <literal>deep</literal> 为 true，则每个元素都会按值复制，而不是按引用复制。</paragraph>
            <paragraph><strong>注意：</strong>要在 <literal>step</literal> 为负时包含第一个元素，请使用 <literal>arr.slice(begin, -arr.size() - 1, step)</literal>（即 <literal>[0, 1, 2].slice(1, -4, -1)</literal> 返回 <literal>[1, 0]</literal>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-sort"></target>
            <paragraph classes="classref-method" ids="class-array-method-sort" names="class_array_method_sort"><abbreviation explanation="无返回值。">void</abbreviation> <strong>sort</strong>() <reference internal="True" refid="class-array-method-sort"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>对数组进行排序。</paragraph>
            <paragraph><strong>注意：</strong>排序所使用的算法并不<reference name="稳定" refuri="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#%E7%A9%A9%E5%AE%9A%E6%80%A7">稳定</reference>。也就是说，使用 <reference internal="True" refid="class-array-method-sort"><inline classes="std std-ref">sort</inline></reference> 时相等的值之间的顺序可能会改变。</paragraph>
            <paragraph><strong>注意：</strong>字符串按字母顺序排序（与自然顺序相反）。当对一个以数字序列结尾的字符串数组进行排序时，这可能会导致意外的行为。请看下面的例子：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var strings = ["string1", "string2", "string10", "string11"]
strings.sort()
print(strings) # 输出 [string1, string10, string11, string2]</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var strings = new Godot.Collections.Array { "string1", "string2", "string10", "string11" };
strings.Sort();
GD.Print(strings); // 输出 [string1, string10, string11, string2]</literal_block>
                </div>
            </container>
            <paragraph>要执行自然顺序排序，可以使用 <reference internal="True" refid="class-array-method-sort-custom"><inline classes="std std-ref">sort_custom</inline></reference> 和 <reference internal="True" refuri="class_string#class-string-method-naturalnocasecmp-to"><inline classes="std std-ref">String.naturalnocasecmp_to</inline></reference>，如下所示：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var strings = ["string1", "string2", "string10", "string11"]
strings.sort_custom(func(a, b): return a.naturalnocasecmp_to(b) &lt; 0)
print(strings) # 输出 [string1, string2, string10, string11]</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-sort-custom"></target>
            <paragraph classes="classref-method" ids="class-array-method-sort-custom" names="class_array_method_sort_custom"><abbreviation explanation="无返回值。">void</abbreviation> <strong>sort_custom</strong>(func: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <reference internal="True" refid="class-array-method-sort-custom"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>使用自定义的方法对数组进行排序。自定义方法接受两个参数（数组中的一对元素），并且必须返回 <literal>true</literal> 或者 <literal>false</literal>。对于两个元素 <literal>a</literal> 和 <literal>b</literal>，如果给定的方法返回 <literal>true</literal>，数组中的元素 <literal>b</literal> 将排在元素 <literal>a</literal> 之后。</paragraph>
            <paragraph><strong>注意：</strong>排序所使用的算法并不<reference name="稳定" refuri="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95#%E7%A9%A9%E5%AE%9A%E6%80%A7">稳定</reference>。也就是说，使用 <reference internal="True" refid="class-array-method-sort-custom"><inline classes="std std-ref">sort_custom</inline></reference> 时相等的值之间的顺序可能会改变。</paragraph>
            <paragraph><strong>注意：</strong>你不能随机化返回值，因为堆排序算法期望确定的结果。随机化返回值将导致意外行为。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func sort_ascending(a, b):
    if a[0] &lt; b[0]:
        return true
    return false

func _ready():
    var my_items = [[5, "Potato"], [9, "Rice"], [4, "Tomato"]]
    my_items.sort_custom(sort_ascending)
    print(my_items) # 输出 [[4, Tomato], [5, Potato], [9, Rice]].

    # Descending, lambda version.
    my_items.sort_custom(func(a, b): return a[0] &gt; b[0])
    print(my_items) # 输出 [[9, Rice], [5, Potato], [4, Tomato]].</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Godot.Collections.Array 不支持自定义排序</literal_block>
                </div>
            </container>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id9" names="操作符说明">
            <title>操作符说明</title>
            <target refid="class-array-operator-neq-array"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-neq-array" names="class_array_operator_neq_array"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-operator-neq-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将左操作数 <strong>Array</strong> 与右操作数 <literal>right</literal> <strong>Array</strong> 进行比较。如果大小或内容<emphasis>不相等</emphasis>，则返回 <literal>true</literal>，否则返回 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-operator-sum-array"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-sum-array" names="class_array_operator_sum_array"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>operator +</strong>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-operator-sum-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>连接两个 <strong>Array</strong>，右操作数 <literal>right</literal> <strong>Array</strong> 加到左操作数指定的 <strong>Array</strong> 的末尾。例如，<literal>[1, 2] + [3, 4]</literal> 的结果是 <literal>[1, 2, 3, 4]</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-operator-lt-array"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-lt-array" names="class_array_operator_lt_array"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &lt;</strong>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-operator-lt-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>对左操作数 <strong>Array</strong> 和右操作数 <literal>right</literal> <strong>Array</strong> 之间的各个索引进行比较，考虑两个数组的最高公共索引：遇到第一个不同的元素时，如果该元素较小则返回 <literal>true</literal>，如果该元素较大则返回 <literal>false</literal>。请注意，部分类型的存储数据可能导致本函数的递归调用。如果所有元素都相等，则比较两个数组的长度，如果左操作数 <strong>Array</strong> 元素较少则返回 <literal>false</literal>，否则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-operator-lte-array"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-lte-array" names="class_array_operator_lte_array"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &lt;=</strong>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-operator-lte-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>对左操作数 <strong>Array</strong> 和右操作数 <literal>right</literal> <strong>Array</strong> 之间的各个索引进行比较，考虑两个数组的最高公共索引：遇到第一个不同的元素时，如果该元素较小则返回 <literal>true</literal>，如果该元素较大则返回 <literal>false</literal>。请注意，部分类型的存储数据可能导致本函数的递归调用。如果所有元素都相等，则比较两个数组的长度，如果左操作数 <strong>Array</strong> 元素数量相等或较少则返回 <literal>true</literal>，否则返回 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-operator-eq-array"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-eq-array" names="class_array_operator_eq_array"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-operator-eq-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将左操作数 <strong>Array</strong> 与 <literal>right</literal> <strong>Array</strong> 进行比较。如果数组的大小和内容相等，则返回 <literal>true</literal>，否则返回 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-operator-gt-array"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-gt-array" names="class_array_operator_gt_array"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &gt;</strong>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-operator-gt-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>对左操作数 <strong>Array</strong> 和右操作数 <literal>right</literal> <strong>Array</strong> 之间的各个索引进行比较，考虑两个数组的最高公共索引：遇到第一个不同的元素时，如果该元素较大则返回 <literal>true</literal>，如果该元素较小则返回 <literal>false</literal>。请注意，部分类型的存储数据可能导致本函数的递归调用。如果所有元素都相等，则比较两个数组的长度，如果左操作数 <strong>Array</strong> 元素较多则返回 <literal>true</literal>，否则返回 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-operator-gte-array"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-gte-array" names="class_array_operator_gte_array"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &gt;=</strong>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-operator-gte-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>对左操作数 <strong>Array</strong> 和右操作数 <literal>right</literal> <strong>Array</strong> 之间的各个索引进行比较，考虑两个数组的最高公共索引：遇到第一个不同的元素时，如果该元素较大则返回 <literal>true</literal>，如果该元素较小则返回 <literal>false</literal>。请注意，部分类型的存储数据可能导致本函数的递归调用。如果所有元素都相等，则比较两个数组的长度，如果左操作数 <strong>Array</strong> 元素数量相等或较多则返回 <literal>true</literal>，否则返回 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-operator-idx-int"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-idx-int" names="class_array_operator_idx_int"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>operator []</strong>(index: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-array-operator-idx-int"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>该函数返回指定位置的 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> 类型元素的引用。数组从索引0开始。 <literal>index</literal> 可以是一个从头开始的零或正值，也可以是一个从末尾开始的负值。访问越界的数组会导致运行时错误，这将导致在编辑器中运行时打印错误并暂停项目执行。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了能接受在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="void"><abbreviation explanation="无返回值。">void</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
