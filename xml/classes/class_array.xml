<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_array.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/master/doc/classes/Array.xml.</comment>
    <target refid="class-array"></target>
    <section ids="array class-array" names="array class_array">
        <title>Array</title>
        <paragraph>一种内置数据结构，包含一系列元素。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>An array data structure that can contain a sequence of elements of any <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> type. Elements are accessed by a numerical index starting at 0. Negative indices are used to count from the back (-1 is the last element, -2 is the second to last, etc.).</paragraph>
            <paragraph><strong>Example:</strong></paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var array = ["First", 2, 3, "Last"]
print(array[0])  # Prints "First"
print(array[2])  # Prints 3
print(array[-1]) # Prints "Last"

array[1] = "Second"
print(array[1])  # Prints "Second"
print(array[-3]) # Prints "Second"</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var array = new Godot.Collections.Array{"First", 2, 3, "Last"};
GD.Print(array[0]); // Prints "First"
GD.Print(array[2]); // Prints 3
GD.Print(array[array.Count - 1]); // Prints "Last"

array[2] = "Second";
GD.Print(array[1]); // Prints "Second"
GD.Print(array[array.Count - 3]); // Prints "Second"</literal_block>
                </div>
            </container>
            <paragraph><strong>Note:</strong> Arrays are always passed by <strong>reference</strong>. To get a copy of an array that can be modified independently of the original array, use <reference internal="True" refid="class-array-method-duplicate"><inline classes="std std-ref">duplicate</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> Erasing elements while iterating over arrays is <strong>not</strong> supported and will result in unpredictable behavior.</paragraph>
            <paragraph><strong>Differences between packed arrays, typed arrays, and untyped arrays:</strong> Packed arrays are generally faster to iterate on and modify compared to a typed array of the same type (e.g. <reference internal="True" refuri="class_packedint64array#class-packedint64array"><inline classes="std std-ref">PackedInt64Array</inline></reference> versus <literal>Array[int]</literal>). Also, packed arrays consume less memory. As a downside, packed arrays are less flexible as they don't offer as many convenience methods such as <reference internal="True" refid="class-array-method-map"><inline classes="std std-ref">map</inline></reference>. Typed arrays are in turn faster to iterate on and modify than untyped arrays.</paragraph>
            <note>
                <paragraph>通过 C# 使用该 API 时会有显著不同，详见 <reference internal="True" refuri="../tutorials/scripting/c_sharp/c_sharp_differences#doc-c-sharp-differences"><inline classes="std std-ref">C# API 与 GDScript 的差异</inline></reference>。</paragraph>
            </note>
        </section>
        <section classes="classref-reftable-group" ids="id2" names="构造函数">
            <title>构造函数</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="27"></colspec>
                    <colspec colwidth="205"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(base: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>, type: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, class_name: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, script: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedcolorarray#class-packedcolorarray"><inline classes="std std-ref">PackedColorArray</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedint64array#class-packedint64array"><inline classes="std std-ref">PackedInt64Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">Array</inline></reference>(from: <reference internal="True" refuri="class_packedvector4array#class-packedvector4array"><inline classes="std std-ref">PackedVector4Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="37"></colspec>
                    <colspec colwidth="201"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-all"><inline classes="std std-ref">all</inline></reference>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-any"><inline classes="std std-ref">any</inline></reference>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-append"><inline classes="std std-ref">append</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-append-array"><inline classes="std std-ref">append_array</inline></reference>(array: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-assign"><inline classes="std std-ref">assign</inline></reference>(array: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-back"><inline classes="std std-ref">back</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-bsearch"><inline classes="std std-ref">bsearch</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, before: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-bsearch-custom"><inline classes="std std-ref">bsearch_custom</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, func: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, before: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-clear"><inline classes="std std-ref">clear</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-count"><inline classes="std std-ref">count</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-duplicate"><inline classes="std std-ref">duplicate</inline></reference>(deep: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-erase"><inline classes="std std-ref">erase</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-fill"><inline classes="std std-ref">fill</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">filter</inline></reference>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-find"><inline classes="std std-ref">find</inline></reference>(what: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-front"><inline classes="std std-ref">front</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-get-typed-builtin"><inline classes="std std-ref">get_typed_builtin</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-get-typed-class-name"><inline classes="std std-ref">get_typed_class_name</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-get-typed-script"><inline classes="std std-ref">get_typed_script</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-has"><inline classes="std std-ref">has</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-hash"><inline classes="std std-ref">hash</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-insert"><inline classes="std std-ref">insert</inline></reference>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-is-empty"><inline classes="std std-ref">is_empty</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-is-read-only"><inline classes="std std-ref">is_read_only</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-is-same-typed"><inline classes="std std-ref">is_same_typed</inline></reference>(array: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-is-typed"><inline classes="std std-ref">is_typed</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-make-read-only"><inline classes="std std-ref">make_read_only</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-map"><inline classes="std std-ref">map</inline></reference>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-max"><inline classes="std std-ref">max</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-min"><inline classes="std std-ref">min</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-pick-random"><inline classes="std std-ref">pick_random</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-pop-at"><inline classes="std std-ref">pop_at</inline></reference>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-pop-back"><inline classes="std std-ref">pop_back</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-pop-front"><inline classes="std std-ref">pop_front</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-push-back"><inline classes="std std-ref">push_back</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-push-front"><inline classes="std std-ref">push_front</inline></reference>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-reduce"><inline classes="std std-ref">reduce</inline></reference>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, accum: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> = null) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-remove-at"><inline classes="std std-ref">remove_at</inline></reference>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-resize"><inline classes="std std-ref">resize</inline></reference>(size: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-reverse"><inline classes="std std-ref">reverse</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-rfind"><inline classes="std std-ref">rfind</inline></reference>(what: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = -1) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-shuffle"><inline classes="std std-ref">shuffle</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-size"><inline classes="std std-ref">size</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-slice"><inline classes="std std-ref">slice</inline></reference>(begin: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, end: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 2147483647, step: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 1, deep: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-sort"><inline classes="std std-ref">sort</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-method-sort-custom"><inline classes="std std-ref">sort_custom</inline></reference>(func: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id4" names="运算符">
            <title>运算符</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="31"></colspec>
                    <colspec colwidth="94"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-neq-array"><inline classes="std std-ref">operator !=</inline></reference>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-sum-array"><inline classes="std std-ref">operator +</inline></reference>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-lt-array"><inline classes="std std-ref">operator &lt;</inline></reference>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-lte-array"><inline classes="std std-ref">operator &lt;=</inline></reference>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-eq-array"><inline classes="std std-ref">operator ==</inline></reference>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-gt-array"><inline classes="std std-ref">operator &gt;</inline></reference>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-gte-array"><inline classes="std std-ref">operator &gt;=</inline></reference>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-array-operator-idx-int"><inline classes="std std-ref">operator []</inline></reference>(index: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id5" names="构造函数说明">
            <title>构造函数说明</title>
            <target refid="class-array-constructor-array"></target>
            <paragraph classes="classref-constructor" ids="class-array-constructor-array" names="class_array_constructor_array"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>() <reference internal="True" refid="class-array-constructor-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>构造空的 <strong>Array</strong>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(base: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>, type: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, class_name: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, script: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
            <paragraph>Creates a typed array from the <literal>base</literal> array. A typed array can only contain elements of the given type, or that inherit from the given class, as described by this constructor's parameters:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>type</literal> is the built-in <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> type, as one the <reference internal="True" refuri="class_@globalscope#enum-globalscope-variant-type"><inline classes="std std-ref">Variant.Type</inline></reference> constants.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>class_name</literal> is the built-in class name (see <reference internal="True" refuri="class_object#class-object-method-get-class"><inline classes="std std-ref">Object.get_class</inline></reference>).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>script</literal> is the associated script. It must be a <reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference> instance or <literal>null</literal>.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If <literal>type</literal> is not <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-type-object"><inline classes="std std-ref">@GlobalScope.TYPE_OBJECT</inline></reference>, <literal>class_name</literal> must be an empty <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> and <literal>script</literal> must be <literal>null</literal>.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">class_name Sword
extends Node

class Stats:
    pass

func _ready():
    var a = Array([], TYPE_INT, "", null)               # Array[int]
    var b = Array([], TYPE_OBJECT, "Node", null)        # Array[Node]
    var c = Array([], TYPE_OBJECT, "Node", Sword)       # Array[Sword]
    var d = Array([], TYPE_OBJECT, "RefCounted", Stats) # Array[Stats]</literal_block>
            <paragraph>The <literal>base</literal> array's elements are converted when necessary. If this is not possible or <literal>base</literal> is already typed, this constructor fails and returns an empty <strong>Array</strong>.</paragraph>
            <paragraph>In GDScript, this constructor is usually not necessary, as it is possible to create a typed array through static typing:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var numbers: Array[float] = []
var children: Array[Node] = [$Node, $Sprite2D, $RigidBody3D]

var integers: Array[int] = [0.2, 4.5, -2.0]
print(integers) # Prints [0, 4, -2]</literal_block>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
            <paragraph>返回与 <literal>from</literal> 相同的数组。如果你需要一个数组的副本，请使用 <reference internal="True" refid="class-array-method-duplicate"><inline classes="std std-ref">duplicate</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedcolorarray#class-packedcolorarray"><inline classes="std std-ref">PackedColorArray</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedcolorarray#class-packedcolorarray"><inline classes="std std-ref">PackedColorArray</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedfloat32array#class-packedfloat32array"><inline classes="std std-ref">PackedFloat32Array</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedint32array#class-packedint32array"><inline classes="std std-ref">PackedInt32Array</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedint64array#class-packedint64array"><inline classes="std std-ref">PackedInt64Array</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedint64array#class-packedint64array"><inline classes="std std-ref">PackedInt64Array</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedvector2array#class-packedvector2array"><inline classes="std std-ref">PackedVector2Array</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedvector3array#class-packedvector3array"><inline classes="std std-ref">PackedVector3Array</inline></reference> 构造一个数组。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>Array</strong>(from: <reference internal="True" refuri="class_packedvector4array#class-packedvector4array"><inline classes="std std-ref">PackedVector4Array</inline></reference>)</paragraph>
            <paragraph>从 <reference internal="True" refuri="class_packedvector4array#class-packedvector4array"><inline classes="std std-ref">PackedVector4Array</inline></reference> 构造一个数组。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id6" names="方法说明">
            <title>方法说明</title>
            <target refid="class-array-method-all"></target>
            <paragraph classes="classref-method" ids="class-array-method-all" names="class_array_method_all"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>all</strong>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-all"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Calls the given <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> on each element in the array and returns <literal>true</literal> if the <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> returns <literal>true</literal> for <emphasis>all</emphasis> elements in the array. If the <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> returns <literal>false</literal> for one array element or more, this method returns <literal>false</literal>.</paragraph>
            <paragraph>The <literal>method</literal> should take one <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> parameter (the current array element) and return a <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func greater_than_5(number):
    return number &gt; 5

func _ready():
    print([6, 10, 6].all(greater_than_5)) # Prints true (3/3 elements evaluate to true).
    print([4, 10, 4].all(greater_than_5)) # Prints false (1/3 elements evaluate to true).
    print([4, 4, 4].all(greater_than_5))  # Prints false (0/3 elements evaluate to true).
    print([].all(greater_than_5))         # Prints true (0/0 elements evaluate to true).

    # Same as the first line above, but using a lambda function.
    print([6, 10, 6].all(func(element): return element &gt; 5)) # Prints true</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private static bool GreaterThan5(int number)
{
    return number &gt; 5;
}

public override void _Ready()
{
    // Prints true (3/3 elements evaluate to true).
    GD.Print(new Godot.Collections.Array&gt;int&lt; { 6, 10, 6 }.All(GreaterThan5));
    // Prints false (1/3 elements evaluate to true).
    GD.Print(new Godot.Collections.Array&gt;int&lt; { 4, 10, 4 }.All(GreaterThan5));
    // Prints false (0/3 elements evaluate to true).
    GD.Print(new Godot.Collections.Array&gt;int&lt; { 4, 4, 4 }.All(GreaterThan5));
    // Prints true (0/0 elements evaluate to true).
    GD.Print(new Godot.Collections.Array&gt;int&lt; { }.All(GreaterThan5));

    // Same as the first line above, but using a lambda function.
    GD.Print(new Godot.Collections.Array&gt;int&lt; { 6, 10, 6 }.All(element =&gt; element &gt; 5)); // Prints true
}</literal_block>
                </div>
            </container>
            <paragraph>See also <reference internal="True" refid="class-array-method-any"><inline classes="std std-ref">any</inline></reference>, <reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">filter</inline></reference>, <reference internal="True" refid="class-array-method-map"><inline classes="std std-ref">map</inline></reference> and <reference internal="True" refid="class-array-method-reduce"><inline classes="std std-ref">reduce</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> Unlike relying on the size of an array returned by <reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">filter</inline></reference>, this method will return as early as possible to improve performance (especially with large arrays).</paragraph>
            <paragraph><strong>Note:</strong> For an empty array, this method <reference name="always" refuri="https://en.wikipedia.org/wiki/Vacuous_truth">always</reference> returns <literal>true</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-any"></target>
            <paragraph classes="classref-method" ids="class-array-method-any" names="class_array_method_any"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>any</strong>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-any"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Calls the given <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> on each element in the array and returns <literal>true</literal> if the <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> returns <literal>true</literal> for <emphasis>one or more</emphasis> elements in the array. If the <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> returns <literal>false</literal> for all elements in the array, this method returns <literal>false</literal>.</paragraph>
            <paragraph>The <literal>method</literal> should take one <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> parameter (the current array element) and return a <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func greater_than_5(number):
    return number &gt; 5

func _ready():
    print([6, 10, 6].any(greater_than_5)) # Prints true (3 elements evaluate to true).
    print([4, 10, 4].any(greater_than_5)) # Prints true (1 elements evaluate to true).
    print([4, 4, 4].any(greater_than_5))  # Prints false (0 elements evaluate to true).
    print([].any(greater_than_5))         # Prints false (0 elements evaluate to true).

    # Same as the first line above, but using a lambda function.
    print([6, 10, 6].any(func(number): return number &gt; 5)) # Prints true</literal_block>
            <paragraph>See also <reference internal="True" refid="class-array-method-all"><inline classes="std std-ref">all</inline></reference>, <reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">filter</inline></reference>, <reference internal="True" refid="class-array-method-map"><inline classes="std std-ref">map</inline></reference> and <reference internal="True" refid="class-array-method-reduce"><inline classes="std std-ref">reduce</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> Unlike relying on the size of an array returned by <reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">filter</inline></reference>, this method will return as early as possible to improve performance (especially with large arrays).</paragraph>
            <paragraph><strong>Note:</strong> For an empty array, this method always returns <literal>false</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-append"></target>
            <paragraph classes="classref-method" ids="class-array-method-append" names="class_array_method_append"><abbreviation explanation="无返回值。">void</abbreviation> <strong>append</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-array-method-append"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Appends <literal>value</literal> at the end of the array (alias of <reference internal="True" refid="class-array-method-push-back"><inline classes="std std-ref">push_back</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-append-array"></target>
            <paragraph classes="classref-method" ids="class-array-method-append-array" names="class_array_method_append_array"><abbreviation explanation="无返回值。">void</abbreviation> <strong>append_array</strong>(array: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-method-append-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Appends another <literal>array</literal> at the end of this array.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var numbers = [1, 2, 3]
var extra = [4, 5, 6]
numbers.append_array(extra)
print(nums) # Prints [1, 2, 3, 4, 5, 6]</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-assign"></target>
            <paragraph classes="classref-method" ids="class-array-method-assign" names="class_array_method_assign"><abbreviation explanation="无返回值。">void</abbreviation> <strong>assign</strong>(array: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-method-assign"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将另一个 <literal>array</literal> 的元素赋值到该数组中。调整数组大小以匹配 <literal>array</literal>。如果数组是有类型的，则执行类型转换。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-back"></target>
            <paragraph classes="classref-method" ids="class-array-method-back" names="class_array_method_back"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>back</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-back"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the last element of the array. If the array is empty, fails and returns <literal>null</literal>. See also <reference internal="True" refid="class-array-method-front"><inline classes="std std-ref">front</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> Unlike with the <literal>[]</literal> operator (<literal>array[-1]</literal>), an error is generated without stopping project execution.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-bsearch"></target>
            <paragraph classes="classref-method" ids="class-array-method-bsearch" names="class_array_method_bsearch"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>bsearch</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, before: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-bsearch"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the index of <literal>value</literal> in the sorted array. If it cannot be found, returns where <literal>value</literal> should be inserted to keep the array sorted. The algorithm used is <reference name="binary search" refuri="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</reference>.</paragraph>
            <paragraph>If <literal>before</literal> is <literal>true</literal> (as by default), the returned index comes before all existing elements equal to <literal>value</literal> in the array.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var numbers = [2, 4, 8, 10]
var idx = numbers.bsearch(7)

numbers.insert(idx, 7)
print(numbers) # Prints [2, 4, 7, 8, 10]

var fruits = ["Apple", "Lemon", "Lemon", "Orange"]
print(fruits.bsearch("Lemon", true))  # Prints 1, points at the first "Lemon".
print(fruits.bsearch("Lemon", false)) # Prints 3, points at "Orange".</literal_block>
            <paragraph><strong>Note:</strong> Calling <reference internal="True" refid="class-array-method-bsearch"><inline classes="std std-ref">bsearch</inline></reference> on an <emphasis>unsorted</emphasis> array will result in unexpected behavior. Use <reference internal="True" refid="class-array-method-sort"><inline classes="std std-ref">sort</inline></reference> before calling this method.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-bsearch-custom"></target>
            <paragraph classes="classref-method" ids="class-array-method-bsearch-custom" names="class_array_method_bsearch_custom"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>bsearch_custom</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, func: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, before: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-bsearch-custom"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the index of <literal>value</literal> in the sorted array. If it cannot be found, returns where <literal>value</literal> should be inserted to keep the array sorted (using <literal>func</literal> for the comparisons). The algorithm used is <reference name="binary search" refuri="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search</reference>.</paragraph>
            <paragraph>Similar to <reference internal="True" refid="class-array-method-sort-custom"><inline classes="std std-ref">sort_custom</inline></reference>, <literal>func</literal> is called as many times as necessary, receiving one array element and <literal>value</literal> as arguments. The function should return <literal>true</literal> if the array element should be <emphasis>behind</emphasis> <literal>value</literal>, otherwise it should return <literal>false</literal>.</paragraph>
            <paragraph>If <literal>before</literal> is <literal>true</literal> (as by default), the returned index comes before all existing elements equal to <literal>value</literal> in the array.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func sort_by_amount(a, b):
    if a[1] &lt; b[1]:
        return true
    return false

func _ready():
    var my_items = [["Tomato", 2], ["Kiwi", 5], ["Rice", 9]]

    var apple = ["Apple", 5]
    # "Apple" is inserted before "Kiwi".
    my_items.insert(my_items.bsearch_custom(apple, sort_by_amount, true), apple)

    var banana = ["Banana", 5]
    # "Banana" is inserted after "Kiwi".
    my_items.insert(my_items.bsearch_custom(banana, sort_by_amount, false), banana)

    # Prints [["Tomato", 2], ["Apple", 5], ["Kiwi", 5], ["Banana", 5], ["Rice", 9]]
    print(my_items)</literal_block>
            <paragraph><strong>Note:</strong> Calling <reference internal="True" refid="class-array-method-bsearch-custom"><inline classes="std std-ref">bsearch_custom</inline></reference> on an <emphasis>unsorted</emphasis> array will result in unexpected behavior. Use <reference internal="True" refid="class-array-method-sort-custom"><inline classes="std std-ref">sort_custom</inline></reference> with <literal>func</literal> before calling this method.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-clear"></target>
            <paragraph classes="classref-method" ids="class-array-method-clear" names="class_array_method_clear"><abbreviation explanation="无返回值。">void</abbreviation> <strong>clear</strong>() <reference internal="True" refid="class-array-method-clear"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Removes all elements from the array. This is equivalent to using <reference internal="True" refid="class-array-method-resize"><inline classes="std std-ref">resize</inline></reference> with a size of <literal>0</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-count"></target>
            <paragraph classes="classref-method" ids="class-array-method-count" names="class_array_method_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>count</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-count"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回元素在数组中出现的次数。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-duplicate"></target>
            <paragraph classes="classref-method" ids="class-array-method-duplicate" names="class_array_method_duplicate"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>duplicate</strong>(deep: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-duplicate"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns a new copy of the array.</paragraph>
            <paragraph>By default, a <strong>shallow</strong> copy is returned: all nested <strong>Array</strong> and <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> elements are shared with the original array. Modifying them in one array will also affect them in the other.</paragraph>
            <paragraph>If <literal>deep</literal> is <literal>true</literal>, a <strong>deep</strong> copy is returned: all nested arrays and dictionaries are also duplicated (recursively).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-erase"></target>
            <paragraph classes="classref-method" ids="class-array-method-erase" names="class_array_method_erase"><abbreviation explanation="无返回值。">void</abbreviation> <strong>erase</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-array-method-erase"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Finds and removes the first occurrence of <literal>value</literal> from the array. If <literal>value</literal> does not exist in the array, nothing happens. To remove an element by index, use <reference internal="True" refid="class-array-method-remove-at"><inline classes="std std-ref">remove_at</inline></reference> instead.</paragraph>
            <paragraph><strong>Note:</strong> This method shifts every element's index after the removed <literal>value</literal> back, which may have a noticeable performance cost, especially on larger arrays.</paragraph>
            <paragraph><strong>Note:</strong> Erasing elements while iterating over arrays is <strong>not</strong> supported and will result in unpredictable behavior.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-fill"></target>
            <paragraph classes="classref-method" ids="class-array-method-fill" names="class_array_method_fill"><abbreviation explanation="无返回值。">void</abbreviation> <strong>fill</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-array-method-fill"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Assigns the given <literal>value</literal> to all elements in the array.</paragraph>
            <paragraph>This method can often be combined with <reference internal="True" refid="class-array-method-resize"><inline classes="std std-ref">resize</inline></reference> to create an array with a given size and initialized elements:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var array = []
array.resize(5)
array.fill(2)
print(array) # Prints [2, 2, 2, 2, 2]</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var array = new Godot.Collections.Array();
array.Resize(5);
array.Fill(2);
GD.Print(array); // Prints [2, 2, 2, 2, 2]</literal_block>
                </div>
            </container>
            <paragraph><strong>Note:</strong> If <literal>value</literal> is a <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> passed by reference (<reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference>-derived, <strong>Array</strong>, <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>, etc.), the array will be filled with references to the same <literal>value</literal>, which are not duplicates.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-filter"></target>
            <paragraph classes="classref-method" ids="class-array-method-filter" names="class_array_method_filter"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>filter</strong>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Calls the given <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> on each element in the array and returns a new, filtered <strong>Array</strong>.</paragraph>
            <paragraph>The <literal>method</literal> receives one of the array elements as an argument, and should return <literal>true</literal> to add the element to the filtered array, or <literal>false</literal> to exclude it.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func is_even(number):
    return number % 2 == 0

func _ready():
    print([1, 4, 5, 8].filter(is_even)) # Prints [4, 8]

    # Same as above, but using a lambda function.
    print([1, 4, 5, 8].filter(func(number): return number % 2 == 0))</literal_block>
            <paragraph>See also <reference internal="True" refid="class-array-method-any"><inline classes="std std-ref">any</inline></reference>, <reference internal="True" refid="class-array-method-all"><inline classes="std std-ref">all</inline></reference>, <reference internal="True" refid="class-array-method-map"><inline classes="std std-ref">map</inline></reference> and <reference internal="True" refid="class-array-method-reduce"><inline classes="std std-ref">reduce</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-find"></target>
            <paragraph classes="classref-method" ids="class-array-method-find" names="class_array_method_find"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>find</strong>(what: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-find"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the index of the <strong>first</strong> occurrence of <literal>what</literal> in this array, or <literal>-1</literal> if there are none. The search's start can be specified with <literal>from</literal>, continuing to the end of the array.</paragraph>
            <paragraph><strong>Note:</strong> If you just want to know whether the array contains <literal>what</literal>, use <reference internal="True" refid="class-array-method-has"><inline classes="std std-ref">has</inline></reference> (<literal>Contains</literal> in C#). In GDScript, you may also use the <literal>in</literal> operator.</paragraph>
            <paragraph><strong>Note:</strong> For performance reasons, the search is affected by <literal>what</literal>'s <reference internal="True" refuri="class_@globalscope#enum-globalscope-variant-type"><inline classes="std std-ref">Variant.Type</inline></reference>. For example, <literal>7</literal> (<reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) and <literal>7.0</literal> (<reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) are not considered equal for this method.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-front"></target>
            <paragraph classes="classref-method" ids="class-array-method-front" names="class_array_method_front"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>front</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-front"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the first element of the array. If the array is empty, fails and returns <literal>null</literal>. See also <reference internal="True" refid="class-array-method-back"><inline classes="std std-ref">back</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> Unlike with the <literal>[]</literal> operator (<literal>array[0]</literal>), an error is generated without stopping project execution.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-get-typed-builtin"></target>
            <paragraph classes="classref-method" ids="class-array-method-get-typed-builtin" names="class_array_method_get_typed_builtin"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_typed_builtin</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-get-typed-builtin"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the built-in <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> type of the typed array as a <reference internal="True" refuri="class_@globalscope#enum-globalscope-variant-type"><inline classes="std std-ref">Variant.Type</inline></reference> constant. If the array is not typed, returns <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-type-nil"><inline classes="std std-ref">@GlobalScope.TYPE_NIL</inline></reference>. See also <reference internal="True" refid="class-array-method-is-typed"><inline classes="std std-ref">is_typed</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-get-typed-class-name"></target>
            <paragraph classes="classref-method" ids="class-array-method-get-typed-class-name" names="class_array_method_get_typed_class_name"><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>get_typed_class_name</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-get-typed-class-name"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the <strong>built-in</strong> class name of the typed array, if the built-in <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> type <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-type-object"><inline classes="std std-ref">@GlobalScope.TYPE_OBJECT</inline></reference>. Otherwise, returns an empty <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>. See also <reference internal="True" refid="class-array-method-is-typed"><inline classes="std std-ref">is_typed</inline></reference> and <reference internal="True" refuri="class_object#class-object-method-get-class"><inline classes="std std-ref">Object.get_class</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-get-typed-script"></target>
            <paragraph classes="classref-method" ids="class-array-method-get-typed-script" names="class_array_method_get_typed_script"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>get_typed_script</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-get-typed-script"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the <reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference> instance associated with this typed array, or <literal>null</literal> if it does not exist. See also <reference internal="True" refid="class-array-method-is-typed"><inline classes="std std-ref">is_typed</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-has"></target>
            <paragraph classes="classref-method" ids="class-array-method-has" names="class_array_method_has"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>has</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-has"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the array contains the given <literal>value</literal>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">print(["inside", 7].has("inside"))  # Prints true
print(["inside", 7].has("outside")) # Prints false
print(["inside", 7].has(7))         # Prints true
print(["inside", 7].has("7"))       # Prints false</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var arr = new Godot.Collections.Array { "inside", 7 };
// By C# convention, this method is renamed to `Contains`.
GD.Print(arr.Contains("inside"));  // Prints true
GD.Print(arr.Contains("outside")); // Prints false
GD.Print(arr.Contains(7));         // Prints true
GD.Print(arr.Contains("7"));       // Prints false</literal_block>
                </div>
            </container>
            <paragraph>In GDScript, this is equivalent to the <literal>in</literal> operator:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">if 4 in [2, 4, 6, 8]:
    print("4 is here!") # Will be printed.</literal_block>
            <paragraph><strong>Note:</strong> For performance reasons, the search is affected by the <literal>value</literal>'s <reference internal="True" refuri="class_@globalscope#enum-globalscope-variant-type"><inline classes="std std-ref">Variant.Type</inline></reference>. For example, <literal>7</literal> (<reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) and <literal>7.0</literal> (<reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) are not considered equal for this method.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-hash"></target>
            <paragraph classes="classref-method" ids="class-array-method-hash" names="class_array_method_hash"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>hash</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-hash"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns a hashed 32-bit integer value representing the array and its contents.</paragraph>
            <paragraph><strong>Note:</strong> Arrays with equal hash values are <emphasis>not</emphasis> guaranteed to be the same, as a result of hash collisions. On the countrary, arrays with different hash values are guaranteed to be different.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-insert"></target>
            <paragraph classes="classref-method" ids="class-array-method-insert" names="class_array_method_insert"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>insert</strong>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-array-method-insert"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Inserts a new element (<literal>value</literal>) at a given index (<literal>position</literal>) in the array. <literal>position</literal> should be between <literal>0</literal> and the array's <reference internal="True" refid="class-array-method-size"><inline classes="std std-ref">size</inline></reference>.</paragraph>
            <paragraph>Returns <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-ok"><inline classes="std std-ref">@GlobalScope.OK</inline></reference> on success, or one of the other <reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> constants if this method fails.</paragraph>
            <paragraph><strong>Note:</strong> Every element's index after <literal>position</literal> needs to be shifted forward, which may have a noticeable performance cost, especially on larger arrays.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-is-empty"></target>
            <paragraph classes="classref-method" ids="class-array-method-is-empty" names="class_array_method_is_empty"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_empty</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-is-empty"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the array is empty (<literal>[]</literal>). See also <reference internal="True" refid="class-array-method-size"><inline classes="std std-ref">size</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-is-read-only"></target>
            <paragraph classes="classref-method" ids="class-array-method-is-read-only" names="class_array_method_is_read_only"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_read_only</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-is-read-only"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the array is read-only. See <reference internal="True" refid="class-array-method-make-read-only"><inline classes="std std-ref">make_read_only</inline></reference>.</paragraph>
            <paragraph>In GDScript, arrays are automatically read-only if declared with the <literal>const</literal> keyword.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-is-same-typed"></target>
            <paragraph classes="classref-method" ids="class-array-method-is-same-typed" names="class_array_method_is_same_typed"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_same_typed</strong>(array: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-is-same-typed"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if this array is typed the same as the given <literal>array</literal>. See also <reference internal="True" refid="class-array-method-is-typed"><inline classes="std std-ref">is_typed</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-is-typed"></target>
            <paragraph classes="classref-method" ids="class-array-method-is-typed" names="class_array_method_is_typed"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_typed</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-is-typed"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the array is typed. Typed arrays can only contain elements of a specific type, as defined by the typed array constructor. The methods of a typed array are still expected to return a generic <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>.</paragraph>
            <paragraph>In GDScript, it is possible to define a typed array with static typing:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var numbers: Array[float] = [0.2, 4.2, -2.0]
print(numbers.is_typed()) # Prints true</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-make-read-only"></target>
            <paragraph classes="classref-method" ids="class-array-method-make-read-only" names="class_array_method_make_read_only"><abbreviation explanation="无返回值。">void</abbreviation> <strong>make_read_only</strong>() <reference internal="True" refid="class-array-method-make-read-only"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Makes the array read-only. The array's elements cannot be overridden with different values, and their order cannot change. Does not apply to nested elements, such as dictionaries.</paragraph>
            <paragraph>In GDScript, arrays are automatically read-only if declared with the <literal>const</literal> keyword.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-map"></target>
            <paragraph classes="classref-method" ids="class-array-method-map" names="class_array_method_map"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>map</strong>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-map"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Calls the given <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> for each element in the array and returns a new array filled with values returned by the <literal>method</literal>.</paragraph>
            <paragraph>The <literal>method</literal> should take one <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> parameter (the current array element) and can return any <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func double(number):
    return number * 2

func _ready():
    print([1, 2, 3].map(double)) # Prints [2, 4, 6]

    # Same as above, but using a lambda function.
    print([1, 2, 3].map(func(element): return element * 2))</literal_block>
            <paragraph>See also <reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">filter</inline></reference>, <reference internal="True" refid="class-array-method-reduce"><inline classes="std std-ref">reduce</inline></reference>, <reference internal="True" refid="class-array-method-any"><inline classes="std std-ref">any</inline></reference> and <reference internal="True" refid="class-array-method-all"><inline classes="std std-ref">all</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-max"></target>
            <paragraph classes="classref-method" ids="class-array-method-max" names="class_array_method_max"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>max</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-max"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the maximum value contained in the array, if all elements can be compared. Otherwise, returns <literal>null</literal>. See also <reference internal="True" refid="class-array-method-min"><inline classes="std std-ref">min</inline></reference>.</paragraph>
            <paragraph>To find the maximum value using a custom comparator, you can use <reference internal="True" refid="class-array-method-reduce"><inline classes="std std-ref">reduce</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-min"></target>
            <paragraph classes="classref-method" ids="class-array-method-min" names="class_array_method_min"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>min</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-min"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the minimum value contained in the array, if all elements can be compared. Otherwise, returns <literal>null</literal>. See also <reference internal="True" refid="class-array-method-max"><inline classes="std std-ref">max</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-pick-random"></target>
            <paragraph classes="classref-method" ids="class-array-method-pick-random" names="class_array_method_pick_random"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>pick_random</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-pick-random"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns a random element from the array. Generates an error and returns <literal>null</literal> if the array is empty.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># May print 1, 2, 3.25, or "Hi".
print([1, 2, 3.25, "Hi"].pick_random())</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var array = new Godot.Collections.Array { 1, 2, 3.25f, "Hi" };
GD.Print(array.PickRandom()); // May print 1, 2, 3.25, or "Hi".</literal_block>
                </div>
            </container>
            <paragraph><strong>Note:</strong> Like many similar functions in the engine (such as <reference internal="True" refuri="class_@globalscope#class-globalscope-method-randi"><inline classes="std std-ref">@GlobalScope.randi</inline></reference> or <reference internal="True" refid="class-array-method-shuffle"><inline classes="std std-ref">shuffle</inline></reference>), this method uses a common, global random seed. To get a predictable outcome from this method, see <reference internal="True" refuri="class_@globalscope#class-globalscope-method-seed"><inline classes="std std-ref">@GlobalScope.seed</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-pop-at"></target>
            <paragraph classes="classref-method" ids="class-array-method-pop-at" names="class_array_method_pop_at"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>pop_at</strong>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-array-method-pop-at"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Removes and returns the element of the array at index <literal>position</literal>. If negative, <literal>position</literal> is considered relative to the end of the array. Returns <literal>null</literal> if the array is empty. If <literal>position</literal> is out of bounds, an error message is also generated.</paragraph>
            <paragraph><strong>Note:</strong> This method shifts every element's index after <literal>position</literal> back, which may have a noticeable performance cost, especially on larger arrays.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-pop-back"></target>
            <paragraph classes="classref-method" ids="class-array-method-pop-back" names="class_array_method_pop_back"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>pop_back</strong>() <reference internal="True" refid="class-array-method-pop-back"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Removes and returns the last element of the array. Returns <literal>null</literal> if the array is empty, without generating an error. See also <reference internal="True" refid="class-array-method-pop-front"><inline classes="std std-ref">pop_front</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-pop-front"></target>
            <paragraph classes="classref-method" ids="class-array-method-pop-front" names="class_array_method_pop_front"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>pop_front</strong>() <reference internal="True" refid="class-array-method-pop-front"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Removes and returns the first element of the array. Returns <literal>null</literal> if the array is empty, without generating an error. See also <reference internal="True" refid="class-array-method-pop-back"><inline classes="std std-ref">pop_back</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This method shifts every other element's index back, which may have a noticeable performance cost, especially on larger arrays.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-push-back"></target>
            <paragraph classes="classref-method" ids="class-array-method-push-back" names="class_array_method_push_back"><abbreviation explanation="无返回值。">void</abbreviation> <strong>push_back</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-array-method-push-back"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>在数组的末端追加一个元素。另请参阅 <reference internal="True" refid="class-array-method-push-front"><inline classes="std std-ref">push_front</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-push-front"></target>
            <paragraph classes="classref-method" ids="class-array-method-push-front" names="class_array_method_push_front"><abbreviation explanation="无返回值。">void</abbreviation> <strong>push_front</strong>(value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-array-method-push-front"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Adds an element at the beginning of the array. See also <reference internal="True" refid="class-array-method-push-back"><inline classes="std std-ref">push_back</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This method shifts every other element's index forward, which may have a noticeable performance cost, especially on larger arrays.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-reduce"></target>
            <paragraph classes="classref-method" ids="class-array-method-reduce" names="class_array_method_reduce"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>reduce</strong>(method: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, accum: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> = null) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-reduce"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Calls the given <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> for each element in array, accumulates the result in <literal>accum</literal>, then returns it.</paragraph>
            <paragraph>The <literal>method</literal> takes two arguments: the current value of <literal>accum</literal> and the current array element. If <literal>accum</literal> is <literal>null</literal> (as by default), the iteration will start from the second element, with the first one used as initial value of <literal>accum</literal>.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func sum(accum, number):
    return accum + number

func _ready():
    print([1, 2, 3].reduce(sum, 0))  # Prints 6
    print([1, 2, 3].reduce(sum, 10)) # Prints 16

    # Same as above, but using a lambda function.
    print([1, 2, 3].reduce(func(accum, number): return accum + number, 10))</literal_block>
            <paragraph>If <reference internal="True" refid="class-array-method-max"><inline classes="std std-ref">max</inline></reference> is not desirable, this method may also be used to implement a custom comparator:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    var arr = [Vector2(5, 0), Vector2(3, 4), Vector2(1, 2)]

    var longest_vec = arr.reduce(func(max, vec): return vec if is_length_greater(vec, max) else max)
    print(longest_vec) # Prints Vector2(3, 4).

func is_length_greater(a, b):
    return a.length() &gt; b.length()</literal_block>
            <paragraph>See also <reference internal="True" refid="class-array-method-map"><inline classes="std std-ref">map</inline></reference>, <reference internal="True" refid="class-array-method-filter"><inline classes="std std-ref">filter</inline></reference>, <reference internal="True" refid="class-array-method-any"><inline classes="std std-ref">any</inline></reference> and <reference internal="True" refid="class-array-method-all"><inline classes="std std-ref">all</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-remove-at"></target>
            <paragraph classes="classref-method" ids="class-array-method-remove-at" names="class_array_method_remove_at"><abbreviation explanation="无返回值。">void</abbreviation> <strong>remove_at</strong>(position: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-array-method-remove-at"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Removes the element from the array at the given index (<literal>position</literal>). If the index is out of bounds, this method fails.</paragraph>
            <paragraph>If you need to return the removed element, use <reference internal="True" refid="class-array-method-pop-at"><inline classes="std std-ref">pop_at</inline></reference>. To remove an element by value, use <reference internal="True" refid="class-array-method-erase"><inline classes="std std-ref">erase</inline></reference> instead.</paragraph>
            <paragraph><strong>Note:</strong> This method shifts every element's index after <literal>position</literal> back, which may have a noticeable performance cost, especially on larger arrays.</paragraph>
            <paragraph><strong>Note:</strong> The <literal>position</literal> cannot be negative. To remove an element relative to the end of the array, use <literal>arr.remove_at(arr.size() - (i + 1))</literal>. To remove the last element from the array, use <literal>arr.resize(arr.size() - 1)</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-resize"></target>
            <paragraph classes="classref-method" ids="class-array-method-resize" names="class_array_method_resize"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>resize</strong>(size: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-array-method-resize"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Sets the array's number of elements to <literal>size</literal>. If <literal>size</literal> is smaller than the array's current size, the elements at the end are removed. If <literal>size</literal> is greater, new default elements (usually <literal>null</literal>) are added, depending on the array's type.</paragraph>
            <paragraph>Returns <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-ok"><inline classes="std std-ref">@GlobalScope.OK</inline></reference> on success, or one of the other <reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> constants if this method fails.</paragraph>
            <paragraph><strong>Note:</strong> Calling this method once and assigning the new values is faster than calling <reference internal="True" refid="class-array-method-append"><inline classes="std std-ref">append</inline></reference> for every new element.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-reverse"></target>
            <paragraph classes="classref-method" ids="class-array-method-reverse" names="class_array_method_reverse"><abbreviation explanation="无返回值。">void</abbreviation> <strong>reverse</strong>() <reference internal="True" refid="class-array-method-reverse"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Reverses the order of all elements in the array.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-rfind"></target>
            <paragraph classes="classref-method" ids="class-array-method-rfind" names="class_array_method_rfind"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>rfind</strong>(what: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, from: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = -1) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-rfind"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the index of the <strong>last</strong> occurrence of <literal>what</literal> in this array, or <literal>-1</literal> if there are none. The search's start can be specified with <literal>from</literal>, continuing to the beginning of the array. This method is the reverse of <reference internal="True" refid="class-array-method-find"><inline classes="std std-ref">find</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-shuffle"></target>
            <paragraph classes="classref-method" ids="class-array-method-shuffle" names="class_array_method_shuffle"><abbreviation explanation="无返回值。">void</abbreviation> <strong>shuffle</strong>() <reference internal="True" refid="class-array-method-shuffle"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Shuffles all elements of the array in a random order.</paragraph>
            <paragraph><strong>Note:</strong> Like many similar functions in the engine (such as <reference internal="True" refuri="class_@globalscope#class-globalscope-method-randi"><inline classes="std std-ref">@GlobalScope.randi</inline></reference> or <reference internal="True" refid="class-array-method-pick-random"><inline classes="std std-ref">pick_random</inline></reference>), this method uses a common, global random seed. To get a predictable outcome from this method, see <reference internal="True" refuri="class_@globalscope#class-globalscope-method-seed"><inline classes="std std-ref">@GlobalScope.seed</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-size"></target>
            <paragraph classes="classref-method" ids="class-array-method-size" names="class_array_method_size"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>size</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-size"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the number of elements in the array. Empty arrays (<literal>[]</literal>) always return <literal>0</literal>. See also <reference internal="True" refid="class-array-method-is-empty"><inline classes="std std-ref">is_empty</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-slice"></target>
            <paragraph classes="classref-method" ids="class-array-method-slice" names="class_array_method_slice"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>slice</strong>(begin: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, end: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 2147483647, step: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 1, deep: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-array-method-slice"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns a new <strong>Array</strong> containing this array's elements, from index <literal>begin</literal> (inclusive) to <literal>end</literal> (exclusive), every <literal>step</literal> elements.</paragraph>
            <paragraph>If either <literal>begin</literal> or <literal>end</literal> are negative, their value is relative to the end of the array.</paragraph>
            <paragraph>If <literal>step</literal> is negative, this method iterates through the array in reverse, returning a slice ordered backwards. For this to work, <literal>begin</literal> must be greater than <literal>end</literal>.</paragraph>
            <paragraph>If <literal>deep</literal> is <literal>true</literal>, all nested <strong>Array</strong> and <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> elements in the slice are duplicated from the original, recursively. See also <reference internal="True" refid="class-array-method-duplicate"><inline classes="std std-ref">duplicate</inline></reference>).</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var letters = ["A", "B", "C", "D", "E", "F"]

print(letters.slice(0, 2))  # Prints ["A", "B"]
print(letters.slice(2, -2)) # Prints ["C", "D"]
print(letters.slice(-2, 6)) # Prints ["E", "F"]

print(letters.slice(0, 6, 2))  # Prints ["A", "C", "E"]
print(letters.slice(4, 1, -1)) # Prints ["E", "D", "C"]</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-sort"></target>
            <paragraph classes="classref-method" ids="class-array-method-sort" names="class_array_method_sort"><abbreviation explanation="无返回值。">void</abbreviation> <strong>sort</strong>() <reference internal="True" refid="class-array-method-sort"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Sorts the array in ascending order. The final order is dependent on the "less than" (<literal>&gt;</literal>) comparison between elements.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var numbers = [10, 5, 2.5, 8]
numbers.sort()
print(numbers) # Prints [2.5, 5, 8, 10]</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var numbers = new Godot.Collections.Array { 10, 5, 2.5, 8 };
numbers.Sort();
GD.Print(numbers); // Prints [2.5, 5, 8, 10]</literal_block>
                </div>
            </container>
            <paragraph><strong>Note:</strong> The sorting algorithm used is not <reference name="stable" refuri="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">stable</reference>. This means that equivalent elements (such as <literal>2</literal> and <literal>2.0</literal>) may have their order changed when calling <reference internal="True" refid="class-array-method-sort"><inline classes="std std-ref">sort</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-method-sort-custom"></target>
            <paragraph classes="classref-method" ids="class-array-method-sort-custom" names="class_array_method_sort_custom"><abbreviation explanation="无返回值。">void</abbreviation> <strong>sort_custom</strong>(func: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <reference internal="True" refid="class-array-method-sort-custom"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Sorts the array using a custom <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>.</paragraph>
            <paragraph><literal>func</literal> is called as many times as necessary, receiving two array elements as arguments. The function should return <literal>true</literal> if the first element should be moved <emphasis>behind</emphasis> the second one, otherwise it should return <literal>false</literal>.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func sort_ascending(a, b):
    if a[1] &lt; b[1]:
        return true
    return false

func _ready():
    var my_items = [["Tomato", 5], ["Apple", 9], ["Rice", 4]]
    my_items.sort_custom(sort_ascending)
    print(my_items) # Prints [["Rice", 4], ["Tomato", 5], ["Apple", 9]]

    # Sort descending, using a lambda function.
    my_items.sort_custom(func(a, b): return a[0] &gt; b[0])
    print(my_items) # Prints [["Apple", 9], ["Tomato", 5], ["Rice", 4]]</literal_block>
            <paragraph>It may also be necessary to use this method to sort strings by natural order, with <reference internal="True" refuri="class_string#class-string-method-naturalnocasecmp-to"><inline classes="std std-ref">String.naturalnocasecmp_to</inline></reference>, as in the following example:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var files = ["newfile1", "newfile2", "newfile10", "newfile11"]
files.sort_custom(func(a, b): return a.naturalnocasecmp_to(b) &lt; 0)
print(files) # Prints ["newfile1", "newfile2", "newfile10", "newfile11"]</literal_block>
            <paragraph><strong>Note:</strong> In C#, this method is not supported.</paragraph>
            <paragraph><strong>Note:</strong> The sorting algorithm used is not <reference name="stable" refuri="https://en.wikipedia.org/wiki/Sorting_algorithm#Stability">stable</reference>. This means that values considered equal may have their order changed when calling this method.</paragraph>
            <paragraph><strong>Note:</strong> You should not randomize the return value of <literal>func</literal>, as the heapsort algorithm expects a consistent result. Randomizing the return value will result in unexpected behavior.</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id7" names="运算符说明">
            <title>运算符说明</title>
            <target refid="class-array-operator-neq-array"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-neq-array" names="class_array_operator_neq_array"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-operator-neq-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the array's size or its elements are different than <literal>right</literal>'s.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-operator-sum-array"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-sum-array" names="class_array_operator_sum_array"><reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference> <strong>operator +</strong>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-operator-sum-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Appends the <literal>right</literal> array to the left operand, creating a new <strong>Array</strong>. This is also known as an array concatenation.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var array1 = ["One", 2]
var array2 = [3, "Four"]
print(array1 + array2) # Prints ["One", 2, 3, "Four"]</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Note that concatenation is not possible with C#'s native Array type.
var array1 = new Godot.Collections.Array{"One", 2};
var array2 = new Godot.Collections.Array{3, "Four"};
GD.Print(array1 + array2); // Prints ["One", 2, 3, "Four"]</literal_block>
                </div>
            </container>
            <paragraph><strong>Note:</strong> For existing arrays, <reference internal="True" refid="class-array-method-append-array"><inline classes="std std-ref">append_array</inline></reference> is much more efficient than concatenation and assignment with the <literal>+=</literal> operator.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-operator-lt-array"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-lt-array" names="class_array_operator_lt_array"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &lt;</strong>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-operator-lt-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Compares the elements of both arrays in order, starting from index <literal>0</literal> and ending on the last index in common between both arrays. For each pair of elements, returns <literal>true</literal> if this array's element is less than <literal>right</literal>'s, <literal>false</literal> if this element is greater. Otherwise, continues to the next pair.</paragraph>
            <paragraph>If all searched elements are equal, returns <literal>true</literal> if this array's size is less than <literal>right</literal>'s, otherwise returns <literal>false</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-operator-lte-array"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-lte-array" names="class_array_operator_lte_array"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &lt;=</strong>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-operator-lte-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Compares the elements of both arrays in order, starting from index <literal>0</literal> and ending on the last index in common between both arrays. For each pair of elements, returns <literal>true</literal> if this array's element is less than <literal>right</literal>'s, <literal>false</literal> if this element is greater. Otherwise, continues to the next pair.</paragraph>
            <paragraph>If all searched elements are equal, returns <literal>true</literal> if this array's size is less or equal to <literal>right</literal>'s, otherwise returns <literal>false</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-operator-eq-array"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-eq-array" names="class_array_operator_eq_array"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-operator-eq-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将左操作数 <strong>Array</strong> 与 <literal>right</literal> <strong>Array</strong> 进行比较。如果数组的大小和内容相等，则返回 <literal>true</literal>，否则返回 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-operator-gt-array"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-gt-array" names="class_array_operator_gt_array"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &gt;</strong>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-operator-gt-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Compares the elements of both arrays in order, starting from index <literal>0</literal> and ending on the last index in common between both arrays. For each pair of elements, returns <literal>true</literal> if this array's element is greater than <literal>right</literal>'s, <literal>false</literal> if this element is less. Otherwise, continues to the next pair.</paragraph>
            <paragraph>If all searched elements are equal, returns <literal>true</literal> if this array's size is greater than <literal>right</literal>'s, otherwise returns <literal>false</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-operator-gte-array"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-gte-array" names="class_array_operator_gte_array"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &gt;=</strong>(right: <reference internal="True" refid="class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-array-operator-gte-array"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Compares the elements of both arrays in order, starting from index <literal>0</literal> and ending on the last index in common between both arrays. For each pair of elements, returns <literal>true</literal> if this array's element is greater than <literal>right</literal>'s, <literal>false</literal> if this element is less. Otherwise, continues to the next pair.</paragraph>
            <paragraph>If all searched elements are equal, returns <literal>true</literal> if this array's size is greater or equal to <literal>right</literal>'s, otherwise returns <literal>false</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-array-operator-idx-int"></target>
            <paragraph classes="classref-operator" ids="class-array-operator-idx-int" names="class_array_operator_idx_int"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>operator []</strong>(index: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-array-operator-idx-int"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> element at the specified <literal>index</literal>. Arrays start at index 0. If <literal>index</literal> is greater or equal to <literal>0</literal>, the element is fetched starting from the beginning of the array. If <literal>index</literal> is a negative value, the element is fetched starting from the end. Accessing an array out-of-bounds will cause a run-time error, pausing the project execution if run from the editor.</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了能接受在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效运算符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列位标志构成位掩码的整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="void"><abbreviation explanation="无返回值。">void</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
