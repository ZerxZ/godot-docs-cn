<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_regex.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/4.2/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/4.2/modules/regex/doc_classes/RegEx.xml.</comment>
    <target refid="class-regex"></target>
    <section ids="regex class-regex" names="regex class_regex">
        <title>RegEx</title>
        <paragraph><strong>继承：</strong> <reference internal="True" refuri="class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> <strong>&lt;</strong> <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference></paragraph>
        <paragraph>使用正则表达式搜索文本的类。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>正则表达式（或称 regex）是一种紧凑的语言，可用于识别遵循特定模式的字符串，如 URL、电子邮件地址、完整句子等。例如正则表达式 <literal>ab[0-9]</literal> 可以找到 <literal>ab</literal> 后面跟着 <literal>0</literal> 到 <literal>9</literal> 的任何数字的字符串。要想更深入地了解，你可以很容易地在互联网上找到各种教程和详细解释。</paragraph>
            <paragraph>首先，在使用 RegEx 对象之前，需要用 <reference internal="True" refid="class-regex-method-compile"><inline classes="std std-ref">compile</inline></reference> 对其进行搜索模式的编译。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var regex = RegEx.new()
regex.compile("\\w-(\\d+)")</literal_block>
            <paragraph>在为表达式转义之前，必须先为 GDScript 转义搜索模式。例如，<literal>compile("\\d+")</literal> 会被 RegEx 读成 <literal>\d+</literal>。同样，<literal>compile("\"(?:\\\\.|[^\"])*\")</literal> 会被读作 <literal>"(?:\.|[^"])*"</literal>。在 GDScript 中，你还可以使用原始字符串文字（r-字符串）。例如，<literal>compile(r'"(?:\\.|[^"])*"')</literal> 将被读取为相同的。</paragraph>
            <paragraph>使用 <reference internal="True" refid="class-regex-method-search"><inline classes="std std-ref">search</inline></reference>，你可以在给定的文本中匹配模式。如果匹配到一个模式，将返回 <reference internal="True" refuri="class_regexmatch#class-regexmatch"><inline classes="std std-ref">RegExMatch</inline></reference>，你可以使用 <reference internal="True" refuri="class_regexmatch#class-regexmatch-method-get-string"><inline classes="std std-ref">RegExMatch.get_string</inline></reference> 和 <reference internal="True" refuri="class_regexmatch#class-regexmatch-method-get-start"><inline classes="std std-ref">RegExMatch.get_start</inline></reference> 等方法检索结果的细节。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var regex = RegEx.new()
regex.compile("\\w-(\\d+)")
var result = regex.search("abc n-0123")
if result:
    print(result.get_string()) # 会输出 n-0123</literal_block>
            <paragraph>捕获组的结果 <literal>()</literal> 可以通过向 <reference internal="True" refuri="class_regexmatch#class-regexmatch"><inline classes="std std-ref">RegExMatch</inline></reference> 中的各种方法传递组号来检索。默认是组 0，并且将总是指整个模式。在上面的例子中，调用 <literal>result.get_string(1)</literal> 会得到 <literal>0123</literal>。</paragraph>
            <paragraph>这个版本的 RegEx 也支持命名的捕获组，名称可以用来检索结果。如果两个或更多的组有相同的名称，那么这个名称将只指第一个有匹配的组。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var regex = RegEx.new()
regex.compile("d(?&lt;digit&gt;[0-9]+)|x(?&lt;digit&gt;[0-9a-f]+)")
var result = regex.search("数字是 x2f")
if result:
    print(result.get_string("digit")) # 会输出 2f</literal_block>
            <paragraph>如果你需要处理多个结果，<reference internal="True" refid="class-regex-method-search-all"><inline classes="std std-ref">search_all</inline></reference> 会生成一个所有不重叠的结果列表。为了方便起见，这可以和一个 <literal>for</literal> 循环结合起来。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">for result in regex.search_all("d01, d03, d0c, x3f and x42"):
    print(result.get_string("digit"))
# 会输出 01 03 0 3f 42</literal_block>
            <paragraph><strong>使用 RegEx 分割字符串的例子：</strong></paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var regex = RegEx.new()
regex.compile("\\S+") # 非空白字符类。
var results = []
for result in regex.search_all("One  Two \n\tThree"):
    results.push_back(result.get_string())
# `results` 数组包含 "One"、"Two"、"Three"。</literal_block>
            <paragraph><strong>注意：</strong>Godot 的 regex 实现基于的是 <reference name="PCRE2" refuri="https://www.pcre.org/">PCRE2</reference>。你可以查看完整的模式参考<reference name="这里" refuri="https://www.pcre.org/current/doc/html/pcre2pattern.html">这里</reference>。</paragraph>
            <paragraph><strong>提示：</strong>你可以使用 <reference name="Regexr" refuri="https://regexr.com/">Regexr</reference> 来在线测试正则表达式。</paragraph>
        </section>
        <section classes="classref-reftable-group" ids="id2" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="51"></colspec>
                    <colspec colwidth="230"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-regex-method-clear"><inline classes="std std-ref">clear</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-regex-method-compile"><inline classes="std std-ref">compile</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> pattern <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-regex"><inline classes="std std-ref">RegEx</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-regex-method-create-from-string"><inline classes="std std-ref">create_from_string</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> pattern <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-regex-method-get-group-count"><inline classes="std std-ref">get_group_count</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-regex-method-get-names"><inline classes="std std-ref">get_names</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-regex-method-get-pattern"><inline classes="std std-ref">get_pattern</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-regex-method-is-valid"><inline classes="std std-ref">is_valid</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_regexmatch#class-regexmatch"><inline classes="std std-ref">RegExMatch</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-regex-method-search"><inline classes="std std-ref">search</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> subject, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> offset=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> end=-1 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_regexmatch#class-regexmatch"><inline classes="std std-ref">RegExMatch[]</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-regex-method-search-all"><inline classes="std std-ref">search_all</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> subject, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> offset=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> end=-1 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-regex-method-sub"><inline classes="std std-ref">sub</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> subject, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> replacement, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> all=false, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> offset=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> end=-1 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id3" names="方法说明">
            <title>方法说明</title>
            <target refid="class-regex-method-clear"></target>
            <paragraph classes="classref-method" ids="class-regex-method-clear" names="class_regex_method_clear">void <strong>clear</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>这个方法重置了对象的状态，就像它是新创建的一样。也就是说，它取消了这个对象的正则表达式的赋值。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-regex-method-compile"></target>
            <paragraph classes="classref-method" ids="class-regex-method-compile" names="class_regex_method_compile"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>compile</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> pattern <strong>)</strong></paragraph>
            <paragraph>编译并指定要使用的搜索模式。如果编译成功，返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-ok"><inline classes="std std-ref">@GlobalScope.OK</inline></reference>。如果遇到错误，细节将被打印到标准输出，并返回一个错误。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-regex-method-create-from-string"></target>
            <paragraph classes="classref-method" ids="class-regex-method-create-from-string" names="class_regex_method_create_from_string"><reference internal="True" refid="class-regex"><inline classes="std std-ref">RegEx</inline></reference> <strong>create_from_string</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> pattern <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>创建并编译新 <strong>RegEx</strong> 对象。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-regex-method-get-group-count"></target>
            <paragraph classes="classref-method" ids="class-regex-method-get-group-count" names="class_regex_method_get_group_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_group_count</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回编译模式中捕获组的数量。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-regex-method-get-names"></target>
            <paragraph classes="classref-method" ids="class-regex-method-get-names" names="class_regex_method_get_names"><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> <strong>get_names</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回一个数组，该数组是编译模式中命名的捕获组的名称。它们是按外观排序的。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-regex-method-get-pattern"></target>
            <paragraph classes="classref-method" ids="class-regex-method-get-pattern" names="class_regex_method_get_pattern"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_pattern</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回被编译的原始搜索模式。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-regex-method-is-valid"></target>
            <paragraph classes="classref-method" ids="class-regex-method-is-valid" names="class_regex_method_is_valid"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回此对象是否分配了有效的搜索模式。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-regex-method-search"></target>
            <paragraph classes="classref-method" ids="class-regex-method-search" names="class_regex_method_search"><reference internal="True" refuri="class_regexmatch#class-regexmatch"><inline classes="std std-ref">RegExMatch</inline></reference> <strong>search</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> subject, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> offset=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> end=-1 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>在文本中搜索编译后的模式。如果找到，则将首个匹配结果放在 <reference internal="True" refuri="class_regexmatch#class-regexmatch"><inline classes="std std-ref">RegExMatch</inline></reference> 容器中返回，否则返回 <literal>null</literal>。</paragraph>
            <paragraph>可以使用 <literal>offset</literal> 和 <literal>end</literal> 指定要搜索的区域。这对在上一次成功后再次调用该方法，以相同的 <literal>subject</literal> 搜索另一个匹配项时很有用。请注意，设置这些参数不同于传递缩短后的字符串。例如，起始锚点 <literal>^</literal> 不受 <literal>offset</literal> 的影响，会为单词边界 <literal>\b</literal> 检查 <literal>offset</literal> 之前的字符。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-regex-method-search-all"></target>
            <paragraph classes="classref-method" ids="class-regex-method-search-all" names="class_regex_method_search_all"><reference internal="True" refuri="class_regexmatch#class-regexmatch"><inline classes="std std-ref">RegExMatch[]</inline></reference> <strong>search_all</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> subject, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> offset=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> end=-1 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>在文本中搜索编译后的模式。返回 <reference internal="True" refuri="class_regexmatch#class-regexmatch"><inline classes="std std-ref">RegExMatch</inline></reference> 容器的数组，其中每个容器包含的是互不重叠的匹配结果。如果没有找到结果，则返回一个空数组。</paragraph>
            <paragraph>可以使用 <literal>offset</literal> 和 <literal>end</literal> 指定要搜索的区域。这对在上一次成功后再次调用该方法，以相同的 <literal>subject</literal> 搜索另一个匹配项时很有用。请注意，设置这些参数不同于传递缩短后的字符串。例如，起始锚点 <literal>^</literal> 不受 <literal>offset</literal> 的影响，会为单词边界 <literal>\b</literal> 检查 <literal>offset</literal> 之前的字符。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-regex-method-sub"></target>
            <paragraph classes="classref-method" ids="class-regex-method-sub" names="class_regex_method_sub"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>sub</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> subject, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> replacement, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> all=false, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> offset=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> end=-1 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>在文本中搜索编译后的模式，并将其替换为指定的字符串。诸如 <literal>$1</literal> 和 <literal>$name</literal> 等转义和反向引用会被扩展和解析。默认情况下，只有第一个实例被替换，但可以修改为针对所有实例（全局替换）。</paragraph>
            <paragraph>可以使用 <literal>offset</literal> 和 <literal>end</literal> 指定要搜索的区域。这对在上一次成功后再次调用该方法，以相同的 <literal>subject</literal> 搜索另一个匹配项时很有用。请注意，设置这些参数不同于传递缩短后的字符串。例如，起始锚点 <literal>^</literal> 不受 <literal>offset</literal> 的影响，会为单词边界 <literal>\b</literal> 检查 <literal>offset</literal> 之前的字符。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
