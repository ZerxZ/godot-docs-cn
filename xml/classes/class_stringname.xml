<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_stringname.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/4.2/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/4.2/doc/classes/StringName.xml.</comment>
    <target refid="class-stringname"></target>
    <section ids="stringname class-stringname" names="stringname class_stringname">
        <title>StringName</title>
        <paragraph>唯一字符串内置类型。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph><strong>StringName</strong> 是不可变的字符串，用于唯一名称的通用表示（也叫“字符串内嵌”）。值相同的两个 <strong>StringName</strong> 是同一个对象。进行比较时比普通 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> 要快很多。</paragraph>
            <paragraph>对于需要 <strong>StringName</strong> 的方法，你通常可以只传 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>，会自动进行转换，不过有时候你可能会想要提前使用 <strong>StringName</strong> 构造函数来构造 <strong>StringName</strong>，在 GDScript 中也可以用 <literal>&amp;"example"</literal> 语法。</paragraph>
            <paragraph>另见 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>，这是与此类似的概念，针对存储预解析的场景树路径设计。</paragraph>
            <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> 的所有方法都在这个类中可用。它们会将 <strong>StringName</strong> 转换为字符串，返回的也是字符串。这样做效率非常低，应该只在需要字符串时使用。</paragraph>
            <paragraph><strong>注意：</strong>在 C# 中，需要显式转换为 <literal>System.String</literal> 才能使用本页列出的方法。使用 <literal>ToString()</literal> 方法将 <strong>StringName</strong> 转换为字符串，然后使用 <literal>System.String</literal> 或 <literal>StringExtensions</literal> 中的等效方法。</paragraph>
            <paragraph><strong>注意：</strong>转换为布尔值时，空的 <strong>StringName</strong>（<literal>StringName("")</literal>）为 <literal>false</literal>，其他 <strong>StringName</strong> 均为 <literal>true</literal>。不能使用 <literal>not</literal> 运算符。请改用 <reference internal="True" refid="class-stringname-method-is-empty"><inline classes="std std-ref">is_empty</inline></reference> 来检查空的 <strong>StringName</strong>。</paragraph>
            <note>
                <paragraph>通过 C# 使用这个 API 时有显著的不同。详见 <reference internal="True" refuri="../tutorials/scripting/c_sharp/c_sharp_differences#doc-c-sharp-differences"><inline classes="std std-ref">C# API 与 GDScript 的差异</inline></reference>。</paragraph>
            </note>
        </section>
        <section classes="classref-reftable-group" ids="id2" names="构造函数">
            <title>构造函数</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="37"></colspec>
                    <colspec colwidth="113"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-constructor-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-constructor-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> from <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-constructor-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> from <strong>)</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="53"></colspec>
                    <colspec colwidth="184"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-begins-with"><inline classes="std std-ref">begins_with</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> text <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-bigrams"><inline classes="std std-ref">bigrams</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-bin-to-int"><inline classes="std std-ref">bin_to_int</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-c-escape"><inline classes="std std-ref">c_escape</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-c-unescape"><inline classes="std std-ref">c_unescape</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-capitalize"><inline classes="std std-ref">capitalize</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-casecmp-to"><inline classes="std std-ref">casecmp_to</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> to <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-contains"><inline classes="std std-ref">contains</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-count"><inline classes="std std-ref">count</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> from=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> to=0 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-countn"><inline classes="std std-ref">countn</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> from=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> to=0 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-dedent"><inline classes="std std-ref">dedent</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-ends-with"><inline classes="std std-ref">ends_with</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> text <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-erase"><inline classes="std std-ref">erase</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> position, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> chars=1 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-find"><inline classes="std std-ref">find</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> from=0 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-findn"><inline classes="std std-ref">findn</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> from=0 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-format"><inline classes="std std-ref">format</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> values, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> placeholder="{_}" <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-get-base-dir"><inline classes="std std-ref">get_base_dir</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-get-basename"><inline classes="std std-ref">get_basename</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-get-extension"><inline classes="std std-ref">get_extension</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-get-file"><inline classes="std std-ref">get_file</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-get-slice"><inline classes="std std-ref">get_slice</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> delimiter, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> slice <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-get-slice-count"><inline classes="std std-ref">get_slice_count</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> delimiter <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-get-slicec"><inline classes="std std-ref">get_slicec</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> delimiter, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> slice <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-hash"><inline classes="std std-ref">hash</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-hex-decode"><inline classes="std std-ref">hex_decode</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-hex-to-int"><inline classes="std std-ref">hex_to_int</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-indent"><inline classes="std std-ref">indent</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> prefix <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-insert"><inline classes="std std-ref">insert</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> position, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-is-absolute-path"><inline classes="std std-ref">is_absolute_path</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-is-empty"><inline classes="std std-ref">is_empty</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-is-relative-path"><inline classes="std std-ref">is_relative_path</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-is-subsequence-of"><inline classes="std std-ref">is_subsequence_of</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> text <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-is-subsequence-ofn"><inline classes="std std-ref">is_subsequence_ofn</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> text <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-is-valid-filename"><inline classes="std std-ref">is_valid_filename</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-is-valid-float"><inline classes="std std-ref">is_valid_float</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-is-valid-hex-number"><inline classes="std std-ref">is_valid_hex_number</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> with_prefix=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-is-valid-html-color"><inline classes="std std-ref">is_valid_html_color</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-is-valid-identifier"><inline classes="std std-ref">is_valid_identifier</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-is-valid-int"><inline classes="std std-ref">is_valid_int</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-is-valid-ip-address"><inline classes="std std-ref">is_valid_ip_address</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-join"><inline classes="std std-ref">join</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> parts <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-json-escape"><inline classes="std std-ref">json_escape</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-left"><inline classes="std std-ref">left</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> length <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-length"><inline classes="std std-ref">length</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-lpad"><inline classes="std std-ref">lpad</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> min_length, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> character=" " <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-lstrip"><inline classes="std std-ref">lstrip</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> chars <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-match"><inline classes="std std-ref">match</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> expr <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-matchn"><inline classes="std std-ref">matchn</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> expr <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-md5-buffer"><inline classes="std std-ref">md5_buffer</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-md5-text"><inline classes="std std-ref">md5_text</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-naturalcasecmp-to"><inline classes="std std-ref">naturalcasecmp_to</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> to <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-naturalnocasecmp-to"><inline classes="std std-ref">naturalnocasecmp_to</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> to <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-nocasecmp-to"><inline classes="std std-ref">nocasecmp_to</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> to <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-pad-decimals"><inline classes="std std-ref">pad_decimals</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> digits <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-pad-zeros"><inline classes="std std-ref">pad_zeros</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> digits <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-path-join"><inline classes="std std-ref">path_join</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> file <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-repeat"><inline classes="std std-ref">repeat</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> count <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-replace"><inline classes="std std-ref">replace</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> forwhat <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-replacen"><inline classes="std std-ref">replacen</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> forwhat <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-reverse"><inline classes="std std-ref">reverse</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-rfind"><inline classes="std std-ref">rfind</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> from=-1 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-rfindn"><inline classes="std std-ref">rfindn</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> from=-1 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-right"><inline classes="std std-ref">right</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> length <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-rpad"><inline classes="std std-ref">rpad</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> min_length, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> character=" " <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-rsplit"><inline classes="std std-ref">rsplit</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> delimiter="", <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> allow_empty=true, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> maxsplit=0 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-rstrip"><inline classes="std std-ref">rstrip</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> chars <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-sha1-buffer"><inline classes="std std-ref">sha1_buffer</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-sha1-text"><inline classes="std std-ref">sha1_text</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-sha256-buffer"><inline classes="std std-ref">sha256_buffer</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-sha256-text"><inline classes="std std-ref">sha256_text</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-similarity"><inline classes="std std-ref">similarity</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> text <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-simplify-path"><inline classes="std std-ref">simplify_path</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-split"><inline classes="std std-ref">split</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> delimiter="", <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> allow_empty=true, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> maxsplit=0 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-split-floats"><inline classes="std std-ref">split_floats</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> delimiter, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> allow_empty=true <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-strip-edges"><inline classes="std std-ref">strip_edges</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> left=true, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> right=true <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-strip-escapes"><inline classes="std std-ref">strip_escapes</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-substr"><inline classes="std std-ref">substr</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> from, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> len=-1 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-to-ascii-buffer"><inline classes="std std-ref">to_ascii_buffer</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-to-camel-case"><inline classes="std std-ref">to_camel_case</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-to-float"><inline classes="std std-ref">to_float</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-to-int"><inline classes="std std-ref">to_int</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-to-lower"><inline classes="std std-ref">to_lower</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-to-pascal-case"><inline classes="std std-ref">to_pascal_case</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-to-snake-case"><inline classes="std std-ref">to_snake_case</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-to-upper"><inline classes="std std-ref">to_upper</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-to-utf8-buffer"><inline classes="std std-ref">to_utf8_buffer</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-to-utf16-buffer"><inline classes="std std-ref">to_utf16_buffer</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-to-utf32-buffer"><inline classes="std std-ref">to_utf32_buffer</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-to-wchar-buffer"><inline classes="std std-ref">to_wchar_buffer</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-trim-prefix"><inline classes="std std-ref">trim_prefix</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> prefix <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-trim-suffix"><inline classes="std std-ref">trim_suffix</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> suffix <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-unicode-at"><inline classes="std std-ref">unicode_at</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> at <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-uri-decode"><inline classes="std std-ref">uri_decode</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-uri-encode"><inline classes="std std-ref">uri_encode</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-validate-filename"><inline classes="std std-ref">validate_filename</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-validate-node-name"><inline classes="std std-ref">validate_node_name</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-xml-escape"><inline classes="std std-ref">xml_escape</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> escape_quotes=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-method-xml-unescape"><inline classes="std std-ref">xml_unescape</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id4" names="操作符">
            <title>操作符</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="29"></colspec>
                    <colspec colwidth="117"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-operator-neq-string"><inline classes="std std-ref">operator !=</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-operator-neq-stringname"><inline classes="std std-ref">operator !=</inline></reference> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-operator-mod-variant"><inline classes="std std-ref">operator %</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-operator-sum-string"><inline classes="std std-ref">operator +</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-operator-sum-stringname"><inline classes="std std-ref">operator +</inline></reference> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-operator-lt-stringname"><inline classes="std std-ref">operator &lt;</inline></reference> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-operator-lte-stringname"><inline classes="std std-ref">operator &lt;=</inline></reference> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-operator-eq-string"><inline classes="std std-ref">operator ==</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-operator-eq-stringname"><inline classes="std std-ref">operator ==</inline></reference> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-operator-gt-stringname"><inline classes="std std-ref">operator &gt;</inline></reference> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-stringname-operator-gte-stringname"><inline classes="std std-ref">operator &gt;=</inline></reference> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id5" names="构造函数说明">
            <title>构造函数说明</title>
            <target refid="class-stringname-constructor-stringname"></target>
            <paragraph classes="classref-constructor" ids="class-stringname-constructor-stringname" names="class_stringname_constructor_stringname"><reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>StringName</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>构造空的 <strong>StringName</strong>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>StringName</strong> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> from <strong>)</strong></paragraph>
            <paragraph>构造给定 <strong>StringName</strong> 的副本。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>StringName</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> from <strong>)</strong></paragraph>
            <paragraph>从给定的 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> 创建 <strong>StringName</strong>。在 GDScript 中，<literal>StringName("example")</literal> 与 <literal>&amp;"example"</literal> 等价。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id6" names="方法说明">
            <title>方法说明</title>
            <target refid="class-stringname-method-begins-with"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-begins-with" names="class_stringname_method_begins_with"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>begins_with</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> text <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串以给定的 <literal>text</literal> 开始，则返回 <literal>true</literal>。另见 <reference internal="True" refid="class-stringname-method-ends-with"><inline classes="std std-ref">ends_with</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-bigrams"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-bigrams" names="class_stringname_method_bigrams"><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> <strong>bigrams</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回包含该字符串的双字母组（连续字母的组合）的数组。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("Get up!".bigrams()) # 输出 ["Ge", "et", "t ", " u", "up", "p!"]</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-bin-to-int"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-bin-to-int" names="class_stringname_method_bin_to_int"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>bin_to_int</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将表示二进制数的字符串转换为 <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>。该字符串可以前缀 <literal>"0b"</literal>，负数可以前缀 <literal>-</literal>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">print("101".bin_to_int())   # 输出 5
print("0b101".bin_to_int()) # 输出 5
print("-0b10".bin_to_int()) # 输出 -2</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GD.Print("101".BinToInt());   // 输出 5
GD.Print("0b101".BinToInt()); // 输出 5
GD.Print("-0b10".BinToInt()); // 输出 -2</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-c-escape"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-c-escape" names="class_stringname_method_c_escape"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>c_escape</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串的副本，按照 C 语言标准对特殊字符进行转义。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-c-unescape"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-c-unescape" names="class_stringname_method_c_unescape"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>c_unescape</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串的副本，转义字符均使用本义代替。支持的转义序列有 <literal>\'</literal>、<literal>\"</literal>、<literal>\\</literal>、<literal>\a</literal>、<literal>\b</literal>、<literal>\f</literal>、<literal>\n</literal>、<literal>\r</literal>、<literal>\t</literal>、<literal>\v</literal>。</paragraph>
            <paragraph><strong>注意：</strong>与 GDScript 解析器不同，这个方法不支持 <literal>\uXXXX</literal> 转义序列。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-capitalize"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-capitalize" names="class_stringname_method_capitalize"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>capitalize</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>改变字符串的外观：用空格代替下划线（<literal>_</literal>），在单词中间的大写字母前添加空格，将所有字母转换为小写，然后将第一个字母和空格后的每个字母转换为大写。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">"move_local_x".capitalize()   # 返回 "Move Local X"
"sceneFile_path".capitalize() # 返回 "Scene File Path"
"2D, FPS, PNG".capitalize()   # 返回 "2d, Fps, Png"</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">"move_local_x".Capitalize();   // 返回 "Move Local X"
"sceneFile_path".Capitalize(); // 返回 "Scene File Path"
"2D, FPS, PNG".Capitalize();   // 返回 "2d, Fps, Png"</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-casecmp-to"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-casecmp-to" names="class_stringname_method_casecmp_to"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>casecmp_to</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> to <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>与另一个字符串进行比较，区分大小写。小于时返回 <literal>-1</literal>、大于时返回 <literal>1</literal>、等于时返回 <literal>0</literal>。“小于”和“大于”比较的是字符串中的 <reference name="Unicode 码位" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 码位</reference>，大致与字母表顺序一致。</paragraph>
            <paragraph>如果字符串长度不同，这个字符串比 <literal>to</literal> 字符串长时返回 <literal>1</literal>，短时返回 <literal>-1</literal>。请注意空字符串的长度<emphasis>始终</emphasis>为 <literal>0</literal>。</paragraph>
            <paragraph>如果想在比较字符串时获得 <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> 返回值，请改用 <literal>==</literal> 运算符。另见 <reference internal="True" refid="class-stringname-method-nocasecmp-to"><inline classes="std std-ref">nocasecmp_to</inline></reference>、<reference internal="True" refid="class-stringname-method-naturalcasecmp-to"><inline classes="std std-ref">naturalcasecmp_to</inline></reference> 和 <reference internal="True" refid="class-stringname-method-naturalnocasecmp-to"><inline classes="std std-ref">naturalnocasecmp_to</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-contains"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-contains" names="class_stringname_method_contains"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>contains</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串包含 <literal>what</literal>，则返回 <literal>true</literal>。在 GDScript 中对应 <literal>in</literal> 运算符。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">print("Node".contains("de")) # 输出 true
print("team".contains("I"))  # 输出 false
print("I" in "team")         # 输出 false</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GD.Print("Node".Contains("de")); // 输出 true
GD.Print("team".Contains("I"));  // 输出 false</literal_block>
                </div>
            </container>
            <paragraph>如果想要知道 <literal>what</literal> 在该字符串中的位置，请使用 <reference internal="True" refid="class-stringname-method-find"><inline classes="std std-ref">find</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-count"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-count" names="class_stringname_method_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>count</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> from=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> to=0 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回子串 <literal>what</literal> 在 <literal>from</literal> 和 <literal>to</literal> 位置之间出现的次数。如果 <literal>to</literal> 为 0，会在剩余字符串中继续搜索。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-countn"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-countn" names="class_stringname_method_countn"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>countn</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> from=0, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> to=0 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回子串 <literal>what</literal> 在 <literal>from</literal> 和 <literal>to</literal> 位置之间出现的次数，<strong>忽略大小写</strong>。如果 <literal>to</literal> 为 0，会在剩余字符串中继续搜索。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-dedent"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-dedent" names="class_stringname_method_dedent"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>dedent</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回删除了缩进（前导制表符和空格）的字符串副本。添加缩进请参阅 <reference internal="True" refid="class-stringname-method-indent"><inline classes="std std-ref">indent</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-ends-with"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-ends-with" names="class_stringname_method_ends_with"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>ends_with</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> text <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串以给定的 <literal>text</literal> 结束，则返回 <literal>true</literal>。另见 <reference internal="True" refid="class-stringname-method-begins-with"><inline classes="std std-ref">begins_with</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-erase"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-erase" names="class_stringname_method_erase"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>erase</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> position, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> chars=1 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回从 <literal>position</literal> 开始擦除 <literal>chars</literal> 个字符后的字符串。如果在指定 <literal>position</literal> 的基础上 <literal>chars</literal> 超过字符串的长度，返回的字符串中擦除的字符数会少于请求的数量。如果 <literal>position</literal> 或 <literal>chars</literal> 为负数，则返回空字符串。如果 <literal>chars</literal> 为 <literal>0</literal> 则返回原字符串，不进行修改。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-find"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-find" names="class_stringname_method_find"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>find</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> from=0 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回 <literal>what</literal> 在该字符串中<strong>第一次</strong>出现的索引，如果不存在则返回 <literal>-1</literal>。搜索的起点可以用 <literal>from</literal> 指定，持续到字符串结尾。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">print("Team".find("I")) # 输出 -1

print("Potato".find("t"))    # 输出 2
print("Potato".find("t", 3)) # 输出 4
print("Potato".find("t", 5)) # 输出 -1</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GD.Print("Team".Find("I")); // 输出 -1

GD.Print("Potato".Find("t"));    // 输出 2
GD.Print("Potato".Find("t", 3)); // 输出 4
GD.Print("Potato".Find("t", 5)); // 输出 -1</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>如果你只是想要知道该字符串中是否包含 <literal>what</literal>，请使用 <reference internal="True" refid="class-stringname-method-contains"><inline classes="std std-ref">contains</inline></reference>。在 GDScript 中，你还可以使用 <literal>in</literal> 运算符。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-findn"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-findn" names="class_stringname_method_findn"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>findn</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> from=0 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回这个字符串中 <literal>what</literal> <strong>首次</strong>出现的索引，<strong>不区分大小写</strong>，不存在时则为 <literal>-1</literal>。搜索的起点可以用 <literal>from</literal> 指定，终点为该字符串的末尾。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-format"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-format" names="class_stringname_method_format"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>format</strong> <strong>(</strong> <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> values, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> placeholder="{_}" <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>通过将所有出现的 <literal>placeholder</literal> 替换为 <literal>values</literal> 的元素来格式化字符串。</paragraph>
            <paragraph><literal>values</literal> 可以是 <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> 或 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>。<literal>placeholder</literal> 中的任何下划线将被预先被替换为对应的键。数组元素使用它们的索引作为键。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># 输出：Waiting for Godot 是 Samuel Beckett 的戏剧，Godot 引擎由此得名。
var use_array_values = "Waiting for {0} 是 {1} 的戏剧，{0} 引擎由此得名。"
print(use_array_values.format(["Godot", "Samuel Beckett"]))

# 输出：第 42 号用户是 Godot。
print("第 {id} 号用户是 {name}。".format({"id": 42, "name": "Godot"}))</literal_block>
            <paragraph>当 <literal>values</literal> 是 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> 时还会执行一些额外的处理。 如果 <literal>placeholder</literal> 不包含下划线，则 <literal>values</literal> 数组的元素将用于按顺序替换出现的占位符；如果 <literal>values</literal> 的元素是另一个 2 元素数组，则它将被解释为键值对。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># 输出：第 42 号用户是 Godot。
print("第 {} 号用户是 {}。".format([42, "Godot"], "{}"))
print("第 {id} 号用户是 {name}。".format([["id", 42], ["name", "Godot"]]))</literal_block>
            <paragraph>另请参阅 <reference internal="True" refuri="../tutorials/scripting/gdscript/gdscript_format_string"><inline classes="doc">GDScript 格式化字符串</inline></reference>教程。</paragraph>
            <paragraph><strong>注意：</strong>在 C# 中推荐改为<reference name="使用“$”插入字符串" refuri="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated">使用“$”插入字符串</reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-get-base-dir"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-get-base-dir" names="class_stringname_method_get_base_dir"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_base_dir</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串是有效的文件路径，则返回基础目录名称。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var dir_path = "/path/to/file.txt".get_base_dir() # dir_path 为 "/path/to"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-get-basename"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-get-basename" names="class_stringname_method_get_basename"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_basename</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串是有效的文件路径，则返回完整文件路径，不包括扩展名。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var base = "/path/to/file.txt".get_basename() # base 为 "/path/to/file"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-get-extension"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-get-extension" names="class_stringname_method_get_extension"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_extension</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串是有效的文件名或路径，则返回该文件的扩展名，不含开头的点号（<literal>.</literal>）。否则返回空字符串。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a = "/path/to/file.txt".get_extension() # a 为 "txt"
var b = "cool.txt".get_extension()          # b 为 "txt"
var c = "cool.font.tres".get_extension()    # c 为 "tres"
var d = ".pack1".get_extension()            # d 为 "pack1"

var e = "file.txt.".get_extension()  # e 为 ""
var f = "file.txt..".get_extension() # f 为 ""
var g = "txt".get_extension()        # g 为 ""
var h = "".get_extension()           # h 为 ""</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-get-file"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-get-file" names="class_stringname_method_get_file"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_file</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串是有效的文件路径，则返回文件名，包括扩展名。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var file = "/path/to/icon.png".get_file() # file 为 "icon.png"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-get-slice"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-get-slice" names="class_stringname_method_get_slice"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_slice</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> delimiter, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> slice <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>使用分隔符 <literal>delimiter</literal> 拆分该字符串，返回索引为 <literal>slice</literal> 的子串。如果 <literal>slice</literal> 不存在则返回空字符串。</paragraph>
            <paragraph>只需要一个子串时这个方法比 <reference internal="True" refid="class-stringname-method-split"><inline classes="std std-ref">split</inline></reference> 快。</paragraph>
            <paragraph><strong>示例：</strong></paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("i/am/example/hi".get_slice("/", 2)) # 输出 "example"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-get-slice-count"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-get-slice-count" names="class_stringname_method_get_slice_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_slice_count</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> delimiter <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回使用给定的分隔符 <literal>delimiter</literal> 拆分该字符串后切片的总数（见 <reference internal="True" refid="class-stringname-method-split"><inline classes="std std-ref">split</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-get-slicec"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-get-slicec" names="class_stringname_method_get_slicec"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_slicec</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> delimiter, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> slice <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>使用 Unicode 字符码分隔符 <literal>delimiter</literal> 拆分该字符串，返回索引为 <literal>slice</literal> 的子串。如果 <literal>slice</literal> 不存在则返回空字符串。</paragraph>
            <paragraph>只需要一个子串时这个方法比 <reference internal="True" refid="class-stringname-method-split"><inline classes="std std-ref">split</inline></reference> 快。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-hash"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-hash" names="class_stringname_method_hash"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>hash</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回代表该字符串内容的 32 位哈希值。</paragraph>
            <paragraph><strong>注意：</strong>由于哈希碰撞的缘故，内容相同的字符串<emphasis>不一定</emphasis>会得到相同的哈希值。而相对的是，哈希不同的字符串一定不同。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-hex-decode"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-hex-decode" names="class_stringname_method_hex_decode"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>hex_decode</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将十六进制字符串解码为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var text = "hello world"
var encoded = text.to_utf8_buffer().hex_encode() # 输出 "68656c6c6f20776f726c64"
print(buf.hex_decode().get_string_from_utf8())</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var text = "hello world";
var encoded = text.ToUtf8Buffer().HexEncode(); // 输出 "68656c6c6f20776f726c64"
GD.Print(buf.HexDecode().GetStringFromUtf8());</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-hex-to-int"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-hex-to-int" names="class_stringname_method_hex_to_int"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>hex_to_int</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将表示十六进制数的字符串转换为 <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>。该字符串可以前缀 <literal>"0x"</literal>，负数可以前缀 <literal>-</literal>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">print("0xff".hex_to_int()) # 输出 255
print("ab".hex_to_int())   # 输出 171</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GD.Print("0xff".HexToInt()); // 输出 255
GD.Print("ab".HexToInt());   // 输出 171</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-indent"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-indent" names="class_stringname_method_indent"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>indent</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> prefix <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>使用前缀 <literal>prefix</literal> 将该字符串中的每一行进行缩进。空行不缩进。移除缩进请参阅 <reference internal="True" refid="class-stringname-method-dedent"><inline classes="std std-ref">dedent</inline></reference>。</paragraph>
            <paragraph>例如，该字符串可以用 <literal>"\t\t"</literal> 缩进两个制表位，用 <literal>"    "</literal> 缩进四个空格。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-insert"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-insert" names="class_stringname_method_insert"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>insert</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> position, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>在该字符串中的 <literal>position</literal> 位置插入 <literal>what</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-is-absolute-path"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-is-absolute-path" names="class_stringname_method_is_absolute_path"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_absolute_path</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串为文件或目录的路径，并且显式指定了起点，则返回 <literal>true</literal>。这个方法与 <reference internal="True" refid="class-stringname-method-is-relative-path"><inline classes="std std-ref">is_relative_path</inline></reference> 相反。</paragraph>
            <paragraph>包括以 <literal>"res://"</literal>、<literal>"user://"</literal>、<literal>"C:\"</literal>、<literal>"/"</literal> 等开头的路径。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-is-empty"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-is-empty" names="class_stringname_method_is_empty"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_empty</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串的长度为 <literal>0</literal>（<literal>""</literal>），则返回 <literal>true</literal>。另见 <reference internal="True" refid="class-stringname-method-length"><inline classes="std std-ref">length</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-is-relative-path"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-is-relative-path" names="class_stringname_method_is_relative_path"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_relative_path</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串为文件或目录的路径，并且起点依赖于上下文，则返回 <literal>true</literal>。路径可以是从当前目录开始，也可以是从当前 <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference> 开始（如果该字符串是从 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> 得到的），有时候也可以是使用了 <literal>"./"</literal> 前缀。这个方法与 <reference internal="True" refid="class-stringname-method-is-absolute-path"><inline classes="std std-ref">is_absolute_path</inline></reference> 相反。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-is-subsequence-of"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-is-subsequence-of" names="class_stringname_method_is_subsequence_of"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_subsequence_of</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> text <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果这个字符串中的所有字符都能在 <literal>text</literal> 中按照原始顺序找到，则返回 <literal>true</literal>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var text = "Wow, incredible!"

print("inedible".is_subsequence_of(text)) # 输出 true
print("Word!".is_subsequence_of(text))    # 输出 true
print("Window".is_subsequence_of(text))   # 输出 false
print("".is_subsequence_of(text))         # 输出 true</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-is-subsequence-ofn"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-is-subsequence-ofn" names="class_stringname_method_is_subsequence_ofn"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_subsequence_ofn</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> text <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果这个字符串中的所有字符都能在 <literal>text</literal> 中按照原始顺序找到，<strong>忽略大小写</strong>，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-is-valid-filename"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-is-valid-filename" names="class_stringname_method_is_valid_filename"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid_filename</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串不包含文件名中不允许的字符，则返回 <literal>true</literal>（不允许的字符有：<literal>:</literal> <literal>/</literal> <literal>\</literal> <literal>?</literal> <literal>*</literal> <literal>"</literal> <literal>|</literal> <literal>%</literal> <literal>&lt;</literal> <literal>&gt;</literal>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-is-valid-float"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-is-valid-float" names="class_stringname_method_is_valid_float"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid_float</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串代表有效的浮点数，则返回 <literal>true</literal>。浮点数只能包含数字、一个小数点（<literal>.</literal>）以及指数字符（<literal>e</literal>）。还可以前缀正号（<literal>+</literal>）或负号（<literal>-</literal>）。有效的整数同时也是有效的浮点数（见 <reference internal="True" refid="class-stringname-method-is-valid-int"><inline classes="std std-ref">is_valid_int</inline></reference>）。另见 <reference internal="True" refid="class-stringname-method-to-float"><inline classes="std std-ref">to_float</inline></reference>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("1.7".is_valid_float())   # 输出 true
print("24".is_valid_float())    # 输出 true
print("7e3".is_valid_float())   # 输出 true
print("Hello".is_valid_float()) # 输出 false</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-is-valid-hex-number"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-is-valid-hex-number" names="class_stringname_method_is_valid_hex_number"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid_hex_number</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> with_prefix=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串代表有效的十六进制数，则返回 <literal>true</literal>。有效的十六进制数只能包含数字或字母 <literal>A</literal> 到 <literal>F</literal>（大小写均可），还可以前缀正号（<literal>+</literal>）或负号（<literal>-</literal>）。</paragraph>
            <paragraph>如果 <literal>with_prefix</literal> 为 <literal>true</literal>，则十六进制数需要有 <literal>"0x"</literal> 前缀才算有效。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("A08E".is_valid_hex_number())    # 输出 true
print("-AbCdEf".is_valid_hex_number()) # 输出 true
print("2.5".is_valid_hex_number())     # 输出 false

print("0xDEADC0DE".is_valid_hex_number(true)) # 输出 true</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-is-valid-html-color"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-is-valid-html-color" names="class_stringname_method_is_valid_html_color"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid_html_color</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串是有效的十六进制 HTML 颜色标记，则返回 <literal>true</literal>。该字符串必须为 3 位、4 位、6 位或 8 位字符的十六进制值（见 <reference internal="True" refid="class-stringname-method-is-valid-hex-number"><inline classes="std std-ref">is_valid_hex_number</inline></reference>），也可以带有井号前缀（<literal>#</literal>）。名称、<literal>hsl()</literal> 等其他 HTML 颜色标记法无效。另见 <reference internal="True" refuri="class_color#class-color-method-html"><inline classes="std std-ref">Color.html</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-is-valid-identifier"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-is-valid-identifier" names="class_stringname_method_is_valid_identifier"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid_identifier</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串为有效的标识符，则返回 <literal>true</literal>。有效的标识符仅可以包含字母、数字和下划线（<literal>_</literal>），第一个字符不能为数字。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("node_2d".is_valid_identifier())    # 输出 true
print("TYPE_FLOAT".is_valid_identifier()) # 输出 true
print("1st_method".is_valid_identifier()) # 输出 false
print("MyMethod#2".is_valid_identifier()) # 输出 false</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-is-valid-int"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-is-valid-int" names="class_stringname_method_is_valid_int"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid_int</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串代表有效的整数，则返回 <literal>true</literal>。有效的整数仅可以包含数字，还可以前缀正号（<literal>+</literal>）或负号（<literal>-</literal>）。另见 <reference internal="True" refid="class-stringname-method-to-int"><inline classes="std std-ref">to_int</inline></reference>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("7".is_valid_int())    # 输出 true
print("1.65".is_valid_int()) # 输出 false
print("Hi".is_valid_int())   # 输出 false
print("+3".is_valid_int())   # 输出 true
print("-12".is_valid_int())  # 输出 true</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-is-valid-ip-address"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-is-valid-ip-address" names="class_stringname_method_is_valid_ip_address"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_valid_ip_address</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串表示格式正确的 IPv4 或 IPv6 地址，则返回 <literal>true</literal>。这个方法认为 <literal>0.0.0.0</literal>、<literal>"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"</literal> 等<reference name="保留 IP 地址" refuri="https://zh.wikipedia.org/wiki/%E4%BF%9D%E7%95%99IP%E5%9C%B0%E5%9D%80">保留 IP 地址</reference>是有效的。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-join"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-join" names="class_stringname_method_join"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>join</strong> <strong>(</strong> <reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> parts <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回将 <literal>parts</literal> 中的元素连接组成的字符串，元素间使用调用该方法的字符串进行分隔。该方法和 <reference internal="True" refid="class-stringname-method-split"><inline classes="std std-ref">split</inline></reference> 相反。</paragraph>
            <paragraph><strong>示例：</strong></paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var fruits = ["Apple", "Orange", "Pear", "Kiwi"]

print(", ".join(fruits))  # 输出 "Apple, Orange, Pear, Kiwi"
print("---".join(fruits)) # 输出 "Apple---Orange---Pear---Kiwi"</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var fruits = new string[] {"Apple", "Orange", "Pear", "Kiwi"};

// 这个方法在 C# 中是静态的。
GD.Print(string.Join(", ", fruits));   // 输出 "Apple, Orange, Pear, Kiwi"
GD.Print(string.Join("---", fruits)); // 输出 "Apple---Orange---Pear---Kiwi"</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-json-escape"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-json-escape" names="class_stringname_method_json_escape"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>json_escape</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串的副本，使用 JSON 标准对特殊字符进行转义。因为与 C 标准非常类似，所以需要时可以用 <reference internal="True" refid="class-stringname-method-c-unescape"><inline classes="std std-ref">c_unescape</inline></reference> 取消转义。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-left"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-left" names="class_stringname_method_left"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>left</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> length <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串开头的前 <literal>length</literal> 个字符。如果 <literal>length</literal> 为负，则会从该字符串的末尾剥离最后 <literal>length</literal> 个字符。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("Hello World!".left(3))  # 输出 "Hel"
print("Hello World!".left(-4)) # 输出 "Hello Wo"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-length"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-length" names="class_stringname_method_length"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>length</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串中的字符数。空字符串（<literal>""</literal>）始终返回 <literal>0</literal>。另见 <reference internal="True" refid="class-stringname-method-is-empty"><inline classes="std std-ref">is_empty</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-lpad"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-lpad" names="class_stringname_method_lpad"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>lpad</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> min_length, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> character=" " <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>必要时在该字符串的左侧添加若干 <literal>character</literal> 字符，使其长度至少为 <literal>min_length</literal>。另见 <reference internal="True" refid="class-stringname-method-rpad"><inline classes="std std-ref">rpad</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-lstrip"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-lstrip" names="class_stringname_method_lstrip"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>lstrip</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> chars <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>从该字符串的开头移除 <literal>chars</literal> 中定义的字符。另见 <reference internal="True" refid="class-stringname-method-rstrip"><inline classes="std std-ref">rstrip</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong><literal>chars</literal> 不是前缀。如果要移除前缀而不是一组字符，请使用 <reference internal="True" refid="class-stringname-method-trim-prefix"><inline classes="std std-ref">trim_prefix</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-match"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-match" names="class_stringname_method_match"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>match</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> expr <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>进行简单的表达式匹配（也叫“通配”），<literal>*</literal> 匹配零个或多个任意字符，<literal>?</literal> 匹配除英文句号外的任意字符（<literal>.</literal>）。使用空字符串或空表达式时始终为 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-matchn"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-matchn" names="class_stringname_method_matchn"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>matchn</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> expr <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>进行简单的<strong>大小写不敏感</strong>表达式匹配（也叫“通配”），<literal>*</literal> 匹配零个或多个任意字符，<literal>?</literal> 匹配除英文句号外的任意字符（<literal>.</literal>）。使用空字符串或空表达式时始终为 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-md5-buffer"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-md5-buffer" names="class_stringname_method_md5_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>md5_buffer</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串的 <reference name="MD5 哈希" refuri="https://zh.wikipedia.org/wiki/MD5">MD5 哈希</reference>，类型为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-md5-text"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-md5-text" names="class_stringname_method_md5_text"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>md5_text</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串的 <reference name="MD5 哈希" refuri="https://zh.wikipedia.org/wiki/MD5">MD5 哈希</reference>，类型 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-naturalcasecmp-to"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-naturalcasecmp-to" names="class_stringname_method_naturalcasecmp_to"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>naturalcasecmp_to</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> to <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>与另一个字符串进行<strong>不区分大小写</strong>的<emphasis>自然顺序</emphasis>比较。小于时返回 <literal>-1</literal>、大于时返回 <literal>1</literal>、等于时返回 <literal>0</literal>。“小于”和“大于”比较的是字符串中的 <reference name="Unicode 码位" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 码位</reference>，大致与字母表顺序一致。内部实现时，会将小写字符转换为大写后进行比较。</paragraph>
            <paragraph>使用自然顺序进行排序时，会和常见预期一样将连续的数字进行组合，而不是一个个数字进行比较。排序后的数列为 <literal>["1", "2", "3", ...]</literal> 而不是 <literal>["1", "10", "2", "3", ...]</literal>。</paragraph>
            <paragraph>如果字符串长度不同，这个字符串比 <literal>to</literal> 字符串长时返回 <literal>1</literal>，短时返回 <literal>-1</literal>。请注意空字符串的长度<emphasis>始终</emphasis>为 <literal>0</literal>。</paragraph>
            <paragraph>如果想在比较字符串时获得 <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> 返回值，请改用 <literal>==</literal> 运算符。另见 <reference internal="True" refid="class-stringname-method-naturalnocasecmp-to"><inline classes="std std-ref">naturalnocasecmp_to</inline></reference>、<reference internal="True" refid="class-stringname-method-nocasecmp-to"><inline classes="std std-ref">nocasecmp_to</inline></reference> 和 <reference internal="True" refid="class-stringname-method-casecmp-to"><inline classes="std std-ref">casecmp_to</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-naturalnocasecmp-to"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-naturalnocasecmp-to" names="class_stringname_method_naturalnocasecmp_to"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>naturalnocasecmp_to</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> to <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>与另一个字符串进行<strong>不区分大小写</strong>的<emphasis>自然顺序</emphasis>比较。小于时返回 <literal>-1</literal>、大于时返回 <literal>1</literal>、等于时返回 <literal>0</literal>。“小于”和“大于”比较的是字符串中的 <reference name="Unicode 码位" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 码位</reference>，大致与字母表顺序一致。内部实现时，会将小写字符转换为大写后进行比较。</paragraph>
            <paragraph>使用自然顺序进行排序时，会和常见预期一样将连续的数字进行组合，而不是一个个数字进行比较。排序后的数列为 <literal>["1", "2", "3", ...]</literal> 而不是 <literal>["1", "10", "2", "3", ...]</literal>。</paragraph>
            <paragraph>如果字符串长度不同，这个字符串比 <literal>to</literal> 字符串长时返回 <literal>1</literal>，短时返回 <literal>-1</literal>。请注意空字符串的长度<emphasis>始终</emphasis>为 <literal>0</literal>。</paragraph>
            <paragraph>如果想在比较字符串时获得 <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> 返回值，请改用 <literal>==</literal> 运算符。另见 <reference internal="True" refid="class-stringname-method-naturalcasecmp-to"><inline classes="std std-ref">naturalcasecmp_to</inline></reference>、<reference internal="True" refid="class-stringname-method-nocasecmp-to"><inline classes="std std-ref">nocasecmp_to</inline></reference> 和 <reference internal="True" refid="class-stringname-method-casecmp-to"><inline classes="std std-ref">casecmp_to</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-nocasecmp-to"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-nocasecmp-to" names="class_stringname_method_nocasecmp_to"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>nocasecmp_to</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> to <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>与另一个字符串进行<strong>不区分大小写</strong>的比较。小于时返回 <literal>-1</literal>、大于时返回 <literal>1</literal>、等于时返回 <literal>0</literal>。“小于”和“大于”比较的是字符串中的 <reference name="Unicode 码位" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 码位</reference>，大致与字母表顺序一致。内部实现时，会将小写字符转换为大写后进行比较。</paragraph>
            <paragraph>如果字符串长度不同，这个字符串比 <literal>to</literal> 字符串长时返回 <literal>1</literal>，短时返回 <literal>-1</literal>。请注意空字符串的长度<emphasis>始终</emphasis>为 <literal>0</literal>。</paragraph>
            <paragraph>如果想在比较字符串时获得 <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> 返回值，请改用 <literal>==</literal> 运算符。另见 <reference internal="True" refid="class-stringname-method-casecmp-to"><inline classes="std std-ref">casecmp_to</inline></reference>、<reference internal="True" refid="class-stringname-method-naturalcasecmp-to"><inline classes="std std-ref">naturalcasecmp_to</inline></reference> 和 <reference internal="True" refid="class-stringname-method-naturalnocasecmp-to"><inline classes="std std-ref">naturalnocasecmp_to</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-pad-decimals"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-pad-decimals" names="class_stringname_method_pad_decimals"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>pad_decimals</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> digits <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>格式化表示数字的字符串，使其小数点<emphasis>后</emphasis>的位数为 <literal>digits</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-pad-zeros"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-pad-zeros" names="class_stringname_method_pad_zeros"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>pad_zeros</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> digits <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>格式化表示数字的字符串，使其小数点<emphasis>前</emphasis>的位数为 <literal>digits</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-path-join"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-path-join" names="class_stringname_method_path_join"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>path_join</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> file <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将 <literal>file</literal> 作为子路径连接到该字符串的末尾，必要时会添加 <literal>/</literal>。</paragraph>
            <paragraph><strong>示例：</strong><literal>"this/is".path_join("path") == "this/is/path"</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-repeat"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-repeat" names="class_stringname_method_repeat"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>repeat</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> count <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将该字符串重复若干次。次数 <literal>count</literal> 需要大于<literal>0</literal> 。否则返回空字符串。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-replace"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-replace" names="class_stringname_method_replace"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>replace</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> forwhat <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将该字符串中出现的所有 <literal>what</literal> 都替换为给定的 <literal>forwhat</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-replacen"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-replacen" names="class_stringname_method_replacen"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>replacen</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> forwhat <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将该字符串中出现的所有 <literal>what</literal> 都替换为给定的 <literal>forwhat</literal>，<strong>大小写不敏感</strong>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-reverse"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-reverse" names="class_stringname_method_reverse"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>reverse</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回将这个字符串逆序后的副本。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-rfind"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-rfind" names="class_stringname_method_rfind"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>rfind</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> from=-1 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回这个字符串中 <literal>what</literal> <strong>最后一次</strong>出现时的索引，不存在时则为 <literal>-1</literal>。搜索的起点可以用 <literal>from</literal> 指定，终点为该字符串的末尾。这个方法与 <reference internal="True" refid="class-stringname-method-find"><inline classes="std std-ref">find</inline></reference> 相对。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-rfindn"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-rfindn" names="class_stringname_method_rfindn"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>rfindn</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> what, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> from=-1 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回这个字符串中 <literal>what</literal> <strong>最后一次</strong>出现时的索引，<strong>不区分大小写</strong>，不存在时则为 <literal>-1</literal>。搜索的起点可以用 <literal>from</literal> 指定，终点为该字符串的末尾。这个方法与 <reference internal="True" refid="class-stringname-method-findn"><inline classes="std std-ref">findn</inline></reference> 相对。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-right"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-right" names="class_stringname_method_right"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>right</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> length <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串末尾的最后 <literal>length</literal> 个字符。如果 <literal>length</literal> 为负，则会从该字符串的开头剥离前 <literal>length</literal> 个字符。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("Hello World!".right(3))  # 输出 "ld!"
print("Hello World!".right(-4)) # 输出 "o World!"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-rpad"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-rpad" names="class_stringname_method_rpad"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>rpad</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> min_length, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> character=" " <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>必要时在该字符串的右侧添加若干 <literal>character</literal> 字符，使其长度至少为 <literal>min_length</literal>。另见 <reference internal="True" refid="class-stringname-method-lpad"><inline classes="std std-ref">lpad</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-rsplit"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-rsplit" names="class_stringname_method_rsplit"><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> <strong>rsplit</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> delimiter="", <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> allow_empty=true, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> maxsplit=0 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>使用分隔符 <literal>delimiter</literal> 将该字符串从末尾开始进行拆分，返回子字符串数组。返回的数组中，每部分的出现顺序与它们在原字符串中的出现顺序一致。如果 <literal>delimiter</literal> 为空，则子串为单个字符。</paragraph>
            <paragraph>如果 <literal>allow_empty</literal> 为 <literal>false</literal>，数组中会排除相邻分隔符之间的空字符串。</paragraph>
            <paragraph>如果 <literal>maxsplit</literal> 大于 <literal>0</literal>，则拆分次数不能超过 <literal>maxsplit</literal>。默认拆分整个字符串，基本与 <reference internal="True" refid="class-stringname-method-split"><inline classes="std std-ref">split</inline></reference> 一致。</paragraph>
            <paragraph><strong>示例：</strong></paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var some_string = "One,Two,Three,Four"
var some_array = some_string.rsplit(",", true, 1)

print(some_array.size()) # 输出 2
print(some_array[0])     # 输出 "One,Two,Three"
print(some_array[1])     # 输出 "Four"</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// C# 中没有 String.RSplit() 方法。</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-rstrip"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-rstrip" names="class_stringname_method_rstrip"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>rstrip</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> chars <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>从该字符串的结尾移除 <literal>chars</literal> 中定义的字符。另见 <reference internal="True" refid="class-stringname-method-rstrip"><inline classes="std std-ref">rstrip</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong><literal>chars</literal> 不是后缀。如果要移除后缀而不是一组字符，请使用 <reference internal="True" refid="class-stringname-method-trim-suffix"><inline classes="std std-ref">trim_suffix</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-sha1-buffer"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-sha1-buffer" names="class_stringname_method_sha1_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>sha1_buffer</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串的 <reference name="SHA-1" refuri="https://zh.wikipedia.org/wiki/SHA-1">SHA-1</reference> 哈希，类型为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-sha1-text"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-sha1-text" names="class_stringname_method_sha1_text"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>sha1_text</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串的 <reference name="SHA-1" refuri="https://zh.wikipedia.org/wiki/SHA-1">SHA-1</reference> 哈希，类型为 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-sha256-buffer"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-sha256-buffer" names="class_stringname_method_sha256_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>sha256_buffer</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串的 <reference name="SHA-256" refuri="https://zh.wikipedia.org/wiki/SHA-2">SHA-256</reference> 哈希，类型为 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-sha256-text"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-sha256-text" names="class_stringname_method_sha256_text"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>sha256_text</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串的 <reference name="SHA-256" refuri="https://zh.wikipedia.org/wiki/SHA-2">SHA-256</reference> 哈希，类型为 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-similarity"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-similarity" names="class_stringname_method_similarity"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>similarity</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> text <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串与另一个字符串的相似指数（<reference name="索伦森-戴斯系数" refuri="https://zh.wikipedia.org/wiki/Dice%E7%B3%BB%E6%95%B0">索伦森-戴斯系数</reference>）。结果为 <literal>1.0</literal> 表示完全相似，<literal>0.0</literal> 表示完全不相似。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">print("ABC123".similarity("ABC123")) # 输出 1.0
print("ABC123".similarity("XYZ456")) # 输出 0.0
print("ABC123".similarity("123ABC")) # 输出 0.8
print("ABC123".similarity("abc123")) # 输出 0.4</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-simplify-path"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-simplify-path" names="class_stringname_method_simplify_path"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>simplify_path</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该字符串为有效的文件路径，则将其转换为规范路径。规范路径是最短路径，不带 <literal>"./"</literal> 和所有不必要的 <literal>".."</literal> 和 <literal>"/"</literal>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var simple_path = "./path/to///../file".simplify_path()
print(simple_path) # 输出 "path/file"</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-split"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-split" names="class_stringname_method_split"><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> <strong>split</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> delimiter="", <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> allow_empty=true, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> maxsplit=0 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>使用分隔符 <literal>delimiter</literal> 将该字符串进行拆分，返回子字符串数组。如果 <literal>delimiter</literal> 为空，则子串为单个字符。这个方法与 <reference internal="True" refid="class-stringname-method-join"><inline classes="std std-ref">join</inline></reference> 相对。</paragraph>
            <paragraph>如果 <literal>allow_empty</literal> 为 <literal>false</literal>，数组中会排除相邻分隔符之间的空字符串。</paragraph>
            <paragraph>如果 <literal>maxsplit</literal> 大于 <literal>0</literal>，则拆分次数不能超过 <literal>maxsplit</literal>。默认拆分整个字符串。</paragraph>
            <paragraph><strong>示例：</strong></paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var some_array = "One,Two,Three,Four".split(",", true, 2)

print(some_array.size()) # 输出 3
print(some_array[0])     # 输出 "One"
print(some_array[1])     # 输出 "Two"
print(some_array[2])     # 输出 "Three,Four"</literal_block>
                </div>
                <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// C# 的 `Split()` 不支持 `maxsplit` 参数。
var someArray = "One,Two,Three".Split(",");

GD.Print(someArray[0]); // 输出 "One"
GD.Print(someArray[1]); // 输出 "Two"
GD.Print(someArray[2]); // 输出 "Three"</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>如果你只需要数组中的某一个子串，请考虑使用更快的 <reference internal="True" refid="class-stringname-method-get-slice"><inline classes="std std-ref">get_slice</inline></reference>。如果你需要用更复杂的规则来拆分字符串，请改用 <reference internal="True" refuri="class_regex#class-regex"><inline classes="std std-ref">RegEx</inline></reference> 类。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-split-floats"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-split-floats" names="class_stringname_method_split_floats"><reference internal="True" refuri="class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference> <strong>split_floats</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> delimiter, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> allow_empty=true <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>使用分隔符 <literal>delimiter</literal> 将该字符串拆分为浮点数，返回 <reference internal="True" refuri="class_packedfloat64array#class-packedfloat64array"><inline classes="std std-ref">PackedFloat64Array</inline></reference>。</paragraph>
            <paragraph>如果 <literal>allow_empty</literal> 为 <literal>false</literal>，则会排除相邻分隔符之间为空或无法转换为 <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> 的内容。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a = "1,2,4.5".split_floats(",")         # a 为 [1.0, 2.0, 4.5]
var c = "1| ||4.5".split_floats("|")        # c 为 [1.0, 0.0, 0.0, 4.5]
var b = "1| ||4.5".split_floats("|", false) # b 为 [1.0, 4.5]</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-strip-edges"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-strip-edges" names="class_stringname_method_strip_edges"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>strip_edges</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> left=true, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> right=true <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>从该字符串的开头和结尾剥离所有不可打印的字符。其中包括空格、制表符（<literal>\t</literal>）以及换行符（<literal>\n</literal> <literal>\r</literal>）。</paragraph>
            <paragraph>如果 <literal>left</literal> 为 <literal>false</literal>，会忽略该字符串的开头。与此类似，如果 <literal>right</literal> 为 <literal>false</literal>，则会忽略该字符串的结尾。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-strip-escapes"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-strip-escapes" names="class_stringname_method_strip_escapes"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>strip_escapes</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>从该字符串中剥离所有转义字符。其中包括 ASCII 表第一页的所有不可打印控制字符（值为 0 到 32），例如制表符（C 中的 <literal>\t</literal>）和换行符（<literal>\n</literal> 和 <literal>]\r</literal>) 字符，但<emphasis>不包括</emphasis>空格。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-substr"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-substr" names="class_stringname_method_substr"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>substr</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> from, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> len=-1 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串中的某一部分，位置从 <literal>from</literal> 开始，长度为 <literal>len</literal>。如果 <literal>len</literal> 为 <literal>-1</literal>（默认值），将返回开给定位置开始的剩余字符。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-to-ascii-buffer"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-to-ascii-buffer" names="class_stringname_method_to_ascii_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>to_ascii_buffer</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将该字符串转换为 <reference name="ASCII" refuri="https://zh.wikipedia.org/wiki/ASCII">ASCII</reference>/Latin-1 编码的 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。这个方法比 <reference internal="True" refid="class-stringname-method-to-utf8-buffer"><inline classes="std std-ref">to_utf8_buffer</inline></reference> 稍快，但会把不支持的字符都替换为空格。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-to-camel-case"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-to-camel-case" names="class_stringname_method_to_camel_case"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>to_camel_case</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回将该字符串转换为小驼峰命名 <literal>camelCase</literal> 的结果。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-to-float"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-to-float" names="class_stringname_method_to_float"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>to_float</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将代表十进制数的字符串转换为 <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>。该方法会在首个非数字字符处停止，除非是首次遇到 <literal>.</literal>（小数点）以及表示指数的 <literal>e</literal>。另见 <reference internal="True" refid="class-stringname-method-is-valid-float"><inline classes="std std-ref">is_valid_float</inline></reference>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a = "12.35".to_float() # a 为 12.35
var b = "1.2.3".to_float() # b 为 1.2
var c = "12xy3".to_float() # c 为 12.0
var d = "1e3".to_float()   # d 为 1000.0
var e = "Hello!".to_int()  # e 为 0.0</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-to-int"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-to-int" names="class_stringname_method_to_int"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>to_int</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将代表整数的字符串转换为 <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>。该方法会删除所有非数字字符，并在遇到 <literal>.</literal> 后停止。另见 <reference internal="True" refid="class-stringname-method-is-valid-int"><inline classes="std std-ref">is_valid_int</inline></reference>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var a = "123".to_int()    # a 为 123
var b = "x1y2z3".to_int() # b 为 123
var c = "-1.2.3".to_int() # c 为 -1
var d = "Hello!".to_int() # d 为 0</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-to-lower"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-to-lower" names="class_stringname_method_to_lower"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>to_lower</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回将该字符串转换为小写 <literal>lowercase</literal> 的结果。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-to-pascal-case"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-to-pascal-case" names="class_stringname_method_to_pascal_case"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>to_pascal_case</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回将该字符串转换为大驼峰命名 <literal>PascalCase</literal> 的结果。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-to-snake-case"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-to-snake-case" names="class_stringname_method_to_snake_case"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>to_snake_case</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回将该字符串转换为蛇形命名 <literal>snake_case</literal> 的结果。</paragraph>
            <paragraph><strong>注意：</strong>如果数字之后存在的是<emphasis>单个</emphasis>字符，则不会进行拆分，这是为了保证某些单词的连贯（例如“2D”）。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">"Node2D".to_snake_case()               # 返回 "node_2d"
"2nd place".to_snake_case()            # 返回 "2_nd_place"
"Texture3DAssetFolder".to_snake_case() # 返回 "texture_3d_asset_folder"</literal_block>
                </div>
                <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">"Node2D".ToSnakeCase();               // 返回 "node_2d"
"2nd place".ToSnakeCase();            // 返回 "2_nd_place"
"Texture3DAssetFolder".ToSnakeCase(); // 返回 "texture_3d_asset_folder"</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-to-upper"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-to-upper" names="class_stringname_method_to_upper"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>to_upper</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回将该字符串转换为大写 <literal>UPPERCASE</literal> 的结果。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-to-utf8-buffer"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-to-utf8-buffer" names="class_stringname_method_to_utf8_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>to_utf8_buffer</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将该字符串转换为 <reference name="UTF-8" refuri="https://zh.wikipedia.org/wiki/UTF-8">UTF-8</reference> 编码的 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。这个方法比 <reference internal="True" refid="class-stringname-method-to-ascii-buffer"><inline classes="std std-ref">to_ascii_buffer</inline></reference> 稍慢，但支持所有 UTF-8 字符。大多数情况下请优先使用这个方法。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-to-utf16-buffer"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-to-utf16-buffer" names="class_stringname_method_to_utf16_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>to_utf16_buffer</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将该字符串转换为 <reference name="UTF-16" refuri="https://zh.wikipedia.org/wiki/UTF-16">UTF-16</reference> 编码的 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-to-utf32-buffer"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-to-utf32-buffer" names="class_stringname_method_to_utf32_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>to_utf32_buffer</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将该字符串转换为 <reference name="UTF-32" refuri="https://zh.wikipedia.org/wiki/UTF-32">UTF-32</reference> 编码的 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-to-wchar-buffer"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-to-wchar-buffer" names="class_stringname_method_to_wchar_buffer"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>to_wchar_buffer</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将该字符串转换为 <reference name="宽字符" refuri="https://zh.wikipedia.org/zh-cn/%E5%AF%AC%E5%AD%97%E5%85%83">宽字符</reference>（<literal>wchat_t</literal>，Windows 上为 UTF-16，其他平台上为 UTF-32）编码的 <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-trim-prefix"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-trim-prefix" names="class_stringname_method_trim_prefix"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>trim_prefix</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> prefix <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>移除该字符串开头的 <literal>prefix</literal> 前缀，否则原样返回该字符串。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-trim-suffix"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-trim-suffix" names="class_stringname_method_trim_suffix"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>trim_suffix</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> suffix <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>移除该字符串末尾的 <literal>suffix</literal> 后缀，否则原样返回该字符串。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-unicode-at"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-unicode-at" names="class_stringname_method_unicode_at"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>unicode_at</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> at <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回位于 <literal>at</literal> 处的字符的代码。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-uri-decode"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-uri-decode" names="class_stringname_method_uri_decode"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>uri_decode</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将该字符串从 URL 编码格式中解码。该方法的目的是在收到 HTTP 请求时正确解码 URL 中的参数。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-10-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-10-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-10-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var url = "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
print(url.uri_decode()) # 输出 "$DOCS_URL/?highlight=Godot Engine:docs"</literal_block>
                </div>
                <div aria-labelledby="tab-10-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-10-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var url = "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
GD.Print(url.URIDecode()) // 输出 "$DOCS_URL/?highlight=Godot Engine:docs"</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-uri-encode"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-uri-encode" names="class_stringname_method_uri_encode"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>uri_encode</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>将该字符串按照对 URL 友好的格式进行编码。该方法的目的是在发送 HTTP 请求时，正确编码 URL 中的参数。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-11-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-11-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-11-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var prefix = "$DOCS_URL/?highlight="
var url = prefix + "Godot Engine:docs".uri_encode()

print(url) # 输出 "$DOCS_URL/?highlight=Godot%20Engine%3%docs"</literal_block>
                </div>
                <div aria-labelledby="tab-11-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-11-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var prefix = "$DOCS_URL/?highlight=";
var url = prefix + "Godot Engine:docs".URIEncode();

GD.Print(url); // 输出 "$DOCS_URL/?highlight=Godot%20Engine%3%docs"</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-validate-filename"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-validate-filename" names="class_stringname_method_validate_filename"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>validate_filename</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串的副本，所有 <reference internal="True" refid="class-stringname-method-is-valid-filename"><inline classes="std std-ref">is_valid_filename</inline></reference> 中不允许的字符都会被替换为下划线。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-validate-node-name"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-validate-node-name" names="class_stringname_method_validate_node_name"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>validate_node_name</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串的副本，所有 <reference internal="True" refuri="class_node#class-node-property-name"><inline classes="std std-ref">Node.name</inline></reference> 中不允许的字符都会被替换为下划线（<literal>.</literal> <literal>:</literal> <literal>@</literal> <literal>/</literal> <literal>"</literal> <literal>%</literal>)）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-xml-escape"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-xml-escape" names="class_stringname_method_xml_escape"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>xml_escape</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> escape_quotes=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串的副本，使用 XML 标准对特殊字符进行转义。如果 <literal>escape_quotes</literal> 为 <literal>true</literal>，则单引号（<literal>'</literal>）和双引号（<literal>"</literal>）字符也会被转义。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-method-xml-unescape"></target>
            <paragraph classes="classref-method" ids="class-stringname-method-xml-unescape" names="class_stringname_method_xml_unescape"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>xml_unescape</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该字符串的副本，转义字符均按照 XML 标准使用本义代替。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id7" names="操作符说明">
            <title>操作符说明</title>
            <target refid="class-stringname-operator-neq-string"></target>
            <paragraph classes="classref-operator" ids="class-stringname-operator-neq-string" names="class_stringname_operator_neq_string"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果该 <strong>StringName</strong> 与给定的 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> 不等价，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-operator-neq-stringname"></target>
            <paragraph classes="classref-operator" ids="class-stringname-operator-neq-stringname" names="class_stringname_operator_neq_stringname"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果该 <strong>StringName</strong> 与 <literal>right</literal> 不指向同一个名称，则返回 <literal>true</literal>。<strong>StringName</strong> 间的比较比常规 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> 间的比较要快很多。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-operator-mod-variant"></target>
            <paragraph classes="classref-operator" ids="class-stringname-operator-mod-variant" names="class_stringname_operator_mod_variant"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>operator %</strong> <strong>(</strong> <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>格式化该 <strong>StringName</strong>，使用若干参数替换占位符，返回的是 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>。要传递多个参数时，<literal>right</literal> 应为 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>。</paragraph>
            <paragraph>更多信息见<reference internal="True" refuri="../tutorials/scripting/gdscript/gdscript_format_string"><inline classes="doc">《GDScript 格式字符串》</inline></reference>教程。</paragraph>
            <paragraph><strong>注意：</strong>C# 中没有等价的运算符。见<reference name="如何使用“$”插入字符串" refuri="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated">如何使用“$”插入字符串</reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-operator-sum-string"></target>
            <paragraph classes="classref-operator" ids="class-stringname-operator-sum-string" names="class_stringname_operator_sum_string"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>operator +</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>将 <literal>right</literal> 追加到该 <strong>StringName</strong> 的末尾，返回的是 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>。也称作字符串连接。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-operator-sum-stringname"></target>
            <paragraph classes="classref-operator" ids="class-stringname-operator-sum-stringname" names="class_stringname_operator_sum_stringname"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>operator +</strong> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>将 <literal>right</literal> 追加到该 <strong>StringName</strong> 的末尾，返回的是 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>。也称作字符串连接。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-operator-lt-stringname"></target>
            <paragraph classes="classref-operator" ids="class-stringname-operator-lt-stringname" names="class_stringname_operator_lt_stringname"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &lt;</strong> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果左侧的 <strong>StringName</strong> 的指针比 <literal>right</literal> 靠前，则返回 <literal>true</literal>。注意，这与 <reference name="Unicode 顺序" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 顺序</reference>是不同的。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-operator-lte-stringname"></target>
            <paragraph classes="classref-operator" ids="class-stringname-operator-lte-stringname" names="class_stringname_operator_lte_stringname"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &lt;=</strong> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果左侧的 <strong>StringName</strong> 的指针比 <literal>right</literal> 靠前或者相同，则返回 <literal>true</literal>。注意，这与 <reference name="Unicode 顺序" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 顺序</reference>是不同的。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-operator-eq-string"></target>
            <paragraph classes="classref-operator" ids="class-stringname-operator-eq-string" names="class_stringname_operator_eq_string"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果该 <strong>StringName</strong> 与给定的 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> 等价，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-operator-eq-stringname"></target>
            <paragraph classes="classref-operator" ids="class-stringname-operator-eq-stringname" names="class_stringname_operator_eq_stringname"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果该 <strong>StringName</strong> 与 <literal>right</literal> 指向同一个名称，则返回 <literal>true</literal>。<strong>StringName</strong> 间的比较比常规 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> 间的比较要快很多。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-operator-gt-stringname"></target>
            <paragraph classes="classref-operator" ids="class-stringname-operator-gt-stringname" names="class_stringname_operator_gt_stringname"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &gt;</strong> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果左侧的 <strong>StringName</strong> 的指针比 <literal>right</literal> 靠后，则返回 <literal>true</literal>。注意，这与 <reference name="Unicode 顺序" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 顺序</reference>是不同的。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-stringname-operator-gte-stringname"></target>
            <paragraph classes="classref-operator" ids="class-stringname-operator-gte-stringname" names="class_stringname_operator_gte_stringname"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator &gt;=</strong> <strong>(</strong> <reference internal="True" refid="class-stringname"><inline classes="std std-ref">StringName</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果左侧的 <strong>StringName</strong> 的指针比 <literal>right</literal> 靠后或相同，则返回 <literal>true</literal>。注意，这与 <reference name="Unicode 顺序" refuri="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8">Unicode 顺序</reference>是不同的。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
