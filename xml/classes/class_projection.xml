<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_projection.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/4.2/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/4.2/doc/classes/Projection.xml.</comment>
    <target refid="class-projection"></target>
    <section ids="projection class-projection" names="projection class_projection">
        <title>Projection</title>
        <paragraph>用于 3D 投影变换的 4×4 矩阵。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>用于 3D 投影变换的 4×4 矩阵，可以表示平移、旋转、缩放、剪切和透视分割等变换，由四个 <reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> 列组成。</paragraph>
            <paragraph>对于纯粹的线性变换（平移、旋转和缩放），建议使用 <reference internal="True" refuri="class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference>，因为它的性能更强，内存占用更少。</paragraph>
            <paragraph>在内部作为 <reference internal="True" refuri="class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference> 的投影矩阵使用。</paragraph>
            <note>
                <paragraph>通过 C# 使用这个 API 时有显著的不同。详见 <reference internal="True" refuri="../tutorials/scripting/c_sharp/c_sharp_differences#doc-c-sharp-differences"><inline classes="std std-ref">C# API 与 GDScript 的差异</inline></reference>。</paragraph>
            </note>
        </section>
        <section classes="classref-reftable-group" ids="id2" names="属性">
            <title>属性</title>
            <table classes="colwidths-auto">
                <tgroup cols="3">
                    <colspec colwidth="31"></colspec>
                    <colspec colwidth="39"></colspec>
                    <colspec colwidth="25"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-property-w"><inline classes="std std-ref">w</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector4(0, 0, 0, 1)</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-property-x"><inline classes="std std-ref">x</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector4(1, 0, 0, 0)</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-property-y"><inline classes="std std-ref">y</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector4(0, 1, 0, 0)</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-property-z"><inline classes="std std-ref">z</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector4(0, 0, 1, 0)</literal></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="构造函数">
            <title>构造函数</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="37"></colspec>
                    <colspec colwidth="223"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-constructor-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-constructor-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>(</strong> <reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> from <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-constructor-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference> from <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-constructor-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> x_axis, <reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> y_axis, <reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> z_axis, <reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> w_axis <strong>)</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id4" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="37"></colspec>
                    <colspec colwidth="381"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-create-depth-correction"><inline classes="std std-ref">create_depth_correction</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> flip_y <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-create-fit-aabb"><inline classes="std std-ref">create_fit_aabb</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_aabb#class-aabb"><inline classes="std std-ref">AABB</inline></reference> aabb <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-create-for-hmd"><inline classes="std std-ref">create_for_hmd</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> eye, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> aspect, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> intraocular_dist, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> display_width, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> display_to_lens, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> oversample, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_near, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_far <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-create-frustum"><inline classes="std std-ref">create_frustum</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> left, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> right, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> bottom, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> top, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_near, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_far <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-create-frustum-aspect"><inline classes="std std-ref">create_frustum_aspect</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> size, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> aspect, <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> offset, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_near, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_far, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> flip_fov=false <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-create-light-atlas-rect"><inline classes="std std-ref">create_light_atlas_rect</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_rect2#class-rect2"><inline classes="std std-ref">Rect2</inline></reference> rect <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-create-orthogonal"><inline classes="std std-ref">create_orthogonal</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> left, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> right, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> bottom, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> top, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_near, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_far <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-create-orthogonal-aspect"><inline classes="std std-ref">create_orthogonal_aspect</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> size, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> aspect, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_near, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_far, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> flip_fov=false <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-create-perspective"><inline classes="std std-ref">create_perspective</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> fovy, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> aspect, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_near, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_far, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> flip_fov=false <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-create-perspective-hmd"><inline classes="std std-ref">create_perspective_hmd</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> fovy, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> aspect, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_near, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_far, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> flip_fov, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> eye, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> intraocular_dist, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> convergence_dist <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-determinant"><inline classes="std std-ref">determinant</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-flipped-y"><inline classes="std std-ref">flipped_y</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-get-aspect"><inline classes="std std-ref">get_aspect</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-get-far-plane-half-extents"><inline classes="std std-ref">get_far_plane_half_extents</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-get-fov"><inline classes="std std-ref">get_fov</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-get-fovy"><inline classes="std std-ref">get_fovy</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> fovx, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> aspect <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-get-lod-multiplier"><inline classes="std std-ref">get_lod_multiplier</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-get-pixels-per-meter"><inline classes="std std-ref">get_pixels_per_meter</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> for_pixel_width <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_plane#class-plane"><inline classes="std std-ref">Plane</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-get-projection-plane"><inline classes="std std-ref">get_projection_plane</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> plane <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-get-viewport-half-extents"><inline classes="std std-ref">get_viewport_half_extents</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-get-z-far"><inline classes="std std-ref">get_z_far</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-get-z-near"><inline classes="std std-ref">get_z_near</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-inverse"><inline classes="std std-ref">inverse</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-is-orthogonal"><inline classes="std std-ref">is_orthogonal</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-jitter-offseted"><inline classes="std std-ref">jitter_offseted</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> offset <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-method-perspective-znear-adjusted"><inline classes="std std-ref">perspective_znear_adjusted</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> new_znear <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id5" names="操作符">
            <title>操作符</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="37"></colspec>
                    <colspec colwidth="116"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-operator-neq-projection"><inline classes="std std-ref">operator !=</inline></reference> <strong>(</strong> <reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-operator-mul-projection"><inline classes="std std-ref">operator *</inline></reference> <strong>(</strong> <reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-operator-mul-vector4"><inline classes="std std-ref">operator *</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-operator-eq-projection"><inline classes="std std-ref">operator ==</inline></reference> <strong>(</strong> <reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-projection-operator-idx-int"><inline classes="std std-ref">operator []</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id6" names="常量">
            <title>常量</title>
            <target refid="class-projection-constant-plane-near"></target>
            <paragraph classes="classref-constant" ids="class-projection-constant-plane-near" names="class_projection_constant_plane_near"><strong>PLANE_NEAR</strong> = <literal>0</literal></paragraph>
            <paragraph>该投影的近裁剪平面的索引值。</paragraph>
            <target refid="class-projection-constant-plane-far"></target>
            <paragraph classes="classref-constant" ids="class-projection-constant-plane-far" names="class_projection_constant_plane_far"><strong>PLANE_FAR</strong> = <literal>1</literal></paragraph>
            <paragraph>该投影的远裁剪平面的索引值。</paragraph>
            <target refid="class-projection-constant-plane-left"></target>
            <paragraph classes="classref-constant" ids="class-projection-constant-plane-left" names="class_projection_constant_plane_left"><strong>PLANE_LEFT</strong> = <literal>2</literal></paragraph>
            <paragraph>该投影的左裁剪平面的索引值。</paragraph>
            <target refid="class-projection-constant-plane-top"></target>
            <paragraph classes="classref-constant" ids="class-projection-constant-plane-top" names="class_projection_constant_plane_top"><strong>PLANE_TOP</strong> = <literal>3</literal></paragraph>
            <paragraph>该投影的上裁剪平面的索引值。</paragraph>
            <target refid="class-projection-constant-plane-right"></target>
            <paragraph classes="classref-constant" ids="class-projection-constant-plane-right" names="class_projection_constant_plane_right"><strong>PLANE_RIGHT</strong> = <literal>4</literal></paragraph>
            <paragraph>该投影的右裁剪平面的索引值。</paragraph>
            <target refid="class-projection-constant-plane-bottom"></target>
            <paragraph classes="classref-constant" ids="class-projection-constant-plane-bottom" names="class_projection_constant_plane_bottom"><strong>PLANE_BOTTOM</strong> = <literal>5</literal></paragraph>
            <paragraph>该投影的下裁剪平面的索引值。</paragraph>
            <target refid="class-projection-constant-identity"></target>
            <paragraph classes="classref-constant" ids="class-projection-constant-identity" names="class_projection_constant_identity"><strong>IDENTITY</strong> = <literal>Projection(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)</literal></paragraph>
            <paragraph>未定义变换的 <strong>Projection</strong>。对其他数据结构使用时，不会进行任何变换。</paragraph>
            <target refid="class-projection-constant-zero"></target>
            <paragraph classes="classref-constant" ids="class-projection-constant-zero" names="class_projection_constant_zero"><strong>ZERO</strong> = <literal>Projection(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)</literal></paragraph>
            <paragraph>所有值都初始化为 0 的 <strong>Projection</strong>。对其他数据结构使用时，会进行清零操作。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id7" names="属性说明">
            <title>属性说明</title>
            <target refid="class-projection-property-w"></target>
            <paragraph classes="classref-property" ids="class-projection-property-w" names="class_projection_property_w"><reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> <strong>w</strong> = <literal>Vector4(0, 0, 0, 1)</literal></paragraph>
            <paragraph>投影矩阵的 W 向量（第 3 列）。相当于数组索引 <literal>3</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-property-x"></target>
            <paragraph classes="classref-property" ids="class-projection-property-x" names="class_projection_property_x"><reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> <strong>x</strong> = <literal>Vector4(1, 0, 0, 0)</literal></paragraph>
            <paragraph>投影矩阵的 X 向量（第 0 列）。相当于数组索引 <literal>0</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-property-y"></target>
            <paragraph classes="classref-property" ids="class-projection-property-y" names="class_projection_property_y"><reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> <strong>y</strong> = <literal>Vector4(0, 1, 0, 0)</literal></paragraph>
            <paragraph>投影矩阵的 Y 向量（第 1 列）。相当于数组索引 <literal>1</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-property-z"></target>
            <paragraph classes="classref-property" ids="class-projection-property-z" names="class_projection_property_z"><reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> <strong>z</strong> = <literal>Vector4(0, 0, 1, 0)</literal></paragraph>
            <paragraph>投影矩阵的 Z 向量（第 2 列）。相当于数组索引 <literal>2</literal>。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id8" names="构造函数说明">
            <title>构造函数说明</title>
            <target refid="class-projection-constructor-projection"></target>
            <paragraph classes="classref-constructor" ids="class-projection-constructor-projection" names="class_projection_constructor_projection"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>Projection</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>构造默认初始化为 <reference internal="True" refid="class-projection-constant-identity"><inline classes="std std-ref">IDENTITY</inline></reference> 的 <strong>Projection</strong>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>Projection</strong> <strong>(</strong> <reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> from <strong>)</strong></paragraph>
            <paragraph>构造给定 <strong>Projection</strong> 的副本。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>Projection</strong> <strong>(</strong> <reference internal="True" refuri="class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference> from <strong>)</strong></paragraph>
            <paragraph>将 Projection 作为给定 <reference internal="True" refuri="class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference> 的副本进行构造。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>Projection</strong> <strong>(</strong> <reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> x_axis, <reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> y_axis, <reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> z_axis, <reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> w_axis <strong>)</strong></paragraph>
            <paragraph>从四个 <reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> 值（矩阵列）构造 Projection。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id9" names="方法说明">
            <title>方法说明</title>
            <target refid="class-projection-method-create-depth-correction"></target>
            <paragraph classes="classref-method" ids="class-projection-method-create-depth-correction" names="class_projection_method_create_depth_correction"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>create_depth_correction</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> flip_y <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>创建新的 <strong>Projection</strong>，将位置从深度 <literal>-1</literal> 到 <literal>1</literal> 的范围投影到 <literal>0</literal> 到 <literal>1</literal> 的范围，并将投影后的位置根据 <literal>flip_y</literal> 垂直翻转。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-create-fit-aabb"></target>
            <paragraph classes="classref-method" ids="class-projection-method-create-fit-aabb" names="class_projection_method_create_fit_aabb"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>create_fit_aabb</strong> <strong>(</strong> <reference internal="True" refuri="class_aabb#class-aabb"><inline classes="std std-ref">AABB</inline></reference> aabb <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>创建新的 <strong>Projection</strong>，将给定的投影进行缩放，从而适应投影空间中的给定 <reference internal="True" refuri="class_aabb#class-aabb"><inline classes="std std-ref">AABB</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-create-for-hmd"></target>
            <paragraph classes="classref-method" ids="class-projection-method-create-for-hmd" names="class_projection_method_create_for_hmd"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>create_for_hmd</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> eye, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> aspect, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> intraocular_dist, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> display_width, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> display_to_lens, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> oversample, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_near, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_far <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>创建新的 <strong>Projection</strong>，将位置投影至头戴显示器中，使用给定的 X:Y 纵横比、双眼间距、显示器宽度、到镜头的距离、过采样系数以及深度裁剪平面。</paragraph>
            <paragraph><literal>eye</literal> 设为 1 时创建的是左眼投影，设为 2 时则为右眼。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-create-frustum"></target>
            <paragraph classes="classref-method" ids="class-projection-method-create-frustum" names="class_projection_method_create_frustum"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>create_frustum</strong> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> left, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> right, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> bottom, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> top, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_near, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_far <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>创建新的 <strong>Projection</strong>，将位置投影至平截头台中，平截头台由给定的裁剪平面指定。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-create-frustum-aspect"></target>
            <paragraph classes="classref-method" ids="class-projection-method-create-frustum-aspect" names="class_projection_method_create_frustum_aspect"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>create_frustum_aspect</strong> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> size, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> aspect, <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> offset, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_near, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_far, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> flip_fov=false <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>创建新的 <strong>Projection</strong>，将位置投影至平截头台中，平截头台由给定的大小、X:Y 纵横比、偏移量以及裁剪平面指定。</paragraph>
            <paragraph><literal>flip_fov</literal> 决定投影视野是否按对角线翻转。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-create-light-atlas-rect"></target>
            <paragraph classes="classref-method" ids="class-projection-method-create-light-atlas-rect" names="class_projection_method_create_light_atlas_rect"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>create_light_atlas_rect</strong> <strong>(</strong> <reference internal="True" refuri="class_rect2#class-rect2"><inline classes="std std-ref">Rect2</inline></reference> rect <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>创建新的 <strong>Projection</strong>，将位置投影至给定的 <reference internal="True" refuri="class_rect2#class-rect2"><inline classes="std std-ref">Rect2</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-create-orthogonal"></target>
            <paragraph classes="classref-method" ids="class-projection-method-create-orthogonal" names="class_projection_method_create_orthogonal"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>create_orthogonal</strong> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> left, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> right, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> bottom, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> top, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_near, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_far <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>创建新的 <strong>Projection</strong>，使用给定裁剪平面的正交投影对位置进行投影。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-create-orthogonal-aspect"></target>
            <paragraph classes="classref-method" ids="class-projection-method-create-orthogonal-aspect" names="class_projection_method_create_orthogonal_aspect"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>create_orthogonal_aspect</strong> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> size, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> aspect, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_near, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_far, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> flip_fov=false <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>创建新的 <strong>Projection</strong>，使用正交投影对位置进行投影，正交投影由给定的大小、X:Y 纵横比以及裁剪平面指定。</paragraph>
            <paragraph><literal>flip_fov</literal> 决定投影视野是否按对角线翻转。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-create-perspective"></target>
            <paragraph classes="classref-method" ids="class-projection-method-create-perspective" names="class_projection_method_create_perspective"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>create_perspective</strong> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> fovy, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> aspect, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_near, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_far, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> flip_fov=false <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>创建新的 <strong>Projection</strong>，使用透视投影对位置进行投影，透视投影由给定的 Y 轴视野（单位为度）、X:Y 纵横比以及裁剪平面指定。</paragraph>
            <paragraph><literal>flip_fov</literal> 决定投影视野是否按对角线翻转。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-create-perspective-hmd"></target>
            <paragraph classes="classref-method" ids="class-projection-method-create-perspective-hmd" names="class_projection_method_create_perspective_hmd"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>create_perspective_hmd</strong> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> fovy, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> aspect, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_near, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> z_far, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> flip_fov, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> eye, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> intraocular_dist, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> convergence_dist <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>创建新的 <strong>Projection</strong>，使用透视投影对位置进行投影，透视投影由给定的 Y 轴视野（单位为度）、X:Y 纵横比以及裁剪平面指定。投影会针对头戴显示器进行调整，使用给定的双眼间距以及与能够聚焦的点的距离。</paragraph>
            <paragraph><literal>eye</literal> 设为 1 时创建的是左眼投影，设为 2 时则为右眼。</paragraph>
            <paragraph><literal>flip_fov</literal> 决定投影视野是否按对角线翻转。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-determinant"></target>
            <paragraph classes="classref-method" ids="class-projection-method-determinant" names="class_projection_method_determinant"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>determinant</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回一个标量值，该标量值是区域被该矩阵缩放的有符号系数。如果符号是负的，则矩阵翻转该区域的方向。</paragraph>
            <paragraph>行列式可用于计算矩阵的可逆性或求解涉及矩阵的线性方程组，以及其他应用。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-flipped-y"></target>
            <paragraph classes="classref-method" ids="class-projection-method-flipped-y" names="class_projection_method_flipped_y"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>flipped_y</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回这个 <strong>Projection</strong> 的副本，Y 列中数值的符号都进行了翻转。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-get-aspect"></target>
            <paragraph classes="classref-method" ids="class-projection-method-get-aspect" names="class_projection_method_get_aspect"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>get_aspect</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该 <strong>Projection</strong> 视口的 X:Y 纵横比。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-get-far-plane-half-extents"></target>
            <paragraph classes="classref-method" ids="class-projection-method-get-far-plane-half-extents" names="class_projection_method_get_far_plane_half_extents"><reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> <strong>get_far_plane_half_extents</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回投影远裁剪平面的尺寸除以二。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-get-fov"></target>
            <paragraph classes="classref-method" ids="class-projection-method-get-fov" names="class_projection_method_get_fov"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>get_fov</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该投影的水平视野（单位为度）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-get-fovy"></target>
            <paragraph classes="classref-method" ids="class-projection-method-get-fovy" names="class_projection_method_get_fovy"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>get_fovy</strong> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> fovx, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> aspect <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>返回与给定水平视场（以度为单位）和长宽比相关联的投影的垂直视场（以度为单位）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-get-lod-multiplier"></target>
            <paragraph classes="classref-method" ids="class-projection-method-get-lod-multiplier" names="class_projection_method_get_lod_multiplier"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>get_lod_multiplier</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回这个 <strong>Projection</strong> 对可见细节级别的缩放系数。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-get-pixels-per-meter"></target>
            <paragraph classes="classref-method" ids="class-projection-method-get-pixels-per-meter" names="class_projection_method_get_pixels_per_meter"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_pixels_per_meter</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> for_pixel_width <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>在该 <strong>Projection</strong> 被应用后，返回每米显示的具有给定像素宽度的像素数。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-get-projection-plane"></target>
            <paragraph classes="classref-method" ids="class-projection-method-get-projection-plane" names="class_projection_method_get_projection_plane"><reference internal="True" refuri="class_plane#class-plane"><inline classes="std std-ref">Plane</inline></reference> <strong>get_projection_plane</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> plane <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回这个 <strong>Projection</strong> 的裁剪平面，索引由 <literal>plane</literal> 给定。</paragraph>
            <paragraph><literal>plane</literal> 应该等于 <reference internal="True" refid="class-projection-constant-plane-near"><inline classes="std std-ref">PLANE_NEAR</inline></reference>、<reference internal="True" refid="class-projection-constant-plane-far"><inline classes="std std-ref">PLANE_FAR</inline></reference>、<reference internal="True" refid="class-projection-constant-plane-left"><inline classes="std std-ref">PLANE_LEFT</inline></reference>、<reference internal="True" refid="class-projection-constant-plane-top"><inline classes="std std-ref">PLANE_TOP</inline></reference>、<reference internal="True" refid="class-projection-constant-plane-right"><inline classes="std std-ref">PLANE_RIGHT</inline></reference> 或 <reference internal="True" refid="class-projection-constant-plane-bottom"><inline classes="std std-ref">PLANE_BOTTOM</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-get-viewport-half-extents"></target>
            <paragraph classes="classref-method" ids="class-projection-method-get-viewport-half-extents" names="class_projection_method_get_viewport_half_extents"><reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> <strong>get_viewport_half_extents</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回视口平面的尺寸除以二，这个 <strong>Projection</strong> 会把位置投影至该平面。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-get-z-far"></target>
            <paragraph classes="classref-method" ids="class-projection-method-get-z-far" names="class_projection_method_get_z_far"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>get_z_far</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该 <strong>Projection</strong> 中的距离，超过这个距离的位置会被裁剪。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-get-z-near"></target>
            <paragraph classes="classref-method" ids="class-projection-method-get-z-near" names="class_projection_method_get_z_near"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>get_z_near</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该 <strong>Projection</strong> 中的距离，未达到这个距离的位置会被裁剪。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-inverse"></target>
            <paragraph classes="classref-method" ids="class-projection-method-inverse" names="class_projection_method_inverse"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>inverse</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回执行这个 <strong>Projection</strong> 的逆投影变换的 <strong>Projection</strong>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-is-orthogonal"></target>
            <paragraph classes="classref-method" ids="class-projection-method-is-orthogonal" names="class_projection_method_is_orthogonal"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_orthogonal</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该 <strong>Projection</strong> 进行的是正交投影，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-jitter-offseted"></target>
            <paragraph classes="classref-method" ids="class-projection-method-jitter-offseted" names="class_projection_method_jitter_offseted"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>jitter_offseted</strong> <strong>(</strong> <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> offset <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回一个 <strong>Projection</strong>，X 和 Y 的取值由给定的 <reference internal="True" refuri="class_vector2#class-vector2"><inline classes="std std-ref">Vector2</inline></reference> 和最后一列中对应的第一个和第二个值相加而来。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-method-perspective-znear-adjusted"></target>
            <paragraph classes="classref-method" ids="class-projection-method-perspective-znear-adjusted" names="class_projection_method_perspective_znear_adjusted"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>perspective_znear_adjusted</strong> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> new_znear <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回一个 <strong>Projection</strong>，将其近裁剪距离调整为 <literal>new_znear</literal>。</paragraph>
            <paragraph><strong>注意：</strong>原始的 <strong>Projection</strong> 必须为透视投影。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id10" names="操作符说明">
            <title>操作符说明</title>
            <target refid="class-projection-operator-neq-projection"></target>
            <paragraph classes="classref-operator" ids="class-projection-operator-neq-projection" names="class_projection_operator_neq_projection"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong> <strong>(</strong> <reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果投影不相等，则返回 <literal>true</literal>。</paragraph>
            <paragraph><strong>注意：</strong>由于浮点精度误差，即使投影实际上相等，也可能会返回 <literal>true</literal> 。可能会在 Godot 的未来版本中添加 <literal>is_equal_approx</literal> 方法。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-operator-mul-projection"></target>
            <paragraph classes="classref-operator" ids="class-projection-operator-mul-projection" names="class_projection_operator_mul_projection"><reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> <strong>operator *</strong> <strong>(</strong> <reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>返回一个 <strong>Projection</strong>，应用了这个 <strong>Projection</strong> 和 <literal>right</literal> 的组合变换。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-operator-mul-vector4"></target>
            <paragraph classes="classref-operator" ids="class-projection-operator-mul-vector4" names="class_projection_operator_mul_vector4"><reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> <strong>operator *</strong> <strong>(</strong> <reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>使用这个 <strong>Projection</strong> 矩阵将给定的 <reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> 进行投影（相乘）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-operator-eq-projection"></target>
            <paragraph classes="classref-operator" ids="class-projection-operator-eq-projection" names="class_projection_operator_eq_projection"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong> <strong>(</strong> <reference internal="True" refid="class-projection"><inline classes="std std-ref">Projection</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果投影相等，则返回 <literal>true</literal>。</paragraph>
            <paragraph><strong>注意：</strong>由于浮点精度错误，即使投影实际上相等，也可能会返回 <literal>false</literal>。可能会在 Godot 的未来版本中添加 <literal>is_equal_approx</literal> 方法。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-projection-operator-idx-int"></target>
            <paragraph classes="classref-operator" ids="class-projection-operator-idx-int" names="class_projection_operator_idx_int"><reference internal="True" refuri="class_vector4#class-vector4"><inline classes="std std-ref">Vector4</inline></reference> <strong>operator []</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong></paragraph>
            <paragraph>返回具有给定索引的 <strong>Projection</strong> 的列。</paragraph>
            <paragraph>索引按以下顺序排列：x、y、z、w。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
