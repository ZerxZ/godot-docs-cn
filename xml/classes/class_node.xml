<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_node.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/4.2/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/4.2/doc/classes/Node.xml.</comment>
    <target refid="class-node"></target>
    <section ids="node class-node" names="node class_node">
        <title>Node</title>
        <paragraph><strong>继承：</strong> <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference></paragraph>
        <paragraph><strong>派生：</strong> <reference internal="True" refuri="class_animationmixer#class-animationmixer"><inline classes="std std-ref">AnimationMixer</inline></reference>, <reference internal="True" refuri="class_audiostreamplayer#class-audiostreamplayer"><inline classes="std std-ref">AudioStreamPlayer</inline></reference>, <reference internal="True" refuri="class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference>, <reference internal="True" refuri="class_canvaslayer#class-canvaslayer"><inline classes="std std-ref">CanvasLayer</inline></reference>, <reference internal="True" refuri="class_editorfilesystem#class-editorfilesystem"><inline classes="std std-ref">EditorFileSystem</inline></reference>, <reference internal="True" refuri="class_editorplugin#class-editorplugin"><inline classes="std std-ref">EditorPlugin</inline></reference>, <reference internal="True" refuri="class_editorresourcepreview#class-editorresourcepreview"><inline classes="std std-ref">EditorResourcePreview</inline></reference>, <reference internal="True" refuri="class_httprequest#class-httprequest"><inline classes="std std-ref">HTTPRequest</inline></reference>, <reference internal="True" refuri="class_instanceplaceholder#class-instanceplaceholder"><inline classes="std std-ref">InstancePlaceholder</inline></reference>, <reference internal="True" refuri="class_missingnode#class-missingnode"><inline classes="std std-ref">MissingNode</inline></reference>, <reference internal="True" refuri="class_multiplayerspawner#class-multiplayerspawner"><inline classes="std std-ref">MultiplayerSpawner</inline></reference>, <reference internal="True" refuri="class_multiplayersynchronizer#class-multiplayersynchronizer"><inline classes="std std-ref">MultiplayerSynchronizer</inline></reference>, <reference internal="True" refuri="class_navigationagent2d#class-navigationagent2d"><inline classes="std std-ref">NavigationAgent2D</inline></reference>, <reference internal="True" refuri="class_navigationagent3d#class-navigationagent3d"><inline classes="std std-ref">NavigationAgent3D</inline></reference>, <reference internal="True" refuri="class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference>, <reference internal="True" refuri="class_resourcepreloader#class-resourcepreloader"><inline classes="std std-ref">ResourcePreloader</inline></reference>, <reference internal="True" refuri="class_shaderglobalsoverride#class-shaderglobalsoverride"><inline classes="std std-ref">ShaderGlobalsOverride</inline></reference>, <reference internal="True" refuri="class_skeletonik3d#class-skeletonik3d"><inline classes="std std-ref">SkeletonIK3D</inline></reference>, <reference internal="True" refuri="class_timer#class-timer"><inline classes="std std-ref">Timer</inline></reference>, <reference internal="True" refuri="class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>, <reference internal="True" refuri="class_worldenvironment#class-worldenvironment"><inline classes="std std-ref">WorldEnvironment</inline></reference></paragraph>
        <paragraph>所有场景对象的基类。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>节点是 Godot 的构建模块。它们可以被指定为另一个节点的子节点，从而形成树状排列。一个给定的节点可以包含任意数量的节点作为子节点，要求所有的兄弟节点（即该节点的直接子节点）的名字唯一。</paragraph>
            <paragraph>节点树被称为<emphasis>场景</emphasis>。场景可以被保存到磁盘上，然后被实例化到其他场景中。这使得 Godot 项目的架构和数据模型具有非常高的灵活性。</paragraph>
            <paragraph><strong>场景树：</strong><reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 包含活动的节点树。当一个节点被添加到场景树中时，它将收到 <reference internal="True" refid="class-node-constant-notification-enter-tree"><inline classes="std std-ref">NOTIFICATION_ENTER_TREE</inline></reference> 通知，并触发其 <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree</inline></reference> 回调。子节点总是在其父节点<emphasis>之后</emphasis>被添加，即父节点的 <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree</inline></reference> 回调将在其子节点的之前被触发。</paragraph>
            <paragraph>一旦所有的节点被添加到场景树中，它们就会收到 <reference internal="True" refid="class-node-constant-notification-ready"><inline classes="std std-ref">NOTIFICATION_READY</inline></reference> 通知，其各自的 <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready</inline></reference> 回调被触发。对于一组节点，<reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready</inline></reference> 回调是按相反的顺序调用的，从子节点开始，向上移动到父节点。</paragraph>
            <paragraph>这意味着，当把一个节点添加到场景树中时，将使用下面的顺序进行回调：父节点的 <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree</inline></reference>、子节点的 <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree</inline></reference>、子节点的 <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready</inline></reference>，最后是父节点的 <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready</inline></reference>（对整个场景树进行递归）。</paragraph>
            <paragraph><strong>处理：</strong>节点可以覆盖“处理”状态，以便它们在每一帧上都收到回调，要求它们进行处理（做一些事情）。普通处理（回调 <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process</inline></reference>，可以使用 <reference internal="True" refid="class-node-method-set-process"><inline classes="std std-ref">set_process</inline></reference> 开关）会尽可能快地发生，并且取决于帧率，所以处理时间 <emphasis>delta</emphasis>（单位为秒）会作为参数传入。物理处理（回调 <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process</inline></reference>，可以使用 <reference internal="True" refid="class-node-method-set-physics-process"><inline classes="std std-ref">set_physics_process</inline></reference> 开关）每秒发生固定次数（默认为 60），对物理引擎相关的代码很有用。</paragraph>
            <paragraph>节点也可以处理输入事件。存在 <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input</inline></reference> 函数时，程序每收到一次输入都会去调用它。在许多情况下，这么做是大材小用了（除非是用于简单的项目），用 <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input</inline></reference> 函数可能更合适；当输入事件没有被其他节点（通常是 GUI <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 节点）处理时，才会调用这个函数，可以确保节点只接收到它该收到的事件。</paragraph>
            <paragraph>为了记录场景的层次结构（尤其是在将场景实例化到其他场景时）可以用 <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> 属性为节点设置一个“所有者”。它记录的是谁实例化了什么。这在编写编辑器和工具时非常有用。</paragraph>
            <paragraph>最后，当一个节点被 <reference internal="True" refuri="class_object#class-object-method-free"><inline classes="std std-ref">Object.free</inline></reference> 或 <reference internal="True" refid="class-node-method-queue-free"><inline classes="std std-ref">queue_free</inline></reference> 释放时，它也将释放它的所有子节点。</paragraph>
            <paragraph><strong>分组：</strong>节点可以被添加到很多的组中，以方便管理，你可以根据自己游戏的需要来创建类似“敌人”或“收集品”这样的组。见 <reference internal="True" refid="class-node-method-add-to-group"><inline classes="std std-ref">add_to_group</inline></reference>、<reference internal="True" refid="class-node-method-is-in-group"><inline classes="std std-ref">is_in_group</inline></reference> 和 <reference internal="True" refid="class-node-method-remove-from-group"><inline classes="std std-ref">remove_from_group</inline></reference>。加入组后，你可以检索这些组中的所有节点，对它们进行迭代，甚至通过 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 中的方法调用组内方法。</paragraph>
            <paragraph><strong>节点的网络编程：</strong>在连接到服务器（或制作服务器，见 <reference internal="True" refuri="class_enetmultiplayerpeer#class-enetmultiplayerpeer"><inline classes="std std-ref">ENetMultiplayerPeer</inline></reference>）之后，可以使用内置的 RPC（远程过程调用）系统在网络上进行通信。在调用 <reference internal="True" refid="class-node-method-rpc"><inline classes="std std-ref">rpc</inline></reference> 时传入方法名，将在本地和所有已连接的对等体中调用对应的方法（对等体=客户端和接受连接的服务器）。为了识别哪个节点收到 RPC 调用，Godot 将使用它的 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>（请确保所有对等体上的节点名称相同）。另外，请参阅高级网络教程和相应的演示。</paragraph>
            <paragraph><strong>注意：</strong><literal>script</literal> 属性是 <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference> 类的一部分，不属于 <strong>Node</strong>。这个属性暴露的方式和其他属性不同，但提供了 setter 和 getter（见 <reference internal="True" refuri="class_object#class-object-method-set-script"><inline classes="std std-ref">Object.set_script</inline></reference> 和 <reference internal="True" refuri="class_object#class-object-method-get-script"><inline classes="std std-ref">Object.get_script</inline></reference>）。</paragraph>
        </section>
        <section classes="classref-introduction-group" ids="id2" names="教程">
            <title>教程</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../getting_started/step_by_step/nodes_and_scenes"><inline classes="doc">节点与场景</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="所有演示" refuri="https://github.com/godotengine/godot-demo-projects/">所有演示</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="属性">
            <title>属性</title>
            <table classes="colwidths-auto">
                <tgroup cols="3">
                    <colspec colwidth="77"></colspec>
                    <colspec colwidth="83"></colspec>
                    <colspec colwidth="11"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-editor-description"><inline classes="std std-ref">editor_description</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>""</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-multiplayer"><inline classes="std std-ref">multiplayer</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-process-mode"><inline classes="std std-ref">process_mode</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>0</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-process-physics-priority"><inline classes="std std-ref">process_physics_priority</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>0</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-process-priority"><inline classes="std std-ref">process_priority</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>0</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref">ProcessThreadGroup</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-process-thread-group"><inline classes="std std-ref">process_thread_group</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>0</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-process-thread-group-order"><inline classes="std std-ref">process_thread_group_order</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation>&lt;<reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref">ProcessThreadMessages</inline></reference>&gt;</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-process-thread-messages"><inline classes="std std-ref">process_thread_messages</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-scene-file-path"><inline classes="std std-ref">scene_file_path</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-unique-name-in-owner"><inline classes="std std-ref">unique_name_in_owner</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>false</literal></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id4" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="51"></colspec>
                    <colspec colwidth="224"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-exit-tree"><inline classes="std std-ref">_exit_tree</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-get-configuration-warnings"><inline classes="std std-ref">_get_configuration_warnings</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> event <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> delta <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> delta <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-shortcut-input"><inline classes="std std-ref">_shortcut_input</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> event <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> event <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref">_unhandled_key_input</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> event <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> force_readable_name=false, <reference internal="True" refid="enum-node-internalmode"><inline classes="std std-ref">InternalMode</inline></reference> internal=0 <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-add-sibling"><inline classes="std std-ref">add_sibling</inline></reference> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> sibling, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> force_readable_name=false <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-add-to-group"><inline classes="std std-ref">add_to_group</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> group, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> persistent=false <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-call-deferred-thread-group"><inline classes="std std-ref">call_deferred_thread_group</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> method, ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-call-thread-safe"><inline classes="std std-ref">call_thread_safe</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> method, ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-can-process"><inline classes="std std-ref">can_process</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-create-tween"><inline classes="std std-ref">create_tween</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-duplicate"><inline classes="std std-ref">duplicate</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> flags=15 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-find-child"><inline classes="std std-ref">find_child</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> pattern, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> recursive=true, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> owned=true <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node[]</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-find-children"><inline classes="std std-ref">find_children</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> pattern, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> type="", <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> recursive=true, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> owned=true <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-find-parent"><inline classes="std std-ref">find_parent</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> pattern <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-child"><inline classes="std std-ref">get_child</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> idx, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> include_internal=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-child-count"><inline classes="std std-ref">get_child_count</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> include_internal=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node[]</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-children"><inline classes="std std-ref">get_children</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> include_internal=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName[]</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-groups"><inline classes="std std-ref">get_groups</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-index"><inline classes="std std-ref">get_index</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> include_internal=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-last-exclusive-window"><inline classes="std std-ref">get_last_exclusive_window</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-multiplayer-authority"><inline classes="std std-ref">get_multiplayer_authority</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> path <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-node-and-resource"><inline classes="std std-ref">get_node_and_resource</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> path <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-node-or-null"><inline classes="std std-ref">get_node_or_null</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> path <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-parent"><inline classes="std std-ref">get_parent</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-path"><inline classes="std std-ref">get_path</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-path-to"><inline classes="std std-ref">get_path_to</inline></reference> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> use_unique_path=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-physics-process-delta-time"><inline classes="std std-ref">get_physics_process_delta_time</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-process-delta-time"><inline classes="std std-ref">get_process_delta_time</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-scene-instance-load-placeholder"><inline classes="std std-ref">get_scene_instance_load_placeholder</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-tree"><inline classes="std std-ref">get_tree</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-tree-string"><inline classes="std std-ref">get_tree_string</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-tree-string-pretty"><inline classes="std std-ref">get_tree_string_pretty</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-viewport"><inline classes="std std-ref">get_viewport</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-window"><inline classes="std std-ref">get_window</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-has-node"><inline classes="std std-ref">has_node</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> path <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-has-node-and-resource"><inline classes="std std-ref">has_node_and_resource</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> path <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-ancestor-of"><inline classes="std std-ref">is_ancestor_of</inline></reference> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-displayed-folded"><inline classes="std std-ref">is_displayed_folded</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-editable-instance"><inline classes="std std-ref">is_editable_instance</inline></reference> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-greater-than"><inline classes="std std-ref">is_greater_than</inline></reference> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-in-group"><inline classes="std std-ref">is_in_group</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> group <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-inside-tree"><inline classes="std std-ref">is_inside_tree</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-multiplayer-authority"><inline classes="std std-ref">is_multiplayer_authority</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-node-ready"><inline classes="std std-ref">is_node_ready</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-physics-processing"><inline classes="std std-ref">is_physics_processing</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-physics-processing-internal"><inline classes="std std-ref">is_physics_processing_internal</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-processing"><inline classes="std std-ref">is_processing</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-processing-input"><inline classes="std std-ref">is_processing_input</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-processing-internal"><inline classes="std std-ref">is_processing_internal</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-processing-shortcut-input"><inline classes="std std-ref">is_processing_shortcut_input</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-processing-unhandled-input"><inline classes="std std-ref">is_processing_unhandled_input</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-processing-unhandled-key-input"><inline classes="std std-ref">is_processing_unhandled_key_input</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-move-child"><inline classes="std std-ref">move_child</inline></reference> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> child_node, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> to_index <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-notify-deferred-thread-group"><inline classes="std std-ref">notify_deferred_thread_group</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> what <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-notify-thread-safe"><inline classes="std std-ref">notify_thread_safe</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> what <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-print-orphan-nodes"><inline classes="std std-ref">print_orphan_nodes</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-print-tree"><inline classes="std std-ref">print_tree</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-print-tree-pretty"><inline classes="std std-ref">print_tree_pretty</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-propagate-call"><inline classes="std std-ref">propagate_call</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> method, <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> args=[], <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> parent_first=false <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-propagate-notification"><inline classes="std std-ref">propagate_notification</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> what <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-queue-free"><inline classes="std std-ref">queue_free</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-remove-child"><inline classes="std std-ref">remove_child</inline></reference> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-remove-from-group"><inline classes="std std-ref">remove_from_group</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> group <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-reparent"><inline classes="std std-ref">reparent</inline></reference> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> new_parent, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> keep_global_transform=true <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-replace-by"><inline classes="std std-ref">replace_by</inline></reference> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> keep_groups=false <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-request-ready"><inline classes="std std-ref">request_ready</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-rpc"><inline classes="std std-ref">rpc</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> method, ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-rpc-config"><inline classes="std std-ref">rpc_config</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> method, <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> config <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-rpc-id"><inline classes="std std-ref">rpc_id</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> peer_id, <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> method, ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-deferred-thread-group"><inline classes="std std-ref">set_deferred_thread_group</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> property, <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> value <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-display-folded"><inline classes="std std-ref">set_display_folded</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> fold <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-editable-instance"><inline classes="std std-ref">set_editable_instance</inline></reference> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> is_editable <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-multiplayer-authority"><inline classes="std std-ref">set_multiplayer_authority</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> id, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> recursive=true <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-physics-process"><inline classes="std std-ref">set_physics_process</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-physics-process-internal"><inline classes="std std-ref">set_physics_process_internal</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-process"><inline classes="std std-ref">set_process</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-process-input"><inline classes="std std-ref">set_process_input</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-process-internal"><inline classes="std std-ref">set_process_internal</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-process-shortcut-input"><inline classes="std std-ref">set_process_shortcut_input</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-process-unhandled-input"><inline classes="std std-ref">set_process_unhandled_input</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-process-unhandled-key-input"><inline classes="std std-ref">set_process_unhandled_key_input</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-scene-instance-load-placeholder"><inline classes="std std-ref">set_scene_instance_load_placeholder</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> load_placeholder <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-thread-safe"><inline classes="std std-ref">set_thread_safe</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> property, <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> value <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph>void</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-update-configuration-warnings"><inline classes="std std-ref">update_configuration_warnings</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id5" names="信号">
            <title>信号</title>
            <target refid="class-node-signal-child-entered-tree"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-child-entered-tree" names="class_node_signal_child_entered_tree"><strong>child_entered_tree</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node <strong>)</strong></paragraph>
            <paragraph>当子节点 <literal>node</literal> 进入 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 时触发，通常是因为该节点进入了树（参见 <reference internal="True" refid="class-node-signal-tree-entered"><inline classes="std std-ref">tree_entered</inline></reference>），或者 <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference> 已被调用。</paragraph>
            <paragraph>该信号在子节点自己的 <reference internal="True" refid="class-node-constant-notification-enter-tree"><inline classes="std std-ref">NOTIFICATION_ENTER_TREE</inline></reference> 和 <reference internal="True" refid="class-node-signal-tree-entered"><inline classes="std std-ref">tree_entered</inline></reference> <emphasis>之后</emphasis>触发。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-child-exiting-tree"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-child-exiting-tree" names="class_node_signal_child_exiting_tree"><strong>child_exiting_tree</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node <strong>)</strong></paragraph>
            <paragraph>当子节点 <literal>node</literal> 即将退出 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 时发出，通常是因为该节点正在退出树（请参阅 <reference internal="True" refid="class-node-signal-tree-exiting"><inline classes="std std-ref">tree_exiting</inline></reference>），或者因为子节点 <literal>node</literal> 正在被移除或释放。</paragraph>
            <paragraph>当收到该信号时，子节点 <literal>node</literal> 仍然可以在树内访问。该信号在子节点自己的 <reference internal="True" refid="class-node-signal-tree-exiting"><inline classes="std std-ref">tree_exiting</inline></reference> 和 <reference internal="True" refid="class-node-constant-notification-exit-tree"><inline classes="std std-ref">NOTIFICATION_EXIT_TREE</inline></reference> <emphasis>之后</emphasis>触发。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-child-order-changed"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-child-order-changed" names="class_node_signal_child_order_changed"><strong>child_order_changed</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>子节点列表发生改变时发出。发生在添加、移动、移除子节点时。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-ready"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-ready" names="class_node_signal_ready"><strong>ready</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>在 <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready</inline></reference> 被调用后，当节点被视为就绪时发出。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-renamed"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-renamed" names="class_node_signal_renamed"><strong>renamed</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>节点位于场景树中，在节点的 <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference> 更改时发出。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-replacing-by"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-replacing-by" names="class_node_signal_replacing_by"><strong>replacing_by</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node <strong>)</strong></paragraph>
            <paragraph>当该节点被 <literal>node</literal> 替换时触发，见 <reference internal="True" refid="class-node-method-replace-by"><inline classes="std std-ref">replace_by</inline></reference>。</paragraph>
            <paragraph>这个信号的触发时机在 <literal>node</literal> 被添加为原父节点的子节点<emphasis>之后</emphasis>，但是在所有原子节点重设父节点为 <literal>node</literal> <emphasis>之前</emphasis>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-tree-entered"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-tree-entered" names="class_node_signal_tree_entered"><strong>tree_entered</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>当该节点进入树时触发。</paragraph>
            <paragraph>这个信号会在相关的 <reference internal="True" refid="class-node-constant-notification-enter-tree"><inline classes="std std-ref">NOTIFICATION_ENTER_TREE</inline></reference> 通知<emphasis>之后</emphasis>触发。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-tree-exited"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-tree-exited" names="class_node_signal_tree_exited"><strong>tree_exited</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>节点退出树并且不再活动后发出。</paragraph>
            <paragraph>该信号会在相关的 <reference internal="True" refid="class-node-constant-notification-exit-tree"><inline classes="std std-ref">NOTIFICATION_EXIT_TREE</inline></reference> 通知<emphasis>之后</emphasis>发出。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-tree-exiting"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-tree-exiting" names="class_node_signal_tree_exiting"><strong>tree_exiting</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>当节点即将退出树时发出。节点仍然有效。因此，这是反初始化（如果愿意，也可以称之为“析构函数”）的正确位置。</paragraph>
            <paragraph>该信号会在节点的 <reference internal="True" refid="class-node-private-method-exit-tree"><inline classes="std std-ref">_exit_tree</inline></reference> <emphasis>之后</emphasis>和相关的 <reference internal="True" refid="class-node-constant-notification-exit-tree"><inline classes="std std-ref">NOTIFICATION_EXIT_TREE</inline></reference> <emphasis>之前</emphasis>发出。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id6" names="枚举">
            <title>枚举</title>
            <target refid="enum-node-processmode"></target>
            <paragraph classes="classref-enumeration" ids="enum-node-processmode" names="enum_node_processmode">enum <strong>ProcessMode</strong>:</paragraph>
            <target refid="class-node-constant-process-mode-inherit"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-mode-inherit" names="class_node_constant_process_mode_inherit"><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> <strong>PROCESS_MODE_INHERIT</strong> = <literal>0</literal></paragraph>
            <paragraph>从该节点的父节点继承 <reference internal="True" refid="class-node-property-process-mode"><inline classes="std std-ref">process_mode</inline></reference>。对于根节点来说，这相当于 <reference internal="True" refid="class-node-constant-process-mode-pausable"><inline classes="std std-ref">PROCESS_MODE_PAUSABLE</inline></reference>。这是任何新创建的节点的默认设置。</paragraph>
            <target refid="class-node-constant-process-mode-pausable"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-mode-pausable" names="class_node_constant_process_mode_pausable"><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> <strong>PROCESS_MODE_PAUSABLE</strong> = <literal>1</literal></paragraph>
            <paragraph>当 <reference internal="True" refuri="class_scenetree#class-scenetree-property-paused"><inline classes="std std-ref">SceneTree.paused</inline></reference> 为 <literal>true</literal> 时停止处理。与 <reference internal="True" refid="class-node-constant-process-mode-when-paused"><inline classes="std std-ref">PROCESS_MODE_WHEN_PAUSED</inline></reference> 相反。</paragraph>
            <target refid="class-node-constant-process-mode-when-paused"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-mode-when-paused" names="class_node_constant_process_mode_when_paused"><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> <strong>PROCESS_MODE_WHEN_PAUSED</strong> = <literal>2</literal></paragraph>
            <paragraph><strong>仅</strong>当 <reference internal="True" refuri="class_scenetree#class-scenetree-property-paused"><inline classes="std std-ref">SceneTree.paused</inline></reference> 为 <literal>true</literal> 时处理。与 <reference internal="True" refid="class-node-constant-process-mode-pausable"><inline classes="std std-ref">PROCESS_MODE_PAUSABLE</inline></reference> 相反。</paragraph>
            <target refid="class-node-constant-process-mode-always"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-mode-always" names="class_node_constant_process_mode_always"><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> <strong>PROCESS_MODE_ALWAYS</strong> = <literal>3</literal></paragraph>
            <paragraph>始终处理。继续处理，忽略 <reference internal="True" refuri="class_scenetree#class-scenetree-property-paused"><inline classes="std std-ref">SceneTree.paused</inline></reference>。与 <reference internal="True" refid="class-node-constant-process-mode-disabled"><inline classes="std std-ref">PROCESS_MODE_DISABLED</inline></reference> 相反。</paragraph>
            <target refid="class-node-constant-process-mode-disabled"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-mode-disabled" names="class_node_constant_process_mode_disabled"><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> <strong>PROCESS_MODE_DISABLED</strong> = <literal>4</literal></paragraph>
            <paragraph>从不处理。完全禁用处理，忽略 <reference internal="True" refuri="class_scenetree#class-scenetree-property-paused"><inline classes="std std-ref">SceneTree.paused</inline></reference>。与 <reference internal="True" refid="class-node-constant-process-mode-always"><inline classes="std std-ref">PROCESS_MODE_ALWAYS</inline></reference> 相反。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-node-processthreadgroup"></target>
            <paragraph classes="classref-enumeration" ids="enum-node-processthreadgroup" names="enum_node_processthreadgroup">enum <strong>ProcessThreadGroup</strong>:</paragraph>
            <target refid="class-node-constant-process-thread-group-inherit"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-thread-group-inherit" names="class_node_constant_process_thread_group_inherit"><reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref">ProcessThreadGroup</inline></reference> <strong>PROCESS_THREAD_GROUP_INHERIT</strong> = <literal>0</literal></paragraph>
            <paragraph>如果 <reference internal="True" refid="class-node-property-process-thread-group"><inline classes="std std-ref">process_thread_group</inline></reference> 属性设为这个值，该节点会属于线程组不是继承的父节点（或祖父节点）。详见 <reference internal="True" refid="class-node-property-process-thread-group"><inline classes="std std-ref">process_thread_group</inline></reference>。</paragraph>
            <target refid="class-node-constant-process-thread-group-main-thread"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-thread-group-main-thread" names="class_node_constant_process_thread_group_main_thread"><reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref">ProcessThreadGroup</inline></reference> <strong>PROCESS_THREAD_GROUP_MAIN_THREAD</strong> = <literal>1</literal></paragraph>
            <paragraph>在主线程上处理该节点（以及设为继承的子节点）。详见 <reference internal="True" refid="class-node-property-process-thread-group"><inline classes="std std-ref">process_thread_group</inline></reference>。</paragraph>
            <target refid="class-node-constant-process-thread-group-sub-thread"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-thread-group-sub-thread" names="class_node_constant_process_thread_group_sub_thread"><reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref">ProcessThreadGroup</inline></reference> <strong>PROCESS_THREAD_GROUP_SUB_THREAD</strong> = <literal>2</literal></paragraph>
            <paragraph>在子线程上处理该节点（以及设为继承的子节点）。详见 <reference internal="True" refid="class-node-property-process-thread-group"><inline classes="std std-ref">process_thread_group</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-node-processthreadmessages"></target>
            <paragraph classes="classref-enumeration" ids="enum-node-processthreadmessages" names="enum_node_processthreadmessages">flags <strong>ProcessThreadMessages</strong>:</paragraph>
            <target refid="class-node-constant-flag-process-thread-messages"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-flag-process-thread-messages" names="class_node_constant_flag_process_thread_messages"><reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref">ProcessThreadMessages</inline></reference> <strong>FLAG_PROCESS_THREAD_MESSAGES</strong> = <literal>1</literal></paragraph>
            <target refid="class-node-constant-flag-process-thread-messages-physics"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-flag-process-thread-messages-physics" names="class_node_constant_flag_process_thread_messages_physics"><reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref">ProcessThreadMessages</inline></reference> <strong>FLAG_PROCESS_THREAD_MESSAGES_PHYSICS</strong> = <literal>2</literal></paragraph>
            <target refid="class-node-constant-flag-process-thread-messages-all"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-flag-process-thread-messages-all" names="class_node_constant_flag_process_thread_messages_all"><reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref">ProcessThreadMessages</inline></reference> <strong>FLAG_PROCESS_THREAD_MESSAGES_ALL</strong> = <literal>3</literal></paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-node-duplicateflags"></target>
            <paragraph classes="classref-enumeration" ids="enum-node-duplicateflags" names="enum_node_duplicateflags">enum <strong>DuplicateFlags</strong>:</paragraph>
            <target refid="class-node-constant-duplicate-signals"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-duplicate-signals" names="class_node_constant_duplicate_signals"><reference internal="True" refid="enum-node-duplicateflags"><inline classes="std std-ref">DuplicateFlags</inline></reference> <strong>DUPLICATE_SIGNALS</strong> = <literal>1</literal></paragraph>
            <paragraph>复制该节点的信号连接。</paragraph>
            <target refid="class-node-constant-duplicate-groups"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-duplicate-groups" names="class_node_constant_duplicate_groups"><reference internal="True" refid="enum-node-duplicateflags"><inline classes="std std-ref">DuplicateFlags</inline></reference> <strong>DUPLICATE_GROUPS</strong> = <literal>2</literal></paragraph>
            <paragraph>复制节点的分组。</paragraph>
            <target refid="class-node-constant-duplicate-scripts"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-duplicate-scripts" names="class_node_constant_duplicate_scripts"><reference internal="True" refid="enum-node-duplicateflags"><inline classes="std std-ref">DuplicateFlags</inline></reference> <strong>DUPLICATE_SCRIPTS</strong> = <literal>4</literal></paragraph>
            <paragraph>复制该节点的脚本（与 <reference internal="True" refid="class-node-constant-duplicate-use-instantiation"><inline classes="std std-ref">DUPLICATE_USE_INSTANTIATION</inline></reference> 组合时包括祖级脚本）。</paragraph>
            <target refid="class-node-constant-duplicate-use-instantiation"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-duplicate-use-instantiation" names="class_node_constant_duplicate_use_instantiation"><reference internal="True" refid="enum-node-duplicateflags"><inline classes="std std-ref">DuplicateFlags</inline></reference> <strong>DUPLICATE_USE_INSTANTIATION</strong> = <literal>8</literal></paragraph>
            <paragraph>使用 <reference internal="True" refuri="class_packedscene#class-packedscene-method-instantiate"><inline classes="std std-ref">PackedScene.instantiate</inline></reference> 进行复制。如果该节点来自磁盘上保存的场景，则会重用 <reference internal="True" refuri="class_packedscene#class-packedscene-method-instantiate"><inline classes="std std-ref">PackedScene.instantiate</inline></reference> 作为该节点及其子节点副本的基础。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-node-internalmode"></target>
            <paragraph classes="classref-enumeration" ids="enum-node-internalmode" names="enum_node_internalmode">enum <strong>InternalMode</strong>:</paragraph>
            <target refid="class-node-constant-internal-mode-disabled"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-internal-mode-disabled" names="class_node_constant_internal_mode_disabled"><reference internal="True" refid="enum-node-internalmode"><inline classes="std std-ref">InternalMode</inline></reference> <strong>INTERNAL_MODE_DISABLED</strong> = <literal>0</literal></paragraph>
            <paragraph>该节点不是内部节点。</paragraph>
            <target refid="class-node-constant-internal-mode-front"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-internal-mode-front" names="class_node_constant_internal_mode_front"><reference internal="True" refid="enum-node-internalmode"><inline classes="std std-ref">InternalMode</inline></reference> <strong>INTERNAL_MODE_FRONT</strong> = <literal>1</literal></paragraph>
            <paragraph>该节点将被放置在父节点的子节点列表开头，位于所有非内部兄弟节点之前。</paragraph>
            <target refid="class-node-constant-internal-mode-back"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-internal-mode-back" names="class_node_constant_internal_mode_back"><reference internal="True" refid="enum-node-internalmode"><inline classes="std std-ref">InternalMode</inline></reference> <strong>INTERNAL_MODE_BACK</strong> = <literal>2</literal></paragraph>
            <paragraph>该节点将被放置在父节点的子节点列表末尾，位于所有非内部兄弟节点之后。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id7" names="常量">
            <title>常量</title>
            <target refid="class-node-constant-notification-enter-tree"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-enter-tree" names="class_node_constant_notification_enter_tree"><strong>NOTIFICATION_ENTER_TREE</strong> = <literal>10</literal></paragraph>
            <paragraph>当节点进入 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 时收到的通知。请参阅 <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree</inline></reference>。</paragraph>
            <paragraph>该通知会在相关 <reference internal="True" refid="class-node-signal-tree-entered"><inline classes="std std-ref">tree_entered</inline></reference> 信号<emphasis>之前</emphasis>收到。</paragraph>
            <target refid="class-node-constant-notification-exit-tree"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-exit-tree" names="class_node_constant_notification_exit_tree"><strong>NOTIFICATION_EXIT_TREE</strong> = <literal>11</literal></paragraph>
            <paragraph>当节点即将退出 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 时收到的通知。请参阅 <reference internal="True" refid="class-node-private-method-exit-tree"><inline classes="std std-ref">_exit_tree</inline></reference>。</paragraph>
            <paragraph>该通知会在相关的 <reference internal="True" refid="class-node-signal-tree-exiting"><inline classes="std std-ref">tree_exiting</inline></reference> 信号<emphasis>之后</emphasis>收到。</paragraph>
            <target refid="class-node-constant-notification-moved-in-parent"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-moved-in-parent" names="class_node_constant_notification_moved_in_parent"><strong>NOTIFICATION_MOVED_IN_PARENT</strong> = <literal>12</literal></paragraph>
            <paragraph><emphasis>已废弃。</emphasis>不会再发出这个通知。请改用 <reference internal="True" refid="class-node-constant-notification-child-order-changed"><inline classes="std std-ref">NOTIFICATION_CHILD_ORDER_CHANGED</inline></reference>。</paragraph>
            <target refid="class-node-constant-notification-ready"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-ready" names="class_node_constant_notification_ready"><strong>NOTIFICATION_READY</strong> = <literal>13</literal></paragraph>
            <paragraph>当该节点就绪时接收到通知。见 <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready</inline></reference>。</paragraph>
            <target refid="class-node-constant-notification-paused"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-paused" names="class_node_constant_notification_paused"><strong>NOTIFICATION_PAUSED</strong> = <literal>14</literal></paragraph>
            <paragraph>当节点暂停时收到的通知。请参阅 <reference internal="True" refid="class-node-property-process-mode"><inline classes="std std-ref">process_mode</inline></reference>。</paragraph>
            <target refid="class-node-constant-notification-unpaused"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-unpaused" names="class_node_constant_notification_unpaused"><strong>NOTIFICATION_UNPAUSED</strong> = <literal>15</literal></paragraph>
            <paragraph>当节点取消暂停时收到的通知。请参阅 <reference internal="True" refid="class-node-property-process-mode"><inline classes="std std-ref">process_mode</inline></reference>。</paragraph>
            <target refid="class-node-constant-notification-physics-process"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-physics-process" names="class_node_constant_notification_physics_process"><strong>NOTIFICATION_PHYSICS_PROCESS</strong> = <literal>16</literal></paragraph>
            <paragraph>当 <reference internal="True" refid="class-node-method-is-physics-processing"><inline classes="std std-ref">is_physics_processing</inline></reference> 返回 <literal>true</literal> 时，每个物理帧都会从场景树收到的通知。请参阅 <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process</inline></reference>。</paragraph>
            <target refid="class-node-constant-notification-process"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-process" names="class_node_constant_notification_process"><strong>NOTIFICATION_PROCESS</strong> = <literal>17</literal></paragraph>
            <paragraph>当 <reference internal="True" refid="class-node-method-is-processing"><inline classes="std std-ref">is_processing</inline></reference> 返回 <literal>true</literal> 时，每个渲染帧从场景树收到的通知。请参阅 <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process</inline></reference>。</paragraph>
            <target refid="class-node-constant-notification-parented"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-parented" names="class_node_constant_notification_parented"><strong>NOTIFICATION_PARENTED</strong> = <literal>18</literal></paragraph>
            <paragraph>当节点被设置为另一个节点的子节点时收到的通知（请参阅 <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference> 和 <reference internal="True" refid="class-node-method-add-sibling"><inline classes="std std-ref">add_sibling</inline></reference>）。</paragraph>
            <paragraph><strong>注意：</strong>这并<emphasis>不</emphasis>意味着该节点进入了 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>。</paragraph>
            <target refid="class-node-constant-notification-unparented"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-unparented" names="class_node_constant_notification_unparented"><strong>NOTIFICATION_UNPARENTED</strong> = <literal>19</literal></paragraph>
            <paragraph>当父节点在该节点上调用 <reference internal="True" refid="class-node-method-remove-child"><inline classes="std std-ref">remove_child</inline></reference> 时收到的通知。</paragraph>
            <paragraph><strong>注意：</strong>这并<emphasis>不</emphasis>意味着该节点退出了 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>。</paragraph>
            <target refid="class-node-constant-notification-scene-instantiated"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-scene-instantiated" names="class_node_constant_notification_scene_instantiated"><strong>NOTIFICATION_SCENE_INSTANTIATED</strong> = <literal>20</literal></paragraph>
            <paragraph>当 <reference internal="True" refuri="class_packedscene#class-packedscene-method-instantiate"><inline classes="std std-ref">PackedScene.instantiate</inline></reference> 完成时，<emphasis>仅</emphasis>被新实例化的场景根节点收到的通知。</paragraph>
            <target refid="class-node-constant-notification-drag-begin"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-drag-begin" names="class_node_constant_notification_drag_begin"><strong>NOTIFICATION_DRAG_BEGIN</strong> = <literal>21</literal></paragraph>
            <paragraph>当拖拽操作开始时收到的通知。所有节点都会收到此通知，而不仅仅是被拖动的节点。</paragraph>
            <paragraph>可以通过拖动提供拖动数据的 <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference>（见 <reference internal="True" refuri="class_control#class-control-private-method-get-drag-data"><inline classes="std std-ref">Control._get_drag_data</inline></reference>），或使用 <reference internal="True" refuri="class_control#class-control-method-force-drag"><inline classes="std std-ref">Control.force_drag</inline></reference> 来触发。</paragraph>
            <paragraph>请使用 <reference internal="True" refuri="class_viewport#class-viewport-method-gui-get-drag-data"><inline classes="std std-ref">Viewport.gui_get_drag_data</inline></reference> 获取拖动数据。</paragraph>
            <target refid="class-node-constant-notification-drag-end"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-drag-end" names="class_node_constant_notification_drag_end"><strong>NOTIFICATION_DRAG_END</strong> = <literal>22</literal></paragraph>
            <paragraph>当拖拽操作结束时收到的通知。</paragraph>
            <paragraph>请使用 <reference internal="True" refuri="class_viewport#class-viewport-method-gui-is-drag-successful"><inline classes="std std-ref">Viewport.gui_is_drag_successful</inline></reference> 检查拖放是否成功。</paragraph>
            <target refid="class-node-constant-notification-path-renamed"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-path-renamed" names="class_node_constant_notification_path_renamed"><strong>NOTIFICATION_PATH_RENAMED</strong> = <literal>23</literal></paragraph>
            <paragraph>当该节点的 <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference> 或其祖先节点之一的 <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference> 更改时收到的通知。当节点从 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 中移除时，<emphasis>不会</emphasis>收到该通知。</paragraph>
            <target refid="class-node-constant-notification-child-order-changed"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-child-order-changed" names="class_node_constant_notification_child_order_changed"><strong>NOTIFICATION_CHILD_ORDER_CHANGED</strong> = <literal>24</literal></paragraph>
            <paragraph>子节点列表发生更改时收到的通知。子节点发生添加、移动、删除时列表会发生更改。</paragraph>
            <target refid="class-node-constant-notification-internal-process"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-internal-process" names="class_node_constant_notification_internal_process"><strong>NOTIFICATION_INTERNAL_PROCESS</strong> = <literal>25</literal></paragraph>
            <paragraph>当 <reference internal="True" refid="class-node-method-is-processing-internal"><inline classes="std std-ref">is_processing_internal</inline></reference> 返回 <literal>true</literal> 时，每个渲染帧都会从树中收到的通知。</paragraph>
            <target refid="class-node-constant-notification-internal-physics-process"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-internal-physics-process" names="class_node_constant_notification_internal_physics_process"><strong>NOTIFICATION_INTERNAL_PHYSICS_PROCESS</strong> = <literal>26</literal></paragraph>
            <paragraph>当 <reference internal="True" refid="class-node-method-is-physics-processing-internal"><inline classes="std std-ref">is_physics_processing_internal</inline></reference> 返回 <literal>true</literal> 时，每个物理帧都会从树中收到的通知。</paragraph>
            <target refid="class-node-constant-notification-post-enter-tree"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-post-enter-tree" names="class_node_constant_notification_post_enter_tree"><strong>NOTIFICATION_POST_ENTER_TREE</strong> = <literal>27</literal></paragraph>
            <paragraph>当该节点进入树时，刚好在可能收到 <reference internal="True" refid="class-node-constant-notification-ready"><inline classes="std std-ref">NOTIFICATION_READY</inline></reference> 之前，收到的通知。与后者不同的是，它在节点每次进入树时都会发送，而不是只发送一次。</paragraph>
            <target refid="class-node-constant-notification-disabled"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-disabled" names="class_node_constant_notification_disabled"><strong>NOTIFICATION_DISABLED</strong> = <literal>28</literal></paragraph>
            <paragraph>当该节点被禁用时收到的通知。见 <reference internal="True" refid="class-node-constant-process-mode-disabled"><inline classes="std std-ref">PROCESS_MODE_DISABLED</inline></reference>。</paragraph>
            <target refid="class-node-constant-notification-enabled"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-enabled" names="class_node_constant_notification_enabled"><strong>NOTIFICATION_ENABLED</strong> = <literal>29</literal></paragraph>
            <paragraph>当该节点被禁用后又再次被启用时收到的通知。见 <reference internal="True" refid="class-node-constant-process-mode-disabled"><inline classes="std std-ref">PROCESS_MODE_DISABLED</inline></reference>。</paragraph>
            <target refid="class-node-constant-notification-editor-pre-save"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-editor-pre-save" names="class_node_constant_notification_editor_pre_save"><strong>NOTIFICATION_EDITOR_PRE_SAVE</strong> = <literal>9001</literal></paragraph>
            <paragraph>在编辑器中保存有节点的场景之前收到的通知。这个通知只在 Godot 编辑器中发送，不会出现在导出的项目中。</paragraph>
            <target refid="class-node-constant-notification-editor-post-save"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-editor-post-save" names="class_node_constant_notification_editor_post_save"><strong>NOTIFICATION_EDITOR_POST_SAVE</strong> = <literal>9002</literal></paragraph>
            <paragraph>在编辑器中保存有节点的场景后立即收到通知。这个通知只在 Godot 编辑器中发送，在导出的项目中不会出现。</paragraph>
            <target refid="class-node-constant-notification-wm-mouse-enter"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-mouse-enter" names="class_node_constant_notification_wm_mouse_enter"><strong>NOTIFICATION_WM_MOUSE_ENTER</strong> = <literal>1002</literal></paragraph>
            <paragraph>鼠标进入窗口时收到的通知。</paragraph>
            <paragraph>为内嵌窗口实现，并在桌面和 Web 平台上实现。</paragraph>
            <target refid="class-node-constant-notification-wm-mouse-exit"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-mouse-exit" names="class_node_constant_notification_wm_mouse_exit"><strong>NOTIFICATION_WM_MOUSE_EXIT</strong> = <literal>1003</literal></paragraph>
            <paragraph>鼠标离开窗口时收到的通知。</paragraph>
            <paragraph>为内嵌窗口实现，并在桌面和 Web 平台上实现。</paragraph>
            <target refid="class-node-constant-notification-wm-window-focus-in"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-window-focus-in" names="class_node_constant_notification_wm_window_focus_in"><strong>NOTIFICATION_WM_WINDOW_FOCUS_IN</strong> = <literal>1004</literal></paragraph>
            <paragraph>当节点的 <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> 祖先获得焦点时从操作系统收到的通知。这可能是同一引擎实例的两个窗口之间的焦点变化，也可能是从操作系统桌面或第三方应用程序切换到游戏的某个窗口的焦点变化（在这种情况下，还会收到 <reference internal="True" refid="class-node-constant-notification-application-focus-in"><inline classes="std std-ref">NOTIFICATION_APPLICATION_FOCUS_IN</inline></reference>）。</paragraph>
            <paragraph><reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> 节点会在获得焦点时收到该通知。</paragraph>
            <target refid="class-node-constant-notification-wm-window-focus-out"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-window-focus-out" names="class_node_constant_notification_wm_window_focus_out"><strong>NOTIFICATION_WM_WINDOW_FOCUS_OUT</strong> = <literal>1005</literal></paragraph>
            <paragraph>当节点的 <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> 祖先失去焦点时从操作系统收到的通知。这可能是同一引擎实例的两个窗口之间的焦点变化，也可能是从游戏的某一窗口切换到操作系统桌面或第三方应用程序的焦点变化（在这种情况下，还会收到 <reference internal="True" refid="class-node-constant-notification-application-focus-out"><inline classes="std std-ref">NOTIFICATION_APPLICATION_FOCUS_OUT</inline></reference>）。</paragraph>
            <paragraph><reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> 节点会在失去焦点时收到该通知。</paragraph>
            <target refid="class-node-constant-notification-wm-close-request"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-close-request" names="class_node_constant_notification_wm_close_request"><strong>NOTIFICATION_WM_CLOSE_REQUEST</strong> = <literal>1006</literal></paragraph>
            <paragraph>当发出关闭请求时，从操作系统收到的通知（例如使用“关闭”按钮或按下 <literal classes="kbd">Alt + F4</literal> 关闭窗口时）。</paragraph>
            <paragraph>在桌面平台上实现。</paragraph>
            <target refid="class-node-constant-notification-wm-go-back-request"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-go-back-request" names="class_node_constant_notification_wm_go_back_request"><strong>NOTIFICATION_WM_GO_BACK_REQUEST</strong> = <literal>1007</literal></paragraph>
            <paragraph>当一个返回请求发出时，从操作系统收到的通知（例如在 Android 系统上按下“返回”按钮）。</paragraph>
            <paragraph>仅在 iOS 上实现。</paragraph>
            <target refid="class-node-constant-notification-wm-size-changed"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-size-changed" names="class_node_constant_notification_wm_size_changed"><strong>NOTIFICATION_WM_SIZE_CHANGED</strong> = <literal>1008</literal></paragraph>
            <paragraph>当窗口大小被调整时收到的通知。</paragraph>
            <paragraph><strong>注意：</strong>只有调整大小的 <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> 节点才会收到该通知，并且不会传播到子节点。</paragraph>
            <target refid="class-node-constant-notification-wm-dpi-change"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-dpi-change" names="class_node_constant_notification_wm_dpi_change"><strong>NOTIFICATION_WM_DPI_CHANGE</strong> = <literal>1009</literal></paragraph>
            <paragraph>当屏幕的每英寸点数（DPI）比例发生更改时，从操作系统收到的通知。仅在 macOS 上实现。</paragraph>
            <target refid="class-node-constant-notification-vp-mouse-enter"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-vp-mouse-enter" names="class_node_constant_notification_vp_mouse_enter"><strong>NOTIFICATION_VP_MOUSE_ENTER</strong> = <literal>1010</literal></paragraph>
            <paragraph>当鼠标指针进入 <reference internal="True" refuri="class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> 的可见区域时收到的通知，可见区域指没有被其他 <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 和 <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> 遮挡的区域，并且需要 <reference internal="True" refuri="class_viewport#class-viewport-property-gui-disable-input"><inline classes="std std-ref">Viewport.gui_disable_input</inline></reference> 为 <literal>false</literal>，与当前是否持有焦点无关。</paragraph>
            <target refid="class-node-constant-notification-vp-mouse-exit"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-vp-mouse-exit" names="class_node_constant_notification_vp_mouse_exit"><strong>NOTIFICATION_VP_MOUSE_EXIT</strong> = <literal>1011</literal></paragraph>
            <paragraph>当鼠标指针离开 <reference internal="True" refuri="class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> 的可见区域时收到的通知，可见区域指没有被其他 <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 和 <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> 遮挡的区域，并且需要 <reference internal="True" refuri="class_viewport#class-viewport-property-gui-disable-input"><inline classes="std std-ref">Viewport.gui_disable_input</inline></reference> 为 <literal>false</literal>，与当前是否持有焦点无关。</paragraph>
            <target refid="class-node-constant-notification-os-memory-warning"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-os-memory-warning" names="class_node_constant_notification_os_memory_warning"><strong>NOTIFICATION_OS_MEMORY_WARNING</strong> = <literal>2009</literal></paragraph>
            <paragraph>当应用程序超过其分配的内存时，从操作系统收到的通知。</paragraph>
            <paragraph>仅在 iOS 上被实现。</paragraph>
            <target refid="class-node-constant-notification-translation-changed"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-translation-changed" names="class_node_constant_notification_translation_changed"><strong>NOTIFICATION_TRANSLATION_CHANGED</strong> = <literal>2010</literal></paragraph>
            <paragraph>当翻译可能发生变化时收到的通知。会在用户改变区域设置时触发。可以用来响应语言的变化，例如实时改变 UI 字符串。可配合内置的翻译支持使用，比如 <reference internal="True" refuri="class_object#class-object-method-tr"><inline classes="std std-ref">Object.tr</inline></reference>。</paragraph>
            <target refid="class-node-constant-notification-wm-about"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-about" names="class_node_constant_notification_wm_about"><strong>NOTIFICATION_WM_ABOUT</strong> = <literal>2011</literal></paragraph>
            <paragraph>当发出“关于”信息请求时，从操作系统收到的通知。</paragraph>
            <paragraph>仅在 macOS 上被实现。</paragraph>
            <target refid="class-node-constant-notification-crash"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-crash" names="class_node_constant_notification_crash"><strong>NOTIFICATION_CRASH</strong> = <literal>2012</literal></paragraph>
            <paragraph>当引擎即将崩溃时，从Godot的崩溃处理程序收到的通知。</paragraph>
            <paragraph>如果崩溃处理程序被启用，则在桌面平台上被实现。</paragraph>
            <target refid="class-node-constant-notification-os-ime-update"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-os-ime-update" names="class_node_constant_notification_os_ime_update"><strong>NOTIFICATION_OS_IME_UPDATE</strong> = <literal>2013</literal></paragraph>
            <paragraph>当输入法引擎发生更新时，从操作系统收到的通知（例如，IME 光标位置或组成字符串的变化）。</paragraph>
            <paragraph>仅在 macOS 上被实现。</paragraph>
            <target refid="class-node-constant-notification-application-resumed"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-application-resumed" names="class_node_constant_notification_application_resumed"><strong>NOTIFICATION_APPLICATION_RESUMED</strong> = <literal>2014</literal></paragraph>
            <paragraph>当应用程序恢复时，从操作系统收到的通知。</paragraph>
            <paragraph>仅在 Android 上被实现。</paragraph>
            <target refid="class-node-constant-notification-application-paused"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-application-paused" names="class_node_constant_notification_application_paused"><strong>NOTIFICATION_APPLICATION_PAUSED</strong> = <literal>2015</literal></paragraph>
            <paragraph>当应用程序暂停时，从操作系统收到的通知。</paragraph>
            <paragraph>仅在 Android 上被实现。</paragraph>
            <target refid="class-node-constant-notification-application-focus-in"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-application-focus-in" names="class_node_constant_notification_application_focus_in"><strong>NOTIFICATION_APPLICATION_FOCUS_IN</strong> = <literal>2016</literal></paragraph>
            <paragraph>当应用程序获得焦点时从操作系统收到的通知，即焦点将从操作系统桌面或第三方应用程序更改为 Godot 实例的任何一个打开窗口时。</paragraph>
            <paragraph>在桌面平台上被实现。</paragraph>
            <target refid="class-node-constant-notification-application-focus-out"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-application-focus-out" names="class_node_constant_notification_application_focus_out"><strong>NOTIFICATION_APPLICATION_FOCUS_OUT</strong> = <literal>2017</literal></paragraph>
            <paragraph>当应用程序失去焦点时从操作系统收到通知，即焦点将从 Godot 实例的任何一个打开窗口，更改为操作系统桌面或第三方应用程序时。</paragraph>
            <paragraph>在桌面平台上被实现。</paragraph>
            <target refid="class-node-constant-notification-text-server-changed"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-text-server-changed" names="class_node_constant_notification_text_server_changed"><strong>NOTIFICATION_TEXT_SERVER_CHANGED</strong> = <literal>2018</literal></paragraph>
            <paragraph><reference internal="True" refuri="class_textserver#class-textserver"><inline classes="std std-ref">TextServer</inline></reference> 被更改时收到的通知。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id8" names="属性说明">
            <title>属性说明</title>
            <target refid="class-node-property-editor-description"></target>
            <paragraph classes="classref-property" ids="class-node-property-editor-description" names="class_node_property_editor_description"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>editor_description</strong> = <literal>""</literal></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph>void <strong>set_editor_description</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> value <strong>)</strong></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_editor_description</strong> <strong>(</strong> <strong>)</strong></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>节点的可选描述。当将悬停在编辑器场景面板中的节点上时，它将显示为工具提示。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-multiplayer"></target>
            <paragraph classes="classref-property" ids="class-node-property-multiplayer" names="class_node_property_multiplayer"><reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> <strong>multiplayer</strong></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> <strong>get_multiplayer</strong> <strong>(</strong> <strong>)</strong></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>与该节点关联的 <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> 实例。见 <reference internal="True" refuri="class_scenetree#class-scenetree-method-get-multiplayer"><inline classes="std std-ref">SceneTree.get_multiplayer</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>将节点重命名或者在树中移动都不会将 <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> 移动至新的路径，你需要手动进行更新。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-name"></target>
            <paragraph classes="classref-property" ids="class-node-property-name" names="class_node_property_name"><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>name</strong></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph>void <strong>set_name</strong> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> value <strong>)</strong></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>get_name</strong> <strong>(</strong> <strong>)</strong></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>该节点的名称。该名称在同级节点（来自同一父节点的其他子节点）中必须是唯一的。当设置为已有同级节点的名称时，该节点将会自动重命名。</paragraph>
            <paragraph><strong>注意：</strong>更改名称时，以下字符将被移除：（<literal>.</literal> <literal>:</literal> <literal>@</literal> <literal>/</literal> <literal>"</literal> <literal>%</literal>）。特别是，<literal>@</literal> 字符是为自动生成的名称保留的。另请参阅 <reference internal="True" refuri="class_string#class-string-method-validate-node-name"><inline classes="std std-ref">String.validate_node_name</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-owner"></target>
            <paragraph classes="classref-property" ids="class-node-property-owner" names="class_node_property_owner"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>owner</strong></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph>void <strong>set_owner</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> value <strong>)</strong></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>get_owner</strong> <strong>(</strong> <strong>)</strong></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>该节点的所有者。所有者必须是该节点的祖先节点。当将所有者节点打包到 <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference> 中时，它拥有的所有节点也会随之保存。</paragraph>
            <paragraph><strong>注意：</strong>在编辑器中，不属于场景根的节点通常不会显示在场景面板中，并且<strong>不</strong>会被保存。为了防止这种情况，请记住在调用 <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference> 后设置所有者。另见（参见 <reference internal="True" refid="class-node-property-unique-name-in-owner"><inline classes="std std-ref">unique_name_in_owner</inline></reference>）</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-process-mode"></target>
            <paragraph classes="classref-property" ids="class-node-property-process-mode" names="class_node_property_process_mode"><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> <strong>process_mode</strong> = <literal>0</literal></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph>void <strong>set_process_mode</strong> <strong>(</strong> <reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> value <strong>)</strong></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> <strong>get_process_mode</strong> <strong>(</strong> <strong>)</strong></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>该节点的处理行为（请参阅 <reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference>）。要检查该节点是否能够在当前模式和 <reference internal="True" refuri="class_scenetree#class-scenetree-property-paused"><inline classes="std std-ref">SceneTree.paused</inline></reference> 下进行处理，请使用 <reference internal="True" refid="class-node-method-can-process"><inline classes="std std-ref">can_process</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-process-physics-priority"></target>
            <paragraph classes="classref-property" ids="class-node-property-process-physics-priority" names="class_node_property_process_physics_priority"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>process_physics_priority</strong> = <literal>0</literal></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph>void <strong>set_physics_process_priority</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> value <strong>)</strong></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_physics_process_priority</strong> <strong>(</strong> <strong>)</strong></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>与 <reference internal="True" refid="class-node-property-process-priority"><inline classes="std std-ref">process_priority</inline></reference> 类似，但是作用于 <reference internal="True" refid="class-node-constant-notification-physics-process"><inline classes="std std-ref">NOTIFICATION_PHYSICS_PROCESS</inline></reference>、<reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process</inline></reference> 以及内部版本。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-process-priority"></target>
            <paragraph classes="classref-property" ids="class-node-property-process-priority" names="class_node_property_process_priority"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>process_priority</strong> = <literal>0</literal></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph>void <strong>set_process_priority</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> value <strong>)</strong></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_process_priority</strong> <strong>(</strong> <strong>)</strong></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>处理回调（<reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process</inline></reference>、<reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process</inline></reference>、和内部处理）的节点执行顺序。无论树顺序如何，优先级值<emphasis>较低</emphasis>的节点将先调用其处理回调。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-process-thread-group"></target>
            <paragraph classes="classref-property" ids="class-node-property-process-thread-group" names="class_node_property_process_thread_group"><reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref">ProcessThreadGroup</inline></reference> <strong>process_thread_group</strong> = <literal>0</literal></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph>void <strong>set_process_thread_group</strong> <strong>(</strong> <reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref">ProcessThreadGroup</inline></reference> value <strong>)</strong></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref">ProcessThreadGroup</inline></reference> <strong>get_process_thread_group</strong> <strong>(</strong> <strong>)</strong></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>设置这个节点的处理线程组（基本上就是在主线程还是子线程中接收 <reference internal="True" refid="class-node-constant-notification-process"><inline classes="std std-ref">NOTIFICATION_PROCESS</inline></reference>、<reference internal="True" refid="class-node-constant-notification-physics-process"><inline classes="std std-ref">NOTIFICATION_PHYSICS_PROCESS</inline></reference>、<reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process</inline></reference>、<reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process</inline></reference> 以及这些回调的内部版本）。</paragraph>
            <paragraph>默认情况下线程组为 <reference internal="True" refid="class-node-constant-process-thread-group-inherit"><inline classes="std std-ref">PROCESS_THREAD_GROUP_INHERIT</inline></reference>，表示这个节点属于和父节点一样的线程组。同一线程组中的节点会一起处理，独立于其他线程组（由 <reference internal="True" refid="class-node-property-process-thread-group-order"><inline classes="std std-ref">process_thread_group_order</inline></reference> 决定）。如果设为 <reference internal="True" refid="class-node-constant-process-thread-group-sub-thread"><inline classes="std std-ref">PROCESS_THREAD_GROUP_SUB_THREAD</inline></reference>，则该线程组会在子线程（非主线程）中执行，否则设为 <reference internal="True" refid="class-node-constant-process-thread-group-main-thread"><inline classes="std std-ref">PROCESS_THREAD_GROUP_MAIN_THREAD</inline></reference> 就会在主线程中处理。如果父节点和先祖节点都没有设置为非继承，则该节点属于<emphasis>默认线程组</emphasis>。默认分组在主线程中处理，分组顺序为 0。</paragraph>
            <paragraph>在子线程中处理时，线程组之外的大多数函数都禁止访问（调试模式下会报错）。请使用 <reference internal="True" refuri="class_object#class-object-method-call-deferred"><inline classes="std std-ref">Object.call_deferred</inline></reference>、<reference internal="True" refid="class-node-method-call-thread-safe"><inline classes="std std-ref">call_thread_safe</inline></reference>、<reference internal="True" refid="class-node-method-call-deferred-thread-group"><inline classes="std std-ref">call_deferred_thread_group</inline></reference> 等方法与主线程（或其他线程组）通信。</paragraph>
            <paragraph>线程组更好的理解方式是，非 <reference internal="True" refid="class-node-constant-process-thread-group-inherit"><inline classes="std std-ref">PROCESS_THREAD_GROUP_INHERIT</inline></reference> 的节点都会将设为继承的子节点（以及后续子孙节点）纳入它的处理线程组。这样该分组中的节点就会一起处理，包括包含它们的节点。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-process-thread-group-order"></target>
            <paragraph classes="classref-property" ids="class-node-property-process-thread-group-order" names="class_node_property_process_thread_group_order"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>process_thread_group_order</strong></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph>void <strong>set_process_thread_group_order</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> value <strong>)</strong></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_process_thread_group_order</strong> <strong>(</strong> <strong>)</strong></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>修改处理线程组的顺序。顺序取值较小的分组会在较大的分组前处理。例如，可以让大量的节点先在子线程中处理，然后另一组节点要在主线程中获取它们的处理结果。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-process-thread-messages"></target>
            <paragraph classes="classref-property" ids="class-node-property-process-thread-messages" names="class_node_property_process_thread_messages"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation>&lt;<reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref">ProcessThreadMessages</inline></reference>&gt; <strong>process_thread_messages</strong></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph>void <strong>set_process_thread_messages</strong> <strong>(</strong> <abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation>&lt;<reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref">ProcessThreadMessages</inline></reference>&gt; value <strong>)</strong></paragraph>
                </list_item>
                <list_item>
                    <paragraph><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation>&lt;<reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref">ProcessThreadMessages</inline></reference>&gt; <strong>get_process_thread_messages</strong> <strong>(</strong> <strong>)</strong></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>设置当前线程组是否会在线程中处理消息（调用 <reference internal="True" refid="class-node-method-call-deferred-thread-group"><inline classes="std std-ref">call_deferred_thread_group</inline></reference>），以及是否需要在常规处理和物理处理回调中接收消息。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-scene-file-path"></target>
            <paragraph classes="classref-property" ids="class-node-property-scene-file-path" names="class_node_property_scene_file_path"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>scene_file_path</strong></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph>void <strong>set_scene_file_path</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> value <strong>)</strong></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_scene_file_path</strong> <strong>(</strong> <strong>)</strong></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>原始场景的文件路径（如果节点已从 <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference> 文件完成实例化）。只有场景根节点包含该文件路径。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-unique-name-in-owner"></target>
            <paragraph classes="classref-property" ids="class-node-property-unique-name-in-owner" names="class_node_property_unique_name_in_owner"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>unique_name_in_owner</strong> = <literal>false</literal></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph>void <strong>set_unique_name_in_owner</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> value <strong>)</strong></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_unique_name_in_owner</strong> <strong>(</strong> <strong>)</strong></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>如果为 <literal>true</literal>，则可以从共享相同 <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> 的任意节点或从 <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> 本身访问该节点，并可在 <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node</inline></reference> 中使用特殊的 <literal>%Name</literal> 语法。</paragraph>
            <paragraph><strong>注意：</strong>如果具有相同 <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> 的另一个节点与该节点共享相同的 <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference>，则另一个节点将不可再作为唯一节点名称进行访问。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id9" names="方法说明">
            <title>方法说明</title>
            <target refid="class-node-private-method-enter-tree"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-enter-tree" names="class_node_private_method__enter_tree">void <strong>_enter_tree</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
            <paragraph>当节点进入 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 时调用（例如实例化时、场景改变时、或者在脚本中调用 <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference> 后）。如果节点有子节点，则首先调用它的 <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree</inline></reference> 回调函数，然后再调用子节点的回调函数。</paragraph>
            <paragraph>对应于 <reference internal="True" refuri="class_object#class-object-private-method-notification"><inline classes="std std-ref">Object._notification</inline></reference> 中的 <reference internal="True" refid="class-node-constant-notification-enter-tree"><inline classes="std std-ref">NOTIFICATION_ENTER_TREE</inline></reference> 通知。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-exit-tree"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-exit-tree" names="class_node_private_method__exit_tree">void <strong>_exit_tree</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
            <paragraph>当节点即将离开 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 时被调用（例如，在释放、场景改变或在脚本中调用 <reference internal="True" refid="class-node-method-remove-child"><inline classes="std std-ref">remove_child</inline></reference> 后）。如果该节点有子节点，它的 <reference internal="True" refid="class-node-private-method-exit-tree"><inline classes="std std-ref">_exit_tree</inline></reference> 回调将在所有子节点离开树后被最后调用。</paragraph>
            <paragraph>对应于 <reference internal="True" refuri="class_object#class-object-private-method-notification"><inline classes="std std-ref">Object._notification</inline></reference> 中的 <reference internal="True" refid="class-node-constant-notification-exit-tree"><inline classes="std std-ref">NOTIFICATION_EXIT_TREE</inline></reference> 通知和 <reference internal="True" refid="class-node-signal-tree-exiting"><inline classes="std std-ref">tree_exiting</inline></reference> 信号。要在节点已经离开活动树时得到通知，请连接到 <reference internal="True" refid="class-node-signal-tree-exited"><inline classes="std std-ref">tree_exited</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-get-configuration-warnings"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-get-configuration-warnings" names="class_node_private_method__get_configuration_warnings"><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> <strong>_get_configuration_warnings</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果覆盖这个方法的脚本是 <literal>tool</literal> 脚本，那么这个函数所返回的数组中的元素会在“场景”面板中显示为警告。</paragraph>
            <paragraph>返回空数组不会生成警告。</paragraph>
            <paragraph>这个节点的警告需要更新时，请调用 <reference internal="True" refid="class-node-method-update-configuration-warnings"><inline classes="std std-ref">update_configuration_warnings</inline></reference>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@export var energy = 0:
    set(value):
        energy = value
        update_configuration_warnings()

func _get_configuration_warnings():
    if energy &lt; 0:
        return ["Energy 必须大于等于 0。"]
    else:
        return []</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-input"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-input" names="class_node_private_method__input">void <strong>_input</strong> <strong>(</strong> <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> event <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
            <paragraph>有输入事件时会被调用。输入事件会沿节点树向上传播，直到有节点将其消耗。</paragraph>
            <paragraph>只有在启用输入处理时才会被调用，如果该方法被重写则会自动启用，可以使用 <reference internal="True" refid="class-node-method-set-process-input"><inline classes="std std-ref">set_process_input</inline></reference> 进行切换。</paragraph>
            <paragraph>要消耗输入事件，阻止它进一步传播到其他节点，可以调用 <reference internal="True" refuri="class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled</inline></reference>。</paragraph>
            <paragraph>对于游戏输入，<reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input</inline></reference> 和 <reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref">_unhandled_key_input</inline></reference> 通常更适合，因为它们允许 GUI 首先拦截事件。</paragraph>
            <paragraph><strong>注意：</strong>仅当该节点存在于场景树中时（即不是孤立节点），此方法才会被调用。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-physics-process"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-physics-process" names="class_node_private_method__physics_process">void <strong>_physics_process</strong> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> delta <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
            <paragraph>在主循环的物理处理步骤中被调用。物理处理意味着帧率与物理同步，即 <literal>delta</literal> 变量应该是常量。 <literal>delta</literal> 的单位是秒。</paragraph>
            <paragraph>只有当物理处理被启用时才会被调用，如果这个方法被重写，就会自动被调用，并且可以使用 <reference internal="True" refid="class-node-method-set-physics-process"><inline classes="std std-ref">set_physics_process</inline></reference> 进行切换。</paragraph>
            <paragraph>对应于 <reference internal="True" refuri="class_object#class-object-private-method-notification"><inline classes="std std-ref">Object._notification</inline></reference> 中的 <reference internal="True" refid="class-node-constant-notification-physics-process"><inline classes="std std-ref">NOTIFICATION_PHYSICS_PROCESS</inline></reference> 通知。</paragraph>
            <paragraph><strong>注意：</strong>这个方法只有在当节点存在于场景树中时才会被调用（也就是说，如果它不是孤立节点）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-process"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-process" names="class_node_private_method__process">void <strong>_process</strong> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> delta <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
            <paragraph>在主循环的处理步骤中被调用。处理发生在每一帧，并且尽可能快，所以从上一帧开始的 <literal>delta</literal> 时间不是恒定的。<literal>delta</literal> 的单位是秒。</paragraph>
            <paragraph>只有在启用处理的情况下才会被调用，如果这个方法被重写，会自动进行处理，可以用 <reference internal="True" refid="class-node-method-set-process"><inline classes="std std-ref">set_process</inline></reference> 来开关。</paragraph>
            <paragraph>对应于 <reference internal="True" refuri="class_object#class-object-private-method-notification"><inline classes="std std-ref">Object._notification</inline></reference> 中的 <reference internal="True" refid="class-node-constant-notification-process"><inline classes="std std-ref">NOTIFICATION_PROCESS</inline></reference> 通知。</paragraph>
            <paragraph><strong>注意：</strong>这个方法只有在节点存在于场景树中时才会被调用（也就是说，如果它不是孤立节点）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-ready"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-ready" names="class_node_private_method__ready">void <strong>_ready</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
            <paragraph>当节点“就绪”时被调用，即当节点及其子节点都已经进入场景树时。如果该节点有子节点，将首先触发子节点的 <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready</inline></reference> 回调，稍后父节点将收到就绪通知。</paragraph>
            <paragraph>对应 <reference internal="True" refuri="class_object#class-object-private-method-notification"><inline classes="std std-ref">Object._notification</inline></reference> 中的 <reference internal="True" refid="class-node-constant-notification-ready"><inline classes="std std-ref">NOTIFICATION_READY</inline></reference> 通知。另请参阅用于变量的 <literal>@onready</literal> 注解。</paragraph>
            <paragraph>通常用于初始化。对于更早的初始化，可以使用 <reference internal="True" refuri="class_object#class-object-private-method-init"><inline classes="std std-ref">Object._init</inline></reference>。另见 <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>该方法对于每个节点可能仅调用一次。从场景树中移除一个节点后，并再次添加该节点时，将<strong>不</strong>会第二次调用 <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready</inline></reference>。这时可以通过使用 <reference internal="True" refid="class-node-method-request-ready"><inline classes="std std-ref">request_ready</inline></reference>，它可以在再次添加节点之前的任何地方被调用。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-shortcut-input"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-shortcut-input" names="class_node_private_method__shortcut_input">void <strong>_shortcut_input</strong> <strong>(</strong> <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> event <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
            <paragraph>当一个 <reference internal="True" refuri="class_inputeventkey#class-inputeventkey"><inline classes="std std-ref">InputEventKey</inline></reference> 或 <reference internal="True" refuri="class_inputeventshortcut#class-inputeventshortcut"><inline classes="std std-ref">InputEventShortcut</inline></reference>，尚未被 <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input</inline></reference> 或任何 GUI <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 项使用时调用。这是在 <reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref">_unhandled_key_input</inline></reference> 和 <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input</inline></reference> 之前调用的。输入事件通过节点树向上传播，直到一个节点消耗它。</paragraph>
            <paragraph>它仅在启用快捷键处理时调用，如果此方法被覆盖，则会自动调用，并且可以使用 <reference internal="True" refid="class-node-method-set-process-shortcut-input"><inline classes="std std-ref">set_process_shortcut_input</inline></reference> 进行开关。</paragraph>
            <paragraph>要消耗输入事件，并阻止它进一步传播到其他节点，可以调用 <reference internal="True" refuri="class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled</inline></reference>。</paragraph>
            <paragraph>此方法可用于处理快捷键。如果是常规的 GUI 事件，请改用 <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input</inline></reference>。游戏事件通常应该使用 <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input</inline></reference> 或 <reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref">_unhandled_key_input</inline></reference> 处理。</paragraph>
            <paragraph><strong>注意：</strong>仅当该节点存在于场景树中（即它不是一个孤立节点）时，此方法才会被调用。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-unhandled-input"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-unhandled-input" names="class_node_private_method__unhandled_input">void <strong>_unhandled_input</strong> <strong>(</strong> <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> event <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
            <paragraph>当一个 <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> 尚未被 <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input</inline></reference> 或任何 GUI <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 项消耗时调用。这是在 <reference internal="True" refid="class-node-private-method-shortcut-input"><inline classes="std std-ref">_shortcut_input</inline></reference> 和 <reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref">_unhandled_key_input</inline></reference> 之后调用的。输入事件通过节点树向上传播，直到一个节点消耗它。</paragraph>
            <paragraph>只有在未处理的输入处理被启用时，才会被调用，如果该方法被重写，则会自动被调用，并且可以使用 <reference internal="True" refid="class-node-method-set-process-unhandled-input"><inline classes="std std-ref">set_process_unhandled_input</inline></reference> 进行切换。</paragraph>
            <paragraph>要消耗输入事件，并阻止它进一步传播到其他节点，可以调用 <reference internal="True" refuri="class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled</inline></reference>。</paragraph>
            <paragraph>对于游戏输入，这个方法通常比 <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input</inline></reference> 更合适，因为 GUI 事件需要更高的优先级。对于键盘快捷键，请考虑改用 <reference internal="True" refid="class-node-private-method-shortcut-input"><inline classes="std std-ref">_shortcut_input</inline></reference>，因为是在这个方法之前调用的。最后，如果要处理键盘事件，那么出于性能方面的原因请考虑使用 <reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref">_unhandled_key_input</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>仅当该节点存在于场景树中（即不是孤立节点）时，该方法才会被调用。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-unhandled-key-input"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-unhandled-key-input" names="class_node_private_method__unhandled_key_input">void <strong>_unhandled_key_input</strong> <strong>(</strong> <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> event <strong>)</strong> <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
            <paragraph>当 <reference internal="True" refuri="class_inputeventkey#class-inputeventkey"><inline classes="std std-ref">InputEventKey</inline></reference> 没有被 <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input</inline></reference> 或任何 GUI <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 项目消耗时调用。这是在 <reference internal="True" refid="class-node-private-method-shortcut-input"><inline classes="std std-ref">_shortcut_input</inline></reference> 之后、<reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input</inline></reference> 之前调用的。输入事件通过节点树向上传播，直到某个节点将其消耗。</paragraph>
            <paragraph>只有在启用了未处理按键输入处理时才会被调用，如果覆盖了这个方法就会自动启用，并且可以用 <reference internal="True" refid="class-node-method-set-process-unhandled-key-input"><inline classes="std std-ref">set_process_unhandled_key_input</inline></reference> 来开关。</paragraph>
            <paragraph>要消耗输入事件并阻止它进一步传播到其他节点，可以调用 <reference internal="True" refuri="class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled</inline></reference>。</paragraph>
            <paragraph>在处理快捷键后，此方法可用于使用 <literal classes="kbd">Alt</literal>、<literal classes="kbd">Alt + Ctrl</literal> 和 <literal classes="kbd">Alt + Shift</literal> 修饰符处理 Unicode 字符输入。</paragraph>
            <paragraph>对于游戏输入，这和 <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input</inline></reference> 通常比 <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input</inline></reference> 更适合，因为应该先处理 GUI 事件。该方法的性能也比 <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input</inline></reference> 更好，因为 <reference internal="True" refuri="class_inputeventmousemotion#class-inputeventmousemotion"><inline classes="std std-ref">InputEventMouseMotion</inline></reference> 等无关事件会被自动过滤。</paragraph>
            <paragraph><strong>注意：</strong>只有当节点存在于场景树中（即不是孤立节点）时，该方法才会被调用。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-add-child"></target>
            <paragraph classes="classref-method" ids="class-node-method-add-child" names="class_node_method_add_child">void <strong>add_child</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> force_readable_name=false, <reference internal="True" refid="enum-node-internalmode"><inline classes="std std-ref">InternalMode</inline></reference> internal=0 <strong>)</strong></paragraph>
            <paragraph>将 <literal>node</literal> 添加为子节点。节点可以有任意数量的子节点，但子节点的名称必须唯一。删除父节点时会自动删除子节点，因此可以通过删除最顶层的节点来删除整个场景。</paragraph>
            <paragraph>如果 <literal>force_readable_name</literal> 为 <literal>true</literal>，则将提高所添加的 <literal>node</literal> 的可读性。如果尚未命名，<literal>node</literal> 将重命名为它的类型，如果存在 <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference> 相同的兄弟节点，则会添加合适的数字后缀。这个操作很慢。因此，建议将其保留为 <literal>false</literal>，在这两种情况下会分配包含 <literal>@</literal> 的虚拟名称。</paragraph>
            <paragraph>如果 <literal>internal</literal> 不同于 <reference internal="True" refid="class-node-constant-internal-mode-disabled"><inline classes="std std-ref">INTERNAL_MODE_DISABLED</inline></reference>，则该子节点将被添加为内部节点。<reference internal="True" refid="class-node-method-get-children"><inline classes="std std-ref">get_children</inline></reference> 等方法会忽略这些节点，除非它们的参数 <literal>include_internal</literal> 为 <literal>true</literal>。这种功能的设计初衷是对用户隐藏内部节点，这样用户就不会意外删除或修改这些节点。部分 GUI 节点会使用这个功能，例如 <reference internal="True" refuri="class_colorpicker#class-colorpicker"><inline classes="std std-ref">ColorPicker</inline></reference>。可用的模式见 <reference internal="True" refid="enum-node-internalmode"><inline classes="std std-ref">InternalMode</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>如果 <literal>node</literal> 已经有父节点，则该方法会失败。请先使用 <reference internal="True" refid="class-node-method-remove-child"><inline classes="std std-ref">remove_child</inline></reference> 将 <literal>node</literal> 从其当前父节点中移除。例如：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var child_node = get_child(0)
if child_node.get_parent():
    child_node.get_parent().remove_child(child_node)
add_child(child_node)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Node childNode = GetChild(0);
if (childNode.GetParent() != null)
{
    childNode.GetParent().RemoveChild(childNode);
}
AddChild(childNode);</literal_block>
                </div>
            </container>
            <paragraph>如果你需要将子节点添加到子节点列表中特定节点的下方，请使用 <reference internal="True" refid="class-node-method-add-sibling"><inline classes="std std-ref">add_sibling</inline></reference> 而不是该方法。</paragraph>
            <paragraph><strong>注意：</strong>如果想让子节点持久化到某个 <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference> 的，除了调用 <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference> 之外，还必须设置 <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference>。通常在<reference internal="True" refuri="../tutorials/plugins/running_code_in_the_editor"><inline classes="doc">工具脚本</inline></reference>和<reference internal="True" refuri="../tutorials/plugins/editor/index"><inline classes="doc">编辑器插件</inline></reference>中会用到。如果在没有设置 <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference>，只调用了 <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference>，则新添加的 <strong>Node</strong> 在场景树中将不可见，但在 2D/3D 视图中却是可见的。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-add-sibling"></target>
            <paragraph classes="classref-method" ids="class-node-method-add-sibling" names="class_node_method_add_sibling">void <strong>add_sibling</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> sibling, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> force_readable_name=false <strong>)</strong></paragraph>
            <paragraph>将一个 <literal>sibling</literal> 节点添加到该节点的父节点，并将该添加的同级节点移动到该节点的正下方。</paragraph>
            <paragraph>如果 <literal>force_readable_name</literal> 为 <literal>true</literal>，则提高添加的 <literal>sibling</literal> 的可读性。如果没有命名，<literal>sibling</literal> 将被重命名为它的类型，如果它与一个同级节点共享 <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference>，则添加一个更合适的数字后缀。这个操作很慢。因此，建议将其保留为 <literal>false</literal>，这会在两种情况下分配一个以 <literal>@</literal> 为特色的虚拟名称。</paragraph>
            <paragraph>如果不需要将该子节点添加到子列表中特定节点的下方，请使用 <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference> 而不是该方法。</paragraph>
            <paragraph><strong>注意：</strong>如果这个节点是内部的，则添加的同级节点也将是内部的（参见 <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference> 的 <literal>internal</literal> 参数）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-add-to-group"></target>
            <paragraph classes="classref-method" ids="class-node-method-add-to-group" names="class_node_method_add_to_group">void <strong>add_to_group</strong> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> group, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> persistent=false <strong>)</strong></paragraph>
            <paragraph>将该节点加入 <literal>group</literal> 分组。使用分组可以很方便地组织部分节点，例如将敌人加入 <literal>"enemies"</literal> 分组、将收集品加入 <literal>"collectables"</literal> 分组。注意事项见下文，以及 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 中相关的分组方法。</paragraph>
            <paragraph>如果 <literal>persistent</literal> 为 <literal>true</literal>，则保存 <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference> 时会存储该分组。在“节点”面板中创建、显示的分组都能够进行持久化。</paragraph>
            <paragraph><strong>注意：</strong>为了提升性能，<emphasis>并不</emphasis>保证分组名称的顺序，每次运行项目可能会不同。因此请不要依赖分组的顺序。</paragraph>
            <paragraph><strong>注意：</strong>不再场景树中时，<reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 的分组方法<emphasis>无法</emphasis>正常工作（见 <reference internal="True" refid="class-node-method-is-inside-tree"><inline classes="std std-ref">is_inside_tree</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-call-deferred-thread-group"></target>
            <paragraph classes="classref-method" ids="class-node-method-call-deferred-thread-group" names="class_node_method_call_deferred_thread_group"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>call_deferred_thread_group</strong> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> method, ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></paragraph>
            <paragraph>这个函数类似于 <reference internal="True" refuri="class_object#class-object-method-call-deferred"><inline classes="std std-ref">Object.call_deferred</inline></reference>，但是会在处理节点线程组时进行调用。如果节点线程组在子线程中处理，那么调用就会在该线程中进行，时机为 <reference internal="True" refid="class-node-constant-notification-process"><inline classes="std std-ref">NOTIFICATION_PROCESS</inline></reference> 和 <reference internal="True" refid="class-node-constant-notification-physics-process"><inline classes="std std-ref">NOTIFICATION_PHYSICS_PROCESS</inline></reference>、<reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process</inline></reference> 和 <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process</inline></reference>，或者对应的内部版本之前。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-call-thread-safe"></target>
            <paragraph classes="classref-method" ids="class-node-method-call-thread-safe" names="class_node_method_call_thread_safe"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>call_thread_safe</strong> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> method, ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></paragraph>
            <paragraph>这个函数能够确保调用成功，无论是否从线程中调用。如果是从不允许调用该函数的线程中调用的，那么调用就会变成延迟调用。否则就会直接调用。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-can-process"></target>
            <paragraph classes="classref-method" ids="class-node-method-can-process" names="class_node_method_can_process"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>can_process</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果节点可以从 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 和 <reference internal="True" refuri="class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> 接收处理通知和输入回调（<reference internal="True" refid="class-node-constant-notification-process"><inline classes="std std-ref">NOTIFICATION_PROCESS</inline></reference>、<reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input</inline></reference> 等），则返回 <literal>true</literal>。该值取决于当前的 <reference internal="True" refid="class-node-property-process-mode"><inline classes="std std-ref">process_mode</inline></reference> 和 <reference internal="True" refuri="class_scenetree#class-scenetree-property-paused"><inline classes="std std-ref">SceneTree.paused</inline></reference>。如果节点不在树内，则返回 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-create-tween"></target>
            <paragraph classes="classref-method" ids="class-node-method-create-tween" names="class_node_method_create_tween"><reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference> <strong>create_tween</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>新建 <reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference> 并将其绑定到这个节点。</paragraph>
            <paragraph>与如下操作等价：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">get_tree().create_tween().bind_node(self)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GetTree().CreateTween().BindNode(this);</literal_block>
                </div>
            </container>
            <paragraph>该 Tween 将在下一个处理帧或物理帧时自动开始（取决于 <reference internal="True" refuri="class_tween#enum-tween-tweenprocessmode"><inline classes="std std-ref">TweenProcessMode</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-duplicate"></target>
            <paragraph classes="classref-method" ids="class-node-method-duplicate" names="class_node_method_duplicate"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>duplicate</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> flags=15 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>复制该节点，返回一个新节点，其中包含从原始节点复制的所有属性、信号和组。可以通过 <literal>flags</literal> 调整该行为（请参阅 <reference internal="True" refid="enum-node-duplicateflags"><inline classes="std std-ref">DuplicateFlags</inline></reference>）。</paragraph>
            <paragraph><strong>注意：</strong>对于附带有 <reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference> 的节点，如果 <reference internal="True" refuri="class_object#class-object-private-method-init"><inline classes="std std-ref">Object._init</inline></reference> 已使用所需参数定义，则复制的节点将不会有 <reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-find-child"></target>
            <paragraph classes="classref-method" ids="class-node-method-find-child" names="class_node_method_find_child"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>find_child</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> pattern, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> recursive=true, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> owned=true <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>查找该节点的后代节点中，其 <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference> 与 <literal>pattern</literal> 匹配的第一个节点。如果找不到匹配项，则返回 <literal>null</literal>。匹配是通过 <reference internal="True" refuri="class_string#class-string-method-match"><inline classes="std std-ref">String.match</inline></reference> 针对节点名称完成的，而<emphasis>不</emphasis>是针对其路径。因此，它区分大小写，<literal>"*"</literal> 匹配零个或多个字符，<literal>"?"</literal> 匹配任意单个字符。</paragraph>
            <paragraph>如果 <literal>recursive</literal> 为 <literal>false</literal>，则仅检查该节点的直接子节点。节点按树顺序检查，因此首先检查该节点的第一个直接子节点，然后检查它自己的直接子节点，依此类推；然后移动到第二个直接子节点，依此类推。内部子级也包含在该搜索中（请参阅 <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference> 中的 <literal>internal</literal> 参数）。</paragraph>
            <paragraph>如果 <literal>owned</literal> 为 <literal>true</literal>，则仅检查具有有效 <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> 节点的后代。</paragraph>
            <paragraph><strong>注意：</strong>该方法可能非常慢。考虑将找到的节点的引用存储在变量中。或者，使用唯一名称调用 <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node</inline></reference>（请参阅 <reference internal="True" refid="class-node-property-unique-name-in-owner"><inline classes="std std-ref">unique_name_in_owner</inline></reference>）。</paragraph>
            <paragraph><strong>注意：</strong>要查找匹配一个模式或类类型的所有后代节点，请参阅 <reference internal="True" refid="class-node-method-find-children"><inline classes="std std-ref">find_children</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-find-children"></target>
            <paragraph classes="classref-method" ids="class-node-method-find-children" names="class_node_method_find_children"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node[]</inline></reference> <strong>find_children</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> pattern, <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> type="", <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> recursive=true, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> owned=true <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>查找该节点的后代节点中，其名称与 <literal>pattern</literal> 匹配的所有节点。如果找不到匹配项，则返回空 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>。匹配是通过 <reference internal="True" refuri="class_string#class-string-method-match"><inline classes="std std-ref">String.match</inline></reference> 针对节点名称完成的，而<emphasis>不</emphasis>是针对其路径。因此，它区分大小写，<literal>"*"</literal> 匹配零个或多个字符，<literal>"?"</literal> 匹配任意单个字符。</paragraph>
            <paragraph>如果 <literal>type</literal> 不为空，则仅包含从 <literal>type</literal> 继承的后代节点（请参阅 <reference internal="True" refuri="class_object#class-object-method-is-class"><inline classes="std std-ref">Object.is_class</inline></reference>）。</paragraph>
            <paragraph>如果 <literal>recursive</literal> 为 <literal>false</literal>，则仅检查该节点的直接子节点。节点按树顺序检查，因此首先检查该节点的第一个直接子节点，然后检查它自己的直接子节点，依此类推；然后移动到第二个直接子节点，依此类推。内部子级也包含在该搜索中（请参阅 <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference> 中的 <literal>internal</literal> 参数）。</paragraph>
            <paragraph>如果 <literal>owned</literal> 为 <literal>true</literal>，则仅检查具有有效 <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> 节点的后代。</paragraph>
            <paragraph><strong>注意：</strong>该方法可能非常慢。考虑将找到的节点的引用存储在变量中。</paragraph>
            <paragraph><strong>注意：</strong>如果只想查找匹配一个模式的单个后代节点，请参阅 <reference internal="True" refid="class-node-method-find-child"><inline classes="std std-ref">find_child</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-find-parent"></target>
            <paragraph classes="classref-method" ids="class-node-method-find-parent" names="class_node_method_find_parent"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>find_parent</strong> <strong>(</strong> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> pattern <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>查找该节点的祖先节点中，其 <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference> 与 <literal>pattern</literal> 匹配的第一个节点。如果找不到匹配项，则返回 <literal>null</literal>。匹配是通过 <reference internal="True" refuri="class_string#class-string-method-match"><inline classes="std std-ref">String.match</inline></reference> 完成的。因此，它区分大小写，<literal>"*"</literal> 匹配零个或多个字符，<literal>"?"</literal> 匹配任意单个字符。另见 <reference internal="True" refid="class-node-method-find-child"><inline classes="std std-ref">find_child</inline></reference> 和 <reference internal="True" refid="class-node-method-find-children"><inline classes="std std-ref">find_children</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong> 由于该方法在场景树中向上遍历，因此在大型、深度嵌套的节点中可能会很慢。考虑将找到的节点的引用存储在变量中。或者，使用唯一名称调用 <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node</inline></reference>（请参阅 <reference internal="True" refid="class-node-property-unique-name-in-owner"><inline classes="std std-ref">unique_name_in_owner</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-child"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-child" names="class_node_method_get_child"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>get_child</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> idx, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> include_internal=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>通过索引获取子节点。每个子节点都有一个相对于其同级节点的索引（请参阅 <reference internal="True" refid="class-node-method-get-index"><inline classes="std std-ref">get_index</inline></reference>）。第一个子节点位于索引 0 处。负值也可用于从列表末尾开始。该方法可以与 <reference internal="True" refid="class-node-method-get-child-count"><inline classes="std std-ref">get_child_count</inline></reference> 结合使用来迭代该节点的子节点。如果给定索引处不存在子节点，则该方法返回 <literal>null</literal> 并生成一个错误。</paragraph>
            <paragraph>如果 <literal>include_internal</literal> 为 <literal>false</literal>，则忽略内部子节点（请参阅 <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference> 的 <literal>internal</literal> 参数）。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># 假设以下是该节点的子节点（按顺序）：
# 第一、中间、最后。

var a = get_child(0).name  # a 是 “第一”
var b = get_child(1).name  # b 是 “中间”
var b = get_child(2).name  # b 是 “最后”
var c = get_child(-1).name # c 是 “最后”</literal_block>
            <paragraph><strong>注意：</strong>要通过 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> 获取节点，请使用 <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-child-count"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-child-count" names="class_node_method_get_child_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_child_count</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> include_internal=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该节点的子节点的数量。</paragraph>
            <paragraph>如果 <literal>include_internal</literal> 为 <literal>false</literal> ，则不计算内部子节点（见 <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference> 的 <literal>internal</literal> 参数）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-children"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-children" names="class_node_method_get_children"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node[]</inline></reference> <strong>get_children</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> include_internal=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该节点的所有子节点到一个 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> 内。</paragraph>
            <paragraph>如果 <literal>include_internal</literal> 为 <literal>false</literal>，则从返回的数组中排除内部子节点（见 <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference> 的 <literal>internal</literal> 参数）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-groups"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-groups" names="class_node_method_get_groups"><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName[]</inline></reference> <strong>get_groups</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该节点已被添加到的分组的名称的 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>为了提高性能，<emphasis>不</emphasis>保证分组名称的顺序，并且在项目运行之间可能会有所不同。因此，不要依赖分组顺序。</paragraph>
            <paragraph><strong>注意：</strong>该方法还可能返回一些以下划线（<literal>_</literal>）开头的分组名称。这些名称被引擎内部使用。为避免冲突，请勿使用以下划线开头的自定义分组。要排除内部分组，请参阅以下代码片段：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># 仅存储节点的非内部分组（作为一个 StringNames 数组）。
var non_internal_groups = []
for group in get_groups():
    if not str(group).begins_with("_"):
        non_internal_groups.push_back(group)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// 仅存储节点的非内部分组（作为一个 StringNames 列表）。
List&lt;string&gt; nonInternalGroups = new List&lt;string&gt;();
foreach (string group in GetGroups())
{
    if (!group.BeginsWith("_"))
        nonInternalGroups.Add(group);
}</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-index"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-index" names="class_node_method_get_index"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_index</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> include_internal=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该节点在其同级节点中的顺序。第一个节点的索引是 <literal>0</literal>。另见 <reference internal="True" refid="class-node-method-get-child"><inline classes="std std-ref">get_child</inline></reference>。</paragraph>
            <paragraph>如果 <literal>include_internal</literal> 为 <literal>false</literal>，则返回的索引会忽略内部子节点。第一个非内部子节点的索引为 <literal>0</literal>（见 <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference> 的 <literal>internal</literal> 参数）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-last-exclusive-window"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-last-exclusive-window" names="class_node_method_get_last_exclusive_window"><reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> <strong>get_last_exclusive_window</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回包含该节点的 <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference>，或者是从包含该节点的窗口开始的窗口链中最近的独占子项。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-multiplayer-authority"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-multiplayer-authority" names="class_node_method_get_multiplayer_authority"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_multiplayer_authority</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回这个节点多人游戏控制者的对等体 ID。见 <reference internal="True" refid="class-node-method-set-multiplayer-authority"><inline classes="std std-ref">set_multiplayer_authority</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-node"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-node" names="class_node_method_get_node"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>get_node</strong> <strong>(</strong> <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> path <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>获取一个节点。<reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> 可以是到一个节点的相对路径（从该节点开始）或绝对路径（从 <reference internal="True" refuri="class_scenetree#class-scenetree-property-root"><inline classes="std std-ref">SceneTree.root</inline></reference> 开始）。如果 <literal>path</literal> 未指向一个有效节点，则会生成错误并返回 <literal>null</literal>。尝试访问返回值上的方法将导致<emphasis>“尝试在一个 null 实例上调用 &lt;method&gt;。”</emphasis>错误。</paragraph>
            <paragraph><strong>注意：</strong>通过绝对路径获取，仅在节点位于场景树内部时有效（参见 <reference internal="True" refid="class-node-method-is-inside-tree"><inline classes="std std-ref">is_inside_tree</inline></reference>）。</paragraph>
            <paragraph><strong>示例：</strong>假设从以下树内的 Character 节点调用该方法：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">┖╴root
   ┠╴Character (you are here!)
   ┃  ┠╴Sword
   ┃  ┖╴Backpack
   ┃     ┖╴Dagger
   ┠╴MyGame
   ┖╴Swamp
      ┠╴Alligator
      ┠╴Mosquito
      ┖╴Goblin</literal_block>
            <paragraph>以下调用将返回一个有效节点：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">get_node("Sword")
get_node("Backpack/Dagger")
get_node("../Swamp/Alligator")
get_node("/root/MyGame")</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GetNode("Sword");
GetNode("Backpack/Dagger");
GetNode("../Swamp/Alligator");
GetNode("/root/MyGame");</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-node-and-resource"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-node-and-resource" names="class_node_method_get_node_and_resource"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> <strong>get_node_and_resource</strong> <strong>(</strong> <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> path <strong>)</strong></paragraph>
            <paragraph>获取节点及其由 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> 子名指定的嵌套最深的资源。返回一个大小为 <literal>3</literal> 的 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>，其中：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>元素 <literal>0</literal> 是 <strong>Node</strong>，如果找不到，则为 <literal>null</literal>；</paragraph>
                </list_item>
                <list_item>
                    <paragraph>元素 <literal>1</literal> 是子名中最后嵌套的 <reference internal="True" refuri="class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>，如果找不到，则为 <literal>null</literal>；</paragraph>
                </list_item>
                <list_item>
                    <paragraph>元素 <literal>2</literal> 是剩余的 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>，引用一个已有的非 <reference internal="True" refuri="class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> 属性（请参阅 <reference internal="True" refuri="class_object#class-object-method-get-indexed"><inline classes="std std-ref">Object.get_indexed</inline></reference>）。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>示例：</strong>假设子节点的 <reference internal="True" refuri="class_sprite2d#class-sprite2d-property-texture"><inline classes="std std-ref">Sprite2D.texture</inline></reference> 已被分配了一个<reference internal="True" refuri="class_atlastexture#class-atlastexture"><inline classes="std std-ref">AtlasTexture</inline></reference>：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var a = get_node_and_resource("Area2D/Sprite2D")
print(a[0].name) # 打印 Sprite2D
print(a[1])      # 打印 &lt;null&gt;
print(a[2])      # 打印 ^""

var b = get_node_and_resource("Area2D/Sprite2D:texture:atlas")
print(b[0].name)        # 打印 Sprite2D
print(b[1].get_class()) # 打印 AtlasTexture
print(b[2])             # 打印 ^""

var c = get_node_and_resource("Area2D/Sprite2D:texture:atlas:region")
print(c[0].name)        # 打印 Sprite2D
print(c[1].get_class()) # 打印 AtlasTexture
print(c[2])             # 打印 ^":region"</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var a = GetNodeAndResource(NodePath("Area2D/Sprite2D"));
GD.Print(a[0].Name); // 打印 Sprite2D
GD.Print(a[1]);      // 打印 &lt;null&gt;
GD.Print(a[2]);      // 打印 ^"

var b = GetNodeAndResource(NodePath("Area2D/Sprite2D:texture:atlas"));
GD.Print(b[0].name);        // 打印 Sprite2D
GD.Print(b[1].get_class()); // 打印 AtlasTexture
GD.Print(b[2]);             // 打印 ^""

var c = GetNodeAndResource(NodePath("Area2D/Sprite2D:texture:atlas:region"));
GD.Print(c[0].name);        // 打印 Sprite2D
GD.Print(c[1].get_class()); // 打印 AtlasTexture
GD.Print(c[2]);             // 打印 ^":region"</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-node-or-null"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-node-or-null" names="class_node_method_get_node_or_null"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>get_node_or_null</strong> <strong>(</strong> <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> path <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>通过 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> 获取节点。类似于 <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node</inline></reference>，但在 <literal>path</literal> 没有指向有效节点时不会生成错误。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-parent"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-parent" names="class_node_method_get_parent"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>get_parent</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该节点的父节点，如果该节点没有父节点，则返回 <literal>null</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-path"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-path" names="class_node_method_get_path"><reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> <strong>get_path</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回该节点相对于 <reference internal="True" refuri="class_scenetree#class-scenetree-property-root"><inline classes="std std-ref">SceneTree.root</inline></reference> 的绝对路径。如果该节点不在场景树内部，则该方法失败并返回空的 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-path-to"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-path-to" names="class_node_method_get_path_to"><reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> <strong>get_path_to</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> use_unique_path=false <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回从该节点到指定节点 <literal>node</literal> 的相对 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>。这两个节点都必须在同一个 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 中，否则该方法将失败并返回一个空的 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>。</paragraph>
            <paragraph>如果 <literal>use_unique_path</literal> 为 <literal>true</literal>，则返回考虑该节点唯一名称的最短路径（请参阅 <reference internal="True" refid="class-node-property-unique-name-in-owner"><inline classes="std std-ref">unique_name_in_owner</inline></reference>）。</paragraph>
            <paragraph><strong>注意：</strong>如果你获取了从唯一节点开始的相对路径，则由于添加了唯一节点的名称，该路径可能比普通的相对路径长。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-physics-process-delta-time"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-physics-process-delta-time" names="class_node_method_get_physics_process_delta_time"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>get_physics_process_delta_time</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回自上次物理回调以来经过的时间（单位为秒）。该值与 <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process</inline></reference> 的 <literal>delta</literal> 参数相同，并且除非 <reference internal="True" refuri="class_engine#class-engine-property-physics-ticks-per-second"><inline classes="std std-ref">Engine.physics_ticks_per_second</inline></reference> 被更改，否则这在运行时通常是恒定的。另请参阅 <reference internal="True" refid="class-node-constant-notification-physics-process"><inline classes="std std-ref">NOTIFICATION_PHYSICS_PROCESS</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-process-delta-time"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-process-delta-time" names="class_node_method_get_process_delta_time"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>get_process_delta_time</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回自上次处理回调以来经过的时间（单位为秒）。该值与 <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process</inline></reference> 的 <literal>delta</literal> 参数相同，并且可能因帧而异。另请参阅 <reference internal="True" refid="class-node-constant-notification-process"><inline classes="std std-ref">NOTIFICATION_PROCESS</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-scene-instance-load-placeholder"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-scene-instance-load-placeholder" names="class_node_method_get_scene_instance_load_placeholder"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>get_scene_instance_load_placeholder</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该节点是一个实例加载占位符，则返回 <literal>true</literal>。见 <reference internal="True" refuri="class_instanceplaceholder#class-instanceplaceholder"><inline classes="std std-ref">InstancePlaceholder</inline></reference> 和 <reference internal="True" refid="class-node-method-set-scene-instance-load-placeholder"><inline classes="std std-ref">set_scene_instance_load_placeholder</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-tree"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-tree" names="class_node_method_get_tree"><reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> <strong>get_tree</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回包含该节点的 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>。如果该节点不在场景树内，则会生成错误并返回 <literal>null</literal>。另见 <reference internal="True" refid="class-node-method-is-inside-tree"><inline classes="std std-ref">is_inside_tree</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-tree-string"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-tree-string" names="class_node_method_get_tree_string"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_tree_string</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>将树以 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> 的形式返回。主要用于调试。这个版本显示相对于当前节点的路径，适合复制/粘贴到 <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node</inline></reference> 函数中。也可以用于游戏中的 UI/UX。</paragraph>
            <paragraph><strong>示例输出：</strong></paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">TheGame
TheGame/Menu
TheGame/Menu/Label
TheGame/Menu/Camera2D
TheGame/SplashScreen
TheGame/SplashScreen/Camera2D</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-tree-string-pretty"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-tree-string-pretty" names="class_node_method_get_tree_string_pretty"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_tree_string_pretty</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>类似于 <reference internal="True" refid="class-node-method-get-tree-string"><inline classes="std std-ref">get_tree_string</inline></reference>，会将树以 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> 的形式返回。这个版本使用的是一种更加图形化的呈现方式，类似于在“场景”面板中显示的内容。非常适合检查较大的树。</paragraph>
            <paragraph><strong>输出示例：</strong></paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">┖╴TheGame
   ┠╴Menu
   ┃  ┠╴Label
   ┃  ┖╴Camera2D
   ┖╴SplashScreen
      ┖╴Camera2D</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-viewport"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-viewport" names="class_node_method_get_viewport"><reference internal="True" refuri="class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> <strong>get_viewport</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果节点位于场景树内部，则返回该节点最近的 <reference internal="True" refuri="class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> 祖先。否则，返回 <literal>null</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-window"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-window" names="class_node_method_get_window"><reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> <strong>get_window</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回包含该节点的 <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference>。如果该节点在主窗口中，则相当于获取根节点（<literal>get_tree().get_root()</literal>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-has-node"></target>
            <paragraph classes="classref-method" ids="class-node-method-has-node" names="class_node_method_has_node"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>has_node</strong> <strong>(</strong> <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> path <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果 <literal>path</literal> 指向一个有效节点，则返回 <literal>true</literal>。另见 <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-has-node-and-resource"></target>
            <paragraph classes="classref-method" ids="class-node-method-has-node-and-resource" names="class_node_method_has_node_and_resource"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>has_node_and_resource</strong> <strong>(</strong> <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> path <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果 <literal>path</literal> 指向一个有效的节点，并且它的子名称指向一个有效的 <reference internal="True" refuri="class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>，例如 <literal>Area2D/CollisionShape2D:shape</literal>，则返回 <literal>true</literal>。不考虑非 <reference internal="True" refuri="class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> 类型（例如节点或其他 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> 类型）的属性。另见 <reference internal="True" refid="class-node-method-get-node-and-resource"><inline classes="std std-ref">get_node_and_resource</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-ancestor-of"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-ancestor-of" names="class_node_method_is_ancestor_of"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_ancestor_of</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果给定的 <literal>node</literal> 是该节点的直接或间接子节点，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-displayed-folded"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-displayed-folded" names="class_node_method_is_displayed_folded"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_displayed_folded</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该节点在“场景”面板中被折叠，则返回 <literal>true</literal>。该方法旨在用于编辑器插件和工具。另见 <reference internal="True" refid="class-node-method-set-display-folded"><inline classes="std std-ref">set_display_folded</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-editable-instance"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-editable-instance" names="class_node_method_is_editable_instance"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_editable_instance</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果 <literal>node</literal> 具有相对于该节点启用的可编辑子节点，则返回 <literal>true</literal>。该方法旨在用于编辑器插件和工具。另见 <reference internal="True" refid="class-node-method-set-editable-instance"><inline classes="std std-ref">set_editable_instance</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-greater-than"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-greater-than" names="class_node_method_is_greater_than"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_greater_than</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果给定的 <literal>node</literal> 在场景层次结构中出现得比该节点晚，则返回 <literal>true</literal>。晚出现的节点通常晚处理。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-in-group"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-in-group" names="class_node_method_is_in_group"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_in_group</strong> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> group <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该节点已被添加到给定的 <literal>group</literal>，则返回 <literal>true</literal>。请参阅 <reference internal="True" refid="class-node-method-add-to-group"><inline classes="std std-ref">add_to_group</inline></reference> 和 <reference internal="True" refid="class-node-method-remove-from-group"><inline classes="std std-ref">remove_from_group</inline></reference>。另请参阅描述中的注释以及 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 的分组方法。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-inside-tree"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-inside-tree" names="class_node_method_is_inside_tree"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_inside_tree</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该节点当前在 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 中，返回 <literal>true</literal>。另见 <reference internal="True" refid="class-node-method-get-tree"><inline classes="std std-ref">get_tree</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-multiplayer-authority"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-multiplayer-authority" names="class_node_method_is_multiplayer_authority"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_multiplayer_authority</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果本地系统为这个节点的多人游戏控制者，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-node-ready"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-node-ready" names="class_node_method_is_node_ready"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_node_ready</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该节点已就绪，则返回 <literal>true</literal>，即该节点位于场景树中，并且所有子项均已初始化。</paragraph>
            <paragraph><reference internal="True" refid="class-node-method-request-ready"><inline classes="std std-ref">request_ready</inline></reference> 会将其重置回 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-physics-processing"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-physics-processing" names="class_node_method_is_physics_processing"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_physics_processing</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果启用了物理处理，返回 <literal>true</literal>（见 <reference internal="True" refid="class-node-method-set-physics-process"><inline classes="std std-ref">set_physics_process</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-physics-processing-internal"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-physics-processing-internal" names="class_node_method_is_physics_processing_internal"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_physics_processing_internal</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果内部物理处理被启用，返回 <literal>true</literal>（见 <reference internal="True" refid="class-node-method-set-physics-process-internal"><inline classes="std std-ref">set_physics_process_internal</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-processing"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-processing" names="class_node_method_is_processing"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_processing</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果开启了处理，返回 <literal>true</literal>（见 <reference internal="True" refid="class-node-method-set-process"><inline classes="std std-ref">set_process</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-processing-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-processing-input" names="class_node_method_is_processing_input"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_processing_input</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果节点正在处理输入，则返回 <literal>true</literal>（见 <reference internal="True" refid="class-node-method-set-process-input"><inline classes="std std-ref">set_process_input</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-processing-internal"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-processing-internal" names="class_node_method_is_processing_internal"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_processing_internal</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果启用了内部处理，则返回 <literal>true</literal>（见 <reference internal="True" refid="class-node-method-set-process-internal"><inline classes="std std-ref">set_process_internal</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-processing-shortcut-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-processing-shortcut-input" names="class_node_method_is_processing_shortcut_input"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_processing_shortcut_input</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果节点正在处理快捷键，则返回 <literal>true</literal>（见 <reference internal="True" refid="class-node-method-set-process-shortcut-input"><inline classes="std std-ref">set_process_shortcut_input</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-processing-unhandled-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-processing-unhandled-input" names="class_node_method_is_processing_unhandled_input"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_processing_unhandled_input</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果节点正在处理未被处理的输入，则返回 <literal>true</literal>（见 <reference internal="True" refid="class-node-method-set-process-unhandled-input"><inline classes="std std-ref">set_process_unhandled_input</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-processing-unhandled-key-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-processing-unhandled-key-input" names="class_node_method_is_processing_unhandled_key_input"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_processing_unhandled_key_input</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果节点正在处理未被处理的键输入，则返回 <literal>true</literal>（见 <reference internal="True" refid="class-node-method-set-process-unhandled-key-input"><inline classes="std std-ref">set_process_unhandled_key_input</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-move-child"></target>
            <paragraph classes="classref-method" ids="class-node-method-move-child" names="class_node_method_move_child">void <strong>move_child</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> child_node, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> to_index <strong>)</strong></paragraph>
            <paragraph>将 <literal>child_node</literal> 移动到给定索引。节点的索引是其同级节点之间的顺序。如果 <literal>to_index</literal> 为负，则索引从列表末尾开始计数。另见 <reference internal="True" refid="class-node-method-get-child"><inline classes="std std-ref">get_child</inline></reference> 和 <reference internal="True" refid="class-node-method-get-index"><inline classes="std std-ref">get_index</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>几个引擎回调（<reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready</inline></reference>、<reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process</inline></reference> 等）和通过 <reference internal="True" refid="class-node-method-propagate-notification"><inline classes="std std-ref">propagate_notification</inline></reference> 发送的通知的处理顺序受树顺序的影响。<reference internal="True" refuri="class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference> 节点也按树顺序渲染。另见<reference internal="True" refid="class-node-property-process-priority"><inline classes="std std-ref">process_priority</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-notify-deferred-thread-group"></target>
            <paragraph classes="classref-method" ids="class-node-method-notify-deferred-thread-group" names="class_node_method_notify_deferred_thread_group">void <strong>notify_deferred_thread_group</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> what <strong>)</strong></paragraph>
            <paragraph>类似于 <reference internal="True" refid="class-node-method-call-deferred-thread-group"><inline classes="std std-ref">call_deferred_thread_group</inline></reference>，但针对的是通知。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-notify-thread-safe"></target>
            <paragraph classes="classref-method" ids="class-node-method-notify-thread-safe" names="class_node_method_notify_thread_safe">void <strong>notify_thread_safe</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> what <strong>)</strong></paragraph>
            <paragraph>类似于 <reference internal="True" refid="class-node-method-call-thread-safe"><inline classes="std std-ref">call_thread_safe</inline></reference>，但针对的是通知。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-print-orphan-nodes"></target>
            <paragraph classes="classref-method" ids="class-node-method-print-orphan-nodes" names="class_node_method_print_orphan_nodes">void <strong>print_orphan_nodes</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>输出所有孤立节点（<reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 之外的节点）。利于调试。</paragraph>
            <paragraph><strong>注意：</strong>该方法仅适用于调试构建版本。在以发布模式导出的项目中不执行任何操作。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-print-tree"></target>
            <paragraph classes="classref-method" ids="class-node-method-print-tree" names="class_node_method_print_tree">void <strong>print_tree</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>将该节点及其子节点打印到标准输出，会进行递归操作。该节点可以不在树中。这个方法输出的是相对于当前节点的路径，适合复制/粘贴到 <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node</inline></reference> 函数中。另见 <reference internal="True" refid="class-node-method-print-tree-pretty"><inline classes="std std-ref">print_tree_pretty</inline></reference>。</paragraph>
            <paragraph><strong>示例输出：</strong></paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">.
Menu
Menu/Label
Menu/Camera2D
SplashScreen
SplashScreen/Camera2D</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-print-tree-pretty"></target>
            <paragraph classes="classref-method" ids="class-node-method-print-tree-pretty" names="class_node_method_print_tree_pretty">void <strong>print_tree_pretty</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>递归地将节点及其子节点打印到控制台。节点不必位于场景树中。类似于 <reference internal="True" refid="class-node-method-print-tree"><inline classes="std std-ref">print_tree</inline></reference>，但图形表示看起来像编辑器的场景面板中显示的内容。利于检查较大的树。</paragraph>
            <paragraph><strong>输出示例：</strong></paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">┖╴TheGame
   ┠╴Menu
   ┃  ┠╴Label
   ┃  ┖╴Camera2D
   ┖╴SplashScreen
      ┖╴Camera2D</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-propagate-call"></target>
            <paragraph classes="classref-method" ids="class-node-method-propagate-call" names="class_node_method_propagate_call">void <strong>propagate_call</strong> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> method, <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> args=[], <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> parent_first=false <strong>)</strong></paragraph>
            <paragraph>在该节点上并递归地在其所有子节点上，调用给定的 <literal>method</literal> 名称，并将 <literal>args</literal> 作为参数传递。</paragraph>
            <paragraph>如果 <literal>parent_first</literal> 参数为 <literal>true</literal>，则该方法将首先在该节点上调用，然后在其所有子节点上调用。如果为 <literal>false</literal>，则子节点的方法将首先被调用。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-propagate-notification"></target>
            <paragraph classes="classref-method" ids="class-node-method-propagate-notification" names="class_node_method_propagate_notification">void <strong>propagate_notification</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> what <strong>)</strong></paragraph>
            <paragraph>在该节点上并递归地在其所有子节点上，使用 <literal>what</literal> 调用 <reference internal="True" refuri="class_object#class-object-method-notification"><inline classes="std std-ref">Object.notification</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-queue-free"></target>
            <paragraph classes="classref-method" ids="class-node-method-queue-free" names="class_node_method_queue_free">void <strong>queue_free</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>将该节点加入队列以在当前帧末尾删除。被删除时，其所有子节点也将被删除，并且对该节点及其子节点的所有引用都将变得无效。</paragraph>
            <paragraph>与 <reference internal="True" refuri="class_object#class-object-method-free"><inline classes="std std-ref">Object.free</inline></reference> 不同，该节点不会被立即删除，并且它在被删除前仍然可以访问。多次调用 <reference internal="True" refid="class-node-method-queue-free"><inline classes="std std-ref">queue_free</inline></reference> 也是安全的。使用 <reference internal="True" refuri="class_object#class-object-method-is-queued-for-deletion"><inline classes="std std-ref">Object.is_queued_for_deletion</inline></reference> 检查节点是否会在该帧末尾删除。</paragraph>
            <paragraph><strong>注意：</strong>该节点只会在所有其他已延迟的调用完成后释放。使用该方法并不总会和通过 <reference internal="True" refuri="class_object#class-object-method-call-deferred"><inline classes="std std-ref">Object.call_deferred</inline></reference> 调用 <reference internal="True" refuri="class_object#class-object-method-free"><inline classes="std std-ref">Object.free</inline></reference> 相同。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-remove-child"></target>
            <paragraph classes="classref-method" ids="class-node-method-remove-child" names="class_node_method_remove_child">void <strong>remove_child</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node <strong>)</strong></paragraph>
            <paragraph>移除一个子 <literal>node</literal>。该 <literal>node</literal> 及其子节点<strong>不会</strong>被删除。要删除节点，见 <reference internal="True" refid="class-node-method-queue-free"><inline classes="std std-ref">queue_free</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>当该节点位于场景树中时，如果被移除的 <literal>node</literal>（或其后代）的 <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> 不再是祖先（参见 <reference internal="True" refid="class-node-method-is-ancestor-of"><inline classes="std std-ref">is_ancestor_of</inline></reference>），则该方法将它们的 <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> 设置为 <literal>null</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-remove-from-group"></target>
            <paragraph classes="classref-method" ids="class-node-method-remove-from-group" names="class_node_method_remove_from_group">void <strong>remove_from_group</strong> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> group <strong>)</strong></paragraph>
            <paragraph>从给定的 <literal>group</literal> 中移除该节点。如果该节点不在 <literal>group</literal> 中，则不执行任何操作。另请参阅描述中的注释以及 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 的分组方法。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-reparent"></target>
            <paragraph classes="classref-method" ids="class-node-method-reparent" names="class_node_method_reparent">void <strong>reparent</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> new_parent, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> keep_global_transform=true <strong>)</strong></paragraph>
            <paragraph>将这个 <strong>Node</strong> 的父节点更改为 <literal>new_parent</literal>。该节点需要拥有父节点。</paragraph>
            <paragraph>如果 <literal>keep_global_transform</literal> 为 <literal>true</literal>，则会在支持时保持该节点的全局变换。<reference internal="True" refuri="class_node2d#class-node2d"><inline classes="std std-ref">Node2D</inline></reference>、<reference internal="True" refuri="class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference>、<reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 支持这个参数（但 <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 只会保留位置）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-replace-by"></target>
            <paragraph classes="classref-method" ids="class-node-method-replace-by" names="class_node_method_replace_by">void <strong>replace_by</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> keep_groups=false <strong>)</strong></paragraph>
            <paragraph>将该节点替换为给定的 <literal>node</literal>。该节点的所有子节点都会被移动到 <literal>node</literal>。</paragraph>
            <paragraph>如果 <literal>keep_groups</literal> 为 <literal>true</literal>，则 <literal>node</literal> 将被添加到被替换节点所在的相同分组中（请参阅 <reference internal="True" refid="class-node-method-add-to-group"><inline classes="std std-ref">add_to_group</inline></reference>）。</paragraph>
            <paragraph><strong>警告：</strong>被替换的节点已从树中移除，但<strong>未</strong>被删除。为了防止内存泄漏，请将该节点的引用存储在变量中，或使用 <reference internal="True" refuri="class_object#class-object-method-free"><inline classes="std std-ref">Object.free</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-request-ready"></target>
            <paragraph classes="classref-method" ids="class-node-method-request-ready" names="class_node_method_request_ready">void <strong>request_ready</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>请求在该节点下次进入树时再次调用 <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready</inline></reference>。<strong>不</strong>会立即调用 <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>该方法只影响当前节点。如果该节点的子节点也需要请求就绪，则需要为每个子节点调用该方法。当节点及其子节点再次进入树时，<reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready</inline></reference> 回调的顺序将与正常情况相同。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-rpc"></target>
            <paragraph classes="classref-method" ids="class-node-method-rpc" names="class_node_method_rpc"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>rpc</strong> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> method, ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></paragraph>
            <paragraph>将给定 <literal>method</literal> 的远程过程调用请求发送到网络（和本地）上的对等体，并将额外参数发送给 RPC 调用的方法。该调用请求只会被具有相同 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> 的节点接收，该节点包括完全相同的 <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference>。行为取决于给定 <literal>method</literal> 的 RPC 配置（请参阅 <reference internal="True" refid="class-node-method-rpc-config"><inline classes="std std-ref">rpc_config</inline></reference> 和 <reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-rpc"><inline classes="std std-ref">@GDScript.@rpc</inline></reference>）。默认情况下，方法不会暴露给 RPC。</paragraph>
            <paragraph>如果调用成功，则返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-ok"><inline classes="std std-ref">@GlobalScope.OK</inline></reference>；如果 <literal>method</literal> 中传递的参数不匹配，则返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-invalid-parameter"><inline classes="std std-ref">@GlobalScope.ERR_INVALID_PARAMETER</inline></reference>；如果无法获取节点的 <reference internal="True" refid="class-node-property-multiplayer"><inline classes="std std-ref">multiplayer</inline></reference>（例如当该节点不在树中），则返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-unconfigured"><inline classes="std std-ref">@GlobalScope.ERR_UNCONFIGURED</inline></reference>；如果 <reference internal="True" refid="class-node-property-multiplayer"><inline classes="std std-ref">multiplayer</inline></reference> 的连接不可用，则返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-connection-error"><inline classes="std std-ref">@GlobalScope.ERR_CONNECTION_ERROR</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>只有在收到来自 <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> 的 <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi-signal-connected-to-server"><inline classes="std std-ref">MultiplayerAPI.connected_to_server</inline></reference> 信号后，才能在客户端上安全地使用 RPC。还需要跟踪连接状态，可通过 <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> 信号（如 <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi-signal-server-disconnected"><inline classes="std std-ref">MultiplayerAPI.server_disconnected</inline></reference>）或通过检查（<literal>get_multiplayer().peer.get_connection_status() == CONNECTION_CONNECTED</literal>）来跟踪。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-rpc-config"></target>
            <paragraph classes="classref-method" ids="class-node-method-rpc-config" names="class_node_method_rpc_config">void <strong>rpc_config</strong> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> method, <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> config <strong>)</strong></paragraph>
            <paragraph>更改给定 <literal>method</literal> 的 RPC 配置。<literal>config</literal> 应该是 <literal>null</literal> 以禁用该功能（默认情况下），或者是包含以下条目的 <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>rpc_mode</literal>：见 <reference internal="True" refuri="class_multiplayerapi#enum-multiplayerapi-rpcmode"><inline classes="std std-ref">RPCMode</inline></reference>；</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>transfer_mode</literal>：见 <reference internal="True" refuri="class_multiplayerpeer#enum-multiplayerpeer-transfermode"><inline classes="std std-ref">TransferMode</inline></reference>；</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>call_local</literal>：如果为 <literal>true</literal>，该方法也将会在本地调用；</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>channel</literal>：一个 <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> 表示启用了发送 RPC 的通道。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>注意：</strong>在 GDScript 中，该方法对应 <reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-rpc"><inline classes="std std-ref">@GDScript.@rpc</inline></reference> 注解，并传递各种参数（<literal>@rpc(any)</literal>、<literal>@rpc(authority)</literal>……）。 另请参阅 <reference internal="True" refuri="../tutorials/networking/high_level_multiplayer"><inline classes="doc">高级多人游戏</inline></reference> 教程。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-rpc-id"></target>
            <paragraph classes="classref-method" ids="class-node-method-rpc-id" names="class_node_method_rpc_id"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>rpc_id</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> peer_id, <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> method, ... <strong>)</strong> <abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></paragraph>
            <paragraph>将 <reference internal="True" refid="class-node-method-rpc"><inline classes="std std-ref">rpc</inline></reference> 发送到由 <literal>peer_id</literal> 标识的特定对等体（请参阅 <reference internal="True" refuri="class_multiplayerpeer#class-multiplayerpeer-method-set-target-peer"><inline classes="std std-ref">MultiplayerPeer.set_target_peer</inline></reference>）。</paragraph>
            <paragraph>如果调用成功，则返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-ok"><inline classes="std std-ref">@GlobalScope.OK</inline></reference>；如果 <literal>method</literal> 中传递的参数不匹配，则返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-invalid-parameter"><inline classes="std std-ref">@GlobalScope.ERR_INVALID_PARAMETER</inline></reference>；如果无法获取节点的 <reference internal="True" refid="class-node-property-multiplayer"><inline classes="std std-ref">multiplayer</inline></reference>（例如当节点不在场景树中），则返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-unconfigured"><inline classes="std std-ref">@GlobalScope.ERR_UNCONFIGURED</inline></reference>；如果 <reference internal="True" refid="class-node-property-multiplayer"><inline classes="std std-ref">multiplayer</inline></reference> 的连接不可用，则返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-connection-error"><inline classes="std std-ref">@GlobalScope.ERR_CONNECTION_ERROR</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-deferred-thread-group"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-deferred-thread-group" names="class_node_method_set_deferred_thread_group">void <strong>set_deferred_thread_group</strong> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> property, <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> value <strong>)</strong></paragraph>
            <paragraph>类似于 <reference internal="True" refid="class-node-method-call-deferred-thread-group"><inline classes="std std-ref">call_deferred_thread_group</inline></reference>，但针对的是设置属性。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-display-folded"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-display-folded" names="class_node_method_set_display_folded">void <strong>set_display_folded</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> fold <strong>)</strong></paragraph>
            <paragraph>如果设置为 <literal>true</literal>，则节点将在场景面板中显示为被折叠。结果，它的所有子节点都被隐藏了。该方法旨在用于编辑器插件和工具脚本，但它也适用于发布构建版本。另请参阅 <reference internal="True" refid="class-node-method-is-displayed-folded"><inline classes="std std-ref">is_displayed_folded</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-editable-instance"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-editable-instance" names="class_node_method_set_editable_instance">void <strong>set_editable_instance</strong> <strong>(</strong> <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> node, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> is_editable <strong>)</strong></paragraph>
            <paragraph>设置为 <literal>true</literal> 以允许 <literal>node</literal> 拥有的所有节点在场景面板中可用且可编辑，即使它们的 <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> 不是场景根。该方法旨在用于编辑器插件和工具脚本，但它也适用于发布构建版本。另见 <reference internal="True" refid="class-node-method-is-editable-instance"><inline classes="std std-ref">is_editable_instance</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-multiplayer-authority"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-multiplayer-authority" names="class_node_method_set_multiplayer_authority">void <strong>set_multiplayer_authority</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> id, <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> recursive=true <strong>)</strong></paragraph>
            <paragraph>将该节点的多人游戏控制方设置为具有给定对等体 <literal>id</literal> 的对等体。多人游戏控制方是对网络上的节点具有控制权限的对等体。默认为对等体 ID 1（服务器）。利于与 <reference internal="True" refid="class-node-method-rpc-config"><inline classes="std std-ref">rpc_config</inline></reference> 和 <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> 结合使用。</paragraph>
            <paragraph>如果 <literal>recursive</literal> 为 <literal>true</literal>，则该节点的所有子节点将递归地将给定的对等体设置为控制方。</paragraph>
            <paragraph><strong>警告：</strong>这<strong>不会</strong>自动将新的控制方复制给其他对等体。是否这样做由开发者负责。可以使用 <reference internal="True" refuri="class_multiplayerspawner#class-multiplayerspawner-property-spawn-function"><inline classes="std std-ref">MultiplayerSpawner.spawn_function</inline></reference>、RPC、或 <reference internal="True" refuri="class_multiplayersynchronizer#class-multiplayersynchronizer"><inline classes="std std-ref">MultiplayerSynchronizer</inline></reference> 复制新控制方的信息。此外，父节点的控制方<strong>不会</strong>传播给新添加的子节点。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-physics-process"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-physics-process" names="class_node_method_set_physics_process">void <strong>set_physics_process</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
            <paragraph>如果设置为 <literal>true</literal>，则启用物理（固定帧率）处理。当一个节点正在被处理时，它将以固定的（通常是 60 FPS，请参阅 <reference internal="True" refuri="class_engine#class-engine-property-physics-ticks-per-second"><inline classes="std std-ref">Engine.physics_ticks_per_second</inline></reference> 以更改）时间间隔，接收一个 <reference internal="True" refid="class-node-constant-notification-physics-process"><inline classes="std std-ref">NOTIFICATION_PHYSICS_PROCESS</inline></reference>（如果存在 <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process</inline></reference> 回调，该回调将被调用）。如果 <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process</inline></reference> 被重写，则会自动启用该属性。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-physics-process-internal"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-physics-process-internal" names="class_node_method_set_physics_process_internal">void <strong>set_physics_process_internal</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
            <paragraph>如果设置为 <literal>true</literal>，则启用该节点的内部物理。内部物理处理独立于正常的 <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process</inline></reference> 调用而发生，并且由某些节点内部使用以确保正常工作，即使节点暂停或物理处理因脚本而禁用（<reference internal="True" refid="class-node-method-set-physics-process"><inline classes="std std-ref">set_physics_process</inline></reference>）也是如此。</paragraph>
            <paragraph><strong>警告：</strong>内置节点依靠内部处理来实现其内部逻辑。禁用它是不安全的，并且可能会导致意外行为。请在你知道自己正在做什么时使用该方法。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-process"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-process" names="class_node_method_set_process">void <strong>set_process</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
            <paragraph>如果设置为 <literal>true</literal>，则启用帧处理。当一个节点正在被处理时，它将在每个绘制的帧上收到一个 <reference internal="True" refid="class-node-constant-notification-process"><inline classes="std std-ref">NOTIFICATION_PROCESS</inline></reference>（如果存在 <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process</inline></reference> 回调，该回调将被调用）。如果 <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process</inline></reference> 被重写，则会自动启用该属性。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-process-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-process-input" names="class_node_method_set_process_input">void <strong>set_process_input</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
            <paragraph>如果设置为 <literal>true</literal>，则启用输入处理。它对于 GUI 控件来说不是必需的！如果 <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input</inline></reference> 被重写，则会自动启用该属性。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-process-internal"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-process-internal" names="class_node_method_set_process_internal">void <strong>set_process_internal</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
            <paragraph>如果设置为 <literal>true</literal>，则启用该节点的内部处理。内部处理独立于正常的 <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process</inline></reference> 调用而发生，并且由某些节点在内部使用以保证正常运行，即使节点已暂停或处理因脚本而禁用（<reference internal="True" refid="class-node-method-set-process"><inline classes="std std-ref">set_process</inline></reference>）也是如此。</paragraph>
            <paragraph><strong>警告：</strong>内置节点依靠内部处理来实现其内部逻辑。禁用它是不安全的，并且可能会导致意外行为。请在你知道自己正在做什么时使用该方法。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-process-shortcut-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-process-shortcut-input" names="class_node_method_set_process_shortcut_input">void <strong>set_process_shortcut_input</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
            <paragraph>如果设置为 <literal>true</literal>，则启用该节点的快捷键处理。如果 <reference internal="True" refid="class-node-private-method-shortcut-input"><inline classes="std std-ref">_shortcut_input</inline></reference> 被重写，则会自动启用该属性。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-process-unhandled-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-process-unhandled-input" names="class_node_method_set_process_unhandled_input">void <strong>set_process_unhandled_input</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
            <paragraph>如果设置为 <literal>true</literal>，则启用未处理的输入处理。这对 GUI 控件来说是不需要的！它使节点能够接收所有以前没有处理的输入（通常是由 <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 处理的）。如果 <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input</inline></reference> 被重写，则会自动启用该属性。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-process-unhandled-key-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-process-unhandled-key-input" names="class_node_method_set_process_unhandled_key_input">void <strong>set_process_unhandled_key_input</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> enable <strong>)</strong></paragraph>
            <paragraph>如果设置为 <literal>true</literal>，则启用未处理的按键输入处理。如果 <reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref">_unhandled_key_input</inline></reference> 被重写，则会自动启用该属性。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-scene-instance-load-placeholder"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-scene-instance-load-placeholder" names="class_node_method_set_scene_instance_load_placeholder">void <strong>set_scene_instance_load_placeholder</strong> <strong>(</strong> <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> load_placeholder <strong>)</strong></paragraph>
            <paragraph>如果设置为 <literal>true</literal>，则当从 <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference> 打包和实例化时，节点将变为 <reference internal="True" refuri="class_instanceplaceholder#class-instanceplaceholder"><inline classes="std std-ref">InstancePlaceholder</inline></reference>。另见 <reference internal="True" refid="class-node-method-get-scene-instance-load-placeholder"><inline classes="std std-ref">get_scene_instance_load_placeholder</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-thread-safe"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-thread-safe" names="class_node_method_set_thread_safe">void <strong>set_thread_safe</strong> <strong>(</strong> <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> property, <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> value <strong>)</strong></paragraph>
            <paragraph>类似于 <reference internal="True" refid="class-node-method-call-thread-safe"><inline classes="std std-ref">call_thread_safe</inline></reference>，但用于设置属性。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-update-configuration-warnings"></target>
            <paragraph classes="classref-method" ids="class-node-method-update-configuration-warnings" names="class_node_method_update_configuration_warnings">void <strong>update_configuration_warnings</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>刷新场景面板中为该节点显示的警告。使用 <reference internal="True" refid="class-node-private-method-get-configuration-warnings"><inline classes="std std-ref">_get_configuration_warnings</inline></reference> 自定义要显示的警告消息。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
