<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_node.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/master/doc/classes/Node.xml.</comment>
    <target refid="class-node"></target>
    <section ids="node class-node" names="node class_node">
        <title>Node</title>
        <paragraph><strong>Inherits:</strong> <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference></paragraph>
        <paragraph><strong>Inherited By:</strong> <reference internal="True" refuri="class_animationmixer#class-animationmixer"><inline classes="std std-ref">AnimationMixer</inline></reference>, <reference internal="True" refuri="class_audiostreamplayer#class-audiostreamplayer"><inline classes="std std-ref">AudioStreamPlayer</inline></reference>, <reference internal="True" refuri="class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference>, <reference internal="True" refuri="class_canvaslayer#class-canvaslayer"><inline classes="std std-ref">CanvasLayer</inline></reference>, <reference internal="True" refuri="class_editorfilesystem#class-editorfilesystem"><inline classes="std std-ref">EditorFileSystem</inline></reference>, <reference internal="True" refuri="class_editorplugin#class-editorplugin"><inline classes="std std-ref">EditorPlugin</inline></reference>, <reference internal="True" refuri="class_editorresourcepreview#class-editorresourcepreview"><inline classes="std std-ref">EditorResourcePreview</inline></reference>, <reference internal="True" refuri="class_httprequest#class-httprequest"><inline classes="std std-ref">HTTPRequest</inline></reference>, <reference internal="True" refuri="class_instanceplaceholder#class-instanceplaceholder"><inline classes="std std-ref">InstancePlaceholder</inline></reference>, <reference internal="True" refuri="class_missingnode#class-missingnode"><inline classes="std std-ref">MissingNode</inline></reference>, <reference internal="True" refuri="class_multiplayerspawner#class-multiplayerspawner"><inline classes="std std-ref">MultiplayerSpawner</inline></reference>, <reference internal="True" refuri="class_multiplayersynchronizer#class-multiplayersynchronizer"><inline classes="std std-ref">MultiplayerSynchronizer</inline></reference>, <reference internal="True" refuri="class_navigationagent2d#class-navigationagent2d"><inline classes="std std-ref">NavigationAgent2D</inline></reference>, <reference internal="True" refuri="class_navigationagent3d#class-navigationagent3d"><inline classes="std std-ref">NavigationAgent3D</inline></reference>, <reference internal="True" refuri="class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference>, <reference internal="True" refuri="class_resourcepreloader#class-resourcepreloader"><inline classes="std std-ref">ResourcePreloader</inline></reference>, <reference internal="True" refuri="class_shaderglobalsoverride#class-shaderglobalsoverride"><inline classes="std std-ref">ShaderGlobalsOverride</inline></reference>, <reference internal="True" refuri="class_statusindicator#class-statusindicator"><inline classes="std std-ref">StatusIndicator</inline></reference>, <reference internal="True" refuri="class_timer#class-timer"><inline classes="std std-ref">Timer</inline></reference>, <reference internal="True" refuri="class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>, <reference internal="True" refuri="class_worldenvironment#class-worldenvironment"><inline classes="std std-ref">WorldEnvironment</inline></reference></paragraph>
        <paragraph>Base class for all scene objects.</paragraph>
        <section classes="classref-introduction-group" ids="description" names="description">
            <title>Description</title>
            <paragraph>Nodes are Godot's building blocks. They can be assigned as the child of another node, resulting in a tree arrangement. A given node can contain any number of nodes as children with the requirement that all siblings (direct children of a node) should have unique names.</paragraph>
            <paragraph>A tree of nodes is called a <emphasis>scene</emphasis>. Scenes can be saved to the disk and then instantiated into other scenes. This allows for very high flexibility in the architecture and data model of Godot projects.</paragraph>
            <paragraph><strong>Scene tree:</strong> The <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> contains the active tree of nodes. When a node is added to the scene tree, it receives the <reference internal="True" refid="class-node-constant-notification-enter-tree"><inline classes="std std-ref">NOTIFICATION_ENTER_TREE</inline></reference> notification and its <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree()</inline></reference> callback is triggered. Child nodes are always added <emphasis>after</emphasis> their parent node, i.e. the <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree()</inline></reference> callback of a parent node will be triggered before its child's.</paragraph>
            <paragraph>Once all nodes have been added in the scene tree, they receive the <reference internal="True" refid="class-node-constant-notification-ready"><inline classes="std std-ref">NOTIFICATION_READY</inline></reference> notification and their respective <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> callbacks are triggered. For groups of nodes, the <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> callback is called in reverse order, starting with the children and moving up to the parent nodes.</paragraph>
            <paragraph>This means that when adding a node to the scene tree, the following order will be used for the callbacks: <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree()</inline></reference> of the parent, <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree()</inline></reference> of the children, <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> of the children and finally <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> of the parent (recursively for the entire scene tree).</paragraph>
            <paragraph><strong>Processing:</strong> Nodes can override the "process" state, so that they receive a callback on each frame requesting them to process (do something). Normal processing (callback <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference>, toggled with <reference internal="True" refid="class-node-method-set-process"><inline classes="std std-ref">set_process()</inline></reference>) happens as fast as possible and is dependent on the frame rate, so the processing time <emphasis>delta</emphasis> (in seconds) is passed as an argument. Physics processing (callback <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference>, toggled with <reference internal="True" refid="class-node-method-set-physics-process"><inline classes="std std-ref">set_physics_process()</inline></reference>) happens a fixed number of times per second (60 by default) and is useful for code related to the physics engine.</paragraph>
            <paragraph>Nodes can also process input events. When present, the <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input()</inline></reference> function will be called for each input that the program receives. In many cases, this can be overkill (unless used for simple projects), and the <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input()</inline></reference> function might be preferred; it is called when the input event was not handled by anyone else (typically, GUI <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> nodes), ensuring that the node only receives the events that were meant for it.</paragraph>
            <paragraph>To keep track of the scene hierarchy (especially when instantiating scenes into other scenes), an "owner" can be set for the node with the <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> property. This keeps track of who instantiated what. This is mostly useful when writing editors and tools, though.</paragraph>
            <paragraph>Finally, when a node is freed with <reference internal="True" refuri="class_object#class-object-method-free"><inline classes="std std-ref">Object.free()</inline></reference> or <reference internal="True" refid="class-node-method-queue-free"><inline classes="std std-ref">queue_free()</inline></reference>, it will also free all its children.</paragraph>
            <paragraph><strong>Groups:</strong> Nodes can be added to as many groups as you want to be easy to manage, you could create groups like "enemies" or "collectables" for example, depending on your game. See <reference internal="True" refid="class-node-method-add-to-group"><inline classes="std std-ref">add_to_group()</inline></reference>, <reference internal="True" refid="class-node-method-is-in-group"><inline classes="std std-ref">is_in_group()</inline></reference> and <reference internal="True" refid="class-node-method-remove-from-group"><inline classes="std std-ref">remove_from_group()</inline></reference>. You can then retrieve all nodes in these groups, iterate them and even call methods on groups via the methods on <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.</paragraph>
            <paragraph><strong>Networking with nodes:</strong> After connecting to a server (or making one, see <reference internal="True" refuri="class_enetmultiplayerpeer#class-enetmultiplayerpeer"><inline classes="std std-ref">ENetMultiplayerPeer</inline></reference>), it is possible to use the built-in RPC (remote procedure call) system to communicate over the network. By calling <reference internal="True" refid="class-node-method-rpc"><inline classes="std std-ref">rpc()</inline></reference> with a method name, it will be called locally and in all connected peers (peers = clients and the server that accepts connections). To identify which node receives the RPC call, Godot will use its <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> (make sure node names are the same on all peers). Also, take a look at the high-level networking tutorial and corresponding demos.</paragraph>
            <paragraph><strong>Note:</strong> The <literal>script</literal> property is part of the <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference> class, not <strong>Node</strong>. It isn't exposed like most properties but does have a setter and getter (see <reference internal="True" refuri="class_object#class-object-method-set-script"><inline classes="std std-ref">Object.set_script()</inline></reference> and <reference internal="True" refuri="class_object#class-object-method-get-script"><inline classes="std std-ref">Object.get_script()</inline></reference>).</paragraph>
        </section>
        <section classes="classref-introduction-group" ids="tutorials" names="tutorials">
            <title>Tutorials</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../getting_started/step_by_step/nodes_and_scenes"><inline classes="doc">Nodes and scenes</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="All Demos" refuri="https://github.com/godotengine/godot-demo-projects/">All Demos</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section classes="classref-reftable-group" ids="properties" names="properties">
            <title>Properties</title>
            <table classes="colwidths-auto">
                <tgroup cols="3">
                    <colspec colwidth="77"></colspec>
                    <colspec colwidth="83"></colspec>
                    <colspec colwidth="11"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="enum-node-autotranslatemode"><inline classes="std std-ref">AutoTranslateMode</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-auto-translate-mode"><inline classes="std std-ref">auto_translate_mode</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>0</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-editor-description"><inline classes="std std-ref">editor_description</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>""</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-multiplayer"><inline classes="std std-ref">multiplayer</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="enum-node-physicsinterpolationmode"><inline classes="std std-ref">PhysicsInterpolationMode</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-physics-interpolation-mode"><inline classes="std std-ref">physics_interpolation_mode</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>0</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-process-mode"><inline classes="std std-ref">process_mode</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>0</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-process-physics-priority"><inline classes="std std-ref">process_physics_priority</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>0</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-process-priority"><inline classes="std std-ref">process_priority</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>0</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref">ProcessThreadGroup</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-process-thread-group"><inline classes="std std-ref">process_thread_group</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>0</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-process-thread-group-order"><inline classes="std std-ref">process_thread_group_order</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="This value is an integer composed as a bitmask of the following flags.">BitField</abbreviation>[<reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref">ProcessThreadMessages</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-process-thread-messages"><inline classes="std std-ref">process_thread_messages</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-scene-file-path"><inline classes="std std-ref">scene_file_path</inline></reference></paragraph>
                            </entry>
                            <entry>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-property-unique-name-in-owner"><inline classes="std std-ref">unique_name_in_owner</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>false</literal></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="methods" names="methods">
            <title>Methods</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="66"></colspec>
                    <colspec colwidth="233"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree</inline></reference>() <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-exit-tree"><inline classes="std std-ref">_exit_tree</inline></reference>() <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-get-accessibility-configuration-warnings"><inline classes="std std-ref">_get_accessibility_configuration_warnings</inline></reference>() <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-get-configuration-warnings"><inline classes="std std-ref">_get_configuration_warnings</inline></reference>() <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_rid#class-rid"><inline classes="std std-ref">RID</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-get-focused-accessibility-element"><inline classes="std std-ref">_get_focused_accessibility_element</inline></reference>() <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input</inline></reference>(event: <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference>) <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process</inline></reference>(delta: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process</inline></reference>(delta: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready</inline></reference>() <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-shortcut-input"><inline classes="std std-ref">_shortcut_input</inline></reference>(event: <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference>) <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input</inline></reference>(event: <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference>) <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref">_unhandled_key_input</inline></reference>(event: <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference>) <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child</inline></reference>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>, force_readable_name: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false, internal: <reference internal="True" refid="enum-node-internalmode"><inline classes="std std-ref">InternalMode</inline></reference> = 0)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-add-sibling"><inline classes="std std-ref">add_sibling</inline></reference>(sibling: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>, force_readable_name: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-add-to-group"><inline classes="std std-ref">add_to_group</inline></reference>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, persistent: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-atr"><inline classes="std std-ref">atr</inline></reference>(message: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>, context: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> = "") <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-atr-n"><inline classes="std std-ref">atr_n</inline></reference>(message: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>, plural_message: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, n: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, context: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> = "") <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-call-deferred-thread-group"><inline classes="std std-ref">call_deferred_thread_group</inline></reference>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-call-thread-safe"><inline classes="std std-ref">call_thread_safe</inline></reference>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-can-auto-translate"><inline classes="std std-ref">can_auto_translate</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-can-process"><inline classes="std std-ref">can_process</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-create-tween"><inline classes="std std-ref">create_tween</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-duplicate"><inline classes="std std-ref">duplicate</inline></reference>(flags: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 15) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-find-child"><inline classes="std std-ref">find_child</inline></reference>(pattern: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>, recursive: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true, owned: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-find-children"><inline classes="std std-ref">find_children</inline></reference>(pattern: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>, type: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> = "", recursive: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true, owned: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-find-parent"><inline classes="std std-ref">find_parent</inline></reference>(pattern: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_rid#class-rid"><inline classes="std std-ref">RID</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-accessibility-element"><inline classes="std std-ref">get_accessibility_element</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-child"><inline classes="std std-ref">get_child</inline></reference>(idx: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, include_internal: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-child-count"><inline classes="std std-ref">get_child_count</inline></reference>(include_internal: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-children"><inline classes="std std-ref">get_children</inline></reference>(include_internal: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-groups"><inline classes="std std-ref">get_groups</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-index"><inline classes="std std-ref">get_index</inline></reference>(include_internal: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-last-exclusive-window"><inline classes="std std-ref">get_last_exclusive_window</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-multiplayer-authority"><inline classes="std std-ref">get_multiplayer_authority</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node</inline></reference>(path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-node-and-resource"><inline classes="std std-ref">get_node_and_resource</inline></reference>(path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-node-or-null"><inline classes="std std-ref">get_node_or_null</inline></reference>(path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-node-rpc-config"><inline classes="std std-ref">get_node_rpc_config</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-orphan-node-ids"><inline classes="std std-ref">get_orphan_node_ids</inline></reference>() <abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-parent"><inline classes="std std-ref">get_parent</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-path"><inline classes="std std-ref">get_path</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-path-to"><inline classes="std std-ref">get_path_to</inline></reference>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>, use_unique_path: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-physics-process-delta-time"><inline classes="std std-ref">get_physics_process_delta_time</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-process-delta-time"><inline classes="std std-ref">get_process_delta_time</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-scene-instance-load-placeholder"><inline classes="std std-ref">get_scene_instance_load_placeholder</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-tree"><inline classes="std std-ref">get_tree</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-tree-string"><inline classes="std std-ref">get_tree_string</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-tree-string-pretty"><inline classes="std std-ref">get_tree_string_pretty</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-viewport"><inline classes="std std-ref">get_viewport</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-get-window"><inline classes="std std-ref">get_window</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-has-node"><inline classes="std std-ref">has_node</inline></reference>(path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-has-node-and-resource"><inline classes="std std-ref">has_node_and_resource</inline></reference>(path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-ancestor-of"><inline classes="std std-ref">is_ancestor_of</inline></reference>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-displayed-folded"><inline classes="std std-ref">is_displayed_folded</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-editable-instance"><inline classes="std std-ref">is_editable_instance</inline></reference>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-greater-than"><inline classes="std std-ref">is_greater_than</inline></reference>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-in-group"><inline classes="std std-ref">is_in_group</inline></reference>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-inside-tree"><inline classes="std std-ref">is_inside_tree</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-multiplayer-authority"><inline classes="std std-ref">is_multiplayer_authority</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-node-ready"><inline classes="std std-ref">is_node_ready</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-part-of-edited-scene"><inline classes="std std-ref">is_part_of_edited_scene</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-physics-interpolated"><inline classes="std std-ref">is_physics_interpolated</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-physics-interpolated-and-enabled"><inline classes="std std-ref">is_physics_interpolated_and_enabled</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-physics-processing"><inline classes="std std-ref">is_physics_processing</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-physics-processing-internal"><inline classes="std std-ref">is_physics_processing_internal</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-processing"><inline classes="std std-ref">is_processing</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-processing-input"><inline classes="std std-ref">is_processing_input</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-processing-internal"><inline classes="std std-ref">is_processing_internal</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-processing-shortcut-input"><inline classes="std std-ref">is_processing_shortcut_input</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-processing-unhandled-input"><inline classes="std std-ref">is_processing_unhandled_input</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-is-processing-unhandled-key-input"><inline classes="std std-ref">is_processing_unhandled_key_input</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-move-child"><inline classes="std std-ref">move_child</inline></reference>(child_node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>, to_index: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-notify-deferred-thread-group"><inline classes="std std-ref">notify_deferred_thread_group</inline></reference>(what: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-notify-thread-safe"><inline classes="std std-ref">notify_thread_safe</inline></reference>(what: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-print-orphan-nodes"><inline classes="std std-ref">print_orphan_nodes</inline></reference>() <abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-print-tree"><inline classes="std std-ref">print_tree</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-print-tree-pretty"><inline classes="std std-ref">print_tree_pretty</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-propagate-call"><inline classes="std std-ref">propagate_call</inline></reference>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, args: <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> = [], parent_first: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-propagate-notification"><inline classes="std std-ref">propagate_notification</inline></reference>(what: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-queue-accessibility-update"><inline classes="std std-ref">queue_accessibility_update</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-queue-free"><inline classes="std std-ref">queue_free</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-remove-child"><inline classes="std std-ref">remove_child</inline></reference>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-remove-from-group"><inline classes="std std-ref">remove_from_group</inline></reference>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-reparent"><inline classes="std std-ref">reparent</inline></reference>(new_parent: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>, keep_global_transform: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-replace-by"><inline classes="std std-ref">replace_by</inline></reference>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>, keep_groups: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-request-ready"><inline classes="std std-ref">request_ready</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-reset-physics-interpolation"><inline classes="std std-ref">reset_physics_interpolation</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-rpc"><inline classes="std std-ref">rpc</inline></reference>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-rpc-config"><inline classes="std std-ref">rpc_config</inline></reference>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, config: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-rpc-id"><inline classes="std std-ref">rpc_id</inline></reference>(peer_id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-deferred-thread-group"><inline classes="std std-ref">set_deferred_thread_group</inline></reference>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-display-folded"><inline classes="std std-ref">set_display_folded</inline></reference>(fold: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-editable-instance"><inline classes="std std-ref">set_editable_instance</inline></reference>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>, is_editable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-multiplayer-authority"><inline classes="std std-ref">set_multiplayer_authority</inline></reference>(id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, recursive: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-physics-process"><inline classes="std std-ref">set_physics_process</inline></reference>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-physics-process-internal"><inline classes="std std-ref">set_physics_process_internal</inline></reference>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-process"><inline classes="std std-ref">set_process</inline></reference>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-process-input"><inline classes="std std-ref">set_process_input</inline></reference>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-process-internal"><inline classes="std std-ref">set_process_internal</inline></reference>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-process-shortcut-input"><inline classes="std std-ref">set_process_shortcut_input</inline></reference>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-process-unhandled-input"><inline classes="std std-ref">set_process_unhandled_input</inline></reference>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-process-unhandled-key-input"><inline classes="std std-ref">set_process_unhandled_key_input</inline></reference>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-scene-instance-load-placeholder"><inline classes="std std-ref">set_scene_instance_load_placeholder</inline></reference>(load_placeholder: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-thread-safe"><inline classes="std std-ref">set_thread_safe</inline></reference>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-set-translation-domain-inherited"><inline classes="std std-ref">set_translation_domain_inherited</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="No return value.">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-node-method-update-configuration-warnings"><inline classes="std std-ref">update_configuration_warnings</inline></reference>()</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="signals" names="signals">
            <title>Signals</title>
            <target refid="class-node-signal-child-entered-tree"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-child-entered-tree" names="class_node_signal_child_entered_tree"><strong>child_entered_tree</strong>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>) <reference internal="True" refid="class-node-signal-child-entered-tree"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Emitted when the child <literal>node</literal> enters the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>, usually because this node entered the tree (see <reference internal="True" refid="class-node-signal-tree-entered"><inline classes="std std-ref">tree_entered</inline></reference>), or <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference> has been called.</paragraph>
            <paragraph>This signal is emitted <emphasis>after</emphasis> the child node's own <reference internal="True" refid="class-node-constant-notification-enter-tree"><inline classes="std std-ref">NOTIFICATION_ENTER_TREE</inline></reference> and <reference internal="True" refid="class-node-signal-tree-entered"><inline classes="std std-ref">tree_entered</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-child-exiting-tree"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-child-exiting-tree" names="class_node_signal_child_exiting_tree"><strong>child_exiting_tree</strong>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>) <reference internal="True" refid="class-node-signal-child-exiting-tree"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Emitted when the child <literal>node</literal> is about to exit the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>, usually because this node is exiting the tree (see <reference internal="True" refid="class-node-signal-tree-exiting"><inline classes="std std-ref">tree_exiting</inline></reference>), or because the child <literal>node</literal> is being removed or freed.</paragraph>
            <paragraph>When this signal is received, the child <literal>node</literal> is still accessible inside the tree. This signal is emitted <emphasis>after</emphasis> the child node's own <reference internal="True" refid="class-node-signal-tree-exiting"><inline classes="std std-ref">tree_exiting</inline></reference> and <reference internal="True" refid="class-node-constant-notification-exit-tree"><inline classes="std std-ref">NOTIFICATION_EXIT_TREE</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-child-order-changed"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-child-order-changed" names="class_node_signal_child_order_changed"><strong>child_order_changed</strong>() <reference internal="True" refid="class-node-signal-child-order-changed"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Emitted when the list of children is changed. This happens when child nodes are added, moved or removed.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-editor-description-changed"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-editor-description-changed" names="class_node_signal_editor_description_changed"><strong>editor_description_changed</strong>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>) <reference internal="True" refid="class-node-signal-editor-description-changed"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Emitted when the node's editor description field changed.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-editor-state-changed"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-editor-state-changed" names="class_node_signal_editor_state_changed"><strong>editor_state_changed</strong>() <reference internal="True" refid="class-node-signal-editor-state-changed"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Emitted when an attribute of the node that is relevant to the editor is changed. Only emitted in the editor.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-ready"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-ready" names="class_node_signal_ready"><strong>ready</strong>() <reference internal="True" refid="class-node-signal-ready"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Emitted when the node is considered ready, after <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> is called.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-renamed"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-renamed" names="class_node_signal_renamed"><strong>renamed</strong>() <reference internal="True" refid="class-node-signal-renamed"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Emitted when the node's <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference> is changed, if the node is inside the tree.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-replacing-by"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-replacing-by" names="class_node_signal_replacing_by"><strong>replacing_by</strong>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>) <reference internal="True" refid="class-node-signal-replacing-by"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Emitted when this node is being replaced by the <literal>node</literal>, see <reference internal="True" refid="class-node-method-replace-by"><inline classes="std std-ref">replace_by()</inline></reference>.</paragraph>
            <paragraph>This signal is emitted <emphasis>after</emphasis> <literal>node</literal> has been added as a child of the original parent node, but <emphasis>before</emphasis> all original child nodes have been reparented to <literal>node</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-tree-entered"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-tree-entered" names="class_node_signal_tree_entered"><strong>tree_entered</strong>() <reference internal="True" refid="class-node-signal-tree-entered"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Emitted when the node enters the tree.</paragraph>
            <paragraph>This signal is emitted <emphasis>after</emphasis> the related <reference internal="True" refid="class-node-constant-notification-enter-tree"><inline classes="std std-ref">NOTIFICATION_ENTER_TREE</inline></reference> notification.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-tree-exited"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-tree-exited" names="class_node_signal_tree_exited"><strong>tree_exited</strong>() <reference internal="True" refid="class-node-signal-tree-exited"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Emitted after the node exits the tree and is no longer active.</paragraph>
            <paragraph>This signal is emitted <emphasis>after</emphasis> the related <reference internal="True" refid="class-node-constant-notification-exit-tree"><inline classes="std std-ref">NOTIFICATION_EXIT_TREE</inline></reference> notification.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-signal-tree-exiting"></target>
            <paragraph classes="classref-signal" ids="class-node-signal-tree-exiting" names="class_node_signal_tree_exiting"><strong>tree_exiting</strong>() <reference internal="True" refid="class-node-signal-tree-exiting"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Emitted when the node is just about to exit the tree. The node is still valid. As such, this is the right place for de-initialization (or a "destructor", if you will).</paragraph>
            <paragraph>This signal is emitted <emphasis>after</emphasis> the node's <reference internal="True" refid="class-node-private-method-exit-tree"><inline classes="std std-ref">_exit_tree()</inline></reference>, and <emphasis>before</emphasis> the related <reference internal="True" refid="class-node-constant-notification-exit-tree"><inline classes="std std-ref">NOTIFICATION_EXIT_TREE</inline></reference>.</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="enumerations" names="enumerations">
            <title>Enumerations</title>
            <target refid="enum-node-processmode"></target>
            <paragraph classes="classref-enumeration" ids="enum-node-processmode" names="enum_node_processmode">enum <strong>ProcessMode</strong>: <reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref"></inline></reference></paragraph>
            <target refid="class-node-constant-process-mode-inherit"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-mode-inherit" names="class_node_constant_process_mode_inherit"><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> <strong>PROCESS_MODE_INHERIT</strong> = <literal>0</literal></paragraph>
            <paragraph>Inherits <reference internal="True" refid="class-node-property-process-mode"><inline classes="std std-ref">process_mode</inline></reference> from the node's parent. This is the default for any newly created node.</paragraph>
            <target refid="class-node-constant-process-mode-pausable"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-mode-pausable" names="class_node_constant_process_mode_pausable"><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> <strong>PROCESS_MODE_PAUSABLE</strong> = <literal>1</literal></paragraph>
            <paragraph>Stops processing when <reference internal="True" refuri="class_scenetree#class-scenetree-property-paused"><inline classes="std std-ref">SceneTree.paused</inline></reference> is <literal>true</literal>. This is the inverse of <reference internal="True" refid="class-node-constant-process-mode-when-paused"><inline classes="std std-ref">PROCESS_MODE_WHEN_PAUSED</inline></reference>, and the default for the root node.</paragraph>
            <target refid="class-node-constant-process-mode-when-paused"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-mode-when-paused" names="class_node_constant_process_mode_when_paused"><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> <strong>PROCESS_MODE_WHEN_PAUSED</strong> = <literal>2</literal></paragraph>
            <paragraph>Process <strong>only</strong> when <reference internal="True" refuri="class_scenetree#class-scenetree-property-paused"><inline classes="std std-ref">SceneTree.paused</inline></reference> is <literal>true</literal>. This is the inverse of <reference internal="True" refid="class-node-constant-process-mode-pausable"><inline classes="std std-ref">PROCESS_MODE_PAUSABLE</inline></reference>.</paragraph>
            <target refid="class-node-constant-process-mode-always"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-mode-always" names="class_node_constant_process_mode_always"><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> <strong>PROCESS_MODE_ALWAYS</strong> = <literal>3</literal></paragraph>
            <paragraph>Always process. Keeps processing, ignoring <reference internal="True" refuri="class_scenetree#class-scenetree-property-paused"><inline classes="std std-ref">SceneTree.paused</inline></reference>. This is the inverse of <reference internal="True" refid="class-node-constant-process-mode-disabled"><inline classes="std std-ref">PROCESS_MODE_DISABLED</inline></reference>.</paragraph>
            <target refid="class-node-constant-process-mode-disabled"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-mode-disabled" names="class_node_constant_process_mode_disabled"><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> <strong>PROCESS_MODE_DISABLED</strong> = <literal>4</literal></paragraph>
            <paragraph>Never process. Completely disables processing, ignoring <reference internal="True" refuri="class_scenetree#class-scenetree-property-paused"><inline classes="std std-ref">SceneTree.paused</inline></reference>. This is the inverse of <reference internal="True" refid="class-node-constant-process-mode-always"><inline classes="std std-ref">PROCESS_MODE_ALWAYS</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-node-processthreadgroup"></target>
            <paragraph classes="classref-enumeration" ids="enum-node-processthreadgroup" names="enum_node_processthreadgroup">enum <strong>ProcessThreadGroup</strong>: <reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref"></inline></reference></paragraph>
            <target refid="class-node-constant-process-thread-group-inherit"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-thread-group-inherit" names="class_node_constant_process_thread_group_inherit"><reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref">ProcessThreadGroup</inline></reference> <strong>PROCESS_THREAD_GROUP_INHERIT</strong> = <literal>0</literal></paragraph>
            <paragraph>Process this node based on the thread group mode of the first parent (or grandparent) node that has a thread group mode that is not inherit. See <reference internal="True" refid="class-node-property-process-thread-group"><inline classes="std std-ref">process_thread_group</inline></reference> for more information.</paragraph>
            <target refid="class-node-constant-process-thread-group-main-thread"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-thread-group-main-thread" names="class_node_constant_process_thread_group_main_thread"><reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref">ProcessThreadGroup</inline></reference> <strong>PROCESS_THREAD_GROUP_MAIN_THREAD</strong> = <literal>1</literal></paragraph>
            <paragraph>Process this node (and child nodes set to inherit) on the main thread. See <reference internal="True" refid="class-node-property-process-thread-group"><inline classes="std std-ref">process_thread_group</inline></reference> for more information.</paragraph>
            <target refid="class-node-constant-process-thread-group-sub-thread"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-process-thread-group-sub-thread" names="class_node_constant_process_thread_group_sub_thread"><reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref">ProcessThreadGroup</inline></reference> <strong>PROCESS_THREAD_GROUP_SUB_THREAD</strong> = <literal>2</literal></paragraph>
            <paragraph>Process this node (and child nodes set to inherit) on a sub-thread. See <reference internal="True" refid="class-node-property-process-thread-group"><inline classes="std std-ref">process_thread_group</inline></reference> for more information.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-node-processthreadmessages"></target>
            <paragraph classes="classref-enumeration" ids="enum-node-processthreadmessages" names="enum_node_processthreadmessages">flags <strong>ProcessThreadMessages</strong>: <reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref"></inline></reference></paragraph>
            <target refid="class-node-constant-flag-process-thread-messages"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-flag-process-thread-messages" names="class_node_constant_flag_process_thread_messages"><reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref">ProcessThreadMessages</inline></reference> <strong>FLAG_PROCESS_THREAD_MESSAGES</strong> = <literal>1</literal></paragraph>
            <paragraph>Allows this node to process threaded messages created with <reference internal="True" refid="class-node-method-call-deferred-thread-group"><inline classes="std std-ref">call_deferred_thread_group()</inline></reference> right before <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference> is called.</paragraph>
            <target refid="class-node-constant-flag-process-thread-messages-physics"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-flag-process-thread-messages-physics" names="class_node_constant_flag_process_thread_messages_physics"><reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref">ProcessThreadMessages</inline></reference> <strong>FLAG_PROCESS_THREAD_MESSAGES_PHYSICS</strong> = <literal>2</literal></paragraph>
            <paragraph>Allows this node to process threaded messages created with <reference internal="True" refid="class-node-method-call-deferred-thread-group"><inline classes="std std-ref">call_deferred_thread_group()</inline></reference> right before <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference> is called.</paragraph>
            <target refid="class-node-constant-flag-process-thread-messages-all"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-flag-process-thread-messages-all" names="class_node_constant_flag_process_thread_messages_all"><reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref">ProcessThreadMessages</inline></reference> <strong>FLAG_PROCESS_THREAD_MESSAGES_ALL</strong> = <literal>3</literal></paragraph>
            <paragraph>Allows this node to process threaded messages created with <reference internal="True" refid="class-node-method-call-deferred-thread-group"><inline classes="std std-ref">call_deferred_thread_group()</inline></reference> right before either <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference> or <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference> are called.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-node-physicsinterpolationmode"></target>
            <paragraph classes="classref-enumeration" ids="enum-node-physicsinterpolationmode" names="enum_node_physicsinterpolationmode">enum <strong>PhysicsInterpolationMode</strong>: <reference internal="True" refid="enum-node-physicsinterpolationmode"><inline classes="std std-ref"></inline></reference></paragraph>
            <target refid="class-node-constant-physics-interpolation-mode-inherit"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-physics-interpolation-mode-inherit" names="class_node_constant_physics_interpolation_mode_inherit"><reference internal="True" refid="enum-node-physicsinterpolationmode"><inline classes="std std-ref">PhysicsInterpolationMode</inline></reference> <strong>PHYSICS_INTERPOLATION_MODE_INHERIT</strong> = <literal>0</literal></paragraph>
            <paragraph>Inherits <reference internal="True" refid="class-node-property-physics-interpolation-mode"><inline classes="std std-ref">physics_interpolation_mode</inline></reference> from the node's parent. This is the default for any newly created node.</paragraph>
            <target refid="class-node-constant-physics-interpolation-mode-on"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-physics-interpolation-mode-on" names="class_node_constant_physics_interpolation_mode_on"><reference internal="True" refid="enum-node-physicsinterpolationmode"><inline classes="std std-ref">PhysicsInterpolationMode</inline></reference> <strong>PHYSICS_INTERPOLATION_MODE_ON</strong> = <literal>1</literal></paragraph>
            <paragraph>Enables physics interpolation for this node and for children set to <reference internal="True" refid="class-node-constant-physics-interpolation-mode-inherit"><inline classes="std std-ref">PHYSICS_INTERPOLATION_MODE_INHERIT</inline></reference>. This is the default for the root node.</paragraph>
            <target refid="class-node-constant-physics-interpolation-mode-off"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-physics-interpolation-mode-off" names="class_node_constant_physics_interpolation_mode_off"><reference internal="True" refid="enum-node-physicsinterpolationmode"><inline classes="std std-ref">PhysicsInterpolationMode</inline></reference> <strong>PHYSICS_INTERPOLATION_MODE_OFF</strong> = <literal>2</literal></paragraph>
            <paragraph>Disables physics interpolation for this node and for children set to <reference internal="True" refid="class-node-constant-physics-interpolation-mode-inherit"><inline classes="std std-ref">PHYSICS_INTERPOLATION_MODE_INHERIT</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-node-duplicateflags"></target>
            <paragraph classes="classref-enumeration" ids="enum-node-duplicateflags" names="enum_node_duplicateflags">enum <strong>DuplicateFlags</strong>: <reference internal="True" refid="enum-node-duplicateflags"><inline classes="std std-ref"></inline></reference></paragraph>
            <target refid="class-node-constant-duplicate-signals"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-duplicate-signals" names="class_node_constant_duplicate_signals"><reference internal="True" refid="enum-node-duplicateflags"><inline classes="std std-ref">DuplicateFlags</inline></reference> <strong>DUPLICATE_SIGNALS</strong> = <literal>1</literal></paragraph>
            <paragraph>Duplicate the node's signal connections that are connected with the <reference internal="True" refuri="class_object#class-object-constant-connect-persist"><inline classes="std std-ref">Object.CONNECT_PERSIST</inline></reference> flag.</paragraph>
            <target refid="class-node-constant-duplicate-groups"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-duplicate-groups" names="class_node_constant_duplicate_groups"><reference internal="True" refid="enum-node-duplicateflags"><inline classes="std std-ref">DuplicateFlags</inline></reference> <strong>DUPLICATE_GROUPS</strong> = <literal>2</literal></paragraph>
            <paragraph>Duplicate the node's groups.</paragraph>
            <target refid="class-node-constant-duplicate-scripts"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-duplicate-scripts" names="class_node_constant_duplicate_scripts"><reference internal="True" refid="enum-node-duplicateflags"><inline classes="std std-ref">DuplicateFlags</inline></reference> <strong>DUPLICATE_SCRIPTS</strong> = <literal>4</literal></paragraph>
            <paragraph>Duplicate the node's script (also overriding the duplicated children's scripts, if combined with <reference internal="True" refid="class-node-constant-duplicate-use-instantiation"><inline classes="std std-ref">DUPLICATE_USE_INSTANTIATION</inline></reference>).</paragraph>
            <target refid="class-node-constant-duplicate-use-instantiation"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-duplicate-use-instantiation" names="class_node_constant_duplicate_use_instantiation"><reference internal="True" refid="enum-node-duplicateflags"><inline classes="std std-ref">DuplicateFlags</inline></reference> <strong>DUPLICATE_USE_INSTANTIATION</strong> = <literal>8</literal></paragraph>
            <paragraph>Duplicate using <reference internal="True" refuri="class_packedscene#class-packedscene-method-instantiate"><inline classes="std std-ref">PackedScene.instantiate()</inline></reference>. If the node comes from a scene saved on disk, reuses <reference internal="True" refuri="class_packedscene#class-packedscene-method-instantiate"><inline classes="std std-ref">PackedScene.instantiate()</inline></reference> as the base for the duplicated node and its children.</paragraph>
            <target refid="class-node-constant-duplicate-internal-state"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-duplicate-internal-state" names="class_node_constant_duplicate_internal_state"><reference internal="True" refid="enum-node-duplicateflags"><inline classes="std std-ref">DuplicateFlags</inline></reference> <strong>DUPLICATE_INTERNAL_STATE</strong> = <literal>16</literal></paragraph>
            <paragraph>Duplicate also non-serializable variables (i.e. without <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-property-usage-storage"><inline classes="std std-ref">@GlobalScope.PROPERTY_USAGE_STORAGE</inline></reference>).</paragraph>
            <target refid="class-node-constant-duplicate-default"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-duplicate-default" names="class_node_constant_duplicate_default"><reference internal="True" refid="enum-node-duplicateflags"><inline classes="std std-ref">DuplicateFlags</inline></reference> <strong>DUPLICATE_DEFAULT</strong> = <literal>15</literal></paragraph>
            <paragraph>Duplicate using default flags. This constant is useful to add or remove a single flag.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Duplicate non-exported variables.
var dupe = duplicate(DUPLICATE_DEFAULT | DUPLICATE_INTERNAL_STATE)</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-node-internalmode"></target>
            <paragraph classes="classref-enumeration" ids="enum-node-internalmode" names="enum_node_internalmode">enum <strong>InternalMode</strong>: <reference internal="True" refid="enum-node-internalmode"><inline classes="std std-ref"></inline></reference></paragraph>
            <target refid="class-node-constant-internal-mode-disabled"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-internal-mode-disabled" names="class_node_constant_internal_mode_disabled"><reference internal="True" refid="enum-node-internalmode"><inline classes="std std-ref">InternalMode</inline></reference> <strong>INTERNAL_MODE_DISABLED</strong> = <literal>0</literal></paragraph>
            <paragraph>The node will not be internal.</paragraph>
            <target refid="class-node-constant-internal-mode-front"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-internal-mode-front" names="class_node_constant_internal_mode_front"><reference internal="True" refid="enum-node-internalmode"><inline classes="std std-ref">InternalMode</inline></reference> <strong>INTERNAL_MODE_FRONT</strong> = <literal>1</literal></paragraph>
            <paragraph>The node will be placed at the beginning of the parent's children, before any non-internal sibling.</paragraph>
            <target refid="class-node-constant-internal-mode-back"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-internal-mode-back" names="class_node_constant_internal_mode_back"><reference internal="True" refid="enum-node-internalmode"><inline classes="std std-ref">InternalMode</inline></reference> <strong>INTERNAL_MODE_BACK</strong> = <literal>2</literal></paragraph>
            <paragraph>The node will be placed at the end of the parent's children, after any non-internal sibling.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="enum-node-autotranslatemode"></target>
            <paragraph classes="classref-enumeration" ids="enum-node-autotranslatemode" names="enum_node_autotranslatemode">enum <strong>AutoTranslateMode</strong>: <reference internal="True" refid="enum-node-autotranslatemode"><inline classes="std std-ref"></inline></reference></paragraph>
            <target refid="class-node-constant-auto-translate-mode-inherit"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-auto-translate-mode-inherit" names="class_node_constant_auto_translate_mode_inherit"><reference internal="True" refid="enum-node-autotranslatemode"><inline classes="std std-ref">AutoTranslateMode</inline></reference> <strong>AUTO_TRANSLATE_MODE_INHERIT</strong> = <literal>0</literal></paragraph>
            <paragraph>Inherits <reference internal="True" refid="class-node-property-auto-translate-mode"><inline classes="std std-ref">auto_translate_mode</inline></reference> from the node's parent. This is the default for any newly created node.</paragraph>
            <target refid="class-node-constant-auto-translate-mode-always"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-auto-translate-mode-always" names="class_node_constant_auto_translate_mode_always"><reference internal="True" refid="enum-node-autotranslatemode"><inline classes="std std-ref">AutoTranslateMode</inline></reference> <strong>AUTO_TRANSLATE_MODE_ALWAYS</strong> = <literal>1</literal></paragraph>
            <paragraph>Always automatically translate. This is the inverse of <reference internal="True" refid="class-node-constant-auto-translate-mode-disabled"><inline classes="std std-ref">AUTO_TRANSLATE_MODE_DISABLED</inline></reference>, and the default for the root node.</paragraph>
            <target refid="class-node-constant-auto-translate-mode-disabled"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-node-constant-auto-translate-mode-disabled" names="class_node_constant_auto_translate_mode_disabled"><reference internal="True" refid="enum-node-autotranslatemode"><inline classes="std std-ref">AutoTranslateMode</inline></reference> <strong>AUTO_TRANSLATE_MODE_DISABLED</strong> = <literal>2</literal></paragraph>
            <paragraph>Never automatically translate. This is the inverse of <reference internal="True" refid="class-node-constant-auto-translate-mode-always"><inline classes="std std-ref">AUTO_TRANSLATE_MODE_ALWAYS</inline></reference>.</paragraph>
            <paragraph>String parsing for translation template generation will be skipped for this node and children that are set to <reference internal="True" refid="class-node-constant-auto-translate-mode-inherit"><inline classes="std std-ref">AUTO_TRANSLATE_MODE_INHERIT</inline></reference>.</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="constants" names="constants">
            <title>Constants</title>
            <target refid="class-node-constant-notification-enter-tree"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-enter-tree" names="class_node_constant_notification_enter_tree"><strong>NOTIFICATION_ENTER_TREE</strong> = <literal>10</literal> <reference internal="True" refid="class-node-constant-notification-enter-tree"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the node enters a <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>. See <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree()</inline></reference>.</paragraph>
            <paragraph>This notification is received <emphasis>before</emphasis> the related <reference internal="True" refid="class-node-signal-tree-entered"><inline classes="std std-ref">tree_entered</inline></reference> signal.</paragraph>
            <target refid="class-node-constant-notification-exit-tree"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-exit-tree" names="class_node_constant_notification_exit_tree"><strong>NOTIFICATION_EXIT_TREE</strong> = <literal>11</literal> <reference internal="True" refid="class-node-constant-notification-exit-tree"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the node is about to exit a <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>. See <reference internal="True" refid="class-node-private-method-exit-tree"><inline classes="std std-ref">_exit_tree()</inline></reference>.</paragraph>
            <paragraph>This notification is received <emphasis>after</emphasis> the related <reference internal="True" refid="class-node-signal-tree-exiting"><inline classes="std std-ref">tree_exiting</inline></reference> signal.</paragraph>
            <paragraph>This notification is sent in reversed order.</paragraph>
            <target refid="class-node-constant-notification-moved-in-parent"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-moved-in-parent" names="class_node_constant_notification_moved_in_parent"><strong>NOTIFICATION_MOVED_IN_PARENT</strong> = <literal>12</literal> <reference internal="True" refid="class-node-constant-notification-moved-in-parent"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph><strong>Deprecated:</strong> This notification is no longer sent by the engine. Use <reference internal="True" refid="class-node-constant-notification-child-order-changed"><inline classes="std std-ref">NOTIFICATION_CHILD_ORDER_CHANGED</inline></reference> instead.</paragraph>
            <target refid="class-node-constant-notification-ready"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-ready" names="class_node_constant_notification_ready"><strong>NOTIFICATION_READY</strong> = <literal>13</literal> <reference internal="True" refid="class-node-constant-notification-ready"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the node is ready. See <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference>.</paragraph>
            <target refid="class-node-constant-notification-paused"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-paused" names="class_node_constant_notification_paused"><strong>NOTIFICATION_PAUSED</strong> = <literal>14</literal> <reference internal="True" refid="class-node-constant-notification-paused"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the node is paused. See <reference internal="True" refid="class-node-property-process-mode"><inline classes="std std-ref">process_mode</inline></reference>.</paragraph>
            <target refid="class-node-constant-notification-unpaused"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-unpaused" names="class_node_constant_notification_unpaused"><strong>NOTIFICATION_UNPAUSED</strong> = <literal>15</literal> <reference internal="True" refid="class-node-constant-notification-unpaused"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the node is unpaused. See <reference internal="True" refid="class-node-property-process-mode"><inline classes="std std-ref">process_mode</inline></reference>.</paragraph>
            <target refid="class-node-constant-notification-physics-process"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-physics-process" names="class_node_constant_notification_physics_process"><strong>NOTIFICATION_PHYSICS_PROCESS</strong> = <literal>16</literal> <reference internal="True" refid="class-node-constant-notification-physics-process"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the tree every physics frame when <reference internal="True" refid="class-node-method-is-physics-processing"><inline classes="std std-ref">is_physics_processing()</inline></reference> returns <literal>true</literal>. See <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference>.</paragraph>
            <target refid="class-node-constant-notification-process"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-process" names="class_node_constant_notification_process"><strong>NOTIFICATION_PROCESS</strong> = <literal>17</literal> <reference internal="True" refid="class-node-constant-notification-process"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the tree every rendered frame when <reference internal="True" refid="class-node-method-is-processing"><inline classes="std std-ref">is_processing()</inline></reference> returns <literal>true</literal>. See <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference>.</paragraph>
            <target refid="class-node-constant-notification-parented"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-parented" names="class_node_constant_notification_parented"><strong>NOTIFICATION_PARENTED</strong> = <literal>18</literal> <reference internal="True" refid="class-node-constant-notification-parented"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the node is set as a child of another node (see <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference> and <reference internal="True" refid="class-node-method-add-sibling"><inline classes="std std-ref">add_sibling()</inline></reference>).</paragraph>
            <paragraph><strong>Note:</strong> This does <emphasis>not</emphasis> mean that the node entered the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.</paragraph>
            <target refid="class-node-constant-notification-unparented"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-unparented" names="class_node_constant_notification_unparented"><strong>NOTIFICATION_UNPARENTED</strong> = <literal>19</literal> <reference internal="True" refid="class-node-constant-notification-unparented"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the parent node calls <reference internal="True" refid="class-node-method-remove-child"><inline classes="std std-ref">remove_child()</inline></reference> on this node.</paragraph>
            <paragraph><strong>Note:</strong> This does <emphasis>not</emphasis> mean that the node exited the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.</paragraph>
            <target refid="class-node-constant-notification-scene-instantiated"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-scene-instantiated" names="class_node_constant_notification_scene_instantiated"><strong>NOTIFICATION_SCENE_INSTANTIATED</strong> = <literal>20</literal> <reference internal="True" refid="class-node-constant-notification-scene-instantiated"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received <emphasis>only</emphasis> by the newly instantiated scene root node, when <reference internal="True" refuri="class_packedscene#class-packedscene-method-instantiate"><inline classes="std std-ref">PackedScene.instantiate()</inline></reference> is completed.</paragraph>
            <target refid="class-node-constant-notification-drag-begin"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-drag-begin" names="class_node_constant_notification_drag_begin"><strong>NOTIFICATION_DRAG_BEGIN</strong> = <literal>21</literal> <reference internal="True" refid="class-node-constant-notification-drag-begin"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when a drag operation begins. All nodes receive this notification, not only the dragged one.</paragraph>
            <paragraph>Can be triggered either by dragging a <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> that provides drag data (see <reference internal="True" refuri="class_control#class-control-private-method-get-drag-data"><inline classes="std std-ref">Control._get_drag_data()</inline></reference>) or using <reference internal="True" refuri="class_control#class-control-method-force-drag"><inline classes="std std-ref">Control.force_drag()</inline></reference>.</paragraph>
            <paragraph>Use <reference internal="True" refuri="class_viewport#class-viewport-method-gui-get-drag-data"><inline classes="std std-ref">Viewport.gui_get_drag_data()</inline></reference> to get the dragged data.</paragraph>
            <target refid="class-node-constant-notification-drag-end"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-drag-end" names="class_node_constant_notification_drag_end"><strong>NOTIFICATION_DRAG_END</strong> = <literal>22</literal> <reference internal="True" refid="class-node-constant-notification-drag-end"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when a drag operation ends.</paragraph>
            <paragraph>Use <reference internal="True" refuri="class_viewport#class-viewport-method-gui-is-drag-successful"><inline classes="std std-ref">Viewport.gui_is_drag_successful()</inline></reference> to check if the drag succeeded.</paragraph>
            <target refid="class-node-constant-notification-path-renamed"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-path-renamed" names="class_node_constant_notification_path_renamed"><strong>NOTIFICATION_PATH_RENAMED</strong> = <literal>23</literal> <reference internal="True" refid="class-node-constant-notification-path-renamed"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the node's <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference> or one of its ancestors' <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference> is changed. This notification is <emphasis>not</emphasis> received when the node is removed from the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.</paragraph>
            <target refid="class-node-constant-notification-child-order-changed"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-child-order-changed" names="class_node_constant_notification_child_order_changed"><strong>NOTIFICATION_CHILD_ORDER_CHANGED</strong> = <literal>24</literal> <reference internal="True" refid="class-node-constant-notification-child-order-changed"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the list of children is changed. This happens when child nodes are added, moved or removed.</paragraph>
            <target refid="class-node-constant-notification-internal-process"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-internal-process" names="class_node_constant_notification_internal_process"><strong>NOTIFICATION_INTERNAL_PROCESS</strong> = <literal>25</literal> <reference internal="True" refid="class-node-constant-notification-internal-process"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the tree every rendered frame when <reference internal="True" refid="class-node-method-is-processing-internal"><inline classes="std std-ref">is_processing_internal()</inline></reference> returns <literal>true</literal>.</paragraph>
            <target refid="class-node-constant-notification-internal-physics-process"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-internal-physics-process" names="class_node_constant_notification_internal_physics_process"><strong>NOTIFICATION_INTERNAL_PHYSICS_PROCESS</strong> = <literal>26</literal> <reference internal="True" refid="class-node-constant-notification-internal-physics-process"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the tree every physics frame when <reference internal="True" refid="class-node-method-is-physics-processing-internal"><inline classes="std std-ref">is_physics_processing_internal()</inline></reference> returns <literal>true</literal>.</paragraph>
            <target refid="class-node-constant-notification-post-enter-tree"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-post-enter-tree" names="class_node_constant_notification_post_enter_tree"><strong>NOTIFICATION_POST_ENTER_TREE</strong> = <literal>27</literal> <reference internal="True" refid="class-node-constant-notification-post-enter-tree"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the node enters the tree, just before <reference internal="True" refid="class-node-constant-notification-ready"><inline classes="std std-ref">NOTIFICATION_READY</inline></reference> may be received. Unlike the latter, it is sent every time the node enters tree, not just once.</paragraph>
            <target refid="class-node-constant-notification-disabled"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-disabled" names="class_node_constant_notification_disabled"><strong>NOTIFICATION_DISABLED</strong> = <literal>28</literal> <reference internal="True" refid="class-node-constant-notification-disabled"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the node is disabled. See <reference internal="True" refid="class-node-constant-process-mode-disabled"><inline classes="std std-ref">PROCESS_MODE_DISABLED</inline></reference>.</paragraph>
            <target refid="class-node-constant-notification-enabled"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-enabled" names="class_node_constant_notification_enabled"><strong>NOTIFICATION_ENABLED</strong> = <literal>29</literal> <reference internal="True" refid="class-node-constant-notification-enabled"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the node is enabled again after being disabled. See <reference internal="True" refid="class-node-constant-process-mode-disabled"><inline classes="std std-ref">PROCESS_MODE_DISABLED</inline></reference>.</paragraph>
            <target refid="class-node-constant-notification-reset-physics-interpolation"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-reset-physics-interpolation" names="class_node_constant_notification_reset_physics_interpolation"><strong>NOTIFICATION_RESET_PHYSICS_INTERPOLATION</strong> = <literal>2001</literal> <reference internal="True" refid="class-node-constant-notification-reset-physics-interpolation"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when <reference internal="True" refid="class-node-method-reset-physics-interpolation"><inline classes="std std-ref">reset_physics_interpolation()</inline></reference> is called on the node or its ancestors.</paragraph>
            <target refid="class-node-constant-notification-editor-pre-save"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-editor-pre-save" names="class_node_constant_notification_editor_pre_save"><strong>NOTIFICATION_EDITOR_PRE_SAVE</strong> = <literal>9001</literal> <reference internal="True" refid="class-node-constant-notification-editor-pre-save"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received right before the scene with the node is saved in the editor. This notification is only sent in the Godot editor and will not occur in exported projects.</paragraph>
            <target refid="class-node-constant-notification-editor-post-save"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-editor-post-save" names="class_node_constant_notification_editor_post_save"><strong>NOTIFICATION_EDITOR_POST_SAVE</strong> = <literal>9002</literal> <reference internal="True" refid="class-node-constant-notification-editor-post-save"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received right after the scene with the node is saved in the editor. This notification is only sent in the Godot editor and will not occur in exported projects.</paragraph>
            <target refid="class-node-constant-notification-wm-mouse-enter"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-mouse-enter" names="class_node_constant_notification_wm_mouse_enter"><strong>NOTIFICATION_WM_MOUSE_ENTER</strong> = <literal>1002</literal> <reference internal="True" refid="class-node-constant-notification-wm-mouse-enter"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the mouse enters the window.</paragraph>
            <paragraph>Implemented for embedded windows and on desktop and web platforms.</paragraph>
            <target refid="class-node-constant-notification-wm-mouse-exit"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-mouse-exit" names="class_node_constant_notification_wm_mouse_exit"><strong>NOTIFICATION_WM_MOUSE_EXIT</strong> = <literal>1003</literal> <reference internal="True" refid="class-node-constant-notification-wm-mouse-exit"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the mouse leaves the window.</paragraph>
            <paragraph>Implemented for embedded windows and on desktop and web platforms.</paragraph>
            <target refid="class-node-constant-notification-wm-window-focus-in"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-window-focus-in" names="class_node_constant_notification_wm_window_focus_in"><strong>NOTIFICATION_WM_WINDOW_FOCUS_IN</strong> = <literal>1004</literal> <reference internal="True" refid="class-node-constant-notification-wm-window-focus-in"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the OS when the node's <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> ancestor is focused. This may be a change of focus between two windows of the same engine instance, or from the OS desktop or a third-party application to a window of the game (in which case <reference internal="True" refid="class-node-constant-notification-application-focus-in"><inline classes="std std-ref">NOTIFICATION_APPLICATION_FOCUS_IN</inline></reference> is also received).</paragraph>
            <paragraph>A <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> node receives this notification when it is focused.</paragraph>
            <target refid="class-node-constant-notification-wm-window-focus-out"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-window-focus-out" names="class_node_constant_notification_wm_window_focus_out"><strong>NOTIFICATION_WM_WINDOW_FOCUS_OUT</strong> = <literal>1005</literal> <reference internal="True" refid="class-node-constant-notification-wm-window-focus-out"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the OS when the node's <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> ancestor is defocused. This may be a change of focus between two windows of the same engine instance, or from a window of the game to the OS desktop or a third-party application (in which case <reference internal="True" refid="class-node-constant-notification-application-focus-out"><inline classes="std std-ref">NOTIFICATION_APPLICATION_FOCUS_OUT</inline></reference> is also received).</paragraph>
            <paragraph>A <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> node receives this notification when it is defocused.</paragraph>
            <target refid="class-node-constant-notification-wm-close-request"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-close-request" names="class_node_constant_notification_wm_close_request"><strong>NOTIFICATION_WM_CLOSE_REQUEST</strong> = <literal>1006</literal> <reference internal="True" refid="class-node-constant-notification-wm-close-request"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the OS when a close request is sent (e.g. closing the window with a "Close" button or <literal classes="kbd">Alt + F4</literal>).</paragraph>
            <paragraph>Implemented on desktop platforms.</paragraph>
            <target refid="class-node-constant-notification-wm-go-back-request"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-go-back-request" names="class_node_constant_notification_wm_go_back_request"><strong>NOTIFICATION_WM_GO_BACK_REQUEST</strong> = <literal>1007</literal> <reference internal="True" refid="class-node-constant-notification-wm-go-back-request"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the OS when a go back request is sent (e.g. pressing the "Back" button on Android).</paragraph>
            <paragraph>Implemented only on Android.</paragraph>
            <target refid="class-node-constant-notification-wm-size-changed"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-size-changed" names="class_node_constant_notification_wm_size_changed"><strong>NOTIFICATION_WM_SIZE_CHANGED</strong> = <literal>1008</literal> <reference internal="True" refid="class-node-constant-notification-wm-size-changed"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the window is resized.</paragraph>
            <paragraph><strong>Note:</strong> Only the resized <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> node receives this notification, and it's not propagated to the child nodes.</paragraph>
            <target refid="class-node-constant-notification-wm-dpi-change"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-dpi-change" names="class_node_constant_notification_wm_dpi_change"><strong>NOTIFICATION_WM_DPI_CHANGE</strong> = <literal>1009</literal> <reference internal="True" refid="class-node-constant-notification-wm-dpi-change"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the OS when the screen's dots per inch (DPI) scale is changed. Only implemented on macOS.</paragraph>
            <target refid="class-node-constant-notification-vp-mouse-enter"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-vp-mouse-enter" names="class_node_constant_notification_vp_mouse_enter"><strong>NOTIFICATION_VP_MOUSE_ENTER</strong> = <literal>1010</literal> <reference internal="True" refid="class-node-constant-notification-vp-mouse-enter"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the mouse cursor enters the <reference internal="True" refuri="class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>'s visible area, that is not occluded behind other <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference>s or <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference>s, provided its <reference internal="True" refuri="class_viewport#class-viewport-property-gui-disable-input"><inline classes="std std-ref">Viewport.gui_disable_input</inline></reference> is <literal>false</literal> and regardless if it's currently focused or not.</paragraph>
            <target refid="class-node-constant-notification-vp-mouse-exit"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-vp-mouse-exit" names="class_node_constant_notification_vp_mouse_exit"><strong>NOTIFICATION_VP_MOUSE_EXIT</strong> = <literal>1011</literal> <reference internal="True" refid="class-node-constant-notification-vp-mouse-exit"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the mouse cursor leaves the <reference internal="True" refuri="class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>'s visible area, that is not occluded behind other <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference>s or <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference>s, provided its <reference internal="True" refuri="class_viewport#class-viewport-property-gui-disable-input"><inline classes="std std-ref">Viewport.gui_disable_input</inline></reference> is <literal>false</literal> and regardless if it's currently focused or not.</paragraph>
            <target refid="class-node-constant-notification-wm-position-changed"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-position-changed" names="class_node_constant_notification_wm_position_changed"><strong>NOTIFICATION_WM_POSITION_CHANGED</strong> = <literal>1012</literal> <reference internal="True" refid="class-node-constant-notification-wm-position-changed"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the window is moved.</paragraph>
            <target refid="class-node-constant-notification-os-memory-warning"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-os-memory-warning" names="class_node_constant_notification_os_memory_warning"><strong>NOTIFICATION_OS_MEMORY_WARNING</strong> = <literal>2009</literal> <reference internal="True" refid="class-node-constant-notification-os-memory-warning"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the OS when the application is exceeding its allocated memory.</paragraph>
            <paragraph>Implemented only on iOS.</paragraph>
            <target refid="class-node-constant-notification-translation-changed"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-translation-changed" names="class_node_constant_notification_translation_changed"><strong>NOTIFICATION_TRANSLATION_CHANGED</strong> = <literal>2010</literal> <reference internal="True" refid="class-node-constant-notification-translation-changed"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when translations may have changed. Can be triggered by the user changing the locale, changing <reference internal="True" refid="class-node-property-auto-translate-mode"><inline classes="std std-ref">auto_translate_mode</inline></reference> or when the node enters the scene tree. Can be used to respond to language changes, for example to change the UI strings on the fly. Useful when working with the built-in translation support, like <reference internal="True" refuri="class_object#class-object-method-tr"><inline classes="std std-ref">Object.tr()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This notification is received alongside <reference internal="True" refid="class-node-constant-notification-enter-tree"><inline classes="std std-ref">NOTIFICATION_ENTER_TREE</inline></reference>, so if you are instantiating a scene, the child nodes will not be initialized yet. You can use it to setup translations for this node, child nodes created from script, or if you want to access child nodes added in the editor, make sure the node is ready using <reference internal="True" refid="class-node-method-is-node-ready"><inline classes="std std-ref">is_node_ready()</inline></reference>.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _notification(what):
    if what == NOTIFICATION_TRANSLATION_CHANGED:
        if not is_node_ready():
            await ready # Wait until ready signal.
        $Label.text = atr("%d Bananas") % banana_counter</literal_block>
            <target refid="class-node-constant-notification-wm-about"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-wm-about" names="class_node_constant_notification_wm_about"><strong>NOTIFICATION_WM_ABOUT</strong> = <literal>2011</literal> <reference internal="True" refid="class-node-constant-notification-wm-about"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the OS when a request for "About" information is sent.</paragraph>
            <paragraph>Implemented only on macOS.</paragraph>
            <target refid="class-node-constant-notification-crash"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-crash" names="class_node_constant_notification_crash"><strong>NOTIFICATION_CRASH</strong> = <literal>2012</literal> <reference internal="True" refid="class-node-constant-notification-crash"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from Godot's crash handler when the engine is about to crash.</paragraph>
            <paragraph>Implemented on desktop platforms, if the crash handler is enabled.</paragraph>
            <target refid="class-node-constant-notification-os-ime-update"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-os-ime-update" names="class_node_constant_notification_os_ime_update"><strong>NOTIFICATION_OS_IME_UPDATE</strong> = <literal>2013</literal> <reference internal="True" refid="class-node-constant-notification-os-ime-update"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the OS when an update of the Input Method Engine occurs (e.g. change of IME cursor position or composition string).</paragraph>
            <paragraph>Implemented on desktop and web platforms.</paragraph>
            <target refid="class-node-constant-notification-application-resumed"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-application-resumed" names="class_node_constant_notification_application_resumed"><strong>NOTIFICATION_APPLICATION_RESUMED</strong> = <literal>2014</literal> <reference internal="True" refid="class-node-constant-notification-application-resumed"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the OS when the application is resumed.</paragraph>
            <paragraph>Specific to the Android and iOS platforms.</paragraph>
            <target refid="class-node-constant-notification-application-paused"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-application-paused" names="class_node_constant_notification_application_paused"><strong>NOTIFICATION_APPLICATION_PAUSED</strong> = <literal>2015</literal> <reference internal="True" refid="class-node-constant-notification-application-paused"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the OS when the application is paused.</paragraph>
            <paragraph>Specific to the Android and iOS platforms.</paragraph>
            <paragraph><strong>Note:</strong> On iOS, you only have approximately 5 seconds to finish a task started by this signal. If you go over this allotment, iOS will kill the app instead of pausing it.</paragraph>
            <target refid="class-node-constant-notification-application-focus-in"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-application-focus-in" names="class_node_constant_notification_application_focus_in"><strong>NOTIFICATION_APPLICATION_FOCUS_IN</strong> = <literal>2016</literal> <reference internal="True" refid="class-node-constant-notification-application-focus-in"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the OS when the application is focused, i.e. when changing the focus from the OS desktop or a thirdparty application to any open window of the Godot instance.</paragraph>
            <paragraph>Implemented on desktop and mobile platforms.</paragraph>
            <target refid="class-node-constant-notification-application-focus-out"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-application-focus-out" names="class_node_constant_notification_application_focus_out"><strong>NOTIFICATION_APPLICATION_FOCUS_OUT</strong> = <literal>2017</literal> <reference internal="True" refid="class-node-constant-notification-application-focus-out"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received from the OS when the application is defocused, i.e. when changing the focus from any open window of the Godot instance to the OS desktop or a thirdparty application.</paragraph>
            <paragraph>Implemented on desktop and mobile platforms.</paragraph>
            <target refid="class-node-constant-notification-text-server-changed"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-text-server-changed" names="class_node_constant_notification_text_server_changed"><strong>NOTIFICATION_TEXT_SERVER_CHANGED</strong> = <literal>2018</literal> <reference internal="True" refid="class-node-constant-notification-text-server-changed"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when the <reference internal="True" refuri="class_textserver#class-textserver"><inline classes="std std-ref">TextServer</inline></reference> is changed.</paragraph>
            <target refid="class-node-constant-notification-accessibility-update"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-accessibility-update" names="class_node_constant_notification_accessibility_update"><strong>NOTIFICATION_ACCESSIBILITY_UPDATE</strong> = <literal>3000</literal> <reference internal="True" refid="class-node-constant-notification-accessibility-update"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when an accessibility information update is required.</paragraph>
            <target refid="class-node-constant-notification-accessibility-invalidate"></target>
            <paragraph classes="classref-constant" ids="class-node-constant-notification-accessibility-invalidate" names="class_node_constant_notification_accessibility_invalidate"><strong>NOTIFICATION_ACCESSIBILITY_INVALIDATE</strong> = <literal>3001</literal> <reference internal="True" refid="class-node-constant-notification-accessibility-invalidate"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Notification received when accessibility elements are invalidated. All node accessibility elements are automatically deleted after receiving this message, therefore all existing references to such elements should be discarded.</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="property-descriptions" names="property\ descriptions">
            <title>Property Descriptions</title>
            <target refid="class-node-property-auto-translate-mode"></target>
            <paragraph classes="classref-property" ids="class-node-property-auto-translate-mode" names="class_node_property_auto_translate_mode"><reference internal="True" refid="enum-node-autotranslatemode"><inline classes="std std-ref">AutoTranslateMode</inline></reference> <strong>auto_translate_mode</strong> = <literal>0</literal> <reference internal="True" refid="class-node-property-auto-translate-mode"><inline classes="std std-ref"></inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_auto_translate_mode</strong>(value: <reference internal="True" refid="enum-node-autotranslatemode"><inline classes="std std-ref">AutoTranslateMode</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refid="enum-node-autotranslatemode"><inline classes="std std-ref">AutoTranslateMode</inline></reference> <strong>get_auto_translate_mode</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Defines if any text should automatically change to its translated version depending on the current locale (for nodes such as <reference internal="True" refuri="class_label#class-label"><inline classes="std std-ref">Label</inline></reference>, <reference internal="True" refuri="class_richtextlabel#class-richtextlabel"><inline classes="std std-ref">RichTextLabel</inline></reference>, <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference>, etc.). Also decides if the node's strings should be parsed for translation template generation.</paragraph>
            <paragraph><strong>Note:</strong> For the root node, auto translate mode can also be set via <reference internal="True" refuri="class_projectsettings#class-projectsettings-property-internationalization-rendering-root-node-auto-translate"><inline classes="std std-ref">ProjectSettings.internationalization/rendering/root_node_auto_translate</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-editor-description"></target>
            <paragraph classes="classref-property" ids="class-node-property-editor-description" names="class_node_property_editor_description"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>editor_description</strong> = <literal>""</literal> <reference internal="True" refid="class-node-property-editor-description"><inline classes="std std-ref"></inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_editor_description</strong>(value: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_editor_description</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>An optional description to the node. It will be displayed as a tooltip when hovering over the node in the editor's Scene dock.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-multiplayer"></target>
            <paragraph classes="classref-property" ids="class-node-property-multiplayer" names="class_node_property_multiplayer"><reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> <strong>multiplayer</strong> <reference internal="True" refid="class-node-property-multiplayer"><inline classes="std std-ref"></inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> <strong>get_multiplayer</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> instance associated with this node. See <reference internal="True" refuri="class_scenetree#class-scenetree-method-get-multiplayer"><inline classes="std std-ref">SceneTree.get_multiplayer()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> Renaming the node, or moving it in the tree, will not move the <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> to the new path, you will have to update this manually.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-name"></target>
            <paragraph classes="classref-property" ids="class-node-property-name" names="class_node_property_name"><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>name</strong> <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref"></inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_name</strong>(value: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> <strong>get_name</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The name of the node. This name must be unique among the siblings (other child nodes from the same parent). When set to an existing sibling's name, the node is automatically renamed.</paragraph>
            <paragraph><strong>Note:</strong> When changing the name, the following characters will be replaced with an underscore: (<literal>.</literal> <literal>:</literal> <literal>@</literal> <literal>/</literal> <literal>"</literal> <literal>%</literal>). In particular, the <literal>@</literal> character is reserved for auto-generated names. See also <reference internal="True" refuri="class_string#class-string-method-validate-node-name"><inline classes="std std-ref">String.validate_node_name()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-owner"></target>
            <paragraph classes="classref-property" ids="class-node-property-owner" names="class_node_property_owner"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>owner</strong> <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref"></inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_owner</strong>(value: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>get_owner</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The owner of this node. The owner must be an ancestor of this node. When packing the owner node in a <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference>, all the nodes it owns are also saved with it. See also <reference internal="True" refid="class-node-property-unique-name-in-owner"><inline classes="std std-ref">unique_name_in_owner</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> In the editor, nodes not owned by the scene root are usually not displayed in the Scene dock, and will <strong>not</strong> be saved. To prevent this, remember to set the owner after calling <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-physics-interpolation-mode"></target>
            <paragraph classes="classref-property" ids="class-node-property-physics-interpolation-mode" names="class_node_property_physics_interpolation_mode"><reference internal="True" refid="enum-node-physicsinterpolationmode"><inline classes="std std-ref">PhysicsInterpolationMode</inline></reference> <strong>physics_interpolation_mode</strong> = <literal>0</literal> <reference internal="True" refid="class-node-property-physics-interpolation-mode"><inline classes="std std-ref"></inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_physics_interpolation_mode</strong>(value: <reference internal="True" refid="enum-node-physicsinterpolationmode"><inline classes="std std-ref">PhysicsInterpolationMode</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refid="enum-node-physicsinterpolationmode"><inline classes="std std-ref">PhysicsInterpolationMode</inline></reference> <strong>get_physics_interpolation_mode</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The physics interpolation mode to use for this node. Only effective if <reference internal="True" refuri="class_projectsettings#class-projectsettings-property-physics-common-physics-interpolation"><inline classes="std std-ref">ProjectSettings.physics/common/physics_interpolation</inline></reference> or <reference internal="True" refuri="class_scenetree#class-scenetree-property-physics-interpolation"><inline classes="std std-ref">SceneTree.physics_interpolation</inline></reference> is <literal>true</literal>.</paragraph>
            <paragraph>By default, nodes inherit the physics interpolation mode from their parent. This property can enable or disable physics interpolation individually for each node, regardless of their parents' physics interpolation mode.</paragraph>
            <paragraph><strong>Note:</strong> Some node types like <reference internal="True" refuri="class_vehiclewheel3d#class-vehiclewheel3d"><inline classes="std std-ref">VehicleWheel3D</inline></reference> have physics interpolation disabled by default, as they rely on their own custom solution.</paragraph>
            <paragraph><strong>Note:</strong> When teleporting a node to a distant position, it's recommended to temporarily disable interpolation with <reference internal="True" refid="class-node-method-reset-physics-interpolation"><inline classes="std std-ref">reset_physics_interpolation()</inline></reference> <emphasis>after</emphasis> moving the node. This avoids creating a visual streak between the old and new positions.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-process-mode"></target>
            <paragraph classes="classref-property" ids="class-node-property-process-mode" names="class_node_property_process_mode"><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> <strong>process_mode</strong> = <literal>0</literal> <reference internal="True" refid="class-node-property-process-mode"><inline classes="std std-ref"></inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_process_mode</strong>(value: <reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refid="enum-node-processmode"><inline classes="std std-ref">ProcessMode</inline></reference> <strong>get_process_mode</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The node's processing behavior. To check if the node can process in its current mode, use <reference internal="True" refid="class-node-method-can-process"><inline classes="std std-ref">can_process()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-process-physics-priority"></target>
            <paragraph classes="classref-property" ids="class-node-property-process-physics-priority" names="class_node_property_process_physics_priority"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>process_physics_priority</strong> = <literal>0</literal> <reference internal="True" refid="class-node-property-process-physics-priority"><inline classes="std std-ref"></inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_physics_process_priority</strong>(value: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_physics_process_priority</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Similar to <reference internal="True" refid="class-node-property-process-priority"><inline classes="std std-ref">process_priority</inline></reference> but for <reference internal="True" refid="class-node-constant-notification-physics-process"><inline classes="std std-ref">NOTIFICATION_PHYSICS_PROCESS</inline></reference>, <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference>, or <reference internal="True" refid="class-node-constant-notification-internal-physics-process"><inline classes="std std-ref">NOTIFICATION_INTERNAL_PHYSICS_PROCESS</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-process-priority"></target>
            <paragraph classes="classref-property" ids="class-node-property-process-priority" names="class_node_property_process_priority"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>process_priority</strong> = <literal>0</literal> <reference internal="True" refid="class-node-property-process-priority"><inline classes="std std-ref"></inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_process_priority</strong>(value: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_process_priority</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The node's execution order of the process callbacks (<reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference>, <reference internal="True" refid="class-node-constant-notification-process"><inline classes="std std-ref">NOTIFICATION_PROCESS</inline></reference>, and <reference internal="True" refid="class-node-constant-notification-internal-process"><inline classes="std std-ref">NOTIFICATION_INTERNAL_PROCESS</inline></reference>). Nodes whose priority value is <emphasis>lower</emphasis> call their process callbacks first, regardless of tree order.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-process-thread-group"></target>
            <paragraph classes="classref-property" ids="class-node-property-process-thread-group" names="class_node_property_process_thread_group"><reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref">ProcessThreadGroup</inline></reference> <strong>process_thread_group</strong> = <literal>0</literal> <reference internal="True" refid="class-node-property-process-thread-group"><inline classes="std std-ref"></inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_process_thread_group</strong>(value: <reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref">ProcessThreadGroup</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refid="enum-node-processthreadgroup"><inline classes="std std-ref">ProcessThreadGroup</inline></reference> <strong>get_process_thread_group</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Set the process thread group for this node (basically, whether it receives <reference internal="True" refid="class-node-constant-notification-process"><inline classes="std std-ref">NOTIFICATION_PROCESS</inline></reference>, <reference internal="True" refid="class-node-constant-notification-physics-process"><inline classes="std std-ref">NOTIFICATION_PHYSICS_PROCESS</inline></reference>, <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference> or <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference> (and the internal versions) on the main thread or in a sub-thread.</paragraph>
            <paragraph>By default, the thread group is <reference internal="True" refid="class-node-constant-process-thread-group-inherit"><inline classes="std std-ref">PROCESS_THREAD_GROUP_INHERIT</inline></reference>, which means that this node belongs to the same thread group as the parent node. The thread groups means that nodes in a specific thread group will process together, separate to other thread groups (depending on <reference internal="True" refid="class-node-property-process-thread-group-order"><inline classes="std std-ref">process_thread_group_order</inline></reference>). If the value is set is <reference internal="True" refid="class-node-constant-process-thread-group-sub-thread"><inline classes="std std-ref">PROCESS_THREAD_GROUP_SUB_THREAD</inline></reference>, this thread group will occur on a sub thread (not the main thread), otherwise if set to <reference internal="True" refid="class-node-constant-process-thread-group-main-thread"><inline classes="std std-ref">PROCESS_THREAD_GROUP_MAIN_THREAD</inline></reference> it will process on the main thread. If there is not a parent or grandparent node set to something other than inherit, the node will belong to the <emphasis>default thread group</emphasis>. This default group will process on the main thread and its group order is 0.</paragraph>
            <paragraph>During processing in a sub-thread, accessing most functions in nodes outside the thread group is forbidden (and it will result in an error in debug mode). Use <reference internal="True" refuri="class_object#class-object-method-call-deferred"><inline classes="std std-ref">Object.call_deferred()</inline></reference>, <reference internal="True" refid="class-node-method-call-thread-safe"><inline classes="std std-ref">call_thread_safe()</inline></reference>, <reference internal="True" refid="class-node-method-call-deferred-thread-group"><inline classes="std std-ref">call_deferred_thread_group()</inline></reference> and the likes in order to communicate from the thread groups to the main thread (or to other thread groups).</paragraph>
            <paragraph>To better understand process thread groups, the idea is that any node set to any other value than <reference internal="True" refid="class-node-constant-process-thread-group-inherit"><inline classes="std std-ref">PROCESS_THREAD_GROUP_INHERIT</inline></reference> will include any child (and grandchild) nodes set to inherit into its process thread group. This means that the processing of all the nodes in the group will happen together, at the same time as the node including them.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-process-thread-group-order"></target>
            <paragraph classes="classref-property" ids="class-node-property-process-thread-group-order" names="class_node_property_process_thread_group_order"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>process_thread_group_order</strong> <reference internal="True" refid="class-node-property-process-thread-group-order"><inline classes="std std-ref"></inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_process_thread_group_order</strong>(value: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_process_thread_group_order</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Change the process thread group order. Groups with a lesser order will process before groups with a greater order. This is useful when a large amount of nodes process in sub thread and, afterwards, another group wants to collect their result in the main thread, as an example.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-process-thread-messages"></target>
            <paragraph classes="classref-property" ids="class-node-property-process-thread-messages" names="class_node_property_process_thread_messages"><abbreviation explanation="This value is an integer composed as a bitmask of the following flags.">BitField</abbreviation>[<reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref">ProcessThreadMessages</inline></reference>] <strong>process_thread_messages</strong> <reference internal="True" refid="class-node-property-process-thread-messages"><inline classes="std std-ref"></inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_process_thread_messages</strong>(value: <abbreviation explanation="This value is an integer composed as a bitmask of the following flags.">BitField</abbreviation>[<reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref">ProcessThreadMessages</inline></reference>])</paragraph>
                </list_item>
                <list_item>
                    <paragraph><abbreviation explanation="This value is an integer composed as a bitmask of the following flags.">BitField</abbreviation>[<reference internal="True" refid="enum-node-processthreadmessages"><inline classes="std std-ref">ProcessThreadMessages</inline></reference>] <strong>get_process_thread_messages</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Set whether the current thread group will process messages (calls to <reference internal="True" refid="class-node-method-call-deferred-thread-group"><inline classes="std std-ref">call_deferred_thread_group()</inline></reference> on threads), and whether it wants to receive them during regular process or physics process callbacks.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-scene-file-path"></target>
            <paragraph classes="classref-property" ids="class-node-property-scene-file-path" names="class_node_property_scene_file_path"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>scene_file_path</strong> <reference internal="True" refid="class-node-property-scene-file-path"><inline classes="std std-ref"></inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_scene_file_path</strong>(value: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_scene_file_path</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The original scene's file path, if the node has been instantiated from a <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference> file. Only scene root nodes contains this.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-property-unique-name-in-owner"></target>
            <paragraph classes="classref-property" ids="class-node-property-unique-name-in-owner" names="class_node_property_unique_name_in_owner"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>unique_name_in_owner</strong> = <literal>false</literal> <reference internal="True" refid="class-node-property-unique-name-in-owner"><inline classes="std std-ref"></inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="No return value.">void</abbreviation> <strong>set_unique_name_in_owner</strong>(value: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_unique_name_in_owner</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If <literal>true</literal>, the node can be accessed from any node sharing the same <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> or from the <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> itself, with special <literal>%Name</literal> syntax in <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> If another node with the same <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> shares the same <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference> as this node, the other node will no longer be accessible as unique.</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="method-descriptions" names="method\ descriptions">
            <title>Method Descriptions</title>
            <target refid="class-node-private-method-enter-tree"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-enter-tree" names="class_node_private_method__enter_tree"><abbreviation explanation="No return value.">void</abbreviation> <strong>_enter_tree</strong>() <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Called when the node enters the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> (e.g. upon instantiating, scene changing, or after calling <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference> in a script). If the node has children, its <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree()</inline></reference> callback will be called first, and then that of the children.</paragraph>
            <paragraph>Corresponds to the <reference internal="True" refid="class-node-constant-notification-enter-tree"><inline classes="std std-ref">NOTIFICATION_ENTER_TREE</inline></reference> notification in <reference internal="True" refuri="class_object#class-object-private-method-notification"><inline classes="std std-ref">Object._notification()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-exit-tree"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-exit-tree" names="class_node_private_method__exit_tree"><abbreviation explanation="No return value.">void</abbreviation> <strong>_exit_tree</strong>() <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <reference internal="True" refid="class-node-private-method-exit-tree"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Called when the node is about to leave the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> (e.g. upon freeing, scene changing, or after calling <reference internal="True" refid="class-node-method-remove-child"><inline classes="std std-ref">remove_child()</inline></reference> in a script). If the node has children, its <reference internal="True" refid="class-node-private-method-exit-tree"><inline classes="std std-ref">_exit_tree()</inline></reference> callback will be called last, after all its children have left the tree.</paragraph>
            <paragraph>Corresponds to the <reference internal="True" refid="class-node-constant-notification-exit-tree"><inline classes="std std-ref">NOTIFICATION_EXIT_TREE</inline></reference> notification in <reference internal="True" refuri="class_object#class-object-private-method-notification"><inline classes="std std-ref">Object._notification()</inline></reference> and signal <reference internal="True" refid="class-node-signal-tree-exiting"><inline classes="std std-ref">tree_exiting</inline></reference>. To get notified when the node has already left the active tree, connect to the <reference internal="True" refid="class-node-signal-tree-exited"><inline classes="std std-ref">tree_exited</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-get-accessibility-configuration-warnings"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-get-accessibility-configuration-warnings" names="class_node_private_method__get_accessibility_configuration_warnings"><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> <strong>_get_accessibility_configuration_warnings</strong>() <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-private-method-get-accessibility-configuration-warnings"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>The elements in the array returned from this method are displayed as warnings in the Scene dock if the script that overrides it is a <literal>tool</literal> script, and accessibility warnings are enabled in the editor settings.</paragraph>
            <paragraph>Returning an empty array produces no warnings.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-get-configuration-warnings"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-get-configuration-warnings" names="class_node_private_method__get_configuration_warnings"><reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> <strong>_get_configuration_warnings</strong>() <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-private-method-get-configuration-warnings"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>The elements in the array returned from this method are displayed as warnings in the Scene dock if the script that overrides it is a <literal>tool</literal> script.</paragraph>
            <paragraph>Returning an empty array produces no warnings.</paragraph>
            <paragraph>Call <reference internal="True" refid="class-node-method-update-configuration-warnings"><inline classes="std std-ref">update_configuration_warnings()</inline></reference> when the warnings need to be updated for this node.</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">@export var energy = 0:
    set(value):
        energy = value
        update_configuration_warnings()

func _get_configuration_warnings():
    if energy &lt; 0:
        return ["Energy must be 0 or greater."]
    else:
        return []</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-get-focused-accessibility-element"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-get-focused-accessibility-element" names="class_node_private_method__get_focused_accessibility_element"><reference internal="True" refuri="class_rid#class-rid"><inline classes="std std-ref">RID</inline></reference> <strong>_get_focused_accessibility_element</strong>() <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-private-method-get-focused-accessibility-element"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Called during accessibility information updates to determine the currently focused sub-element, should return a sub-element RID or the value returned by <reference internal="True" refid="class-node-method-get-accessibility-element"><inline classes="std std-ref">get_accessibility_element()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-input"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-input" names="class_node_private_method__input"><abbreviation explanation="No return value.">void</abbreviation> <strong>_input</strong>(event: <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference>) <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Called when there is an input event. The input event propagates up through the node tree until a node consumes it.</paragraph>
            <paragraph>It is only called if input processing is enabled, which is done automatically if this method is overridden, and can be toggled with <reference internal="True" refid="class-node-method-set-process-input"><inline classes="std std-ref">set_process_input()</inline></reference>.</paragraph>
            <paragraph>To consume the input event and stop it propagating further to other nodes, <reference internal="True" refuri="class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled()</inline></reference> can be called.</paragraph>
            <paragraph>For gameplay input, <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input()</inline></reference> and <reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref">_unhandled_key_input()</inline></reference> are usually a better fit as they allow the GUI to intercept the events first.</paragraph>
            <paragraph><strong>Note:</strong> This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-physics-process"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-physics-process" names="class_node_private_method__physics_process"><abbreviation explanation="No return value.">void</abbreviation> <strong>_physics_process</strong>(delta: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Called once on each physics tick, and allows Nodes to synchronize their logic with physics ticks. <literal>delta</literal> is the logical time between physics ticks in seconds and is equal to <reference internal="True" refuri="class_engine#class-engine-property-time-scale"><inline classes="std std-ref">Engine.time_scale</inline></reference> / <reference internal="True" refuri="class_engine#class-engine-property-physics-ticks-per-second"><inline classes="std std-ref">Engine.physics_ticks_per_second</inline></reference>.</paragraph>
            <paragraph>It is only called if physics processing is enabled for this Node, which is done automatically if this method is overridden, and can be toggled with <reference internal="True" refid="class-node-method-set-physics-process"><inline classes="std std-ref">set_physics_process()</inline></reference>.</paragraph>
            <paragraph>Processing happens in order of <reference internal="True" refid="class-node-property-process-physics-priority"><inline classes="std std-ref">process_physics_priority</inline></reference>, lower priority values are called first. Nodes with the same priority are processed in tree order, or top to bottom as seen in the editor (also known as pre-order traversal).</paragraph>
            <paragraph>Corresponds to the <reference internal="True" refid="class-node-constant-notification-physics-process"><inline classes="std std-ref">NOTIFICATION_PHYSICS_PROCESS</inline></reference> notification in <reference internal="True" refuri="class_object#class-object-private-method-notification"><inline classes="std std-ref">Object._notification()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).</paragraph>
            <paragraph><strong>Note:</strong> Accumulated <literal>delta</literal> may diverge from real world seconds.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-process"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-process" names="class_node_private_method__process"><abbreviation explanation="No return value.">void</abbreviation> <strong>_process</strong>(delta: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Called on each idle frame, prior to rendering, and after physics ticks have been processed. <literal>delta</literal> is the time between frames in seconds.</paragraph>
            <paragraph>It is only called if processing is enabled for this Node, which is done automatically if this method is overridden, and can be toggled with <reference internal="True" refid="class-node-method-set-process"><inline classes="std std-ref">set_process()</inline></reference>.</paragraph>
            <paragraph>Processing happens in order of <reference internal="True" refid="class-node-property-process-priority"><inline classes="std std-ref">process_priority</inline></reference>, lower priority values are called first. Nodes with the same priority are processed in tree order, or top to bottom as seen in the editor (also known as pre-order traversal).</paragraph>
            <paragraph>Corresponds to the <reference internal="True" refid="class-node-constant-notification-process"><inline classes="std std-ref">NOTIFICATION_PROCESS</inline></reference> notification in <reference internal="True" refuri="class_object#class-object-private-method-notification"><inline classes="std std-ref">Object._notification()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).</paragraph>
            <paragraph><strong>Note:</strong> When the engine is struggling and the frame rate is lowered, <literal>delta</literal> will increase. When <literal>delta</literal> is increased, it's capped at a maximum of <reference internal="True" refuri="class_engine#class-engine-property-time-scale"><inline classes="std std-ref">Engine.time_scale</inline></reference> * <reference internal="True" refuri="class_engine#class-engine-property-max-physics-steps-per-frame"><inline classes="std std-ref">Engine.max_physics_steps_per_frame</inline></reference> / <reference internal="True" refuri="class_engine#class-engine-property-physics-ticks-per-second"><inline classes="std std-ref">Engine.physics_ticks_per_second</inline></reference>. As a result, accumulated <literal>delta</literal> may not represent real world time.</paragraph>
            <paragraph><strong>Note:</strong> When <literal>--fixed-fps</literal> is enabled or the engine is running in Movie Maker mode (see <reference internal="True" refuri="class_moviewriter#class-moviewriter"><inline classes="std std-ref">MovieWriter</inline></reference>), process <literal>delta</literal> will always be the same for every frame, regardless of how much time the frame took to render.</paragraph>
            <paragraph><strong>Note:</strong> Frame delta may be post-processed by <reference internal="True" refuri="class_os#class-os-property-delta-smoothing"><inline classes="std std-ref">OS.delta_smoothing</inline></reference> if this is enabled for the project.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-ready"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-ready" names="class_node_private_method__ready"><abbreviation explanation="No return value.">void</abbreviation> <strong>_ready</strong>() <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Called when the node is "ready", i.e. when both the node and its children have entered the scene tree. If the node has children, their <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> callbacks get triggered first, and the parent node will receive the ready notification afterwards.</paragraph>
            <paragraph>Corresponds to the <reference internal="True" refid="class-node-constant-notification-ready"><inline classes="std std-ref">NOTIFICATION_READY</inline></reference> notification in <reference internal="True" refuri="class_object#class-object-private-method-notification"><inline classes="std std-ref">Object._notification()</inline></reference>. See also the <literal>@onready</literal> annotation for variables.</paragraph>
            <paragraph>Usually used for initialization. For even earlier initialization, <reference internal="True" refuri="class_object#class-object-private-method-init"><inline classes="std std-ref">Object._init()</inline></reference> may be used. See also <reference internal="True" refid="class-node-private-method-enter-tree"><inline classes="std std-ref">_enter_tree()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This method may be called only once for each node. After removing a node from the scene tree and adding it again, <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> will <strong>not</strong> be called a second time. This can be bypassed by requesting another call with <reference internal="True" refid="class-node-method-request-ready"><inline classes="std std-ref">request_ready()</inline></reference>, which may be called anywhere before adding the node again.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-shortcut-input"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-shortcut-input" names="class_node_private_method__shortcut_input"><abbreviation explanation="No return value.">void</abbreviation> <strong>_shortcut_input</strong>(event: <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference>) <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <reference internal="True" refid="class-node-private-method-shortcut-input"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Called when an <reference internal="True" refuri="class_inputeventkey#class-inputeventkey"><inline classes="std std-ref">InputEventKey</inline></reference>, <reference internal="True" refuri="class_inputeventshortcut#class-inputeventshortcut"><inline classes="std std-ref">InputEventShortcut</inline></reference>, or <reference internal="True" refuri="class_inputeventjoypadbutton#class-inputeventjoypadbutton"><inline classes="std std-ref">InputEventJoypadButton</inline></reference> hasn't been consumed by <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input()</inline></reference> or any GUI <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> item. It is called before <reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref">_unhandled_key_input()</inline></reference> and <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input()</inline></reference>. The input event propagates up through the node tree until a node consumes it.</paragraph>
            <paragraph>It is only called if shortcut processing is enabled, which is done automatically if this method is overridden, and can be toggled with <reference internal="True" refid="class-node-method-set-process-shortcut-input"><inline classes="std std-ref">set_process_shortcut_input()</inline></reference>.</paragraph>
            <paragraph>To consume the input event and stop it propagating further to other nodes, <reference internal="True" refuri="class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled()</inline></reference> can be called.</paragraph>
            <paragraph>This method can be used to handle shortcuts. For generic GUI events, use <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input()</inline></reference> instead. Gameplay events should usually be handled with either <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input()</inline></reference> or <reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref">_unhandled_key_input()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This method is only called if the node is present in the scene tree (i.e. if it's not orphan).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-unhandled-input"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-unhandled-input" names="class_node_private_method__unhandled_input"><abbreviation explanation="No return value.">void</abbreviation> <strong>_unhandled_input</strong>(event: <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference>) <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Called when an <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference> hasn't been consumed by <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input()</inline></reference> or any GUI <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> item. It is called after <reference internal="True" refid="class-node-private-method-shortcut-input"><inline classes="std std-ref">_shortcut_input()</inline></reference> and after <reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref">_unhandled_key_input()</inline></reference>. The input event propagates up through the node tree until a node consumes it.</paragraph>
            <paragraph>It is only called if unhandled input processing is enabled, which is done automatically if this method is overridden, and can be toggled with <reference internal="True" refid="class-node-method-set-process-unhandled-input"><inline classes="std std-ref">set_process_unhandled_input()</inline></reference>.</paragraph>
            <paragraph>To consume the input event and stop it propagating further to other nodes, <reference internal="True" refuri="class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled()</inline></reference> can be called.</paragraph>
            <paragraph>For gameplay input, this method is usually a better fit than <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input()</inline></reference>, as GUI events need a higher priority. For keyboard shortcuts, consider using <reference internal="True" refid="class-node-private-method-shortcut-input"><inline classes="std std-ref">_shortcut_input()</inline></reference> instead, as it is called before this method. Finally, to handle keyboard events, consider using <reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref">_unhandled_key_input()</inline></reference> for performance reasons.</paragraph>
            <paragraph><strong>Note:</strong> This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-private-method-unhandled-key-input"></target>
            <paragraph classes="classref-method" ids="class-node-private-method-unhandled-key-input" names="class_node_private_method__unhandled_key_input"><abbreviation explanation="No return value.">void</abbreviation> <strong>_unhandled_key_input</strong>(event: <reference internal="True" refuri="class_inputevent#class-inputevent"><inline classes="std std-ref">InputEvent</inline></reference>) <abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation> <reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Called when an <reference internal="True" refuri="class_inputeventkey#class-inputeventkey"><inline classes="std std-ref">InputEventKey</inline></reference> hasn't been consumed by <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input()</inline></reference> or any GUI <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> item. It is called after <reference internal="True" refid="class-node-private-method-shortcut-input"><inline classes="std std-ref">_shortcut_input()</inline></reference> but before <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input()</inline></reference>. The input event propagates up through the node tree until a node consumes it.</paragraph>
            <paragraph>It is only called if unhandled key input processing is enabled, which is done automatically if this method is overridden, and can be toggled with <reference internal="True" refid="class-node-method-set-process-unhandled-key-input"><inline classes="std std-ref">set_process_unhandled_key_input()</inline></reference>.</paragraph>
            <paragraph>To consume the input event and stop it propagating further to other nodes, <reference internal="True" refuri="class_viewport#class-viewport-method-set-input-as-handled"><inline classes="std std-ref">Viewport.set_input_as_handled()</inline></reference> can be called.</paragraph>
            <paragraph>This method can be used to handle Unicode character input with <literal classes="kbd">Alt</literal>, <literal classes="kbd">Alt + Ctrl</literal>, and <literal classes="kbd">Alt + Shift</literal> modifiers, after shortcuts were handled.</paragraph>
            <paragraph>For gameplay input, this and <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input()</inline></reference> are usually a better fit than <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input()</inline></reference>, as GUI events should be handled first. This method also performs better than <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input()</inline></reference>, since unrelated events such as <reference internal="True" refuri="class_inputeventmousemotion#class-inputeventmousemotion"><inline classes="std std-ref">InputEventMouseMotion</inline></reference> are automatically filtered. For shortcuts, consider using <reference internal="True" refid="class-node-private-method-shortcut-input"><inline classes="std std-ref">_shortcut_input()</inline></reference> instead.</paragraph>
            <paragraph><strong>Note:</strong> This method is only called if the node is present in the scene tree (i.e. if it's not an orphan).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-add-child"></target>
            <paragraph classes="classref-method" ids="class-node-method-add-child" names="class_node_method_add_child"><abbreviation explanation="No return value.">void</abbreviation> <strong>add_child</strong>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>, force_readable_name: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false, internal: <reference internal="True" refid="enum-node-internalmode"><inline classes="std std-ref">InternalMode</inline></reference> = 0) <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Adds a child <literal>node</literal>. Nodes can have any number of children, but every child must have a unique name. Child nodes are automatically deleted when the parent node is deleted, so an entire scene can be removed by deleting its topmost node.</paragraph>
            <paragraph>If <literal>force_readable_name</literal> is <literal>true</literal>, improves the readability of the added <literal>node</literal>. If not named, the <literal>node</literal> is renamed to its type, and if it shares <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference> with a sibling, a number is suffixed more appropriately. This operation is very slow. As such, it is recommended leaving this to <literal>false</literal>, which assigns a dummy name featuring <literal>@</literal> in both situations.</paragraph>
            <paragraph>If <literal>internal</literal> is different than <reference internal="True" refid="class-node-constant-internal-mode-disabled"><inline classes="std std-ref">INTERNAL_MODE_DISABLED</inline></reference>, the child will be added as internal node. These nodes are ignored by methods like <reference internal="True" refid="class-node-method-get-children"><inline classes="std std-ref">get_children()</inline></reference>, unless their parameter <literal>include_internal</literal> is <literal>true</literal>. It also prevents these nodes being duplicated with their parent. The intended usage is to hide the internal nodes from the user, so the user won't accidentally delete or modify them. Used by some GUI nodes, e.g. <reference internal="True" refuri="class_colorpicker#class-colorpicker"><inline classes="std std-ref">ColorPicker</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> If <literal>node</literal> already has a parent, this method will fail. Use <reference internal="True" refid="class-node-method-remove-child"><inline classes="std std-ref">remove_child()</inline></reference> first to remove <literal>node</literal> from its current parent. For example:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var child_node = get_child(0)
if child_node.get_parent():
    child_node.get_parent().remove_child(child_node)
add_child(child_node)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Node childNode = GetChild(0);
if (childNode.GetParent() != null)
{
    childNode.GetParent().RemoveChild(childNode);
}
AddChild(childNode);</literal_block>
                </div>
            </container>
            <paragraph>If you need the child node to be added below a specific node in the list of children, use <reference internal="True" refid="class-node-method-add-sibling"><inline classes="std std-ref">add_sibling()</inline></reference> instead of this method.</paragraph>
            <paragraph><strong>Note:</strong> If you want a child to be persisted to a <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference>, you must set <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> in addition to calling <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference>. This is typically relevant for <reference internal="True" refuri="../tutorials/plugins/running_code_in_the_editor"><inline classes="doc">tool scripts</inline></reference> and <reference internal="True" refuri="../tutorials/plugins/editor/index"><inline classes="doc">editor plugins</inline></reference>. If <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference> is called without setting <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference>, the newly added <strong>Node</strong> will not be visible in the scene tree, though it will be visible in the 2D/3D view.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-add-sibling"></target>
            <paragraph classes="classref-method" ids="class-node-method-add-sibling" names="class_node_method_add_sibling"><abbreviation explanation="No return value.">void</abbreviation> <strong>add_sibling</strong>(sibling: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>, force_readable_name: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <reference internal="True" refid="class-node-method-add-sibling"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Adds a <literal>sibling</literal> node to this node's parent, and moves the added sibling right below this node.</paragraph>
            <paragraph>If <literal>force_readable_name</literal> is <literal>true</literal>, improves the readability of the added <literal>sibling</literal>. If not named, the <literal>sibling</literal> is renamed to its type, and if it shares <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference> with a sibling, a number is suffixed more appropriately. This operation is very slow. As such, it is recommended leaving this to <literal>false</literal>, which assigns a dummy name featuring <literal>@</literal> in both situations.</paragraph>
            <paragraph>Use <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference> instead of this method if you don't need the child node to be added below a specific node in the list of children.</paragraph>
            <paragraph><strong>Note:</strong> If this node is internal, the added sibling will be internal too (see <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference>'s <literal>internal</literal> parameter).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-add-to-group"></target>
            <paragraph classes="classref-method" ids="class-node-method-add-to-group" names="class_node_method_add_to_group"><abbreviation explanation="No return value.">void</abbreviation> <strong>add_to_group</strong>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, persistent: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <reference internal="True" refid="class-node-method-add-to-group"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Adds the node to the <literal>group</literal>. Groups can be helpful to organize a subset of nodes, for example <literal>"enemies"</literal> or <literal>"collectables"</literal>. See notes in the description, and the group methods in <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.</paragraph>
            <paragraph>If <literal>persistent</literal> is <literal>true</literal>, the group will be stored when saved inside a <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference>. All groups created and displayed in the Groups dock are persistent.</paragraph>
            <paragraph><strong>Note:</strong> To improve performance, the order of group names is <emphasis>not</emphasis> guaranteed and may vary between project runs. Therefore, do not rely on the group order.</paragraph>
            <paragraph><strong>Note:</strong> <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>'s group methods will <emphasis>not</emphasis> work on this node if not inside the tree (see <reference internal="True" refid="class-node-method-is-inside-tree"><inline classes="std std-ref">is_inside_tree()</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-atr"></target>
            <paragraph classes="classref-method" ids="class-node-method-atr" names="class_node_method_atr"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>atr</strong>(message: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>, context: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> = "") <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-atr"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Translates a <literal>message</literal>, using the translation catalogs configured in the Project Settings. Further <literal>context</literal> can be specified to help with the translation. Note that most <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> nodes automatically translate their strings, so this method is mostly useful for formatted strings or custom drawn text.</paragraph>
            <paragraph>This method works the same as <reference internal="True" refuri="class_object#class-object-method-tr"><inline classes="std std-ref">Object.tr()</inline></reference>, with the addition of respecting the <reference internal="True" refid="class-node-property-auto-translate-mode"><inline classes="std std-ref">auto_translate_mode</inline></reference> state.</paragraph>
            <paragraph>If <reference internal="True" refuri="class_object#class-object-method-can-translate-messages"><inline classes="std std-ref">Object.can_translate_messages()</inline></reference> is <literal>false</literal>, or no translation is available, this method returns the <literal>message</literal> without changes. See <reference internal="True" refuri="class_object#class-object-method-set-message-translation"><inline classes="std std-ref">Object.set_message_translation()</inline></reference>.</paragraph>
            <paragraph>For detailed examples, see <reference internal="True" refuri="../tutorials/i18n/internationalizing_games"><inline classes="doc">Internationalizing games</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-atr-n"></target>
            <paragraph classes="classref-method" ids="class-node-method-atr-n" names="class_node_method_atr_n"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>atr_n</strong>(message: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>, plural_message: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, n: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, context: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> = "") <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-atr-n"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Translates a <literal>message</literal> or <literal>plural_message</literal>, using the translation catalogs configured in the Project Settings. Further <literal>context</literal> can be specified to help with the translation.</paragraph>
            <paragraph>This method works the same as <reference internal="True" refuri="class_object#class-object-method-tr-n"><inline classes="std std-ref">Object.tr_n()</inline></reference>, with the addition of respecting the <reference internal="True" refid="class-node-property-auto-translate-mode"><inline classes="std std-ref">auto_translate_mode</inline></reference> state.</paragraph>
            <paragraph>If <reference internal="True" refuri="class_object#class-object-method-can-translate-messages"><inline classes="std std-ref">Object.can_translate_messages()</inline></reference> is <literal>false</literal>, or no translation is available, this method returns <literal>message</literal> or <literal>plural_message</literal>, without changes. See <reference internal="True" refuri="class_object#class-object-method-set-message-translation"><inline classes="std std-ref">Object.set_message_translation()</inline></reference>.</paragraph>
            <paragraph>The <literal>n</literal> is the number, or amount, of the message's subject. It is used by the translation system to fetch the correct plural form for the current language.</paragraph>
            <paragraph>For detailed examples, see <reference internal="True" refuri="../tutorials/i18n/localization_using_gettext"><inline classes="doc">Localization using gettext</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> Negative and <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> numbers may not properly apply to some countable subjects. It's recommended to handle these cases with <reference internal="True" refid="class-node-method-atr"><inline classes="std std-ref">atr()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-call-deferred-thread-group"></target>
            <paragraph classes="classref-method" ids="class-node-method-call-deferred-thread-group" names="class_node_method_call_deferred_thread_group"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>call_deferred_thread_group</strong>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <reference internal="True" refid="class-node-method-call-deferred-thread-group"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>This function is similar to <reference internal="True" refuri="class_object#class-object-method-call-deferred"><inline classes="std std-ref">Object.call_deferred()</inline></reference> except that the call will take place when the node thread group is processed. If the node thread group processes in sub-threads, then the call will be done on that thread, right before <reference internal="True" refid="class-node-constant-notification-process"><inline classes="std std-ref">NOTIFICATION_PROCESS</inline></reference> or <reference internal="True" refid="class-node-constant-notification-physics-process"><inline classes="std std-ref">NOTIFICATION_PHYSICS_PROCESS</inline></reference>, the <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference> or <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference> or their internal versions are called.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-call-thread-safe"></target>
            <paragraph classes="classref-method" ids="class-node-method-call-thread-safe" names="class_node_method_call_thread_safe"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>call_thread_safe</strong>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <reference internal="True" refid="class-node-method-call-thread-safe"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>This function ensures that the calling of this function will succeed, no matter whether it's being done from a thread or not. If called from a thread that is not allowed to call the function, the call will become deferred. Otherwise, the call will go through directly.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-can-auto-translate"></target>
            <paragraph classes="classref-method" ids="class-node-method-can-auto-translate" names="class_node_method_can_auto_translate"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>can_auto_translate</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-can-auto-translate"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if this node can automatically translate messages depending on the current locale. See <reference internal="True" refid="class-node-property-auto-translate-mode"><inline classes="std std-ref">auto_translate_mode</inline></reference>, <reference internal="True" refid="class-node-method-atr"><inline classes="std std-ref">atr()</inline></reference>, and <reference internal="True" refid="class-node-method-atr-n"><inline classes="std std-ref">atr_n()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-can-process"></target>
            <paragraph classes="classref-method" ids="class-node-method-can-process" names="class_node_method_can_process"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>can_process</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-can-process"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the node can receive processing notifications and input callbacks (<reference internal="True" refid="class-node-constant-notification-process"><inline classes="std std-ref">NOTIFICATION_PROCESS</inline></reference>, <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input()</inline></reference>, etc.) from the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> and <reference internal="True" refuri="class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference>. The returned value depends on <reference internal="True" refid="class-node-property-process-mode"><inline classes="std std-ref">process_mode</inline></reference>:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>If set to <reference internal="True" refid="class-node-constant-process-mode-pausable"><inline classes="std std-ref">PROCESS_MODE_PAUSABLE</inline></reference>, returns <literal>true</literal> when the game is processing, i.e. <reference internal="True" refuri="class_scenetree#class-scenetree-property-paused"><inline classes="std std-ref">SceneTree.paused</inline></reference> is <literal>false</literal>;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If set to <reference internal="True" refid="class-node-constant-process-mode-when-paused"><inline classes="std std-ref">PROCESS_MODE_WHEN_PAUSED</inline></reference>, returns <literal>true</literal> when the game is paused, i.e. <reference internal="True" refuri="class_scenetree#class-scenetree-property-paused"><inline classes="std std-ref">SceneTree.paused</inline></reference> is <literal>true</literal>;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If set to <reference internal="True" refid="class-node-constant-process-mode-always"><inline classes="std std-ref">PROCESS_MODE_ALWAYS</inline></reference>, always returns <literal>true</literal>;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If set to <reference internal="True" refid="class-node-constant-process-mode-disabled"><inline classes="std std-ref">PROCESS_MODE_DISABLED</inline></reference>, always returns <literal>false</literal>;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If set to <reference internal="True" refid="class-node-constant-process-mode-inherit"><inline classes="std std-ref">PROCESS_MODE_INHERIT</inline></reference>, use the parent node's <reference internal="True" refid="class-node-property-process-mode"><inline classes="std std-ref">process_mode</inline></reference> to determine the result.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>If the node is not inside the tree, returns <literal>false</literal> no matter the value of <reference internal="True" refid="class-node-property-process-mode"><inline classes="std std-ref">process_mode</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-create-tween"></target>
            <paragraph classes="classref-method" ids="class-node-method-create-tween" names="class_node_method_create_tween"><reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference> <strong>create_tween</strong>() <reference internal="True" refid="class-node-method-create-tween"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Creates a new <reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference> and binds it to this node.</paragraph>
            <paragraph>This is the equivalent of doing:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">get_tree().create_tween().bind_node(self)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GetTree().CreateTween().BindNode(this);</literal_block>
                </div>
            </container>
            <paragraph>The Tween will start automatically on the next process frame or physics frame (depending on <reference internal="True" refuri="class_tween#enum-tween-tweenprocessmode"><inline classes="std std-ref">TweenProcessMode</inline></reference>). See <reference internal="True" refuri="class_tween#class-tween-method-bind-node"><inline classes="std std-ref">Tween.bind_node()</inline></reference> for more info on Tweens bound to nodes.</paragraph>
            <paragraph><strong>Note:</strong> The method can still be used when the node is not inside <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>. It can fail in an unlikely case of using a custom <reference internal="True" refuri="class_mainloop#class-mainloop"><inline classes="std std-ref">MainLoop</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-duplicate"></target>
            <paragraph classes="classref-method" ids="class-node-method-duplicate" names="class_node_method_duplicate"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>duplicate</strong>(flags: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 15) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-duplicate"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Duplicates the node, returning a new node with all of its properties, signals, groups, and children copied from the original, recursively. The behavior can be tweaked through the <literal>flags</literal> (see <reference internal="True" refid="enum-node-duplicateflags"><inline classes="std std-ref">DuplicateFlags</inline></reference>). Internal nodes are not duplicated.</paragraph>
            <paragraph><strong>Note:</strong> For nodes with a <reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference> attached, if <reference internal="True" refuri="class_object#class-object-private-method-init"><inline classes="std std-ref">Object._init()</inline></reference> has been defined with required parameters, the duplicated node will not have a <reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> By default, this method will duplicate only properties marked for serialization (i.e. using <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-property-usage-storage"><inline classes="std std-ref">@GlobalScope.PROPERTY_USAGE_STORAGE</inline></reference>, or in GDScript, <reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-export"><inline classes="std std-ref">@GDScript.@export</inline></reference>). If you want to duplicate all properties, use <reference internal="True" refid="class-node-constant-duplicate-internal-state"><inline classes="std std-ref">DUPLICATE_INTERNAL_STATE</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-find-child"></target>
            <paragraph classes="classref-method" ids="class-node-method-find-child" names="class_node_method_find_child"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>find_child</strong>(pattern: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>, recursive: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true, owned: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-find-child"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Finds the first descendant of this node whose <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference> matches <literal>pattern</literal>, returning <literal>null</literal> if no match is found. The matching is done against node names, <emphasis>not</emphasis> their paths, through <reference internal="True" refuri="class_string#class-string-method-match"><inline classes="std std-ref">String.match()</inline></reference>. As such, it is case-sensitive, <literal>"*"</literal> matches zero or more characters, and <literal>"?"</literal> matches any single character.</paragraph>
            <paragraph>If <literal>recursive</literal> is <literal>false</literal>, only this node's direct children are checked. Nodes are checked in tree order, so this node's first direct child is checked first, then its own direct children, etc., before moving to the second direct child, and so on. Internal children are also included in the search (see <literal>internal</literal> parameter in <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference>).</paragraph>
            <paragraph>If <literal>owned</literal> is <literal>true</literal>, only descendants with a valid <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> node are checked.</paragraph>
            <paragraph><strong>Note:</strong> This method can be very slow. Consider storing a reference to the found node in a variable. Alternatively, use <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node()</inline></reference> with unique names (see <reference internal="True" refid="class-node-property-unique-name-in-owner"><inline classes="std std-ref">unique_name_in_owner</inline></reference>).</paragraph>
            <paragraph><strong>Note:</strong> To find all descendant nodes matching a pattern or a class type, see <reference internal="True" refid="class-node-method-find-children"><inline classes="std std-ref">find_children()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-find-children"></target>
            <paragraph classes="classref-method" ids="class-node-method-find-children" names="class_node_method_find_children"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>] <strong>find_children</strong>(pattern: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>, type: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> = "", recursive: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true, owned: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-find-children"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Finds all descendants of this node whose names match <literal>pattern</literal>, returning an empty <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> if no match is found. The matching is done against node names, <emphasis>not</emphasis> their paths, through <reference internal="True" refuri="class_string#class-string-method-match"><inline classes="std std-ref">String.match()</inline></reference>. As such, it is case-sensitive, <literal>"*"</literal> matches zero or more characters, and <literal>"?"</literal> matches any single character.</paragraph>
            <paragraph>If <literal>type</literal> is not empty, only ancestors inheriting from <literal>type</literal> are included (see <reference internal="True" refuri="class_object#class-object-method-is-class"><inline classes="std std-ref">Object.is_class()</inline></reference>).</paragraph>
            <paragraph>If <literal>recursive</literal> is <literal>false</literal>, only this node's direct children are checked. Nodes are checked in tree order, so this node's first direct child is checked first, then its own direct children, etc., before moving to the second direct child, and so on. Internal children are also included in the search (see <literal>internal</literal> parameter in <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference>).</paragraph>
            <paragraph>If <literal>owned</literal> is <literal>true</literal>, only descendants with a valid <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> node are checked.</paragraph>
            <paragraph><strong>Note:</strong> This method can be very slow. Consider storing references to the found nodes in a variable.</paragraph>
            <paragraph><strong>Note:</strong> To find a single descendant node matching a pattern, see <reference internal="True" refid="class-node-method-find-child"><inline classes="std std-ref">find_child()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-find-parent"></target>
            <paragraph classes="classref-method" ids="class-node-method-find-parent" names="class_node_method_find_parent"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>find_parent</strong>(pattern: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-find-parent"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Finds the first ancestor of this node whose <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference> matches <literal>pattern</literal>, returning <literal>null</literal> if no match is found. The matching is done through <reference internal="True" refuri="class_string#class-string-method-match"><inline classes="std std-ref">String.match()</inline></reference>. As such, it is case-sensitive, <literal>"*"</literal> matches zero or more characters, and <literal>"?"</literal> matches any single character. See also <reference internal="True" refid="class-node-method-find-child"><inline classes="std std-ref">find_child()</inline></reference> and <reference internal="True" refid="class-node-method-find-children"><inline classes="std std-ref">find_children()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> As this method walks upwards in the scene tree, it can be slow in large, deeply nested nodes. Consider storing a reference to the found node in a variable. Alternatively, use <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node()</inline></reference> with unique names (see <reference internal="True" refid="class-node-property-unique-name-in-owner"><inline classes="std std-ref">unique_name_in_owner</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-accessibility-element"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-accessibility-element" names="class_node_method_get_accessibility_element"><reference internal="True" refuri="class_rid#class-rid"><inline classes="std std-ref">RID</inline></reference> <strong>get_accessibility_element</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-accessibility-element"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns main accessibility element RID.</paragraph>
            <paragraph><strong>Note:</strong> This method should be called only during accessibility information updates (<reference internal="True" refid="class-node-constant-notification-accessibility-update"><inline classes="std std-ref">NOTIFICATION_ACCESSIBILITY_UPDATE</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-child"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-child" names="class_node_method_get_child"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>get_child</strong>(idx: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, include_internal: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-child"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Fetches a child node by its index. Each child node has an index relative to its siblings (see <reference internal="True" refid="class-node-method-get-index"><inline classes="std std-ref">get_index()</inline></reference>). The first child is at index 0. Negative values can also be used to start from the end of the list. This method can be used in combination with <reference internal="True" refid="class-node-method-get-child-count"><inline classes="std std-ref">get_child_count()</inline></reference> to iterate over this node's children. If no child exists at the given index, this method returns <literal>null</literal> and an error is generated.</paragraph>
            <paragraph>If <literal>include_internal</literal> is <literal>false</literal>, internal children are ignored (see <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference>'s <literal>internal</literal> parameter).</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve"># Assuming the following are children of this node, in order:
# First, Middle, Last.

var a = get_child(0).name  # a is "First"
var b = get_child(1).name  # b is "Middle"
var b = get_child(2).name  # b is "Last"
var c = get_child(-1).name # c is "Last"</literal_block>
            <paragraph><strong>Note:</strong> To fetch a node by <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>, use <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-child-count"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-child-count" names="class_node_method_get_child_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_child_count</strong>(include_internal: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-child-count"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns the number of children of this node.</paragraph>
            <paragraph>If <literal>include_internal</literal> is <literal>false</literal>, internal children are not counted (see <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference>'s <literal>internal</literal> parameter).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-children"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-children" names="class_node_method_get_children"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>] <strong>get_children</strong>(include_internal: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-children"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns all children of this node inside an <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>.</paragraph>
            <paragraph>If <literal>include_internal</literal> is <literal>false</literal>, excludes internal children from the returned array (see <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference>'s <literal>internal</literal> parameter).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-groups"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-groups" names="class_node_method_get_groups"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>] <strong>get_groups</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-groups"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns an <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> of group names that the node has been added to.</paragraph>
            <paragraph><strong>Note:</strong> To improve performance, the order of group names is <emphasis>not</emphasis> guaranteed and may vary between project runs. Therefore, do not rely on the group order.</paragraph>
            <paragraph><strong>Note:</strong> This method may also return some group names starting with an underscore (<literal>_</literal>). These are internally used by the engine. To avoid conflicts, do not use custom groups starting with underscores. To exclude internal groups, see the following code snippet:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Stores the node's non-internal groups only (as an array of StringNames).
var non_internal_groups = []
for group in get_groups():
    if not str(group).begins_with("_"):
        non_internal_groups.push_back(group)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Stores the node's non-internal groups only (as a List of StringNames).
List&lt;string&gt; nonInternalGroups = new List&lt;string&gt;();
foreach (string group in GetGroups())
{
    if (!group.BeginsWith("_"))
        nonInternalGroups.Add(group);
}</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-index"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-index" names="class_node_method_get_index"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_index</strong>(include_internal: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-index"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns this node's order among its siblings. The first node's index is <literal>0</literal>. See also <reference internal="True" refid="class-node-method-get-child"><inline classes="std std-ref">get_child()</inline></reference>.</paragraph>
            <paragraph>If <literal>include_internal</literal> is <literal>false</literal>, returns the index ignoring internal children. The first, non-internal child will have an index of <literal>0</literal> (see <reference internal="True" refid="class-node-method-add-child"><inline classes="std std-ref">add_child()</inline></reference>'s <literal>internal</literal> parameter).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-last-exclusive-window"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-last-exclusive-window" names="class_node_method_get_last_exclusive_window"><reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> <strong>get_last_exclusive_window</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-last-exclusive-window"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns the <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> that contains this node, or the last exclusive child in a chain of windows starting with the one that contains this node.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-multiplayer-authority"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-multiplayer-authority" names="class_node_method_get_multiplayer_authority"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_multiplayer_authority</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-multiplayer-authority"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns the peer ID of the multiplayer authority for this node. See <reference internal="True" refid="class-node-method-set-multiplayer-authority"><inline classes="std std-ref">set_multiplayer_authority()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-node"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-node" names="class_node_method_get_node"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>get_node</strong>(path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Fetches a node. The <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> can either be a relative path (from this node), or an absolute path (from the <reference internal="True" refuri="class_scenetree#class-scenetree-property-root"><inline classes="std std-ref">SceneTree.root</inline></reference>) to a node. If <literal>path</literal> does not point to a valid node, generates an error and returns <literal>null</literal>. Attempts to access methods on the return value will result in an <emphasis>"Attempt to call &lt;method&gt; on a null instance."</emphasis> error.</paragraph>
            <paragraph><strong>Note:</strong> Fetching by absolute path only works when the node is inside the scene tree (see <reference internal="True" refid="class-node-method-is-inside-tree"><inline classes="std std-ref">is_inside_tree()</inline></reference>).</paragraph>
            <paragraph><strong>Example:</strong> Assume this method is called from the Character node, inside the following tree:</paragraph>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">root
   Character (you are here!)
     Sword
     Backpack
        Dagger
   MyGame
   Swamp
      Alligator
      Mosquito
      Goblin</literal_block>
            <paragraph>The following calls will return a valid node:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">get_node("Sword")
get_node("Backpack/Dagger")
get_node("../Swamp/Alligator")
get_node("/root/MyGame")</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GetNode("Sword");
GetNode("Backpack/Dagger");
GetNode("../Swamp/Alligator");
GetNode("/root/MyGame");</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-node-and-resource"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-node-and-resource" names="class_node_method_get_node_and_resource"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> <strong>get_node_and_resource</strong>(path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>) <reference internal="True" refid="class-node-method-get-node-and-resource"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Fetches a node and its most nested resource as specified by the <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>'s subname. Returns an <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> of size <literal>3</literal> where:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Element <literal>0</literal> is the <strong>Node</strong>, or <literal>null</literal> if not found;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Element <literal>1</literal> is the subname's last nested <reference internal="True" refuri="class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>, or <literal>null</literal> if not found;</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Element <literal>2</literal> is the remaining <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>, referring to an existing, non-<reference internal="True" refuri="class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> property (see <reference internal="True" refuri="class_object#class-object-method-get-indexed"><inline classes="std std-ref">Object.get_indexed()</inline></reference>).</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>Example:</strong> Assume that the child's <reference internal="True" refuri="class_sprite2d#class-sprite2d-property-texture"><inline classes="std std-ref">Sprite2D.texture</inline></reference> has been assigned an <reference internal="True" refuri="class_atlastexture#class-atlastexture"><inline classes="std std-ref">AtlasTexture</inline></reference>:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var a = get_node_and_resource("Area2D/Sprite2D")
print(a[0].name) # Prints Sprite2D
print(a[1])      # Prints &lt;null&gt;
print(a[2])      # Prints ^""

var b = get_node_and_resource("Area2D/Sprite2D:texture:atlas")
print(b[0].name)        # Prints Sprite2D
print(b[1].get_class()) # Prints AtlasTexture
print(b[2])             # Prints ^""

var c = get_node_and_resource("Area2D/Sprite2D:texture:atlas:region")
print(c[0].name)        # Prints Sprite2D
print(c[1].get_class()) # Prints AtlasTexture
print(c[2])             # Prints ^":region"</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var a = GetNodeAndResource(NodePath("Area2D/Sprite2D"));
GD.Print(a[0].Name); // Prints Sprite2D
GD.Print(a[1]);      // Prints &lt;null&gt;
GD.Print(a[2]);      // Prints ^"

var b = GetNodeAndResource(NodePath("Area2D/Sprite2D:texture:atlas"));
GD.Print(b[0].name);        // Prints Sprite2D
GD.Print(b[1].get_class()); // Prints AtlasTexture
GD.Print(b[2]);             // Prints ^""

var c = GetNodeAndResource(NodePath("Area2D/Sprite2D:texture:atlas:region"));
GD.Print(c[0].name);        // Prints Sprite2D
GD.Print(c[1].get_class()); // Prints AtlasTexture
GD.Print(c[2]);             // Prints ^":region"</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-node-or-null"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-node-or-null" names="class_node_method_get_node_or_null"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>get_node_or_null</strong>(path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-node-or-null"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Fetches a node by <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>. Similar to <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node()</inline></reference>, but does not generate an error if <literal>path</literal> does not point to a valid node.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-node-rpc-config"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-node-rpc-config" names="class_node_method_get_node_rpc_config"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>get_node_rpc_config</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-node-rpc-config"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns a <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> mapping method names to their RPC configuration defined for this node using <reference internal="True" refid="class-node-method-rpc-config"><inline classes="std std-ref">rpc_config()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This method only returns the RPC configuration assigned via <reference internal="True" refid="class-node-method-rpc-config"><inline classes="std std-ref">rpc_config()</inline></reference>. See <reference internal="True" refuri="class_script#class-script-method-get-rpc-config"><inline classes="std std-ref">Script.get_rpc_config()</inline></reference> to retrieve the RPCs defined by the <reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-orphan-node-ids"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-orphan-node-ids" names="class_node_method_get_orphan_node_ids"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>] <strong>get_orphan_node_ids</strong>() <abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation> <reference internal="True" refid="class-node-method-get-orphan-node-ids"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns object IDs of all orphan nodes (nodes outside the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>). Used for debugging.</paragraph>
            <paragraph><strong>Note:</strong> <reference internal="True" refid="class-node-method-get-orphan-node-ids"><inline classes="std std-ref">get_orphan_node_ids()</inline></reference> only works in debug builds. When called in a project exported in release mode, <reference internal="True" refid="class-node-method-get-orphan-node-ids"><inline classes="std std-ref">get_orphan_node_ids()</inline></reference> will return an empty array.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-parent"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-parent" names="class_node_method_get_parent"><reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference> <strong>get_parent</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-parent"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns this node's parent node, or <literal>null</literal> if the node doesn't have a parent.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-path"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-path" names="class_node_method_get_path"><reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> <strong>get_path</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-path"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns the node's absolute path, relative to the <reference internal="True" refuri="class_scenetree#class-scenetree-property-root"><inline classes="std std-ref">SceneTree.root</inline></reference>. If the node is not inside the scene tree, this method fails and returns an empty <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-path-to"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-path-to" names="class_node_method_get_path_to"><reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> <strong>get_path_to</strong>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>, use_unique_path: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-path-to"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns the relative <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference> from this node to the specified <literal>node</literal>. Both nodes must be in the same <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> or scene hierarchy, otherwise this method fails and returns an empty <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>.</paragraph>
            <paragraph>If <literal>use_unique_path</literal> is <literal>true</literal>, returns the shortest path accounting for this node's unique name (see <reference internal="True" refid="class-node-property-unique-name-in-owner"><inline classes="std std-ref">unique_name_in_owner</inline></reference>).</paragraph>
            <paragraph><strong>Note:</strong> If you get a relative path which starts from a unique node, the path may be longer than a normal relative path, due to the addition of the unique node's name.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-physics-process-delta-time"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-physics-process-delta-time" names="class_node_method_get_physics_process_delta_time"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>get_physics_process_delta_time</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-physics-process-delta-time"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns the time elapsed (in seconds) since the last physics callback. This value is identical to <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference>'s <literal>delta</literal> parameter, and is often consistent at run-time, unless <reference internal="True" refuri="class_engine#class-engine-property-physics-ticks-per-second"><inline classes="std std-ref">Engine.physics_ticks_per_second</inline></reference> is changed. See also <reference internal="True" refid="class-node-constant-notification-physics-process"><inline classes="std std-ref">NOTIFICATION_PHYSICS_PROCESS</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> The returned value will be larger than expected if running at a framerate lower than <reference internal="True" refuri="class_engine#class-engine-property-physics-ticks-per-second"><inline classes="std std-ref">Engine.physics_ticks_per_second</inline></reference> / <reference internal="True" refuri="class_engine#class-engine-property-max-physics-steps-per-frame"><inline classes="std std-ref">Engine.max_physics_steps_per_frame</inline></reference> FPS. This is done to avoid "spiral of death" scenarios where performance would plummet due to an ever-increasing number of physics steps per frame. This behavior affects both <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference> and <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference>. As a result, avoid using <literal>delta</literal> for time measurements in real-world seconds. Use the <reference internal="True" refuri="class_time#class-time"><inline classes="std std-ref">Time</inline></reference> singleton's methods for this purpose instead, such as <reference internal="True" refuri="class_time#class-time-method-get-ticks-usec"><inline classes="std std-ref">Time.get_ticks_usec()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-process-delta-time"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-process-delta-time" names="class_node_method_get_process_delta_time"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>get_process_delta_time</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-process-delta-time"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns the time elapsed (in seconds) since the last process callback. This value is identical to <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference>'s <literal>delta</literal> parameter, and may vary from frame to frame. See also <reference internal="True" refid="class-node-constant-notification-process"><inline classes="std std-ref">NOTIFICATION_PROCESS</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> The returned value will be larger than expected if running at a framerate lower than <reference internal="True" refuri="class_engine#class-engine-property-physics-ticks-per-second"><inline classes="std std-ref">Engine.physics_ticks_per_second</inline></reference> / <reference internal="True" refuri="class_engine#class-engine-property-max-physics-steps-per-frame"><inline classes="std std-ref">Engine.max_physics_steps_per_frame</inline></reference> FPS. This is done to avoid "spiral of death" scenarios where performance would plummet due to an ever-increasing number of physics steps per frame. This behavior affects both <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference> and <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference>. As a result, avoid using <literal>delta</literal> for time measurements in real-world seconds. Use the <reference internal="True" refuri="class_time#class-time"><inline classes="std std-ref">Time</inline></reference> singleton's methods for this purpose instead, such as <reference internal="True" refuri="class_time#class-time-method-get-ticks-usec"><inline classes="std std-ref">Time.get_ticks_usec()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-scene-instance-load-placeholder"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-scene-instance-load-placeholder" names="class_node_method_get_scene_instance_load_placeholder"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>get_scene_instance_load_placeholder</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-scene-instance-load-placeholder"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if this node is an instance load placeholder. See <reference internal="True" refuri="class_instanceplaceholder#class-instanceplaceholder"><inline classes="std std-ref">InstancePlaceholder</inline></reference> and <reference internal="True" refid="class-node-method-set-scene-instance-load-placeholder"><inline classes="std std-ref">set_scene_instance_load_placeholder()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-tree"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-tree" names="class_node_method_get_tree"><reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> <strong>get_tree</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-tree"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> that contains this node. If this node is not inside the tree, generates an error and returns <literal>null</literal>. See also <reference internal="True" refid="class-node-method-is-inside-tree"><inline classes="std std-ref">is_inside_tree()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-tree-string"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-tree-string" names="class_node_method_get_tree_string"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_tree_string</strong>() <reference internal="True" refid="class-node-method-get-tree-string"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns the tree as a <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>. Used mainly for debugging purposes. This version displays the path relative to the current node, and is good for copy/pasting into the <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node()</inline></reference> function. It also can be used in game UI/UX.</paragraph>
            <paragraph>May print, for example:</paragraph>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">TheGame
TheGame/Menu
TheGame/Menu/Label
TheGame/Menu/Camera2D
TheGame/SplashScreen
TheGame/SplashScreen/Camera2D</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-tree-string-pretty"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-tree-string-pretty" names="class_node_method_get_tree_string_pretty"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_tree_string_pretty</strong>() <reference internal="True" refid="class-node-method-get-tree-string-pretty"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Similar to <reference internal="True" refid="class-node-method-get-tree-string"><inline classes="std std-ref">get_tree_string()</inline></reference>, this returns the tree as a <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>. This version displays a more graphical representation similar to what is displayed in the Scene Dock. It is useful for inspecting larger trees.</paragraph>
            <paragraph>May print, for example:</paragraph>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">TheGame
   Menu
     Label
     Camera2D
   SplashScreen
      Camera2D</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-viewport"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-viewport" names="class_node_method_get_viewport"><reference internal="True" refuri="class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> <strong>get_viewport</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-viewport"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns the node's closest <reference internal="True" refuri="class_viewport#class-viewport"><inline classes="std std-ref">Viewport</inline></reference> ancestor, if the node is inside the tree. Otherwise, returns <literal>null</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-get-window"></target>
            <paragraph classes="classref-method" ids="class-node-method-get-window" names="class_node_method_get_window"><reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> <strong>get_window</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-get-window"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns the <reference internal="True" refuri="class_window#class-window"><inline classes="std std-ref">Window</inline></reference> that contains this node. If the node is in the main window, this is equivalent to getting the root node (<literal>get_tree().get_root()</literal>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-has-node"></target>
            <paragraph classes="classref-method" ids="class-node-method-has-node" names="class_node_method_has_node"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>has_node</strong>(path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-has-node"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the <literal>path</literal> points to a valid node. See also <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-has-node-and-resource"></target>
            <paragraph classes="classref-method" ids="class-node-method-has-node-and-resource" names="class_node_method_has_node_and_resource"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>has_node_and_resource</strong>(path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-has-node-and-resource"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if <literal>path</literal> points to a valid node and its subnames point to a valid <reference internal="True" refuri="class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>, e.g. <literal>Area2D/CollisionShape2D:shape</literal>. Properties that are not <reference internal="True" refuri="class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> types (such as nodes or other <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> types) are not considered. See also <reference internal="True" refid="class-node-method-get-node-and-resource"><inline classes="std std-ref">get_node_and_resource()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-ancestor-of"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-ancestor-of" names="class_node_method_is_ancestor_of"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_ancestor_of</strong>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-ancestor-of"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the given <literal>node</literal> is a direct or indirect child of this node.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-displayed-folded"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-displayed-folded" names="class_node_method_is_displayed_folded"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_displayed_folded</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-displayed-folded"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the node is folded (collapsed) in the Scene dock. This method is intended to be used in editor plugins and tools. See also <reference internal="True" refid="class-node-method-set-display-folded"><inline classes="std std-ref">set_display_folded()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-editable-instance"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-editable-instance" names="class_node_method_is_editable_instance"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_editable_instance</strong>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-editable-instance"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if <literal>node</literal> has editable children enabled relative to this node. This method is intended to be used in editor plugins and tools. See also <reference internal="True" refid="class-node-method-set-editable-instance"><inline classes="std std-ref">set_editable_instance()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-greater-than"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-greater-than" names="class_node_method_is_greater_than"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_greater_than</strong>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-greater-than"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the given <literal>node</literal> occurs later in the scene hierarchy than this node. A node occurring later is usually processed last.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-in-group"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-in-group" names="class_node_method_is_in_group"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_in_group</strong>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-in-group"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if this node has been added to the given <literal>group</literal>. See <reference internal="True" refid="class-node-method-add-to-group"><inline classes="std std-ref">add_to_group()</inline></reference> and <reference internal="True" refid="class-node-method-remove-from-group"><inline classes="std std-ref">remove_from_group()</inline></reference>. See also notes in the description, and the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>'s group methods.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-inside-tree"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-inside-tree" names="class_node_method_is_inside_tree"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_inside_tree</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-inside-tree"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if this node is currently inside a <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>. See also <reference internal="True" refid="class-node-method-get-tree"><inline classes="std std-ref">get_tree()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-multiplayer-authority"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-multiplayer-authority" names="class_node_method_is_multiplayer_authority"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_multiplayer_authority</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-multiplayer-authority"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the local system is the multiplayer authority of this node.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-node-ready"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-node-ready" names="class_node_method_is_node_ready"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_node_ready</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-node-ready"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the node is ready, i.e. it's inside scene tree and all its children are initialized.</paragraph>
            <paragraph><reference internal="True" refid="class-node-method-request-ready"><inline classes="std std-ref">request_ready()</inline></reference> resets it back to <literal>false</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-part-of-edited-scene"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-part-of-edited-scene" names="class_node_method_is_part_of_edited_scene"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_part_of_edited_scene</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-part-of-edited-scene"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the node is part of the scene currently opened in the editor.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-physics-interpolated"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-physics-interpolated" names="class_node_method_is_physics_interpolated"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_physics_interpolated</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-physics-interpolated"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if physics interpolation is enabled for this node (see <reference internal="True" refid="class-node-property-physics-interpolation-mode"><inline classes="std std-ref">physics_interpolation_mode</inline></reference>).</paragraph>
            <paragraph><strong>Note:</strong> Interpolation will only be active if both the flag is set <strong>and</strong> physics interpolation is enabled within the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>. This can be tested using <reference internal="True" refid="class-node-method-is-physics-interpolated-and-enabled"><inline classes="std std-ref">is_physics_interpolated_and_enabled()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-physics-interpolated-and-enabled"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-physics-interpolated-and-enabled" names="class_node_method_is_physics_interpolated_and_enabled"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_physics_interpolated_and_enabled</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-physics-interpolated-and-enabled"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if physics interpolation is enabled (see <reference internal="True" refid="class-node-property-physics-interpolation-mode"><inline classes="std std-ref">physics_interpolation_mode</inline></reference>) <strong>and</strong> enabled in the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>.</paragraph>
            <paragraph>This is a convenience version of <reference internal="True" refid="class-node-method-is-physics-interpolated"><inline classes="std std-ref">is_physics_interpolated()</inline></reference> that also checks whether physics interpolation is enabled globally.</paragraph>
            <paragraph>See <reference internal="True" refuri="class_scenetree#class-scenetree-property-physics-interpolation"><inline classes="std std-ref">SceneTree.physics_interpolation</inline></reference> and <reference internal="True" refuri="class_projectsettings#class-projectsettings-property-physics-common-physics-interpolation"><inline classes="std std-ref">ProjectSettings.physics/common/physics_interpolation</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-physics-processing"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-physics-processing" names="class_node_method_is_physics_processing"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_physics_processing</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-physics-processing"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if physics processing is enabled (see <reference internal="True" refid="class-node-method-set-physics-process"><inline classes="std std-ref">set_physics_process()</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-physics-processing-internal"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-physics-processing-internal" names="class_node_method_is_physics_processing_internal"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_physics_processing_internal</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-physics-processing-internal"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if internal physics processing is enabled (see <reference internal="True" refid="class-node-method-set-physics-process-internal"><inline classes="std std-ref">set_physics_process_internal()</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-processing"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-processing" names="class_node_method_is_processing"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_processing</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-processing"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if processing is enabled (see <reference internal="True" refid="class-node-method-set-process"><inline classes="std std-ref">set_process()</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-processing-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-processing-input" names="class_node_method_is_processing_input"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_processing_input</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-processing-input"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the node is processing input (see <reference internal="True" refid="class-node-method-set-process-input"><inline classes="std std-ref">set_process_input()</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-processing-internal"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-processing-internal" names="class_node_method_is_processing_internal"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_processing_internal</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-processing-internal"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if internal processing is enabled (see <reference internal="True" refid="class-node-method-set-process-internal"><inline classes="std std-ref">set_process_internal()</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-processing-shortcut-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-processing-shortcut-input" names="class_node_method_is_processing_shortcut_input"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_processing_shortcut_input</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-processing-shortcut-input"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the node is processing shortcuts (see <reference internal="True" refid="class-node-method-set-process-shortcut-input"><inline classes="std std-ref">set_process_shortcut_input()</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-processing-unhandled-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-processing-unhandled-input" names="class_node_method_is_processing_unhandled_input"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_processing_unhandled_input</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-processing-unhandled-input"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the node is processing unhandled input (see <reference internal="True" refid="class-node-method-set-process-unhandled-input"><inline classes="std std-ref">set_process_unhandled_input()</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-is-processing-unhandled-key-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-is-processing-unhandled-key-input" names="class_node_method_is_processing_unhandled_key_input"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_processing_unhandled_key_input</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-node-method-is-processing-unhandled-key-input"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the node is processing unhandled key input (see <reference internal="True" refid="class-node-method-set-process-unhandled-key-input"><inline classes="std std-ref">set_process_unhandled_key_input()</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-move-child"></target>
            <paragraph classes="classref-method" ids="class-node-method-move-child" names="class_node_method_move_child"><abbreviation explanation="No return value.">void</abbreviation> <strong>move_child</strong>(child_node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>, to_index: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-node-method-move-child"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Moves <literal>child_node</literal> to the given index. A node's index is the order among its siblings. If <literal>to_index</literal> is negative, the index is counted from the end of the list. See also <reference internal="True" refid="class-node-method-get-child"><inline classes="std std-ref">get_child()</inline></reference> and <reference internal="True" refid="class-node-method-get-index"><inline classes="std std-ref">get_index()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> The processing order of several engine callbacks (<reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference>, <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference>, etc.) and notifications sent through <reference internal="True" refid="class-node-method-propagate-notification"><inline classes="std std-ref">propagate_notification()</inline></reference> is affected by tree order. <reference internal="True" refuri="class_canvasitem#class-canvasitem"><inline classes="std std-ref">CanvasItem</inline></reference> nodes are also rendered in tree order. See also <reference internal="True" refid="class-node-property-process-priority"><inline classes="std std-ref">process_priority</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-notify-deferred-thread-group"></target>
            <paragraph classes="classref-method" ids="class-node-method-notify-deferred-thread-group" names="class_node_method_notify_deferred_thread_group"><abbreviation explanation="No return value.">void</abbreviation> <strong>notify_deferred_thread_group</strong>(what: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-node-method-notify-deferred-thread-group"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Similar to <reference internal="True" refid="class-node-method-call-deferred-thread-group"><inline classes="std std-ref">call_deferred_thread_group()</inline></reference>, but for notifications.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-notify-thread-safe"></target>
            <paragraph classes="classref-method" ids="class-node-method-notify-thread-safe" names="class_node_method_notify_thread_safe"><abbreviation explanation="No return value.">void</abbreviation> <strong>notify_thread_safe</strong>(what: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-node-method-notify-thread-safe"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Similar to <reference internal="True" refid="class-node-method-call-thread-safe"><inline classes="std std-ref">call_thread_safe()</inline></reference>, but for notifications.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-print-orphan-nodes"></target>
            <paragraph classes="classref-method" ids="class-node-method-print-orphan-nodes" names="class_node_method_print_orphan_nodes"><abbreviation explanation="No return value.">void</abbreviation> <strong>print_orphan_nodes</strong>() <abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation> <reference internal="True" refid="class-node-method-print-orphan-nodes"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Prints all orphan nodes (nodes outside the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>). Useful for debugging.</paragraph>
            <paragraph><strong>Note:</strong> This method only works in debug builds. It does nothing in a project exported in release mode.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-print-tree"></target>
            <paragraph classes="classref-method" ids="class-node-method-print-tree" names="class_node_method_print_tree"><abbreviation explanation="No return value.">void</abbreviation> <strong>print_tree</strong>() <reference internal="True" refid="class-node-method-print-tree"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Prints the node and its children to the console, recursively. The node does not have to be inside the tree. This method outputs <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>s relative to this node, and is good for copy/pasting into <reference internal="True" refid="class-node-method-get-node"><inline classes="std std-ref">get_node()</inline></reference>. See also <reference internal="True" refid="class-node-method-print-tree-pretty"><inline classes="std std-ref">print_tree_pretty()</inline></reference>.</paragraph>
            <paragraph>May print, for example:</paragraph>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">.
Menu
Menu/Label
Menu/Camera2D
SplashScreen
SplashScreen/Camera2D</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-print-tree-pretty"></target>
            <paragraph classes="classref-method" ids="class-node-method-print-tree-pretty" names="class_node_method_print_tree_pretty"><abbreviation explanation="No return value.">void</abbreviation> <strong>print_tree_pretty</strong>() <reference internal="True" refid="class-node-method-print-tree-pretty"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Prints the node and its children to the console, recursively. The node does not have to be inside the tree. Similar to <reference internal="True" refid="class-node-method-print-tree"><inline classes="std std-ref">print_tree()</inline></reference>, but the graphical representation looks like what is displayed in the editor's Scene dock. It is useful for inspecting larger trees.</paragraph>
            <paragraph>May print, for example:</paragraph>
            <literal_block force="False" highlight_args="{}" language="text" linenos="False" xml:space="preserve">TheGame
   Menu
     Label
     Camera2D
   SplashScreen
      Camera2D</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-propagate-call"></target>
            <paragraph classes="classref-method" ids="class-node-method-propagate-call" names="class_node_method_propagate_call"><abbreviation explanation="No return value.">void</abbreviation> <strong>propagate_call</strong>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, args: <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> = [], parent_first: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <reference internal="True" refid="class-node-method-propagate-call"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Calls the given <literal>method</literal> name, passing <literal>args</literal> as arguments, on this node and all of its children, recursively.</paragraph>
            <paragraph>If <literal>parent_first</literal> is <literal>true</literal>, the method is called on this node first, then on all of its children. If <literal>false</literal>, the children's methods are called first.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-propagate-notification"></target>
            <paragraph classes="classref-method" ids="class-node-method-propagate-notification" names="class_node_method_propagate_notification"><abbreviation explanation="No return value.">void</abbreviation> <strong>propagate_notification</strong>(what: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-node-method-propagate-notification"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Calls <reference internal="True" refuri="class_object#class-object-method-notification"><inline classes="std std-ref">Object.notification()</inline></reference> with <literal>what</literal> on this node and all of its children, recursively.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-queue-accessibility-update"></target>
            <paragraph classes="classref-method" ids="class-node-method-queue-accessibility-update" names="class_node_method_queue_accessibility_update"><abbreviation explanation="No return value.">void</abbreviation> <strong>queue_accessibility_update</strong>() <reference internal="True" refid="class-node-method-queue-accessibility-update"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Queues an accessibility information update for this node.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-queue-free"></target>
            <paragraph classes="classref-method" ids="class-node-method-queue-free" names="class_node_method_queue_free"><abbreviation explanation="No return value.">void</abbreviation> <strong>queue_free</strong>() <reference internal="True" refid="class-node-method-queue-free"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Queues this node to be deleted at the end of the current frame. When deleted, all of its children are deleted as well, and all references to the node and its children become invalid.</paragraph>
            <paragraph>Unlike with <reference internal="True" refuri="class_object#class-object-method-free"><inline classes="std std-ref">Object.free()</inline></reference>, the node is not deleted instantly, and it can still be accessed before deletion. It is also safe to call <reference internal="True" refid="class-node-method-queue-free"><inline classes="std std-ref">queue_free()</inline></reference> multiple times. Use <reference internal="True" refuri="class_object#class-object-method-is-queued-for-deletion"><inline classes="std std-ref">Object.is_queued_for_deletion()</inline></reference> to check if the node will be deleted at the end of the frame.</paragraph>
            <paragraph><strong>Note:</strong> The node will only be freed after all other deferred calls are finished. Using this method is not always the same as calling <reference internal="True" refuri="class_object#class-object-method-free"><inline classes="std std-ref">Object.free()</inline></reference> through <reference internal="True" refuri="class_object#class-object-method-call-deferred"><inline classes="std std-ref">Object.call_deferred()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-remove-child"></target>
            <paragraph classes="classref-method" ids="class-node-method-remove-child" names="class_node_method_remove_child"><abbreviation explanation="No return value.">void</abbreviation> <strong>remove_child</strong>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>) <reference internal="True" refid="class-node-method-remove-child"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Removes a child <literal>node</literal>. The <literal>node</literal>, along with its children, are <strong>not</strong> deleted. To delete a node, see <reference internal="True" refid="class-node-method-queue-free"><inline classes="std std-ref">queue_free()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> When this node is inside the tree, this method sets the <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> of the removed <literal>node</literal> (or its descendants) to <literal>null</literal>, if their <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> is no longer an ancestor (see <reference internal="True" refid="class-node-method-is-ancestor-of"><inline classes="std std-ref">is_ancestor_of()</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-remove-from-group"></target>
            <paragraph classes="classref-method" ids="class-node-method-remove-from-group" names="class_node_method_remove_from_group"><abbreviation explanation="No return value.">void</abbreviation> <strong>remove_from_group</strong>(group: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <reference internal="True" refid="class-node-method-remove-from-group"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Removes the node from the given <literal>group</literal>. Does nothing if the node is not in the <literal>group</literal>. See also notes in the description, and the <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference>'s group methods.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-reparent"></target>
            <paragraph classes="classref-method" ids="class-node-method-reparent" names="class_node_method_reparent"><abbreviation explanation="No return value.">void</abbreviation> <strong>reparent</strong>(new_parent: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>, keep_global_transform: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <reference internal="True" refid="class-node-method-reparent"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Changes the parent of this <strong>Node</strong> to the <literal>new_parent</literal>. The node needs to already have a parent. The node's <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> is preserved if its owner is still reachable from the new location (i.e., the node is still a descendant of the new parent after the operation).</paragraph>
            <paragraph>If <literal>keep_global_transform</literal> is <literal>true</literal>, the node's global transform will be preserved if supported. <reference internal="True" refuri="class_node2d#class-node2d"><inline classes="std std-ref">Node2D</inline></reference>, <reference internal="True" refuri="class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> and <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> support this argument (but <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> keeps only position).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-replace-by"></target>
            <paragraph classes="classref-method" ids="class-node-method-replace-by" names="class_node_method_replace_by"><abbreviation explanation="No return value.">void</abbreviation> <strong>replace_by</strong>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>, keep_groups: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <reference internal="True" refid="class-node-method-replace-by"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Replaces this node by the given <literal>node</literal>. All children of this node are moved to <literal>node</literal>.</paragraph>
            <paragraph>If <literal>keep_groups</literal> is <literal>true</literal>, the <literal>node</literal> is added to the same groups that the replaced node is in (see <reference internal="True" refid="class-node-method-add-to-group"><inline classes="std std-ref">add_to_group()</inline></reference>).</paragraph>
            <paragraph><strong>Warning:</strong> The replaced node is removed from the tree, but it is <strong>not</strong> deleted. To prevent memory leaks, store a reference to the node in a variable, or use <reference internal="True" refuri="class_object#class-object-method-free"><inline classes="std std-ref">Object.free()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-request-ready"></target>
            <paragraph classes="classref-method" ids="class-node-method-request-ready" names="class_node_method_request_ready"><abbreviation explanation="No return value.">void</abbreviation> <strong>request_ready</strong>() <reference internal="True" refid="class-node-method-request-ready"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Requests <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> to be called again the next time the node enters the tree. Does <strong>not</strong> immediately call <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This method only affects the current node. If the node's children also need to request ready, this method needs to be called for each one of them. When the node and its children enter the tree again, the order of <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> callbacks will be the same as normal.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-reset-physics-interpolation"></target>
            <paragraph classes="classref-method" ids="class-node-method-reset-physics-interpolation" names="class_node_method_reset_physics_interpolation"><abbreviation explanation="No return value.">void</abbreviation> <strong>reset_physics_interpolation</strong>() <reference internal="True" refid="class-node-method-reset-physics-interpolation"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>When physics interpolation is active, moving a node to a radically different transform (such as placement within a level) can result in a visible glitch as the object is rendered moving from the old to new position over the physics tick.</paragraph>
            <paragraph>That glitch can be prevented by calling this method, which temporarily disables interpolation until the physics tick is complete.</paragraph>
            <paragraph>The notification <reference internal="True" refid="class-node-constant-notification-reset-physics-interpolation"><inline classes="std std-ref">NOTIFICATION_RESET_PHYSICS_INTERPOLATION</inline></reference> will be received by the node and all children recursively.</paragraph>
            <paragraph><strong>Note:</strong> This function should be called <strong>after</strong> moving the node, rather than before.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-rpc"></target>
            <paragraph classes="classref-method" ids="class-node-method-rpc" names="class_node_method_rpc"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>rpc</strong>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <reference internal="True" refid="class-node-method-rpc"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Sends a remote procedure call request for the given <literal>method</literal> to peers on the network (and locally), sending additional arguments to the method called by the RPC. The call request will only be received by nodes with the same <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>, including the exact same <reference internal="True" refid="class-node-property-name"><inline classes="std std-ref">name</inline></reference>. Behavior depends on the RPC configuration for the given <literal>method</literal> (see <reference internal="True" refid="class-node-method-rpc-config"><inline classes="std std-ref">rpc_config()</inline></reference> and <reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-rpc"><inline classes="std std-ref">@GDScript.@rpc</inline></reference>). By default, methods are not exposed to RPCs.</paragraph>
            <paragraph>May return <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-ok"><inline classes="std std-ref">@GlobalScope.OK</inline></reference> if the call is successful, <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-invalid-parameter"><inline classes="std std-ref">@GlobalScope.ERR_INVALID_PARAMETER</inline></reference> if the arguments passed in the <literal>method</literal> do not match, <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-unconfigured"><inline classes="std std-ref">@GlobalScope.ERR_UNCONFIGURED</inline></reference> if the node's <reference internal="True" refid="class-node-property-multiplayer"><inline classes="std std-ref">multiplayer</inline></reference> cannot be fetched (such as when the node is not inside the tree), <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-connection-error"><inline classes="std std-ref">@GlobalScope.ERR_CONNECTION_ERROR</inline></reference> if <reference internal="True" refid="class-node-property-multiplayer"><inline classes="std std-ref">multiplayer</inline></reference>'s connection is not available.</paragraph>
            <paragraph><strong>Note:</strong> You can only safely use RPCs on clients after you received the <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi-signal-connected-to-server"><inline classes="std std-ref">MultiplayerAPI.connected_to_server</inline></reference> signal from the <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference>. You also need to keep track of the connection state, either by the <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference> signals like <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi-signal-server-disconnected"><inline classes="std std-ref">MultiplayerAPI.server_disconnected</inline></reference> or by checking (<literal>get_multiplayer().peer.get_connection_status() == CONNECTION_CONNECTED</literal>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-rpc-config"></target>
            <paragraph classes="classref-method" ids="class-node-method-rpc-config" names="class_node_method_rpc_config"><abbreviation explanation="No return value.">void</abbreviation> <strong>rpc_config</strong>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, config: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-node-method-rpc-config"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Changes the RPC configuration for the given <literal>method</literal>. <literal>config</literal> should either be <literal>null</literal> to disable the feature (as by default), or a <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> containing the following entries:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>rpc_mode</literal>: see <reference internal="True" refuri="class_multiplayerapi#enum-multiplayerapi-rpcmode"><inline classes="std std-ref">RPCMode</inline></reference>;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>transfer_mode</literal>: see <reference internal="True" refuri="class_multiplayerpeer#enum-multiplayerpeer-transfermode"><inline classes="std std-ref">TransferMode</inline></reference>;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>call_local</literal>: if <literal>true</literal>, the method will also be called locally;</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>channel</literal>: an <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> representing the channel to send the RPC on.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>Note:</strong> In GDScript, this method corresponds to the <reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-rpc"><inline classes="std std-ref">@GDScript.@rpc</inline></reference> annotation, with various parameters passed (<literal>@rpc(any)</literal>, <literal>@rpc(authority)</literal>...). See also the <reference internal="True" refuri="../tutorials/networking/high_level_multiplayer"><inline classes="doc">high-level multiplayer</inline></reference> tutorial.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-rpc-id"></target>
            <paragraph classes="classref-method" ids="class-node-method-rpc-id" names="class_node_method_rpc_id"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>rpc_id</strong>(peer_id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation> <reference internal="True" refid="class-node-method-rpc-id"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Sends a <reference internal="True" refid="class-node-method-rpc"><inline classes="std std-ref">rpc()</inline></reference> to a specific peer identified by <literal>peer_id</literal> (see <reference internal="True" refuri="class_multiplayerpeer#class-multiplayerpeer-method-set-target-peer"><inline classes="std std-ref">MultiplayerPeer.set_target_peer()</inline></reference>).</paragraph>
            <paragraph>May return <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-ok"><inline classes="std std-ref">@GlobalScope.OK</inline></reference> if the call is successful, <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-invalid-parameter"><inline classes="std std-ref">@GlobalScope.ERR_INVALID_PARAMETER</inline></reference> if the arguments passed in the <literal>method</literal> do not match, <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-unconfigured"><inline classes="std std-ref">@GlobalScope.ERR_UNCONFIGURED</inline></reference> if the node's <reference internal="True" refid="class-node-property-multiplayer"><inline classes="std std-ref">multiplayer</inline></reference> cannot be fetched (such as when the node is not inside the tree), <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-connection-error"><inline classes="std std-ref">@GlobalScope.ERR_CONNECTION_ERROR</inline></reference> if <reference internal="True" refid="class-node-property-multiplayer"><inline classes="std std-ref">multiplayer</inline></reference>'s connection is not available.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-deferred-thread-group"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-deferred-thread-group" names="class_node_method_set_deferred_thread_group"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_deferred_thread_group</strong>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-node-method-set-deferred-thread-group"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Similar to <reference internal="True" refid="class-node-method-call-deferred-thread-group"><inline classes="std std-ref">call_deferred_thread_group()</inline></reference>, but for setting properties.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-display-folded"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-display-folded" names="class_node_method_set_display_folded"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_display_folded</strong>(fold: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>) <reference internal="True" refid="class-node-method-set-display-folded"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>If set to <literal>true</literal>, the node appears folded in the Scene dock. As a result, all of its children are hidden. This method is intended to be used in editor plugins and tools, but it also works in release builds. See also <reference internal="True" refid="class-node-method-is-displayed-folded"><inline classes="std std-ref">is_displayed_folded()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-editable-instance"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-editable-instance" names="class_node_method_set_editable_instance"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_editable_instance</strong>(node: <reference internal="True" refid="class-node"><inline classes="std std-ref">Node</inline></reference>, is_editable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>) <reference internal="True" refid="class-node-method-set-editable-instance"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Set to <literal>true</literal> to allow all nodes owned by <literal>node</literal> to be available, and editable, in the Scene dock, even if their <reference internal="True" refid="class-node-property-owner"><inline classes="std std-ref">owner</inline></reference> is not the scene root. This method is intended to be used in editor plugins and tools, but it also works in release builds. See also <reference internal="True" refid="class-node-method-is-editable-instance"><inline classes="std std-ref">is_editable_instance()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-multiplayer-authority"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-multiplayer-authority" names="class_node_method_set_multiplayer_authority"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_multiplayer_authority</strong>(id: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, recursive: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = true) <reference internal="True" refid="class-node-method-set-multiplayer-authority"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Sets the node's multiplayer authority to the peer with the given peer <literal>id</literal>. The multiplayer authority is the peer that has authority over the node on the network. Defaults to peer ID 1 (the server). Useful in conjunction with <reference internal="True" refid="class-node-method-rpc-config"><inline classes="std std-ref">rpc_config()</inline></reference> and the <reference internal="True" refuri="class_multiplayerapi#class-multiplayerapi"><inline classes="std std-ref">MultiplayerAPI</inline></reference>.</paragraph>
            <paragraph>If <literal>recursive</literal> is <literal>true</literal>, the given peer is recursively set as the authority for all children of this node.</paragraph>
            <paragraph><strong>Warning:</strong> This does <strong>not</strong> automatically replicate the new authority to other peers. It is the developer's responsibility to do so. You may replicate the new authority's information using <reference internal="True" refuri="class_multiplayerspawner#class-multiplayerspawner-property-spawn-function"><inline classes="std std-ref">MultiplayerSpawner.spawn_function</inline></reference>, an RPC, or a <reference internal="True" refuri="class_multiplayersynchronizer#class-multiplayersynchronizer"><inline classes="std std-ref">MultiplayerSynchronizer</inline></reference>. Furthermore, the parent's authority does <strong>not</strong> propagate to newly added children.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-physics-process"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-physics-process" names="class_node_method_set_physics_process"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_physics_process</strong>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>) <reference internal="True" refid="class-node-method-set-physics-process"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>If set to <literal>true</literal>, enables physics (fixed framerate) processing. When a node is being processed, it will receive a <reference internal="True" refid="class-node-constant-notification-physics-process"><inline classes="std std-ref">NOTIFICATION_PHYSICS_PROCESS</inline></reference> at a fixed (usually 60 FPS, see <reference internal="True" refuri="class_engine#class-engine-property-physics-ticks-per-second"><inline classes="std std-ref">Engine.physics_ticks_per_second</inline></reference> to change) interval (and the <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference> callback will be called if it exists).</paragraph>
            <paragraph><strong>Note:</strong> If <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference> is overridden, this will be automatically enabled before <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> is called.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-physics-process-internal"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-physics-process-internal" names="class_node_method_set_physics_process_internal"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_physics_process_internal</strong>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>) <reference internal="True" refid="class-node-method-set-physics-process-internal"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>If set to <literal>true</literal>, enables internal physics for this node. Internal physics processing happens in isolation from the normal <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference> calls and is used by some nodes internally to guarantee proper functioning even if the node is paused or physics processing is disabled for scripting (<reference internal="True" refid="class-node-method-set-physics-process"><inline classes="std std-ref">set_physics_process()</inline></reference>).</paragraph>
            <paragraph><strong>Warning:</strong> Built-in nodes rely on internal processing for their internal logic. Disabling it is unsafe and may lead to unexpected behavior. Use this method if you know what you are doing.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-process"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-process" names="class_node_method_set_process"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_process</strong>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>) <reference internal="True" refid="class-node-method-set-process"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>If set to <literal>true</literal>, enables processing. When a node is being processed, it will receive a <reference internal="True" refid="class-node-constant-notification-process"><inline classes="std std-ref">NOTIFICATION_PROCESS</inline></reference> on every drawn frame (and the <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference> callback will be called if it exists).</paragraph>
            <paragraph><strong>Note:</strong> If <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference> is overridden, this will be automatically enabled before <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> is called.</paragraph>
            <paragraph><strong>Note:</strong> This method only affects the <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference> callback, i.e. it has no effect on other callbacks like <reference internal="True" refid="class-node-private-method-physics-process"><inline classes="std std-ref">_physics_process()</inline></reference>. If you want to disable all processing for the node, set <reference internal="True" refid="class-node-property-process-mode"><inline classes="std std-ref">process_mode</inline></reference> to <reference internal="True" refid="class-node-constant-process-mode-disabled"><inline classes="std std-ref">PROCESS_MODE_DISABLED</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-process-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-process-input" names="class_node_method_set_process_input"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_process_input</strong>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>) <reference internal="True" refid="class-node-method-set-process-input"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>If set to <literal>true</literal>, enables input processing.</paragraph>
            <paragraph><strong>Note:</strong> If <reference internal="True" refid="class-node-private-method-input"><inline classes="std std-ref">_input()</inline></reference> is overridden, this will be automatically enabled before <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> is called. Input processing is also already enabled for GUI controls, such as <reference internal="True" refuri="class_button#class-button"><inline classes="std std-ref">Button</inline></reference> and <reference internal="True" refuri="class_textedit#class-textedit"><inline classes="std std-ref">TextEdit</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-process-internal"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-process-internal" names="class_node_method_set_process_internal"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_process_internal</strong>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>) <reference internal="True" refid="class-node-method-set-process-internal"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>If set to <literal>true</literal>, enables internal processing for this node. Internal processing happens in isolation from the normal <reference internal="True" refid="class-node-private-method-process"><inline classes="std std-ref">_process()</inline></reference> calls and is used by some nodes internally to guarantee proper functioning even if the node is paused or processing is disabled for scripting (<reference internal="True" refid="class-node-method-set-process"><inline classes="std std-ref">set_process()</inline></reference>).</paragraph>
            <paragraph><strong>Warning:</strong> Built-in nodes rely on internal processing for their internal logic. Disabling it is unsafe and may lead to unexpected behavior. Use this method if you know what you are doing.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-process-shortcut-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-process-shortcut-input" names="class_node_method_set_process_shortcut_input"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_process_shortcut_input</strong>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>) <reference internal="True" refid="class-node-method-set-process-shortcut-input"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>If set to <literal>true</literal>, enables shortcut processing for this node.</paragraph>
            <paragraph><strong>Note:</strong> If <reference internal="True" refid="class-node-private-method-shortcut-input"><inline classes="std std-ref">_shortcut_input()</inline></reference> is overridden, this will be automatically enabled before <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> is called.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-process-unhandled-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-process-unhandled-input" names="class_node_method_set_process_unhandled_input"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_process_unhandled_input</strong>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>) <reference internal="True" refid="class-node-method-set-process-unhandled-input"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>If set to <literal>true</literal>, enables unhandled input processing. It enables the node to receive all input that was not previously handled (usually by a <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference>).</paragraph>
            <paragraph><strong>Note:</strong> If <reference internal="True" refid="class-node-private-method-unhandled-input"><inline classes="std std-ref">_unhandled_input()</inline></reference> is overridden, this will be automatically enabled before <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> is called. Unhandled input processing is also already enabled for GUI controls, such as <reference internal="True" refuri="class_button#class-button"><inline classes="std std-ref">Button</inline></reference> and <reference internal="True" refuri="class_textedit#class-textedit"><inline classes="std std-ref">TextEdit</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-process-unhandled-key-input"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-process-unhandled-key-input" names="class_node_method_set_process_unhandled_key_input"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_process_unhandled_key_input</strong>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>) <reference internal="True" refid="class-node-method-set-process-unhandled-key-input"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>If set to <literal>true</literal>, enables unhandled key input processing.</paragraph>
            <paragraph><strong>Note:</strong> If <reference internal="True" refid="class-node-private-method-unhandled-key-input"><inline classes="std std-ref">_unhandled_key_input()</inline></reference> is overridden, this will be automatically enabled before <reference internal="True" refid="class-node-private-method-ready"><inline classes="std std-ref">_ready()</inline></reference> is called.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-scene-instance-load-placeholder"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-scene-instance-load-placeholder" names="class_node_method_set_scene_instance_load_placeholder"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_scene_instance_load_placeholder</strong>(load_placeholder: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>) <reference internal="True" refid="class-node-method-set-scene-instance-load-placeholder"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>If set to <literal>true</literal>, the node becomes an <reference internal="True" refuri="class_instanceplaceholder#class-instanceplaceholder"><inline classes="std std-ref">InstancePlaceholder</inline></reference> when packed and instantiated from a <reference internal="True" refuri="class_packedscene#class-packedscene"><inline classes="std std-ref">PackedScene</inline></reference>. See also <reference internal="True" refid="class-node-method-get-scene-instance-load-placeholder"><inline classes="std std-ref">get_scene_instance_load_placeholder()</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-thread-safe"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-thread-safe" names="class_node_method_set_thread_safe"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_thread_safe</strong>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-node-method-set-thread-safe"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Similar to <reference internal="True" refid="class-node-method-call-thread-safe"><inline classes="std std-ref">call_thread_safe()</inline></reference>, but for setting properties.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-set-translation-domain-inherited"></target>
            <paragraph classes="classref-method" ids="class-node-method-set-translation-domain-inherited" names="class_node_method_set_translation_domain_inherited"><abbreviation explanation="No return value.">void</abbreviation> <strong>set_translation_domain_inherited</strong>() <reference internal="True" refid="class-node-method-set-translation-domain-inherited"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Makes this node inherit the translation domain from its parent node. If this node has no parent, the main translation domain will be used.</paragraph>
            <paragraph>This is the default behavior for all nodes. Calling <reference internal="True" refuri="class_object#class-object-method-set-translation-domain"><inline classes="std std-ref">Object.set_translation_domain()</inline></reference> disables this behavior.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-node-method-update-configuration-warnings"></target>
            <paragraph classes="classref-method" ids="class-node-method-update-configuration-warnings" names="class_node_method_update_configuration_warnings"><abbreviation explanation="No return value.">void</abbreviation> <strong>update_configuration_warnings</strong>() <reference internal="True" refid="class-node-method-update-configuration-warnings"><inline classes="std std-ref"></inline></reference></paragraph>
            <paragraph>Refreshes the warnings displayed for this node in the Scene dock. Use <reference internal="True" refid="class-node-private-method-get-configuration-warnings"><inline classes="std std-ref">_get_configuration_warnings()</inline></reference> to customize the warning messages to display.</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></substitution_definition>
            <substitution_definition names="required"><abbreviation explanation="This method is required to be overridden when extending its base class.">required</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="This method is used to construct a type.">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="This method describes a valid operator to use with this type as left-hand operand.">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="This value is an integer composed as a bitmask of the following flags.">BitField</abbreviation></substitution_definition>
            <substitution_definition names="void"><abbreviation explanation="No return value.">void</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
