<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_object.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/master/doc/classes/Object.xml.</comment>
    <target refid="class-object"></target>
    <section ids="object class-object" names="object class_object">
        <title>Object</title>
        <paragraph><strong>派生：</strong> <reference internal="True" refuri="class_audioserver#class-audioserver"><inline classes="std std-ref">AudioServer</inline></reference>, <reference internal="True" refuri="class_cameraserver#class-cameraserver"><inline classes="std std-ref">CameraServer</inline></reference>, <reference internal="True" refuri="class_classdb#class-classdb"><inline classes="std std-ref">ClassDB</inline></reference>, <reference internal="True" refuri="class_displayserver#class-displayserver"><inline classes="std std-ref">DisplayServer</inline></reference>, <reference internal="True" refuri="class_editorfilesystemdirectory#class-editorfilesystemdirectory"><inline classes="std std-ref">EditorFileSystemDirectory</inline></reference>, <reference internal="True" refuri="class_editorinterface#class-editorinterface"><inline classes="std std-ref">EditorInterface</inline></reference>, <reference internal="True" refuri="class_editorpaths#class-editorpaths"><inline classes="std std-ref">EditorPaths</inline></reference>, <reference internal="True" refuri="class_editorselection#class-editorselection"><inline classes="std std-ref">EditorSelection</inline></reference>, <reference internal="True" refuri="class_editorundoredomanager#class-editorundoredomanager"><inline classes="std std-ref">EditorUndoRedoManager</inline></reference>, <reference internal="True" refuri="class_editorvcsinterface#class-editorvcsinterface"><inline classes="std std-ref">EditorVCSInterface</inline></reference>, <reference internal="True" refuri="class_engine#class-engine"><inline classes="std std-ref">Engine</inline></reference>, <reference internal="True" refuri="class_enginedebugger#class-enginedebugger"><inline classes="std std-ref">EngineDebugger</inline></reference>, <reference internal="True" refuri="class_framebuffercacherd#class-framebuffercacherd"><inline classes="std std-ref">FramebufferCacheRD</inline></reference>, <reference internal="True" refuri="class_gdextensionmanager#class-gdextensionmanager"><inline classes="std std-ref">GDExtensionManager</inline></reference>, <reference internal="True" refuri="class_geometry2d#class-geometry2d"><inline classes="std std-ref">Geometry2D</inline></reference>, <reference internal="True" refuri="class_geometry3d#class-geometry3d"><inline classes="std std-ref">Geometry3D</inline></reference>, <reference internal="True" refuri="class_input#class-input"><inline classes="std std-ref">Input</inline></reference>, <reference internal="True" refuri="class_inputmap#class-inputmap"><inline classes="std std-ref">InputMap</inline></reference>, <reference internal="True" refuri="class_ip#class-ip"><inline classes="std std-ref">IP</inline></reference>, <reference internal="True" refuri="class_javaclasswrapper#class-javaclasswrapper"><inline classes="std std-ref">JavaClassWrapper</inline></reference>, <reference internal="True" refuri="class_javascriptbridge#class-javascriptbridge"><inline classes="std std-ref">JavaScriptBridge</inline></reference>, <reference internal="True" refuri="class_jnisingleton#class-jnisingleton"><inline classes="std std-ref">JNISingleton</inline></reference>, <reference internal="True" refuri="class_jsonrpc#class-jsonrpc"><inline classes="std std-ref">JSONRPC</inline></reference>, <reference internal="True" refuri="class_mainloop#class-mainloop"><inline classes="std std-ref">MainLoop</inline></reference>, <reference internal="True" refuri="class_marshalls#class-marshalls"><inline classes="std std-ref">Marshalls</inline></reference>, <reference internal="True" refuri="class_moviewriter#class-moviewriter"><inline classes="std std-ref">MovieWriter</inline></reference>, <reference internal="True" refuri="class_nativemenu#class-nativemenu"><inline classes="std std-ref">NativeMenu</inline></reference>, <reference internal="True" refuri="class_navigationmeshgenerator#class-navigationmeshgenerator"><inline classes="std std-ref">NavigationMeshGenerator</inline></reference>, <reference internal="True" refuri="class_navigationserver2d#class-navigationserver2d"><inline classes="std std-ref">NavigationServer2D</inline></reference>, <reference internal="True" refuri="class_navigationserver3d#class-navigationserver3d"><inline classes="std std-ref">NavigationServer3D</inline></reference>, <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>, <reference internal="True" refuri="class_openxrextensionwrapperextension#class-openxrextensionwrapperextension"><inline classes="std std-ref">OpenXRExtensionWrapperExtension</inline></reference>, <reference internal="True" refuri="class_openxrinteractionprofilemetadata#class-openxrinteractionprofilemetadata"><inline classes="std std-ref">OpenXRInteractionProfileMetadata</inline></reference>, <reference internal="True" refuri="class_os#class-os"><inline classes="std std-ref">OS</inline></reference>, <reference internal="True" refuri="class_performance#class-performance"><inline classes="std std-ref">Performance</inline></reference>, <reference internal="True" refuri="class_physicsdirectbodystate2d#class-physicsdirectbodystate2d"><inline classes="std std-ref">PhysicsDirectBodyState2D</inline></reference>, <reference internal="True" refuri="class_physicsdirectbodystate3d#class-physicsdirectbodystate3d"><inline classes="std std-ref">PhysicsDirectBodyState3D</inline></reference>, <reference internal="True" refuri="class_physicsdirectspacestate2d#class-physicsdirectspacestate2d"><inline classes="std std-ref">PhysicsDirectSpaceState2D</inline></reference>, <reference internal="True" refuri="class_physicsdirectspacestate3d#class-physicsdirectspacestate3d"><inline classes="std std-ref">PhysicsDirectSpaceState3D</inline></reference>, <reference internal="True" refuri="class_physicsserver2d#class-physicsserver2d"><inline classes="std std-ref">PhysicsServer2D</inline></reference>, <reference internal="True" refuri="class_physicsserver2dmanager#class-physicsserver2dmanager"><inline classes="std std-ref">PhysicsServer2DManager</inline></reference>, <reference internal="True" refuri="class_physicsserver3d#class-physicsserver3d"><inline classes="std std-ref">PhysicsServer3D</inline></reference>, <reference internal="True" refuri="class_physicsserver3dmanager#class-physicsserver3dmanager"><inline classes="std std-ref">PhysicsServer3DManager</inline></reference>, <reference internal="True" refuri="class_physicsserver3drenderingserverhandler#class-physicsserver3drenderingserverhandler"><inline classes="std std-ref">PhysicsServer3DRenderingServerHandler</inline></reference>, <reference internal="True" refuri="class_projectsettings#class-projectsettings"><inline classes="std std-ref">ProjectSettings</inline></reference>, <reference internal="True" refuri="class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference>, <reference internal="True" refuri="class_renderdata#class-renderdata"><inline classes="std std-ref">RenderData</inline></reference>, <reference internal="True" refuri="class_renderingdevice#class-renderingdevice"><inline classes="std std-ref">RenderingDevice</inline></reference>, <reference internal="True" refuri="class_renderingserver#class-renderingserver"><inline classes="std std-ref">RenderingServer</inline></reference>, <reference internal="True" refuri="class_renderscenedata#class-renderscenedata"><inline classes="std std-ref">RenderSceneData</inline></reference>, <reference internal="True" refuri="class_resourceloader#class-resourceloader"><inline classes="std std-ref">ResourceLoader</inline></reference>, <reference internal="True" refuri="class_resourcesaver#class-resourcesaver"><inline classes="std std-ref">ResourceSaver</inline></reference>, <reference internal="True" refuri="class_resourceuid#class-resourceuid"><inline classes="std std-ref">ResourceUID</inline></reference>, <reference internal="True" refuri="class_scriptlanguage#class-scriptlanguage"><inline classes="std std-ref">ScriptLanguage</inline></reference>, <reference internal="True" refuri="class_textservermanager#class-textservermanager"><inline classes="std std-ref">TextServerManager</inline></reference>, <reference internal="True" refuri="class_themedb#class-themedb"><inline classes="std std-ref">ThemeDB</inline></reference>, <reference internal="True" refuri="class_tiledata#class-tiledata"><inline classes="std std-ref">TileData</inline></reference>, <reference internal="True" refuri="class_time#class-time"><inline classes="std std-ref">Time</inline></reference>, <reference internal="True" refuri="class_translationserver#class-translationserver"><inline classes="std std-ref">TranslationServer</inline></reference>, <reference internal="True" refuri="class_treeitem#class-treeitem"><inline classes="std std-ref">TreeItem</inline></reference>, <reference internal="True" refuri="class_undoredo#class-undoredo"><inline classes="std std-ref">UndoRedo</inline></reference>, <reference internal="True" refuri="class_uniformsetcacherd#class-uniformsetcacherd"><inline classes="std std-ref">UniformSetCacheRD</inline></reference>, <reference internal="True" refuri="class_workerthreadpool#class-workerthreadpool"><inline classes="std std-ref">WorkerThreadPool</inline></reference>, <reference internal="True" refuri="class_xrserver#class-xrserver"><inline classes="std std-ref">XRServer</inline></reference>, <reference internal="True" refuri="class_xrvrs#class-xrvrs"><inline classes="std std-ref">XRVRS</inline></reference></paragraph>
        <paragraph>引擎中所有其他类的基类。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>一种高级的 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> 类型。引擎中的所有类都继承自 Object。每个类都可以定义新的属性、方法或信号，并且这些对所有继承的类都可用。例如，一个 <reference internal="True" refuri="class_sprite2d#class-sprite2d"><inline classes="std std-ref">Sprite2D</inline></reference> 实例能够调用 <reference internal="True" refuri="class_node#class-node-method-add-child"><inline classes="std std-ref">Node.add_child</inline></reference> 因为它继承自 <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference>。</paragraph>
            <paragraph>可以使用 GDScript 中的 <literal>Object.new()</literal> 或 C# 中的 <literal>new GodotObject</literal> 来创建新实例。</paragraph>
            <paragraph>要删除一个 Object 实例，请调用 <reference internal="True" refid="class-object-method-free"><inline classes="std std-ref">free</inline></reference>。这对于大多数继承 Object 的类来说是必须的，因为它们本身并不管理内存，如果不调用该方法的话，在不再使用时会造成内存泄漏。有几个类会执行内存管理。例如，<reference internal="True" refuri="class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference>（以及扩展的 <reference internal="True" refuri="class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>）在不再被引用时删除自身，而 <reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference> 在释放时会删除其子节点。</paragraph>
            <paragraph>对象可以附加一个 <reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference>。一旦该 <reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference> 被实例化，它就有效地充当了基类的扩展，允许它定义和继承新的属性、方法和信号。</paragraph>
            <paragraph>在 <reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference> 中，<reference internal="True" refid="class-object-private-method-get-property-list"><inline classes="std std-ref">_get_property_list</inline></reference> 可以被可以重写，以通过多种方式自定义属性。这允许它们对编辑器可用，显示为选项列表，细分为组，保存在磁盘上，等等。脚本语言提供更简单的方式来自定义属性，例如使用 <reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-export"><inline classes="std std-ref">@GDScript.@export</inline></reference> 注解。</paragraph>
            <paragraph>Godot 是非常动态的。一个对象的脚本，以及它的属性、方法和信号，都可以在运行时改变。正因为如此，可能会出现这样的情况，例如，一个方法所需的属性可能不存在。为了防止运行时出错，可以参考 <reference internal="True" refid="class-object-method-set"><inline classes="std std-ref">set</inline></reference>、<reference internal="True" refid="class-object-method-get"><inline classes="std std-ref">get</inline></reference>、<reference internal="True" refid="class-object-method-call"><inline classes="std std-ref">call</inline></reference>、<reference internal="True" refid="class-object-method-has-method"><inline classes="std std-ref">has_method</inline></reference>、<reference internal="True" refid="class-object-method-has-signal"><inline classes="std std-ref">has_signal</inline></reference> 等方法。请注意，这些方法比直接引用慢<strong>得多</strong>。</paragraph>
            <paragraph>在 GDScript 中，还可以使用 <literal>in</literal> 运算符来检查对象中是否存在给定的属性、方法或信号名称：</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var node = Node.new()
print("name" in node)         # 输出 true
print("get_parent" in node)   # 输出 true
print("tree_entered" in node) # 输出 true
print("unknown" in node)      # 输出 false</literal_block>
            <paragraph>通知是 <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> 常量，通常由对象发送和接收。例如，在每个渲染帧上，<reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 使用 <reference internal="True" refuri="class_node#class-node-constant-notification-process"><inline classes="std std-ref">Node.NOTIFICATION_PROCESS</inline></reference> 通知树内的节点。节点收到它后，可以调用 <reference internal="True" refuri="class_node#class-node-private-method-process"><inline classes="std std-ref">Node._process</inline></reference> 进行更新。要使用通知，请参阅 <reference internal="True" refid="class-object-method-notification"><inline classes="std std-ref">notification</inline></reference> 和 <reference internal="True" refid="class-object-private-method-notification"><inline classes="std std-ref">_notification</inline></reference>。</paragraph>
            <paragraph>最后，每个对象还可以包含元数据（关于数据的数据）。<reference internal="True" refid="class-object-method-set-meta"><inline classes="std std-ref">set_meta</inline></reference> 可用于存储对象本身不依赖的信息。为了保持代码整洁，不鼓励过度使用元数据。</paragraph>
            <paragraph><strong>注意：</strong>与对 <reference internal="True" refuri="class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> 的引用不同，对存储在变量中的对象的引用，可能会在未被设置为 <literal>null</literal> 的情况下变得无效。要检查对象是否已被删除，请<emphasis>不要</emphasis>将其与 <literal>null</literal> 进行比较。而是使用 <reference internal="True" refuri="class_@globalscope#class-globalscope-method-is-instance-valid"><inline classes="std std-ref">@GlobalScope.is_instance_valid</inline></reference>。存储数据的类，建议从 <reference internal="True" refuri="class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> 继承而不是 <strong>Object</strong>。</paragraph>
            <paragraph><strong>注意：</strong><literal>script</literal> 不像大多数属性那样公开。要在代码中设置或获取一个对象的 <reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference>，请分别使用 <reference internal="True" refid="class-object-method-set-script"><inline classes="std std-ref">set_script</inline></reference> 和 <reference internal="True" refid="class-object-method-get-script"><inline classes="std std-ref">get_script</inline></reference>。</paragraph>
        </section>
        <section classes="classref-introduction-group" ids="id2" names="教程">
            <title>教程</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../contributing/development/core_and_modules/object_class"><inline classes="doc">Object 类介绍</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/best_practices/node_alternatives"><inline classes="doc">何时以及如何避免为任何事情使用节点</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/best_practices/godot_notifications"><inline classes="doc">对象通知</inline></reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="66"></colspec>
                    <colspec colwidth="234"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-private-method-get"><inline classes="std std-ref">_get</inline></reference>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-private-method-get-property-list"><inline classes="std std-ref">_get_property_list</inline></reference>() <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-private-method-init"><inline classes="std std-ref">_init</inline></reference>() <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-private-method-notification"><inline classes="std std-ref">_notification</inline></reference>(what: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-private-method-property-can-revert"><inline classes="std std-ref">_property_can_revert</inline></reference>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-private-method-property-get-revert"><inline classes="std std-ref">_property_get_revert</inline></reference>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-private-method-set"><inline classes="std std-ref">_set</inline></reference>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-private-method-to-string"><inline classes="std std-ref">_to_string</inline></reference>() <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-private-method-validate-property"><inline classes="std std-ref">_validate_property</inline></reference>(property: <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>) <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-add-user-signal"><inline classes="std std-ref">add_user_signal</inline></reference>(signal: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>, arguments: <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> = [])</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-call"><inline classes="std std-ref">call</inline></reference>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="本方法除了能接受在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-call-deferred"><inline classes="std std-ref">call_deferred</inline></reference>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="本方法除了能接受在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-callv"><inline classes="std std-ref">callv</inline></reference>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, arg_array: <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-can-translate-messages"><inline classes="std std-ref">can_translate_messages</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-cancel-free"><inline classes="std std-ref">cancel_free</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-connect"><inline classes="std std-ref">connect</inline></reference>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, callable: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, flags: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-disconnect"><inline classes="std std-ref">disconnect</inline></reference>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, callable: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-emit-signal"><inline classes="std std-ref">emit_signal</inline></reference>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="本方法除了能接受在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-free"><inline classes="std std-ref">free</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-get"><inline classes="std std-ref">get</inline></reference>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-get-class"><inline classes="std std-ref">get_class</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-get-incoming-connections"><inline classes="std std-ref">get_incoming_connections</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-get-indexed"><inline classes="std std-ref">get_indexed</inline></reference>(property_path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-get-instance-id"><inline classes="std std-ref">get_instance_id</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-get-meta"><inline classes="std std-ref">get_meta</inline></reference>(name: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, default: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> = null) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-get-meta-list"><inline classes="std std-ref">get_meta_list</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-get-method-argument-count"><inline classes="std std-ref">get_method_argument_count</inline></reference>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-get-method-list"><inline classes="std std-ref">get_method_list</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-get-property-list"><inline classes="std std-ref">get_property_list</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-get-script"><inline classes="std std-ref">get_script</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-get-signal-connection-list"><inline classes="std std-ref">get_signal_connection_list</inline></reference>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>]</paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-get-signal-list"><inline classes="std std-ref">get_signal_list</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-has-meta"><inline classes="std std-ref">has_meta</inline></reference>(name: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-has-method"><inline classes="std std-ref">has_method</inline></reference>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-has-signal"><inline classes="std std-ref">has_signal</inline></reference>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-has-user-signal"><inline classes="std std-ref">has_user_signal</inline></reference>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-is-blocking-signals"><inline classes="std std-ref">is_blocking_signals</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-is-class"><inline classes="std std-ref">is_class</inline></reference>(class: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-is-connected"><inline classes="std std-ref">is_connected</inline></reference>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, callable: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-is-queued-for-deletion"><inline classes="std std-ref">is_queued_for_deletion</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-notification"><inline classes="std std-ref">notification</inline></reference>(what: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, reversed: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-notify-property-list-changed"><inline classes="std std-ref">notify_property_list_changed</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-property-can-revert"><inline classes="std std-ref">property_can_revert</inline></reference>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-property-get-revert"><inline classes="std std-ref">property_get_revert</inline></reference>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-remove-meta"><inline classes="std std-ref">remove_meta</inline></reference>(name: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-remove-user-signal"><inline classes="std std-ref">remove_user_signal</inline></reference>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-set"><inline classes="std std-ref">set</inline></reference>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-set-block-signals"><inline classes="std std-ref">set_block_signals</inline></reference>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-set-deferred"><inline classes="std std-ref">set_deferred</inline></reference>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-set-indexed"><inline classes="std std-ref">set_indexed</inline></reference>(property_path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-set-message-translation"><inline classes="std std-ref">set_message_translation</inline></reference>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-set-meta"><inline classes="std std-ref">set_meta</inline></reference>(name: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><abbreviation explanation="无返回值。">void</abbreviation></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-set-script"><inline classes="std std-ref">set_script</inline></reference>(script: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-to-string"><inline classes="std std-ref">to_string</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-tr"><inline classes="std std-ref">tr</inline></reference>(message: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, context: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> = &amp;"") <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-object-method-tr-n"><inline classes="std std-ref">tr_n</inline></reference>(message: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, plural_message: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, n: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, context: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> = &amp;"") <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id4" names="信号">
            <title>信号</title>
            <target refid="class-object-signal-property-list-changed"></target>
            <paragraph classes="classref-signal" ids="class-object-signal-property-list-changed" names="class_object_signal_property_list_changed"><strong>property_list_changed</strong>() <reference internal="True" refid="class-object-signal-property-list-changed"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>调用 <reference internal="True" refid="class-object-method-notify-property-list-changed"><inline classes="std std-ref">notify_property_list_changed</inline></reference> 时发出。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-signal-script-changed"></target>
            <paragraph classes="classref-signal" ids="class-object-signal-script-changed" names="class_object_signal_script_changed"><strong>script_changed</strong>() <reference internal="True" refid="class-object-signal-script-changed"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>该对象的脚本发生改变时发出。</paragraph>
            <paragraph><strong>注意：</strong>发出这个信号时，新脚本还没有初始化。如果你需要访问新脚本，请用 <reference internal="True" refid="class-object-constant-connect-deferred"><inline classes="std std-ref">CONNECT_DEFERRED</inline></reference> 推迟与这个信号的连接。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id5" names="枚举">
            <title>枚举</title>
            <target refid="enum-object-connectflags"></target>
            <paragraph classes="classref-enumeration" ids="enum-object-connectflags" names="enum_object_connectflags">enum <strong>ConnectFlags</strong>: <reference internal="True" refid="enum-object-connectflags"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <target refid="class-object-constant-connect-deferred"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-object-constant-connect-deferred" names="class_object_constant_connect_deferred"><reference internal="True" refid="enum-object-connectflags"><inline classes="std std-ref">ConnectFlags</inline></reference> <strong>CONNECT_DEFERRED</strong> = <literal>1</literal></paragraph>
            <paragraph>延迟连接会在空闲时触发 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>（当前帧的末尾），不会立即触发。</paragraph>
            <target refid="class-object-constant-connect-persist"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-object-constant-connect-persist" names="class_object_constant_connect_persist"><reference internal="True" refid="enum-object-connectflags"><inline classes="std std-ref">ConnectFlags</inline></reference> <strong>CONNECT_PERSIST</strong> = <literal>2</literal></paragraph>
            <paragraph>持久连接会在序列化对象时存储（比如使用 <reference internal="True" refuri="class_packedscene#class-packedscene-method-pack"><inline classes="std std-ref">PackedScene.pack</inline></reference> 时）。在编辑器中，通过“节点”面板创建的连接总是持久的。</paragraph>
            <target refid="class-object-constant-connect-one-shot"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-object-constant-connect-one-shot" names="class_object_constant_connect_one_shot"><reference internal="True" refid="enum-object-connectflags"><inline classes="std std-ref">ConnectFlags</inline></reference> <strong>CONNECT_ONE_SHOT</strong> = <literal>4</literal></paragraph>
            <paragraph>一次性连接，会在触发后自行断开。</paragraph>
            <target refid="class-object-constant-connect-reference-counted"></target>
            <paragraph classes="classref-enumeration-constant" ids="class-object-constant-connect-reference-counted" names="class_object_constant_connect_reference_counted"><reference internal="True" refid="enum-object-connectflags"><inline classes="std std-ref">ConnectFlags</inline></reference> <strong>CONNECT_REFERENCE_COUNTED</strong> = <literal>8</literal></paragraph>
            <paragraph>引用计数连接可以多次分配给同一个 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>。每断开一次连接会让内部计数器减一。信号会在计数器变为 0 时完全断开连接。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id6" names="常量">
            <title>常量</title>
            <target refid="class-object-constant-notification-postinitialize"></target>
            <paragraph classes="classref-constant" ids="class-object-constant-notification-postinitialize" names="class_object_constant_notification_postinitialize"><strong>NOTIFICATION_POSTINITIALIZE</strong> = <literal>0</literal> <reference internal="True" refid="class-object-constant-notification-postinitialize"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>该对象初始化时收到的通知，发生在附加脚本之前。内部使用。</paragraph>
            <target refid="class-object-constant-notification-predelete"></target>
            <paragraph classes="classref-constant" ids="class-object-constant-notification-predelete" names="class_object_constant_notification_predelete"><strong>NOTIFICATION_PREDELETE</strong> = <literal>1</literal> <reference internal="True" refid="class-object-constant-notification-predelete"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>该对象即将被删除时收到的通知。可以当作其他编程语言中的析构函数。</paragraph>
            <target refid="class-object-constant-notification-extension-reloaded"></target>
            <paragraph classes="classref-constant" ids="class-object-constant-notification-extension-reloaded" names="class_object_constant_notification_extension_reloaded"><strong>NOTIFICATION_EXTENSION_RELOADED</strong> = <literal>2</literal> <reference internal="True" refid="class-object-constant-notification-extension-reloaded"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>当对象完成热重加载时收到的通知。该通知仅针对扩展类和派生类发送。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id7" names="方法说明">
            <title>方法说明</title>
            <target refid="class-object-private-method-get"></target>
            <paragraph classes="classref-method" ids="class-object-private-method-get" names="class_object_private_method__get"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>_get</strong>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <reference internal="True" refid="class-object-private-method-get"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>覆盖该方法以自定义 <reference internal="True" refid="class-object-method-get"><inline classes="std std-ref">get</inline></reference> 的行为。应该返回给定的 <literal>property</literal> 的值，或者 <literal>property</literal> 应该被正常处理时返回 <literal>null</literal>。</paragraph>
            <paragraph>结合 <reference internal="True" refid="class-object-private-method-set"><inline classes="std std-ref">_set</inline></reference> 和 <reference internal="True" refid="class-object-private-method-get-property-list"><inline classes="std std-ref">_get_property_list</inline></reference>，该方法允许定义自定义属性，这对编辑器插件特别有用。请注意，属性必须存在于 <reference internal="True" refid="class-object-method-get-property-list"><inline classes="std std-ref">get_property_list</inline></reference> 中，否则该方法不会被调用。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _get(property):
    if property == "fake_property":
        print("正在获取我的属性！")
        return 4

func _get_property_list():
    return [
        { "name": "fake_property", "type": TYPE_INT }
    ]</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override Variant _Get(StringName property)
{
    if (property == "FakeProperty")
    {
        GD.Print("正在获取我的属性！");
        return 4;
    }
    return default;
}

public override Godot.Collections.Array&lt;Godot.Collections.Dictionary&gt; _GetPropertyList()
{
    return new Godot.Collections.Array&lt;Godot.Collections.Dictionary&gt;()
    {
        new Godot.Collections.Dictionary()
        {
            { "name", "FakeProperty" },
            { "type", (int)Variant.Type.Int }
        }
    };
}</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-private-method-get-property-list"></target>
            <paragraph classes="classref-method" ids="class-object-private-method-get-property-list" names="class_object_private_method__get_property_list"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>] <strong>_get_property_list</strong>() <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <reference internal="True" refid="class-object-private-method-get-property-list"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>覆盖该方法以提供由引擎处理的额外属性的自定义列表。</paragraph>
            <paragraph>应该返回一个属性列表，作为字典的 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>。该结果被添加到 <reference internal="True" refid="class-object-method-get-property-list"><inline classes="std std-ref">get_property_list</inline></reference> 的数组中，并且应该以相同的方式进行格式化。每个 <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> 必须至少包含 <literal>name</literal> 和 <literal>type</literal> 条目。</paragraph>
            <paragraph>你可以使用 <reference internal="True" refid="class-object-private-method-property-can-revert"><inline classes="std std-ref">_property_can_revert</inline></reference> 和 <reference internal="True" refid="class-object-private-method-property-get-revert"><inline classes="std std-ref">_property_get_revert</inline></reference> 自定义该方法添加的属性的默认值。</paragraph>
            <paragraph>下面的示例显示了一个数字列表，该列表显示为从 <literal>ZERO</literal> 到 <literal>FIVE</literal> 的单词，其中 <literal>number_count</literal> 控制列表的大小：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@tool
extends Node

@export var number_count = 3:
    set(nc):
        number_count = nc
        numbers.resize(number_count)
        notify_property_list_changed()

var numbers = PackedInt32Array([0, 0, 0])

func _get_property_list():
    var properties = []

    for i in range(number_count):
        properties.append({
            "name": "number_%d" % i,
            "type": TYPE_INT,
            "hint": PROPERTY_HINT_ENUM,
            "hint_string": "ZERO,ONE,TWO,THREE,FOUR,FIVE",
        })

    return properties

func _get(property):
    if property.begins_with("number_"):
        var index = property.get_slice("_", 1).to_int()
        return numbers[index]

func _set(property, value):
    if property.begins_with("number_"):
        var index = property.get_slice("_", 1).to_int()
        numbers[index] = value
        return true
    return false</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Tool]
public partial class MyNode : Node
{
    private int _numberCount;

    [Export]
    public int NumberCount
    {
        get =&gt; _numberCount;
        set
        {
            _numberCount = value;
            _numbers.Resize(_numberCount);
            NotifyPropertyListChanged();
        }
    }

    private List&lt;int&gt; _numbers = new();

    public override Godot.Collections.Array&lt;Godot.Collections.Dictionary&gt; _GetPropertyList()
    {
        var properties = new Godot.Collections.Array&lt;Godot.Collections.Dictionary&gt;();

        for (int i = 0; i &lt; _numberCount; i++)
        {
            properties.Add(new Godot.Collections.Dictionary()
            {
                { "name", $"number_{i}" },
                { "type", (int)Variant.Type.Int },
                { "hint", (int)PropertyHint.Enum },
                { "hint_string", "Zero,One,Two,Three,Four,Five" },
            });
        }

        return properties;
    }

    public override Variant _Get(StringName property)
    {
        string propertyName = property.ToString();
        if (propertyName.StartsWith("number_"))
        {
            int index = int.Parse(propertyName.Substring("number_".Length));
            return _numbers[index];
        }
        return default;
    }

    public override bool _Set(StringName property, Variant value)
    {
        string propertyName = property.ToString();
        if (propertyName.StartsWith("number_"))
        {
            int index = int.Parse(propertyName.Substring("number_".Length));
            numbers[index] = value.As&lt;int&gt;();
            return true;
        }
        return false;
    }
}</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>该方法旨在用于高级目的。对于大多数常见用例，脚本语言提供了更简单的方法来处理属性。参见 <reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-export"><inline classes="std std-ref">@GDScript.@export</inline></reference>、<reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-export-enum"><inline classes="std std-ref">@GDScript.@export_enum</inline></reference>、<reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-export-group"><inline classes="std std-ref">@GDScript.@export_group</inline></reference>、等。如果要自定义导出的属性，请使用 <reference internal="True" refid="class-object-private-method-validate-property"><inline classes="std std-ref">_validate_property</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>如果该对象的脚本不是 <reference internal="True" refuri="class_@gdscript#class-gdscript-annotation-tool"><inline classes="std std-ref">@GDScript.@tool</inline></reference>，则该方法在编辑器中不会被调用。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-private-method-init"></target>
            <paragraph classes="classref-method" ids="class-object-private-method-init" names="class_object_private_method__init"><abbreviation explanation="无返回值。">void</abbreviation> <strong>_init</strong>() <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <reference internal="True" refid="class-object-private-method-init"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>实例化对象的脚本时调用，通常是在对象在内存中初始化之后（通过 GDScript 中的 <literal>Object.new()</literal> 或 C# 中的 <literal>new GodotObject</literal>）。也可以将其定义为接受参数的形式。该方法类似于大多数编程语言中的构造函数。</paragraph>
            <paragraph><strong>注意：</strong>如果为 <reference internal="True" refid="class-object-private-method-init"><inline classes="std std-ref">_init</inline></reference> 定义了<emphasis>必填的</emphasis>参数，则带脚本的 Object 只能直接创建。使用任何其他方式（例如 <reference internal="True" refuri="class_packedscene#class-packedscene-method-instantiate"><inline classes="std std-ref">PackedScene.instantiate</inline></reference> 或 <reference internal="True" refuri="class_node#class-node-method-duplicate"><inline classes="std std-ref">Node.duplicate</inline></reference>）创建时，该脚本的初始化都将失败。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-private-method-notification"></target>
            <paragraph classes="classref-method" ids="class-object-private-method-notification" names="class_object_private_method__notification"><abbreviation explanation="无返回值。">void</abbreviation> <strong>_notification</strong>(what: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <reference internal="True" refid="class-object-private-method-notification"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>当对象收到通知时被调用，可以通过将 <literal>what</literal> 与常量比较来识别通知。另见 <reference internal="True" refid="class-object-method-notification"><inline classes="std std-ref">notification</inline></reference>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _notification(what):
    if what == NOTIFICATION_PREDELETE:
        print("再见！")</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Notification(int what)
{
    if (what == NotificationPredelete)
    {
        GD.Print("再见！");
    }
}</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>基类 <strong>Object</strong> 定义了一些通知（<reference internal="True" refid="class-object-constant-notification-postinitialize"><inline classes="std std-ref">NOTIFICATION_POSTINITIALIZE</inline></reference> 和 <reference internal="True" refid="class-object-constant-notification-predelete"><inline classes="std std-ref">NOTIFICATION_PREDELETE</inline></reference>）。<reference internal="True" refuri="class_node#class-node"><inline classes="std std-ref">Node</inline></reference> 等继承类定义了更多通知，这些通知也由该方法接收。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-private-method-property-can-revert"></target>
            <paragraph classes="classref-method" ids="class-object-private-method-property-can-revert" names="class_object_private_method__property_can_revert"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>_property_can_revert</strong>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <reference internal="True" refid="class-object-private-method-property-can-revert"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>覆盖该方法以自定义给定 <literal>property</literal> 的恢复行为。如果 <literal>property</literal> 具有自定义默认值并且可在检查器面板中恢复，则应返回 <literal>true</literal>。使用 <reference internal="True" refid="class-object-private-method-property-get-revert"><inline classes="std std-ref">_property_get_revert</inline></reference> 来指定 <literal>property</literal> 的默认值。</paragraph>
            <paragraph><strong>注意：</strong>无论 <literal>property</literal> 的当前值如何，该方法都必须始终如一地返回。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-private-method-property-get-revert"></target>
            <paragraph classes="classref-method" ids="class-object-private-method-property-get-revert" names="class_object_private_method__property_get_revert"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>_property_get_revert</strong>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <reference internal="True" refid="class-object-private-method-property-get-revert"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>覆盖该方法以自定义给定 <literal>property</literal> 的还原行为。应返回 <literal>property</literal> 的默认值。如果默认值与 <literal>property</literal> 的当前值不同，则检查器停靠面板中会显示一个还原图标。</paragraph>
            <paragraph><strong>注意：</strong><reference internal="True" refid="class-object-private-method-property-can-revert"><inline classes="std std-ref">_property_can_revert</inline></reference> 也必须被覆盖，该方法才能被调用。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-private-method-set"></target>
            <paragraph classes="classref-method" ids="class-object-private-method-set" names="class_object_private_method__set"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>_set</strong>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <reference internal="True" refid="class-object-private-method-set"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>覆盖该方法以自定义 <reference internal="True" refid="class-object-method-set"><inline classes="std std-ref">set</inline></reference> 的行为。应将 <literal>property</literal> 设置为 <literal>value</literal> 并返回 <literal>true</literal>，如果 <literal>property</literal> 正常处理则返回 <literal>false</literal>。设置 <literal>property</literal> 的<emphasis>确切</emphasis>方式取决于该方法的实现。</paragraph>
            <paragraph>结合 <reference internal="True" refid="class-object-private-method-get"><inline classes="std std-ref">_get</inline></reference> 和 <reference internal="True" refid="class-object-private-method-get-property-list"><inline classes="std std-ref">_get_property_list</inline></reference>，该方法允许定义自定义属性，这对编辑器插件特别有用。注意属性<emphasis>必须</emphasis>在 <reference internal="True" refid="class-object-method-get-property-list"><inline classes="std std-ref">get_property_list</inline></reference> 中存在，否则该方法将不会被调用。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var internal_data = {}

func _set(property, value):
    if property == "fake_property":
        # 在冒牌属性中存值。
        internal_data["fake_property"] = value
        return true
    return false

func _get_property_list():
    return [
        { "name": "fake_property", "type": TYPE_INT }
    ]</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private Godot.Collections.Dictionary _internalData = new Godot.Collections.Dictionary();

public override bool _Set(StringName property, Variant value)
{
    if (property == "FakeProperty")
    {
        // 在冒牌属性中存值。
        _internalData["FakeProperty"] = value;
        return true;
    }

    return false;
}

public override Godot.Collections.Array&lt;Godot.Collections.Dictionary&gt; _GetPropertyList()
{
    return new Godot.Collections.Array&lt;Godot.Collections.Dictionary&gt;()
    {
        new Godot.Collections.Dictionary()
        {
            { "name", "FakeProperty" },
            { "type", (int)Variant.Type.Int }
        }
    };
}</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-private-method-to-string"></target>
            <paragraph classes="classref-method" ids="class-object-private-method-to-string" names="class_object_private_method__to_string"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>_to_string</strong>() <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <reference internal="True" refid="class-object-private-method-to-string"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>覆盖该方法以自定义 <reference internal="True" refid="class-object-method-to-string"><inline classes="std std-ref">to_string</inline></reference> 的返回值，从而将对象表示为一个 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">func _to_string():
    return "欢迎来到 Godot 4！"

func _init():
    print(self)       # 输出“欢迎来到 Godot 4！”
    var a = str(self) # a 是“欢迎来到 Godot 4！”</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-private-method-validate-property"></target>
            <paragraph classes="classref-method" ids="class-object-private-method-validate-property" names="class_object_private_method__validate_property"><abbreviation explanation="无返回值。">void</abbreviation> <strong>_validate_property</strong>(property: <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>) <abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation> <reference internal="True" refid="class-object-private-method-validate-property"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>覆盖该方法以自定义已有属性。除了使用 <reference internal="True" refid="class-object-private-method-get-property-list"><inline classes="std std-ref">_get_property_list</inline></reference> 添加的属性之外，每个属性信息都经过该方法。字典内容与 <reference internal="True" refid="class-object-private-method-get-property-list"><inline classes="std std-ref">_get_property_list</inline></reference> 中的相同。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">@tool
extends Node

@export var is_number_editable: bool:
    set(value):
        is_number_editable = value
        notify_property_list_changed()
@export var number: int

func _validate_property(property: Dictionary):
    if property.name == "number" and not is_number_editable:
        property.usage |= PROPERTY_USAGE_READ_ONLY</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">[Tool]
public partial class MyNode : Node
{
    private bool _isNumberEditable;

    [Export]
    public bool IsNumberEditable
    {
        get =&gt; _isNumberEditable;
        set
        {
            _isNumberEditable = value;
            NotifyPropertyListChanged();
        }
    }

    [Export]
    public int Number { get; set; }

    public override void _ValidateProperty(Godot.Collections.Dictionary property)
    {
        if (property["name"].AsStringName() == PropertyName.Number &amp;&amp; IsNumberEditable)
        {
            var usage = property["usage"].As&lt;PropertyUsageFlags&gt;() | PropertyUsageFlags.ReadOnly;
            property["usage"] = (int)usage;
        }
    }
}</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-add-user-signal"></target>
            <paragraph classes="classref-method" ids="class-object-method-add-user-signal" names="class_object_method_add_user_signal"><abbreviation explanation="无返回值。">void</abbreviation> <strong>add_user_signal</strong>(signal: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>, arguments: <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> = []) <reference internal="True" refid="class-object-method-add-user-signal"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Adds a user-defined <literal>signal</literal>. Optional arguments for the signal can be added as an <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> of dictionaries, each defining a <literal>name</literal> <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> and a <literal>type</literal> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> (see <reference internal="True" refuri="class_@globalscope#enum-globalscope-variant-type"><inline classes="std std-ref">Variant.Type</inline></reference>). See also <reference internal="True" refid="class-object-method-has-user-signal"><inline classes="std std-ref">has_user_signal</inline></reference> and <reference internal="True" refid="class-object-method-remove-user-signal"><inline classes="std std-ref">remove_user_signal</inline></reference>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">add_user_signal("hurt", [
    { "name": "damage", "type": TYPE_INT },
    { "name": "source", "type": TYPE_OBJECT }
])</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">AddUserSignal("Hurt", new Godot.Collections.Array()
{
    new Godot.Collections.Dictionary()
    {
        { "name", "damage" },
        { "type", (int)Variant.Type.Int }
    },
    new Godot.Collections.Dictionary()
    {
        { "name", "source" },
        { "type", (int)Variant.Type.Object }
    }
});</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-call"></target>
            <paragraph classes="classref-method" ids="class-object-method-call" names="class_object_method_call"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>call</strong>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="本方法除了能接受在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation> <reference internal="True" refid="class-object-method-call"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>在对象上调用 <literal>method</literal> 并返回结果。该方法支持可变数量的参数，因此参数可以作为逗号分隔的列表传递。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var node = Node3D.new()
node.call("rotate", Vector3(1.0, 0.0, 0.0), 1.571)</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var node = new Node3D();
node.Call(Node3D.MethodName.Rotate, new Vector3(1f, 0f, 0f), 1.571f);</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>在 C# 中，在引用 Godot 内置方法时，<literal>method</literal> 必须为 snake_case 格式。最好使用 <literal>MethodName</literal> 类中公开的名称，以避免在每次调用时分配新的 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-call-deferred"></target>
            <paragraph classes="classref-method" ids="class-object-method-call-deferred" names="class_object_method_call_deferred"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>call_deferred</strong>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="本方法除了能接受在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation> <reference internal="True" refid="class-object-method-call-deferred"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>在空闲时调用该对象的 <literal>method</literal> 方法。始终返回 null，<strong>不返回</strong>该方法的结果。</paragraph>
            <paragraph>空闲时间主要出现在处理帧和物理帧的末尾。延迟的调用会在此时执行，直到没有调用剩余为止，这意味着你可以从其他延迟的调用中延迟调用，并且它们仍将在当前空闲时间周期中运行。这意味着你不应从延迟调用的方法（或从其调用的方法）中延迟调用其自身，因为这会导致无限递归，就像你直接调用该方法一样。</paragraph>
            <paragraph>这个方法支持可变数量的参数，所以参数可以用逗号分隔列表的形式传递。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var node = Node3D.new()
node.call_deferred("rotate", Vector3(1.0, 0.0, 0.0), 1.571)</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var node = new Node3D();
node.CallDeferred(Node3D.MethodName.Rotate, new Vector3(1f, 0f, 0f), 1.571f);</literal_block>
                </div>
            </container>
            <paragraph>另见 <reference internal="True" refuri="class_callable#class-callable-method-call-deferred"><inline classes="std std-ref">Callable.call_deferred</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>在 C# 中，<literal>method</literal> 引用内置的 Godot 方法时必须使用 snake_case 的形式。请优先使用 <literal>MethodName</literal> 类中暴露的名称，避免每次调用都分配一个新的 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>如果你想要延迟一帧再调用函数，请使用 <reference internal="True" refuri="class_scenetree#class-scenetree-signal-process-frame"><inline classes="std std-ref">SceneTree.process_frame</inline></reference> 和 <reference internal="True" refuri="class_scenetree#class-scenetree-signal-physics-frame"><inline classes="std std-ref">SceneTree.physics_frame</inline></reference> 信号。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var node = Node3D.new()
# 制作可调用体并将参数绑定到该节点的 rotate() 调用。
var callable = node.rotate.bind(Vector3(1.0, 0.0, 0.0), 1.571)
# 将可调用体连接到 process_frame 信号，这样就能够在下一个处理帧中调用。
# CONNECT_ONE_SHOT 能够确保只调用一次，不会每帧都调用。
get_tree().process_frame.connect(callable, CONNECT_ONE_SHOT)</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-callv"></target>
            <paragraph classes="classref-method" ids="class-object-method-callv" names="class_object_method_callv"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>callv</strong>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, arg_array: <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>) <reference internal="True" refid="class-object-method-callv"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>在对象上调用 <literal>method</literal> 并返回结果。与 <reference internal="True" refid="class-object-method-call"><inline classes="std std-ref">call</inline></reference> 不同，该方法期望所有参数都包含在 <literal>arg_array</literal> 中。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var node = Node3D.new()
node.callv("rotate", [Vector3(1.0, 0.0, 0.0), 1.571])</literal_block>
                </div>
                <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var node = new Node3D();
node.Callv(Node3D.MethodName.Rotate, new Godot.Collections.Array { new Vector3(1f, 0f, 0f), 1.571f });</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>在 C# 中，<literal>method</literal> 在引用 Godot 内置方法时必须是 snake_case。最好使用 <literal>MethodName</literal> 类中公开的名称，以避免在每次调用时分配新的 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-can-translate-messages"></target>
            <paragraph classes="classref-method" ids="class-object-method-can-translate-messages" names="class_object_method_can_translate_messages"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>can_translate_messages</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-can-translate-messages"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果允许该对象使用 <reference internal="True" refid="class-object-method-tr"><inline classes="std std-ref">tr</inline></reference> 和 <reference internal="True" refid="class-object-method-tr-n"><inline classes="std std-ref">tr_n</inline></reference> 翻译消息，则返回 <literal>true</literal>。另见 <reference internal="True" refid="class-object-method-set-message-translation"><inline classes="std std-ref">set_message_translation</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-cancel-free"></target>
            <paragraph classes="classref-method" ids="class-object-method-cancel-free" names="class_object_method_cancel_free"><abbreviation explanation="无返回值。">void</abbreviation> <strong>cancel_free</strong>() <reference internal="True" refid="class-object-method-cancel-free"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果在 <reference internal="True" refid="class-object-constant-notification-predelete"><inline classes="std std-ref">NOTIFICATION_PREDELETE</inline></reference> 时调用该方法，则该对象拒绝释放，仍会保持已分配的状态。主要是作为内部函数使用，用于错误处理，避免用户释放不想释放的对象。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-connect"></target>
            <paragraph classes="classref-method" ids="class-object-method-connect" names="class_object_method_connect"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>connect</strong>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, callable: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>, flags: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 0) <reference internal="True" refid="class-object-method-connect"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Connects a <literal>signal</literal> by name to a <literal>callable</literal>. Optional <literal>flags</literal> can be also added to configure the connection's behavior (see <reference internal="True" refid="enum-object-connectflags"><inline classes="std std-ref">ConnectFlags</inline></reference> constants).</paragraph>
            <paragraph>A signal can only be connected once to the same <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>. If the signal is already connected, this method returns <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-invalid-parameter"><inline classes="std std-ref">@GlobalScope.ERR_INVALID_PARAMETER</inline></reference> and pushes an error message, unless the signal is connected with <reference internal="True" refid="class-object-constant-connect-reference-counted"><inline classes="std std-ref">CONNECT_REFERENCE_COUNTED</inline></reference>. To prevent this, use <reference internal="True" refid="class-object-method-is-connected"><inline classes="std std-ref">is_connected</inline></reference> first to check for existing connections.</paragraph>
            <paragraph>If the <literal>callable</literal>'s object is freed, the connection will be lost.</paragraph>
            <paragraph><strong>Examples with recommended syntax:</strong></paragraph>
            <paragraph>Connecting signals is one of the most common operations in Godot and the API gives many options to do so, which are described further down. The code block below shows the recommended approach.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    var button = Button.new()
    # `button_down` here is a Signal variant type, and we thus call the Signal.connect() method, not Object.connect().
    # See discussion below for a more in-depth overview of the API.
    button.button_down.connect(_on_button_down)

    # This assumes that a `Player` class exists, which defines a `hit` signal.
    var player = Player.new()
    # We use Signal.connect() again, and we also use the Callable.bind() method,
    # which returns a new Callable with the parameter binds.
    player.hit.connect(_on_player_hit.bind("sword", 100))

func _on_button_down():
    print("Button down!")

func _on_player_hit(weapon_type, damage):
    print("Hit with weapon %s for %d damage." % [weapon_type, damage])</literal_block>
                </div>
                <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    var button = new Button();
    // C# supports passing signals as events, so we can use this idiomatic construct:
    button.ButtonDown += OnButtonDown;

    // This assumes that a `Player` class exists, which defines a `Hit` signal.
    var player = new Player();
    // We can use lambdas when we need to bind additional parameters.
    player.Hit += () =&gt; OnPlayerHit("sword", 100);
}

private void OnButtonDown()
{
    GD.Print("Button down!");
}

private void OnPlayerHit(string weaponType, int damage)
{
    GD.Print($"Hit with weapon {weaponType} for {damage} damage.");
}</literal_block>
                </div>
            </container>
            <paragraph><strong>``Object.connect()`` or ``Signal.connect()``?</strong></paragraph>
            <paragraph>As seen above, the recommended method to connect signals is not <reference internal="True" refid="class-object-method-connect"><inline classes="std std-ref">connect</inline></reference>. The code block below shows the four options for connecting signals, using either this legacy method or the recommended <reference internal="True" refuri="class_signal#class-signal-method-connect"><inline classes="std std-ref">Signal.connect</inline></reference>, and using either an implicit <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> or a manually defined one.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-10-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-10-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-10-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    var button = Button.new()
    # Option 1: Object.connect() with an implicit Callable for the defined function.
    button.connect("button_down", _on_button_down)
    # Option 2: Object.connect() with a constructed Callable using a target object and method name.
    button.connect("button_down", Callable(self, "_on_button_down"))
    # Option 3: Signal.connect() with an implicit Callable for the defined function.
    button.button_down.connect(_on_button_down)
    # Option 4: Signal.connect() with a constructed Callable using a target object and method name.
    button.button_down.connect(Callable(self, "_on_button_down"))

func _on_button_down():
    print("Button down!")</literal_block>
                </div>
                <div aria-labelledby="tab-10-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-10-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    var button = new Button();
    // Option 1: In C#, we can use signals as events and connect with this idiomatic syntax:
    button.ButtonDown += OnButtonDown;
    // Option 2: GodotObject.Connect() with a constructed Callable from a method group.
    button.Connect(Button.SignalName.ButtonDown, Callable.From(OnButtonDown));
    // Option 3: GodotObject.Connect() with a constructed Callable using a target object and method name.
    button.Connect(Button.SignalName.ButtonDown, new Callable(this, MethodName.OnButtonDown));
}

private void OnButtonDown()
{
    GD.Print("Button down!");
}</literal_block>
                </div>
            </container>
            <paragraph>While all options have the same outcome (<literal>button</literal>'s <reference internal="True" refuri="class_basebutton#class-basebutton-signal-button-down"><inline classes="std std-ref">BaseButton.button_down</inline></reference> signal will be connected to <literal>_on_button_down</literal>), <strong>option 3</strong> offers the best validation: it will print a compile-time error if either the <literal>button_down</literal> <reference internal="True" refuri="class_signal#class-signal"><inline classes="std std-ref">Signal</inline></reference> or the <literal>_on_button_down</literal> <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> are not defined. On the other hand, <strong>option 2</strong> only relies on string names and will only be able to validate either names at runtime: it will print a runtime error if <literal>"button_down"</literal> doesn't correspond to a signal, or if <literal>"_on_button_down"</literal> is not a registered method in the object <literal>self</literal>. The main reason for using options 1, 2, or 4 would be if you actually need to use strings (e.g. to connect signals programmatically based on strings read from a configuration file). Otherwise, option 3 is the recommended (and fastest) method.</paragraph>
            <paragraph><strong>Binding and passing parameters:</strong></paragraph>
            <paragraph>The syntax to bind parameters is through <reference internal="True" refuri="class_callable#class-callable-method-bind"><inline classes="std std-ref">Callable.bind</inline></reference>, which returns a copy of the <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> with its parameters bound.</paragraph>
            <paragraph>When calling <reference internal="True" refid="class-object-method-emit-signal"><inline classes="std std-ref">emit_signal</inline></reference> or <reference internal="True" refuri="class_signal#class-signal-method-emit"><inline classes="std std-ref">Signal.emit</inline></reference>, the signal parameters can be also passed. The examples below show the relationship between these signal parameters and bound parameters.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-11-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-11-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-11-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-11-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-11-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    # This assumes that a `Player` class exists, which defines a `hit` signal.
    var player = Player.new()
    # Using Callable.bind().
    player.hit.connect(_on_player_hit.bind("sword", 100))

    # Parameters added when emitting the signal are passed first.
    player.hit.emit("Dark lord", 5)

# We pass two arguments when emitting (`hit_by`, `level`),
# and bind two more arguments when connecting (`weapon_type`, `damage`).
func _on_player_hit(hit_by, level, weapon_type, damage):
    print("Hit by %s (level %d) with weapon %s for %d damage." % [hit_by, level, weapon_type, damage])</literal_block>
                </div>
                <div aria-labelledby="tab-11-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-11-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    // This assumes that a `Player` class exists, which defines a `Hit` signal.
    var player = new Player();
    // Using lambda expressions that create a closure that captures the additional parameters.
    // The lambda only receives the parameters defined by the signal's delegate.
    player.Hit += (hitBy, level) =&gt; OnPlayerHit(hitBy, level, "sword", 100);

    // Parameters added when emitting the signal are passed first.
    player.EmitSignal(SignalName.Hit, "Dark lord", 5);
}

// We pass two arguments when emitting (`hit_by`, `level`),
// and bind two more arguments when connecting (`weapon_type`, `damage`).
private void OnPlayerHit(string hitBy, int level, string weaponType, int damage)
{
    GD.Print($"Hit by {hitBy} (level {level}) with weapon {weaponType} for {damage} damage.");
}</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-disconnect"></target>
            <paragraph classes="classref-method" ids="class-object-method-disconnect" names="class_object_method_disconnect"><abbreviation explanation="无返回值。">void</abbreviation> <strong>disconnect</strong>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, callable: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <reference internal="True" refid="class-object-method-disconnect"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>按名称从给定的 <literal>callable</literal> 断开 <literal>signal</literal>。如果连接不存在，则生成一个错误。使用 <reference internal="True" refid="class-object-method-is-connected"><inline classes="std std-ref">is_connected</inline></reference> 确保该连接存在。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-emit-signal"></target>
            <paragraph classes="classref-method" ids="class-object-method-emit-signal" names="class_object_method_emit_signal"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>emit_signal</strong>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, ...) <abbreviation explanation="本方法除了能接受在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation> <reference internal="True" refid="class-object-method-emit-signal"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>按名称发出给定的 <literal>signal</literal>。该信号必须存在，所以它应该是该类或其继承类之一的内置信号，或者是用户定义的信号（参见 <reference internal="True" refid="class-object-method-add-user-signal"><inline classes="std std-ref">add_user_signal</inline></reference>）。该方法支持可变数量的参数，所以参数可以以逗号分隔的列表形式传递。</paragraph>
            <paragraph>如果 <literal>signal</literal> 不存在或参数无效，则返回 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-unavailable"><inline classes="std std-ref">@GlobalScope.ERR_UNAVAILABLE</inline></reference>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-12-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-12-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-12-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-12-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-12-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-12-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">emit_signal("hit", "剑", 100)
emit_signal("game_over")</literal_block>
                </div>
                <div aria-labelledby="tab-12-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-12-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">EmitSignal(SignalName.Hit, "剑", 100);
EmitSignal(SignalName.GameOver);</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>在C#中，在引用内置 Godot 信号时，<literal>signal</literal> 必须是 snake_case。最好使用 <literal>SignalName</literal> 类中公开的名称，以避免在每次调用时分配一个新的 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-free"></target>
            <paragraph classes="classref-method" ids="class-object-method-free" names="class_object_method_free"><abbreviation explanation="无返回值。">void</abbreviation> <strong>free</strong>() <reference internal="True" refid="class-object-method-free"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>从内存中删除该对象。对该对象的预先存在的引用会变得无效，并且任何访问它们的尝试都将会产生一个运行时错误。使用 <reference internal="True" refuri="class_@globalscope#class-globalscope-method-is-instance-valid"><inline classes="std std-ref">@GlobalScope.is_instance_valid</inline></reference> 检查引用时将返回 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-get"></target>
            <paragraph classes="classref-method" ids="class-object-method-get" names="class_object_method_get"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>get</strong>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-get"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> value of the given <literal>property</literal>. If the <literal>property</literal> does not exist, this method returns <literal>null</literal>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-13-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-13-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-13-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-13-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-13-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-13-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var node = Node2D.new()
node.rotation = 1.5
var a = node.get("rotation") # a is 1.5</literal_block>
                </div>
                <div aria-labelledby="tab-13-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-13-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var node = new Node2D();
node.Rotation = 1.5f;
var a = node.Get(Node2D.PropertyName.Rotation); // a is 1.5</literal_block>
                </div>
            </container>
            <paragraph><strong>Note:</strong> In C#, <literal>property</literal> must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the <literal>PropertyName</literal> class to avoid allocating a new <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> on each call.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-get-class"></target>
            <paragraph classes="classref-method" ids="class-object-method-get-class" names="class_object_method_get_class"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>get_class</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-get-class"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该对象的内置类名，作为一个 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>。另请参阅 <reference internal="True" refid="class-object-method-is-class"><inline classes="std std-ref">is_class</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>该方法将忽略 <literal>class_name</literal> 声明。如果该对象的脚本定义了一个 <literal>class_name</literal>，则改为返回内置基类名称。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-get-incoming-connections"></target>
            <paragraph classes="classref-method" ids="class-object-method-get-incoming-connections" names="class_object_method_get_incoming_connections"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>] <strong>get_incoming_connections</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-get-incoming-connections"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该对象接收到的信号连接的 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>。每个连接都被表示为包含三个条目的 <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>signal</literal> 是对 <reference internal="True" refuri="class_signal#class-signal"><inline classes="std std-ref">Signal</inline></reference> 的引用；</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>callable</literal> 是对 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> 的引用；</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>flags</literal> 是 <reference internal="True" refid="enum-object-connectflags"><inline classes="std std-ref">ConnectFlags</inline></reference> 的组合。</paragraph>
                </list_item>
            </bullet_list>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-get-indexed"></target>
            <paragraph classes="classref-method" ids="class-object-method-get-indexed" names="class_object_method_get_indexed"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>get_indexed</strong>(property_path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-get-indexed"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>获取该对象的某个属性，该属性的属性路径由 <literal>property_path</literal> 给出。该路径应该是相对于当前对象的 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>，可是使用英文冒号（<literal>:</literal>）访问内嵌属性。</paragraph>
            <paragraph><strong>示例：</strong><literal>"position:x"</literal> 或 <literal>"material:next_pass:blend_mode"</literal>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-14-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-14-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-14-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-14-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-14-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-14-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var node = Node2D.new()
node.position = Vector2(5, -10)
var a = node.get_indexed("position")   # a 为 Vector2(5, -10)
var b = node.get_indexed("position:y") # b 为 -10</literal_block>
                </div>
                <div aria-labelledby="tab-14-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-14-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var node = new Node2D();
node.Position = new Vector2(5, -10);
var a = node.GetIndexed("position");   // a 为 Vector2(5, -10)
var b = node.GetIndexed("position:y"); // b 为 -10</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>在 C# 中引用内置 Godot 属性时 <literal>property_path</literal> 必须为 snake_case 蛇形大小写。请优先使用 <literal>PropertyName</literal> 类中暴露的名称，避免每次调用都重新分配一个 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>这个方法不支持指向 <reference internal="True" refuri="class_scenetree#class-scenetree"><inline classes="std std-ref">SceneTree</inline></reference> 中节点的路径，仅支持子属性路径。在节点语境下，请改用 <reference internal="True" refuri="class_node#class-node-method-get-node-and-resource"><inline classes="std std-ref">Node.get_node_and_resource</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-get-instance-id"></target>
            <paragraph classes="classref-method" ids="class-object-method-get-instance-id" names="class_object_method_get_instance_id"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_instance_id</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-get-instance-id"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the object's unique instance ID. This ID can be saved in <reference internal="True" refuri="class_encodedobjectasid#class-encodedobjectasid"><inline classes="std std-ref">EncodedObjectAsID</inline></reference>, and can be used to retrieve this object instance with <reference internal="True" refuri="class_@globalscope#class-globalscope-method-instance-from-id"><inline classes="std std-ref">@GlobalScope.instance_from_id</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This ID is only useful during the current session. It won't correspond to a similar object if the ID is sent over a network, or loaded from a file at a later time.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-get-meta"></target>
            <paragraph classes="classref-method" ids="class-object-method-get-meta" names="class_object_method_get_meta"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>get_meta</strong>(name: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, default: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> = null) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-get-meta"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该对象的元数据中名称为 <literal>name</literal> 的条目。如果不存在该条目，则返回 <literal>default</literal>。如果 <literal>default</literal> 为 <literal>null</literal>，则还会生成错误。</paragraph>
            <paragraph><strong>注意：</strong>元数据的名称必须是符合 <reference internal="True" refuri="class_stringname#class-stringname-method-is-valid-identifier"><inline classes="std std-ref">StringName.is_valid_identifier</inline></reference> 的有效标识符。</paragraph>
            <paragraph><strong>注意：</strong>名称以下划线（<literal>_</literal>）开头的元数据仅供编辑器使用。仅供编辑器使用的元数据不会在“检查器”中显示，虽然仍然能够被这个方法找到，但是不应该进行编辑。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-get-meta-list"></target>
            <paragraph classes="classref-method" ids="class-object-method-get-meta-list" names="class_object_method_get_meta_list"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>] <strong>get_meta_list</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-get-meta-list"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将该对象的元数据作为 <reference internal="True" refuri="class_packedstringarray#class-packedstringarray"><inline classes="std std-ref">PackedStringArray</inline></reference> 返回。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-get-method-argument-count"></target>
            <paragraph classes="classref-method" ids="class-object-method-get-method-argument-count" names="class_object_method_get_method_argument_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_method_argument_count</strong>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-get-method-argument-count"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns the number of arguments of the given <literal>method</literal> by name.</paragraph>
            <paragraph><strong>Note:</strong> In C#, <literal>method</literal> must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the <literal>MethodName</literal> class to avoid allocating a new <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> on each call.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-get-method-list"></target>
            <paragraph classes="classref-method" ids="class-object-method-get-method-list" names="class_object_method_get_method_list"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>] <strong>get_method_list</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-get-method-list"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将该对象的方法及对应签名作为字典 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> 返回。每个 <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> 包含以下条目：</paragraph>
            <paragraph>-<literal>name</literal> 是该方法的名称，为 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>；</paragraph>
            <paragraph>-<literal>args</literal> 是代表参数的字典 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>；</paragraph>
            <paragraph>-<literal>default_args</literal> 是默认参数，为变体 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>；</paragraph>
            <paragraph>-<literal>flags</literal> 是 <reference internal="True" refuri="class_@globalscope#enum-globalscope-methodflags"><inline classes="std std-ref">MethodFlags</inline></reference> 的组合；</paragraph>
            <paragraph>-<literal>id</literal> 是该方法的内部标识符 <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>；</paragraph>
            <paragraph>-<literal>return</literal> 是返回值，为 <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>；</paragraph>
            <paragraph><strong>注意：</strong><literal>args</literal> 和 <literal>return</literal> 的字典格式与 <reference internal="True" refid="class-object-method-get-property-list"><inline classes="std std-ref">get_property_list</inline></reference> 的结果相同，但不会用到所有条目。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-get-property-list"></target>
            <paragraph classes="classref-method" ids="class-object-method-get-property-list" names="class_object_method_get_property_list"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>] <strong>get_property_list</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-get-property-list"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>以字典 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> 的形式返回该对象的属性列表。每个 <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> 中都包含如下条目：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>name</literal> 是该属性的名称，类型为 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>；</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>class_name</literal> 为空 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>，除非该属性为 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-type-object"><inline classes="std std-ref">@GlobalScope.TYPE_OBJECT</inline></reference> 并继承自某个类；</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>type</literal> 是该属性的类型，类型为 <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>（见 <reference internal="True" refuri="class_@globalscope#enum-globalscope-variant-type"><inline classes="std std-ref">Variant.Type</inline></reference>）；</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>hint</literal> 是应当<emphasis>如何</emphasis>编辑该属性（见 <reference internal="True" refuri="class_@globalscope#enum-globalscope-propertyhint"><inline classes="std std-ref">PropertyHint</inline></reference>）；</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>hint_string</literal> 取决于 hint（见 <reference internal="True" refuri="class_@globalscope#enum-globalscope-propertyhint"><inline classes="std std-ref">PropertyHint</inline></reference>）；</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>usage</literal> 是 <reference internal="True" refuri="class_@globalscope#enum-globalscope-propertyusageflags"><inline classes="std std-ref">PropertyUsageFlags</inline></reference> 的组合。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>注意：</strong>在 GDScript 中，类的所有成员都被视为属性。在 C# 和 GDExtension 中，则需要使用装饰器或特性将类的成员显式标记为 Godot 属性。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-get-script"></target>
            <paragraph classes="classref-method" ids="class-object-method-get-script" names="class_object_method_get_script"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>get_script</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-get-script"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该对象的 <reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference> 实例，如果没有附加脚本，则返回 <literal>null</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-get-signal-connection-list"></target>
            <paragraph classes="classref-method" ids="class-object-method-get-signal-connection-list" names="class_object_method_get_signal_connection_list"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>] <strong>get_signal_connection_list</strong>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-get-signal-connection-list"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回给定 <literal>signal</literal> 名称的连接的 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>。每个连接都被表示为包含三个条目的 <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>signal</literal> 是对 <reference internal="True" refuri="class_signal#class-signal"><inline classes="std std-ref">Signal</inline></reference> 的引用；</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>callable</literal> 是对已连接 <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference> 的引用；</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>flags</literal> 是 <reference internal="True" refid="enum-object-connectflags"><inline classes="std std-ref">ConnectFlags</inline></reference> 的组合。</paragraph>
                </list_item>
            </bullet_list>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-get-signal-list"></target>
            <paragraph classes="classref-method" ids="class-object-method-get-signal-list" names="class_object_method_get_signal_list"><reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference>[<reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference>] <strong>get_signal_list</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-get-signal-list"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将现有信号的列表返回为字典的一个 <reference internal="True" refuri="class_array#class-array"><inline classes="std std-ref">Array</inline></reference> 。</paragraph>
            <paragraph><strong>注意：</strong>由于该实现，每个 <reference internal="True" refuri="class_dictionary#class-dictionary"><inline classes="std std-ref">Dictionary</inline></reference> 被格式为与 <reference internal="True" refid="class-object-method-get-method-list"><inline classes="std std-ref">get_method_list</inline></reference> 的返回值非常相似。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-has-meta"></target>
            <paragraph classes="classref-method" ids="class-object-method-has-meta" names="class_object_method_has_meta"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>has_meta</strong>(name: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-has-meta"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果找到名称为 <literal>name</literal> 的元数据条目，则返回 <literal>true</literal>。另请参阅 <reference internal="True" refid="class-object-method-get-meta"><inline classes="std std-ref">get_meta</inline></reference>、<reference internal="True" refid="class-object-method-set-meta"><inline classes="std std-ref">set_meta</inline></reference> 和 <reference internal="True" refid="class-object-method-remove-meta"><inline classes="std std-ref">remove_meta</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>元数据的名称必须是符合 <reference internal="True" refuri="class_stringname#class-stringname-method-is-valid-identifier"><inline classes="std std-ref">StringName.is_valid_identifier</inline></reference> 的有效标识符。</paragraph>
            <paragraph><strong>注意：</strong>名称以下划线（<literal>_</literal>）开头的元数据仅供编辑器使用。仅供编辑器使用的元数据不会在“检查器”中显示，虽然仍然能够被这个方法找到，但是不应该进行编辑。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-has-method"></target>
            <paragraph classes="classref-method" ids="class-object-method-has-method" names="class_object_method_has_method"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>has_method</strong>(method: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-has-method"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该对象中存在给定的方法名 <literal>method</literal>，则返回 <literal>true</literal>。</paragraph>
            <paragraph><strong>注意：</strong>在 C# 中引用内置 Godot 方法时 <literal>method</literal> 必须为 snake_case 蛇形大小写。请优先使用 <literal>MethodName</literal> 类中暴露的名称，避免每次调用都重新分配一个 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-has-signal"></target>
            <paragraph classes="classref-method" ids="class-object-method-has-signal" names="class_object_method_has_signal"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>has_signal</strong>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-has-signal"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该对象中存在给定的信号名 <literal>signal</literal>，则返回 <literal>true</literal>。</paragraph>
            <paragraph><strong>注意：</strong>在 C# 中引用内置 Godot 信号时 <literal>signal</literal> 必须为 snake_case 蛇形大小写。请优先使用 <literal>SignalName</literal> 类中暴露的名称，避免每次调用都重新分配一个 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-has-user-signal"></target>
            <paragraph classes="classref-method" ids="class-object-method-has-user-signal" names="class_object_method_has_user_signal"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>has_user_signal</strong>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-has-user-signal"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the given user-defined <literal>signal</literal> name exists. Only signals added with <reference internal="True" refid="class-object-method-add-user-signal"><inline classes="std std-ref">add_user_signal</inline></reference> are included. See also <reference internal="True" refid="class-object-method-remove-user-signal"><inline classes="std std-ref">remove_user_signal</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-is-blocking-signals"></target>
            <paragraph classes="classref-method" ids="class-object-method-is-blocking-signals" names="class_object_method_is_blocking_signals"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_blocking_signals</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-is-blocking-signals"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该对象正在阻止发出信号，则返回 <literal>true</literal>。见 <reference internal="True" refid="class-object-method-set-block-signals"><inline classes="std std-ref">set_block_signals</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-is-class"></target>
            <paragraph classes="classref-method" ids="class-object-method-is-class" names="class_object_method_is_class"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_class</strong>(class: <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-is-class"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该对象继承自给定的 <literal>class</literal> 则返回 <literal>true</literal>。另见 <reference internal="True" refid="class-object-method-get-class"><inline classes="std std-ref">get_class</inline></reference>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-15-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-15-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-15-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-15-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-15-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-15-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var sprite2d = Sprite2D.new()
sprite2d.is_class("Sprite2D") # 返回 true
sprite2d.is_class("Node")     # 返回 true
sprite2d.is_class("Node3D")   # 返回 false</literal_block>
                </div>
                <div aria-labelledby="tab-15-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-15-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var sprite2D = new Sprite2D();
sprite2D.IsClass("Sprite2D"); // 返回 true
sprite2D.IsClass("Node");     // 返回 true
sprite2D.IsClass("Node3D");   // 返回 false</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>此方法忽略对象脚本中的 <literal>class_name</literal> 声明。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-is-connected"></target>
            <paragraph classes="classref-method" ids="class-object-method-is-connected" names="class_object_method_is_connected"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_connected</strong>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, callable: <reference internal="True" refuri="class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-is-connected"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果给定的 <literal>signal</literal> 名称和 <literal>callable</literal> 之间存在连接，则返回 <literal>true</literal>。</paragraph>
            <paragraph><strong>注意：</strong>在 C# 中，在引用 Godot 内置方法时，<literal>signal</literal> 必须是 snake_case。最好使用 <literal>SignalName</literal> 类中公开的名称，以避免在每次调用时分配一个新的 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-is-queued-for-deletion"></target>
            <paragraph classes="classref-method" ids="class-object-method-is-queued-for-deletion" names="class_object_method_is_queued_for_deletion"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_queued_for_deletion</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-is-queued-for-deletion"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果为该对象调用了 <reference internal="True" refuri="class_node#class-node-method-queue-free"><inline classes="std std-ref">Node.queue_free</inline></reference> 方法，则返回 <literal>true</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-notification"></target>
            <paragraph classes="classref-method" ids="class-object-method-notification" names="class_object_method_notification"><abbreviation explanation="无返回值。">void</abbreviation> <strong>notification</strong>(what: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, reversed: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <reference internal="True" refid="class-object-method-notification"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将给定的 <literal>what</literal> 通知发送给对象继承的所有类，触发对 <reference internal="True" refid="class-object-private-method-notification"><inline classes="std std-ref">_notification</inline></reference> 的调用，从最高祖先（<strong>Object</strong> 类）开始，向下一直到对象的脚本。</paragraph>
            <paragraph>如果 <literal>reversed</literal> 为 <literal>true</literal>，则调用顺序会被颠倒。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-16-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-16-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-16-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-16-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-16-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-16-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var player = Node2D.new()
player.set_script(load("res://player.gd"))

player.notification(NOTIFICATION_ENTER_TREE)
# 调用顺序是 Object -&gt; Node -&gt; Node2D -&gt; player.gd。

player.notification(NOTIFICATION_ENTER_TREE, true)
# 调用顺序是 player.gd -&gt; Node2D -&gt; Node -&gt; Object。</literal_block>
                </div>
                <div aria-labelledby="tab-16-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-16-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var player = new Node2D();
player.SetScript(GD.Load("res://player.gd"));

player.Notification(NotificationEnterTree);
// 调用顺序是 GodotObject -&gt; Node -&gt; Node2D -&gt; player.gd。

player.Notification(NotificationEnterTree, true);
// 调用顺序是 player.gd -&gt; Node2D -&gt; Node -&gt; GodotObject。</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-notify-property-list-changed"></target>
            <paragraph classes="classref-method" ids="class-object-method-notify-property-list-changed" names="class_object_method_notify_property_list_changed"><abbreviation explanation="无返回值。">void</abbreviation> <strong>notify_property_list_changed</strong>() <reference internal="True" refid="class-object-method-notify-property-list-changed"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>发出 <reference internal="True" refid="class-object-signal-property-list-changed"><inline classes="std std-ref">property_list_changed</inline></reference> 信号。这主要是用来刷新编辑器，以让检查器和编辑器插件被正确更新。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-property-can-revert"></target>
            <paragraph classes="classref-method" ids="class-object-method-property-can-revert" names="class_object_method_property_can_revert"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>property_can_revert</strong>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-property-can-revert"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果给定的属性 <literal>property</literal> 有自定义的默认值，则返回 <literal>true</literal>。请使用 <reference internal="True" refid="class-object-method-property-get-revert"><inline classes="std std-ref">property_get_revert</inline></reference> 获取 <literal>property</literal> 的默认值。</paragraph>
            <paragraph><strong>注意：</strong>“检查器”面板会使用这个方法来显示恢复图标。该对象必须实现 <reference internal="True" refid="class-object-private-method-property-can-revert"><inline classes="std std-ref">_property_can_revert</inline></reference> 来自定义默认值。如果未实现 <reference internal="True" refid="class-object-private-method-property-can-revert"><inline classes="std std-ref">_property_can_revert</inline></reference>，则这个方法返回 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-property-get-revert"></target>
            <paragraph classes="classref-method" ids="class-object-method-property-get-revert" names="class_object_method_property_get_revert"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>property_get_revert</strong>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-property-get-revert"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回给定的属性 <literal>property</literal> 的自定义默认值。请使用 <reference internal="True" refid="class-object-method-property-can-revert"><inline classes="std std-ref">property_can_revert</inline></reference> 检查 <literal>property</literal> 是否有自定义的默认值。</paragraph>
            <paragraph><strong>注意：</strong>“检查器”面板会使用这个方法来显示恢复图标。该对象必须实现 <reference internal="True" refid="class-object-private-method-property-get-revert"><inline classes="std std-ref">_property_get_revert</inline></reference> 来自定义默认值。如果未实现 <reference internal="True" refid="class-object-private-method-property-get-revert"><inline classes="std std-ref">_property_get_revert</inline></reference>，则这个方法返回 <literal>null</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-remove-meta"></target>
            <paragraph classes="classref-method" ids="class-object-method-remove-meta" names="class_object_method_remove_meta"><abbreviation explanation="无返回值。">void</abbreviation> <strong>remove_meta</strong>(name: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <reference internal="True" refid="class-object-method-remove-meta"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>从对象的元数据中移除名称为 <literal>name</literal> 的条目。另请参阅 <reference internal="True" refid="class-object-method-has-meta"><inline classes="std std-ref">has_meta</inline></reference>、<reference internal="True" refid="class-object-method-get-meta"><inline classes="std std-ref">get_meta</inline></reference> 和 <reference internal="True" refid="class-object-method-set-meta"><inline classes="std std-ref">set_meta</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>元数据的名称必须是符合 <reference internal="True" refuri="class_stringname#class-stringname-method-is-valid-identifier"><inline classes="std std-ref">StringName.is_valid_identifier</inline></reference> 的有效标识符。</paragraph>
            <paragraph><strong>注意：</strong>名称以下划线（<literal>_</literal>）开头的元数据仅供编辑器使用。仅供编辑器使用的元数据不会在“检查器”中显示，虽然仍然能够被这个方法找到，但是不应该进行编辑。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-remove-user-signal"></target>
            <paragraph classes="classref-method" ids="class-object-method-remove-user-signal" names="class_object_method_remove_user_signal"><abbreviation explanation="无返回值。">void</abbreviation> <strong>remove_user_signal</strong>(signal: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>) <reference internal="True" refid="class-object-method-remove-user-signal"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Removes the given user signal <literal>signal</literal> from the object. See also <reference internal="True" refid="class-object-method-add-user-signal"><inline classes="std std-ref">add_user_signal</inline></reference> and <reference internal="True" refid="class-object-method-has-user-signal"><inline classes="std std-ref">has_user_signal</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-set"></target>
            <paragraph classes="classref-method" ids="class-object-method-set" names="class_object_method_set"><abbreviation explanation="无返回值。">void</abbreviation> <strong>set</strong>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-object-method-set"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Assigns <literal>value</literal> to the given <literal>property</literal>. If the property does not exist or the given <literal>value</literal>'s type doesn't match, nothing happens.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-17-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-17-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-17-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-17-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-17-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-17-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var node = Node2D.new()
node.set("global_scale", Vector2(8, 2.5))
print(node.global_scale) # Prints (8, 2.5)</literal_block>
                </div>
                <div aria-labelledby="tab-17-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-17-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var node = new Node2D();
node.Set(Node2D.PropertyName.GlobalScale, new Vector2(8, 2.5));
GD.Print(node.GlobalScale); // Prints Vector2(8, 2.5)</literal_block>
                </div>
            </container>
            <paragraph><strong>Note:</strong> In C#, <literal>property</literal> must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the <literal>PropertyName</literal> class to avoid allocating a new <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> on each call.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-set-block-signals"></target>
            <paragraph classes="classref-method" ids="class-object-method-set-block-signals" names="class_object_method_set_block_signals"><abbreviation explanation="无返回值。">void</abbreviation> <strong>set_block_signals</strong>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>) <reference internal="True" refid="class-object-method-set-block-signals"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果设置为 <literal>true</literal>，这该对象将无法发出信号。因此，<reference internal="True" refid="class-object-method-emit-signal"><inline classes="std std-ref">emit_signal</inline></reference> 和信号连接将不起作用，直到该属性被设置为 <literal>false</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-set-deferred"></target>
            <paragraph classes="classref-method" ids="class-object-method-set-deferred" names="class_object_method_set_deferred"><abbreviation explanation="无返回值。">void</abbreviation> <strong>set_deferred</strong>(property: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-object-method-set-deferred"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Assigns <literal>value</literal> to the given <literal>property</literal>, at the end of the current frame. This is equivalent to calling <reference internal="True" refid="class-object-method-set"><inline classes="std std-ref">set</inline></reference> through <reference internal="True" refid="class-object-method-call-deferred"><inline classes="std std-ref">call_deferred</inline></reference>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-18-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-18-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-18-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-18-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-18-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-18-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var node = Node2D.new()
add_child(node)

node.rotation = 1.5
node.set_deferred("rotation", 3.0)
print(node.rotation) # Prints 1.5

await get_tree().process_frame
print(node.rotation) # Prints 3.0</literal_block>
                </div>
                <div aria-labelledby="tab-18-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-18-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var node = new Node2D();
node.Rotation = 1.5f;
node.SetDeferred(Node2D.PropertyName.Rotation, 3f);
GD.Print(node.Rotation); // Prints 1.5

await ToSignal(GetTree(), SceneTree.SignalName.ProcessFrame);
GD.Print(node.Rotation); // Prints 3.0</literal_block>
                </div>
            </container>
            <paragraph><strong>Note:</strong> In C#, <literal>property</literal> must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the <literal>PropertyName</literal> class to avoid allocating a new <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> on each call.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-set-indexed"></target>
            <paragraph classes="classref-method" ids="class-object-method-set-indexed" names="class_object_method_set_indexed"><abbreviation explanation="无返回值。">void</abbreviation> <strong>set_indexed</strong>(property_path: <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-object-method-set-indexed"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将由属性路径 <literal>property_path</literal> 标识的属性的值分配为 <literal>value</literal>。该路径应为相对于这个对象的 <reference internal="True" refuri="class_nodepath#class-nodepath"><inline classes="std std-ref">NodePath</inline></reference>，可以使用英文冒号（<literal>:</literal>）访问内嵌属性。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-19-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-19-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-19-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-19-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-19-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-19-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var node = Node2D.new()
node.set_indexed("position", Vector2(42, 0))
node.set_indexed("position:y", -10)
print(node.position) # 输出 (42, -10)</literal_block>
                </div>
                <div aria-labelledby="tab-19-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-19-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var node = new Node2D();
node.SetIndexed("position", new Vector2(42, 0));
node.SetIndexed("position:y", -10);
GD.Print(node.Position); // 输出 (42, -10)</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>在 C# 中引用内置 Godot 属性时 <literal>property_path</literal> 必须为 snake_case 蛇形大小写。请优先使用 <literal>PropertyName</literal> 类中暴露的名称，避免每次调用都重新分配一个 <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-set-message-translation"></target>
            <paragraph classes="classref-method" ids="class-object-method-set-message-translation" names="class_object_method_set_message_translation"><abbreviation explanation="无返回值。">void</abbreviation> <strong>set_message_translation</strong>(enable: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference>) <reference internal="True" refid="class-object-method-set-message-translation"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果设置为 <literal>true</literal>，则允许对象使用 <reference internal="True" refid="class-object-method-tr"><inline classes="std std-ref">tr</inline></reference> 和 <reference internal="True" refid="class-object-method-tr-n"><inline classes="std std-ref">tr_n</inline></reference> 翻译消息。该属性默认启用。另请参阅 <reference internal="True" refid="class-object-method-can-translate-messages"><inline classes="std std-ref">can_translate_messages</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-set-meta"></target>
            <paragraph classes="classref-method" ids="class-object-method-set-meta" names="class_object_method_set_meta"><abbreviation explanation="无返回值。">void</abbreviation> <strong>set_meta</strong>(name: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, value: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-object-method-set-meta"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>添加或更改对象元数据中名称为 <literal>name</literal> 的条目。元数据值 <literal>value</literal> 可以是任何 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>，尽管某些类型无法正确序列化。</paragraph>
            <paragraph>如果 <literal>value</literal> 为 <literal>null</literal>，则该条目被移除。等价于使用 <reference internal="True" refid="class-object-method-remove-meta"><inline classes="std std-ref">remove_meta</inline></reference>。另见 <reference internal="True" refid="class-object-method-has-meta"><inline classes="std std-ref">has_meta</inline></reference> 和 <reference internal="True" refid="class-object-method-get-meta"><inline classes="std std-ref">get_meta</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>元数据的名称必须是符合 <reference internal="True" refuri="class_stringname#class-stringname-method-is-valid-identifier"><inline classes="std std-ref">StringName.is_valid_identifier</inline></reference> 的有效标识符。</paragraph>
            <paragraph><strong>注意：</strong>名称以下划线（<literal>_</literal>）开头的元数据仅供编辑器使用。仅供编辑器使用的元数据不会在“检查器”中显示，虽然仍然能够被这个方法找到，但是不应该进行编辑。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-set-script"></target>
            <paragraph classes="classref-method" ids="class-object-method-set-script" names="class_object_method_set_script"><abbreviation explanation="无返回值。">void</abbreviation> <strong>set_script</strong>(script: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>) <reference internal="True" refid="class-object-method-set-script"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将脚本 <literal>script</literal> 附加至该对象，并进行实例化。因此会调用该脚本的 <reference internal="True" refid="class-object-private-method-init"><inline classes="std std-ref">_init</inline></reference>。<reference internal="True" refuri="class_script#class-script"><inline classes="std std-ref">Script</inline></reference> 可用于扩展对象的功能。</paragraph>
            <paragraph>如果已存在脚本，则该脚本的实例会被分离，其属性值和状态会丢失。仍会保留内置属性的值。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-to-string"></target>
            <paragraph classes="classref-method" ids="class-object-method-to-string" names="class_object_method_to_string"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>to_string</strong>() <reference internal="True" refid="class-object-method-to-string"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回表示对象的 <reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference>。默认为 <literal>"&lt;ClassName#RID&gt;"</literal>。覆盖 <reference internal="True" refid="class-object-private-method-to-string"><inline classes="std std-ref">_to_string</inline></reference> 以自定义对象的字符串表示形式。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-tr"></target>
            <paragraph classes="classref-method" ids="class-object-method-tr" names="class_object_method_tr"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>tr</strong>(message: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, context: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> = &amp;"") <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-tr"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Translates a <literal>message</literal>, using the translation catalogs configured in the Project Settings. Further <literal>context</literal> can be specified to help with the translation. Note that most <reference internal="True" refuri="class_control#class-control"><inline classes="std std-ref">Control</inline></reference> nodes automatically translate their strings, so this method is mostly useful for formatted strings or custom drawn text.</paragraph>
            <paragraph>If <reference internal="True" refid="class-object-method-can-translate-messages"><inline classes="std std-ref">can_translate_messages</inline></reference> is <literal>false</literal>, or no translation is available, this method returns the <literal>message</literal> without changes. See <reference internal="True" refid="class-object-method-set-message-translation"><inline classes="std std-ref">set_message_translation</inline></reference>.</paragraph>
            <paragraph>For detailed examples, see <reference internal="True" refuri="../tutorials/i18n/internationalizing_games"><inline classes="doc">Internationalizing games</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This method can't be used without an <strong>Object</strong> instance, as it requires the <reference internal="True" refid="class-object-method-can-translate-messages"><inline classes="std std-ref">can_translate_messages</inline></reference> method. To translate strings in a static context, use <reference internal="True" refuri="class_translationserver#class-translationserver-method-translate"><inline classes="std std-ref">TranslationServer.translate</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-object-method-tr-n"></target>
            <paragraph classes="classref-method" ids="class-object-method-tr-n" names="class_object_method_tr_n"><reference internal="True" refuri="class_string#class-string"><inline classes="std std-ref">String</inline></reference> <strong>tr_n</strong>(message: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, plural_message: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference>, n: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>, context: <reference internal="True" refuri="class_stringname#class-stringname"><inline classes="std std-ref">StringName</inline></reference> = &amp;"") <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-object-method-tr-n"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Translates a <literal>message</literal> or <literal>plural_message</literal>, using the translation catalogs configured in the Project Settings. Further <literal>context</literal> can be specified to help with the translation.</paragraph>
            <paragraph>If <reference internal="True" refid="class-object-method-can-translate-messages"><inline classes="std std-ref">can_translate_messages</inline></reference> is <literal>false</literal>, or no translation is available, this method returns <literal>message</literal> or <literal>plural_message</literal>, without changes. See <reference internal="True" refid="class-object-method-set-message-translation"><inline classes="std std-ref">set_message_translation</inline></reference>.</paragraph>
            <paragraph>The <literal>n</literal> is the number, or amount, of the message's subject. It is used by the translation system to fetch the correct plural form for the current language.</paragraph>
            <paragraph>For detailed examples, see <reference internal="True" refuri="../tutorials/i18n/localization_using_gettext"><inline classes="doc">Localization using gettext</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> Negative and <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> numbers may not properly apply to some countable subjects. It's recommended to handle these cases with <reference internal="True" refid="class-object-method-tr"><inline classes="std std-ref">tr</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> This method can't be used without an <strong>Object</strong> instance, as it requires the <reference internal="True" refid="class-object-method-can-translate-messages"><inline classes="std std-ref">can_translate_messages</inline></reference> method. To translate strings in a static context, use <reference internal="True" refuri="class_translationserver#class-translationserver-method-translate-plural"><inline classes="std std-ref">TranslationServer.translate_plural</inline></reference>.</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了能接受在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="void"><abbreviation explanation="无返回值。">void</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
