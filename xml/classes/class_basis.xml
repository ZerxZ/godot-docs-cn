<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_basis.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/4.2/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/4.2/doc/classes/Basis.xml.</comment>
    <target refid="class-basis"></target>
    <section ids="basis class-basis" names="basis class_basis">
        <title>Basis</title>
        <paragraph>用于表示 3D 旋转和缩放的 3×3 矩阵。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>用于表示 3D 旋转和缩放的 3×3 矩阵。通常用作 <reference internal="True" refuri="class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference> 的正交基。</paragraph>
            <paragraph>包含 3 个向量字段 X、Y 和 Z 作为其列，它们通常被解释为变换的局部基向量。对于这种用途，它由缩放和旋转矩阵组成，顺序为 (M = R.S)。</paragraph>
            <paragraph>基也可以作为 3D 向量的数组访问。这些向量通常彼此正交，但（由于缩放）不一定是归一化的。</paragraph>
            <paragraph>有关一般介绍，请参阅 <reference internal="True" refuri="../tutorials/math/matrices_and_transforms"><inline classes="doc">矩阵与变换</inline></reference> 教程。</paragraph>
            <note>
                <paragraph>通过 C# 使用这个 API 时有显著的不同。详见 <reference internal="True" refuri="../tutorials/scripting/c_sharp/c_sharp_differences#doc-c-sharp-differences"><inline classes="std std-ref">C# API 与 GDScript 的差异</inline></reference>。</paragraph>
            </note>
        </section>
        <section classes="classref-introduction-group" ids="id2" names="教程">
            <title>教程</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/math/index"><inline classes="doc">数学文档索引</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/math/matrices_and_transforms"><inline classes="doc">矩阵与变换</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/3d/using_transforms"><inline classes="doc">使用 3D 变换</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="矩阵变换演示" refuri="https://godotengine.org/asset-library/asset/584">矩阵变换演示</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="3D 平台跳跃演示" refuri="https://godotengine.org/asset-library/asset/125">3D 平台跳跃演示</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="3D 体素演示" refuri="https://godotengine.org/asset-library/asset/676">3D 体素演示</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="2.5D 演示" refuri="https://godotengine.org/asset-library/asset/583">2.5D 演示</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="属性">
            <title>属性</title>
            <table classes="colwidths-auto">
                <tgroup cols="3">
                    <colspec colwidth="31"></colspec>
                    <colspec colwidth="34"></colspec>
                    <colspec colwidth="22"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector3(1, 0, 0)</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector3(0, 1, 0)</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector3(0, 0, 1)</literal></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id4" names="构造函数">
            <title>构造函数</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="27"></colspec>
                    <colspec colwidth="170"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>(</strong> <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>(</strong> <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> from <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> axis, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> angle <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> from <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> x_axis, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> y_axis, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> z_axis <strong>)</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id5" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="37"></colspec>
                    <colspec colwidth="206"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-determinant"><inline classes="std std-ref">determinant</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-from-euler"><inline classes="std std-ref">from_euler</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> euler, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> order=2 <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-from-scale"><inline classes="std std-ref">from_scale</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> scale <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-get-euler"><inline classes="std std-ref">get_euler</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> order=2 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-get-rotation-quaternion"><inline classes="std std-ref">get_rotation_quaternion</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-get-scale"><inline classes="std std-ref">get_scale</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-inverse"><inline classes="std std-ref">inverse</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-is-conformal"><inline classes="std std-ref">is_conformal</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-is-equal-approx"><inline classes="std std-ref">is_equal_approx</inline></reference> <strong>(</strong> <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> b <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-is-finite"><inline classes="std std-ref">is_finite</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-looking-at"><inline classes="std std-ref">looking_at</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> target, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> up=Vector3(0, 1, 0), <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> use_model_front=false <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-orthonormalized"><inline classes="std std-ref">orthonormalized</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-rotated"><inline classes="std std-ref">rotated</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> axis, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> angle <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-scaled"><inline classes="std std-ref">scaled</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> scale <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-slerp"><inline classes="std std-ref">slerp</inline></reference> <strong>(</strong> <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> to, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> weight <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-tdotx"><inline classes="std std-ref">tdotx</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> with <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-tdoty"><inline classes="std std-ref">tdoty</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> with <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-tdotz"><inline classes="std std-ref">tdotz</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> with <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-transposed"><inline classes="std std-ref">transposed</inline></reference> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id6" names="操作符">
            <title>操作符</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="31"></colspec>
                    <colspec colwidth="101"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-neq-basis"><inline classes="std std-ref">operator !=</inline></reference> <strong>(</strong> <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-mul-basis"><inline classes="std std-ref">operator *</inline></reference> <strong>(</strong> <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-mul-vector3"><inline classes="std std-ref">operator *</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-mul-float"><inline classes="std std-ref">operator *</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-mul-int"><inline classes="std std-ref">operator *</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-eq-basis"><inline classes="std std-ref">operator ==</inline></reference> <strong>(</strong> <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> right <strong>)</strong></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-idx-int"><inline classes="std std-ref">operator []</inline></reference> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id7" names="常量">
            <title>常量</title>
            <target refid="class-basis-constant-identity"></target>
            <paragraph classes="classref-constant" ids="class-basis-constant-identity" names="class_basis_constant_identity"><strong>IDENTITY</strong> = <literal>Basis(1, 0, 0, 0, 1, 0, 0, 0, 1)</literal></paragraph>
            <paragraph>恒等基，未应用旋转或缩放。</paragraph>
            <paragraph>这与不带任何参数调用 <reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference> 来创建是一样的。这个常量可以用来让你的代码更清晰，并与 C# 保持一致。</paragraph>
            <target refid="class-basis-constant-flip-x"></target>
            <paragraph classes="classref-constant" ids="class-basis-constant-flip-x" names="class_basis_constant_flip_x"><strong>FLIP_X</strong> = <literal>Basis(-1, 0, 0, 0, 1, 0, 0, 0, 1)</literal></paragraph>
            <paragraph>在变换中使用时，会沿 X 轴翻转某物的基。</paragraph>
            <target refid="class-basis-constant-flip-y"></target>
            <paragraph classes="classref-constant" ids="class-basis-constant-flip-y" names="class_basis_constant_flip_y"><strong>FLIP_Y</strong> = <literal>Basis(1, 0, 0, 0, -1, 0, 0, 0, 1)</literal></paragraph>
            <paragraph>在变换中使用时，会沿 Y 轴翻转某物的基。</paragraph>
            <target refid="class-basis-constant-flip-z"></target>
            <paragraph classes="classref-constant" ids="class-basis-constant-flip-z" names="class_basis_constant_flip_z"><strong>FLIP_Z</strong> = <literal>Basis(1, 0, 0, 0, 1, 0, 0, 0, -1)</literal></paragraph>
            <paragraph>在变换中使用时，会沿 Z 轴翻转某物的基。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id8" names="属性说明">
            <title>属性说明</title>
            <target refid="class-basis-property-x"></target>
            <paragraph classes="classref-property" ids="class-basis-property-x" names="class_basis_property_x"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>x</strong> = <literal>Vector3(1, 0, 0)</literal></paragraph>
            <paragraph>基矩阵的 X 向量（第 0 列）。相当于数组索引 <literal>0</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-property-y"></target>
            <paragraph classes="classref-property" ids="class-basis-property-y" names="class_basis_property_y"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>y</strong> = <literal>Vector3(0, 1, 0)</literal></paragraph>
            <paragraph>基矩阵的 Y 向量（第 1 列）。相当于数组索引 <literal>1</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-property-z"></target>
            <paragraph classes="classref-property" ids="class-basis-property-z" names="class_basis_property_z"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>z</strong> = <literal>Vector3(0, 0, 1)</literal></paragraph>
            <paragraph>基矩阵的 Z 向量（第 2 列）。相当于数组索引 <literal>2</literal>。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id9" names="构造函数说明">
            <title>构造函数说明</title>
            <target refid="class-basis-constructor-basis"></target>
            <paragraph classes="classref-constructor" ids="class-basis-constructor-basis" names="class_basis_constructor_basis"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong> <strong>(</strong> <strong>)</strong></paragraph>
            <paragraph>构造默认初始化为 <reference internal="True" refid="class-basis-constant-identity"><inline classes="std std-ref">IDENTITY</inline></reference> 的 <strong>Basis</strong> 。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong> <strong>(</strong> <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> from <strong>)</strong></paragraph>
            <paragraph>构造给定 <strong>Basis</strong> 的副本。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> axis, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> angle <strong>)</strong></paragraph>
            <paragraph>构造纯旋转的基矩阵，围绕给定的轴 <literal>axis</literal> 旋转 <literal>angle</literal>（单位为弧度）。该轴必须是归一化向量。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong> <strong>(</strong> <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> from <strong>)</strong></paragraph>
            <paragraph>根据给定的四元数构造纯旋转的基矩阵。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> x_axis, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> y_axis, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> z_axis <strong>)</strong></paragraph>
            <paragraph>从 3 个轴向量（矩阵列）构造一个基矩阵。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id10" names="方法说明">
            <title>方法说明</title>
            <target refid="class-basis-method-determinant"></target>
            <paragraph classes="classref-method" ids="class-basis-method-determinant" names="class_basis_method_determinant"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>determinant</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回基矩阵的行列式。如果基是均匀缩放的，它的行列式是缩放的平方。</paragraph>
            <paragraph>负的行列式意味着基的缩放是负的。负的行列式意味着基不可逆，通常被认为无效。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-from-euler"></target>
            <paragraph classes="classref-method" ids="class-basis-method-from-euler" names="class_basis_method_from_euler"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>from_euler</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> euler, <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> order=2 <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>按照指定的欧拉旋转顺序，从欧拉角中构造一个纯旋转的 Basis 矩阵。默认情况下，使用 YXZ 顺序（最常用）。参见枚举 <reference internal="True" refuri="class_@globalscope#enum-globalscope-eulerorder"><inline classes="std std-ref">EulerOrder</inline></reference> 的可能值。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-from-scale"></target>
            <paragraph classes="classref-method" ids="class-basis-method-from-scale" names="class_basis_method_from_scale"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>from_scale</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> scale <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>构造一个没有旋转或剪切的纯缩放基础矩阵。scale 值被设置为矩阵的对角线，矩阵的其他部分为零。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-get-euler"></target>
            <paragraph classes="classref-method" ids="class-basis-method-get-euler" names="class_basis_method_get_euler"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>get_euler</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> order=2 <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>以欧拉角的形式返回基的旋转。欧拉顺序取决于 <literal>order</literal> 参数，默认使用 YXZ 惯例：分解时，先 Z、再 X、最后 Y。返回的向量包含格式为（X 角、Y 角、Z 角）的旋转角。</paragraph>
            <paragraph>可考虑改用 <reference internal="True" refid="class-basis-method-get-rotation-quaternion"><inline classes="std std-ref">get_rotation_quaternion</inline></reference> 方法，将返回 <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> 四元数而不是欧拉角。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-get-rotation-quaternion"></target>
            <paragraph classes="classref-method" ids="class-basis-method-get-rotation-quaternion" names="class_basis_method_get_rotation_quaternion"><reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> <strong>get_rotation_quaternion</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>以四元数的形式返回基的旋转。如果你需要欧拉角，请参阅 <reference internal="True" refid="class-basis-method-get-euler"><inline classes="std std-ref">get_euler</inline></reference> 方法，但通常首选四元数而不是欧拉角。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-get-scale"></target>
            <paragraph classes="classref-method" ids="class-basis-method-get-scale" names="class_basis_method_get_scale"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>get_scale</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>假设矩阵是旋转和缩放的组合，返回沿各轴缩放系数的绝对值。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-inverse"></target>
            <paragraph classes="classref-method" ids="class-basis-method-inverse" names="class_basis_method_inverse"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>inverse</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回矩阵的逆值。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-is-conformal"></target>
            <paragraph classes="classref-method" ids="class-basis-method-is-conformal" names="class_basis_method_is_conformal"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_conformal</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该基是共形的，则返回<literal>true</literal>，这意味着它保留角度和距离比率，并且只能由旋转和均匀缩放组成。如果该基具有不均匀的缩放或剪切/倾斜，则返回 <literal>false</literal>。这可以用来验证该基是否不失真，这对于物理和其他用例很重要。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-is-equal-approx"></target>
            <paragraph classes="classref-method" ids="class-basis-method-is-equal-approx" names="class_basis_method_is_equal_approx"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_equal_approx</strong> <strong>(</strong> <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> b <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该基和 <literal>b</literal> 近似相等，则返回 <literal>true</literal>，判断方法是在每个向量分量上调用 <reference internal="True" refuri="class_@globalscope#class-globalscope-method-is-equal-approx"><inline classes="std std-ref">@GlobalScope.is_equal_approx</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-is-finite"></target>
            <paragraph classes="classref-method" ids="class-basis-method-is-finite" names="class_basis_method_is_finite"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_finite</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>如果该基是有限的，则返回 <literal>true</literal>，判断方法是在每个向量分量上调用 <reference internal="True" refuri="class_@globalscope#class-globalscope-method-is-finite"><inline classes="std std-ref">@GlobalScope.is_finite</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-looking-at"></target>
            <paragraph classes="classref-method" ids="class-basis-method-looking-at" names="class_basis_method_looking_at"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>looking_at</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> target, <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> up=Vector3(0, 1, 0), <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> use_model_front=false <strong>)</strong> <abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></paragraph>
            <paragraph>创建旋转 Basis，向前的轴（-Z）指向 <literal>target</literal> 的位置。</paragraph>
            <paragraph>向上的轴（+Y）在保持与向前的轴垂直的前提下，尽可能接近 <literal>up</literal> 向量。最终的 Basis 是标准正交基。 <literal>target</literal> 和 <literal>up</literal> 向量不能为零，不能互相平行。</paragraph>
            <paragraph>如果 <literal>use_model_front</literal> 为 <literal>true</literal>，则会将 +Z 轴（资产正面）作为向前的轴（此时 +X 为左），指向 <literal>target</literal> 的位置。默认情况下会将 -Z 轴（相机前方）作为向前的轴（此时 +X 为右）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-orthonormalized"></target>
            <paragraph classes="classref-method" ids="class-basis-method-orthonormalized" names="class_basis_method_orthonormalized"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>orthonormalized</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回矩阵的正交归一化版本（对于正交矩阵来说，偶尔调用以避免四舍五入错误是有用的）。这将在矩阵的基上执行 Gram-Schmidt 正交化。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-rotated"></target>
            <paragraph classes="classref-method" ids="class-basis-method-rotated" names="class_basis_method_rotated"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>rotated</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> axis, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> angle <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>围绕给定轴线引入一个额外的旋转 <literal>angle</literal>（单位为弧度）。该轴必须是一个归一化的向量。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-scaled"></target>
            <paragraph classes="classref-method" ids="class-basis-method-scaled" names="class_basis_method_scaled"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>scaled</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> scale <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>引入一个由给定的 3D 缩放因子指定的附加缩放。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-slerp"></target>
            <paragraph classes="classref-method" ids="class-basis-method-slerp" names="class_basis_method_slerp"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>slerp</strong> <strong>(</strong> <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> to, <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> weight <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>假设该矩阵是一个合适的旋转矩阵，slerp 与另一个旋转矩阵进行球面直线插值。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-tdotx"></target>
            <paragraph classes="classref-method" ids="class-basis-method-tdotx" names="class_basis_method_tdotx"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>tdotx</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> with <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>与矩阵 X 轴的转置点积。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-tdoty"></target>
            <paragraph classes="classref-method" ids="class-basis-method-tdoty" names="class_basis_method_tdoty"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>tdoty</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> with <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>与矩阵 Y 轴的转置点积。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-tdotz"></target>
            <paragraph classes="classref-method" ids="class-basis-method-tdotz" names="class_basis_method_tdotz"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>tdotz</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> with <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>与矩阵 Z 轴的转置点积。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-transposed"></target>
            <paragraph classes="classref-method" ids="class-basis-method-transposed" names="class_basis_method_transposed"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>transposed</strong> <strong>(</strong> <strong>)</strong> <abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
            <paragraph>返回矩阵的转置版本。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id11" names="操作符说明">
            <title>操作符说明</title>
            <target refid="class-basis-operator-neq-basis"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-neq-basis" names="class_basis_operator_neq_basis"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong> <strong>(</strong> <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果 <strong>Basis</strong> 矩阵不相等，则返回 <literal>true</literal>。</paragraph>
            <paragraph><strong>注意：</strong>由于浮点数精度误差，请考虑改用 <reference internal="True" refid="class-basis-method-is-equal-approx"><inline classes="std std-ref">is_equal_approx</inline></reference>，会更可靠。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-mul-basis"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-mul-basis" names="class_basis_operator_mul_basis"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>operator *</strong> <strong>(</strong> <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>通过将这两个 basis 矩阵相乘来组合它们。这具有使用第一个 basis（父项）变换第二个 basis（子项）的效果。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-mul-vector3"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-mul-vector3" names="class_basis_operator_mul_vector3"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>operator *</strong> <strong>(</strong> <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>使用给定的 <strong>Basis</strong> 矩阵变换（乘）该 <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-mul-float"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-mul-float" names="class_basis_operator_mul_float"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>operator *</strong> <strong>(</strong> <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>该运算符会对 <strong>Basis</strong> 的所有分量进行乘操作，达到统一缩放的效果。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-mul-int"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-mul-int" names="class_basis_operator_mul_int"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>operator *</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>该运算符会对 <strong>Basis</strong> 的所有分量进行乘操作，达到统一缩放的效果。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-eq-basis"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-eq-basis" names="class_basis_operator_eq_basis"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong> <strong>(</strong> <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> right <strong>)</strong></paragraph>
            <paragraph>如果 <strong>Basis</strong> 矩阵完全相等，则返回 <literal>true</literal>。</paragraph>
            <paragraph><strong>注意：</strong>由于浮点数精度误差，请考虑改用 <reference internal="True" refid="class-basis-method-is-equal-approx"><inline classes="std std-ref">is_equal_approx</inline></reference>，会更可靠。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-idx-int"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-idx-int" names="class_basis_operator_idx_int"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>operator []</strong> <strong>(</strong> <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> index <strong>)</strong></paragraph>
            <paragraph>使用索引访问基的分量。<literal>b[0]</literal> 相当于 <literal>b.x</literal>、<literal>b[1]</literal> 相当于 <literal>b.y</literal>、<literal>b[2]</literal> 相当于 <literal>b.z</literal>。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用。不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，所以可以直接使用类名调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
