<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_basis.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/master/doc/classes/Basis.xml.</comment>
    <target refid="class-basis"></target>
    <section ids="basis class-basis" names="basis class_basis">
        <title>Basis</title>
        <paragraph>用于表示 3D 旋转和缩放的 3×3 矩阵。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph><strong>Basis</strong> 内置 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> 类型是一种 3×3 <reference name="矩阵" refuri="https://en.wikipedia.org/wiki/Matrix_(mathematics)">矩阵</reference>，用于表示 3D 旋转、缩放和剪切。常用于 <reference internal="True" refuri="class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference>。</paragraph>
            <paragraph><strong>Basis</strong> 由 3 个轴向量组成，每个轴向量代表矩阵的一列：<reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference>、<reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference> 和 <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference>。每个轴的长度（<reference internal="True" refuri="class_vector3#class-vector3-method-length"><inline classes="std std-ref">Vector3.length</inline></reference>）都会影响该基的缩放，而所有轴的方向将影响旋转。通常，这些轴彼此垂直。但是，当你单独旋转任意轴时，该基会被剪切。对 3D 模型应用剪切基将使模型显得扭曲。</paragraph>
            <paragraph>如果 <strong>Basis</strong> 的轴彼此垂直，则它是<strong>正交的</strong>。如果每个轴的长度为 <literal>1</literal>，则该基是<strong>归一化的</strong>。如果所有轴共享相同的长度，则该基是<strong>均匀的</strong>（请参阅 <reference internal="True" refid="class-basis-method-get-scale"><inline classes="std std-ref">get_scale</inline></reference>）。如果一个基既是正交的又是归一化的，则它是<strong>正交归一的</strong>，这使得它只能表示旋转。如果一个基既正交又均匀，那么它就是<strong>共形的</strong>，这确保了它不被扭曲。</paragraph>
            <paragraph>通用介绍见教程<reference internal="True" refuri="../tutorials/math/matrices_and_transforms"><inline classes="doc">《矩阵与变换》</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>Godot 使用<reference name="右手坐标系" refuri="https://zh.wikipedia.org/zh-cn/%E5%8F%B3%E6%89%8B%E5%AE%9A%E5%89%87">右手坐标系</reference>，这是一种普遍标准。方向方面，<reference internal="True" refuri="class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference> 等内置类型的约定是 -Z 指向前方（+X 为右、+Y 为上、+Z 为后）。其他对象可能使用不同的方向约定。更多信息见教程<reference name="《导入 3D 场景》" refuri="../tutorials/assets_pipeline/importing_scenes.html#d-asset-direction-conventions">《导入 3D 场景》</reference>。</paragraph>
            <paragraph><strong>注意：</strong>基矩阵按<reference name="列为主" refuri="https://www.mindcontrol.org/~hplus/graphics/matrix-layout.html">列为主</reference>的顺序公开，这与 OpenGL 一致。但是内部使用行为主的顺序存储，这与 DirectX 一致。</paragraph>
            <note>
                <paragraph>通过 C# 使用这个 API 时有显著的不同。详见 <reference internal="True" refuri="../tutorials/scripting/c_sharp/c_sharp_differences#doc-c-sharp-differences"><inline classes="std std-ref">C# API 与 GDScript 的差异</inline></reference>。</paragraph>
            </note>
        </section>
        <section classes="classref-introduction-group" ids="id2" names="教程">
            <title>教程</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/math/index"><inline classes="doc">数学文档索引</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/math/matrices_and_transforms"><inline classes="doc">矩阵与变换</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/3d/using_transforms"><inline classes="doc">使用 3D 变换</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="矩阵变换演示" refuri="https://godotengine.org/asset-library/asset/2787">矩阵变换演示</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="3D 平台跳跃演示" refuri="https://godotengine.org/asset-library/asset/2748">3D 平台跳跃演示</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="3D 体素演示" refuri="https://godotengine.org/asset-library/asset/2755">3D 体素演示</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="2.5D 游戏演示" refuri="https://godotengine.org/asset-library/asset/2783">2.5D 游戏演示</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="属性">
            <title>属性</title>
            <table classes="colwidths-auto">
                <tgroup cols="3">
                    <colspec colwidth="31"></colspec>
                    <colspec colwidth="34"></colspec>
                    <colspec colwidth="22"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector3(1, 0, 0)</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector3(0, 1, 0)</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector3(0, 0, 1)</literal></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id4" names="构造函数">
            <title>构造函数</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="27"></colspec>
                    <colspec colwidth="171"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference>(from: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference>(axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, angle: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference>(from: <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference>(x_axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, y_axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, z_axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id5" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="37"></colspec>
                    <colspec colwidth="211"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-determinant"><inline classes="std std-ref">determinant</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-from-euler"><inline classes="std std-ref">from_euler</inline></reference>(euler: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, order: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 2) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-from-scale"><inline classes="std std-ref">from_scale</inline></reference>(scale: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-get-euler"><inline classes="std std-ref">get_euler</inline></reference>(order: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 2) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-get-rotation-quaternion"><inline classes="std std-ref">get_rotation_quaternion</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-get-scale"><inline classes="std std-ref">get_scale</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-inverse"><inline classes="std std-ref">inverse</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-is-conformal"><inline classes="std std-ref">is_conformal</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-is-equal-approx"><inline classes="std std-ref">is_equal_approx</inline></reference>(b: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-is-finite"><inline classes="std std-ref">is_finite</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-looking-at"><inline classes="std std-ref">looking_at</inline></reference>(target: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, up: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> = Vector3(0, 1, 0), use_model_front: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-orthonormalized"><inline classes="std std-ref">orthonormalized</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-rotated"><inline classes="std std-ref">rotated</inline></reference>(axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, angle: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-scaled"><inline classes="std std-ref">scaled</inline></reference>(scale: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-slerp"><inline classes="std std-ref">slerp</inline></reference>(to: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>, weight: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-tdotx"><inline classes="std std-ref">tdotx</inline></reference>(with: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-tdoty"><inline classes="std std-ref">tdoty</inline></reference>(with: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-tdotz"><inline classes="std std-ref">tdotz</inline></reference>(with: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-transposed"><inline classes="std std-ref">transposed</inline></reference>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id6" names="操作符">
            <title>操作符</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="31"></colspec>
                    <colspec colwidth="98"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-neq-basis"><inline classes="std std-ref">operator !=</inline></reference>(right: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-mul-basis"><inline classes="std std-ref">operator *</inline></reference>(right: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-mul-vector3"><inline classes="std std-ref">operator *</inline></reference>(right: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-mul-float"><inline classes="std std-ref">operator *</inline></reference>(right: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-mul-int"><inline classes="std std-ref">operator *</inline></reference>(right: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-div-float"><inline classes="std std-ref">operator /</inline></reference>(right: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-div-int"><inline classes="std std-ref">operator /</inline></reference>(right: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-eq-basis"><inline classes="std std-ref">operator ==</inline></reference>(right: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-idx-int"><inline classes="std std-ref">operator []</inline></reference>(index: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id7" names="常量">
            <title>常量</title>
            <target refid="class-basis-constant-identity"></target>
            <paragraph classes="classref-constant" ids="class-basis-constant-identity" names="class_basis_constant_identity"><strong>IDENTITY</strong> = <literal>Basis(1, 0, 0, 0, 1, 0, 0, 0, 1)</literal> <reference internal="True" refid="class-basis-constant-identity"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>单位基。这是一个没有旋转、没有剪切的基，其缩放为 <literal>1</literal>。这意味着：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference> 指向右侧（<reference internal="True" refuri="class_vector3#class-vector3-constant-right"><inline classes="std std-ref">Vector3.RIGHT</inline></reference>）；</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference> 指向上方（<reference internal="True" refuri="class_vector3#class-vector3-constant-up"><inline classes="std std-ref">Vector3.UP</inline></reference>）；</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference> 指向后面（<reference internal="True" refuri="class_vector3#class-vector3-constant-back"><inline classes="std std-ref">Vector3.BACK</inline></reference>）。</paragraph>
                </list_item>
            </bullet_list>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var basis := Basis.IDENTITY
print("| X | Y | Z")
print("| %s | %s | %s" % [basis.x.x, basis.y.x, basis.z.x])
print("| %s | %s | %s" % [basis.x.y, basis.y.y, basis.z.y])
print("| %s | %s | %s" % [basis.x.z, basis.y.z, basis.z.z])
# 输出：
# | X | Y | Z
# | 1 | 0 | 0
# | 0 | 1 | 0
# | 0 | 0 | 1</literal_block>
            <paragraph>这与创建没有任何参数的 <reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference> 相同。该常量可用于使你的代码更清晰，并与 C# 保持一致。</paragraph>
            <target refid="class-basis-constant-flip-x"></target>
            <paragraph classes="classref-constant" ids="class-basis-constant-flip-x" names="class_basis_constant_flip_x"><strong>FLIP_X</strong> = <literal>Basis(-1, 0, 0, 0, 1, 0, 0, 0, 1)</literal> <reference internal="True" refid="class-basis-constant-flip-x"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>当任意基被 <reference internal="True" refid="class-basis-constant-flip-x"><inline classes="std std-ref">FLIP_X</inline></reference> 相乘时，它会取负 <reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference> 轴（X 列）的所有分量。</paragraph>
            <paragraph>当 <reference internal="True" refid="class-basis-constant-flip-x"><inline classes="std std-ref">FLIP_X</inline></reference> 被任意基相乘时，它会取负所有轴（X 行）的 <reference internal="True" refuri="class_vector3#class-vector3-property-x"><inline classes="std std-ref">Vector3.x</inline></reference> 分量。</paragraph>
            <target refid="class-basis-constant-flip-y"></target>
            <paragraph classes="classref-constant" ids="class-basis-constant-flip-y" names="class_basis_constant_flip_y"><strong>FLIP_Y</strong> = <literal>Basis(1, 0, 0, 0, -1, 0, 0, 0, 1)</literal> <reference internal="True" refid="class-basis-constant-flip-y"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>当任意基被 <reference internal="True" refid="class-basis-constant-flip-y"><inline classes="std std-ref">FLIP_Y</inline></reference> 相乘时，它会取负 <reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference> 轴（Y 列）的所有分量。</paragraph>
            <paragraph>当 <reference internal="True" refid="class-basis-constant-flip-y"><inline classes="std std-ref">FLIP_Y</inline></reference> 被任意基相乘时，它会取负所有轴（Y 行）的 <reference internal="True" refuri="class_vector3#class-vector3-property-y"><inline classes="std std-ref">Vector3.y</inline></reference> 分量。</paragraph>
            <target refid="class-basis-constant-flip-z"></target>
            <paragraph classes="classref-constant" ids="class-basis-constant-flip-z" names="class_basis_constant_flip_z"><strong>FLIP_Z</strong> = <literal>Basis(1, 0, 0, 0, 1, 0, 0, 0, -1)</literal> <reference internal="True" refid="class-basis-constant-flip-z"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>当任意基被 <reference internal="True" refid="class-basis-constant-flip-z"><inline classes="std std-ref">FLIP_Z</inline></reference> 相乘时，它会取负 <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference> 轴（Z 列）的所有分量。</paragraph>
            <paragraph>当 <reference internal="True" refid="class-basis-constant-flip-z"><inline classes="std std-ref">FLIP_Z</inline></reference> 被任意基相乘时，它会取负所有轴（Z 行）的 <reference internal="True" refuri="class_vector3#class-vector3-property-z"><inline classes="std std-ref">Vector3.z</inline></reference> 分量。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id8" names="属性说明">
            <title>属性说明</title>
            <target refid="class-basis-property-x"></target>
            <paragraph classes="classref-property" ids="class-basis-property-x" names="class_basis_property_x"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>x</strong> = <literal>Vector3(1, 0, 0)</literal> <reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>该基的 X 轴和矩阵的 <literal>0</literal> 列。</paragraph>
            <paragraph>在单位基上，该向量指向右侧（<reference internal="True" refuri="class_vector3#class-vector3-constant-right"><inline classes="std std-ref">Vector3.RIGHT</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-property-y"></target>
            <paragraph classes="classref-property" ids="class-basis-property-y" names="class_basis_property_y"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>y</strong> = <literal>Vector3(0, 1, 0)</literal> <reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>该基的 Y 轴和矩阵的第 <literal>1</literal> 列。</paragraph>
            <paragraph>在单位基上，该向量指向上方（<reference internal="True" refuri="class_vector3#class-vector3-constant-up"><inline classes="std std-ref">Vector3.UP</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-property-z"></target>
            <paragraph classes="classref-property" ids="class-basis-property-z" names="class_basis_property_z"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>z</strong> = <literal>Vector3(0, 0, 1)</literal> <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>该基的 Z 轴和矩阵的第 <literal>2</literal> 列。</paragraph>
            <paragraph>在单位基上，该向量指向后面（<reference internal="True" refuri="class_vector3#class-vector3-constant-back"><inline classes="std std-ref">Vector3.BACK</inline></reference>）。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id9" names="构造函数说明">
            <title>构造函数说明</title>
            <target refid="class-basis-constructor-basis"></target>
            <paragraph classes="classref-constructor" ids="class-basis-constructor-basis" names="class_basis_constructor_basis"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong>() <reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>构造一个与 <reference internal="True" refid="class-basis-constant-identity"><inline classes="std std-ref">IDENTITY</inline></reference> 相同的 <strong>Basis</strong>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong>(from: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>)</paragraph>
            <paragraph>构造给定 <strong>Basis</strong> 的副本。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong>(axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, angle: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>)</paragraph>
            <paragraph>构造仅表示旋转的 <strong>Basis</strong>，给定的 <literal>angle</literal> 以弧度为单位，表示围绕 <literal>axis</literal> 轴的旋转量。这个轴必须是归一化的向量。</paragraph>
            <paragraph><strong>注意：</strong>与对 <reference internal="True" refid="class-basis-constant-identity"><inline classes="std std-ref">IDENTITY</inline></reference> 基使用 <reference internal="True" refid="class-basis-method-rotated"><inline classes="std std-ref">rotated</inline></reference> 一致。多角度旋转请改用 <reference internal="True" refid="class-basis-method-from-euler"><inline classes="std std-ref">from_euler</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong>(from: <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference>)</paragraph>
            <paragraph>根据给定的 <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> 构造仅表示旋转的 <strong>Basis</strong>。</paragraph>
            <paragraph><strong>注意：</strong>四元数<emphasis>仅</emphasis>存储旋转，不会存储缩放。因此，<strong>Basis</strong> 到 <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> 的转换并不一定可逆。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong>(x_axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, y_axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, z_axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>)</paragraph>
            <paragraph>根据 3 个轴向量构造 <strong>Basis</strong>。这些是基矩阵的列向量。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id10" names="方法说明">
            <title>方法说明</title>
            <target refid="class-basis-method-determinant"></target>
            <paragraph classes="classref-method" ids="class-basis-method-determinant" names="class_basis_method_determinant"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>determinant</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-determinant"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回基矩阵的<reference name="行列式" refuri="https://zh.wikipedia.org/wiki/%E8%A1%8C%E5%88%97%E5%BC%8F">行列式</reference>。在高等数学中，这个数可以用来确定一些性质：</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>如果行列式为 <literal>0</literal>，则基不可逆（见 <reference internal="True" refid="class-basis-method-inverse"><inline classes="std std-ref">inverse</inline></reference>）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>如果行列式为负数，则基表示负缩放。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>注意：</strong>如果基的每个轴缩放都相同，那么这个行列式始终为 2 的该缩放次幂。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-from-euler"></target>
            <paragraph classes="classref-method" ids="class-basis-method-from-euler" names="class_basis_method_from_euler"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>from_euler</strong>(euler: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, order: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 2) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation> <reference internal="True" refid="class-basis-method-from-euler"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>根据给定的 <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> 构造 <strong>Basis</strong>，这个向量为 <reference name="欧拉角" refuri="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%8B%89%E8%A7%92">欧拉角</reference>，单位为弧度。</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="class_vector3#class-vector3-property-x"><inline classes="std std-ref">Vector3.x</inline></reference> 应包含围绕 <reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference> 轴的角度（俯仰）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_vector3#class-vector3-property-y"><inline classes="std std-ref">Vector3.y</inline></reference> 应包含围绕 <reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference> 轴的角度（偏摆）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_vector3#class-vector3-property-z"><inline classes="std std-ref">Vector3.z</inline></reference> 应包含围绕 <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference> 轴的角度（翻滚）。</paragraph>
                </list_item>
            </bullet_list>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># 创建 Z 轴向下的 Basis。
var my_basis = Basis.from_euler(Vector3(TAU / 4, 0, 0))

print(my_basis.z) # 输出 (0, -1, 0)。</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// 创建 Z 轴向下的 Basis。
var myBasis = Basis.FromEuler(new Vector3(Mathf.Tau / 4.0f, 0.0f, 0.0f));

GD.Print(myBasis.Z); // 输出 (0, -1, 0)。</literal_block>
                </div>
            </container>
            <paragraph>连续旋转的顺序可以通过 <literal>order</literal> 修改（见 <reference internal="True" refuri="class_@globalscope#enum-globalscope-eulerorder"><inline classes="std std-ref">EulerOrder</inline></reference> 常量）。默认使用 YXZ 约定（<reference internal="True" refuri="class_@globalscope#class-globalscope-constant-euler-order-yxz"><inline classes="std std-ref">@GlobalScope.EULER_ORDER_YXZ</inline></reference>）：基首先围绕 Y 轴旋转（偏摆），然后围绕 X 轴旋转（俯仰），最后围绕 Z 轴旋转（翻滚）。这个顺序在相对的函数 <reference internal="True" refid="class-basis-method-get-euler"><inline classes="std std-ref">get_euler</inline></reference> 中是相反的。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-from-scale"></target>
            <paragraph classes="classref-method" ids="class-basis-method-from-scale" names="class_basis_method_from_scale"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>from_scale</strong>(scale: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation> <reference internal="True" refid="class-basis-method-from-scale"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>根据给定的 <literal>scale</literal> 向量构造仅表示缩放的 <strong>Basis</strong>，不包含旋转和切变。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var my_basis = Basis.from_scale(Vector3(2, 4, 8))

print(my_basis.x) # 输出 (2, 0, 0).
print(my_basis.y) # 输出 (0, 4, 0).
print(my_basis.z) # 输出 (0, 0, 8).</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var myBasis = Basis.FromScale(new Vector3(2.0f, 4.0f, 8.0f));

GD.Print(myBasis.X); // 输出 (2, 0, 0).
GD.Print(myBasis.Y); // 输出 (0, 4, 0).
GD.Print(myBasis.Z); // 输出 (0, 0, 8).</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>在线性代数中，这种基矩阵也被称作<reference name="对角矩阵" refuri="https://zh.wikipedia.org/zh-cn/%E5%B0%8D%E8%A7%92%E7%9F%A9%E9%99%A3">对角矩阵</reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-get-euler"></target>
            <paragraph classes="classref-method" ids="class-basis-method-get-euler" names="class_basis_method_get_euler"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>get_euler</strong>(order: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 2) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-get-euler"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>以 <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> 的形式返回基的旋转，这个向量为 <reference name="欧拉角" refuri="https://zh.wikipedia.org/zh-cn/%E6%AC%A7%E6%8B%89%E8%A7%92">欧拉角</reference>，单位为弧度。</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="class_vector3#class-vector3-property-x"><inline classes="std std-ref">Vector3.x</inline></reference> 包含围绕 <reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference> 轴的角度（俯仰）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_vector3#class-vector3-property-y"><inline classes="std std-ref">Vector3.y</inline></reference> 包含围绕 <reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference> 轴的角度（偏摆）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_vector3#class-vector3-property-z"><inline classes="std std-ref">Vector3.z</inline></reference> 包含围绕 <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference> 轴的角度（翻滚）。</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>连续旋转的顺序可以通过 <literal>order</literal> 修改（见 <reference internal="True" refuri="class_@globalscope#enum-globalscope-eulerorder"><inline classes="std std-ref">EulerOrder</inline></reference> 常量）。默认使用 YXZ 约定（<reference internal="True" refuri="class_@globalscope#class-globalscope-constant-euler-order-yxz"><inline classes="std std-ref">@GlobalScope.EULER_ORDER_YXZ</inline></reference>）：首先计算围绕 Z 轴的旋转（翻滚），然后计算围绕 X 轴的旋转（俯仰），最后计算围绕 Y 轴旋转（偏摆）。这个顺序在相对的函数 <reference internal="True" refid="class-basis-method-from-euler"><inline classes="std std-ref">from_euler</inline></reference> 中是相反的。</paragraph>
            <paragraph><strong>注意：</strong>欧拉角更符合直觉，但是并不适合 3D 数学。因此请考虑改用返回 <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> 的 <reference internal="True" refid="class-basis-method-get-rotation-quaternion"><inline classes="std std-ref">get_rotation_quaternion</inline></reference>。</paragraph>
            <paragraph><strong>注意：</strong>在检查器面板中，基的旋转通常是以欧拉角的形式显示的（单位为度），与 <reference internal="True" refuri="class_node3d#class-node3d-property-rotation"><inline classes="std std-ref">Node3D.rotation</inline></reference> 属性相同。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-get-rotation-quaternion"></target>
            <paragraph classes="classref-method" ids="class-basis-method-get-rotation-quaternion" names="class_basis_method_get_rotation_quaternion"><reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> <strong>get_rotation_quaternion</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-get-rotation-quaternion"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>以 <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> 的形式返回基的旋转。</paragraph>
            <paragraph><strong>注意：</strong>四元数更适合 3D 数学，但是并不那么符合直觉。用户界面相关的场合请考虑使用返回欧拉角的 <reference internal="True" refid="class-basis-method-get-euler"><inline classes="std std-ref">get_euler</inline></reference> 方法。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-get-scale"></target>
            <paragraph classes="classref-method" ids="class-basis-method-get-scale" names="class_basis_method_get_scale"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>get_scale</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-get-scale"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该基的每个轴的长度，作为一个 <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>。如果该基没有被剪切，这就是缩放系数。它不受旋转的影响。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var my_basis = Basis(
    Vector3(2, 0, 0),
    Vector3(0, 4, 0),
    Vector3(0, 0, 8)
)
# 以任何方式旋转基都会保持其缩放。
my_basis = my_basis.rotated(Vector3.UP, TAU / 2)
my_basis = my_basis.rotated(Vector3.RIGHT, TAU / 4)

print(my_basis.get_scale()) # 输出 (2, 4, 8)。</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var myBasis = new Basis(
    Vector3(2.0f, 0.0f, 0.0f),
    Vector3(0.0f, 4.0f, 0.0f),
    Vector3(0.0f, 0.0f, 8.0f)
);
// 以任何方式旋转基都会保持其缩放。
myBasis = myBasis.Rotated(Vector3.Up, Mathf.Tau / 2.0f);
myBasis = myBasis.Rotated(Vector3.Right, Mathf.Tau / 4.0f);

GD.Print(myBasis.Scale); // 输出 (2, 4, 8)。</literal_block>
                </div>
            </container>
            <paragraph><strong>注意：</strong>如果 <reference internal="True" refid="class-basis-method-determinant"><inline classes="std std-ref">determinant</inline></reference> 返回的值为负数，则缩放也为负数。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-inverse"></target>
            <paragraph classes="classref-method" ids="class-basis-method-inverse" names="class_basis_method_inverse"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>inverse</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-inverse"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回 <reference name="该基矩阵的逆矩阵" refuri="https://en.wikipedia.org/wiki/Invertible_matrix">该基矩阵的逆矩阵</reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-is-conformal"></target>
            <paragraph classes="classref-method" ids="class-basis-method-is-conformal" names="class_basis_method_is_conformal"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_conformal</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-is-conformal"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该基是共形的，则返回 <literal>true</literal>。共形的基既是<emphasis>正交的</emphasis>（轴彼此垂直）又是<emphasis>均匀的</emphasis>（轴共享相同长度）。该方法在物理计算过程中特别有用。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-is-equal-approx"></target>
            <paragraph classes="classref-method" ids="class-basis-method-is-equal-approx" names="class_basis_method_is_equal_approx"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_equal_approx</strong>(b: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-is-equal-approx"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该基和 <literal>b</literal> 近似相等，则返回 <literal>true</literal>，判断方法是在每个向量分量上调用 <reference internal="True" refuri="class_@globalscope#class-globalscope-method-is-equal-approx"><inline classes="std std-ref">@GlobalScope.is_equal_approx</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-is-finite"></target>
            <paragraph classes="classref-method" ids="class-basis-method-is-finite" names="class_basis_method_is_finite"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_finite</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-is-finite"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果该基是有限的，则返回 <literal>true</literal>，判断方法是在每个向量分量上调用 <reference internal="True" refuri="class_@globalscope#class-globalscope-method-is-finite"><inline classes="std std-ref">@GlobalScope.is_finite</inline></reference>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-looking-at"></target>
            <paragraph classes="classref-method" ids="class-basis-method-looking-at" names="class_basis_method_looking_at"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>looking_at</strong>(target: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, up: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> = Vector3(0, 1, 0), use_model_front: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation> <reference internal="True" refid="class-basis-method-looking-at"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>创建一个带有旋转的新 <strong>Basis</strong>，使向前轴（-Z）指向 <literal>target</literal> 的位置。</paragraph>
            <paragraph>默认情况下，-Z 轴（相机向前）被视为向前（意味着 +X 位于右侧）。如果 <literal>use_model_front</literal> 为 <literal>true</literal>，则 +Z 轴（资产正面）被视为向前（意味着 +X 位于左侧）并指向 <literal>target</literal> 的位置。</paragraph>
            <paragraph>向上轴（+Y）尽可能靠近 <literal>up</literal> 向量，同时保持垂直于向前轴。返回的基是正交归一化的（参见 <reference internal="True" refid="class-basis-method-orthonormalized"><inline classes="std std-ref">orthonormalized</inline></reference>）。<literal>target</literal> 和 <literal>up</literal> 向量不能是 <reference internal="True" refuri="class_vector3#class-vector3-constant-zero"><inline classes="std std-ref">Vector3.ZERO</inline></reference>，并且不能彼此平行。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-orthonormalized"></target>
            <paragraph classes="classref-method" ids="class-basis-method-orthonormalized" names="class_basis_method_orthonormalized"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>orthonormalized</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-orthonormalized"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该基的正交归一化版本。正交归一化基既是<emphasis>正交的</emphasis>（轴彼此垂直）又是<emphasis>归一化的</emphasis>（轴长度为 <literal>1</literal>），这也意味着它只能代表旋转。</paragraph>
            <paragraph>调用该方法通常很有用，以避免旋转基上的舍入错误：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># 每帧旋转该 Node3D。
func _process(delta):
    basis = basis.rotated(Vector3.UP, TAU * delta)
    basis = basis.rotated(Vector3.RIGHT, TAU * delta)

    basis = basis.orthonormalized()</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// 每帧旋转该 Node3D。
public override void _Process(double delta)
{
    Basis = Basis.Rotated(Vector3.Up, Mathf.Tau * (float)delta)
                 .Rotated(Vector3.Right, Mathf.Tau * (float)delta)
                 .Orthonormalized();
}</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-rotated"></target>
            <paragraph classes="classref-method" ids="class-basis-method-rotated" names="class_basis_method_rotated"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>rotated</strong>(axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, angle: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-rotated"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回围绕给定 <literal>axis</literal> 旋转 <literal>angle</literal>（单位为弧度）的基。<literal>axis</literal> 必须是归一化的向量（请参阅 <reference internal="True" refuri="class_vector3#class-vector3-method-normalized"><inline classes="std std-ref">Vector3.normalized</inline></reference>）。</paragraph>
            <paragraph>正值绕该轴顺时针旋转该基，而负值则逆时针旋转该基。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var my_basis = Basis.IDENTITY
var angle = TAU / 2

my_basis = my_basis.rotated(Vector3.UP, angle)    # 绕向上轴旋转（偏航）。
my_basis = my_basis.rotated(Vector3.RIGHT, angle) # 绕向右轴旋转（俯仰）。
my_basis = my_basis.rotated(Vector3.BACK, angle)  # 绕向后轴旋转（滚动）。</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var myBasis = Basis.Identity;
var angle = Mathf.Tau / 2.0f;

myBasis = myBasis.Rotated(Vector3.Up, angle);    // 绕向上轴旋转（偏航）。
myBasis = myBasis.Rotated(Vector3.Right, angle); // 绕向右轴旋转（俯仰）。
myBasis = myBasis.Rotated(Vector3.Back, angle);  // 绕向后轴旋转（滚动）。</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-scaled"></target>
            <paragraph classes="classref-method" ids="class-basis-method-scaled" names="class_basis_method_scaled"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>scaled</strong>(scale: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-scaled"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该基，其中每个轴的分量都按给定的 <literal>scale</literal> 的分量缩放。</paragraph>
            <paragraph>该基矩阵的行乘以 <literal>scale</literal> 的分量。该操作是全局缩放（相对于父级）。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var my_basis = Basis(
    Vector3(1, 1, 1),
    Vector3(2, 2, 2),
    Vector3(3, 3, 3)
)
my_basis = my_basis.scaled(Vector3(0, 2, -2))

print(my_basis.x) # 输出 (0, 2, -2).
print(my_basis.y) # 输出 (0, 4, -4).
print(my_basis.z) # 输出 (0, 6, -6).</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var myBasis = new Basis(
    new Vector3(1.0f, 1.0f, 1.0f),
    new Vector3(2.0f, 2.0f, 2.0f),
    new Vector3(3.0f, 3.0f, 3.0f)
);
myBasis = myBasis.Scaled(new Vector3(0.0f, 2.0f, -2.0f));

GD.Print(myBasis.X); // 输出 (0, 2, -2).
GD.Print(myBasis.Y); // 输出 (0, 4, -4).
GD.Print(myBasis.Z); // 输出 (0, 6, -6).</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-slerp"></target>
            <paragraph classes="classref-method" ids="class-basis-method-slerp" names="class_basis_method_slerp"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>slerp</strong>(to: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>, weight: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-slerp"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>使用 <literal>to</literal> 基在给定 <literal>weight</literal> 的情况下执行球面线性插值。该基和 <literal>to</literal> 两者都应该代表一个旋转。</paragraph>
            <paragraph><strong>示例：</strong>使用 <reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference> 随时间平滑地将 <reference internal="True" refuri="class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> 旋转到目标基。</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var start_basis = Basis.IDENTITY
var target_basis = Basis.IDENTITY.rotated(Vector3.UP, TAU / 2)

func _ready():
    create_tween().tween_method(interpolate, 0.0, 1.0, 5.0).set_trans(Tween.TRANS_EXPO)

func interpolate(weight):
    basis = start_basis.slerp(target_basis, weight)</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-tdotx"></target>
            <paragraph classes="classref-method" ids="class-basis-method-tdotx" names="class_basis_method_tdotx"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>tdotx</strong>(with: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-tdotx"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回 <literal>with</literal> 和 <reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference> 轴之间的转置点积（请参阅 <reference internal="True" refid="class-basis-method-transposed"><inline classes="std std-ref">transposed</inline></reference>）。</paragraph>
            <paragraph>这相当于 <literal>basis.x.dot(vector)</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-tdoty"></target>
            <paragraph classes="classref-method" ids="class-basis-method-tdoty" names="class_basis_method_tdoty"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>tdoty</strong>(with: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-tdoty"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回 <literal>with</literal> 和 <reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference> 轴之间的转置点积（请参阅 <reference internal="True" refid="class-basis-method-transposed"><inline classes="std std-ref">transposed</inline></reference>）。</paragraph>
            <paragraph>这相当于 <literal>basis.y.dot(vector)</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-tdotz"></target>
            <paragraph classes="classref-method" ids="class-basis-method-tdotz" names="class_basis_method_tdotz"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>tdotz</strong>(with: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-tdotz"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回 <literal>with</literal> 和 <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference> 轴之间的转置点积（请参阅 <reference internal="True" refid="class-basis-method-transposed"><inline classes="std std-ref">transposed</inline></reference>）。</paragraph>
            <paragraph>这相当于 <literal>basis.z.dot(vector)</literal>。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-transposed"></target>
            <paragraph classes="classref-method" ids="class-basis-method-transposed" names="class_basis_method_transposed"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>transposed</strong>() <abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-basis-method-transposed"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回该基的转置版本。这会将基矩阵的列转换为行，并将其行转换为列。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var my_basis = Basis(
    Vector3(1, 2, 3),
    Vector3(4, 5, 6),
    Vector3(7, 8, 9)
)
my_basis = my_basis.transposed()

print(my_basis.x) # 输出 (1, 4, 7).
print(my_basis.y) # 输出 (2, 5, 8).
print(my_basis.z) # 输出 (3, 6, 9).</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var myBasis = new Basis(
    new Vector3(1.0f, 2.0f, 3.0f),
    new Vector3(4.0f, 5.0f, 6.0f),
    new Vector3(7.0f, 8.0f, 9.0f)
);
myBasis = myBasis.Transposed();

GD.Print(myBasis.X); // 输出 (1, 4, 7).
GD.Print(myBasis.Y); // 输出 (2, 5, 8).
GD.Print(myBasis.Z); // 输出 (3, 6, 9).</literal_block>
                </div>
            </container>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id11" names="操作符说明">
            <title>操作符说明</title>
            <target refid="class-basis-operator-neq-basis"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-neq-basis" names="class_basis_operator_neq_basis"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong>(right: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>) <reference internal="True" refid="class-basis-operator-neq-basis"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果两个 <strong>Basis</strong> 矩阵的分量不相等，则返回 <literal>true</literal>。</paragraph>
            <paragraph><strong>注意：</strong>由于浮点精度误差，请考虑改用 <reference internal="True" refid="class-basis-method-is-equal-approx"><inline classes="std std-ref">is_equal_approx</inline></reference>，这样更可靠。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-mul-basis"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-mul-basis" names="class_basis_operator_mul_basis"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>operator *</strong>(right: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>) <reference internal="True" refid="class-basis-operator-mul-basis"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>由该基转换（乘以） <literal>right</literal> 基。</paragraph>
            <paragraph>这是父级和子级 <reference internal="True" refuri="class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> 之间执行的操作。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-mul-vector3"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-mul-vector3" names="class_basis_operator_mul_vector3"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>operator *</strong>(right: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <reference internal="True" refid="class-basis-operator-mul-vector3"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>Transforms (multiplies) the <literal>right</literal> vector by this basis, returning a <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Basis that swaps the X/Z axes and doubles the scale.
var my_basis = Basis(Vector3(0, 2, 0), Vector3(2, 0, 0), Vector3(0, 0, 2))
print(my_basis * Vector3(1, 2, 3)) # Prints (4, 2, 6)</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Basis that swaps the X/Z axes and doubles the scale.
var myBasis = new Basis(new Vector3(0, 2, 0), new Vector3(2, 0, 0), new Vector3(0, 0, 2));
GD.Print(myBasis * new Vector3(1, 2, 3)); // Prints (4, 2, 6)</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-mul-float"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-mul-float" names="class_basis_operator_mul_float"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>operator *</strong>(right: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <reference internal="True" refid="class-basis-operator-mul-float"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将 <strong>Basis</strong> 的所有分量乘以给定的 <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>。这会均匀地影响该基矩阵的缩放，并通过 <literal>right</literal> 值调整所有 3 个轴的大小。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-mul-int"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-mul-int" names="class_basis_operator_mul_int"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>operator *</strong>(right: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-basis-operator-mul-int"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将该 <strong>Basis</strong> 的所有分量乘以给定的 <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>。这会均匀地影响该基的缩放，并通过 <literal>right</literal> 值调整所有 3 个轴的大小。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-div-float"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-div-float" names="class_basis_operator_div_float"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>operator /</strong>(right: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <reference internal="True" refid="class-basis-operator-div-float"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将 <strong>Basis</strong> 的所有分量除以给定的 <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>。这会均匀地影响该基的缩放，并通过 <literal>right</literal> 值调整所有 3 个轴的大小。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-div-int"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-div-int" names="class_basis_operator_div_int"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>operator /</strong>(right: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-basis-operator-div-int"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将 <strong>Basis</strong> 的所有分量除以给定的 <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>。这会均匀地影响该基的缩放，并通过 <literal>right</literal> 值调整所有 3 个轴的大小。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-eq-basis"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-eq-basis" names="class_basis_operator_eq_basis"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong>(right: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>) <reference internal="True" refid="class-basis-operator-eq-basis"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>如果两个 <strong>Basis</strong> 矩阵的分量完全相等，则返回 <literal>true</literal>。</paragraph>
            <paragraph><strong>注意：</strong>由于浮点精度误差，请考虑改用 <reference internal="True" refid="class-basis-method-is-equal-approx"><inline classes="std std-ref">is_equal_approx</inline></reference>，这样更可靠。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-idx-int"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-idx-int" names="class_basis_operator_idx_int"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>operator []</strong>(index: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-basis-operator-idx-int"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>通过索引访问该基的每个轴（列）。索引 <literal>0</literal> 与 <reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference> 相同，索引 <literal>1</literal> 与 <reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference> 相同，索引 <literal>2</literal> 与 <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference> 相同。</paragraph>
            <paragraph><strong>注意：</strong>在 C++ 中，该运算符访问基础矩阵的行，而<emphasis>不</emphasis>是列。对于与脚本语言相同的行为，请使用 <literal>set_column</literal> 和 <literal>get_column</literal> 方法。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法没有副作用，不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了能接受在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效操作符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列标志构成的位掩码整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="void"><abbreviation explanation="无返回值。">void</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
