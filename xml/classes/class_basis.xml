<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_basis.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/master/doc/classes/Basis.xml.</comment>
    <target refid="class-basis"></target>
    <section ids="basis class-basis" names="basis class_basis">
        <title>Basis</title>
        <paragraph>A 3Ã—3 matrix for representing 3D rotation and scale.</paragraph>
        <section classes="classref-introduction-group" ids="description" names="description">
            <title>Description</title>
            <paragraph>The <strong>Basis</strong> built-in <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> type is a 3Ã—3 <reference name="matrix" refuri="https://en.wikipedia.org/wiki/Matrix_(mathematics)">matrix</reference> used to represent 3D rotation, scale, and shear. It is frequently used within a <reference internal="True" refuri="class_transform3d#class-transform3d"><inline classes="std std-ref">Transform3D</inline></reference>.</paragraph>
            <paragraph>A <strong>Basis</strong> is composed by 3 axis vectors, each representing a column of the matrix: <reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference>, <reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference>, and <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference>. The length of each axis (<reference internal="True" refuri="class_vector3#class-vector3-method-length"><inline classes="std std-ref">Vector3.length()</inline></reference>) influences the basis's scale, while the direction of all axes influence the rotation. Usually, these axes are perpendicular to one another. However, when you rotate any axis individually, the basis becomes sheared. Applying a sheared basis to a 3D model will make the model appear distorted.</paragraph>
            <paragraph>A <strong>Basis</strong> is:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>Orthogonal</strong> if its axes are perpendicular to each other.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Normalized</strong> if the length of every axis is <literal>1.0</literal>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Uniform</strong> if all axes share the same length (see <reference internal="True" refid="class-basis-method-get-scale"><inline classes="std std-ref">get_scale()</inline></reference>).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Orthonormal</strong> if it is both orthogonal and normalized, which allows it to only represent rotations (see <reference internal="True" refid="class-basis-method-orthonormalized"><inline classes="std std-ref">orthonormalized()</inline></reference>).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Conformal</strong> if it is both orthogonal and uniform, which ensures it is not distorted.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>For a general introduction, see the <reference internal="True" refuri="../tutorials/math/matrices_and_transforms"><inline classes="doc">Matrices and transforms</inline></reference> tutorial.</paragraph>
            <paragraph><strong>Note:</strong> Godot uses a <reference name="right-handed coordinate system" refuri="https://en.wikipedia.org/wiki/Right-hand_rule">right-handed coordinate system</reference>, which is a common standard. For directions, the convention for built-in types like <reference internal="True" refuri="class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference> is for -Z to point forward (+X is right, +Y is up, and +Z is back). Other objects may use different direction conventions. For more information, see the <reference name="3D asset direction conventions" refuri="../tutorials/assets_pipeline/importing_3d_scenes/model_export_considerations.html#d-asset-direction-conventions">3D asset direction conventions</reference> tutorial.</paragraph>
            <paragraph><strong>Note:</strong> The basis matrices are exposed as <reference name="column-major" refuri="https://www.mindcontrol.org/~hplus/graphics/matrix-layout.html">column-major</reference> order, which is the same as OpenGL. However, they are stored internally in row-major order, which is the same as DirectX.</paragraph>
            <note>
                <paragraph>There are notable differences when using this API with C#. See <reference internal="True" refuri="../tutorials/scripting/c_sharp/c_sharp_differences#doc-c-sharp-differences"><inline classes="std std-ref">C# API differences to GDScript</inline></reference> for more information.</paragraph>
            </note>
        </section>
        <section classes="classref-introduction-group" ids="tutorials" names="tutorials">
            <title>Tutorials</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/math/index"><inline classes="doc">Math documentation index</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/math/matrices_and_transforms"><inline classes="doc">Matrices and transforms</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="../tutorials/3d/using_transforms"><inline classes="doc">Using 3D transforms</inline></reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="Matrix Transform Demo" refuri="https://godotengine.org/asset-library/asset/2787">Matrix Transform Demo</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="3D Platformer Demo" refuri="https://godotengine.org/asset-library/asset/2748">3D Platformer Demo</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="3D Voxel Demo" refuri="https://godotengine.org/asset-library/asset/2755">3D Voxel Demo</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="2.5D Game Demo" refuri="https://godotengine.org/asset-library/asset/2783">2.5D Game Demo</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section classes="classref-reftable-group" ids="properties" names="properties">
            <title>Properties</title>
            <table classes="colwidths-auto">
                <tgroup cols="3">
                    <colspec colwidth="31"></colspec>
                    <colspec colwidth="34"></colspec>
                    <colspec colwidth="22"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector3(1, 0, 0)</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector3(0, 1, 0)</literal></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>Vector3(0, 0, 1)</literal></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="constructors" names="constructors">
            <title>Constructors</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="27"></colspec>
                    <colspec colwidth="171"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference>(from: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference>(axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, angle: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference>(from: <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference>(x_axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, y_axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, z_axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="methods" names="methods">
            <title>Methods</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="37"></colspec>
                    <colspec colwidth="211"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-determinant"><inline classes="std std-ref">determinant</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-from-euler"><inline classes="std std-ref">from_euler</inline></reference>(euler: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, order: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 2) <abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-from-scale"><inline classes="std std-ref">from_scale</inline></reference>(scale: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-get-euler"><inline classes="std std-ref">get_euler</inline></reference>(order: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 2) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-get-rotation-quaternion"><inline classes="std std-ref">get_rotation_quaternion</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-get-scale"><inline classes="std std-ref">get_scale</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-inverse"><inline classes="std std-ref">inverse</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-is-conformal"><inline classes="std std-ref">is_conformal</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-is-equal-approx"><inline classes="std std-ref">is_equal_approx</inline></reference>(b: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-is-finite"><inline classes="std std-ref">is_finite</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-looking-at"><inline classes="std std-ref">looking_at</inline></reference>(target: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, up: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> = Vector3(0, 1, 0), use_model_front: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-orthonormalized"><inline classes="std std-ref">orthonormalized</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-rotated"><inline classes="std std-ref">rotated</inline></reference>(axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, angle: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-scaled"><inline classes="std std-ref">scaled</inline></reference>(scale: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-scaled-local"><inline classes="std std-ref">scaled_local</inline></reference>(scale: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-slerp"><inline classes="std std-ref">slerp</inline></reference>(to: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>, weight: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-tdotx"><inline classes="std std-ref">tdotx</inline></reference>(with: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-tdoty"><inline classes="std std-ref">tdoty</inline></reference>(with: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-tdotz"><inline classes="std std-ref">tdotz</inline></reference>(with: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-method-transposed"><inline classes="std std-ref">transposed</inline></reference>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="operators" names="operators">
            <title>Operators</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="31"></colspec>
                    <colspec colwidth="98"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-neq-basis"><inline classes="std std-ref">operator !=</inline></reference>(right: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-mul-basis"><inline classes="std std-ref">operator *</inline></reference>(right: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-mul-vector3"><inline classes="std std-ref">operator *</inline></reference>(right: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-mul-float"><inline classes="std std-ref">operator *</inline></reference>(right: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-mul-int"><inline classes="std std-ref">operator *</inline></reference>(right: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-div-float"><inline classes="std std-ref">operator /</inline></reference>(right: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-div-int"><inline classes="std std-ref">operator /</inline></reference>(right: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-eq-basis"><inline classes="std std-ref">operator ==</inline></reference>(right: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-basis-operator-idx-int"><inline classes="std std-ref">operator []</inline></reference>(index: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="constants" names="constants">
            <title>Constants</title>
            <target refid="class-basis-constant-identity"></target>
            <paragraph classes="classref-constant" ids="class-basis-constant-identity" names="class_basis_constant_identity"><strong>IDENTITY</strong> = <literal>Basis(1, 0, 0, 0, 1, 0, 0, 0, 1)</literal> <reference internal="True" refid="class-basis-constant-identity"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>The identity <strong>Basis</strong>. This is an orthonormal basis with no rotation, no shear, and a scale of <reference internal="True" refuri="class_vector3#class-vector3-constant-one"><inline classes="std std-ref">Vector3.ONE</inline></reference>. This also means that:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The <reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference> points right (<reference internal="True" refuri="class_vector3#class-vector3-constant-right"><inline classes="std std-ref">Vector3.RIGHT</inline></reference>);</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference> points up (<reference internal="True" refuri="class_vector3#class-vector3-constant-up"><inline classes="std std-ref">Vector3.UP</inline></reference>);</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference> points back (<reference internal="True" refuri="class_vector3#class-vector3-constant-back"><inline classes="std std-ref">Vector3.BACK</inline></reference>).</paragraph>
                </list_item>
            </bullet_list>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var basis = Basis.IDENTITY
print("| X | Y | Z")
print("| %.f | %.f | %.f" % [basis.x.x, basis.y.x, basis.z.x])
print("| %.f | %.f | %.f" % [basis.x.y, basis.y.y, basis.z.y])
print("| %.f | %.f | %.f" % [basis.x.z, basis.y.z, basis.z.z])
# Prints:
# | X | Y | Z
# | 1 | 0 | 0
# | 0 | 1 | 0
# | 0 | 0 | 1</literal_block>
            <paragraph>If a <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> or another <strong>Basis</strong> is transformed (multiplied) by this constant, no transformation occurs.</paragraph>
            <paragraph><strong>Note:</strong> In GDScript, this constant is equivalent to creating a <reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">Basis</inline></reference> without any arguments. It can be used to make your code clearer, and for consistency with C#.</paragraph>
            <target refid="class-basis-constant-flip-x"></target>
            <paragraph classes="classref-constant" ids="class-basis-constant-flip-x" names="class_basis_constant_flip_x"><strong>FLIP_X</strong> = <literal>Basis(-1, 0, 0, 0, 1, 0, 0, 0, 1)</literal> <reference internal="True" refid="class-basis-constant-flip-x"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>When any basis is multiplied by <reference internal="True" refid="class-basis-constant-flip-x"><inline classes="std std-ref">FLIP_X</inline></reference>, it negates all components of the <reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference> axis (the X column).</paragraph>
            <paragraph>When <reference internal="True" refid="class-basis-constant-flip-x"><inline classes="std std-ref">FLIP_X</inline></reference> is multiplied by any basis, it negates the <reference internal="True" refuri="class_vector3#class-vector3-property-x"><inline classes="std std-ref">Vector3.x</inline></reference> component of all axes (the X row).</paragraph>
            <target refid="class-basis-constant-flip-y"></target>
            <paragraph classes="classref-constant" ids="class-basis-constant-flip-y" names="class_basis_constant_flip_y"><strong>FLIP_Y</strong> = <literal>Basis(1, 0, 0, 0, -1, 0, 0, 0, 1)</literal> <reference internal="True" refid="class-basis-constant-flip-y"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>When any basis is multiplied by <reference internal="True" refid="class-basis-constant-flip-y"><inline classes="std std-ref">FLIP_Y</inline></reference>, it negates all components of the <reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference> axis (the Y column).</paragraph>
            <paragraph>When <reference internal="True" refid="class-basis-constant-flip-y"><inline classes="std std-ref">FLIP_Y</inline></reference> is multiplied by any basis, it negates the <reference internal="True" refuri="class_vector3#class-vector3-property-y"><inline classes="std std-ref">Vector3.y</inline></reference> component of all axes (the Y row).</paragraph>
            <target refid="class-basis-constant-flip-z"></target>
            <paragraph classes="classref-constant" ids="class-basis-constant-flip-z" names="class_basis_constant_flip_z"><strong>FLIP_Z</strong> = <literal>Basis(1, 0, 0, 0, 1, 0, 0, 0, -1)</literal> <reference internal="True" refid="class-basis-constant-flip-z"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>When any basis is multiplied by <reference internal="True" refid="class-basis-constant-flip-z"><inline classes="std std-ref">FLIP_Z</inline></reference>, it negates all components of the <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference> axis (the Z column).</paragraph>
            <paragraph>When <reference internal="True" refid="class-basis-constant-flip-z"><inline classes="std std-ref">FLIP_Z</inline></reference> is multiplied by any basis, it negates the <reference internal="True" refuri="class_vector3#class-vector3-property-z"><inline classes="std std-ref">Vector3.z</inline></reference> component of all axes (the Z row).</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="property-descriptions" names="property\ descriptions">
            <title>Property Descriptions</title>
            <target refid="class-basis-property-x"></target>
            <paragraph classes="classref-property" ids="class-basis-property-x" names="class_basis_property_x"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>x</strong> = <literal>Vector3(1, 0, 0)</literal> <reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>The basis's X axis, and the column <literal>0</literal> of the matrix.</paragraph>
            <paragraph>On the identity basis, this vector points right (<reference internal="True" refuri="class_vector3#class-vector3-constant-right"><inline classes="std std-ref">Vector3.RIGHT</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-property-y"></target>
            <paragraph classes="classref-property" ids="class-basis-property-y" names="class_basis_property_y"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>y</strong> = <literal>Vector3(0, 1, 0)</literal> <reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>The basis's Y axis, and the column <literal>1</literal> of the matrix.</paragraph>
            <paragraph>On the identity basis, this vector points up (<reference internal="True" refuri="class_vector3#class-vector3-constant-up"><inline classes="std std-ref">Vector3.UP</inline></reference>).</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-property-z"></target>
            <paragraph classes="classref-property" ids="class-basis-property-z" names="class_basis_property_z"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>z</strong> = <literal>Vector3(0, 0, 1)</literal> <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>The basis's Z axis, and the column <literal>2</literal> of the matrix.</paragraph>
            <paragraph>On the identity basis, this vector points back (<reference internal="True" refuri="class_vector3#class-vector3-constant-back"><inline classes="std std-ref">Vector3.BACK</inline></reference>).</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="constructor-descriptions" names="constructor\ descriptions">
            <title>Constructor Descriptions</title>
            <target refid="class-basis-constructor-basis"></target>
            <paragraph classes="classref-constructor" ids="class-basis-constructor-basis" names="class_basis_constructor_basis"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong>() <reference internal="True" refid="class-basis-constructor-basis"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Constructs a <strong>Basis</strong> identical to <reference internal="True" refid="class-basis-constant-identity"><inline classes="std std-ref">IDENTITY</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> In C#, this constructs a <strong>Basis</strong> with all of its components set to <reference internal="True" refuri="class_vector3#class-vector3-constant-zero"><inline classes="std std-ref">Vector3.ZERO</inline></reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong>(from: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>)</paragraph>
            <paragraph>Constructs a <strong>Basis</strong> as a copy of the given <strong>Basis</strong>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong>(axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, angle: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>)</paragraph>
            <paragraph>Constructs a <strong>Basis</strong> that only represents rotation, rotated around the <literal>axis</literal> by the given <literal>angle</literal>, in radians. The axis must be a normalized vector.</paragraph>
            <paragraph><strong>Note:</strong> This is the same as using <reference internal="True" refid="class-basis-method-rotated"><inline classes="std std-ref">rotated()</inline></reference> on the <reference internal="True" refid="class-basis-constant-identity"><inline classes="std std-ref">IDENTITY</inline></reference> basis. With more than one angle consider using <reference internal="True" refid="class-basis-method-from-euler"><inline classes="std std-ref">from_euler()</inline></reference>, instead.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong>(from: <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference>)</paragraph>
            <paragraph>Constructs a <strong>Basis</strong> that only represents rotation from the given <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> Quaternions <emphasis>only</emphasis> store rotation, not scale. Because of this, conversions from <strong>Basis</strong> to <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> cannot always be reversed.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <paragraph classes="classref-constructor"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>Basis</strong>(x_axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, y_axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, z_axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>)</paragraph>
            <paragraph>Constructs a <strong>Basis</strong> from 3 axis vectors. These are the columns of the basis matrix.</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="method-descriptions" names="method\ descriptions">
            <title>Method Descriptions</title>
            <target refid="class-basis-method-determinant"></target>
            <paragraph classes="classref-method" ids="class-basis-method-determinant" names="class_basis_method_determinant"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>determinant</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-determinant"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the <reference name="determinant" refuri="https://en.wikipedia.org/wiki/Determinant">determinant</reference> of this basis's matrix. For advanced math, this number can be used to determine a few attributes:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>If the determinant is exactly <literal>0.0</literal>, the basis is not invertible (see <reference internal="True" refid="class-basis-method-inverse"><inline classes="std std-ref">inverse()</inline></reference>).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If the determinant is a negative number, the basis represents a negative scale.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>Note:</strong> If the basis's scale is the same for every axis, its determinant is always that scale by the power of 3.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-from-euler"></target>
            <paragraph classes="classref-method" ids="class-basis-method-from-euler" names="class_basis_method_from_euler"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>from_euler</strong>(euler: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, order: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 2) <abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation> <reference internal="True" refid="class-basis-method-from-euler"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Constructs a new <strong>Basis</strong> that only represents rotation from the given <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> of <reference name="Euler angles" refuri="https://en.wikipedia.org/wiki/Euler_angles">Euler angles</reference>, in radians.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The <reference internal="True" refuri="class_vector3#class-vector3-property-x"><inline classes="std std-ref">Vector3.x</inline></reference> should contain the angle around the <reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference> axis (pitch);</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <reference internal="True" refuri="class_vector3#class-vector3-property-y"><inline classes="std std-ref">Vector3.y</inline></reference> should contain the angle around the <reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference> axis (yaw);</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <reference internal="True" refuri="class_vector3#class-vector3-property-z"><inline classes="std std-ref">Vector3.z</inline></reference> should contain the angle around the <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference> axis (roll).</paragraph>
                </list_item>
            </bullet_list>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Creates a Basis whose z axis points down.
var my_basis = Basis.from_euler(Vector3(TAU / 4, 0, 0))

print(my_basis.z) # Prints (0.0, -1.0, 0.0)</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Creates a Basis whose z axis points down.
var myBasis = Basis.FromEuler(new Vector3(Mathf.Tau / 4.0f, 0.0f, 0.0f));

GD.Print(myBasis.Z); // Prints (0, -1, 0)</literal_block>
                </div>
            </container>
            <paragraph>The order of each consecutive rotation can be changed with <literal>order</literal> (see <reference internal="True" refuri="class_@globalscope#enum-globalscope-eulerorder"><inline classes="std std-ref">EulerOrder</inline></reference> constants). By default, the YXZ convention is used (<reference internal="True" refuri="class_@globalscope#class-globalscope-constant-euler-order-yxz"><inline classes="std std-ref">@GlobalScope.EULER_ORDER_YXZ</inline></reference>): the basis rotates first around the Y axis (yaw), then X (pitch), and lastly Z (roll). When using the opposite method <reference internal="True" refid="class-basis-method-get-euler"><inline classes="std std-ref">get_euler()</inline></reference>, this order is reversed.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-from-scale"></target>
            <paragraph classes="classref-method" ids="class-basis-method-from-scale" names="class_basis_method_from_scale"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>from_scale</strong>(scale: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation> <reference internal="True" refid="class-basis-method-from-scale"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Constructs a new <strong>Basis</strong> that only represents scale, with no rotation or shear, from the given <literal>scale</literal> vector.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var my_basis = Basis.from_scale(Vector3(2, 4, 8))

print(my_basis.x) # Prints (2.0, 0.0, 0.0)
print(my_basis.y) # Prints (0.0, 4.0, 0.0)
print(my_basis.z) # Prints (0.0, 0.0, 8.0)</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var myBasis = Basis.FromScale(new Vector3(2.0f, 4.0f, 8.0f));

GD.Print(myBasis.X); // Prints (2, 0, 0)
GD.Print(myBasis.Y); // Prints (0, 4, 0)
GD.Print(myBasis.Z); // Prints (0, 0, 8)</literal_block>
                </div>
            </container>
            <paragraph><strong>Note:</strong> In linear algebra, the matrix of this basis is also known as a <reference name="diagonal matrix" refuri="https://en.wikipedia.org/wiki/Diagonal_matrix">diagonal matrix</reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-get-euler"></target>
            <paragraph classes="classref-method" ids="class-basis-method-get-euler" names="class_basis_method_get_euler"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>get_euler</strong>(order: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> = 2) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-get-euler"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns this basis's rotation as a <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> of <reference name="Euler angles" refuri="https://en.wikipedia.org/wiki/Euler_angles">Euler angles</reference>, in radians. For the returned value:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>The <reference internal="True" refuri="class_vector3#class-vector3-property-x"><inline classes="std std-ref">Vector3.x</inline></reference> contains the angle around the <reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference> axis (pitch);</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <reference internal="True" refuri="class_vector3#class-vector3-property-y"><inline classes="std std-ref">Vector3.y</inline></reference> contains the angle around the <reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference> axis (yaw);</paragraph>
                </list_item>
                <list_item>
                    <paragraph>The <reference internal="True" refuri="class_vector3#class-vector3-property-z"><inline classes="std std-ref">Vector3.z</inline></reference> contains the angle around the <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference> axis (roll).</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The order of each consecutive rotation can be changed with <literal>order</literal> (see <reference internal="True" refuri="class_@globalscope#enum-globalscope-eulerorder"><inline classes="std std-ref">EulerOrder</inline></reference> constants). By default, the YXZ convention is used (<reference internal="True" refuri="class_@globalscope#class-globalscope-constant-euler-order-yxz"><inline classes="std std-ref">@GlobalScope.EULER_ORDER_YXZ</inline></reference>): Z (roll) is calculated first, then X (pitch), and lastly Y (yaw). When using the opposite method <reference internal="True" refid="class-basis-method-from-euler"><inline classes="std std-ref">from_euler()</inline></reference>, this order is reversed.</paragraph>
            <paragraph><strong>Note:</strong> For this method to return correctly, the basis needs to be <emphasis>orthonormal</emphasis> (see <reference internal="True" refid="class-basis-method-orthonormalized"><inline classes="std std-ref">orthonormalized()</inline></reference>).</paragraph>
            <paragraph><strong>Note:</strong> Euler angles are much more intuitive but are not suitable for 3D math. Because of this, consider using the <reference internal="True" refid="class-basis-method-get-rotation-quaternion"><inline classes="std std-ref">get_rotation_quaternion()</inline></reference> method instead, which returns a <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> In the Inspector dock, a basis's rotation is often displayed in Euler angles (in degrees), as is the case with the <reference internal="True" refuri="class_node3d#class-node3d-property-rotation"><inline classes="std std-ref">Node3D.rotation</inline></reference> property.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-get-rotation-quaternion"></target>
            <paragraph classes="classref-method" ids="class-basis-method-get-rotation-quaternion" names="class_basis_method_get_rotation_quaternion"><reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference> <strong>get_rotation_quaternion</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-get-rotation-quaternion"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns this basis's rotation as a <reference internal="True" refuri="class_quaternion#class-quaternion"><inline classes="std std-ref">Quaternion</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> Quaternions are much more suitable for 3D math but are less intuitive. For user interfaces, consider using the <reference internal="True" refid="class-basis-method-get-euler"><inline classes="std std-ref">get_euler()</inline></reference> method, which returns Euler angles.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-get-scale"></target>
            <paragraph classes="classref-method" ids="class-basis-method-get-scale" names="class_basis_method_get_scale"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>get_scale</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-get-scale"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the length of each axis of this basis, as a <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>. If the basis is not sheared, this value is the scaling factor. It is not affected by rotation.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var my_basis = Basis(
    Vector3(2, 0, 0),
    Vector3(0, 4, 0),
    Vector3(0, 0, 8)
)
# Rotating the Basis in any way preserves its scale.
my_basis = my_basis.rotated(Vector3.UP, TAU / 2)
my_basis = my_basis.rotated(Vector3.RIGHT, TAU / 4)

print(my_basis.get_scale()) # Prints (2.0, 4.0, 8.0)</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var myBasis = new Basis(
    Vector3(2.0f, 0.0f, 0.0f),
    Vector3(0.0f, 4.0f, 0.0f),
    Vector3(0.0f, 0.0f, 8.0f)
);
// Rotating the Basis in any way preserves its scale.
myBasis = myBasis.Rotated(Vector3.Up, Mathf.Tau / 2.0f);
myBasis = myBasis.Rotated(Vector3.Right, Mathf.Tau / 4.0f);

GD.Print(myBasis.Scale); // Prints (2, 4, 8)</literal_block>
                </div>
            </container>
            <paragraph><strong>Note:</strong> If the value returned by <reference internal="True" refid="class-basis-method-determinant"><inline classes="std std-ref">determinant()</inline></reference> is negative, the scale is also negative.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-inverse"></target>
            <paragraph classes="classref-method" ids="class-basis-method-inverse" names="class_basis_method_inverse"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>inverse</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-inverse"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the <reference name="inverse of this basis's matrix" refuri="https://en.wikipedia.org/wiki/Invertible_matrix">inverse of this basis's matrix</reference>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-is-conformal"></target>
            <paragraph classes="classref-method" ids="class-basis-method-is-conformal" names="class_basis_method_is_conformal"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_conformal</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-is-conformal"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if this basis is conformal. A conformal basis is both <emphasis>orthogonal</emphasis> (the axes are perpendicular to each other) and <emphasis>uniform</emphasis> (the axes share the same length). This method can be especially useful during physics calculations.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-is-equal-approx"></target>
            <paragraph classes="classref-method" ids="class-basis-method-is-equal-approx" names="class_basis_method_is_equal_approx"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_equal_approx</strong>(b: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-is-equal-approx"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if this basis and <literal>b</literal> are approximately equal, by calling <reference internal="True" refuri="class_@globalscope#class-globalscope-method-is-equal-approx"><inline classes="std std-ref">@GlobalScope.is_equal_approx()</inline></reference> on all vector components.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-is-finite"></target>
            <paragraph classes="classref-method" ids="class-basis-method-is-finite" names="class_basis_method_is_finite"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>is_finite</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-is-finite"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if this basis is finite, by calling <reference internal="True" refuri="class_@globalscope#class-globalscope-method-is-finite"><inline classes="std std-ref">@GlobalScope.is_finite()</inline></reference> on all vector components.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-looking-at"></target>
            <paragraph classes="classref-method" ids="class-basis-method-looking-at" names="class_basis_method_looking_at"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>looking_at</strong>(target: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, up: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> = Vector3(0, 1, 0), use_model_front: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation> <reference internal="True" refid="class-basis-method-looking-at"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Creates a new <strong>Basis</strong> with a rotation such that the forward axis (-Z) points towards the <literal>target</literal> position.</paragraph>
            <paragraph>By default, the -Z axis (camera forward) is treated as forward (implies +X is right). If <literal>use_model_front</literal> is <literal>true</literal>, the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the <literal>target</literal> position.</paragraph>
            <paragraph>The up axis (+Y) points as close to the <literal>up</literal> vector as possible while staying perpendicular to the forward axis. The returned basis is orthonormalized (see <reference internal="True" refid="class-basis-method-orthonormalized"><inline classes="std std-ref">orthonormalized()</inline></reference>).</paragraph>
            <paragraph>The <literal>target</literal> and the <literal>up</literal> cannot be <reference internal="True" refuri="class_vector3#class-vector3-constant-zero"><inline classes="std std-ref">Vector3.ZERO</inline></reference>, and shouldn't be colinear to avoid unintended rotation around local Z axis.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-orthonormalized"></target>
            <paragraph classes="classref-method" ids="class-basis-method-orthonormalized" names="class_basis_method_orthonormalized"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>orthonormalized</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-orthonormalized"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the orthonormalized version of this basis. An orthonormal basis is both <emphasis>orthogonal</emphasis> (the axes are perpendicular to each other) and <emphasis>normalized</emphasis> (the axes have a length of <literal>1.0</literal>), which also means it can only represent a rotation.</paragraph>
            <paragraph>It is often useful to call this method to avoid rounding errors on a rotating basis:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Rotate this Node3D every frame.
func _process(delta):
    basis = basis.rotated(Vector3.UP, TAU * delta)
    basis = basis.rotated(Vector3.RIGHT, TAU * delta)
    basis = basis.orthonormalized()</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Rotate this Node3D every frame.
public override void _Process(double delta)
{
    Basis = Basis.Rotated(Vector3.Up, Mathf.Tau * (float)delta)
            .Rotated(Vector3.Right, Mathf.Tau * (float)delta)
            .Orthonormalized();
}</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-rotated"></target>
            <paragraph classes="classref-method" ids="class-basis-method-rotated" names="class_basis_method_rotated"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>rotated</strong>(axis: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>, angle: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-rotated"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns a copy of this basis rotated around the given <literal>axis</literal> by the given <literal>angle</literal> (in radians).</paragraph>
            <paragraph>The <literal>axis</literal> must be a normalized vector (see <reference internal="True" refuri="class_vector3#class-vector3-method-normalized"><inline classes="std std-ref">Vector3.normalized()</inline></reference>). If <literal>angle</literal> is positive, the basis is rotated counter-clockwise around the axis.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var my_basis = Basis.IDENTITY
var angle = TAU / 2

my_basis = my_basis.rotated(Vector3.UP, angle)    # Rotate around the up axis (yaw).
my_basis = my_basis.rotated(Vector3.RIGHT, angle) # Rotate around the right axis (pitch).
my_basis = my_basis.rotated(Vector3.BACK, angle)  # Rotate around the back axis (roll).</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var myBasis = Basis.Identity;
var angle = Mathf.Tau / 2.0f;

myBasis = myBasis.Rotated(Vector3.Up, angle);    // Rotate around the up axis (yaw).
myBasis = myBasis.Rotated(Vector3.Right, angle); // Rotate around the right axis (pitch).
myBasis = myBasis.Rotated(Vector3.Back, angle);  // Rotate around the back axis (roll).</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-scaled"></target>
            <paragraph classes="classref-method" ids="class-basis-method-scaled" names="class_basis_method_scaled"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>scaled</strong>(scale: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-scaled"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns this basis with each axis's components scaled by the given <literal>scale</literal>'s components.</paragraph>
            <paragraph>The basis matrix's rows are multiplied by <literal>scale</literal>'s components. This operation is a global scale (relative to the parent).</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var my_basis = Basis(
    Vector3(1, 1, 1),
    Vector3(2, 2, 2),
    Vector3(3, 3, 3)
)
my_basis = my_basis.scaled(Vector3(0, 2, -2))

print(my_basis.x) # Prints (0.0, 2.0, -2.0)
print(my_basis.y) # Prints (0.0, 4.0, -4.0)
print(my_basis.z) # Prints (0.0, 6.0, -6.0)</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var myBasis = new Basis(
    new Vector3(1.0f, 1.0f, 1.0f),
    new Vector3(2.0f, 2.0f, 2.0f),
    new Vector3(3.0f, 3.0f, 3.0f)
);
myBasis = myBasis.Scaled(new Vector3(0.0f, 2.0f, -2.0f));

GD.Print(myBasis.X); // Prints (0, 2, -2)
GD.Print(myBasis.Y); // Prints (0, 4, -4)
GD.Print(myBasis.Z); // Prints (0, 6, -6)</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-scaled-local"></target>
            <paragraph classes="classref-method" ids="class-basis-method-scaled-local" names="class_basis_method_scaled_local"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>scaled_local</strong>(scale: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-scaled-local"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns this basis with each axis scaled by the corresponding component in the given <literal>scale</literal>.</paragraph>
            <paragraph>The basis matrix's columns are multiplied by <literal>scale</literal>'s components. This operation is a local scale (relative to self).</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var my_basis = Basis(
    Vector3(1, 1, 1),
    Vector3(2, 2, 2),
    Vector3(3, 3, 3)
)
my_basis = my_basis.scaled_local(Vector3(0, 2, -2))

print(my_basis.x) # Prints (0.0, 0.0, 0.0)
print(my_basis.y) # Prints (4.0, 4.0, 4.0)
print(my_basis.z) # Prints (-6.0, -6.0, -6.0)</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var myBasis = new Basis(
    new Vector3(1.0f, 1.0f, 1.0f),
    new Vector3(2.0f, 2.0f, 2.0f),
    new Vector3(3.0f, 3.0f, 3.0f)
);
myBasis = myBasis.ScaledLocal(new Vector3(0.0f, 2.0f, -2.0f));

GD.Print(myBasis.X); // Prints (0, 0, 0)
GD.Print(myBasis.Y); // Prints (4, 4, 4)
GD.Print(myBasis.Z); // Prints (-6, -6, -6)</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-slerp"></target>
            <paragraph classes="classref-method" ids="class-basis-method-slerp" names="class_basis_method_slerp"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>slerp</strong>(to: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>, weight: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-slerp"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Performs a spherical-linear interpolation with the <literal>to</literal> basis, given a <literal>weight</literal>. Both this basis and <literal>to</literal> should represent a rotation.</paragraph>
            <paragraph><strong>Example:</strong> Smoothly rotate a <reference internal="True" refuri="class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> to the target basis over time, with a <reference internal="True" refuri="class_tween#class-tween"><inline classes="std std-ref">Tween</inline></reference>:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">var start_basis = Basis.IDENTITY
var target_basis = Basis.IDENTITY.rotated(Vector3.UP, TAU / 2)

func _ready():
    create_tween().tween_method(interpolate, 0.0, 1.0, 5.0).set_trans(Tween.TRANS_EXPO)

func interpolate(weight):
    basis = start_basis.slerp(target_basis, weight)</literal_block>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-tdotx"></target>
            <paragraph classes="classref-method" ids="class-basis-method-tdotx" names="class_basis_method_tdotx"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>tdotx</strong>(with: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-tdotx"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the transposed dot product between <literal>with</literal> and the <reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference> axis (see <reference internal="True" refid="class-basis-method-transposed"><inline classes="std std-ref">transposed()</inline></reference>).</paragraph>
            <paragraph>This is equivalent to <literal>basis.x.dot(vector)</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-tdoty"></target>
            <paragraph classes="classref-method" ids="class-basis-method-tdoty" names="class_basis_method_tdoty"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>tdoty</strong>(with: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-tdoty"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the transposed dot product between <literal>with</literal> and the <reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference> axis (see <reference internal="True" refid="class-basis-method-transposed"><inline classes="std std-ref">transposed()</inline></reference>).</paragraph>
            <paragraph>This is equivalent to <literal>basis.y.dot(vector)</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-tdotz"></target>
            <paragraph classes="classref-method" ids="class-basis-method-tdotz" names="class_basis_method_tdotz"><reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference> <strong>tdotz</strong>(with: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-tdotz"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the transposed dot product between <literal>with</literal> and the <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference> axis (see <reference internal="True" refid="class-basis-method-transposed"><inline classes="std std-ref">transposed()</inline></reference>).</paragraph>
            <paragraph>This is equivalent to <literal>basis.z.dot(vector)</literal>.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-method-transposed"></target>
            <paragraph classes="classref-method" ids="class-basis-method-transposed" names="class_basis_method_transposed"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>transposed</strong>() <abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation> <reference internal="True" refid="class-basis-method-transposed"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns the transposed version of this basis. This turns the basis matrix's columns into rows, and its rows into columns.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var my_basis = Basis(
    Vector3(1, 2, 3),
    Vector3(4, 5, 6),
    Vector3(7, 8, 9)
)
my_basis = my_basis.transposed()

print(my_basis.x) # Prints (1.0, 4.0, 7.0)
print(my_basis.y) # Prints (2.0, 5.0, 8.0)
print(my_basis.z) # Prints (3.0, 6.0, 9.0)</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var myBasis = new Basis(
    new Vector3(1.0f, 2.0f, 3.0f),
    new Vector3(4.0f, 5.0f, 6.0f),
    new Vector3(7.0f, 8.0f, 9.0f)
);
myBasis = myBasis.Transposed();

GD.Print(myBasis.X); // Prints (1, 4, 7)
GD.Print(myBasis.Y); // Prints (2, 5, 8)
GD.Print(myBasis.Z); // Prints (3, 6, 9)</literal_block>
                </div>
            </container>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="operator-descriptions" names="operator\ descriptions">
            <title>Operator Descriptions</title>
            <target refid="class-basis-operator-neq-basis"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-neq-basis" names="class_basis_operator_neq_basis"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator !=</strong>(right: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>) <reference internal="True" refid="class-basis-operator-neq-basis"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the components of both <strong>Basis</strong> matrices are not equal.</paragraph>
            <paragraph><strong>Note:</strong> Due to floating-point precision errors, consider using <reference internal="True" refid="class-basis-method-is-equal-approx"><inline classes="std std-ref">is_equal_approx()</inline></reference> instead, which is more reliable.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-mul-basis"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-mul-basis" names="class_basis_operator_mul_basis"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>operator *</strong>(right: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>) <reference internal="True" refid="class-basis-operator-mul-basis"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Transforms (multiplies) the <literal>right</literal> basis by this basis.</paragraph>
            <paragraph>This is the operation performed between parent and child <reference internal="True" refuri="class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference>s.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-mul-vector3"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-mul-vector3" names="class_basis_operator_mul_vector3"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>operator *</strong>(right: <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>) <reference internal="True" refid="class-basis-operator-mul-vector3"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Transforms (multiplies) the <literal>right</literal> vector by this basis, returning a <reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Basis that swaps the X/Z axes and doubles the scale.
var my_basis = Basis(Vector3(0, 2, 0), Vector3(2, 0, 0), Vector3(0, 0, 2))
print(my_basis * Vector3(1, 2, 3)) # Prints (4.0, 2.0, 6.0)</literal_block>
                </div>
                <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Basis that swaps the X/Z axes and doubles the scale.
var myBasis = new Basis(new Vector3(0, 2, 0), new Vector3(2, 0, 0), new Vector3(0, 0, 2));
GD.Print(myBasis * new Vector3(1, 2, 3)); // Prints (4, 2, 6)</literal_block>
                </div>
            </container>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-mul-float"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-mul-float" names="class_basis_operator_mul_float"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>operator *</strong>(right: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <reference internal="True" refid="class-basis-operator-mul-float"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Multiplies all components of the <strong>Basis</strong> by the given <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>. This affects the basis's scale uniformly, resizing all 3 axes by the <literal>right</literal> value.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-mul-int"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-mul-int" names="class_basis_operator_mul_int"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>operator *</strong>(right: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-basis-operator-mul-int"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Multiplies all components of the <strong>Basis</strong> by the given <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>. This affects the basis's scale uniformly, resizing all 3 axes by the <literal>right</literal> value.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-div-float"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-div-float" names="class_basis_operator_div_float"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>operator /</strong>(right: <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>) <reference internal="True" refid="class-basis-operator-div-float"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Divides all components of the <strong>Basis</strong> by the given <reference internal="True" refuri="class_float#class-float"><inline classes="std std-ref">float</inline></reference>. This affects the basis's scale uniformly, resizing all 3 axes by the <literal>right</literal> value.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-div-int"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-div-int" names="class_basis_operator_div_int"><reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference> <strong>operator /</strong>(right: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-basis-operator-div-int"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Divides all components of the <strong>Basis</strong> by the given <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>. This affects the basis's scale uniformly, resizing all 3 axes by the <literal>right</literal> value.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-eq-basis"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-eq-basis" names="class_basis_operator_eq_basis"><reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> <strong>operator ==</strong>(right: <reference internal="True" refid="class-basis"><inline classes="std std-ref">Basis</inline></reference>) <reference internal="True" refid="class-basis-operator-eq-basis"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Returns <literal>true</literal> if the components of both <strong>Basis</strong> matrices are exactly equal.</paragraph>
            <paragraph><strong>Note:</strong> Due to floating-point precision errors, consider using <reference internal="True" refid="class-basis-method-is-equal-approx"><inline classes="std std-ref">is_equal_approx()</inline></reference> instead, which is more reliable.</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-basis-operator-idx-int"></target>
            <paragraph classes="classref-operator" ids="class-basis-operator-idx-int" names="class_basis_operator_idx_int"><reference internal="True" refuri="class_vector3#class-vector3"><inline classes="std std-ref">Vector3</inline></reference> <strong>operator []</strong>(index: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>) <reference internal="True" refid="class-basis-operator-idx-int"><inline classes="std std-ref">ðŸ”—</inline></reference></paragraph>
            <paragraph>Accesses each axis (column) of this basis by their index. Index <literal>0</literal> is the same as <reference internal="True" refid="class-basis-property-x"><inline classes="std std-ref">x</inline></reference>, index <literal>1</literal> is the same as <reference internal="True" refid="class-basis-property-y"><inline classes="std std-ref">y</inline></reference>, and index <literal>2</literal> is the same as <reference internal="True" refid="class-basis-property-z"><inline classes="std std-ref">z</inline></reference>.</paragraph>
            <paragraph><strong>Note:</strong> In C++, this operator accesses the rows of the basis matrix, <emphasis>not</emphasis> the columns. For the same behavior as scripting languages, use the <literal>set_column</literal> and <literal>get_column</literal> methods.</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="This method should typically be overridden by the user to have any effect.">virtual</abbreviation></substitution_definition>
            <substitution_definition names="required"><abbreviation explanation="This method is required to be overridden when extending its base class.">required</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="This method accepts any number of arguments after the ones described here.">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="This method is used to construct a type.">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="This method doesn't need an instance to be called, so it can be called directly using the class name.">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="This method describes a valid operator to use with this type as left-hand operand.">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="This value is an integer composed as a bitmask of the following flags.">BitField</abbreviation></substitution_definition>
            <substitution_definition names="void"><abbreviation explanation="No return value.">void</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
