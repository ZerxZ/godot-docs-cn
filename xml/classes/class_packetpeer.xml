<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/classes/class_packetpeer.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">DO NOT EDIT THIS FILE!!!</comment>
    <comment xml:space="preserve">Generated automatically from Godot engine sources.</comment>
    <comment xml:space="preserve">Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.</comment>
    <comment xml:space="preserve">XML source: https://github.com/godotengine/godot/tree/master/doc/classes/PacketPeer.xml.</comment>
    <target refid="class-packetpeer"></target>
    <section ids="packetpeer class-packetpeer" names="packetpeer class_packetpeer">
        <title>PacketPeer</title>
        <paragraph><strong>继承：</strong> <reference internal="True" refuri="class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> <strong>&lt;</strong> <reference internal="True" refuri="class_object#class-object"><inline classes="std std-ref">Object</inline></reference></paragraph>
        <paragraph><strong>派生：</strong> <reference internal="True" refuri="class_enetpacketpeer#class-enetpacketpeer"><inline classes="std std-ref">ENetPacketPeer</inline></reference>, <reference internal="True" refuri="class_multiplayerpeer#class-multiplayerpeer"><inline classes="std std-ref">MultiplayerPeer</inline></reference>, <reference internal="True" refuri="class_packetpeerdtls#class-packetpeerdtls"><inline classes="std std-ref">PacketPeerDTLS</inline></reference>, <reference internal="True" refuri="class_packetpeerextension#class-packetpeerextension"><inline classes="std std-ref">PacketPeerExtension</inline></reference>, <reference internal="True" refuri="class_packetpeerstream#class-packetpeerstream"><inline classes="std std-ref">PacketPeerStream</inline></reference>, <reference internal="True" refuri="class_packetpeerudp#class-packetpeerudp"><inline classes="std std-ref">PacketPeerUDP</inline></reference>, <reference internal="True" refuri="class_webrtcdatachannel#class-webrtcdatachannel"><inline classes="std std-ref">WebRTCDataChannel</inline></reference>, <reference internal="True" refuri="class_websocketpeer#class-websocketpeer"><inline classes="std std-ref">WebSocketPeer</inline></reference></paragraph>
        <paragraph>基于包的协议的抽象和基类。</paragraph>
        <section classes="classref-introduction-group" ids="id1" names="描述">
            <title>描述</title>
            <paragraph>PacketPeer 是基于数据包的协议（如 UDP）的抽象和基类。它提供了用于发送和接收数据包的 API，可以发送原始数据或变量。这使得在协议之间传输数据变得容易，不必将数据编码为低级字节或担心网络排序问题。</paragraph>
            <paragraph><strong>注意：</strong>导出到安卓时，在导出项目或使用一键部署之前，请务必在安卓导出预设中，开启 <literal>INTERNET</literal> 权限。否则，任何类型的网络通信，都将被 Android 阻止。</paragraph>
        </section>
        <section classes="classref-reftable-group" ids="id2" names="属性">
            <title>属性</title>
            <table classes="colwidths-auto">
                <tgroup cols="3">
                    <colspec colwidth="23"></colspec>
                    <colspec colwidth="81"></colspec>
                    <colspec colwidth="13"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeer-property-encode-buffer-max-size"><inline classes="std std-ref">encode_buffer_max_size</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><literal>8388608</literal></paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <section classes="classref-reftable-group" ids="id3" names="方法">
            <title>方法</title>
            <table classes="colwidths-auto">
                <tgroup cols="2">
                    <colspec colwidth="47"></colspec>
                    <colspec colwidth="140"></colspec>
                    <tbody>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeer-method-get-available-packet-count"><inline classes="std std-ref">get_available_packet_count</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeer-method-get-packet"><inline classes="std std-ref">get_packet</inline></reference>()</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeer-method-get-packet-error"><inline classes="std std-ref">get_packet_error</inline></reference>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeer-method-get-var"><inline classes="std std-ref">get_var</inline></reference>(allow_objects: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeer-method-put-packet"><inline classes="std std-ref">put_packet</inline></reference>(buffer: <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>)</paragraph>
                            </entry>
                        </row>
                        <row>
                            <entry>
                                <paragraph><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference></paragraph>
                            </entry>
                            <entry>
                                <paragraph><reference internal="True" refid="class-packetpeer-method-put-var"><inline classes="std std-ref">put_var</inline></reference>(var: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, full_objects: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false)</paragraph>
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id4" names="属性说明">
            <title>属性说明</title>
            <target refid="class-packetpeer-property-encode-buffer-max-size"></target>
            <paragraph classes="classref-property" ids="class-packetpeer-property-encode-buffer-max-size" names="class_packetpeer_property_encode_buffer_max_size"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>encode_buffer_max_size</strong> = <literal>8388608</literal> <reference internal="True" refid="class-packetpeer-property-encode-buffer-max-size"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <bullet_list bullet="-" classes="classref-property-setget">
                <list_item>
                    <paragraph><abbreviation explanation="无返回值。">void</abbreviation> <strong>set_encode_buffer_max_size</strong>(value: <reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_encode_buffer_max_size</strong>()</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>编码 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> 时允许的最大缓冲区大小。提高此值以支持更大的内存分配。</paragraph>
            <paragraph><reference internal="True" refid="class-packetpeer-method-put-var"><inline classes="std std-ref">put_var</inline></reference> 方法在栈上分配内存，使用的缓冲区将自动增长到最接近的二次方，以匹配 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> 的大小。如果 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> 大于 <reference internal="True" refid="class-packetpeer-property-encode-buffer-max-size"><inline classes="std std-ref">encode_buffer_max_size</inline></reference>，则该方法将以 <reference internal="True" refuri="class_@globalscope#class-globalscope-constant-err-out-of-memory"><inline classes="std std-ref">@GlobalScope.ERR_OUT_OF_MEMORY</inline></reference> 出错。</paragraph>
        </section>
        <transition classes="classref-section-separator"></transition>
        <section classes="classref-descriptions-group" ids="id5" names="方法说明">
            <title>方法说明</title>
            <target refid="class-packetpeer-method-get-available-packet-count"></target>
            <paragraph classes="classref-method" ids="class-packetpeer-method-get-available-packet-count" names="class_packetpeer_method_get_available_packet_count"><reference internal="True" refuri="class_int#class-int"><inline classes="std std-ref">int</inline></reference> <strong>get_available_packet_count</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-packetpeer-method-get-available-packet-count"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回环形缓冲区中当前可用的数据包数。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeer-method-get-packet"></target>
            <paragraph classes="classref-method" ids="class-packetpeer-method-get-packet" names="class_packetpeer_method_get_packet"><reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference> <strong>get_packet</strong>() <reference internal="True" refid="class-packetpeer-method-get-packet"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>获取原始数据包。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeer-method-get-packet-error"></target>
            <paragraph classes="classref-method" ids="class-packetpeer-method-get-packet-error" names="class_packetpeer_method_get_packet_error"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>get_packet_error</strong>() <abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation> <reference internal="True" refid="class-packetpeer-method-get-packet-error"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>返回最后接收的数据包的错误状态（通过 <reference internal="True" refid="class-packetpeer-method-get-packet"><inline classes="std std-ref">get_packet</inline></reference> 和 <reference internal="True" refid="class-packetpeer-method-get-var"><inline classes="std std-ref">get_var</inline></reference>）。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeer-method-get-var"></target>
            <paragraph classes="classref-method" ids="class-packetpeer-method-get-var" names="class_packetpeer_method_get_var"><reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> <strong>get_var</strong>(allow_objects: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <reference internal="True" refid="class-packetpeer-method-get-var"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>获取 Variant。如果 <literal>allow_objects</literal> 为 <literal>true</literal>，则允许解码出对象。</paragraph>
            <paragraph>在内部，这使用与 <reference internal="True" refuri="class_@globalscope#class-globalscope-method-bytes-to-var"><inline classes="std std-ref">@GlobalScope.bytes_to_var</inline></reference> 方法相同的解码机制。</paragraph>
            <paragraph><strong>警告：</strong>反序列化出的对象可能包含会被执行的代码。如果序列化的对象来自不受信任的来源，请不要使用此选项，以避免潜在的安全威胁，例如远程代码执行。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeer-method-put-packet"></target>
            <paragraph classes="classref-method" ids="class-packetpeer-method-put-packet" names="class_packetpeer_method_put_packet"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>put_packet</strong>(buffer: <reference internal="True" refuri="class_packedbytearray#class-packedbytearray"><inline classes="std std-ref">PackedByteArray</inline></reference>) <reference internal="True" refid="class-packetpeer-method-put-packet"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>发送一个原始数据包。</paragraph>
            <transition classes="classref-item-separator"></transition>
            <target refid="class-packetpeer-method-put-var"></target>
            <paragraph classes="classref-method" ids="class-packetpeer-method-put-var" names="class_packetpeer_method_put_var"><reference internal="True" refuri="class_@globalscope#enum-globalscope-error"><inline classes="std std-ref">Error</inline></reference> <strong>put_var</strong>(var: <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, full_objects: <reference internal="True" refuri="class_bool#class-bool"><inline classes="std std-ref">bool</inline></reference> = false) <reference internal="True" refid="class-packetpeer-method-put-var"><inline classes="std std-ref">🔗</inline></reference></paragraph>
            <paragraph>将 <reference internal="True" refuri="class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference> 作为数据包发送。如果 <literal>full_objects</literal> 为 <literal>true</literal>，则允许将对象编码（其中可能包含代码）。</paragraph>
            <paragraph>在内部，这使用与 <reference internal="True" refuri="class_@globalscope#class-globalscope-method-var-to-bytes"><inline classes="std std-ref">@GlobalScope.var_to_bytes</inline></reference> 方法相同的编码机制。</paragraph>
            <substitution_definition names="virtual"><abbreviation explanation="本方法通常需要用户覆盖才能生效。">virtual</abbreviation></substitution_definition>
            <substitution_definition names="const"><abbreviation explanation="本方法无副作用，不会修改该实例的任何成员变量。">const</abbreviation></substitution_definition>
            <substitution_definition names="vararg"><abbreviation explanation="本方法除了能接受在此处描述的参数外，还能够继续接受任意数量的参数。">vararg</abbreviation></substitution_definition>
            <substitution_definition names="constructor"><abbreviation explanation="本方法用于构造某个类型。">constructor</abbreviation></substitution_definition>
            <substitution_definition names="static"><abbreviation explanation="调用本方法无需实例，可直接使用类名进行调用。">static</abbreviation></substitution_definition>
            <substitution_definition names="operator"><abbreviation explanation="本方法描述的是使用本类型作为左操作数的有效运算符。">operator</abbreviation></substitution_definition>
            <substitution_definition names="bitfield"><abbreviation explanation="这个值是由下列位标志构成位掩码的整数。">BitField</abbreviation></substitution_definition>
            <substitution_definition names="void"><abbreviation explanation="无返回值。">void</abbreviation></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
