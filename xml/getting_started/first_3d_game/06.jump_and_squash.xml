<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/first_3d_game/06.jump_and_squash.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-first-3d-game-jumping-and-squashing-monsters"></target>
    <section ids="jumping-and-squashing-monsters doc-first-3d-game-jumping-and-squashing-monsters" names="jumping\ and\ squashing\ monsters 跳跃与踩扁怪物 doc_first_3d_game_jumping_and_squashing_monsters">
        <title>跳跃与踩扁怪物</title>
        <paragraph>在这一部分中，我们将添加跳跃、踩扁怪物的能力。在下一节课中，我们会让怪物在地面上击中玩家时让玩家死亡。</paragraph>
        <paragraph>首先我们要修改一些物理交互相关的设置。请进入<reference internal="True" refuri="../../tutorials/physics/physics_introduction#doc-physics-introduction-collision-layers-and-masks"><inline classes="std std-ref">物理层</inline></reference>的世界。</paragraph>
        <section ids="controlling-physics-interactions" names="controlling\ physics\ interactions 控制物理交互">
            <title>控制物理交互</title>
            <paragraph>物理实体可以访问两个互补的属性：层和遮罩。层（Layer）定义的是该对象位于哪些物理层上。</paragraph>
            <paragraph>遮罩（Mask）控制的是该实体会监听并检测的层，会影响碰撞检测。希望两个实体能够发生交互时，你需要让其中至少一个的遮罩与另一个（的层）相对应。</paragraph>
            <paragraph>可能有点绕，但请别担心，我们马上就会看到三个例子。</paragraph>
            <paragraph>重要的知识点是，你能够使用层和遮罩来过滤物理交互、控制性能、让代码中不需要再做额外的条件检测。</paragraph>
            <paragraph>默认情况下，所有物理体和区域的层和遮罩都被设成了 <literal>1</literal>。也就是说它们会互相碰撞。</paragraph>
            <paragraph>物理层由数字表示，但我们也可以为它们命名，记录什么是什么。</paragraph>
            <section ids="setting-layer-names" names="setting\ layer\ names 设置层名称">
                <title>设置层名称</title>
                <paragraph>让我们来为物理层命名。打开<emphasis>项目 -&gt; 项目设置</emphasis>。</paragraph>
                <paragraph><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/02.project_settings.png'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/02.project_settings.png"></image></paragraph>
                <paragraph>在左侧的菜单中，找到 <emphasis>Layer Names -&gt; 3D Physics</emphasis>（层名称 -&gt; 3D 物理）。你可以在右侧看到层的列表，每一层右侧都有一个字段，可以用来设置名称。将前三层分别命名为“player”“enemies”“world”（玩家、敌人、世界）。</paragraph>
                <paragraph><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/03.physics_layers.webp'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/03.physics_layers.webp"></image></paragraph>
                <paragraph>现在，我们就可以将它们分配给我们的物理节点了。</paragraph>
            </section>
            <section ids="assigning-layers-and-masks" names="assigning\ layers\ and\ masks 层和遮罩的分配">
                <title>层和遮罩的分配</title>
                <paragraph>在 <emphasis>Main</emphasis> 场景中选中 <literal>Ground</literal> 节点。在<emphasis>检查器</emphasis>中展开 <emphasis>Collision</emphasis>（碰撞）部分。你可以看到，该节点的层和遮罩在这里以按钮网格的形式排列。</paragraph>
                <paragraph><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/04.default_physics_properties.webp'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/04.default_physics_properties.webp"></image></paragraph>
                <paragraph>地面是世界的一部分，所以我们希望它属于第三层。点击 <emphasis>Layer</emphasis> 中的第一个点亮的按钮将其<strong>关闭</strong>，<strong>打开</strong>第三层。然后点击<strong>关闭</strong> <emphasis>Mask</emphasis>。</paragraph>
                <paragraph><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/05.toggle_layer_and_mask.webp'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/05.toggle_layer_and_mask.webp"></image></paragraph>
                <paragraph>上面说到过，<emphasis>Mask</emphasis> 属性可以让节点监听与其他物理对象的交互，但它不是实现碰撞所必须的。<literal>Ground</literal> 不需要监听任何东西；它存在的意义是防止生物下落。</paragraph>
                <paragraph>请注意，点击右侧的“...”按钮会将该属性以带名称的复选框的形式展示。</paragraph>
                <paragraph><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/06.named_checkboxes.png'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/06.named_checkboxes.png"></image></paragraph>
                <paragraph>接下来就是 <literal>Player</literal> 和 <literal>Mob</literal>。在<emphasis>文件系统</emphasis>面板中双击打开 <literal>player.tscn</literal> 文件。</paragraph>
                <paragraph>选中 <emphasis>Player</emphasis> 节点，将其 <emphasis>Collision -&gt; Mask</emphasis> 设为“enemies”和“world”。<emphasis>Layer</emphasis> 属性可以保持默认，因为第一个层就是“player”层。</paragraph>
                <paragraph><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/07.player_physics_mask.webp'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/07.player_physics_mask.webp"></image></paragraph>
                <paragraph>然后双击 <literal>mob.tscn</literal> 打开 <emphasis>Mob</emphasis> 场景，选中 <literal>Mob</literal> 节点。</paragraph>
                <paragraph>将其 <emphasis>Collision -&gt; Layer</emphasis> 设为“enemies”，然后取消 <emphasis>Collision -&gt; Mask</emphasis> 的设置，让遮罩为空。</paragraph>
                <paragraph><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/08.mob_physics_mask.webp'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/08.mob_physics_mask.webp"></image></paragraph>
                <paragraph>这些设置意味着怪物可以互相穿越。如果你希望怪物之间会发生碰撞和滑动，请<strong>打开</strong>“enemies”遮罩。</paragraph>
                <note>
                    <paragraph>小怪并不需要遮罩“world”层，因为它们只会沿着 XZ 平面移动。我们是故意不去为它们添加重力影响的。</paragraph>
                </note>
            </section>
        </section>
        <section ids="jumping" names="jumping 跳跃">
            <title>跳跃</title>
            <paragraph>跳跃机制本身只需要两行代码。打开 <emphasis>Player</emphasis> 脚本。我们需要一个值来控制跳跃的强度，并更新 <literal>_physics_process()</literal> 来对跳跃进行编码。</paragraph>
            <paragraph>在定义 <literal>fall_acceleration</literal> 这一行之后，在脚本的顶部，添加 <literal>jump_impulse</literal>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">#...
# Vertical impulse applied to the character upon jumping in meters per second.
@export var jump_impulse = 20</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Don't forget to rebuild the project so the editor knows about the new export variable.

// ...
// Vertical impulse applied to the character upon jumping in meters per second.
[Export]
public int JumpImpulse { get; set; } = 20;</literal_block>
                </div>
            </container>
            <paragraph>在 <literal>_physics_process()</literal> 内，请在调用 <literal>move_and_slide()</literal> 那块代码之前添加以下代码。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _physics_process(delta):
    #...

    # Jumping.
    if is_on_floor() and Input.is_action_just_pressed("jump"):
        target_velocity.y = jump_impulse

    #...</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _PhysicsProcess(double delta)
{
    // ...

    // Jumping.
    if (IsOnFloor() &amp;&amp; Input.IsActionJustPressed("jump"))
    {
        _targetVelocity.Y = JumpImpulse;
    }

    // ...
}</literal_block>
                </div>
            </container>
            <paragraph>这就是跳跃所需的所有东西！</paragraph>
            <paragraph><literal>is_on_floor()</literal> 方法是来自 <literal>CharacterBody3D</literal> 类的工具。如果物体在这一帧中与地板发生碰撞返回 <literal>true</literal>。这就是为什么我们要对 <emphasis>Player</emphasis> 施加重力的原因：这样我们就会与地板相撞，而不是像怪物一样漂浮在地板上。</paragraph>
            <paragraph>如果角色在地板上并且玩家按下跳跃，立即给予角色较大的垂直速度，因为在游戏中，玩家通常希望控制能得到响应，就像这样提供的即时速度提升，虽然不切实际，但会令玩家感觉很好。</paragraph>
            <paragraph>请注意，Y 轴的正方向是朝上的。这与 2D 有所不同， 2D的Y 轴的正方向是朝下的。</paragraph>
        </section>
        <section ids="squashing-monsters" names="squashing\ monsters 踩扁怪物">
            <title>踩扁怪物</title>
            <paragraph>接下来让我们来添加踩扁机制。我们会让玩家在怪物身上弹起，并同时消灭它们。</paragraph>
            <paragraph>我们需要检测与怪物的碰撞，并和与地板的碰撞相区分。要这么做，我们可以使用 Godot 的<reference internal="True" refuri="../../tutorials/scripting/groups#doc-groups"><inline classes="std std-ref">分组</inline></reference>标签功能。</paragraph>
            <paragraph>再次打开 <literal>mob.tscn</literal> 场景，选中 <emphasis>Mob</emphasis> 节点，就能在右侧的<emphasis>Node</emphasis>面板中看到信号的列表。<emphasis>Node</emphasis>面板有两个选项卡：你已经使用过的<emphasis>Signals</emphasis>，以及<emphasis>Groups</emphasis>它允许你为节点添加标签。</paragraph>
            <paragraph>单击这个选项卡就会出现一个输入框，可以填写标签的名称。在这个输入框中输入“mob”（小怪）并单击<emphasis>添加</emphasis>按钮。</paragraph>
            <paragraph><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/09.groups_tab.png'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/09.groups_tab.png"></image></paragraph>
            <paragraph><emphasis>场景</emphasis>面板中会出现一个图标，表示该节点至少处在一个分组之中。</paragraph>
            <paragraph><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/10.group_scene_icon.png'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/10.group_scene_icon.png"></image></paragraph>
            <paragraph>我们现在就可以在代码中使用分组来区分与怪物的碰撞和与地板的碰撞了。</paragraph>
            <section ids="coding-the-squash-mechanic" names="coding\ the\ squash\ mechanic 编写踩扁机制">
                <title>编写踩扁机制</title>
                <paragraph>回到 <emphasis>Player</emphasis> 脚本来编写踩扁和弹跳。</paragraph>
                <paragraph>在脚本顶部，我们需要添加一个属性 <literal>bounce_impulse</literal>。踩扁敌人时，我们不必让角色弹得比跳跃一样高。</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Vertical impulse applied to the character upon bouncing over a mob in
# meters per second.
@export var bounce_impulse = 16</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Don't forget to rebuild the project so the editor knows about the new export variable.

// Vertical impulse applied to the character upon bouncing over a mob in meters per second.
[Export]
public int BounceImpulse { get; set; } = 16;</literal_block>
                    </div>
                </container>
                <paragraph>然后，在 <literal>_physics_process()</literal> 中添加的 <strong>Jumping</strong> 代码块之后，添加以下循环。使用 <literal>move_and_slide()</literal> 时，Godot 有时会连续多次移动角色身体来平滑运动。因此，我们必须循环遍历所有可能发生的碰撞。</paragraph>
                <paragraph>在循环的每次迭代中，我们会检查是否落在了小怪身上。如果是的话，我们就消灭它并进行弹跳。</paragraph>
                <paragraph>如果某一帧没有发生碰撞，那么这段代码中的循环就不会执行。</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _physics_process(delta):
    #...

    # Iterate through all collisions that occurred this frame
    for index in range(get_slide_collision_count()):
        # We get one of the collisions with the player
        var collision = get_slide_collision(index)

        # If the collision is with ground
        if collision.get_collider() == null:
            continue

        # If the collider is with a mob
        if collision.get_collider().is_in_group("mob"):
            var mob = collision.get_collider()
            # we check that we are hitting it from above.
            if Vector3.UP.dot(collision.get_normal()) &gt; 0.1:
                # If so, we squash it and bounce.
                mob.squash()
                target_velocity.y = bounce_impulse
                # Prevent further duplicate calls.
                break</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _PhysicsProcess(double delta)
{
    // ...

    // Iterate through all collisions that occurred this frame.
    for (int index = 0; index &lt; GetSlideCollisionCount(); index++)
    {
        // We get one of the collisions with the player.
        KinematicCollision3D collision = GetSlideCollision(index);

        // If the collision is with a mob.
        // With C# we leverage typing and pattern-matching
        // instead of checking for the group we created.
        if (collision.GetCollider() is Mob mob)
        {
            // We check that we are hitting it from above.
            if (Vector3.Up.Dot(collision.GetNormal()) &gt; 0.1f)
            {
                // If so, we squash it and bounce.
                mob.Squash();
                _targetVelocity.Y = BounceImpulse;
                // Prevent further duplicate calls.
                break;
            }
        }
    }
}</literal_block>
                    </div>
                    <paragraph>新函数很多。下面我们来进一步介绍一下。</paragraph>
                </container>
                <paragraph>函数 <literal>get_slide_collision_count()</literal> 和 <literal>get_slide_collision()</literal> 都来自于 <reference internal="True" refuri="../../classes/class_characterbody3d#class-characterbody3d"><inline classes="std std-ref">CharacterBody3D</inline></reference> 类，他们与 <literal>move_and_slide()</literal> 有关。</paragraph>
                <paragraph><literal>get_slide_collision()</literal> 返回的是 <reference internal="True" refuri="../../classes/class_kinematiccollision3d#class-kinematiccollision3d"><inline classes="std std-ref">KinematicCollision3D</inline></reference> 对象，包含碰撞在哪里发生、如何发生等信息。例如，我们对它的 <literal>get_collider</literal> 属性调用 <literal>is_in_group()</literal> 来检查我们是否是和“mob”发生了碰撞：<literal>collision.collider.is_in_group("mob")</literal>。</paragraph>
                <note>
                    <paragraph>每一个 <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> 都可以使用 <literal>is_in_group()</literal> 方法。</paragraph>
                </note>
                <paragraph>我们使用向量点积 <literal>Vector3.UP.dot(collision.get_normal()) &gt; 0.1</literal> 来检查我们是不是降落在怪物身上。碰撞法线（normal）是垂直于碰撞平面的 3D 向量。可以通过点积与上方向进行比较。</paragraph>
                <paragraph>点积结果大于 <literal>0</literal> 时，两个向量的夹角小于 90 度。大于 <literal>0.1</literal> 表示我们大概位于怪物上方。</paragraph>
                <paragraph>处理完踩扁和反弹逻辑后，我们通过 <literal>break</literal> 语句提前终止循环，以防止进一步重复调用 <literal>mob.squash()</literal> ，否则这可能会导致意外的错误，例如将一次击杀获得的分数算成好几倍。</paragraph>
                <paragraph>我们调用了一个尚未定义的函数 <literal>mob.squash()</literal>。所以我们需要把它加入到 Mob 类中。</paragraph>
                <paragraph>在<emphasis>文件系统</emphasis>面板中双击打开 <literal>Mob.gd</literal> 脚本。在脚本顶部，我们要定义一个新的信号叫作 <literal>squashed</literal>（被踩扁）。你可以在底部添加 squash 函数，在里面发出这个信号并销毁这个小怪。</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Emitted when the player jumped on the mob.
signal squashed

# ...


func squash():
    squashed.emit()
    queue_free()</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Don't forget to rebuild the project so the editor knows about the new signal.

// Emitted when the player jumped on the mob.
[Signal]
public delegate void SquashedEventHandler();

// ...

public void Squash()
{
    EmitSignal(SignalName.Squashed);
    QueueFree();
}</literal_block>
                    </div>
                </container>
                <note>
                    <paragraph>使用 C# 时，Godot 将为所有以 <title_reference>EventHandler</title_reference> 结尾的信号自动创建适当的事件，请参阅 <reference internal="True" refuri="../../tutorials/scripting/c_sharp/c_sharp_signals#doc-c-sharp-signals"><inline classes="std std-ref">C# 信号</inline></reference>。</paragraph>
                </note>
                <paragraph>下一节课中，我们会使用这个信号来加分数。</paragraph>
                <paragraph>好了，你应该可以跳在怪物身上把它们消灭了。你可以按 <literal classes="kbd">F5</literal> 试玩游戏，并把 <literal>main.tscn</literal> 设成项目的主场景。</paragraph>
                <paragraph>不过玩家现在还不会死。我们会在下一部分实现。</paragraph>
                <substitution_definition names="image0"><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/02.project_settings.png'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/02.project_settings.png"></image></substitution_definition>
                <substitution_definition names="image1"><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/03.physics_layers.webp'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/03.physics_layers.webp"></image></substitution_definition>
                <substitution_definition names="image2"><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/04.default_physics_properties.webp'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/04.default_physics_properties.webp"></image></substitution_definition>
                <substitution_definition names="image3"><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/05.toggle_layer_and_mask.webp'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/05.toggle_layer_and_mask.webp"></image></substitution_definition>
                <substitution_definition names="image4"><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/06.named_checkboxes.png'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/06.named_checkboxes.png"></image></substitution_definition>
                <substitution_definition names="image5"><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/07.player_physics_mask.webp'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/07.player_physics_mask.webp"></image></substitution_definition>
                <substitution_definition names="image6"><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/08.mob_physics_mask.webp'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/08.mob_physics_mask.webp"></image></substitution_definition>
                <substitution_definition names="image7"><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/09.groups_tab.png'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/09.groups_tab.png"></image></substitution_definition>
                <substitution_definition names="image8"><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/10.group_scene_icon.png'}" uri="getting_started/first_3d_game/img/06.jump_and_squash/10.group_scene_icon.png"></image></substitution_definition>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
