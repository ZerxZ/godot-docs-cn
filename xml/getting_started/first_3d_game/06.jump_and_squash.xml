<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/first_3d_game/06.jump_and_squash.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-first-3d-game-jumping-and-squashing-monsters"></target>
    <section ids="jumping-and-squashing-monsters doc-first-3d-game-jumping-and-squashing-monsters" names="jumping\ and\ squashing\ monsters doc_first_3d_game_jumping_and_squashing_monsters">
        <title>Jumping and squashing monsters</title>
        <paragraph>In this part, we'll add the ability to jump and squash the monsters. In the next
            lesson, we'll make the player die when a monster hits them on the ground.</paragraph>
        <paragraph>First, we have to change a few settings related to physics interactions. Enter
            the world of <reference internal="True" refuri="../../tutorials/physics/physics_introduction#doc-physics-introduction-collision-layers-and-masks"><inline classes="std std-ref">physics layers</inline></reference>.</paragraph>
        <section ids="controlling-physics-interactions" names="controlling\ physics\ interactions">
            <title>Controlling physics interactions</title>
            <paragraph>Physics bodies have access to two complementary properties: layers and masks.
                Layers define on which physics layer(s) an object is.</paragraph>
            <paragraph>Masks control the layers that a body will listen to and detect. This affects
                collision detection. When you want two bodies to interact, you need at least one
                to have a mask corresponding to the other.</paragraph>
            <paragraph>If that's confusing, don't worry, we'll see three examples in a second.</paragraph>
            <paragraph>The important point is that you can use layers and masks to filter physics
                interactions, control performance, and remove the need for extra conditions in
                your code.</paragraph>
            <paragraph>By default, all physics bodies and areas are set to both layer and mask <literal>1</literal>.
                This means they all collide with each other.</paragraph>
            <paragraph>Physics layers are represented by numbers, but we can give them names to keep
                track of what's what.</paragraph>
            <section ids="setting-layer-names" names="setting\ layer\ names">
                <title>Setting layer names</title>
                <paragraph>Let's give our physics layers a name. Go to <emphasis>Project -&gt; Project Settings</emphasis>.</paragraph>
                <paragraph><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/02.project_settings.webp'}" original_uri="img/06.jump_and_squash/02.project_settings.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/02.project_settings.webp"></image></paragraph>
                <paragraph>In the left menu, navigate down to <emphasis>Layer Names -&gt; 3D Physics</emphasis>. You can see a
                    list of layers with a field next to each of them on the right. You can set their
                    names there. Name the first three layers <emphasis>player</emphasis>, <emphasis>enemies</emphasis>, and <emphasis>world</emphasis>,
                    respectively.</paragraph>
                <paragraph><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/03.physics_layers.webp'}" original_uri="img/06.jump_and_squash/03.physics_layers.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/03.physics_layers.webp"></image></paragraph>
                <paragraph>Now, we can assign them to our physics nodes.</paragraph>
            </section>
            <section ids="assigning-layers-and-masks" names="assigning\ layers\ and\ masks">
                <title>Assigning layers and masks</title>
                <paragraph>In the <emphasis>Main</emphasis> scene, select the <literal>Ground</literal> node. In the <emphasis>Inspector</emphasis>, expand the
                    <emphasis>Collision</emphasis> section. There, you can see the node's layers and masks as a grid of
                    buttons.</paragraph>
                <paragraph><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/04.default_physics_properties.webp'}" original_uri="img/06.jump_and_squash/04.default_physics_properties.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/04.default_physics_properties.webp"></image></paragraph>
                <paragraph>The ground is part of the world, so we want it to be part of the third layer.
                    Click the lit button to toggle <strong>off</strong> the first <emphasis>Layer</emphasis> and toggle <strong>on</strong> the third
                    one. Then, toggle <strong>off</strong> the <emphasis>Mask</emphasis> by clicking on it.</paragraph>
                <paragraph><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/05.toggle_layer_and_mask.webp'}" original_uri="img/06.jump_and_squash/05.toggle_layer_and_mask.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/05.toggle_layer_and_mask.webp"></image></paragraph>
                <paragraph>As mentioned before, the <emphasis>Mask</emphasis> property allows a node to listen to interaction
                    with other physics objects, but we don't need it to have collisions. <literal>Ground</literal> doesn't need to listen to anything; it's just there to prevent
                    creatures from falling.</paragraph>
                <paragraph>Note that you can click the "..." button on the right side of the properties to
                    see a list of named checkboxes.</paragraph>
                <paragraph><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/06.named_checkboxes.webp'}" original_uri="img/06.jump_and_squash/06.named_checkboxes.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/06.named_checkboxes.webp"></image></paragraph>
                <paragraph>Next up are the <literal>Player</literal> and the <literal>Mob</literal>. Open <literal>player.tscn</literal> by double-clicking
                    the file in the <emphasis>FileSystem</emphasis> dock.</paragraph>
                <paragraph>Select the <emphasis>Player</emphasis> node and set its <emphasis>Collision -&gt; Mask</emphasis> to both "enemies" and
                    "world". You can leave the default <emphasis>Layer</emphasis> property as it is, because the first layer is the
                    "player" layer.</paragraph>
                <paragraph><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/07.player_physics_mask.webp'}" original_uri="img/06.jump_and_squash/07.player_physics_mask.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/07.player_physics_mask.webp"></image></paragraph>
                <paragraph>Then, open the <emphasis>Mob</emphasis> scene by double-clicking on <literal>mob.tscn</literal> and select the
                    <literal>Mob</literal> node.</paragraph>
                <paragraph>Set its <emphasis>Collision -&gt; Layer</emphasis> to "enemies" and unset its <emphasis>Collision -&gt; Mask</emphasis>,
                    leaving the mask empty.</paragraph>
                <paragraph><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/08.mob_physics_mask.webp'}" original_uri="img/06.jump_and_squash/08.mob_physics_mask.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/08.mob_physics_mask.webp"></image></paragraph>
                <paragraph>These settings mean the monsters will move through one another. If you want the
                    monsters to collide with and slide against each other, turn <strong>on</strong> the "enemies"
                    mask.</paragraph>
                <note>
                    <paragraph>The mobs don't need to mask the "world" layer because they only move
                        on the XZ plane. We don't apply any gravity to them by design.</paragraph>
                </note>
            </section>
        </section>
        <section ids="jumping" names="jumping">
            <title>Jumping</title>
            <paragraph>The jumping mechanic itself requires only two lines of code. Open the <emphasis>Player</emphasis>
                script. We need a value to control the jump's strength and update
                <literal>_physics_process()</literal> to code the jump.</paragraph>
            <paragraph>After the line that defines <literal>fall_acceleration</literal>, at the top of the script, add
                the <literal>jump_impulse</literal>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">#...
# Vertical impulse applied to the character upon jumping in meters per second.
@export var jump_impulse = 20</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Don't forget to rebuild the project so the editor knows about the new export variable.

// ...
// Vertical impulse applied to the character upon jumping in meters per second.
[Export]
public int JumpImpulse { get; set; } = 20;</literal_block>
                </div>
            </container>
            <paragraph>Inside <literal>_physics_process()</literal>, add the following code before the <literal>move_and_slide()</literal> codeblock.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _physics_process(delta):
    #...

    # Jumping.
    if is_on_floor() and Input.is_action_just_pressed("jump"):
        target_velocity.y = jump_impulse

    #...</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _PhysicsProcess(double delta)
{
    // ...

    // Jumping.
    if (IsOnFloor() &amp;&amp; Input.IsActionJustPressed("jump"))
    {
        _targetVelocity.Y = JumpImpulse;
    }

    // ...
}</literal_block>
                </div>
            </container>
            <paragraph>That's all you need to jump!</paragraph>
            <paragraph>The <literal>is_on_floor()</literal> method is a tool from the <literal>CharacterBody3D</literal> class. It
                returns <literal>true</literal> if the body collided with the floor in this frame. That's why
                we apply gravity to the <emphasis>Player</emphasis>: so we collide with the floor instead of
                floating over it like the monsters.</paragraph>
            <paragraph>If the character is on the floor and the player presses "jump", we instantly
                give them a lot of vertical speed. In games, you really want controls to be
                responsive and giving instant speed boosts like these, while unrealistic, feels
                great.</paragraph>
            <paragraph>Notice that the Y axis is positive upwards. That's unlike 2D, where the Y axis
                is positive downwards.</paragraph>
        </section>
        <section ids="squashing-monsters" names="squashing\ monsters">
            <title>Squashing monsters</title>
            <paragraph>Let's add the squash mechanic next. We're going to make the character bounce
                over monsters and kill them at the same time.</paragraph>
            <paragraph>We need to detect collisions with a monster and to differentiate them from
                collisions with the floor. To do so, we can use Godot's <reference internal="True" refuri="../../tutorials/scripting/groups#doc-groups"><inline classes="std std-ref">group</inline></reference> tagging feature.</paragraph>
            <paragraph>Open the scene <literal>mob.tscn</literal> again and select the <emphasis>Mob</emphasis> node. Go to the <emphasis>Node</emphasis>
                dock on the right to see a list of signals. The <emphasis>Node</emphasis> dock has two tabs:
                <emphasis>Signals</emphasis>, which you've already used, and <emphasis>Groups</emphasis>, which allows you to assign
                tags to nodes. Click on the <emphasis>+</emphasis> button to open the <emphasis>Create new Group</emphasis> dialog.</paragraph>
            <paragraph><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/09.groups_tab.webp'}" original_uri="img/06.jump_and_squash/09.groups_tab.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/09.groups_tab.webp"></image></paragraph>
            <paragraph>Enter "mob" in the <emphasis>Name</emphasis> field and click the <emphasis>Ok</emphasis> button.</paragraph>
            <paragraph><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/10.group_create_new.webp'}" original_uri="img/06.jump_and_squash/10.group_create_new.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/10.group_create_new.webp"></image></paragraph>
            <paragraph>The "mob" group is now shown under the <emphasis>Scene Groups</emphasis> section.</paragraph>
            <paragraph><image alt="image9" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/11.group_scene_groups.webp'}" original_uri="img/06.jump_and_squash/11.group_scene_groups.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/11.group_scene_groups.webp"></image></paragraph>
            <paragraph>An icon appears in the <emphasis>Scene</emphasis> dock to indicate the node is part of at least one
                group.</paragraph>
            <paragraph><image alt="image10" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/12.group_scene_icon.webp'}" original_uri="img/06.jump_and_squash/12.group_scene_icon.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/12.group_scene_icon.webp"></image></paragraph>
            <paragraph>We can now use the group from the code to distinguish collisions with monsters
                from collisions with the floor.</paragraph>
            <section ids="coding-the-squash-mechanic" names="coding\ the\ squash\ mechanic">
                <title>Coding the squash mechanic</title>
                <paragraph>Head back to the <emphasis>Player</emphasis> script to code the squash and bounce.</paragraph>
                <paragraph>At the top of the script, we need another property, <literal>bounce_impulse</literal>. When
                    squashing an enemy, we don't necessarily want the character to go as high up as
                    when jumping.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Vertical impulse applied to the character upon bouncing over a mob in
# meters per second.
@export var bounce_impulse = 16</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Don't forget to rebuild the project so the editor knows about the new export variable.

// Vertical impulse applied to the character upon bouncing over a mob in meters per second.
[Export]
public int BounceImpulse { get; set; } = 16;</literal_block>
                    </div>
                </container>
                <paragraph>Then, after the <strong>Jumping</strong> codeblock we added above in <literal>_physics_process()</literal>, add the following loop. With
                    <literal>move_and_slide()</literal>, Godot makes the body move sometimes multiple times in a
                    row to smooth out the character's motion. So we have to loop over all collisions
                    that may have happened.</paragraph>
                <paragraph>In every iteration of the loop, we check if we landed on a mob. If so, we kill
                    it and bounce.</paragraph>
                <paragraph>With this code, if no collisions occurred on a given frame, the loop won't run.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _physics_process(delta):
    #...

    # Iterate through all collisions that occurred this frame
    for index in range(get_slide_collision_count()):
        # We get one of the collisions with the player
        var collision = get_slide_collision(index)

        # If there are duplicate collisions with a mob in a single frame
        # the mob will be deleted after the first collision, and a second call to
        # get_collider will return null, leading to a null pointer when calling
        # collision.get_collider().is_in_group("mob").
        # This block of code prevents processing duplicate collisions.
        if collision.get_collider() == null:
            continue

        # If the collider is with a mob
        if collision.get_collider().is_in_group("mob"):
            var mob = collision.get_collider()
            # we check that we are hitting it from above.
            if Vector3.UP.dot(collision.get_normal()) &gt; 0.1:
                # If so, we squash it and bounce.
                mob.squash()
                target_velocity.y = bounce_impulse
                # Prevent further duplicate calls.
                break</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _PhysicsProcess(double delta)
{
    // ...

    // Iterate through all collisions that occurred this frame.
    for (int index = 0; index &lt; GetSlideCollisionCount(); index++)
    {
        // We get one of the collisions with the player.
        KinematicCollision3D collision = GetSlideCollision(index);

        // If the collision is with a mob.
        // With C# we leverage typing and pattern-matching
        // instead of checking for the group we created.
        if (collision.GetCollider() is Mob mob)
        {
            // We check that we are hitting it from above.
            if (Vector3.Up.Dot(collision.GetNormal()) &gt; 0.1f)
            {
                // If so, we squash it and bounce.
                mob.Squash();
                _targetVelocity.Y = BounceImpulse;
                // Prevent further duplicate calls.
                break;
            }
        }
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>That's a lot of new functions. Here's some more information about them.</paragraph>
                <paragraph>The functions <literal>get_slide_collision_count()</literal> and <literal>get_slide_collision()</literal> both come from
                    the <reference internal="True" refuri="../../classes/class_characterbody3d#class-characterbody3d"><inline classes="std std-ref">CharacterBody3D</inline></reference> class and are related to
                    <literal>move_and_slide()</literal>.</paragraph>
                <paragraph><literal>get_slide_collision()</literal> returns a
                    <reference internal="True" refuri="../../classes/class_kinematiccollision3d#class-kinematiccollision3d"><inline classes="std std-ref">KinematicCollision3D</inline></reference> object that holds
                    information about where and how the collision occurred. For example, we use its
                    <literal>get_collider</literal> property to check if we collided with a "mob" by calling
                    <literal>is_in_group()</literal> on it: <literal>collision.get_collider().is_in_group("mob")</literal>.</paragraph>
                <note>
                    <paragraph>The method <literal>is_in_group()</literal> is available on every <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference>.</paragraph>
                </note>
                <paragraph>To check that we are landing on the monster, we use the vector dot product:
                    <literal>Vector3.UP.dot(collision.get_normal()) &gt; 0.1</literal>. The collision normal is a 3D vector
                    that is perpendicular to the plane where the collision occurred. The dot product
                    allows us to compare it to the up direction.</paragraph>
                <paragraph>With dot products, when the result is greater than <literal>0</literal>, the two vectors are at
                    an angle of fewer than 90 degrees. A value higher than <literal>0.1</literal> tells us that we
                    are roughly above the monster.</paragraph>
                <paragraph>After handling the squash and bounce logic, we terminate the loop early via the <literal>break</literal> statement
                    to prevent further duplicate calls to <literal>mob.squash()</literal>, which may otherwise result in unintended bugs
                    such as counting the score multiple times for one kill.</paragraph>
                <paragraph>We are calling one undefined function, <literal>mob.squash()</literal>, so we have to add it to
                    the Mob class.</paragraph>
                <paragraph>Open the script <literal>mob.gd</literal> by double-clicking on it in the <emphasis>FileSystem</emphasis> dock. At
                    the top of the script, we want to define a new signal named <literal>squashed</literal>. And at
                    the bottom, you can add the squash function, where we emit the signal and
                    destroy the mob.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Emitted when the player jumped on the mob.
signal squashed

# ...


func squash():
    squashed.emit()
    queue_free()</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Don't forget to rebuild the project so the editor knows about the new signal.

// Emitted when the player jumped on the mob.
[Signal]
public delegate void SquashedEventHandler();

// ...

public void Squash()
{
    EmitSignal(SignalName.Squashed);
    QueueFree();
}</literal_block>
                    </div>
                </container>
                <note>
                    <paragraph>When using C#, Godot will create the appropriate events automatically for all Signals ending with <title_reference>EventHandler</title_reference>, see <reference internal="True" refuri="../../tutorials/scripting/c_sharp/c_sharp_signals#doc-c-sharp-signals"><inline classes="std std-ref">C# Signals</inline></reference>.</paragraph>
                </note>
                <paragraph>We will use the signal to add points to the score in the next lesson.</paragraph>
                <paragraph>With that, you should be able to kill monsters by jumping on them. You can press
                    <literal classes="kbd">F5</literal> to try the game and set <literal>main.tscn</literal> as your project's main scene.</paragraph>
                <paragraph>However, the player won't die yet. We'll work on that in the next part.</paragraph>
                <substitution_definition names="image0"><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/02.project_settings.webp'}" original_uri="img/06.jump_and_squash/02.project_settings.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/02.project_settings.webp"></image></substitution_definition>
                <substitution_definition names="image1"><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/03.physics_layers.webp'}" original_uri="img/06.jump_and_squash/03.physics_layers.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/03.physics_layers.webp"></image></substitution_definition>
                <substitution_definition names="image2"><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/04.default_physics_properties.webp'}" original_uri="img/06.jump_and_squash/04.default_physics_properties.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/04.default_physics_properties.webp"></image></substitution_definition>
                <substitution_definition names="image3"><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/05.toggle_layer_and_mask.webp'}" original_uri="img/06.jump_and_squash/05.toggle_layer_and_mask.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/05.toggle_layer_and_mask.webp"></image></substitution_definition>
                <substitution_definition names="image4"><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/06.named_checkboxes.webp'}" original_uri="img/06.jump_and_squash/06.named_checkboxes.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/06.named_checkboxes.webp"></image></substitution_definition>
                <substitution_definition names="image5"><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/07.player_physics_mask.webp'}" original_uri="img/06.jump_and_squash/07.player_physics_mask.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/07.player_physics_mask.webp"></image></substitution_definition>
                <substitution_definition names="image6"><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/08.mob_physics_mask.webp'}" original_uri="img/06.jump_and_squash/08.mob_physics_mask.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/08.mob_physics_mask.webp"></image></substitution_definition>
                <substitution_definition names="image7"><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/09.groups_tab.webp'}" original_uri="img/06.jump_and_squash/09.groups_tab.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/09.groups_tab.webp"></image></substitution_definition>
                <substitution_definition names="image8"><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/10.group_create_new.webp'}" original_uri="img/06.jump_and_squash/10.group_create_new.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/10.group_create_new.webp"></image></substitution_definition>
                <substitution_definition names="image9"><image alt="image9" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/11.group_scene_groups.webp'}" original_uri="img/06.jump_and_squash/11.group_scene_groups.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/11.group_scene_groups.webp"></image></substitution_definition>
                <substitution_definition names="image10"><image alt="image10" candidates="{'*': 'getting_started/first_3d_game/img/06.jump_and_squash/12.group_scene_icon.webp'}" original_uri="img/06.jump_and_squash/12.group_scene_icon.webp" uri="getting_started/first_3d_game/img/06.jump_and_squash/12.group_scene_icon.webp"></image></substitution_definition>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
