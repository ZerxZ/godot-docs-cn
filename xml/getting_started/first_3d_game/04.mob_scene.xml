<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/first_3d_game/04.mob_scene.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-first-3d-game-designing-the-mob-scene"></target>
    <section ids="designing-the-mob-scene doc-first-3d-game-designing-the-mob-scene" names="designing\ the\ mob\ scene doc_first_3d_game_designing_the_mob_scene">
        <title>Designing the mob scene</title>
        <paragraph>In this part, you're going to code the monsters, which we'll call mobs. In the
            next lesson, we'll spawn them randomly around the playable area.</paragraph>
        <paragraph>Let's design the monsters themselves in a new scene. The node structure is going
            to be similar to the <literal>player.tscn</literal> scene.</paragraph>
        <paragraph>Create a scene with, once again, a <reference internal="True" refuri="../../classes/class_characterbody3d#class-characterbody3d"><inline classes="std std-ref">CharacterBody3D</inline></reference> node as its root. Name it
            <literal>Mob</literal>. Add a child node <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference>, name it <literal>Pivot</literal>. And drag and drop
            the file <literal>mob.glb</literal> from the <emphasis>FileSystem</emphasis> dock onto the <literal>Pivot</literal> to add the
            monster's 3D model to the scene.</paragraph>
        <image candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/drag_drop_mob.webp'}" original_uri="img/04.mob_scene/drag_drop_mob.webp" uri="getting_started/first_3d_game/img/04.mob_scene/drag_drop_mob.webp"></image>
        <paragraph>You can rename the newly created <literal>mob</literal> node
            into <literal>Character</literal>.</paragraph>
        <paragraph><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/01.initial_three_nodes.webp'}" original_uri="img/04.mob_scene/01.initial_three_nodes.webp" uri="getting_started/first_3d_game/img/04.mob_scene/01.initial_three_nodes.webp"></image></paragraph>
        <paragraph>We need a collision shape for our body to work. Right-click on the <literal>Mob</literal> node,
            the scene's root, and click <emphasis>Add Child Node</emphasis>.</paragraph>
        <paragraph><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/02.add_child_node.webp'}" original_uri="img/04.mob_scene/02.add_child_node.webp" uri="getting_started/first_3d_game/img/04.mob_scene/02.add_child_node.webp"></image></paragraph>
        <paragraph>Add a <reference internal="True" refuri="../../classes/class_collisionshape3d#class-collisionshape3d"><inline classes="std std-ref">CollisionShape3D</inline></reference>.</paragraph>
        <paragraph><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/03.scene_with_collision_shape.webp'}" original_uri="img/04.mob_scene/03.scene_with_collision_shape.webp" uri="getting_started/first_3d_game/img/04.mob_scene/03.scene_with_collision_shape.webp"></image></paragraph>
        <paragraph>In the <emphasis>Inspector</emphasis>, assign a <emphasis>BoxShape3D</emphasis> to the <emphasis>Shape</emphasis> property.</paragraph>
        <image candidates="{'*': 'getting_started/first_3d_game/img/01.game_setup/08.create_box_shape3D.webp'}" original_uri="img/01.game_setup/08.create_box_shape3D.webp" uri="getting_started/first_3d_game/img/01.game_setup/08.create_box_shape3D.webp"></image>
        <paragraph>We should change its size to fit the 3D model better. You can do so
            interactively by clicking and dragging on the orange dots.</paragraph>
        <paragraph>The box should touch the floor and be a little thinner than the model. Physics
            engines work in such a way that if the player's sphere touches even the box's
            corner, a collision will occur. If the box is a little too big compared to the
            3D model, you may die at a distance from the monster, and the game will feel
            unfair to the players.</paragraph>
        <paragraph><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/05.box_final_size.png'}" original_uri="img/04.mob_scene/05.box_final_size.png" uri="getting_started/first_3d_game/img/04.mob_scene/05.box_final_size.png"></image></paragraph>
        <paragraph>Notice that my box is taller than the monster. It is okay in this game because
            we're looking at the scene from above and using a fixed perspective. Collision
            shapes don't have to match the model exactly. It's the way the game feels when
            you test it that should dictate their form and size.</paragraph>
        <section ids="removing-monsters-off-screen" names="removing\ monsters\ off-screen">
            <title>Removing monsters off-screen</title>
            <paragraph>We're going to spawn monsters at regular time intervals in the game level. If
                we're not careful, their count could increase to infinity, and we don't want
                that. Each mob instance has both a memory and a processing cost, and we don't
                want to pay for it when the mob is outside the screen.</paragraph>
            <paragraph>Once a monster leaves the screen, we don't need it anymore, so we should delete it.
                Godot has a node that detects when objects leave the screen,
                <reference internal="True" refuri="../../classes/class_visibleonscreennotifier3d#class-visibleonscreennotifier3d"><inline classes="std std-ref">VisibleOnScreenNotifier3D</inline></reference>, and we're going to use it to destroy our mobs.</paragraph>
            <note>
                <paragraph>When you keep instancing an object, there's a technique you can
                    use to avoid the cost of creating and destroying instances all the time
                    called pooling. It consists of pre-creating an array of objects and reusing
                    them over and over.</paragraph>
                <paragraph>When working with GDScript, you don't need to worry about this. The main
                    reason to use pools is to avoid freezes with garbage-collected languages
                    like C# or Lua. GDScript uses a different technique to manage memory,
                    reference counting, which doesn't have that caveat. You can learn more
                    about that here: <reference internal="True" refuri="../../tutorials/scripting/gdscript/gdscript_basics#doc-gdscript-basics-memory-management"><inline classes="std std-ref">Memory management</inline></reference>.</paragraph>
            </note>
            <paragraph>Select the <literal>Mob</literal> node and add a child node <reference internal="True" refuri="../../classes/class_visibleonscreennotifier3d#class-visibleonscreennotifier3d"><inline classes="std std-ref">VisibleOnScreenNotifier3D</inline></reference>. Another
                box, pink this time, appears. When this box completely leaves the screen, the
                node will emit a signal.</paragraph>
            <paragraph><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/06.visibility_notifier.webp'}" original_uri="img/04.mob_scene/06.visibility_notifier.webp" uri="getting_started/first_3d_game/img/04.mob_scene/06.visibility_notifier.webp"></image></paragraph>
            <paragraph>Resize it using the orange dots until it covers the entire 3D model.</paragraph>
            <paragraph><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/07.visibility_notifier_bbox_resized.png'}" original_uri="img/04.mob_scene/07.visibility_notifier_bbox_resized.png" uri="getting_started/first_3d_game/img/04.mob_scene/07.visibility_notifier_bbox_resized.png"></image></paragraph>
            <section ids="coding-the-mob-s-movement" names="coding\ the\ mob's\ movement">
                <title>Coding the mob's movement</title>
                <paragraph>Let's implement the monster's motion. We're going to do this in two steps.
                    First, we'll write a script on the <literal>Mob</literal> that defines a function to initialize
                    the monster. We'll then code the randomized spawn mechanism in the <literal>main.tscn</literal> scene
                    and call the function from there.</paragraph>
                <paragraph>Attach a script to the <literal>Mob</literal>.</paragraph>
                <paragraph><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/08.mob_attach_script.webp'}" original_uri="img/04.mob_scene/08.mob_attach_script.webp" uri="getting_started/first_3d_game/img/04.mob_scene/08.mob_attach_script.webp"></image></paragraph>
                <paragraph>Here's the movement code to start with. We define two properties, <literal>min_speed</literal>
                    and <literal>max_speed</literal>, to define a random speed range, which we will later use to define <literal>CharacterBody3D.velocity</literal>.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

# Minimum speed of the mob in meters per second.
@export var min_speed = 10
# Maximum speed of the mob in meters per second.
@export var max_speed = 18


func _physics_process(_delta):
    move_and_slide()</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Mob : CharacterBody3D
{
    // Don't forget to rebuild the project so the editor knows about the new export variable.

    // Minimum speed of the mob in meters per second
    [Export]
    public int MinSpeed { get; set; } = 10;
    // Maximum speed of the mob in meters per second
    [Export]
    public int MaxSpeed { get; set; } = 18;

    public override void _PhysicsProcess(double delta)
    {
        MoveAndSlide();
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>Similarly to the player, we move the mob every frame by calling the function
                    <literal>CharacterBody3D.move_and_slide()</literal>. This time, we don't update
                    the <literal>velocity</literal> every frame; we want the monster to move at a constant speed
                    and leave the screen, even if it were to hit an obstacle.</paragraph>
                <paragraph>We need to define another function to calculate the <literal>CharacterBody3D.velocity</literal>. This
                    function will turn the monster towards the player and randomize both its angle
                    of motion and its velocity.</paragraph>
                <paragraph>The function will take a <literal>start_position</literal>,the mob's spawn position, and the
                    <literal>player_position</literal> as its arguments.</paragraph>
                <paragraph>We position the mob at <literal>start_position</literal> and turn it towards the player using
                    the <literal>look_at_from_position()</literal> method, and randomize the angle by rotating a
                    random amount around the Y axis. Below, <literal>randf_range()</literal> outputs a random value
                    between <literal>-PI / 4</literal> radians and <literal>PI / 4</literal> radians.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># This function will be called from the Main scene.
func initialize(start_position, player_position):
    # We position the mob by placing it at start_position
    # and rotate it towards player_position, so it looks at the player.
    look_at_from_position(start_position, player_position, Vector3.UP)
    # Rotate this mob randomly within range of -45 and +45 degrees,
    # so that it doesn't move directly towards the player.
    rotate_y(randf_range(-PI / 4, PI / 4))</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// This function will be called from the Main scene.
public void Initialize(Vector3 startPosition, Vector3 playerPosition)
{
    // We position the mob by placing it at startPosition
    // and rotate it towards playerPosition, so it looks at the player.
    LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
    // Rotate this mob randomly within range of -45 and +45 degrees,
    // so that it doesn't move directly towards the player.
    RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));
}</literal_block>
                    </div>
                </container>
                <paragraph>We got a random position, now we need a <literal>random_speed</literal>. <literal>randi_range()</literal> will be useful as it gives random int values, and we will use <literal>min_speed</literal> and <literal>max_speed</literal>.
                    <literal>random_speed</literal> is just an integer, and we just use it to multiply our <literal>CharacterBody3D.velocity</literal>. After <literal>random_speed</literal> is applied, we rotate <literal>CharacterBody3D.velocity</literal> Vector3 towards the player.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func initialize(start_position, player_position):
    # ...

    # We calculate a random speed (integer)
    var random_speed = randi_range(min_speed, max_speed)
    # We calculate a forward velocity that represents the speed.
    velocity = Vector3.FORWARD * random_speed
    # We then rotate the velocity vector based on the mob's Y rotation
    # in order to move in the direction the mob is looking.
    velocity = velocity.rotated(Vector3.UP, rotation.y)</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void Initialize(Vector3 startPosition, Vector3 playerPosition)
{
    // ...

    // We calculate a random speed (integer).
    int randomSpeed = GD.RandRange(MinSpeed, MaxSpeed);
    // We calculate a forward velocity that represents the speed.
    Velocity = Vector3.Forward * randomSpeed;
    // We then rotate the velocity vector based on the mob's Y rotation
    // in order to move in the direction the mob is looking.
    Velocity = Velocity.Rotated(Vector3.Up, Rotation.Y);
}</literal_block>
                    </div>
                </container>
            </section>
            <section ids="leaving-the-screen" names="leaving\ the\ screen">
                <title>Leaving the screen</title>
                <paragraph>We still have to destroy the mobs when they leave the screen. To do so, we'll
                    connect our <reference internal="True" refuri="../../classes/class_visibleonscreennotifier3d#class-visibleonscreennotifier3d"><inline classes="std std-ref">VisibleOnScreenNotifier3D</inline></reference> node's <literal>screen_exited</literal> signal to the <literal>Mob</literal>.</paragraph>
                <paragraph>Head back to the 3D viewport by clicking on the <emphasis>3D</emphasis> label at the top of the
                    editor. You can also press <literal classes="kbd">Ctrl + F2</literal> (<literal classes="kbd">Opt + 2</literal> on macOS).</paragraph>
                <paragraph><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/09.switch_to_3d_workspace.webp'}" original_uri="img/04.mob_scene/09.switch_to_3d_workspace.webp" uri="getting_started/first_3d_game/img/04.mob_scene/09.switch_to_3d_workspace.webp"></image></paragraph>
                <paragraph>Select the <reference internal="True" refuri="../../classes/class_visibleonscreennotifier3d#class-visibleonscreennotifier3d"><inline classes="std std-ref">VisibleOnScreenNotifier3D</inline></reference> node and on the right side of the interface,
                    navigate to the <emphasis>Node</emphasis> dock. Double-click the <literal>screen_exited()</literal> signal.</paragraph>
                <paragraph><image alt="image9" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/10.node_dock.webp'}" original_uri="img/04.mob_scene/10.node_dock.webp" uri="getting_started/first_3d_game/img/04.mob_scene/10.node_dock.webp"></image></paragraph>
                <paragraph>Connect the signal to the <literal>Mob</literal></paragraph>
                <paragraph><image alt="image10" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/11.connect_signal.webp'}" original_uri="img/04.mob_scene/11.connect_signal.webp" uri="getting_started/first_3d_game/img/04.mob_scene/11.connect_signal.webp"></image></paragraph>
                <paragraph>This will add a new function for you in your mob script,
                    <literal>_on_visible_on_screen_notifier_3d_screen_exited()</literal>. From it, call the <literal>queue_free()</literal>
                    method. This function destroys the instance it's called on.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_visible_on_screen_notifier_3d_screen_exited():
    queue_free()</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// We also specified this function name in PascalCase in the editor's connection window.
private void OnVisibilityNotifierScreenExited()
{
    QueueFree();
}</literal_block>
                    </div>
                </container>
                <paragraph>Our monster is ready to enter the game! In the next part, you will spawn
                    monsters in the game level.</paragraph>
                <paragraph>Here is the complete <literal>mob.gd</literal> script for reference.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

# Minimum speed of the mob in meters per second.
@export var min_speed = 10
# Maximum speed of the mob in meters per second.
@export var max_speed = 18

func _physics_process(_delta):
    move_and_slide()

# This function will be called from the Main scene.
func initialize(start_position, player_position):
    # We position the mob by placing it at start_position
    # and rotate it towards player_position, so it looks at the player.
    look_at_from_position(start_position, player_position, Vector3.UP)
    # Rotate this mob randomly within range of -45 and +45 degrees,
    # so that it doesn't move directly towards the player.
    rotate_y(randf_range(-PI / 4, PI / 4))

    # We calculate a random speed (integer)
    var random_speed = randi_range(min_speed, max_speed)
    # We calculate a forward velocity that represents the speed.
    velocity = Vector3.FORWARD * random_speed
    # We then rotate the velocity vector based on the mob's Y rotation
    # in order to move in the direction the mob is looking.
    velocity = velocity.rotated(Vector3.UP, rotation.y)

func _on_visible_on_screen_notifier_3d_screen_exited():
    queue_free()</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Mob : CharacterBody3D
{
    // Minimum speed of the mob in meters per second.
    [Export]
    public int MinSpeed { get; set; } = 10;
    // Maximum speed of the mob in meters per second.
    [Export]
    public int MaxSpeed { get; set; } = 18;

    public override void _PhysicsProcess(double delta)
    {
        MoveAndSlide();
    }

    // This function will be called from the Main scene.
    public void Initialize(Vector3 startPosition, Vector3 playerPosition)
    {
        // We position the mob by placing it at startPosition
        // and rotate it towards playerPosition, so it looks at the player.
        LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
        // Rotate this mob randomly within range of -45 and +45 degrees,
        // so that it doesn't move directly towards the player.
        RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));

        // We calculate a random speed (integer).
        int randomSpeed = GD.RandRange(MinSpeed, MaxSpeed);
        // We calculate a forward velocity that represents the speed.
        Velocity = Vector3.Forward * randomSpeed;
        // We then rotate the velocity vector based on the mob's Y rotation
        // in order to move in the direction the mob is looking.
        Velocity = Velocity.Rotated(Vector3.Up, Rotation.Y);
    }

    // We also specified this function name in PascalCase in the editor's connection window.
    private void OnVisibilityNotifierScreenExited()
    {
        QueueFree();
    }
}</literal_block>
                    </div>
                </container>
                <substitution_definition names="image0"><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/01.initial_three_nodes.webp'}" original_uri="img/04.mob_scene/01.initial_three_nodes.webp" uri="getting_started/first_3d_game/img/04.mob_scene/01.initial_three_nodes.webp"></image></substitution_definition>
                <substitution_definition names="image1"><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/02.add_child_node.webp'}" original_uri="img/04.mob_scene/02.add_child_node.webp" uri="getting_started/first_3d_game/img/04.mob_scene/02.add_child_node.webp"></image></substitution_definition>
                <substitution_definition names="image2"><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/03.scene_with_collision_shape.webp'}" original_uri="img/04.mob_scene/03.scene_with_collision_shape.webp" uri="getting_started/first_3d_game/img/04.mob_scene/03.scene_with_collision_shape.webp"></image></substitution_definition>
                <substitution_definition names="image4"><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/05.box_final_size.png'}" original_uri="img/04.mob_scene/05.box_final_size.png" uri="getting_started/first_3d_game/img/04.mob_scene/05.box_final_size.png"></image></substitution_definition>
                <substitution_definition names="image5"><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/06.visibility_notifier.webp'}" original_uri="img/04.mob_scene/06.visibility_notifier.webp" uri="getting_started/first_3d_game/img/04.mob_scene/06.visibility_notifier.webp"></image></substitution_definition>
                <substitution_definition names="image6"><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/07.visibility_notifier_bbox_resized.png'}" original_uri="img/04.mob_scene/07.visibility_notifier_bbox_resized.png" uri="getting_started/first_3d_game/img/04.mob_scene/07.visibility_notifier_bbox_resized.png"></image></substitution_definition>
                <substitution_definition names="image7"><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/08.mob_attach_script.webp'}" original_uri="img/04.mob_scene/08.mob_attach_script.webp" uri="getting_started/first_3d_game/img/04.mob_scene/08.mob_attach_script.webp"></image></substitution_definition>
                <substitution_definition names="image8"><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/09.switch_to_3d_workspace.webp'}" original_uri="img/04.mob_scene/09.switch_to_3d_workspace.webp" uri="getting_started/first_3d_game/img/04.mob_scene/09.switch_to_3d_workspace.webp"></image></substitution_definition>
                <substitution_definition names="image9"><image alt="image9" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/10.node_dock.webp'}" original_uri="img/04.mob_scene/10.node_dock.webp" uri="getting_started/first_3d_game/img/04.mob_scene/10.node_dock.webp"></image></substitution_definition>
                <substitution_definition names="image10"><image alt="image10" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/11.connect_signal.webp'}" original_uri="img/04.mob_scene/11.connect_signal.webp" uri="getting_started/first_3d_game/img/04.mob_scene/11.connect_signal.webp"></image></substitution_definition>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
