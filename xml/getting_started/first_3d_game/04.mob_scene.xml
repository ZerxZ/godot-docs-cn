<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/first_3d_game/04.mob_scene.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-first-3d-game-designing-the-mob-scene"></target>
    <section ids="designing-the-mob-scene doc-first-3d-game-designing-the-mob-scene" names="designing\ the\ mob\ scene 设计小怪场景 doc_first_3d_game_designing_the_mob_scene">
        <title>设计小怪场景</title>
        <paragraph>在这一部分中，我们要为怪物编写代码，我们后续会称之为“mob”（小怪）。在下一节课中，我们会在游戏区域周围随机生成它们。</paragraph>
        <paragraph>让我们在一个新场景中设计这些怪物。节点结构和 <literal>player.tscn</literal> 场景类似。</paragraph>
        <paragraph>还是用 <reference internal="True" refuri="../../classes/class_characterbody3d#class-characterbody3d"><inline classes="std std-ref">CharacterBody3D</inline></reference> 节点作为根节点来创建场景。命名为 <emphasis>Mob</emphasis>。添加一个 <reference internal="True" refuri="../../classes/class_node3d#class-node3d"><inline classes="std std-ref">Node3D</inline></reference> 节点作为其子项，将其命名为 <emphasis>Pivot</emphasis>。将 <literal>mob.glb</literal> 文件从<emphasis>文件系统</emphasis>面板拖放到 <emphasis>Pivot</emphasis> 上，这样就把怪物的 3D 模型添加到了场景之中。</paragraph>
        <image candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/drag_drop_mob.webp'}" uri="getting_started/first_3d_game/img/04.mob_scene/drag_drop_mob.webp"></image>
        <paragraph>你可以将新创建的 <literal>mob</literal> 节点重命名成 <literal>Character</literal>。</paragraph>
        <paragraph><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/01.initial_three_nodes.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/01.initial_three_nodes.png"></image></paragraph>
        <paragraph>我们的实体要添加碰撞形状后才能正常工作。右键单击场景的根节点 <emphasis>Mob</emphasis>，然后单击<emphasis>添加子节点</emphasis>。</paragraph>
        <paragraph><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/02.add_child_node.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/02.add_child_node.png"></image></paragraph>
        <paragraph>添加一个 <reference internal="True" refuri="../../classes/class_collisionshape3d#class-collisionshape3d"><inline classes="std std-ref">CollisionShape3D</inline></reference>。</paragraph>
        <paragraph><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/03.scene_with_collision_shape.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/03.scene_with_collision_shape.png"></image></paragraph>
        <paragraph>在<emphasis>检查器</emphasis>中为 <emphasis>Shape</emphasis>（形状）属性分配一个 <emphasis>BoxShape3D</emphasis>。</paragraph>
        <image candidates="{'*': 'getting_started/first_3d_game/img/01.game_setup/08.create_box_shape3D.jpg'}" uri="getting_started/first_3d_game/img/01.game_setup/08.create_box_shape3D.jpg"></image>
        <paragraph>我们要调整一下它的大小，来更好地框住 3D 模型。可以单击并拖动橙色的小点来进行。</paragraph>
        <paragraph>碰撞盒应该接触地面，并且比模型稍微瘦一点点。即便玩家的球体只接触了这个碰撞盒的角落，物理引擎也会判定发生了碰撞。如果盒子比 3D 模型要大一点，你可能距离怪物还有一定的距离就死了，玩家就会觉得不公平。</paragraph>
        <paragraph><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/05.box_final_size.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/05.box_final_size.png"></image></paragraph>
        <paragraph>请注意，我的盒子要比怪物稍高。在这个游戏里是没问题的，因为我们是从游戏场景的上方用固定角度观察的。碰撞形状不必精确匹配模型。决定碰撞形状形式和大小的关键是你在试玩游戏时的手感。</paragraph>
        <section ids="removing-monsters-off-screen" names="removing\ monsters\ off-screen 移除离屏的怪物">
            <title>移除离屏的怪物</title>
            <paragraph>我们要在游戏关卡中按照一定的时间间隔刷怪。如果你不小心，它们的数量可能就会无限地增长下去，我们可不想那样。每个小怪实例都需要付出一定的内存和处理代价，我们不希望让屏幕之外的小怪浪费资源。</paragraph>
            <paragraph>怪物离开屏幕之后，我们就不再需要它了，所以我们可以把它删除。Godot 有一个可以检测对象离开屏幕的节点， <reference internal="True" refuri="../../classes/class_visibleonscreennotifier3d#class-visibleonscreennotifier3d"><inline classes="std std-ref">VisibleOnScreenNotifier3D</inline></reference> ，我们就要用它来销毁我们的小怪。</paragraph>
            <note>
                <paragraph>如果要在游戏中不断实例化同一种对象，可以通过一种叫“池化”（pooling）的技术来避免持续地创建和销毁实例。做法是预先创建一个该对象的数组，然后去不断地重用里面的元素。</paragraph>
                <paragraph>使用 GDScript 时，你不必担心这个问题。用对象池的主要目的是避免 C# 或 Lua 等语言在进行垃圾回收（Garbage collection，GC）时所带来的停滞。GDScript 管理内存的技术和这些语言是不同的，用的是引用计数，不会产生那种问题。你可以在此了解更多相关内容：<reference internal="True" refuri="../../tutorials/scripting/gdscript/gdscript_basics#doc-gdscript-basics-memory-management"><inline classes="std std-ref">内存管理</inline></reference>。</paragraph>
            </note>
            <paragraph>选中 <literal>Mob</literal> 节点，并为其添加一个 <reference internal="True" refuri="../../classes/class_visibleonscreennotifier3d#class-visibleonscreennotifier3d"><inline classes="std std-ref">VisibleOnScreenNotifier3D</inline></reference> 作为子项。这回出现的就是一个粉色的框。这个框完全离开屏幕后，该节点就会发出信号。</paragraph>
            <paragraph><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/06.visibility_notifier.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/06.visibility_notifier.png"></image></paragraph>
            <paragraph>使用橙色的点来调整大小，让它覆盖住整个 3D 模型。</paragraph>
            <paragraph><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/07.visibility_notifier_bbox_resized.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/07.visibility_notifier_bbox_resized.png"></image></paragraph>
            <section ids="coding-the-mob-s-movement" names="coding\ the\ mob's\ movement 为小怪的移动编写代码">
                <title>为小怪的移动编写代码</title>
                <paragraph>让我们来实现怪物的运动。我们要分两步来实现。首先，我们要为 <literal>Mob</literal> 编写脚本，定义初始化怪物的函数。然后我们会在 <literal>main.tscn</literal> 场景中编写随机刷怪的机制并进行调用。</paragraph>
                <paragraph>为 <literal>Mob</literal> 附加脚本。</paragraph>
                <paragraph><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/08.mob_attach_script.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/08.mob_attach_script.png"></image></paragraph>
                <paragraph>这是最初的移动代码。我们定义了两个属性 <literal>min_speed</literal> 和 <literal>max_speed</literal>（最小速度和最大速度）来定义随机速度的范围，后面我们会用这两个属性来定义 <literal>CharacterBody3D.velocity</literal>。</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

# Minimum speed of the mob in meters per second.
@export var min_speed = 10
# Maximum speed of the mob in meters per second.
@export var max_speed = 18


func _physics_process(_delta):
    move_and_slide()</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Mob : CharacterBody3D
{
    // Don't forget to rebuild the project so the editor knows about the new export variable.

    // Minimum speed of the mob in meters per second
    [Export]
    public int MinSpeed { get; set; } = 10;
    // Maximum speed of the mob in meters per second
    [Export]
    public int MaxSpeed { get; set; } = 18;

    public override void _PhysicsProcess(double delta)
    {
        MoveAndSlide();
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>与玩家类似，在每一帧我们都会通过调用 <literal>CharacterBody3D.move_and_slide()</literal> 方法来移动小怪。这一回，我们不会再每帧更新 <literal>velocity</literal> 了：我们希望怪物匀速移动，然后离开屏幕，即便碰到障碍物也一样。</paragraph>
                <paragraph>我们需要再定义一个函数来计算初始的速度。这个函数会让怪物面朝玩家，并将其运动角度和速度随机化。</paragraph>
                <paragraph>这个函数接受小怪的生成位置 <literal>start_position</literal> 以及玩家的位置 <literal>player_position</literal> 作为参数。</paragraph>
                <paragraph>我们首先将小怪定位在 <literal>start_position</literal> 并用 <literal>look_at_from_position()</literal> 方法将它转向玩家，并通过围绕 Y 轴旋转随机量来随机化角度。下面，<literal>rand_range()</literal> 输出一个介于 <literal>-PI / 4</literal> 弧度和 <literal>PI / 4</literal> 弧度的随机值。</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># This function will be called from the Main scene.
func initialize(start_position, player_position):
    # We position the mob by placing it at start_position
    # and rotate it towards player_position, so it looks at the player.
    look_at_from_position(start_position, player_position, Vector3.UP)
    # Rotate this mob randomly within range of -45 and +45 degrees,
    # so that it doesn't move directly towards the player.
    rotate_y(randf_range(-PI / 4, PI / 4))</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// This function will be called from the Main scene.
public void Initialize(Vector3 startPosition, Vector3 playerPosition)
{
    // We position the mob by placing it at startPosition
    // and rotate it towards playerPosition, so it looks at the player.
    LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
    // Rotate this mob randomly within range of -45 and +45 degrees,
    // so that it doesn't move directly towards the player.
    RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));
}</literal_block>
                    </div>
                </container>
                <paragraph>我们已经获取到了一个随机的位置，现在我们需要一个 <literal>random_speed</literal>。<literal>randi_range()</literal> 可以给我们需要的随机整数，并且我们要使用 <literal>min_speed</literal> 和 <literal>max_speed</literal>。<literal>random_speed</literal> 是一个整数，我们只是使用它与我们的 <literal>CharacterBody3D.velocity</literal> 相乘。在乘完 <literal>random_speed</literal> 之后，我们将 <literal>random_speed</literal> 旋转至朝向玩家的方向。</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func initialize(start_position, player_position):
    # ...

    # We calculate a random speed (integer)
    var random_speed = randi_range(min_speed, max_speed)
    # We calculate a forward velocity that represents the speed.
    velocity = Vector3.FORWARD * random_speed
    # We then rotate the velocity vector based on the mob's Y rotation
    # in order to move in the direction the mob is looking.
    velocity = velocity.rotated(Vector3.UP, rotation.y)</literal_block>
                    </div>
                    <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void Initialize(Vector3 startPosition, Vector3 playerPosition)
{
    // ...

    // We calculate a random speed (integer).
    int randomSpeed = GD.RandRange(MinSpeed, MaxSpeed);
    // We calculate a forward velocity that represents the speed.
    Velocity = Vector3.Forward * randomSpeed;
    // We then rotate the velocity vector based on the mob's Y rotation
    // in order to move in the direction the mob is looking.
    Velocity = Velocity.Rotated(Vector3.Up, Rotation.Y);
}</literal_block>
                    </div>
                </container>
            </section>
            <section ids="leaving-the-screen" names="leaving\ the\ screen 离开屏幕">
                <title>离开屏幕</title>
                <paragraph>我们还需要在小怪离开屏幕后将其销毁。实现方法是将 <reference internal="True" refuri="../../classes/class_visibleonscreennotifier3d#class-visibleonscreennotifier3d"><inline classes="std std-ref">VisibleOnScreenNotifier3D</inline></reference> 节点的 <literal>screen_exited</literal> 信号连接到 <literal>Mob</literal> 上。</paragraph>
                <paragraph>单击编辑器顶部的 <emphasis>3D</emphasis> 标签回到 3D 视口。你也可以按 <literal classes="kbd">Ctrl + F2</literal>（macOS 上则是 <literal classes="kbd">Alt + 2</literal>）。</paragraph>
                <paragraph><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/09.switch_to_3d_workspace.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/09.switch_to_3d_workspace.png"></image></paragraph>
                <paragraph>选中 <reference internal="True" refuri="../../classes/class_visibleonscreennotifier3d#class-visibleonscreennotifier3d"><inline classes="std std-ref">VisibleOnScreenNotifier3D</inline></reference> 节点，然后在界面右侧打开<emphasis>节点</emphasis>面板。双击 <literal>screen_exited()</literal> 信号。</paragraph>
                <paragraph><image alt="image9" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/10.node_dock.webp'}" uri="getting_started/first_3d_game/img/04.mob_scene/10.node_dock.webp"></image></paragraph>
                <paragraph>将信号连接到 <emphasis>Mob</emphasis></paragraph>
                <paragraph><image alt="image10" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/11.connect_signal.webp'}" uri="getting_started/first_3d_game/img/04.mob_scene/11.connect_signal.webp"></image></paragraph>
                <paragraph>这样会使你回到脚本编辑器，并且添加一个新的函数： <literal>_on_visible_on_screen_notifier_3d_screen_exited()</literal>。请在里面调用 <literal>queue_free()</literal> 方法。这个函数会将调用它的实例销毁。</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_visible_on_screen_notifier_3d_screen_exited():
    queue_free()</literal_block>
                    </div>
                    <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// We also specified this function name in PascalCase in the editor's connection window.
private void OnVisibilityNotifierScreenExited()
{
    QueueFree();
}</literal_block>
                    </div>
                </container>
                <paragraph>我们的怪物已经准备好进入游戏了！在下一部分，你将在游戏关卡中生成怪物。</paragraph>
                <paragraph>Here is the complete <literal>mob.gd</literal> script for reference.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

# Minimum speed of the mob in meters per second.
@export var min_speed = 10
# Maximum speed of the mob in meters per second.
@export var max_speed = 18

func _physics_process(_delta):
    move_and_slide()

# This function will be called from the Main scene.
func initialize(start_position, player_position):
    # We position the mob by placing it at start_position
    # and rotate it towards player_position, so it looks at the player.
    look_at_from_position(start_position, player_position, Vector3.UP)
    # Rotate this mob randomly within range of -45 and +45 degrees,
    # so that it doesn't move directly towards the player.
    rotate_y(randf_range(-PI / 4, PI / 4))

    # We calculate a random speed (integer)
    var random_speed = randi_range(min_speed, max_speed)
    # We calculate a forward velocity that represents the speed.
    velocity = Vector3.FORWARD * random_speed
    # We then rotate the velocity vector based on the mob's Y rotation
    # in order to move in the direction the mob is looking.
    velocity = velocity.rotated(Vector3.UP, rotation.y)

func _on_visible_on_screen_notifier_3d_screen_exited():
    queue_free()</literal_block>
                    </div>
                    <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Mob : CharacterBody3D
{
    // Minimum speed of the mob in meters per second.
    [Export]
    public int MinSpeed { get; set; } = 10;
    // Maximum speed of the mob in meters per second.
    [Export]
    public int MaxSpeed { get; set; } = 18;

    public override void _PhysicsProcess(double delta)
    {
        MoveAndSlide();
    }

    // This function will be called from the Main scene.
    public void Initialize(Vector3 startPosition, Vector3 playerPosition)
    {
        // We position the mob by placing it at startPosition
        // and rotate it towards playerPosition, so it looks at the player.
        LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
        // Rotate this mob randomly within range of -45 and +45 degrees,
        // so that it doesn't move directly towards the player.
        RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));

        // We calculate a random speed (integer).
        int randomSpeed = GD.RandRange(MinSpeed, MaxSpeed);
        // We calculate a forward velocity that represents the speed.
        Velocity = Vector3.Forward * randomSpeed;
        // We then rotate the velocity vector based on the mob's Y rotation
        // in order to move in the direction the mob is looking.
        Velocity = Velocity.Rotated(Vector3.Up, Rotation.Y);
    }

    // We also specified this function name in PascalCase in the editor's connection window.
    private void OnVisibilityNotifierScreenExited()
    {
        QueueFree();
    }
}</literal_block>
                    </div>
                </container>
                <substitution_definition names="image0"><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/01.initial_three_nodes.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/01.initial_three_nodes.png"></image></substitution_definition>
                <substitution_definition names="image1"><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/02.add_child_node.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/02.add_child_node.png"></image></substitution_definition>
                <substitution_definition names="image2"><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/03.scene_with_collision_shape.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/03.scene_with_collision_shape.png"></image></substitution_definition>
                <substitution_definition names="image4"><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/05.box_final_size.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/05.box_final_size.png"></image></substitution_definition>
                <substitution_definition names="image5"><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/06.visibility_notifier.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/06.visibility_notifier.png"></image></substitution_definition>
                <substitution_definition names="image6"><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/07.visibility_notifier_bbox_resized.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/07.visibility_notifier_bbox_resized.png"></image></substitution_definition>
                <substitution_definition names="image7"><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/08.mob_attach_script.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/08.mob_attach_script.png"></image></substitution_definition>
                <substitution_definition names="image8"><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/09.switch_to_3d_workspace.png'}" uri="getting_started/first_3d_game/img/04.mob_scene/09.switch_to_3d_workspace.png"></image></substitution_definition>
                <substitution_definition names="image9"><image alt="image9" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/10.node_dock.webp'}" uri="getting_started/first_3d_game/img/04.mob_scene/10.node_dock.webp"></image></substitution_definition>
                <substitution_definition names="image10"><image alt="image10" candidates="{'*': 'getting_started/first_3d_game/img/04.mob_scene/11.connect_signal.webp'}" uri="getting_started/first_3d_game/img/04.mob_scene/11.connect_signal.webp"></image></substitution_definition>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
