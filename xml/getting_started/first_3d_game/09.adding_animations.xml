<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/first_3d_game/09.adding_animations.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-first-3d-game-character-animation"></target>
    <section ids="character-animation doc-first-3d-game-character-animation" names="character\ animation doc_first_3d_game_character_animation">
        <title>Character animation</title>
        <paragraph>In this final lesson, we'll use Godot's built-in animation tools to make our
            characters float and flap. You'll learn to design animations in the editor and
            use code to make your game feel alive.</paragraph>
        <paragraph><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/squash-the-creeps-final.gif'}" original_uri="img/squash-the-creeps-final.gif" uri="getting_started/first_3d_game/img/squash-the-creeps-final.gif"></image></paragraph>
        <paragraph>We'll start with an introduction to using the animation editor.</paragraph>
        <section ids="using-the-animation-editor" names="using\ the\ animation\ editor">
            <title>Using the animation editor</title>
            <paragraph>The engine comes with tools to author animations in the editor. You can then use
                the code to play and control them at runtime.</paragraph>
            <paragraph>Open the player scene, select the <literal>Player</literal> node, and add an <reference internal="True" refuri="../../classes/class_animationplayer#class-animationplayer"><inline classes="std std-ref">AnimationPlayer</inline></reference> node.</paragraph>
            <paragraph>The <emphasis>Animation</emphasis> dock appears in the bottom panel.</paragraph>
            <paragraph><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/animation_player_dock.webp'}" original_uri="img/09.adding_animations/animation_player_dock.webp" uri="getting_started/first_3d_game/img/09.adding_animations/animation_player_dock.webp"></image></paragraph>
            <paragraph>It features a toolbar and the animation drop-down menu at the top, a track
                editor in the middle that's currently empty, and filter, snap, and zoom options
                at the bottom.</paragraph>
            <paragraph>Let's create an animation. Click on <emphasis>Animation -&gt; New</emphasis>.</paragraph>
            <paragraph><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/02.new_animation.webp'}" original_uri="img/09.adding_animations/02.new_animation.webp" uri="getting_started/first_3d_game/img/09.adding_animations/02.new_animation.webp"></image></paragraph>
            <paragraph>Name the animation "float".</paragraph>
            <paragraph><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/03.float_name.webp'}" original_uri="img/09.adding_animations/03.float_name.webp" uri="getting_started/first_3d_game/img/09.adding_animations/03.float_name.webp"></image></paragraph>
            <paragraph>Once you've created the animation, the timeline appears with numbers representing
                time in seconds.</paragraph>
            <paragraph><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/03.timeline.webp'}" original_uri="img/09.adding_animations/03.timeline.webp" uri="getting_started/first_3d_game/img/09.adding_animations/03.timeline.webp"></image></paragraph>
            <paragraph>We want the animation to start playback automatically at the start of the game.
                Also, it should loop.</paragraph>
            <paragraph>To do so, you can click the autoplay button (<image alt="Autoplay" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/autoplay_button.webp'}" original_uri="img/09.adding_animations/autoplay_button.webp" uri="getting_started/first_3d_game/img/09.adding_animations/autoplay_button.webp"></image>) in the animation toolbar
                and the looping arrows, respectively.</paragraph>
            <paragraph><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/04.autoplay_and_loop.webp'}" original_uri="img/09.adding_animations/04.autoplay_and_loop.webp" uri="getting_started/first_3d_game/img/09.adding_animations/04.autoplay_and_loop.webp"></image></paragraph>
            <paragraph>You can also pin the animation editor by clicking the pin icon in the top-right.
                This prevents it from folding when you click on the viewport and deselect the
                nodes.</paragraph>
            <paragraph><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/05.pin_icon.webp'}" original_uri="img/09.adding_animations/05.pin_icon.webp" uri="getting_started/first_3d_game/img/09.adding_animations/05.pin_icon.webp"></image></paragraph>
            <paragraph>Set the animation duration to <literal>1.2</literal> seconds in the top-right of the dock.</paragraph>
            <paragraph>You should see the gray ribbon widen a bit. It shows you the start and end of
                your animation and the vertical blue line is your time cursor.</paragraph>
            <paragraph><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/06.animation_duration.webp'}" original_uri="img/09.adding_animations/06.animation_duration.webp" uri="getting_started/first_3d_game/img/09.adding_animations/06.animation_duration.webp"></image></paragraph>
            <paragraph>You can click and drag the slider in the bottom-right to zoom in and out of the
                timeline.</paragraph>
            <paragraph><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/08.zoom_slider.webp'}" original_uri="img/09.adding_animations/08.zoom_slider.webp" uri="getting_started/first_3d_game/img/09.adding_animations/08.zoom_slider.webp"></image></paragraph>
        </section>
        <section ids="the-float-animation" names="the\ float\ animation">
            <title>The float animation</title>
            <paragraph>With the animation player node, you can animate most properties on as many nodes
                as you need. Notice the key icon next to properties in the <emphasis>Inspector</emphasis>. You can
                click any of them to create a keyframe, a time and value pair for the
                corresponding property. The keyframe gets inserted where your time cursor is in
                the timeline.</paragraph>
            <paragraph>Let's insert our first keys. Here, we will animate both the position and the
                rotation of the <literal>Character</literal> node.</paragraph>
            <paragraph>Select the <literal>Character</literal> and in the <emphasis>Inspector</emphasis> expand the <emphasis>Transform</emphasis> section. Click the key icon next to <emphasis>Position</emphasis>, and <emphasis>Rotation</emphasis>.</paragraph>
            <paragraph><image alt="image9" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/09.creating_first_keyframe.webp'}" original_uri="img/09.adding_animations/09.creating_first_keyframe.webp" uri="getting_started/first_3d_game/img/09.adding_animations/09.creating_first_keyframe.webp"></image></paragraph>
            <image candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/curves.webp'}" original_uri="img/09.adding_animations/curves.webp" uri="getting_started/first_3d_game/img/09.adding_animations/curves.webp"></image>
            <paragraph>For this tutorial, just create RESET Track(s) which is the default choice</paragraph>
            <paragraph>Two tracks appear in the editor with a diamond icon representing each keyframe.</paragraph>
            <paragraph><image alt="image10" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/10.initial_keys.webp'}" original_uri="img/09.adding_animations/10.initial_keys.webp" uri="getting_started/first_3d_game/img/09.adding_animations/10.initial_keys.webp"></image></paragraph>
            <paragraph>You can click and drag on the diamonds to move them in time. Move the
                position key to <literal>0.3</literal> seconds and the rotation key to <literal>0.1</literal> seconds.</paragraph>
            <paragraph><image alt="image11" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/11.moving_keys.webp'}" original_uri="img/09.adding_animations/11.moving_keys.webp" uri="getting_started/first_3d_game/img/09.adding_animations/11.moving_keys.webp"></image></paragraph>
            <paragraph>Move the time cursor to <literal>0.5</literal> seconds by clicking and dragging on the gray
                timeline, or by entering it into the input field.</paragraph>
            <paragraph><image alt="timeline_05_click" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/timeline_05_click.webp'}" original_uri="img/09.adding_animations/timeline_05_click.webp" uri="getting_started/first_3d_game/img/09.adding_animations/timeline_05_click.webp"></image></paragraph>
            <paragraph>In the <emphasis>Inspector</emphasis>, set the <emphasis>Position</emphasis>'s <emphasis>Y</emphasis> axis to <literal>0.65</literal> meters and the
                <emphasis>Rotation</emphasis>' <emphasis>X</emphasis> axis to <literal>8</literal>.</paragraph>
            <paragraph>If you don't see the properties in the <emphasis>Inspector</emphasis> panel, first click on the
                <literal>Character</literal> node again in the <emphasis>Scene</emphasis> dock.</paragraph>
            <paragraph><image alt="image12" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/12.second_keys_values.webp'}" original_uri="img/09.adding_animations/12.second_keys_values.webp" uri="getting_started/first_3d_game/img/09.adding_animations/12.second_keys_values.webp"></image></paragraph>
            <paragraph>Create a keyframe for both properties</paragraph>
            <paragraph><image alt="second_keys_both" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/second_keys_both.webp'}" original_uri="img/09.adding_animations/second_keys_both.webp" uri="getting_started/first_3d_game/img/09.adding_animations/second_keys_both.webp"></image></paragraph>
            <paragraph>Now, move the position keyframe to <literal>0.7</literal>
                seconds by dragging it on the timeline.</paragraph>
            <paragraph><image alt="image13" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/13.second_keys.webp'}" original_uri="img/09.adding_animations/13.second_keys.webp" uri="getting_started/first_3d_game/img/09.adding_animations/13.second_keys.webp"></image></paragraph>
            <note>
                <paragraph>A lecture on the principles of animation is beyond the scope of this
                    tutorial. Just note that you don't want to time and space everything evenly.
                    Instead, animators play with timing and spacing, two core animation
                    principles. You want to offset and contrast in your character's motion to
                    make them feel alive.</paragraph>
            </note>
            <paragraph>Move the time cursor to the end of the animation, at <literal>1.2</literal> seconds. Set the Y
                position to about <literal>0.35</literal> and the X rotation to <literal>-9</literal> degrees. Once again,
                create a key for both properties.</paragraph>
            <paragraph><image alt="animation_final_keyframes" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/animation_final_keyframes.webp'}" original_uri="img/09.adding_animations/animation_final_keyframes.webp" uri="getting_started/first_3d_game/img/09.adding_animations/animation_final_keyframes.webp"></image></paragraph>
            <paragraph>You can preview the result by clicking the play button or pressing <literal classes="kbd">Shift + D</literal>.
                Click the stop button or press <literal classes="kbd">S</literal> to stop playback.</paragraph>
            <paragraph><image alt="image14" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/14.play_button.webp'}" original_uri="img/09.adding_animations/14.play_button.webp" uri="getting_started/first_3d_game/img/09.adding_animations/14.play_button.webp"></image></paragraph>
            <paragraph>You can see that the engine interpolates between your keyframes to produce a
                continuous animation. At the moment, though, the motion feels very robotic. This
                is because the default interpolation is linear, causing constant transitions,
                unlike how living things move in the real world.</paragraph>
            <paragraph>We can control the transition between keyframes using easing curves.</paragraph>
            <paragraph>Click and drag around the first two keys in the timeline to box select them.</paragraph>
            <paragraph><image alt="image15" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/15.box_select.webp'}" original_uri="img/09.adding_animations/15.box_select.webp" uri="getting_started/first_3d_game/img/09.adding_animations/15.box_select.webp"></image></paragraph>
            <paragraph>You can edit the properties of both keys simultaneously in the <emphasis>Inspector</emphasis>,
                where you can see an <emphasis>Easing</emphasis> property.</paragraph>
            <paragraph><image alt="image16" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/16.easing_property.webp'}" original_uri="img/09.adding_animations/16.easing_property.webp" uri="getting_started/first_3d_game/img/09.adding_animations/16.easing_property.webp"></image></paragraph>
            <paragraph>Click and drag on the curve, pulling it towards the left. This will make it
                ease-out, that is to say, transition fast initially and slow down as the time
                cursor reaches the next keyframe.</paragraph>
            <paragraph><image alt="image17" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/17.ease_out.webp'}" original_uri="img/09.adding_animations/17.ease_out.webp" uri="getting_started/first_3d_game/img/09.adding_animations/17.ease_out.webp"></image></paragraph>
            <paragraph>Play the animation again to see the difference. The first half should already
                feel a bit bouncier.</paragraph>
            <paragraph>Apply an ease-out to the second keyframe in the rotation track.</paragraph>
            <paragraph><image alt="image18" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/18.ease_out_second_rotation_key.webp'}" original_uri="img/09.adding_animations/18.ease_out_second_rotation_key.webp" uri="getting_started/first_3d_game/img/09.adding_animations/18.ease_out_second_rotation_key.webp"></image></paragraph>
            <paragraph>Do the opposite for the second position keyframe, dragging it to the right.</paragraph>
            <paragraph><image alt="image19" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/19.ease_in_second_translation_key.webp'}" original_uri="img/09.adding_animations/19.ease_in_second_translation_key.webp" uri="getting_started/first_3d_game/img/09.adding_animations/19.ease_in_second_translation_key.webp"></image></paragraph>
            <paragraph>Your animation should look something like this.</paragraph>
            <paragraph><image alt="image20" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/20.float_animation.gif'}" original_uri="img/09.adding_animations/20.float_animation.gif" uri="getting_started/first_3d_game/img/09.adding_animations/20.float_animation.gif"></image></paragraph>
            <note>
                <paragraph>Animations update the properties of the animated nodes every frame,
                    overriding initial values. If we directly animated the <emphasis>Player</emphasis> node, it
                    would prevent us from moving it in code. This is where the <emphasis>Pivot</emphasis> node
                    comes in handy: even though we animated the <emphasis>Character</emphasis>, we can still move
                    and rotate the <emphasis>Pivot</emphasis> and layer changes on top of the animation in a
                    script.</paragraph>
            </note>
            <paragraph>If you play the game, the player's creature will now float!</paragraph>
            <paragraph>If the creature is a little too close to the floor, you can move the <literal>Pivot</literal> up
                to offset it.</paragraph>
            <section ids="controlling-the-animation-in-code" names="controlling\ the\ animation\ in\ code">
                <title>Controlling the animation in code</title>
                <paragraph>We can use code to control the animation playback based on the player's input.
                    Let's change the animation speed when the character is moving.</paragraph>
                <paragraph>Open the <literal>Player</literal>'s script by clicking the script icon next to it.</paragraph>
                <paragraph><image alt="image21" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/21.script_icon.webp'}" original_uri="img/09.adding_animations/21.script_icon.webp" uri="getting_started/first_3d_game/img/09.adding_animations/21.script_icon.webp"></image></paragraph>
                <paragraph>In <literal>_physics_process()</literal>, after the line where we check the <literal>direction</literal>
                    vector, add the following code.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _physics_process(delta):
    #...
    if direction != Vector3.ZERO:
        #...
        $AnimationPlayer.speed_scale = 4
    else:
        $AnimationPlayer.speed_scale = 1</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _PhysicsProcess(double delta)
{
    // ...
    if (direction != Vector3.Zero)
    {
        // ...
        GetNode&lt;AnimationPlayer&gt;("AnimationPlayer").SpeedScale = 4;
    }
    else
    {
        GetNode&lt;AnimationPlayer&gt;("AnimationPlayer").SpeedScale = 1;
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>This code makes it so when the player moves, we multiply the playback speed by
                    <literal>4</literal>. When they stop, we reset it to normal.</paragraph>
                <paragraph>We mentioned that the <literal>Pivot</literal> could layer transforms on top of the animation. We
                    can make the character arc when jumping using the following line of code. Add it
                    at the end of <literal>_physics_process()</literal>.</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _physics_process(delta):
    #...
    $Pivot.rotation.x = PI / 6 * velocity.y / jump_impulse</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _PhysicsProcess(double delta)
{
    // ...
    var pivot = GetNode&lt;Node3D&gt;("Pivot");
    pivot.Rotation = new Vector3(Mathf.Pi / 6.0f * Velocity.Y / JumpImpulse, pivot.Rotation.Y, pivot.Rotation.Z);
}</literal_block>
                    </div>
                </container>
            </section>
        </section>
        <section ids="animating-the-mobs" names="animating\ the\ mobs">
            <title>Animating the mobs</title>
            <paragraph>Here's another nice trick with animations in Godot: as long as you use a similar
                node structure, you can copy them to different scenes.</paragraph>
            <paragraph>For example, both the <literal>Mob</literal> and the <literal>Player</literal> scenes have a <literal>Pivot</literal> and a
                <literal>Character</literal> node, so we can reuse animations between them.</paragraph>
            <paragraph>Open the <emphasis>Player</emphasis> scene, select the AnimationPlayer node and then click on
                <strong>Animation &gt; Manage Animations...</strong>. Click the <emphasis>Copy animation to clipboard</emphasis> button
                (two small squares) alongside the <emphasis>float</emphasis> animation. Click OK to close the window.</paragraph>
            <paragraph>Then open <literal>mob.tscn</literal>, create an <reference internal="True" refuri="../../classes/class_animationplayer#class-animationplayer"><inline classes="std std-ref">AnimationPlayer</inline></reference> child
                node and select it. Click <strong>Animation &gt; Manage Animations</strong>, then <strong>New Library</strong>. You
                should see the message "Global library will be created." Leave the text field blank and
                click OK. Click the <emphasis>Paste</emphasis> icon (clipboard) and it should appear in the window. Click OK
                to close the window.</paragraph>
            <paragraph>Next, make sure that the autoplay button (<image alt="Autoplay" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/autoplay_button.webp'}" original_uri="img/09.adding_animations/autoplay_button.webp" uri="getting_started/first_3d_game/img/09.adding_animations/autoplay_button.webp"></image>) and the looping
                arrows (Animation looping) are also turned on in the animation editor in the bottom panel.
                That's it; all monsters will now play the float animation.</paragraph>
            <paragraph>We can change the playback speed based on the creature's <literal>random_speed</literal>. Open
                the <emphasis>Mob</emphasis>'s script and at the end of the <literal>initialize()</literal> function, add the following line.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func initialize(start_position, player_position):
    #...
    $AnimationPlayer.speed_scale = random_speed / min_speed</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void Initialize(Vector3 startPosition, Vector3 playerPosition)
{
    // ...
    GetNode&lt;AnimationPlayer&gt;("AnimationPlayer").SpeedScale = randomSpeed / MinSpeed;
}</literal_block>
                </div>
            </container>
            <paragraph>And with that, you finished coding your first complete 3D game.</paragraph>
            <paragraph><strong>Congratulations</strong>!</paragraph>
            <paragraph>In the next part, we'll quickly recap what you learned and give you some links
                to keep learning more. But for now, here are the complete <literal>player.gd</literal> and
                <literal>mob.gd</literal> so you can check your code against them.</paragraph>
            <paragraph>Here's the <emphasis>Player</emphasis> script.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

signal hit

# How fast the player moves in meters per second.
@export var speed = 14
# The downward acceleration while in the air, in meters per second squared.
@export var fall_acceleration = 75
# Vertical impulse applied to the character upon jumping in meters per second.
@export var jump_impulse = 20
# Vertical impulse applied to the character upon bouncing over a mob
# in meters per second.
@export var bounce_impulse = 16

var target_velocity = Vector3.ZERO


func _physics_process(delta):
    # We create a local variable to store the input direction
    var direction = Vector3.ZERO

    # We check for each move input and update the direction accordingly
    if Input.is_action_pressed("move_right"):
        direction.x = direction.x + 1
    if Input.is_action_pressed("move_left"):
        direction.x = direction.x - 1
    if Input.is_action_pressed("move_back"):
        # Notice how we are working with the vector's x and z axes.
        # In 3D, the XZ plane is the ground plane.
        direction.z = direction.z + 1
    if Input.is_action_pressed("move_forward"):
        direction.z = direction.z - 1

    # Prevent diagonal movement being very fast
    if direction != Vector3.ZERO:
        direction = direction.normalized()
        # Setting the basis property will affect the rotation of the node.
        $Pivot.basis = Basis.looking_at(direction)
        $AnimationPlayer.speed_scale = 4
    else:
        $AnimationPlayer.speed_scale = 1

    # Ground Velocity
    target_velocity.x = direction.x * speed
    target_velocity.z = direction.z * speed

    # Vertical Velocity
    if not is_on_floor(): # If in the air, fall towards the floor
        target_velocity.y = target_velocity.y - (fall_acceleration * delta)

    # Jumping.
    if is_on_floor() and Input.is_action_just_pressed("jump"):
        target_velocity.y = jump_impulse

    # Iterate through all collisions that occurred this frame
    # in C this would be for(int i = 0; i &lt; collisions.Count; i++)
    for index in range(get_slide_collision_count()):
        # We get one of the collisions with the player
        var collision = get_slide_collision(index)

        # If the collision is with ground
        if collision.get_collider() == null:
            continue

        # If the collider is with a mob
        if collision.get_collider().is_in_group("mob"):
            var mob = collision.get_collider()
            # we check that we are hitting it from above.
            if Vector3.UP.dot(collision.get_normal()) &gt; 0.1:
                # If so, we squash it and bounce.
                mob.squash()
                target_velocity.y = bounce_impulse
                # Prevent further duplicate calls.
                break

    # Moving the Character
    velocity = target_velocity
    move_and_slide()

    $Pivot.rotation.x = PI / 6 * velocity.y / jump_impulse

# And this function at the bottom.
func die():
    hit.emit()
    queue_free()

func _on_mob_detector_body_entered(body):
    die()</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Player : CharacterBody3D
{
    // Emitted when the player was hit by a mob.
    [Signal]
    public delegate void HitEventHandler();

    // How fast the player moves in meters per second.
    [Export]
    public int Speed { get; set; } = 14;
    // The downward acceleration when in the air, in meters per second squared.
    [Export]
    public int FallAcceleration { get; set; } = 75;
    // Vertical impulse applied to the character upon jumping in meters per second.
    [Export]
    public int JumpImpulse { get; set; } = 20;
    // Vertical impulse applied to the character upon bouncing over a mob in meters per second.
    [Export]
    public int BounceImpulse { get; set; } = 16;

    private Vector3 _targetVelocity = Vector3.Zero;

    public override void _PhysicsProcess(double delta)
    {
        // We create a local variable to store the input direction.
        var direction = Vector3.Zero;

        // We check for each move input and update the direction accordingly.
        if (Input.IsActionPressed("move_right"))
        {
            direction.X += 1.0f;
        }
        if (Input.IsActionPressed("move_left"))
        {
            direction.X -= 1.0f;
        }
        if (Input.IsActionPressed("move_back"))
        {
            // Notice how we are working with the vector's X and Z axes.
            // In 3D, the XZ plane is the ground plane.
            direction.Z += 1.0f;
        }
        if (Input.IsActionPressed("move_forward"))
        {
            direction.Z -= 1.0f;
        }

        // Prevent diagonal movement being very fast.
        if (direction != Vector3.Zero)
        {
            direction = direction.Normalized();
            // Setting the basis property will affect the rotation of the node.
            GetNode&lt;Node3D&gt;("Pivot").Basis = Basis.LookingAt(direction);
            GetNode&lt;AnimationPlayer&gt;("AnimationPlayer").SpeedScale = 4;
        }
        else
        {
            GetNode&lt;AnimationPlayer&gt;("AnimationPlayer").SpeedScale = 1;
        }

        // Ground velocity
        _targetVelocity.X = direction.X * Speed;
        _targetVelocity.Z = direction.Z * Speed;

        // Vertical velocity
        if (!IsOnFloor())
        {
            _targetVelocity.Y -= FallAcceleration * (float)delta;
        }

        // Jumping.
        if (IsOnFloor() &amp;&amp; Input.IsActionJustPressed("jump"))
        {
            _targetVelocity.Y += JumpImpulse;
        }

        // Iterate through all collisions that occurred this frame.
        for (int index = 0; index &lt; GetSlideCollisionCount(); index++)
        {
            // We get one of the collisions with the player.
            KinematicCollision3D collision = GetSlideCollision(index);

            // If the collision is with a mob.
            if (collision.GetCollider() is Mob mob)
            {
                // We check that we are hitting it from above.
                if (Vector3.Up.Dot(collision.GetNormal()) &gt; 0.1f)
                {
                    // If so, we squash it and bounce.
                    mob.Squash();
                    _targetVelocity.Y = BounceImpulse;
                    // Prevent further duplicate calls.
                    break;
                }
            }
        }

        // Moving the character
        Velocity = _targetVelocity;
        MoveAndSlide();

        var pivot = GetNode&lt;Node3D&gt;("Pivot");
        pivot.Rotation = new Vector3(Mathf.Pi / 6.0f * Velocity.Y / JumpImpulse, pivot.Rotation.Y, pivot.Rotation.Z);
    }

    private void Die()
    {
        EmitSignal(SignalName.Hit);
        QueueFree();
    }

    private void OnMobDetectorBodyEntered(Node body)
    {
        Die();
    }
}</literal_block>
                </div>
            </container>
            <paragraph>And the <emphasis>Mob</emphasis>'s script.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

# Minimum speed of the mob in meters per second.
@export var min_speed = 10
# Maximum speed of the mob in meters per second.
@export var max_speed = 18

# Emitted when the player jumped on the mob
signal squashed

func _physics_process(_delta):
    move_and_slide()

# This function will be called from the Main scene.
func initialize(start_position, player_position):
    # We position the mob by placing it at start_position
    # and rotate it towards player_position, so it looks at the player.
    look_at_from_position(start_position, player_position, Vector3.UP)
    # Rotate this mob randomly within range of -45 and +45 degrees,
    # so that it doesn't move directly towards the player.
    rotate_y(randf_range(-PI / 4, PI / 4))

    # We calculate a random speed (integer)
    var random_speed = randi_range(min_speed, max_speed)
    # We calculate a forward velocity that represents the speed.
    velocity = Vector3.FORWARD * random_speed
    # We then rotate the velocity vector based on the mob's Y rotation
    # in order to move in the direction the mob is looking.
    velocity = velocity.rotated(Vector3.UP, rotation.y)

    $AnimationPlayer.speed_scale = random_speed / min_speed

func _on_visible_on_screen_notifier_3d_screen_exited():
    queue_free()

func squash():
    squashed.emit()
    queue_free() # Destroy this node</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Mob : CharacterBody3D
{
    // Emitted when the played jumped on the mob.
    [Signal]
    public delegate void SquashedEventHandler();

    // Minimum speed of the mob in meters per second
    [Export]
    public int MinSpeed { get; set; } = 10;
    // Maximum speed of the mob in meters per second
    [Export]
    public int MaxSpeed { get; set; } = 18;

    public override void _PhysicsProcess(double delta)
    {
        MoveAndSlide();
    }

    // This function will be called from the Main scene.
    public void Initialize(Vector3 startPosition, Vector3 playerPosition)
    {
        // We position the mob by placing it at startPosition
        // and rotate it towards playerPosition, so it looks at the player.
        LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
        // Rotate this mob randomly within range of -45 and +45 degrees,
        // so that it doesn't move directly towards the player.
        RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));

        // We calculate a random speed (integer).
        int randomSpeed = GD.RandRange(MinSpeed, MaxSpeed);
        // We calculate a forward velocity that represents the speed.
        Velocity = Vector3.Forward * randomSpeed;
        // We then rotate the velocity vector based on the mob's Y rotation
        // in order to move in the direction the mob is looking.
        Velocity = Velocity.Rotated(Vector3.Up, Rotation.Y);

        GetNode&lt;AnimationPlayer&gt;("AnimationPlayer").SpeedScale = randomSpeed / MinSpeed;
    }

    public void Squash()
    {
        EmitSignal(SignalName.Squashed);
        QueueFree(); // Destroy this node
    }

    private void OnVisibilityNotifierScreenExited()
    {
        QueueFree();
    }
}</literal_block>
                </div>
            </container>
            <substitution_definition names="image0"><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/squash-the-creeps-final.gif'}" original_uri="img/squash-the-creeps-final.gif" uri="getting_started/first_3d_game/img/squash-the-creeps-final.gif"></image></substitution_definition>
            <substitution_definition names="image1"><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/animation_player_dock.webp'}" original_uri="img/09.adding_animations/animation_player_dock.webp" uri="getting_started/first_3d_game/img/09.adding_animations/animation_player_dock.webp"></image></substitution_definition>
            <substitution_definition names="image2"><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/02.new_animation.webp'}" original_uri="img/09.adding_animations/02.new_animation.webp" uri="getting_started/first_3d_game/img/09.adding_animations/02.new_animation.webp"></image></substitution_definition>
            <substitution_definition names="image3"><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/03.float_name.webp'}" original_uri="img/09.adding_animations/03.float_name.webp" uri="getting_started/first_3d_game/img/09.adding_animations/03.float_name.webp"></image></substitution_definition>
            <substitution_definition names="image4"><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/03.timeline.webp'}" original_uri="img/09.adding_animations/03.timeline.webp" uri="getting_started/first_3d_game/img/09.adding_animations/03.timeline.webp"></image></substitution_definition>
            <substitution_definition names="image5"><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/04.autoplay_and_loop.webp'}" original_uri="img/09.adding_animations/04.autoplay_and_loop.webp" uri="getting_started/first_3d_game/img/09.adding_animations/04.autoplay_and_loop.webp"></image></substitution_definition>
            <substitution_definition names="image6"><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/05.pin_icon.webp'}" original_uri="img/09.adding_animations/05.pin_icon.webp" uri="getting_started/first_3d_game/img/09.adding_animations/05.pin_icon.webp"></image></substitution_definition>
            <substitution_definition names="image7"><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/06.animation_duration.webp'}" original_uri="img/09.adding_animations/06.animation_duration.webp" uri="getting_started/first_3d_game/img/09.adding_animations/06.animation_duration.webp"></image></substitution_definition>
            <substitution_definition names="image8"><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/08.zoom_slider.webp'}" original_uri="img/09.adding_animations/08.zoom_slider.webp" uri="getting_started/first_3d_game/img/09.adding_animations/08.zoom_slider.webp"></image></substitution_definition>
            <substitution_definition names="image9"><image alt="image9" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/09.creating_first_keyframe.webp'}" original_uri="img/09.adding_animations/09.creating_first_keyframe.webp" uri="getting_started/first_3d_game/img/09.adding_animations/09.creating_first_keyframe.webp"></image></substitution_definition>
            <substitution_definition names="image10"><image alt="image10" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/10.initial_keys.webp'}" original_uri="img/09.adding_animations/10.initial_keys.webp" uri="getting_started/first_3d_game/img/09.adding_animations/10.initial_keys.webp"></image></substitution_definition>
            <substitution_definition names="image11"><image alt="image11" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/11.moving_keys.webp'}" original_uri="img/09.adding_animations/11.moving_keys.webp" uri="getting_started/first_3d_game/img/09.adding_animations/11.moving_keys.webp"></image></substitution_definition>
            <substitution_definition names="image12"><image alt="image12" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/12.second_keys_values.webp'}" original_uri="img/09.adding_animations/12.second_keys_values.webp" uri="getting_started/first_3d_game/img/09.adding_animations/12.second_keys_values.webp"></image></substitution_definition>
            <substitution_definition names="image13"><image alt="image13" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/13.second_keys.webp'}" original_uri="img/09.adding_animations/13.second_keys.webp" uri="getting_started/first_3d_game/img/09.adding_animations/13.second_keys.webp"></image></substitution_definition>
            <substitution_definition names="image14"><image alt="image14" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/14.play_button.webp'}" original_uri="img/09.adding_animations/14.play_button.webp" uri="getting_started/first_3d_game/img/09.adding_animations/14.play_button.webp"></image></substitution_definition>
            <substitution_definition names="image15"><image alt="image15" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/15.box_select.webp'}" original_uri="img/09.adding_animations/15.box_select.webp" uri="getting_started/first_3d_game/img/09.adding_animations/15.box_select.webp"></image></substitution_definition>
            <substitution_definition names="image16"><image alt="image16" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/16.easing_property.webp'}" original_uri="img/09.adding_animations/16.easing_property.webp" uri="getting_started/first_3d_game/img/09.adding_animations/16.easing_property.webp"></image></substitution_definition>
            <substitution_definition names="image17"><image alt="image17" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/17.ease_out.webp'}" original_uri="img/09.adding_animations/17.ease_out.webp" uri="getting_started/first_3d_game/img/09.adding_animations/17.ease_out.webp"></image></substitution_definition>
            <substitution_definition names="image18"><image alt="image18" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/18.ease_out_second_rotation_key.webp'}" original_uri="img/09.adding_animations/18.ease_out_second_rotation_key.webp" uri="getting_started/first_3d_game/img/09.adding_animations/18.ease_out_second_rotation_key.webp"></image></substitution_definition>
            <substitution_definition names="image19"><image alt="image19" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/19.ease_in_second_translation_key.webp'}" original_uri="img/09.adding_animations/19.ease_in_second_translation_key.webp" uri="getting_started/first_3d_game/img/09.adding_animations/19.ease_in_second_translation_key.webp"></image></substitution_definition>
            <substitution_definition names="image20"><image alt="image20" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/20.float_animation.gif'}" original_uri="img/09.adding_animations/20.float_animation.gif" uri="getting_started/first_3d_game/img/09.adding_animations/20.float_animation.gif"></image></substitution_definition>
            <substitution_definition names="image21"><image alt="image21" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/21.script_icon.webp'}" original_uri="img/09.adding_animations/21.script_icon.webp" uri="getting_started/first_3d_game/img/09.adding_animations/21.script_icon.webp"></image></substitution_definition>
            <substitution_definition names="animation_final_keyframes"><image alt="animation_final_keyframes" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/animation_final_keyframes.webp'}" original_uri="img/09.adding_animations/animation_final_keyframes.webp" uri="getting_started/first_3d_game/img/09.adding_animations/animation_final_keyframes.webp"></image></substitution_definition>
            <substitution_definition names="second_keys_both"><image alt="second_keys_both" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/second_keys_both.webp'}" original_uri="img/09.adding_animations/second_keys_both.webp" uri="getting_started/first_3d_game/img/09.adding_animations/second_keys_both.webp"></image></substitution_definition>
            <substitution_definition names="timeline_05_click"><image alt="timeline_05_click" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/timeline_05_click.webp'}" original_uri="img/09.adding_animations/timeline_05_click.webp" uri="getting_started/first_3d_game/img/09.adding_animations/timeline_05_click.webp"></image></substitution_definition>
            <substitution_definition names="Autoplay"><image alt="Autoplay" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/autoplay_button.webp'}" original_uri="img/09.adding_animations/autoplay_button.webp" uri="getting_started/first_3d_game/img/09.adding_animations/autoplay_button.webp"></image></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
