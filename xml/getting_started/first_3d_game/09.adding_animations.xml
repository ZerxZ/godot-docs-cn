<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/first_3d_game/09.adding_animations.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-first-3d-game-character-animation"></target>
    <section ids="character-animation doc-first-3d-game-character-animation" names="character\ animation 角色动画 doc_first_3d_game_character_animation">
        <title>角色动画</title>
        <paragraph>这是最后一课，我们会使用 Godot 的内置动画工具制作角色的浮动和拍打动画。你会学到如何在编辑器中设计动画，以及如何使用代码让游戏变得活灵活现。</paragraph>
        <paragraph><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/squash-the-creeps-final.gif'}" uri="getting_started/first_3d_game/img/squash-the-creeps-final.gif"></image></paragraph>
        <paragraph>我们将会开始介绍动画编辑器的使用。</paragraph>
        <section ids="using-the-animation-editor" names="using\ the\ animation\ editor 动画编辑器的使用">
            <title>动画编辑器的使用</title>
            <paragraph>该引擎自带的工具可以在编辑器中编写动画。然后你可以在运行时使用代码来播放和控制它们。</paragraph>
            <paragraph>打开玩家场景，选中 <literal>Player</literal> 节点，然后添加一个 <reference internal="True" refuri="../../classes/class_animationplayer#class-animationplayer"><inline classes="std std-ref">AnimationPlayer</inline></reference> 节点。</paragraph>
            <paragraph><emphasis>动画</emphasis>停靠面板就会出现在底部面板中。</paragraph>
            <paragraph><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/animation_player_dock.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/animation_player_dock.webp"></image></paragraph>
            <paragraph>它的特点是顶部有一个工具栏和动画下拉菜单，中间有一个轨道编辑器，目前是空的，底部有过滤、捕捉和缩放选项。</paragraph>
            <paragraph>让我们来创建一个动画。请点击<emphasis>动画 -&gt; 新建</emphasis>。</paragraph>
            <paragraph><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/02.new_animation.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/02.new_animation.webp"></image></paragraph>
            <paragraph>将动画命名为“float”（漂浮）。</paragraph>
            <paragraph><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/03.float_name.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/03.float_name.png"></image></paragraph>
            <paragraph>创建动画后，将显示时间轴，其中数字表示以秒为单位的时间。</paragraph>
            <paragraph><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/03.timeline.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/03.timeline.png"></image></paragraph>
            <paragraph>我们希望让这个动画在游戏开始时自动开始播放，而且还应该循环播放。</paragraph>
            <paragraph>要实现这个需求，可以单击动画工具栏上对应的“A+”图标和循环箭头。</paragraph>
            <paragraph><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/04.autoplay_and_loop.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/04.autoplay_and_loop.png"></image></paragraph>
            <paragraph>你还可以单击右上角的图钉图标，将动画编辑器进行固定。这样它就不会在你点击视口取消选择节点时折叠。</paragraph>
            <paragraph><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/05.pin_icon.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/05.pin_icon.png"></image></paragraph>
            <paragraph>在面板右上角将动画的时长设为 <literal>1.2</literal> 秒。</paragraph>
            <paragraph><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/06.animation_duration.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/06.animation_duration.webp"></image></paragraph>
            <paragraph>你应该看到灰色带子变宽了一点。它显示动画的开始和结束，垂直蓝线是你的时间光标。</paragraph>
            <paragraph><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/07.editable_timeline.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/07.editable_timeline.webp"></image></paragraph>
            <paragraph>单击并拖拽右下角的滑动条，即可将时间线进行缩放。</paragraph>
            <paragraph><image alt="image9" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/08.zoom_slider.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/08.zoom_slider.webp"></image></paragraph>
        </section>
        <section ids="the-float-animation" names="the\ float\ animation 漂浮动画">
            <title>漂浮动画</title>
            <paragraph>使用动画播放器节点，你可以对所需任意数量的节点的大多数属性做动画。请注意<emphasis>检查器</emphasis>中属性旁的钥匙图标。在上面单击就可以创建一个关键帧，即对应属性的一对时间与值。关键帧会被插入到时间线上的时间光标处。</paragraph>
            <paragraph>让我们来开始插入帧吧。这里，我们要为 <literal>Character</literal> 节点的位置（position）和旋转（rotation）做动画。</paragraph>
            <paragraph>选中 <literal>Character</literal> 并在<emphasis>检查器</emphasis>中展开 <emphasis>Transform</emphasis> 栏。单击 <emphasis>Position</emphasis> 和 <emphasis>Rotation</emphasis> 旁的钥匙图标。</paragraph>
            <paragraph><image alt="image10" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/09.creating_first_keyframe.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/09.creating_first_keyframe.webp"></image></paragraph>
            <image candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/curves.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/curves.webp"></image>
            <paragraph>对于本教程，我们只创建默认选择 RESET（重置）轨道</paragraph>
            <paragraph>编辑器中会出现两个轨道，各有一个代表关键帧的菱形图标。</paragraph>
            <paragraph><image alt="image11" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/10.initial_keys.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/10.initial_keys.webp"></image></paragraph>
            <paragraph>你可以在菱形滑块上单击并拖动，以移动它们的时间。将位置（position ）帧移动到 <literal>0.3</literal> 秒处，将旋转（rotation ）帧移动到 <literal>0.1</literal> 秒处。</paragraph>
            <paragraph><image alt="image12" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/11.moving_keys.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/11.moving_keys.webp"></image></paragraph>
            <paragraph>在灰色的时间线上单击并拖拽，将时间光标移动至 <literal>0.5</literal> 秒位置。</paragraph>
            <image candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/timeline_05_click.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/timeline_05_click.webp"></image>
            <paragraph>在 <emphasis>检查器</emphasis> 中，将 <emphasis>Position</emphasis> 的 <emphasis>Y</emphasis> 轴设置为 <literal>0.65</literal> 米，将 <emphasis>Rotation</emphasis> 的 <emphasis>X</emphasis> 轴设置为 <literal>8</literal> 。</paragraph>
            <paragraph><image alt="image13" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/12.second_keys_values.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/12.second_keys_values.webp"></image></paragraph>
            <paragraph>为这两个属性分别创建一个关键帧</paragraph>
            <image candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/second_keys_both.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/second_keys_both.webp"></image>
            <paragraph>现在开始在时间线上拖动，将位置（position）的关键帧移动到 <literal>0.7</literal> 秒。</paragraph>
            <paragraph><image alt="image14" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/13.second_keys.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/13.second_keys.webp"></image></paragraph>
            <note>
                <paragraph>关于动画原理的讲解已经超出了本教程的范围。请注意，你不想均匀地分配时间和空间。取而代之的是，动画师使用时间和间隔，这两个核心动画原则。你希望让它们存在一定的偏移，在角色的运动中产生对比，以使他们感觉生动。</paragraph>
            </note>
            <paragraph>将时间光标移动到动画结尾，即 <literal>1.2</literal> 秒。将 Y 平移量设为约 <literal>0.35</literal>、X 旋转量设为 <literal>-9</literal> 度。再次为这两个属性添加帧。</paragraph>
            <image candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/animation_final_keyframes.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/animation_final_keyframes.webp"></image>
            <paragraph>单击播放按钮或者按 <literal classes="kbd">Shift + D</literal> 即可预览结果。单击停止按钮或者按 <literal classes="kbd">S</literal> 即可停止播放。</paragraph>
            <paragraph><image alt="image15" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/14.play_button.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/14.play_button.png"></image></paragraph>
            <paragraph>你可以看到引擎在关键帧之间插值以生成连续动画。不过目前，这个动作感觉非常机器人化。这是因为默认插值是线性的，导致持续的过渡，这与现实世界中生物的移动方式不同。</paragraph>
            <paragraph>我们可以使用缓动曲线来控制关键帧之间的过渡。</paragraph>
            <paragraph>单击并拖拽，框选时间线上的前两个帧。</paragraph>
            <paragraph><image alt="image16" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/15.box_select.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/15.box_select.webp"></image></paragraph>
            <paragraph>可以在<emphasis>检查器</emphasis>中同时编辑这两个帧的属性，其中就有一个属性叫做 <emphasis>Easing</emphasis>（缓动）。</paragraph>
            <paragraph><image alt="image17" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/16.easing_property.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/16.easing_property.png"></image></paragraph>
            <paragraph>单击并拖动曲线，把它往左拉。这样就会让他实现缓出，也就是说，一开始变得快，然后时间光标越接近下一个关键帧就变得越慢。</paragraph>
            <paragraph><image alt="image18" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/17.ease_out.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/17.ease_out.png"></image></paragraph>
            <paragraph>再次播放动画以查看差异。前半部分应该已经感觉有点弹性了。</paragraph>
            <paragraph>将缓动效果应用于旋转轨迹中的第二个关键帧。</paragraph>
            <paragraph><image alt="image19" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/18.ease_out_second_rotation_key.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/18.ease_out_second_rotation_key.png"></image></paragraph>
            <paragraph>对第二个平移关键帧执行相反操作，将其拖动到右侧。</paragraph>
            <paragraph><image alt="image20" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/19.ease_in_second_translation_key.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/19.ease_in_second_translation_key.png"></image></paragraph>
            <paragraph>你的动画应该类似这样。</paragraph>
            <paragraph><image alt="image21" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/20.float_animation.gif'}" uri="getting_started/first_3d_game/img/09.adding_animations/20.float_animation.gif"></image></paragraph>
            <note>
                <paragraph>每一帧，动画都会去更新被动画的节点的属性，覆盖掉初始值。如果我们直接对 <emphasis>Player</emphasis> 节点做动画，就没法使用代码来移动它了。这就是 <emphasis>Pivot</emphasis> 节点的用处：尽管我们为 <emphasis>Character</emphasis> 做了动画，我们还是可以在此动画之上，再通过代码来移动并旋转 <emphasis>Pivot</emphasis>。</paragraph>
            </note>
            <paragraph>如果你运行游戏，玩家的生物就会漂浮起来！</paragraph>
            <paragraph>如果这个生物离地面太近了，你可以将 <literal>Pivot</literal> 向上移动，达成偏移的目的。</paragraph>
            <section ids="controlling-the-animation-in-code" names="controlling\ the\ animation\ in\ code 使用代码控制动画">
                <title>使用代码控制动画</title>
                <paragraph>我们可以使用代码来根据玩家的输入控制动画的播放。让我们在角色移动时修改动画的速度吧。</paragraph>
                <paragraph>点击 <literal>Player</literal> 旁的脚本图标打开其脚本。</paragraph>
                <paragraph><image alt="image22" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/21.script_icon.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/21.script_icon.png"></image></paragraph>
                <paragraph>在 <literal>_physics_process()</literal> 中检查 <literal>direction</literal> 向量的那一行之后添加如下代码。</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _physics_process(delta):
    #...
    if direction != Vector3.ZERO:
        #...
        $AnimationPlayer.speed_scale = 4
    else:
        $AnimationPlayer.speed_scale = 1</literal_block>
                    </div>
                    <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _PhysicsProcess(double delta)
{
    // ...
    if (direction != Vector3.Zero)
    {
        // ...
        GetNode&lt;AnimationPlayer&gt;("AnimationPlayer").SpeedScale = 4;
    }
    else
    {
        GetNode&lt;AnimationPlayer&gt;("AnimationPlayer").SpeedScale = 1;
    }
}</literal_block>
                    </div>
                </container>
                <paragraph>这段代码的作用是让玩家在移动时将播放速度乘以 <literal>4</literal>。在停止移动时将其恢复原状。</paragraph>
                <paragraph>我们提到 Pivot（轴心）可以在动画之上叠加变换。我们可以用下面这行代码使角色在跳跃时产生弧线。把它加在 <literal>_physics_process()</literal> 的最后。</paragraph>
                <container classes="sphinx-tabs" type="tab-element">
                    <div aria-label="Tabbed content" role="tablist">
                        <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                        <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                    </div>
                    <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _physics_process(delta):
    #...
    $Pivot.rotation.x = PI / 6 * velocity.y / jump_impulse</literal_block>
                    </div>
                    <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                        <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _PhysicsProcess(double delta)
{
    // ...
    var pivot = GetNode&lt;Node3D&gt;("Pivot");
    pivot.Rotation = new Vector3(Mathf.Pi / 6.0f * Velocity.Y / JumpImpulse, pivot.Rotation.Y, pivot.Rotation.Z);
}</literal_block>
                    </div>
                </container>
            </section>
        </section>
        <section ids="animating-the-mobs" names="animating\ the\ mobs 为小怪制作动画">
            <title>为小怪制作动画</title>
            <paragraph>在 Godot 中还有一个很好的动画技巧：只要你使用类似的节点结构，你就可以把它们复制到不同的场景中。</paragraph>
            <paragraph>例如，<literal>Mob</literal> 和 <literal>Player</literal> 场景都有 <literal>Pivot</literal> 和 <literal>Character</literal> 节点，所以我们可以在它们之间复用动画。</paragraph>
            <paragraph>打开 <emphasis>Player</emphasis> 场景，选中动画播放器节点，打开“float”（漂浮）动画。然后点击<strong>动画 -&gt; 复制</strong>。然后打开 <literal>mob.tscn</literal> ，创建一个 AnimationPlayer 子节点并选择它。点击<strong>动画 -&gt; 粘贴</strong>，并确保底部面板的动画编辑器中带有“A+”图标的按钮（加载时自动播放）和循环箭头（动画循环）也已打开。这样就行了；所有的怪物现在就都能播放浮动动画了。</paragraph>
            <paragraph>我们可以根据生物的 <literal>random_speed</literal> 来更改播放速度。打开 <emphasis>Mob</emphasis> 的脚本，在 <literal>initialize()</literal> 函数的末尾添加下面这行代码。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func initialize(start_position, player_position):
    #...
    $AnimationPlayer.speed_scale = random_speed / min_speed</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void Initialize(Vector3 startPosition, Vector3 playerPosition)
{
    // ...
    GetNode&lt;AnimationPlayer&gt;("AnimationPlayer").SpeedScale = randomSpeed / MinSpeed;
}</literal_block>
                </div>
            </container>
            <paragraph>这样，你就完成了你第一个完整 3D 游戏的编码。</paragraph>
            <paragraph><strong>恭喜</strong>！</paragraph>
            <paragraph>在下一部分，我们将快速复习已学到的内容，并为你提供一些继续学习的链接。不过现在，这里是完整的 <literal>Player.gd</literal> 和 <literal>Mob.gd</literal>，你可以用它们来校对你的代码。</paragraph>
            <paragraph>这是 <emphasis>Player</emphasis> 脚本。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

signal hit

# How fast the player moves in meters per second.
@export var speed = 14
# The downward acceleration while in the air, in meters per second squared.
@export var fall_acceleration = 75
# Vertical impulse applied to the character upon jumping in meters per second.
@export var jump_impulse = 20
# Vertical impulse applied to the character upon bouncing over a mob
# in meters per second.
@export var bounce_impulse = 16

var target_velocity = Vector3.ZERO


func _physics_process(delta):
    # We create a local variable to store the input direction
    var direction = Vector3.ZERO

    # We check for each move input and update the direction accordingly
    if Input.is_action_pressed("move_right"):
        direction.x = direction.x + 1
    if Input.is_action_pressed("move_left"):
        direction.x = direction.x - 1
    if Input.is_action_pressed("move_back"):
        # Notice how we are working with the vector's x and z axes.
        # In 3D, the XZ plane is the ground plane.
        direction.z = direction.z + 1
    if Input.is_action_pressed("move_forward"):
        direction.z = direction.z - 1

    # Prevent diagonal movement being very fast
    if direction != Vector3.ZERO:
        direction = direction.normalized()
        $Pivot.look_at(position + direction,Vector3.UP)
        $AnimationPlayer.speed_scale = 4
    else:
        $AnimationPlayer.speed_scale = 1

    # Ground Velocity
    target_velocity.x = direction.x * speed
    target_velocity.z = direction.z * speed

    # Vertical Velocity
    if not is_on_floor(): # If in the air, fall towards the floor
        target_velocity.y = target_velocity.y - (fall_acceleration * delta)

    # Jumping.
    if is_on_floor() and Input.is_action_just_pressed("jump"):
        target_velocity.y = jump_impulse

    # Iterate through all collisions that occurred this frame
    # in C this would be for(int i = 0; i &lt; collisions.Count; i++)
    for index in range(get_slide_collision_count()):
        # We get one of the collisions with the player
        var collision = get_slide_collision(index)

        # If the collision is with ground
        if collision.get_collider() == null:
            continue

        # If the collider is with a mob
        if collision.get_collider().is_in_group("mob"):
            var mob = collision.get_collider()
            # we check that we are hitting it from above.
            if Vector3.UP.dot(collision.get_normal()) &gt; 0.1:
                # If so, we squash it and bounce.
                mob.squash()
                target_velocity.y = bounce_impulse
                # Prevent further duplicate calls.
                break

    # Moving the Character
    velocity = target_velocity
    move_and_slide()

    $Pivot.rotation.x = PI / 6 * velocity.y / jump_impulse

# And this function at the bottom.
func die():
    hit.emit()
    queue_free()

func _on_mob_detector_body_entered(body):
    die()</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Player : CharacterBody3D
{
    // Emitted when the player was hit by a mob.
    [Signal]
    public delegate void HitEventHandler();

    // How fast the player moves in meters per second.
    [Export]
    public int Speed { get; set; } = 14;
    // The downward acceleration when in the air, in meters per second squared.
    [Export]
    public int FallAcceleration { get; set; } = 75;
    // Vertical impulse applied to the character upon jumping in meters per second.
    [Export]
    public int JumpImpulse { get; set; } = 20;
    // Vertical impulse applied to the character upon bouncing over a mob in meters per second.
    [Export]
    public int BounceImpulse { get; set; } = 16;

    private Vector3 _targetVelocity = Vector3.Zero;

    public override void _PhysicsProcess(double delta)
    {
        // We create a local variable to store the input direction.
        var direction = Vector3.Zero;

        // We check for each move input and update the direction accordingly.
        if (Input.IsActionPressed("move_right"))
        {
            direction.X += 1.0f;
        }
        if (Input.IsActionPressed("move_left"))
        {
            direction.X -= 1.0f;
        }
        if (Input.IsActionPressed("move_back"))
        {
            // Notice how we are working with the vector's X and Z axes.
            // In 3D, the XZ plane is the ground plane.
            direction.Z += 1.0f;
        }
        if (Input.IsActionPressed("move_forward"))
        {
            direction.Z -= 1.0f;
        }

        // Prevent diagonal movement being very fast.
        if (direction != Vector3.Zero)
        {
            direction = direction.Normalized();
            GetNode&lt;Node3D&gt;("Pivot").LookAt(Position + direction, Vector3.Up);
            GetNode&lt;AnimationPlayer&gt;("AnimationPlayer").PlaybackSpeed = 4;
        }
        else
        {
            GetNode&lt;AnimationPlayer&gt;("AnimationPlayer").PlaybackSpeed = 1;
        }

        // Ground velocity
        _targetVelocity.X = direction.X * Speed;
        _targetVelocity.Z = direction.Z * Speed;

        // Vertical velocity
        if (!IsOnFloor())
        {
            _targetVelocity.Y -= FallAcceleration * (float)delta;
        }

        // Jumping.
        if (IsOnFloor() &amp;&amp; Input.IsActionJustPressed("jump"))
        {
            _targetVelocity.Y += JumpImpulse;
        }

        // Iterate through all collisions that occurred this frame.
        for (int index = 0; index &lt; GetSlideCollisionCount(); index++)
        {
            // We get one of the collisions with the player.
            KinematicCollision3D collision = GetSlideCollision(index);

            // If the collision is with a mob.
            if (collision.GetCollider() is Mob mob)
            {
                // We check that we are hitting it from above.
                if (Vector3.Up.Dot(collision.GetNormal()) &gt; 0.1f)
                {
                    // If so, we squash it and bounce.
                    mob.Squash();
                    _targetVelocity.Y = BounceImpulse;
                    // Prevent further duplicate calls.
                    break;
                }
            }
        }

        // Moving the character
        Velocity = _targetVelocity;
        MoveAndSlide();

        var pivot = GetNode&lt;Node3D&gt;("Pivot");
        pivot.Rotation = new Vector3(Mathf.Pi / 6.0f * Velocity.Y / JumpImpulse, pivot.Rotation.Y, pivot.Rotation.Z);
    }

    private void Die()
    {
        EmitSignal(SignalName.Hit);
        QueueFree();
    }

    private void OnMobDetectorBodyEntered(Node body)
    {
        Die();
    }
}</literal_block>
                </div>
            </container>
            <paragraph>这是 <emphasis>Mob</emphasis> 的脚本。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

# Minimum speed of the mob in meters per second.
@export var min_speed = 10
# Maximum speed of the mob in meters per second.
@export var max_speed = 18

# Emitted when the player jumped on the mob
signal squashed

func _physics_process(_delta):
    move_and_slide()

# This function will be called from the Main scene.
func initialize(start_position, player_position):
    # We position the mob by placing it at start_position
    # and rotate it towards player_position, so it looks at the player.
    look_at_from_position(start_position, player_position, Vector3.UP)
    # Rotate this mob randomly within range of -90 and +90 degrees,
    # so that it doesn't move directly towards the player.
    rotate_y(randf_range(-PI / 4, PI / 4))

    # We calculate a random speed (integer)
    var random_speed = randi_range(min_speed, max_speed)
    # We calculate a forward velocity that represents the speed.
    velocity = Vector3.FORWARD * random_speed
    # We then rotate the velocity vector based on the mob's Y rotation
    # in order to move in the direction the mob is looking.
    velocity = velocity.rotated(Vector3.UP, rotation.y)

    $AnimationPlayer.speed_scale = random_speed / min_speed

func _on_visible_on_screen_notifier_3d_screen_exited():
    queue_free()

func squash():
    squashed.emit()
    queue_free() # Destroy this node</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Mob : CharacterBody3D
{
    // Emitted when the played jumped on the mob.
    [Signal]
    public delegate void SquashedEventHandler();

    // Minimum speed of the mob in meters per second
    [Export]
    public int MinSpeed { get; set; } = 10;
    // Maximum speed of the mob in meters per second
    [Export]
    public int MaxSpeed { get; set; } = 18;

    public override void _PhysicsProcess(double delta)
    {
        MoveAndSlide();
    }

    // This function will be called from the Main scene.
    public void Initialize(Vector3 startPosition, Vector3 playerPosition)
    {
        // We position the mob by placing it at startPosition
        // and rotate it towards playerPosition, so it looks at the player.
        LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
        // Rotate this mob randomly within range of -90 and +90 degrees,
        // so that it doesn't move directly towards the player.
        RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));

        // We calculate a random speed (integer).
        int randomSpeed = GD.RandRange(MinSpeed, MaxSpeed);
        // We calculate a forward velocity that represents the speed.
        Velocity = Vector3.Forward * randomSpeed;
        // We then rotate the velocity vector based on the mob's Y rotation
        // in order to move in the direction the mob is looking.
        Velocity = Velocity.Rotated(Vector3.Up, Rotation.Y);

        GetNode&lt;AnimationPlayer&gt;("AnimationPlayer").SpeedScale = randomSpeed / MinSpeed;
    }

    public void Squash()
    {
        EmitSignal(SignalName.Squashed);
        QueueFree(); // Destroy this node
    }

    private void OnVisibilityNotifierScreenExited()
    {
        QueueFree();
    }
}</literal_block>
                </div>
            </container>
            <substitution_definition names="image0"><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/squash-the-creeps-final.gif'}" uri="getting_started/first_3d_game/img/squash-the-creeps-final.gif"></image></substitution_definition>
            <substitution_definition names="image1"><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/animation_player_dock.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/animation_player_dock.webp"></image></substitution_definition>
            <substitution_definition names="image2"><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/02.new_animation.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/02.new_animation.webp"></image></substitution_definition>
            <substitution_definition names="image3"><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/03.float_name.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/03.float_name.png"></image></substitution_definition>
            <substitution_definition names="image4"><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/03.timeline.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/03.timeline.png"></image></substitution_definition>
            <substitution_definition names="image5"><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/04.autoplay_and_loop.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/04.autoplay_and_loop.png"></image></substitution_definition>
            <substitution_definition names="image6"><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/05.pin_icon.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/05.pin_icon.png"></image></substitution_definition>
            <substitution_definition names="image7"><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/06.animation_duration.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/06.animation_duration.webp"></image></substitution_definition>
            <substitution_definition names="image8"><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/07.editable_timeline.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/07.editable_timeline.webp"></image></substitution_definition>
            <substitution_definition names="image9"><image alt="image9" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/08.zoom_slider.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/08.zoom_slider.webp"></image></substitution_definition>
            <substitution_definition names="image10"><image alt="image10" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/09.creating_first_keyframe.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/09.creating_first_keyframe.webp"></image></substitution_definition>
            <substitution_definition names="image11"><image alt="image11" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/10.initial_keys.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/10.initial_keys.webp"></image></substitution_definition>
            <substitution_definition names="image12"><image alt="image12" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/11.moving_keys.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/11.moving_keys.webp"></image></substitution_definition>
            <substitution_definition names="image13"><image alt="image13" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/12.second_keys_values.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/12.second_keys_values.webp"></image></substitution_definition>
            <substitution_definition names="image14"><image alt="image14" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/13.second_keys.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/13.second_keys.webp"></image></substitution_definition>
            <substitution_definition names="image15"><image alt="image15" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/14.play_button.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/14.play_button.png"></image></substitution_definition>
            <substitution_definition names="image16"><image alt="image16" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/15.box_select.webp'}" uri="getting_started/first_3d_game/img/09.adding_animations/15.box_select.webp"></image></substitution_definition>
            <substitution_definition names="image17"><image alt="image17" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/16.easing_property.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/16.easing_property.png"></image></substitution_definition>
            <substitution_definition names="image18"><image alt="image18" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/17.ease_out.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/17.ease_out.png"></image></substitution_definition>
            <substitution_definition names="image19"><image alt="image19" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/18.ease_out_second_rotation_key.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/18.ease_out_second_rotation_key.png"></image></substitution_definition>
            <substitution_definition names="image20"><image alt="image20" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/19.ease_in_second_translation_key.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/19.ease_in_second_translation_key.png"></image></substitution_definition>
            <substitution_definition names="image21"><image alt="image21" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/20.float_animation.gif'}" uri="getting_started/first_3d_game/img/09.adding_animations/20.float_animation.gif"></image></substitution_definition>
            <substitution_definition names="image22"><image alt="image22" candidates="{'*': 'getting_started/first_3d_game/img/09.adding_animations/21.script_icon.png'}" uri="getting_started/first_3d_game/img/09.adding_animations/21.script_icon.png"></image></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
