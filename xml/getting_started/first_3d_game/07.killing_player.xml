<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/first_3d_game/07.killing_player.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-first-3d-game-killing-the-player"></target>
    <section ids="killing-the-player doc-first-3d-game-killing-the-player" names="killing\ the\ player 杀死玩家 doc_first_3d_game_killing_the_player">
        <title>杀死玩家</title>
        <paragraph>我们可以通过跳到敌人身上来杀死他们，但玩家仍然不能死亡。让我们来解决这个问题。</paragraph>
        <paragraph>我们希望检测到被敌人击中与压扁敌人时的不同。我们希望玩家在地板上移动时死亡，但如果他们在空中，则不会死亡。我们可以使用向量数学来区分这两种碰撞。但是，我们将使用 <reference internal="True" refuri="../../classes/class_area3d#class-area3d"><inline classes="std std-ref">Area3D</inline></reference> 节点，该节点适用于命中框。</paragraph>
        <section ids="hitbox-with-the-area-node" names="hitbox\ with\ the\ area\ node 使用\ area\ 节点制作攻击框">
            <title>使用 Area 节点制作攻击框</title>
            <paragraph>回到 <literal>player.tscn</literal> 场景，添加一个新的 <reference internal="True" refuri="../../classes/class_area3d#class-area3d"><inline classes="std std-ref">Area3D</inline></reference> 子节点。把它命名为 <literal>MobDetector</literal>（小怪检测器）。添加一个 <reference internal="True" refuri="../../classes/class_collisionshape3d#class-collisionshape3d"><inline classes="std std-ref">CollisionShape3D</inline></reference> 节点作为它的一个子节点。</paragraph>
            <paragraph><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/01.adding_area_node.png'}" uri="getting_started/first_3d_game/img/07.killing_player/01.adding_area_node.png"></image></paragraph>
            <paragraph>在<emphasis>检查器</emphasis>中，给它指定一个圆柱体形状。</paragraph>
            <paragraph><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/02.cylinder_shape.png'}" uri="getting_started/first_3d_game/img/07.killing_player/02.cylinder_shape.png"></image></paragraph>
            <paragraph>这里有一个技巧，你可以用它来使碰撞只发生在玩家在地面上或靠近地面时。你可以降低圆柱体的高度并将其向上移动到角色的顶部。这样，当玩家跳跃时，形状会太高，敌人无法与之碰撞。</paragraph>
            <paragraph><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/03.cylinder_in_editor.png'}" uri="getting_started/first_3d_game/img/07.killing_player/03.cylinder_in_editor.png"></image></paragraph>
            <paragraph>你还希望圆柱体比球体更宽。这样一来，玩家在碰撞之前就会被击中，并被推到怪物的碰撞盒之上。</paragraph>
            <paragraph>圆柱体越宽，玩家就越容易被杀死。</paragraph>
            <paragraph>接下来，再次选择 <literal>MobDetector</literal> 节点，并在<emphasis>检查器</emphasis>中， <strong>关闭</strong> 其 <emphasis>Monitorable</emphasis> 属性。这使得其他物理节点无法检测到这个区域。补充的 <emphasis>Monitoring</emphasis> 属性允许它检测碰撞。然后，清除 <emphasis>Collision -&gt; Layer</emphasis>，并将掩码设置为“enemies”层。</paragraph>
            <paragraph><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/04.mob_detector_properties.webp'}" uri="getting_started/first_3d_game/img/07.killing_player/04.mob_detector_properties.webp"></image></paragraph>
            <paragraph>当区域检测到碰撞时，它们会发出信号。我们要将一个信号连接到 <emphasis>Player</emphasis> 节点。在<emphasis>节点</emphasis>选项卡中，双击 <literal>body_entered</literal> 信号并将其连接到 <emphasis>Player</emphasis></paragraph>
            <paragraph><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/05.body_entered_signal.png'}" uri="getting_started/first_3d_game/img/07.killing_player/05.body_entered_signal.png"></image></paragraph>
            <paragraph>当一个 <reference internal="True" refuri="../../classes/class_characterbody3d#class-characterbody3d"><inline classes="std std-ref">CharacterBody3D</inline></reference> 或 <reference internal="True" refuri="../../classes/class_rigidbody3d#class-rigidbody3d"><inline classes="std std-ref">RigidBody3D</inline></reference> 节点进入它时，<emphasis>MobDetector</emphasis> 将发出 <literal>body_entered</literal> 信号。由于它只遮罩了“enemies”物理层，它将只检测 <emphasis>Mob</emphasis> 节点。</paragraph>
            <paragraph>从代码上看，我们要做两件事：发出一个信号，我们以后会用来结束游戏，并销毁玩家。我们可以用 <literal>die()</literal> 函数来包装这些操作，帮助我们给代码贴上描述性标签。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Emitted when the player was hit by a mob.
# Put this at the top of the script.
signal hit


# And this function at the bottom.
func die():
    hit.emit()
    queue_free()


func _on_mob_detector_body_entered(body):
    die()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Don't forget to rebuild the project so the editor knows about the new signal.

// Emitted when the player was hit by a mob.
[Signal]
public delegate void HitEventHandler();

// ...

private void Die()
{
    EmitSignal(SignalName.Hit);
    QueueFree();
}

// We also specified this function name in PascalCase in the editor's connection window
private void OnMobDetectorBodyEntered(Node3D body)
{
    Die();
}</literal_block>
                </div>
            </container>
            <paragraph>按 <literal classes="kbd">F5</literal> 再试一下游戏。如果一切设置正确，角色在被敌人碰到时应该会死亡</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var player_position = $Player.position</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">Vector3 playerPosition = GetNode&lt;Player&gt;("Player").Position;</literal_block>
                </div>
            </container>
            <paragraph>由于此处没有 $Player 导致的报错！</paragraph>
            <paragraph>另外请注意，敌人与玩家碰撞并死亡取决于 <literal>Player</literal> 和 <literal>Mob</literal> 的碰撞形状的大小和位置。你可能需要移动它们，调整它们的大小，以达到紧凑的游戏感觉。</paragraph>
        </section>
        <section ids="ending-the-game" names="ending\ the\ game 结束游戏">
            <title>结束游戏</title>
            <paragraph>我们可以利用 <literal>Player</literal> 的 <literal>hit</literal> 信号来结束游戏。我们所要做的就是将它连接到 <literal>Main</literal> 节点上，在处理时停止 <literal>MobTimer</literal>。</paragraph>
            <paragraph>打开 <literal>main.tscn</literal> 场景，选中 <literal>Player</literal> 节点，然后在<emphasis>节点</emphasis>面板中把 <literal>hit</literal> 信号连接到 <literal>Main</literal> 节点。</paragraph>
            <paragraph><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/06.player_hit_signal.png'}" uri="getting_started/first_3d_game/img/07.killing_player/06.player_hit_signal.png"></image></paragraph>
            <paragraph>在 <literal>_on_player_hit()</literal> 函数中获取并停止计时器。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_player_hit():
    $MobTimer.stop()</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// We also specified this function name in PascalCase in the editor's connection window
private void OnPlayerHit()
{
    GetNode&lt;Timer&gt;("MobTimer").Stop();
}</literal_block>
                </div>
            </container>
            <paragraph>如果你现在试玩游戏，你死亡后就会停止刷怪，现有的怪物会离开屏幕。</paragraph>
            <paragraph>你可以鼓励鼓励自己了：你做出了完整 3D 游戏的原型，虽说还有点粗糙。</paragraph>
            <paragraph>在此基础上，我们将会添加计分、重启游戏的选项，你还会看到如何使用简单的动画让游戏变得更加活灵活现。</paragraph>
        </section>
        <section ids="code-checkpoint" names="code\ checkpoint 代码检查点">
            <title>代码检查点</title>
            <paragraph>这些是 <literal>Main</literal>、<literal>Mob</literal>、<literal>Player</literal> 节点的完整脚本，仅供参考。你可以把它们和你的代码进行对比检查。</paragraph>
            <paragraph>首先是 <literal>main.gd</literal>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

@export var mob_scene: PackedScene


func _on_mob_timer_timeout():
    # Create a new instance of the Mob scene.
    var mob = mob_scene.instantiate()

    # Choose a random location on the SpawnPath.
    # We store the reference to the SpawnLocation node.
    var mob_spawn_location = get_node("SpawnPath/SpawnLocation")
    # And give it a random offset.
    mob_spawn_location.progress_ratio = randf()

    var player_position = $Player.position
    mob.initialize(mob_spawn_location.position, player_position)

    # Spawn the mob by adding it to the Main scene.
    add_child(mob)

func _on_player_hit():
    $MobTimer.stop()</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Main : Node
{
    [Export]
    public PackedScene MobScene { get; set; }

    private void OnMobTimerTimeout()
    {
        // Create a new instance of the Mob scene.
        Mob mob = MobScene.Instantiate&lt;Mob&gt;();

        // Choose a random location on the SpawnPath.
        // We store the reference to the SpawnLocation node.
        var mobSpawnLocation = GetNode&lt;PathFollow3D&gt;("SpawnPath/SpawnLocation");
        // And give it a random offset.
        mobSpawnLocation.ProgressRatio = GD.Randf();

        Vector3 playerPosition = GetNode&lt;Player&gt;("Player").Position;
        mob.Initialize(mobSpawnLocation.Position, playerPosition);

        // Spawn the mob by adding it to the Main scene.
        AddChild(mob);
    }

    private void OnPlayerHit()
    {
        GetNode&lt;Timer&gt;("MobTimer").Stop();
    }
}</literal_block>
                </div>
            </container>
            <paragraph>然后是 <literal>Mob.gd</literal>。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

# Minimum speed of the mob in meters per second.
@export var min_speed = 10
# Maximum speed of the mob in meters per second.
@export var max_speed = 18

# Emitted when the player jumped on the mob
signal squashed

func _physics_process(_delta):
    move_and_slide()

# This function will be called from the Main scene.
func initialize(start_position, player_position):
    # We position the mob by placing it at start_position
    # and rotate it towards player_position, so it looks at the player.
    look_at_from_position(start_position, player_position, Vector3.UP)
    # Rotate this mob randomly within range of -90 and +90 degrees,
    # so that it doesn't move directly towards the player.
    rotate_y(randf_range(-PI / 4, PI / 4))

    # We calculate a random speed (integer)
    var random_speed = randi_range(min_speed, max_speed)
    # We calculate a forward velocity that represents the speed.
    velocity = Vector3.FORWARD * random_speed
    # We then rotate the velocity vector based on the mob's Y rotation
    # in order to move in the direction the mob is looking.
    velocity = velocity.rotated(Vector3.UP, rotation.y)

func _on_visible_on_screen_notifier_3d_screen_exited():
    queue_free()

func squash():
    squashed.emit()
    queue_free() # Destroy this node</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Mob : CharacterBody3D
{
    // Emitted when the played jumped on the mob.
    [Signal]
    public delegate void SquashedEventHandler();

    // Minimum speed of the mob in meters per second
    [Export]
    public int MinSpeed { get; set; } = 10;
    // Maximum speed of the mob in meters per second
    [Export]
    public int MaxSpeed { get; set; } = 18;

    public override void _PhysicsProcess(double delta)
    {
        MoveAndSlide();
    }

    // This function will be called from the Main scene.
    public void Initialize(Vector3 startPosition, Vector3 playerPosition)
    {
        // We position the mob by placing it at startPosition
        // and rotate it towards playerPosition, so it looks at the player.
        LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
        // Rotate this mob randomly within range of -90 and +90 degrees,
        // so that it doesn't move directly towards the player.
        RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));

        // We calculate a random speed (integer)
        int randomSpeed = GD.RandRange(MinSpeed, MaxSpeed);
        // We calculate a forward velocity that represents the speed.
        Velocity = Vector3.Forward * randomSpeed;
        // We then rotate the velocity vector based on the mob's Y rotation
        // in order to move in the direction the mob is looking.
        Velocity = Velocity.Rotated(Vector3.Up, Rotation.Y);
    }

    public void Squash()
    {
        EmitSignal(SignalName.Squashed);
        QueueFree(); // Destroy this node
    }

    private void OnVisibilityNotifierScreenExited()
    {
        QueueFree();
    }
}</literal_block>
                </div>
            </container>
            <paragraph>最后是最长的脚本 <literal>Player.gd</literal>：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

signal hit

# How fast the player moves in meters per second
@export var speed = 14
# The downward acceleration while in the air, in meters per second squared.
@export var fall_acceleration = 75
# Vertical impulse applied to the character upon jumping in meters per second.
@export var jump_impulse = 20
# Vertical impulse applied to the character upon bouncing over a mob
# in meters per second.
@export var bounce_impulse = 16

var target_velocity = Vector3.ZERO


func _physics_process(delta):
    # We create a local variable to store the input direction
    var direction = Vector3.ZERO

    # We check for each move input and update the direction accordingly
    if Input.is_action_pressed("move_right"):
        direction.x = direction.x + 1
    if Input.is_action_pressed("move_left"):
        direction.x = direction.x - 1
    if Input.is_action_pressed("move_back"):
        # Notice how we are working with the vector's x and z axes.
        # In 3D, the XZ plane is the ground plane.
        direction.z = direction.z + 1
    if Input.is_action_pressed("move_forward"):
        direction.z = direction.z - 1

    # Prevent diagonal moving fast af
    if direction != Vector3.ZERO:
        direction = direction.normalized()
        $Pivot.look_at(position + direction, Vector3.UP)

    # Ground Velocity
    target_velocity.x = direction.x * speed
    target_velocity.z = direction.z * speed

    # Vertical Velocity
    if not is_on_floor(): # If in the air, fall towards the floor. Literally gravity
        target_velocity.y = target_velocity.y - (fall_acceleration * delta)

    # Jumping.
    if is_on_floor() and Input.is_action_just_pressed("jump"):
        target_velocity.y = jump_impulse

    # Iterate through all collisions that occurred this frame
    # in C this would be for(int i = 0; i &lt; collisions.Count; i++)
    for index in range(get_slide_collision_count()):
        # We get one of the collisions with the player
        var collision = get_slide_collision(index)

        # If the collision is with ground
        if collision.get_collider() == null:
            continue

        # If the collider is with a mob
        if collision.get_collider().is_in_group("mob"):
            var mob = collision.get_collider()
            # we check that we are hitting it from above.
            if Vector3.UP.dot(collision.get_normal()) &gt; 0.1:
                # If so, we squash it and bounce.
                mob.squash()
                target_velocity.y = bounce_impulse
                # Prevent further duplicate calls.
                break

    # Moving the Character
    velocity = target_velocity
    move_and_slide()

# And this function at the bottom.
func die():
    hit.emit()
    queue_free()

func _on_mob_detector_body_entered(body):
    die()</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Player : CharacterBody3D
{
    // Emitted when the player was hit by a mob.
    [Signal]
    public delegate void HitEventHandler();

    // How fast the player moves in meters per second.
    [Export]
    public int Speed { get; set; } = 14;
    // The downward acceleration when in the air, in meters per second squared.
    [Export]
    public int FallAcceleration { get; set; } = 75;
    // Vertical impulse applied to the character upon jumping in meters per second.
    [Export]
    public int JumpImpulse { get; set; } = 20;
    // Vertical impulse applied to the character upon bouncing over a mob in meters per second.
    [Export]
    public int BounceImpulse { get; set; } = 16;

    private Vector3 _targetVelocity = Vector3.Zero;

    public override void _PhysicsProcess(double delta)
    {
        // We create a local variable to store the input direction.
        var direction = Vector3.Zero;

        // We check for each move input and update the direction accordingly.
        if (Input.IsActionPressed("move_right"))
        {
            direction.X += 1.0f;
        }
        if (Input.IsActionPressed("move_left"))
        {
            direction.X -= 1.0f;
        }
        if (Input.IsActionPressed("move_back"))
        {
            // Notice how we are working with the vector's X and Z axes.
            // In 3D, the XZ plane is the ground plane.
            direction.Z += 1.0f;
        }
        if (Input.IsActionPressed("move_forward"))
        {
            direction.Z -= 1.0f;
        }

        // Prevent diagonal moving fast af
        if (direction != Vector3.Zero)
        {
            direction = direction.Normalized();
            GetNode&lt;Node3D&gt;("Pivot").LookAt(Position + direction, Vector3.Up);
        }

        // Ground Velocity
        _targetVelocity.X = direction.X * Speed;
        _targetVelocity.Z = direction.Z * Speed;

        // Vertical Velocity
        if (!IsOnFloor()) // If in the air, fall towards the floor. Literally gravity
        {
            _targetVelocity.Y -= FallAcceleration * (float)delta;
        }

        // Jumping.
        if (IsOnFloor() &amp;&amp; Input.IsActionJustPressed("jump"))
        {
            _targetVelocity.Y = JumpImpulse;
        }

        // Iterate through all collisions that occurred this frame.
        for (int index = 0; index &lt; GetSlideCollisionCount(); index++)
        {
            // We get one of the collisions with the player.
            KinematicCollision3D collision = GetSlideCollision(index);

            // If the collision is with a mob.
            if (collision.GetCollider() is Mob mob)
            {
                // We check that we are hitting it from above.
                if (Vector3.Up.Dot(collision.GetNormal()) &gt; 0.1f)
                {
                    // If so, we squash it and bounce.
                    mob.Squash();
                    _targetVelocity.Y = BounceImpulse;
                    // Prevent further duplicate calls.
                    break;
                }
            }
        }

        // Moving the Character
        Velocity = _targetVelocity;
        MoveAndSlide();
    }

    private void Die()
    {
        EmitSignal(SignalName.Hit);
        QueueFree();
    }

    private void OnMobDetectorBodyEntered(Node3D body)
    {
        Die();
    }
}</literal_block>
                </div>
            </container>
            <paragraph>在下一节课中我们会添加计分和重试选项，再见。</paragraph>
            <substitution_definition names="image0"><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/01.adding_area_node.png'}" uri="getting_started/first_3d_game/img/07.killing_player/01.adding_area_node.png"></image></substitution_definition>
            <substitution_definition names="image1"><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/02.cylinder_shape.png'}" uri="getting_started/first_3d_game/img/07.killing_player/02.cylinder_shape.png"></image></substitution_definition>
            <substitution_definition names="image2"><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/03.cylinder_in_editor.png'}" uri="getting_started/first_3d_game/img/07.killing_player/03.cylinder_in_editor.png"></image></substitution_definition>
            <substitution_definition names="image3"><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/04.mob_detector_properties.webp'}" uri="getting_started/first_3d_game/img/07.killing_player/04.mob_detector_properties.webp"></image></substitution_definition>
            <substitution_definition names="image4"><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/05.body_entered_signal.png'}" uri="getting_started/first_3d_game/img/07.killing_player/05.body_entered_signal.png"></image></substitution_definition>
            <substitution_definition names="image5"><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/06.player_hit_signal.png'}" uri="getting_started/first_3d_game/img/07.killing_player/06.player_hit_signal.png"></image></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
