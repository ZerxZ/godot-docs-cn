<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/first_3d_game/07.killing_player.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-first-3d-game-killing-the-player"></target>
    <section ids="killing-the-player doc-first-3d-game-killing-the-player" names="killing\ the\ player doc_first_3d_game_killing_the_player">
        <title>Killing the player</title>
        <paragraph>We can kill enemies by jumping on them, but the player still can't die.
            Let's fix this.</paragraph>
        <paragraph>We want to detect being hit by an enemy differently from squashing them.
            We want the player to die when they're moving on the floor, but not if
            they're in the air. We could use vector math to distinguish the two
            kinds of collisions. Instead, though, we will use an <reference internal="True" refuri="../../classes/class_area3d#class-area3d"><inline classes="std std-ref">Area3D</inline></reference> node, which
            works well for hitboxes.</paragraph>
        <section ids="hitbox-with-the-area-node" names="hitbox\ with\ the\ area\ node">
            <title>Hitbox with the Area node</title>
            <paragraph>Head back to the <literal>player.tscn</literal> scene and add a new child node <reference internal="True" refuri="../../classes/class_area3d#class-area3d"><inline classes="std std-ref">Area3D</inline></reference>. Name it
                <literal>MobDetector</literal>
                Add a <reference internal="True" refuri="../../classes/class_collisionshape3d#class-collisionshape3d"><inline classes="std std-ref">CollisionShape3D</inline></reference> node as a child of it.</paragraph>
            <paragraph><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/01.adding_area_node.webp'}" original_uri="img/07.killing_player/01.adding_area_node.webp" uri="getting_started/first_3d_game/img/07.killing_player/01.adding_area_node.webp"></image></paragraph>
            <paragraph>In the <emphasis>Inspector</emphasis>, assign a cylinder shape to it.</paragraph>
            <paragraph><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/02.cylinder_shape.webp'}" original_uri="img/07.killing_player/02.cylinder_shape.webp" uri="getting_started/first_3d_game/img/07.killing_player/02.cylinder_shape.webp"></image></paragraph>
            <paragraph>Here is a trick you can use to make the collisions only happen when the
                player is on the ground or close to it. You can reduce the cylinder's
                height and move it up to the top of the character. This way, when the
                player jumps, the shape will be too high up for the enemies to collide
                with it.</paragraph>
            <paragraph><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/03.cylinder_in_editor.png'}" original_uri="img/07.killing_player/03.cylinder_in_editor.png" uri="getting_started/first_3d_game/img/07.killing_player/03.cylinder_in_editor.png"></image></paragraph>
            <paragraph>You also want the cylinder to be wider than the sphere. This way, the
                player gets hit before colliding and being pushed on top of the
                monster's collision box.</paragraph>
            <paragraph>The wider the cylinder, the more easily the player will get killed.</paragraph>
            <paragraph>Next, select the <literal>MobDetector</literal> node again, and in the <emphasis>Inspector</emphasis>, turn
                <strong>off</strong> its <emphasis>Monitorable</emphasis> property. This makes it so other physics nodes
                cannot detect the area. The complementary <emphasis>Monitoring</emphasis> property allows
                it to detect collisions. Then, remove the <emphasis>Collision -&gt; Layer</emphasis> and set
                the mask to the "enemies" layer.</paragraph>
            <paragraph><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/04.mob_detector_properties.webp'}" original_uri="img/07.killing_player/04.mob_detector_properties.webp" uri="getting_started/first_3d_game/img/07.killing_player/04.mob_detector_properties.webp"></image></paragraph>
            <paragraph>When areas detect a collision, they emit signals. We're going to connect
                one to the <literal>Player</literal> node. Select <literal>MobDetector</literal> and go to <emphasis>Inspector</emphasis>'s <emphasis>Node</emphasis> tab, double-click the
                <literal>body_entered</literal> signal and connect it to the <literal>Player</literal></paragraph>
            <paragraph><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/05.body_entered_signal.webp'}" original_uri="img/07.killing_player/05.body_entered_signal.webp" uri="getting_started/first_3d_game/img/07.killing_player/05.body_entered_signal.webp"></image></paragraph>
            <paragraph>The <emphasis>MobDetector</emphasis> will emit <literal>body_entered</literal> when a <reference internal="True" refuri="../../classes/class_characterbody3d#class-characterbody3d"><inline classes="std std-ref">CharacterBody3D</inline></reference> or a
                <reference internal="True" refuri="../../classes/class_rigidbody3d#class-rigidbody3d"><inline classes="std std-ref">RigidBody3D</inline></reference> node enters it. As it only masks the "enemies" physics
                layers, it will only detect the <literal>Mob</literal> nodes.</paragraph>
            <paragraph>Code-wise, we're going to do two things: emit a signal we'll later use
                to end the game and destroy the player. We can wrap these operations in
                a <literal>die()</literal> function that helps us put a descriptive label on the code.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve"># Emitted when the player was hit by a mob.
# Put this at the top of the script.
signal hit


# And this function at the bottom.
func die():
    hit.emit()
    queue_free()


func _on_mob_detector_body_entered(body):
    die()</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Don't forget to rebuild the project so the editor knows about the new signal.

// Emitted when the player was hit by a mob.
[Signal]
public delegate void HitEventHandler();

// ...

private void Die()
{
    EmitSignal(SignalName.Hit);
    QueueFree();
}

// We also specified this function name in PascalCase in the editor's connection window.
private void OnMobDetectorBodyEntered(Node3D body)
{
    Die();
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="ending-the-game" names="ending\ the\ game">
            <title>Ending the game</title>
            <paragraph>We can use the <literal>Player</literal>'s <literal>hit</literal> signal to end the game. All we need
                to do is connect it to the <literal>Main</literal> node and stop the <literal>MobTimer</literal> in
                reaction.</paragraph>
            <paragraph>Open <literal>main.tscn</literal>, select the <literal>Player</literal> node, and in the <emphasis>Node</emphasis> dock,
                connect its <literal>hit</literal> signal to the <literal>Main</literal> node.</paragraph>
            <paragraph><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/06.player_hit_signal.webp'}" original_uri="img/07.killing_player/06.player_hit_signal.webp" uri="getting_started/first_3d_game/img/07.killing_player/06.player_hit_signal.webp"></image></paragraph>
            <paragraph>Get the timer, and stop it, in the <literal>_on_player_hit()</literal> function.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_player_hit():
    $MobTimer.stop()</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// We also specified this function name in PascalCase in the editor's connection window.
private void OnPlayerHit()
{
    GetNode&lt;Timer&gt;("MobTimer").Stop();
}</literal_block>
                </div>
            </container>
            <paragraph>If you try the game now, the monsters will stop spawning when you die,
                and the remaining ones will leave the screen.</paragraph>
            <paragraph>Notice also that the game no longer crashes or displays an error when the player dies. Because
                we are stopping the MobTimer, it no longer triggers the <literal>_on_mob_timer_timeout()</literal> function.</paragraph>
            <paragraph>Also note that the enemy colliding with the player and dying depends on the size and position of the
                <literal>Player</literal> and the <literal>Mob</literal>'s collision shapes. You may need to move them
                and resize them to achieve a tight game feel.</paragraph>
            <paragraph>You can pat yourself on the back: you prototyped a complete 3D game,
                even if it's still a bit rough.</paragraph>
            <paragraph>From there, we'll add a score, the option to retry the game, and you'll
                see how you can make the game feel much more alive with minimalistic
                animations.</paragraph>
        </section>
        <section ids="code-checkpoint" names="code\ checkpoint">
            <title>Code checkpoint</title>
            <paragraph>Here are the complete scripts for the <literal>Main</literal>, <literal>Mob</literal>, and <literal>Player</literal> nodes,
                for reference. You can use them to compare and check your code.</paragraph>
            <paragraph>Starting with <literal>main.gd</literal>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

@export var mob_scene: PackedScene


func _on_mob_timer_timeout():
    # Create a new instance of the Mob scene.
    var mob = mob_scene.instantiate()

    # Choose a random location on the SpawnPath.
    # We store the reference to the SpawnLocation node.
    var mob_spawn_location = get_node("SpawnPath/SpawnLocation")
    # And give it a random offset.
    mob_spawn_location.progress_ratio = randf()

    var player_position = $Player.position
    mob.initialize(mob_spawn_location.position, player_position)

    # Spawn the mob by adding it to the Main scene.
    add_child(mob)

func _on_player_hit():
    $MobTimer.stop()</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Main : Node
{
    [Export]
    public PackedScene MobScene { get; set; }

    private void OnMobTimerTimeout()
    {
        // Create a new instance of the Mob scene.
        Mob mob = MobScene.Instantiate&lt;Mob&gt;();

        // Choose a random location on the SpawnPath.
        // We store the reference to the SpawnLocation node.
        var mobSpawnLocation = GetNode&lt;PathFollow3D&gt;("SpawnPath/SpawnLocation");
        // And give it a random offset.
        mobSpawnLocation.ProgressRatio = GD.Randf();

        Vector3 playerPosition = GetNode&lt;Player&gt;("Player").Position;
        mob.Initialize(mobSpawnLocation.Position, playerPosition);

        // Spawn the mob by adding it to the Main scene.
        AddChild(mob);
    }

    private void OnPlayerHit()
    {
        GetNode&lt;Timer&gt;("MobTimer").Stop();
    }
}</literal_block>
                </div>
            </container>
            <paragraph>Next is <literal>mob.gd</literal>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

# Minimum speed of the mob in meters per second.
@export var min_speed = 10
# Maximum speed of the mob in meters per second.
@export var max_speed = 18

# Emitted when the player jumped on the mob
signal squashed

func _physics_process(_delta):
    move_and_slide()

# This function will be called from the Main scene.
func initialize(start_position, player_position):
    # We position the mob by placing it at start_position
    # and rotate it towards player_position, so it looks at the player.
    look_at_from_position(start_position, player_position, Vector3.UP)
    # Rotate this mob randomly within range of -45 and +45 degrees,
    # so that it doesn't move directly towards the player.
    rotate_y(randf_range(-PI / 4, PI / 4))

    # We calculate a random speed (integer)
    var random_speed = randi_range(min_speed, max_speed)
    # We calculate a forward velocity that represents the speed.
    velocity = Vector3.FORWARD * random_speed
    # We then rotate the velocity vector based on the mob's Y rotation
    # in order to move in the direction the mob is looking.
    velocity = velocity.rotated(Vector3.UP, rotation.y)

func _on_visible_on_screen_notifier_3d_screen_exited():
    queue_free()

func squash():
    squashed.emit()
    queue_free() # Destroy this node</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Mob : CharacterBody3D
{
    // Emitted when the played jumped on the mob.
    [Signal]
    public delegate void SquashedEventHandler();

    // Minimum speed of the mob in meters per second
    [Export]
    public int MinSpeed { get; set; } = 10;
    // Maximum speed of the mob in meters per second
    [Export]
    public int MaxSpeed { get; set; } = 18;

    public override void _PhysicsProcess(double delta)
    {
        MoveAndSlide();
    }

    // This function will be called from the Main scene.
    public void Initialize(Vector3 startPosition, Vector3 playerPosition)
    {
        // We position the mob by placing it at startPosition
        // and rotate it towards playerPosition, so it looks at the player.
        LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
        // Rotate this mob randomly within range of -45 and +45 degrees,
        // so that it doesn't move directly towards the player.
        RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));

        // We calculate a random speed (integer)
        int randomSpeed = GD.RandRange(MinSpeed, MaxSpeed);
        // We calculate a forward velocity that represents the speed.
        Velocity = Vector3.Forward * randomSpeed;
        // We then rotate the velocity vector based on the mob's Y rotation
        // in order to move in the direction the mob is looking.
        Velocity = Velocity.Rotated(Vector3.Up, Rotation.Y);
    }

    public void Squash()
    {
        EmitSignal(SignalName.Squashed);
        QueueFree(); // Destroy this node
    }

    private void OnVisibilityNotifierScreenExited()
    {
        QueueFree();
    }
}</literal_block>
                </div>
            </container>
            <paragraph>Finally, the longest script, <literal>player.gd</literal>:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

signal hit

# How fast the player moves in meters per second
@export var speed = 14
# The downward acceleration while in the air, in meters per second squared.
@export var fall_acceleration = 75
# Vertical impulse applied to the character upon jumping in meters per second.
@export var jump_impulse = 20
# Vertical impulse applied to the character upon bouncing over a mob
# in meters per second.
@export var bounce_impulse = 16

var target_velocity = Vector3.ZERO


func _physics_process(delta):
    # We create a local variable to store the input direction
    var direction = Vector3.ZERO

    # We check for each move input and update the direction accordingly
    if Input.is_action_pressed("move_right"):
        direction.x = direction.x + 1
    if Input.is_action_pressed("move_left"):
        direction.x = direction.x - 1
    if Input.is_action_pressed("move_back"):
        # Notice how we are working with the vector's x and z axes.
        # In 3D, the XZ plane is the ground plane.
        direction.z = direction.z + 1
    if Input.is_action_pressed("move_forward"):
        direction.z = direction.z - 1

    # Prevent diagonal moving fast af
    if direction != Vector3.ZERO:
        direction = direction.normalized()
        # Setting the basis property will affect the rotation of the node.
        $Pivot.basis = Basis.looking_at(direction)

    # Ground Velocity
    target_velocity.x = direction.x * speed
    target_velocity.z = direction.z * speed

    # Vertical Velocity
    if not is_on_floor(): # If in the air, fall towards the floor. Literally gravity
        target_velocity.y = target_velocity.y - (fall_acceleration * delta)

    # Jumping.
    if is_on_floor() and Input.is_action_just_pressed("jump"):
        target_velocity.y = jump_impulse

    # Iterate through all collisions that occurred this frame
    # in C this would be for(int i = 0; i &lt; collisions.Count; i++)
    for index in range(get_slide_collision_count()):
        # We get one of the collisions with the player
        var collision = get_slide_collision(index)

        # If the collision is with ground
        if collision.get_collider() == null:
            continue

        # If the collider is with a mob
        if collision.get_collider().is_in_group("mob"):
            var mob = collision.get_collider()
            # we check that we are hitting it from above.
            if Vector3.UP.dot(collision.get_normal()) &gt; 0.1:
                # If so, we squash it and bounce.
                mob.squash()
                target_velocity.y = bounce_impulse
                # Prevent further duplicate calls.
                break

    # Moving the Character
    velocity = target_velocity
    move_and_slide()

# And this function at the bottom.
func die():
    hit.emit()
    queue_free()

func _on_mob_detector_body_entered(body):
    die()</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Player : CharacterBody3D
{
    // Emitted when the player was hit by a mob.
    [Signal]
    public delegate void HitEventHandler();

    // How fast the player moves in meters per second.
    [Export]
    public int Speed { get; set; } = 14;
    // The downward acceleration when in the air, in meters per second squared.
    [Export]
    public int FallAcceleration { get; set; } = 75;
    // Vertical impulse applied to the character upon jumping in meters per second.
    [Export]
    public int JumpImpulse { get; set; } = 20;
    // Vertical impulse applied to the character upon bouncing over a mob in meters per second.
    [Export]
    public int BounceImpulse { get; set; } = 16;

    private Vector3 _targetVelocity = Vector3.Zero;

    public override void _PhysicsProcess(double delta)
    {
        // We create a local variable to store the input direction.
        var direction = Vector3.Zero;

        // We check for each move input and update the direction accordingly.
        if (Input.IsActionPressed("move_right"))
        {
            direction.X += 1.0f;
        }
        if (Input.IsActionPressed("move_left"))
        {
            direction.X -= 1.0f;
        }
        if (Input.IsActionPressed("move_back"))
        {
            // Notice how we are working with the vector's X and Z axes.
            // In 3D, the XZ plane is the ground plane.
            direction.Z += 1.0f;
        }
        if (Input.IsActionPressed("move_forward"))
        {
            direction.Z -= 1.0f;
        }

        // Prevent diagonal moving fast af
        if (direction != Vector3.Zero)
        {
            direction = direction.Normalized();
            // Setting the basis property will affect the rotation of the node.
            GetNode&lt;Node3D&gt;("Pivot").Basis = Basis.LookingAt(direction);
        }

        // Ground Velocity
        _targetVelocity.X = direction.X * Speed;
        _targetVelocity.Z = direction.Z * Speed;

        // Vertical Velocity
        if (!IsOnFloor()) // If in the air, fall towards the floor. Literally gravity
        {
            _targetVelocity.Y -= FallAcceleration * (float)delta;
        }

        // Jumping.
        if (IsOnFloor() &amp;&amp; Input.IsActionJustPressed("jump"))
        {
            _targetVelocity.Y = JumpImpulse;
        }

        // Iterate through all collisions that occurred this frame.
        for (int index = 0; index &lt; GetSlideCollisionCount(); index++)
        {
            // We get one of the collisions with the player.
            KinematicCollision3D collision = GetSlideCollision(index);

            // If the collision is with a mob.
            if (collision.GetCollider() is Mob mob)
            {
                // We check that we are hitting it from above.
                if (Vector3.Up.Dot(collision.GetNormal()) &gt; 0.1f)
                {
                    // If so, we squash it and bounce.
                    mob.Squash();
                    _targetVelocity.Y = BounceImpulse;
                    // Prevent further duplicate calls.
                    break;
                }
            }
        }

        // Moving the Character
        Velocity = _targetVelocity;
        MoveAndSlide();
    }

    private void Die()
    {
        EmitSignal(SignalName.Hit);
        QueueFree();
    }

    private void OnMobDetectorBodyEntered(Node3D body)
    {
        Die();
    }
}</literal_block>
                </div>
            </container>
            <paragraph>See you in the next lesson to add the score and the retry option.</paragraph>
            <substitution_definition names="image0"><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/01.adding_area_node.webp'}" original_uri="img/07.killing_player/01.adding_area_node.webp" uri="getting_started/first_3d_game/img/07.killing_player/01.adding_area_node.webp"></image></substitution_definition>
            <substitution_definition names="image1"><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/02.cylinder_shape.webp'}" original_uri="img/07.killing_player/02.cylinder_shape.webp" uri="getting_started/first_3d_game/img/07.killing_player/02.cylinder_shape.webp"></image></substitution_definition>
            <substitution_definition names="image2"><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/03.cylinder_in_editor.png'}" original_uri="img/07.killing_player/03.cylinder_in_editor.png" uri="getting_started/first_3d_game/img/07.killing_player/03.cylinder_in_editor.png"></image></substitution_definition>
            <substitution_definition names="image3"><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/04.mob_detector_properties.webp'}" original_uri="img/07.killing_player/04.mob_detector_properties.webp" uri="getting_started/first_3d_game/img/07.killing_player/04.mob_detector_properties.webp"></image></substitution_definition>
            <substitution_definition names="image4"><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/05.body_entered_signal.webp'}" original_uri="img/07.killing_player/05.body_entered_signal.webp" uri="getting_started/first_3d_game/img/07.killing_player/05.body_entered_signal.webp"></image></substitution_definition>
            <substitution_definition names="image5"><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/07.killing_player/06.player_hit_signal.webp'}" original_uri="img/07.killing_player/06.player_hit_signal.webp" uri="getting_started/first_3d_game/img/07.killing_player/06.player_hit_signal.webp"></image></substitution_definition>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
