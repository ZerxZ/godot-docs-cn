<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/first_3d_game/03.player_movement_code.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-first-3d-game-player-movement"></target>
    <section ids="moving-the-player-with-code doc-first-3d-game-player-movement" names="moving\ the\ player\ with\ code 使用代码移动玩家 doc_first_3d_game_player_movement">
        <title>使用代码移动玩家</title>
        <paragraph>该轮到编写代码了！我们将使用先前创建的输入动作来移动角色。</paragraph>
        <note>
            <paragraph>对于此项目，我们将遵循 Godot 的命名约定。</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>GDScript</strong>：类（节点）使用 PascalCase（大驼峰命名法），变量和函数使用 snake_case（蛇形命名法），常量使用 ALL_CAPS（全大写）（请参阅 <reference internal="True" refuri="../../tutorials/scripting/gdscript/gdscript_styleguide#doc-gdscript-styleguide"><inline classes="std std-ref">GDScript 编写风格指南</inline></reference>）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>C#</strong>：类、导出变量和方法使用 PascalCase（大驼峰命名法），私有字段使用 _camelCase（前缀下划线的小驼峰命名法），局部变量和参数使用 camelCase（小驼峰命名法）（请参阅 <reference internal="True" refuri="../../tutorials/scripting/c_sharp/c_sharp_style_guide#doc-c-sharp-styleguide"><inline classes="std std-ref">C# 风格指南</inline></reference>）。连接信号时，请务必准确键入方法名称。</paragraph>
                </list_item>
            </bullet_list>
        </note>
        <paragraph>右键单击 <literal>Player</literal> 节点，选择<emphasis>附加脚本</emphasis>为其添加一个新脚本。在弹出窗口中，先将<emphasis>模板</emphasis>设置为 <emphasis>空</emphasis>，然后按下<emphasis>创建</emphasis>按钮 。之所以要设置为<emphasis>空</emphasis>是因为我们想要自己写玩家的移动代码。</paragraph>
        <paragraph><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/01.attach_script_to_player.webp'}" uri="getting_started/first_3d_game/img/03.player_movement_code/01.attach_script_to_player.webp"></image></paragraph>
        <paragraph>先定义类的属性。我们将定义移动速率（标量）、重力加速度，以及一个我们将用来移动角色的速度（向量）。</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

# How fast the player moves in meters per second.
@export var speed = 14
# The downward acceleration when in the air, in meters per second squared.
@export var fall_acceleration = 75

var target_velocity = Vector3.ZERO</literal_block>
            </div>
            <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Player : CharacterBody3D
{
    // Don't forget to rebuild the project so the editor knows about the new export variable.

    // How fast the player moves in meters per second.
    [Export]
    public int Speed { get; set; } = 14;
    // The downward acceleration when in the air, in meters per second squared.
    [Export]
    public int FallAcceleration { get; set; } = 75;

    private Vector3 _targetVelocity = Vector3.Zero;
}</literal_block>
            </div>
        </container>
        <paragraph>这是一个移动物体的常见属性。 <literal>target_velocity</literal> 是一个组合了速度和方向的 <reference internal="True" refuri="../../classes/class_vector3#class-vector3"><inline classes="std std-ref">3D 向量</inline></reference>。在这里，我们将其定义为属性，因为我们希望在帧之间更新并重用其值。</paragraph>
        <note>
            <paragraph>这些值与二维代码完全不同，因为距离以米为单位。在 2D 中，一千个单位（像素）可能只对应于屏幕宽度的一半，而在 3D 中，它是一千米。</paragraph>
        </note>
        <paragraph>那么来编写移动的代码。首先在 <literal>_physics_process()</literal> 中使用全局 <literal>Input</literal> 对象来计算输入方向向量。</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _physics_process(delta):
    # We create a local variable to store the input direction.
    var direction = Vector3.ZERO

    # We check for each move input and update the direction accordingly.
    if Input.is_action_pressed("move_right"):
        direction.x += 1
    if Input.is_action_pressed("move_left"):
        direction.x -= 1
    if Input.is_action_pressed("move_back"):
        # Notice how we are working with the vector's x and z axes.
        # In 3D, the XZ plane is the ground plane.
        direction.z += 1
    if Input.is_action_pressed("move_forward"):
        direction.z -= 1</literal_block>
            </div>
            <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _PhysicsProcess(double delta)
{
    // We create a local variable to store the input direction.
    var direction = Vector3.Zero;

    // We check for each move input and update the direction accordingly.
    if (Input.IsActionPressed("move_right"))
    {
        direction.X += 1.0f;
    }
    if (Input.IsActionPressed("move_left"))
    {
        direction.X -= 1.0f;
    }
    if (Input.IsActionPressed("move_back"))
    {
        // Notice how we are working with the vector's X and Z axes.
        // In 3D, the XZ plane is the ground plane.
        direction.Z += 1.0f;
    }
    if (Input.IsActionPressed("move_forward"))
    {
        direction.Z -= 1.0f;
    }
}</literal_block>
            </div>
        </container>
        <paragraph>在这里，我们将使用 <literal>_physics_process()</literal> 虚函数进行所有计算。与 <literal>_process()</literal> 一样，它允许你每帧更新节点，但它是专门为物理相关代码设计的，例如运动学物体或刚体。</paragraph>
        <seealso>
            <paragraph>要了解更多关于 <literal>_process()</literal> 和 <literal>_physics_process()</literal> 之间的区别，见 <reference internal="True" refuri="../../tutorials/scripting/idle_and_physics_processing#doc-idle-and-physics-processing"><inline classes="std std-ref">空闲处理与物理处理</inline></reference>。</paragraph>
        </seealso>
        <paragraph>我们首先将一个 <literal>direction</literal> 变量初始化为 <literal>Vector3.ZERO</literal>。然后，我们检查玩家是否正在按下一个或多个 <literal>move_*</literal> 输入，并相应地更新矢量的 <literal>x</literal> 和 <literal>z</literal> 分量。它们对应于地平面的轴。</paragraph>
        <paragraph>这四个条件给了我们八个可能性和八个可能的方向。</paragraph>
        <paragraph>如果玩家同时按下 W 键 和 D 键，这个向量长度大约为 <literal>1.4</literal>。但如果他们只按一个键，则它的长度将为 <literal>1</literal>。我们希望该向量的长度保持一致，而不是在对角线上移动得更快。为此，我们需调用其 <literal>normalize()</literal> 方法。</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">#func _physics_process(delta):
    #...

    if direction != Vector3.ZERO:
        direction = direction.normalized()
        # Setting the basis property will affect the rotation of the node.
        $Pivot.basis = Basis.looking_at(direction)</literal_block>
            </div>
            <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _PhysicsProcess(double delta)
{
    // ...

    if (direction != Vector3.Zero)
    {
        direction = direction.Normalized();
        // Setting the basis property will affect the rotation of the node.
        GetNode&lt;Node3D&gt;("Pivot").Basis = Basis.LookingAt(direction);
    }
}</literal_block>
            </div>
        </container>
        <paragraph>在这里，我们只在方向的长度大于零的情况下对向量进行归一化，因为玩家正在按某个方向键。</paragraph>
        <paragraph>通过创建一个朝 <literal>direction</literal> 方向搜寻的 <reference internal="True" refuri="../../classes/class_basis#class-basis"><inline classes="std std-ref">Basis</inline></reference> 来计算 <literal>$Pivot</literal> 所搜寻的方向。</paragraph>
        <paragraph>然后，更新速度。需要分别计算地面速度和下降速度。请确保 tab 缩进，使行在 <literal>_physics_process()</literal> 函数内部，而不在刚编写的条件外部。</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _physics_process(delta):
    #...
    if direction != Vector3.ZERO:
        #...

    # Ground Velocity
    target_velocity.x = direction.x * speed
    target_velocity.z = direction.z * speed

    # Vertical Velocity
    if not is_on_floor(): # If in the air, fall towards the floor. Literally gravity
        target_velocity.y = target_velocity.y - (fall_acceleration * delta)

    # Moving the Character
    velocity = target_velocity
    move_and_slide()</literal_block>
            </div>
            <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _PhysicsProcess(double delta)
{
    // ...
    if (direction != Vector3.Zero)
    {
        // ...
    }

    // Ground velocity
    _targetVelocity.X = direction.X * Speed;
    _targetVelocity.Z = direction.Z * Speed;

    // Vertical velocity
    if (!IsOnFloor()) // If in the air, fall towards the floor. Literally gravity
    {
        _targetVelocity.Y -= FallAcceleration * (float)delta;
    }

    // Moving the character
    Velocity = _targetVelocity;
    MoveAndSlide();
}</literal_block>
            </div>
        </container>
        <paragraph>如果物体在这一帧中与地板发生了碰撞，那么 <literal>CharacterBody3D.is_on_floor()</literal> 函数就会返回 <literal>true</literal>。这就是为什么我们只在空中对 <literal>Player</literal> 施加重力。</paragraph>
        <paragraph>对于垂直速度，在每一帧中减去下降加速度乘以增量时间（delta time，每个帧之间的时间，也称帧时间）。这条代码将使角色在没有在地板上或是碰撞地板的情况下，每帧都会下降。</paragraph>
        <paragraph>物理引擎只有在运动和碰撞发生的情况下才能检测到在某一帧中与墙壁、地板或其他物体的相互作用。我们将在后面使用这个属性来编写跳跃的代码。</paragraph>
        <paragraph>在最后一行，我们调用了 <literal>CharacterBody3D.move_and_slide()</literal>，这是 <literal>CharacterBody3D</literal> 类的一个强大方法，可以让你顺利地移动一个角色。如果它在运动过程中撞到了墙，引擎会试着为你把它进行平滑处理。它使用的是 <reference internal="True" refuri="../../classes/class_characterbody3d#class-characterbody3d"><inline classes="std std-ref">CharacterBody3D</inline></reference> 自带的<emphasis>速度</emphasis>值</paragraph>
        <comment xml:space="preserve">OLD TEXT: The function takes two parameters: our velocity and the up direction. It moves</comment>
        <comment xml:space="preserve">the character and returns a leftover velocity after applying collisions. When</comment>
        <comment xml:space="preserve">hitting the floor or a wall, the function will reduce or reset the speed in that</comment>
        <comment xml:space="preserve">direction from you. In our case, storing the function's returned value prevents</comment>
        <comment xml:space="preserve">the character from accumulating vertical momentum, which could otherwise get so</comment>
        <comment xml:space="preserve">big the character would move through the ground slab after a while.</comment>
        <paragraph>这就是你在地面上移动角色所需的所有代码。</paragraph>
        <paragraph>Here is the complete <literal>player.gd</literal> code for reference.</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

# How fast the player moves in meters per second.
@export var speed = 14
# The downward acceleration when in the air, in meters per second squared.
@export var fall_acceleration = 75

var target_velocity = Vector3.ZERO


func _physics_process(delta):
    var direction = Vector3.ZERO

    if Input.is_action_pressed("move_right"):
        direction.x += 1
    if Input.is_action_pressed("move_left"):
        direction.x -= 1
    if Input.is_action_pressed("move_back"):
        direction.z += 1
    if Input.is_action_pressed("move_forward"):
        direction.z -= 1

    if direction != Vector3.ZERO:
        direction = direction.normalized()
        $Pivot.basis = Basis.looking_at(direction)

    # Ground Velocity
    target_velocity.x = direction.x * speed
    target_velocity.z = direction.z * speed

    # Vertical Velocity
    if not is_on_floor(): # If in the air, fall towards the floor. Literally gravity
        target_velocity.y = target_velocity.y - (fall_acceleration * delta)

    # Moving the Character
    velocity = target_velocity
    move_and_slide()</literal_block>
            </div>
            <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Player : CharacterBody3D
{
    // How fast the player moves in meters per second.
    [Export]
    public int Speed { get; set; } = 14;
    // The downward acceleration when in the air, in meters per second squared.
    [Export]
    public int FallAcceleration { get; set; } = 75;

    private Vector3 _targetVelocity = Vector3.Zero;

    public override void _PhysicsProcess(double delta)
    {
        var direction = Vector3.Zero;

        if (Input.IsActionPressed("move_right"))
        {
            direction.X += 1.0f;
        }
        if (Input.IsActionPressed("move_left"))
        {
            direction.X -= 1.0f;
        }
        if (Input.IsActionPressed("move_back"))
        {
            direction.Z += 1.0f;
        }
        if (Input.IsActionPressed("move_forward"))
        {
            direction.Z -= 1.0f;
        }

        if (direction != Vector3.Zero)
        {
            direction = direction.Normalized();
            GetNode&lt;Node3D&gt;("Pivot").Basis = Basis.LookingAt(direction);
        }

        // Ground velocity
        _targetVelocity.X = direction.X * Speed;
        _targetVelocity.Z = direction.Z * Speed;

        // Vertical velocity
        if (!IsOnFloor()) // If in the air, fall towards the floor. Literally gravity
        {
            _targetVelocity.Y -= FallAcceleration * (float)delta;
        }

        // Moving the character
        Velocity = _targetVelocity;
        MoveAndSlide();
    }
}</literal_block>
            </div>
        </container>
        <section ids="testing-our-player-s-movement" names="testing\ our\ player's\ movement 测试玩家的移动">
            <title>测试玩家的移动</title>
            <paragraph>将玩家放在 <literal>Main</literal> 场景中进行测试，这时，需要先实例化玩家，然后添加相机。 3D 与 2D 不同，如果没有添加摄像机，你将无法看到任何物体。</paragraph>
            <paragraph>保存 <literal>Player</literal> 场景，然后打开 <literal>Main</literal> 场景。可以点击编辑器顶部的 <emphasis>Main</emphasis> 选项卡切换。</paragraph>
            <paragraph><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/02.clicking_main_tab.png'}" uri="getting_started/first_3d_game/img/03.player_movement_code/02.clicking_main_tab.png"></image></paragraph>
            <paragraph>如果场景之前已关闭，请转到 <emphasis>文件系统</emphasis> 面板，双击 <literal>main.tscn</literal> 文件重新打开。</paragraph>
            <paragraph>要实例化 <literal>Player</literal> ，可右键单击 <literal>Main</literal> 节点，然后选择 <emphasis>实例化子场景</emphasis> 。</paragraph>
            <paragraph><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/03.instance_child_scene.webp'}" uri="getting_started/first_3d_game/img/03.player_movement_code/03.instance_child_scene.webp"></image></paragraph>
            <paragraph>在弹出窗口中，双击 <literal>player.tscn</literal> ，角色将显示在视窗的中心。</paragraph>
            <section ids="adding-a-camera" names="adding\ a\ camera 添加摄像机">
                <title>添加摄像机</title>
                <paragraph>Let's add the camera next. Like we did with our <emphasis>Player</emphasis>'s <emphasis>Pivot</emphasis>, we're
                    going to create a basic rig. Right-click on the <literal>Main</literal> node again and select
                    <emphasis>Add Child Node</emphasis>. Create a new <reference internal="True" refuri="../../classes/class_marker3d#class-marker3d"><inline classes="std std-ref">Marker3D</inline></reference>, and name it <literal>CameraPivot</literal>.
                    Select <literal>CameraPivot</literal> and add a child node <reference internal="True" refuri="../../classes/class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference> to it.
                    Your scene tree should look similar to this.</paragraph>
                <paragraph><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/04.scene_tree_with_camera.webp'}" uri="getting_started/first_3d_game/img/03.player_movement_code/04.scene_tree_with_camera.webp"></image></paragraph>
                <paragraph>请注意在选中 <emphasis>Camera</emphasis> 时，左上角会出现一个<emphasis>预览</emphasis>复选框。你可以单击预览游戏中的摄像机投影视角。</paragraph>
                <paragraph><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/05.camera_preview_checkbox.png'}" uri="getting_started/first_3d_game/img/03.player_movement_code/05.camera_preview_checkbox.png"></image></paragraph>
                <paragraph>我们要使用 <emphasis>Pivot</emphasis> 来旋转摄像机，让他像被吊车吊起来一样。让我们先拆分 3D 视图，以便在进行自由移动的同时观察摄像机拍摄到的内容。</paragraph>
                <paragraph>在视口上方的工具栏中，单击<emphasis>视图</emphasis>，然后单击<emphasis>2 个视口</emphasis>。你也可以按 <literal classes="kbd">Ctrl + 2</literal>（macOS 上则为 <literal classes="kbd">Cmd + 2</literal>）。</paragraph>
                <paragraph><image alt="image11" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/12.viewport_change.webp'}" uri="getting_started/first_3d_game/img/03.player_movement_code/12.viewport_change.webp"></image></paragraph>
                <paragraph><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/06.two_viewports.png'}" uri="getting_started/first_3d_game/img/03.player_movement_code/06.two_viewports.png"></image></paragraph>
                <paragraph>在下面那个视图中，选中 <reference internal="True" refuri="../../classes/class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference>，然后勾选预览复选框打开摄像机预览。</paragraph>
                <paragraph><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/07.camera_preview_checkbox.png'}" uri="getting_started/first_3d_game/img/03.player_movement_code/07.camera_preview_checkbox.png"></image></paragraph>
                <paragraph>在上面那个视图中，选中摄像机后将它沿 Z 轴（蓝色）移动 <literal>19</literal> 个单位。</paragraph>
                <paragraph><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/08.camera_moved.png'}" uri="getting_started/first_3d_game/img/03.player_movement_code/08.camera_moved.png"></image></paragraph>
                <paragraph>接下来就是关键。选中 <emphasis>CameraPivot</emphasis> 并将其围绕 X 周旋转 <literal>-45</literal> 度（使用红色的圆圈）。你会看到摄像机就像是被连上了吊车一样移动。</paragraph>
                <paragraph><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/09.camera_rotated.png'}" uri="getting_started/first_3d_game/img/03.player_movement_code/09.camera_rotated.png"></image></paragraph>
                <paragraph>你可以按 <literal classes="kbd">F6</literal> 运行场景，然后按方向键来移动角色。</paragraph>
                <paragraph><image alt="image9" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/10.camera_perspective.png'}" uri="getting_started/first_3d_game/img/03.player_movement_code/10.camera_perspective.png"></image></paragraph>
                <paragraph>因为透视投影的缘故，我们会在角色的周围看到一些空白区域。在这个游戏中，我们要使用的是正交投影，从而更好地展示游戏区域，让玩家更易于识别距离。</paragraph>
                <paragraph>再次选中 <emphasis>Camera</emphasis>，然后在<emphasis>检查器</emphasis> 中将 <emphasis>Projection</emphasis>（投影）设为 <emphasis>Orthogonal</emphasis>（正交）、将 <emphasis>Size</emphasis>（大小）设为 <literal>19</literal>。角色现在看起来应该更加扁平，背景应该被地面充满。</paragraph>
                <note>
                    <paragraph>当在 Godot 4 中使用正交相机时，方向阴影的质量取决于相机的 <emphasis>Far</emphasis> 值。<emphasis>Far</emphasis> 越高，相机能够看到的距离就更远。然而由于更高的 <emphasis>Far</emphasis> 值会使得阴影渲染必须覆盖到更远的距离，这个操作也会导致阴影质量下降。</paragraph>
                    <paragraph>如果在切换到正交相机后方向阴影看起来变得模糊，请减小相机的 <emphasis>Far</emphasis> 属性到更低的值，如 <literal>100</literal> 。请不要将 <emphasis>Far</emphasis> 属性减小得太多，否则远处的物体将会开始消失。</paragraph>
                </note>
                <paragraph><image alt="image10" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/13.camera3d_values.webp'}" uri="getting_started/first_3d_game/img/03.player_movement_code/13.camera3d_values.webp"></image></paragraph>
                <paragraph>测试你的场景，你应该能够在所有 8 个方向上移动，并且不会穿过地板！</paragraph>
                <paragraph>这样，我们就完成了玩家的移动以及视图。接下来，我们要来处理怪物。</paragraph>
                <substitution_definition names="image0"><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/01.attach_script_to_player.webp'}" uri="getting_started/first_3d_game/img/03.player_movement_code/01.attach_script_to_player.webp"></image></substitution_definition>
                <substitution_definition names="image1"><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/02.clicking_main_tab.png'}" uri="getting_started/first_3d_game/img/03.player_movement_code/02.clicking_main_tab.png"></image></substitution_definition>
                <substitution_definition names="image2"><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/03.instance_child_scene.webp'}" uri="getting_started/first_3d_game/img/03.player_movement_code/03.instance_child_scene.webp"></image></substitution_definition>
                <substitution_definition names="image3"><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/04.scene_tree_with_camera.webp'}" uri="getting_started/first_3d_game/img/03.player_movement_code/04.scene_tree_with_camera.webp"></image></substitution_definition>
                <substitution_definition names="image4"><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/05.camera_preview_checkbox.png'}" uri="getting_started/first_3d_game/img/03.player_movement_code/05.camera_preview_checkbox.png"></image></substitution_definition>
                <substitution_definition names="image5"><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/06.two_viewports.png'}" uri="getting_started/first_3d_game/img/03.player_movement_code/06.two_viewports.png"></image></substitution_definition>
                <substitution_definition names="image6"><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/07.camera_preview_checkbox.png'}" uri="getting_started/first_3d_game/img/03.player_movement_code/07.camera_preview_checkbox.png"></image></substitution_definition>
                <substitution_definition names="image7"><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/08.camera_moved.png'}" uri="getting_started/first_3d_game/img/03.player_movement_code/08.camera_moved.png"></image></substitution_definition>
                <substitution_definition names="image8"><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/09.camera_rotated.png'}" uri="getting_started/first_3d_game/img/03.player_movement_code/09.camera_rotated.png"></image></substitution_definition>
                <substitution_definition names="image9"><image alt="image9" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/10.camera_perspective.png'}" uri="getting_started/first_3d_game/img/03.player_movement_code/10.camera_perspective.png"></image></substitution_definition>
                <substitution_definition names="image10"><image alt="image10" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/13.camera3d_values.webp'}" uri="getting_started/first_3d_game/img/03.player_movement_code/13.camera3d_values.webp"></image></substitution_definition>
                <substitution_definition names="image11"><image alt="image11" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/12.viewport_change.webp'}" uri="getting_started/first_3d_game/img/03.player_movement_code/12.viewport_change.webp"></image></substitution_definition>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
