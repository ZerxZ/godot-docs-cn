<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/first_3d_game/03.player_movement_code.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-first-3d-game-player-movement"></target>
    <section ids="moving-the-player-with-code doc-first-3d-game-player-movement" names="moving\ the\ player\ with\ code doc_first_3d_game_player_movement">
        <title>Moving the player with code</title>
        <paragraph>It's time to code! We're going to use the input actions we created in the last
            part to move the character.</paragraph>
        <note>
            <paragraph>For this project, we will be following the Godot naming conventions.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>GDScript</strong>: Classes (nodes) use PascalCase, variables and
                        functions use snake_case, and constants use ALL_CAPS (See
                        <reference internal="True" refuri="../../tutorials/scripting/gdscript/gdscript_styleguide#doc-gdscript-styleguide"><inline classes="std std-ref">GDScript style guide</inline></reference>).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>C#</strong>: Classes, export variables and methods use PascalCase,
                        private fields use _camelCase, local variables and parameters use
                        camelCase (See <reference internal="True" refuri="../../tutorials/scripting/c_sharp/c_sharp_style_guide#doc-c-sharp-styleguide"><inline classes="std std-ref">C# style guide</inline></reference>). Be careful to type
                        the method names precisely when connecting signals.</paragraph>
                </list_item>
            </bullet_list>
        </note>
        <paragraph>Right-click the <literal>Player</literal> node and select <emphasis>Attach Script</emphasis> to add a new script to
            it. In the popup, set the <emphasis>Template</emphasis> to <emphasis>Empty</emphasis> before pressing the <emphasis>Create</emphasis>
            button. We set it to <emphasis>Empty</emphasis> because we want to write our own code for
            player movement.</paragraph>
        <paragraph><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/01.attach_script_to_player.webp'}" original_uri="img/03.player_movement_code/01.attach_script_to_player.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/01.attach_script_to_player.webp"></image></paragraph>
        <paragraph>Let's start with the class's properties. We're going to define a movement speed,
            a fall acceleration representing gravity, and a velocity we'll use to move the
            character.</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

# How fast the player moves in meters per second.
@export var speed = 14
# The downward acceleration when in the air, in meters per second squared.
@export var fall_acceleration = 75

var target_velocity = Vector3.ZERO</literal_block>
            </div>
            <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Player : CharacterBody3D
{
    // Don't forget to rebuild the project so the editor knows about the new export variable.

    // How fast the player moves in meters per second.
    [Export]
    public int Speed { get; set; } = 14;
    // The downward acceleration when in the air, in meters per second squared.
    [Export]
    public int FallAcceleration { get; set; } = 75;

    private Vector3 _targetVelocity = Vector3.Zero;
}</literal_block>
            </div>
        </container>
        <paragraph>These are common properties for a moving body. The <literal>target_velocity</literal> is a <reference internal="True" refuri="../../classes/class_vector3#class-vector3"><inline classes="std std-ref">3D vector</inline></reference>
            combining a speed with a direction. Here, we define it as a property because
            we want to update and reuse its value across frames.</paragraph>
        <note>
            <paragraph>The values are quite different from 2D code because distances are in meters.
                While in 2D, a thousand units (pixels) may only correspond to half of your
                screen's width, in 3D, it's a kilometer.</paragraph>
        </note>
        <paragraph>Let's code the movement. We start by calculating the input direction vector
            using the global <literal>Input</literal> object, in <literal>_physics_process()</literal>.</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _physics_process(delta):
    # We create a local variable to store the input direction.
    var direction = Vector3.ZERO

    # We check for each move input and update the direction accordingly.
    if Input.is_action_pressed("move_right"):
        direction.x += 1
    if Input.is_action_pressed("move_left"):
        direction.x -= 1
    if Input.is_action_pressed("move_back"):
        # Notice how we are working with the vector's x and z axes.
        # In 3D, the XZ plane is the ground plane.
        direction.z += 1
    if Input.is_action_pressed("move_forward"):
        direction.z -= 1</literal_block>
            </div>
            <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _PhysicsProcess(double delta)
{
    // We create a local variable to store the input direction.
    var direction = Vector3.Zero;

    // We check for each move input and update the direction accordingly.
    if (Input.IsActionPressed("move_right"))
    {
        direction.X += 1.0f;
    }
    if (Input.IsActionPressed("move_left"))
    {
        direction.X -= 1.0f;
    }
    if (Input.IsActionPressed("move_back"))
    {
        // Notice how we are working with the vector's X and Z axes.
        // In 3D, the XZ plane is the ground plane.
        direction.Z += 1.0f;
    }
    if (Input.IsActionPressed("move_forward"))
    {
        direction.Z -= 1.0f;
    }
}</literal_block>
            </div>
        </container>
        <paragraph>Here, instead of <literal>_process()</literal>, we're going to make all calculations using the <literal>_physics_process()</literal>
            virtual function. It's designed specifically for physics-related code like moving a
            kinematic or rigid body. It updates the node using fixed time intervals.</paragraph>
        <seealso>
            <paragraph>To learn more about the difference between <literal>_process()</literal> and
                <literal>_physics_process()</literal>, see <reference internal="True" refuri="../../tutorials/scripting/idle_and_physics_processing#doc-idle-and-physics-processing"><inline classes="std std-ref">Idle and Physics Processing</inline></reference>.</paragraph>
        </seealso>
        <paragraph>We start by initializing a <literal>direction</literal> variable to <literal>Vector3.ZERO</literal>. Then, we
            check if the player is pressing one or more of the <literal>move_*</literal> inputs and update
            the vector's <literal>x</literal> and <literal>z</literal> components accordingly. These correspond to the
            ground plane's axes.</paragraph>
        <paragraph>These four conditions give us eight possibilities and eight possible directions.</paragraph>
        <paragraph>In case the player presses, say, both W and D simultaneously, the vector will
            have a length of about <literal>1.4</literal>. But if they press a single key, it will have a
            length of <literal>1</literal>. We want the vector's length to be consistent, and not move faster diagonally. To do so, we can
            call its <literal>normalized()</literal> method.</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _physics_process(delta):
    #...

    if direction != Vector3.ZERO:
        direction = direction.normalized()
        # Setting the basis property will affect the rotation of the node.
        $Pivot.basis = Basis.looking_at(direction)</literal_block>
            </div>
            <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _PhysicsProcess(double delta)
{
    // ...

    if (direction != Vector3.Zero)
    {
        direction = direction.Normalized();
        // Setting the basis property will affect the rotation of the node.
        GetNode&lt;Node3D&gt;("Pivot").Basis = Basis.LookingAt(direction);
    }
}</literal_block>
            </div>
        </container>
        <paragraph>Here, we only normalize the vector if the direction has a length greater than
            zero, which means the player is pressing a direction key.</paragraph>
        <paragraph>We compute the direction the <literal>$Pivot</literal> is looking by creating a <reference internal="True" refuri="../../classes/class_basis#class-basis"><inline classes="std std-ref">Basis</inline></reference>
            that looks in the <literal>direction</literal> direction.</paragraph>
        <paragraph>Then, we update the velocity. We have to calculate the ground velocity and the
            fall speed separately. Be sure to go back one tab so the lines are inside the
            <literal>_physics_process()</literal> function but outside the condition we just wrote above.</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _physics_process(delta):
    #...
    if direction != Vector3.ZERO:
        #...

    # Ground Velocity
    target_velocity.x = direction.x * speed
    target_velocity.z = direction.z * speed

    # Vertical Velocity
    if not is_on_floor(): # If in the air, fall towards the floor. Literally gravity
        target_velocity.y = target_velocity.y - (fall_acceleration * delta)

    # Moving the Character
    velocity = target_velocity
    move_and_slide()</literal_block>
            </div>
            <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _PhysicsProcess(double delta)
{
    // ...
    if (direction != Vector3.Zero)
    {
        // ...
    }

    // Ground velocity
    _targetVelocity.X = direction.X * Speed;
    _targetVelocity.Z = direction.Z * Speed;

    // Vertical velocity
    if (!IsOnFloor()) // If in the air, fall towards the floor. Literally gravity
    {
        _targetVelocity.Y -= FallAcceleration * (float)delta;
    }

    // Moving the character
    Velocity = _targetVelocity;
    MoveAndSlide();
}</literal_block>
            </div>
        </container>
        <paragraph>The <literal>CharacterBody3D.is_on_floor()</literal> function returns <literal>true</literal> if the body collided with the floor in this frame. That's why
            we apply gravity to the <literal>Player</literal> only while it is in the air.</paragraph>
        <paragraph>For the vertical velocity, we subtract the fall acceleration multiplied by the
            delta time every frame.
            This line of code will cause our character to fall in every frame, as long as it is not on or colliding with the floor.</paragraph>
        <paragraph>The physics engine can only detect interactions with walls, the floor, or other
            bodies during a given frame if movement and collisions happen. We will use this
            property later to code the jump.</paragraph>
        <paragraph>On the last line, we call <literal>CharacterBody3D.move_and_slide()</literal> which is a powerful
            method of the <literal>CharacterBody3D</literal> class that allows you to move a character
            smoothly. If it hits a wall midway through a motion, the engine will try to
            smooth it out for you. It uses the <emphasis>velocity</emphasis> value native to the <reference internal="True" refuri="../../classes/class_characterbody3d#class-characterbody3d"><inline classes="std std-ref">CharacterBody3D</inline></reference></paragraph>
        <comment xml:space="preserve">OLD TEXT: The function takes two parameters: our velocity and the up direction. It moves</comment>
        <comment xml:space="preserve">the character and returns a leftover velocity after applying collisions. When</comment>
        <comment xml:space="preserve">hitting the floor or a wall, the function will reduce or reset the speed in that</comment>
        <comment xml:space="preserve">direction from you. In our case, storing the function's returned value prevents</comment>
        <comment xml:space="preserve">the character from accumulating vertical momentum, which could otherwise get so</comment>
        <comment xml:space="preserve">big the character would move through the ground slab after a while.</comment>
        <paragraph>And that's all the code you need to move the character on the floor.</paragraph>
        <paragraph>Here is the complete <literal>player.gd</literal> code for reference.</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CharacterBody3D

# How fast the player moves in meters per second.
@export var speed = 14
# The downward acceleration when in the air, in meters per second squared.
@export var fall_acceleration = 75

var target_velocity = Vector3.ZERO


func _physics_process(delta):
    var direction = Vector3.ZERO

    if Input.is_action_pressed("move_right"):
        direction.x += 1
    if Input.is_action_pressed("move_left"):
        direction.x -= 1
    if Input.is_action_pressed("move_back"):
        direction.z += 1
    if Input.is_action_pressed("move_forward"):
        direction.z -= 1

    if direction != Vector3.ZERO:
        direction = direction.normalized()
        # Setting the basis property will affect the rotation of the node.
        $Pivot.basis = Basis.looking_at(direction)

    # Ground Velocity
    target_velocity.x = direction.x * speed
    target_velocity.z = direction.z * speed

    # Vertical Velocity
    if not is_on_floor(): # If in the air, fall towards the floor. Literally gravity
        target_velocity.y = target_velocity.y - (fall_acceleration * delta)

    # Moving the Character
    velocity = target_velocity
    move_and_slide()</literal_block>
            </div>
            <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Player : CharacterBody3D
{
    // How fast the player moves in meters per second.
    [Export]
    public int Speed { get; set; } = 14;
    // The downward acceleration when in the air, in meters per second squared.
    [Export]
    public int FallAcceleration { get; set; } = 75;

    private Vector3 _targetVelocity = Vector3.Zero;

    public override void _PhysicsProcess(double delta)
    {
        var direction = Vector3.Zero;

        if (Input.IsActionPressed("move_right"))
        {
            direction.X += 1.0f;
        }
        if (Input.IsActionPressed("move_left"))
        {
            direction.X -= 1.0f;
        }
        if (Input.IsActionPressed("move_back"))
        {
            direction.Z += 1.0f;
        }
        if (Input.IsActionPressed("move_forward"))
        {
            direction.Z -= 1.0f;
        }

        if (direction != Vector3.Zero)
        {
            direction = direction.Normalized();
            // Setting the basis property will affect the rotation of the node.
            GetNode&lt;Node3D&gt;("Pivot").Basis = Basis.LookingAt(direction);
        }

        // Ground velocity
        _targetVelocity.X = direction.X * Speed;
        _targetVelocity.Z = direction.Z * Speed;

        // Vertical velocity
        if (!IsOnFloor()) // If in the air, fall towards the floor. Literally gravity
        {
            _targetVelocity.Y -= FallAcceleration * (float)delta;
        }

        // Moving the character
        Velocity = _targetVelocity;
        MoveAndSlide();
    }
}</literal_block>
            </div>
        </container>
        <section ids="testing-our-player-s-movement" names="testing\ our\ player's\ movement">
            <title>Testing our player's movement</title>
            <paragraph>We're going to put our player in the <literal>Main</literal> scene to test it. To do so, we need
                to instantiate the player and then add a camera. Unlike in 2D, in 3D, you won't
                see anything if your viewport doesn't have a camera pointing at something.</paragraph>
            <paragraph>Save your <literal>Player</literal> scene and open the <literal>Main</literal> scene. You can click on the <emphasis>Main</emphasis>
                tab at the top of the editor to do so.</paragraph>
            <paragraph><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/02.clicking_main_tab.webp'}" original_uri="img/03.player_movement_code/02.clicking_main_tab.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/02.clicking_main_tab.webp"></image></paragraph>
            <paragraph>If you closed the scene before, head to the <emphasis>FileSystem</emphasis> dock and double-click
                <literal>main.tscn</literal> to re-open it.</paragraph>
            <paragraph>To instantiate the <literal>Player</literal>, right-click on the <literal>Main</literal> node and select <emphasis>Instantiate
                    Child Scene</emphasis>.</paragraph>
            <paragraph><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/03.instance_child_scene.webp'}" original_uri="img/03.player_movement_code/03.instance_child_scene.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/03.instance_child_scene.webp"></image></paragraph>
            <paragraph>In the popup, double-click <literal>player.tscn</literal>. The character should appear in the
                center of the viewport.</paragraph>
            <section ids="adding-a-camera" names="adding\ a\ camera">
                <title>Adding a camera</title>
                <paragraph>Let's add the camera next. Like we did with our <emphasis>Player</emphasis>'s <emphasis>Pivot</emphasis>, we're
                    going to create a basic rig. Right-click on the <literal>Main</literal> node again and select
                    <emphasis>Add Child Node</emphasis>. Create a new <reference internal="True" refuri="../../classes/class_marker3d#class-marker3d"><inline classes="std std-ref">Marker3D</inline></reference>, and name it <literal>CameraPivot</literal>.
                    Select <literal>CameraPivot</literal> and add a child node <reference internal="True" refuri="../../classes/class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference> to it.
                    Your scene tree should look similar to this.</paragraph>
                <paragraph><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/04.scene_tree_with_camera.webp'}" original_uri="img/03.player_movement_code/04.scene_tree_with_camera.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/04.scene_tree_with_camera.webp"></image></paragraph>
                <paragraph>Notice the <emphasis>Preview</emphasis> checkbox that appears in the top-left of the 3D view when you
                    have the <emphasis>Camera</emphasis> selected. You can click it to preview the in-game camera projection.</paragraph>
                <paragraph><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/05.camera_preview_checkbox.webp'}" original_uri="img/03.player_movement_code/05.camera_preview_checkbox.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/05.camera_preview_checkbox.webp"></image></paragraph>
                <paragraph>We're going to use the <emphasis>Pivot</emphasis> to rotate the camera as if it was on a crane.
                    Let's first split the 3D view to be able to freely navigate the scene and see
                    what the camera sees.</paragraph>
                <paragraph>In the toolbar right above the viewport, click on <emphasis>View</emphasis>, then <emphasis>2 Viewports</emphasis>.
                    You can also press <literal classes="kbd">Ctrl + 2</literal> (<literal classes="kbd">Cmd + 2</literal> on macOS).</paragraph>
                <paragraph><image alt="image11" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/12.viewport_change.webp'}" original_uri="img/03.player_movement_code/12.viewport_change.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/12.viewport_change.webp"></image></paragraph>
                <paragraph><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/06.two_viewports.webp'}" original_uri="img/03.player_movement_code/06.two_viewports.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/06.two_viewports.webp"></image></paragraph>
                <paragraph>On the bottom view, select your <reference internal="True" refuri="../../classes/class_camera3d#class-camera3d"><inline classes="std std-ref">Camera3D</inline></reference> and turn on camera
                    Preview by clicking the checkbox.</paragraph>
                <paragraph><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/07.camera_preview_checkbox.webp'}" original_uri="img/03.player_movement_code/07.camera_preview_checkbox.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/07.camera_preview_checkbox.webp"></image></paragraph>
                <paragraph>In the top view, make sure your <emphasis>Camera3D</emphasis> is selected and move the camera about
                    <literal>19</literal> units on the Z axis (drag the blue arrow).</paragraph>
                <paragraph><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/08.camera_moved.png'}" original_uri="img/03.player_movement_code/08.camera_moved.png" uri="getting_started/first_3d_game/img/03.player_movement_code/08.camera_moved.png"></image></paragraph>
                <paragraph>Here's where the magic happens. Select the <emphasis>CameraPivot</emphasis> and rotate it <literal>-45</literal>
                    degrees around the X axis (using the red circle). You'll see the camera move as
                    if it was attached to a crane.</paragraph>
                <paragraph><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/09.camera_rotated.png'}" original_uri="img/03.player_movement_code/09.camera_rotated.png" uri="getting_started/first_3d_game/img/03.player_movement_code/09.camera_rotated.png"></image></paragraph>
                <paragraph>You can run the scene by pressing <literal classes="kbd">F6</literal> (<literal classes="kbd">Cmd + R</literal> on macOS) and
                    press the arrow keys to move the character.</paragraph>
                <paragraph><image alt="image9" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/10.camera_perspective.png'}" original_uri="img/03.player_movement_code/10.camera_perspective.png" uri="getting_started/first_3d_game/img/03.player_movement_code/10.camera_perspective.png"></image></paragraph>
                <paragraph>We can see some empty space around the character due to the perspective
                    projection. In this game, we're going to use an orthographic projection instead
                    to better frame the gameplay area and make it easier for the player to read
                    distances.</paragraph>
                <paragraph>Select the <emphasis>Camera</emphasis> again and in the <emphasis>Inspector</emphasis>, set the <emphasis>Projection</emphasis> to
                    <emphasis>Orthogonal</emphasis> and the <emphasis>Size</emphasis> to <literal>19</literal>. The character should now look flatter and
                    the ground should fill the background.</paragraph>
                <note>
                    <paragraph>When using an orthogonal camera in Godot 4, directional shadow quality is
                        dependent on the camera's <emphasis>Far</emphasis> value. The higher the <emphasis>Far</emphasis> value, the
                        further away the camera will be able to see. However, higher <emphasis>Far</emphasis> values
                        also decrease shadow quality as the shadow rendering has to cover a greater
                        distance.</paragraph>
                    <paragraph>If directional shadows look too blurry after switching to an orthogonal
                        camera, decrease the camera's <emphasis>Far</emphasis> property to a lower value such as
                        <literal>100</literal>. Don't decrease this <emphasis>Far</emphasis> property too much, or objects in the
                        distance will start disappearing.</paragraph>
                </note>
                <paragraph><image alt="image10" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/13.camera3d_values.webp'}" original_uri="img/03.player_movement_code/13.camera3d_values.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/13.camera3d_values.webp"></image></paragraph>
                <paragraph>Test your scene and you should be able to move in all 8 directions and not glitch through the floor!</paragraph>
                <paragraph>Ultimately, we have both player movement and the view in place. Next, we will
                    work on the monsters.</paragraph>
                <substitution_definition names="image0"><image alt="image0" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/01.attach_script_to_player.webp'}" original_uri="img/03.player_movement_code/01.attach_script_to_player.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/01.attach_script_to_player.webp"></image></substitution_definition>
                <substitution_definition names="image1"><image alt="image1" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/02.clicking_main_tab.webp'}" original_uri="img/03.player_movement_code/02.clicking_main_tab.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/02.clicking_main_tab.webp"></image></substitution_definition>
                <substitution_definition names="image2"><image alt="image2" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/03.instance_child_scene.webp'}" original_uri="img/03.player_movement_code/03.instance_child_scene.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/03.instance_child_scene.webp"></image></substitution_definition>
                <substitution_definition names="image3"><image alt="image3" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/04.scene_tree_with_camera.webp'}" original_uri="img/03.player_movement_code/04.scene_tree_with_camera.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/04.scene_tree_with_camera.webp"></image></substitution_definition>
                <substitution_definition names="image4"><image alt="image4" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/05.camera_preview_checkbox.webp'}" original_uri="img/03.player_movement_code/05.camera_preview_checkbox.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/05.camera_preview_checkbox.webp"></image></substitution_definition>
                <substitution_definition names="image5"><image alt="image5" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/06.two_viewports.webp'}" original_uri="img/03.player_movement_code/06.two_viewports.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/06.two_viewports.webp"></image></substitution_definition>
                <substitution_definition names="image6"><image alt="image6" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/07.camera_preview_checkbox.webp'}" original_uri="img/03.player_movement_code/07.camera_preview_checkbox.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/07.camera_preview_checkbox.webp"></image></substitution_definition>
                <substitution_definition names="image7"><image alt="image7" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/08.camera_moved.png'}" original_uri="img/03.player_movement_code/08.camera_moved.png" uri="getting_started/first_3d_game/img/03.player_movement_code/08.camera_moved.png"></image></substitution_definition>
                <substitution_definition names="image8"><image alt="image8" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/09.camera_rotated.png'}" original_uri="img/03.player_movement_code/09.camera_rotated.png" uri="getting_started/first_3d_game/img/03.player_movement_code/09.camera_rotated.png"></image></substitution_definition>
                <substitution_definition names="image9"><image alt="image9" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/10.camera_perspective.png'}" original_uri="img/03.player_movement_code/10.camera_perspective.png" uri="getting_started/first_3d_game/img/03.player_movement_code/10.camera_perspective.png"></image></substitution_definition>
                <substitution_definition names="image10"><image alt="image10" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/13.camera3d_values.webp'}" original_uri="img/03.player_movement_code/13.camera3d_values.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/13.camera3d_values.webp"></image></substitution_definition>
                <substitution_definition names="image11"><image alt="image11" candidates="{'*': 'getting_started/first_3d_game/img/03.player_movement_code/12.viewport_change.webp'}" original_uri="img/03.player_movement_code/12.viewport_change.webp" uri="getting_started/first_3d_game/img/03.player_movement_code/12.viewport_change.webp"></image></substitution_definition>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
