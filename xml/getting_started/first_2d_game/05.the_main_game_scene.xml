<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/first_2d_game/05.the_main_game_scene.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-your-first-2d-game-the-main-game-scene"></target>
    <section ids="the-main-game-scene doc-your-first-2d-game-the-main-game-scene" names="the\ main\ game\ scene doc_your_first_2d_game_the_main_game_scene">
        <title>The main game scene</title>
        <paragraph>Now it's time to bring everything we did together into a playable game scene.</paragraph>
        <paragraph>Create a new scene and add a <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> named <literal>Main</literal>.
            (The reason we are using Node instead of Node2D is because this node will
            be a container for handling game logic. It does not require 2D functionality itself.)</paragraph>
        <paragraph>Click the <strong>Instance</strong> button (represented by a chain link icon) and select your saved
            <literal>player.tscn</literal>.</paragraph>
        <image candidates="{'*': 'getting_started/first_2d_game/img/instance_scene.webp'}" original_uri="img/instance_scene.webp" uri="getting_started/first_2d_game/img/instance_scene.webp"></image>
        <paragraph>Now, add the following nodes as children of <literal>Main</literal>, and name them as shown:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><reference internal="True" refuri="../../classes/class_timer#class-timer"><inline classes="std std-ref">Timer</inline></reference> (named <literal>MobTimer</literal>) - to control how often mobs
                    spawn</paragraph>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="../../classes/class_timer#class-timer"><inline classes="std std-ref">Timer</inline></reference> (named <literal>ScoreTimer</literal>) - to increment the score
                    every second</paragraph>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="../../classes/class_timer#class-timer"><inline classes="std std-ref">Timer</inline></reference> (named <literal>StartTimer</literal>) - to give a delay before
                    starting</paragraph>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="../../classes/class_marker2d#class-marker2d"><inline classes="std std-ref">Marker2D</inline></reference> (named <literal>StartPosition</literal>) - to indicate
                    the player's start position</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>Set the <literal>Wait Time</literal> property of each of the <literal>Timer</literal> nodes as follows (values are in seconds):</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><literal>MobTimer</literal>: <literal>0.5</literal></paragraph>
            </list_item>
            <list_item>
                <paragraph><literal>ScoreTimer</literal>: <literal>1</literal></paragraph>
            </list_item>
            <list_item>
                <paragraph><literal>StartTimer</literal>: <literal>2</literal></paragraph>
            </list_item>
        </bullet_list>
        <paragraph>In addition, set the <literal>One Shot</literal> property of <literal>StartTimer</literal> to "On" and set
            <literal>Position</literal> of the <literal>StartPosition</literal> node to <literal>(240, 450)</literal>.</paragraph>
        <section ids="spawning-mobs" names="spawning\ mobs">
            <title>Spawning mobs</title>
            <paragraph>The Main node will be spawning new mobs, and we want them to appear at a random
                location on the edge of the screen. Click the <literal>Main</literal> node in the Scene dock, then
                add a child <reference internal="True" refuri="../../classes/class_path2d#class-path2d"><inline classes="std std-ref">Path2D</inline></reference> node named <literal>MobPath</literal>. When you select
                <literal>Path2D</literal>, you will see some new buttons at the top of the editor:</paragraph>
            <image candidates="{'*': 'getting_started/first_2d_game/img/path2d_buttons.webp'}" original_uri="img/path2d_buttons.webp" uri="getting_started/first_2d_game/img/path2d_buttons.webp"></image>
            <paragraph>Select the middle one ("Add Point") and draw the path by clicking to add the
                points at the corners shown. To have the points snap to the grid, make sure "Use
                Grid Snap" and "Use Smart Snap" are both selected. These options can be found to the
                left of the "Lock" button, appearing as a magnet next to some dots and
                intersecting lines, respectively.</paragraph>
            <image candidates="{'*': 'getting_started/first_2d_game/img/grid_snap_button.webp'}" original_uri="img/grid_snap_button.webp" uri="getting_started/first_2d_game/img/grid_snap_button.webp"></image>
            <important>
                <paragraph>Draw the path in <emphasis>clockwise</emphasis> order, or your mobs will spawn
                    pointing <emphasis>outwards</emphasis> instead of <emphasis>inwards</emphasis>!</paragraph>
            </important>
            <image candidates="{'*': 'getting_started/first_2d_game/img/draw_path2d.gif'}" original_uri="img/draw_path2d.gif" uri="getting_started/first_2d_game/img/draw_path2d.gif"></image>
            <paragraph>After placing point <literal>4</literal> in the image, click the "Close Curve" button and your
                curve will be complete.</paragraph>
            <paragraph>Now that the path is defined, add a <reference internal="True" refuri="../../classes/class_pathfollow2d#class-pathfollow2d"><inline classes="std std-ref">PathFollow2D</inline></reference>
                node as a child of <literal>MobPath</literal> and name it <literal>MobSpawnLocation</literal>. This node will
                automatically rotate and follow the path as it moves, so we can use it to select
                a random position and direction along the path.</paragraph>
            <paragraph>Your scene should look like this:</paragraph>
            <image candidates="{'*': 'getting_started/first_2d_game/img/main_scene_nodes.webp'}" original_uri="img/main_scene_nodes.webp" uri="getting_started/first_2d_game/img/main_scene_nodes.webp"></image>
        </section>
        <section ids="main-script" names="main\ script">
            <title>Main script</title>
            <paragraph>Add a script to <literal>Main</literal>. At the top of the script, we use
                <literal>@export var mob_scene: PackedScene</literal> to allow us to choose the Mob scene we want
                to instance.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node

@export var mob_scene: PackedScene
var score</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class Main : Node
{
    // Don't forget to rebuild the project so the editor knows about the new export variable.

    [Export]
    public PackedScene MobScene { get; set; }

    private int _score;
}</literal_block>
                </div>
            </container>
            <paragraph>Click the <literal>Main</literal> node and you will see the <literal>Mob Scene</literal> property in the Inspector
                under "Main.gd".</paragraph>
            <paragraph>You can assign this property's value in two ways:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Drag <literal>mob.tscn</literal> from the "FileSystem" dock and drop it in the <strong>Mob Scene</strong>
                        property.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Click the down arrow next to "[empty]" and choose "Load". Select <literal>mob.tscn</literal>.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Next, select the instance of the <literal>Player</literal> scene under <literal>Main</literal> node in the Scene dock,
                and access the Node dock on the sidebar. Make sure to have the Signals tab selected
                in the Node dock.</paragraph>
            <paragraph>You should see a list of the signals for the <literal>Player</literal> node. Find and
                double-click the <literal>hit</literal> signal in the list (or right-click it and select
                "Connect..."). This will open the signal connection dialog. We want to make a
                new function named <literal>game_over</literal>, which will handle what needs to happen when a
                game ends. Type "game_over" in the "Receiver Method" box at the bottom of the
                signal connection dialog and click "Connect". You are aiming to have the <literal>hit</literal> signal
                emitted from <literal>Player</literal> and handled in the <literal>Main</literal> script. Add the following code
                to the new function, as well as a <literal>new_game</literal> function that will set
                everything up for a new game:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func game_over():
    $ScoreTimer.stop()
    $MobTimer.stop()

func new_game():
    score = 0
    $Player.start($StartPosition.position)
    $StartTimer.start()</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void GameOver()
{
    GetNode&lt;Timer&gt;("MobTimer").Stop();
    GetNode&lt;Timer&gt;("ScoreTimer").Stop();
}

public void NewGame()
{
    _score = 0;

    var player = GetNode&lt;Player&gt;("Player");
    var startPosition = GetNode&lt;Marker2D&gt;("StartPosition");
    player.Start(startPosition.Position);

    GetNode&lt;Timer&gt;("StartTimer").Start();
}</literal_block>
                </div>
            </container>
            <paragraph>Now we'll connect the <literal>timeout()</literal> signal of each Timer node (<literal>StartTimer</literal>,
                <literal>ScoreTimer</literal>, and <literal>MobTimer</literal>) to the main script. For each of the three
                timers, select the timer in the Scene dock, open the Signals tab of the Node
                dock, then double-click the <literal>timeout()</literal> signal in the list. This will open a new
                signal connection dialog. The default settings in this dialog should be fine, so
                select <strong>Connect</strong> to create a new signal connection.</paragraph>
            <paragraph>Once all three timers have this set up, you should be able to see each timer
                have a Signal connection for their respective <literal>timeout()</literal> signal, showing in
                green, within their respective Signals tabs:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>(For MobTimer): <literal>_on_mob_timer_timeout()</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph>(For ScoreTimer): <literal>_on_score_timer_timeout()</literal></paragraph>
                </list_item>
                <list_item>
                    <paragraph>(For StartTimer): <literal>_on_start_timer_timeout()</literal></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Now we define how each of these timers operate by adding the code below. Notice
                that <literal>StartTimer</literal> will start the other two timers, and that <literal>ScoreTimer</literal>
                will increment the score by 1.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_score_timer_timeout():
    score += 1

func _on_start_timer_timeout():
    $MobTimer.start()
    $ScoreTimer.start()</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// We also specified this function name in PascalCase in the editor's connection window.
private void OnScoreTimerTimeout()
{
    _score++;
}

// We also specified this function name in PascalCase in the editor's connection window.
private void OnStartTimerTimeout()
{
    GetNode&lt;Timer&gt;("MobTimer").Start();
    GetNode&lt;Timer&gt;("ScoreTimer").Start();
}</literal_block>
                </div>
            </container>
            <paragraph>In <literal>_on_mob_timer_timeout()</literal>, we will create a mob instance, pick a random
                starting location along the <literal>Path2D</literal>, and set the mob in motion. The
                <literal>PathFollow2D</literal> node will automatically rotate as it follows the path, so we
                will use that to select the mob's direction as well as its position.
                When we spawn a mob, we'll pick a random value between <literal>150.0</literal> and
                <literal>250.0</literal> for how fast each mob will move (it would be boring if they were
                all moving at the same speed).</paragraph>
            <paragraph>Note that a new instance must be added to the scene using <literal>add_child()</literal>.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_mob_timer_timeout():
    # Create a new instance of the Mob scene.
    var mob = mob_scene.instantiate()

    # Choose a random location on Path2D.
    var mob_spawn_location = $MobPath/MobSpawnLocation
    mob_spawn_location.progress_ratio = randf()

    # Set the mob's position to the random location.
    mob.position = mob_spawn_location.position

    # Set the mob's direction perpendicular to the path direction.
    var direction = mob_spawn_location.rotation + PI / 2

    # Add some randomness to the direction.
    direction += randf_range(-PI / 4, PI / 4)
    mob.rotation = direction

    # Choose the velocity for the mob.
    var velocity = Vector2(randf_range(150.0, 250.0), 0.0)
    mob.linear_velocity = velocity.rotated(direction)

    # Spawn the mob by adding it to the Main scene.
    add_child(mob)</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// We also specified this function name in PascalCase in the editor's connection window.
private void OnMobTimerTimeout()
{
    // Create a new instance of the Mob scene.
    Mob mob = MobScene.Instantiate&lt;Mob&gt;();

    // Choose a random location on Path2D.
    var mobSpawnLocation = GetNode&lt;PathFollow2D&gt;("MobPath/MobSpawnLocation");
    mobSpawnLocation.ProgressRatio = GD.Randf();

    // Set the mob's direction perpendicular to the path direction.
    float direction = mobSpawnLocation.Rotation + Mathf.Pi / 2;

    // Set the mob's position to a random location.
    mob.Position = mobSpawnLocation.Position;

    // Add some randomness to the direction.
    direction += (float)GD.RandRange(-Mathf.Pi / 4, Mathf.Pi / 4);
    mob.Rotation = direction;

    // Choose the velocity.
    var velocity = new Vector2((float)GD.RandRange(150.0, 250.0), 0);
    mob.LinearVelocity = velocity.Rotated(direction);

    // Spawn the mob by adding it to the Main scene.
    AddChild(mob);
}</literal_block>
                </div>
            </container>
            <important>
                <paragraph>Why <literal>PI</literal>? In functions requiring angles, Godot uses <emphasis>radians</emphasis>,
                    not degrees. Pi represents a half turn in radians, about
                    <literal>3.1415</literal> (there is also <literal>TAU</literal> which is equal to <literal>2 * PI</literal>).
                    If you're more comfortable working with degrees, you'll need to
                    use the <literal>deg_to_rad()</literal> and <literal>rad_to_deg()</literal> functions to
                    convert between the two.</paragraph>
            </important>
        </section>
        <section ids="testing-the-scene" names="testing\ the\ scene">
            <title>Testing the scene</title>
            <paragraph>Let's test the scene to make sure everything is working. Add this <literal>new_game</literal>
                call to <literal>_ready()</literal>:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    new_game()</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    NewGame();
}</literal_block>
                </div>
            </container>
            <paragraph>Let's also assign <literal>Main</literal> as our "Main Scene" - the one that runs automatically
                when the game launches. Press the "Play" button and select <literal>main.tscn</literal> when
                prompted.</paragraph>
            <tip>
                <paragraph>If you had already set another scene as the "Main Scene", you can right
                    click <literal>main.tscn</literal> in the FileSystem dock and select "Set As Main Scene".</paragraph>
            </tip>
            <paragraph>You should be able to move the player around, see mobs spawning, and see the
                player disappear when hit by a mob.</paragraph>
            <paragraph>When you're sure everything is working, remove the call to <literal>new_game()</literal> from
                <literal>_ready()</literal> and replace it with <literal>pass</literal>.</paragraph>
            <paragraph>What's our game lacking? Some user interface. In the next lesson, we'll add a
                title screen and display the player's score.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
