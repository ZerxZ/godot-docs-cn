<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/first_2d_game/06.heads_up_display.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-your-first-2d-game-heads-up-display"></target>
    <section ids="heads-up-display doc-your-first-2d-game-heads-up-display" names="heads\ up\ display 游戏信息显示 doc_your_first_2d_game_heads_up_display">
        <title>游戏信息显示</title>
        <paragraph>我们的游戏最后还需要用户界面（User Interface，UI），显示分数、“游戏结束”信息、重启按钮。</paragraph>
        <paragraph>创建新场景，点击“其他节点”按钮，然后添加一个 <reference internal="True" refuri="../../classes/class_canvaslayer#class-canvaslayer"><inline classes="std std-ref">CanvasLayer</inline></reference> 节点并命名为 <literal>HUD</literal>。“HUD”是“heads-up display”（游戏信息显示）的缩写，是覆盖在游戏视图上显示的信息。</paragraph>
        <paragraph><reference internal="True" refuri="../../classes/class_canvaslayer#class-canvaslayer"><inline classes="std std-ref">CanvasLayer</inline></reference> 节点可以让我们在游戏的其他部分的上一层绘制 UI 元素，这样它所显示的信息就不会被任何游戏元素（如玩家或敌人）所覆盖。</paragraph>
        <paragraph>HUD 中需要显示以下信息：</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>得分，由 <literal>ScoreTimer</literal> 更改。</paragraph>
            </list_item>
            <list_item>
                <paragraph>消息，例如“Game Over”或“Get Ready!”</paragraph>
            </list_item>
            <list_item>
                <paragraph>“Start”按钮来开始游戏。</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>UI 元素的基本节点是 <reference internal="True" refuri="../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 。要创建 UI，我们需使用 <reference internal="True" refuri="../../classes/class_control#class-control"><inline classes="std std-ref">Control</inline></reference> 下的两种节点：<reference internal="True" refuri="../../classes/class_label#class-label"><inline classes="std std-ref">Label</inline></reference> 和 <reference internal="True" refuri="../../classes/class_button#class-button"><inline classes="std std-ref">Button</inline></reference>。</paragraph>
        <paragraph>创建以下节点作为 <literal>HUD</literal> 的子节点：</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph>名为分数标签 <literal>ScoreLabel</literal> 的 <reference internal="True" refuri="../../classes/class_label#class-label"><inline classes="std std-ref">Label</inline></reference>。</paragraph>
            </list_item>
            <list_item>
                <paragraph>名为消息 <literal>Message</literal> 的 <reference internal="True" refuri="../../classes/class_label#class-label"><inline classes="std std-ref">Label</inline></reference>。</paragraph>
            </list_item>
            <list_item>
                <paragraph>名为开始按钮 <literal>StartButton</literal> 的 <reference internal="True" refuri="../../classes/class_button#class-button"><inline classes="std std-ref">Button</inline></reference>。</paragraph>
            </list_item>
            <list_item>
                <paragraph>名为信息计数器 <literal>MessageTimer</literal> 的 <reference internal="True" refuri="../../classes/class_timer#class-timer"><inline classes="std std-ref">Timer</inline></reference>。</paragraph>
            </list_item>
        </bullet_list>
        <paragraph>点击 <literal>ScoreLabel</literal> 并在“检查器”的 <literal>Text</literal> 字段中键入一个数字。 <literal>Control</literal> 节点的默认字体很小，不能很好地缩放。游戏资产包中有一个叫作“Xolonium-Regular.ttf”的字体文件。 使用此字体需要执行以下操作：</paragraph>
        <paragraph>在“Theme Overrides &gt; Fonts”（主题覆盖 &gt; 字体）中选择“加载”，然后选中“Xolonium-Regular.ttf”文件。</paragraph>
        <image candidates="{'*': 'getting_started/first_2d_game/img/custom_font_load_font.webp'}" uri="getting_started/first_2d_game/img/custom_font_load_font.webp"></image>
        <paragraph>字体尺寸仍然太小，请在“Theme Overrides &gt; Font Sizes”（主题覆盖 &gt; 字体大小）下将其增加到 <literal>64</literal>。当 <literal>ScoreLabel</literal> 完成此操作后，请重复对 <literal>Message</literal> 和 <literal>StartButton</literal> 节点做同样的修改。</paragraph>
        <image candidates="{'*': 'getting_started/first_2d_game/img/custom_font_size.webp'}" uri="getting_started/first_2d_game/img/custom_font_size.webp"></image>
        <note>
            <paragraph><strong>锚点：</strong><literal>Control</literal> 节点具有位置和大小，但它也有锚点（Anchor）。锚点定义的是原点——节点边缘的参考点。</paragraph>
        </note>
        <paragraph>请将节点如下图排列。拖动节点可以手动放置，也可以使用“锚点预设（Anchor Preset）”进行更精确的定位。</paragraph>
        <image candidates="{'*': 'getting_started/first_2d_game/img/ui_anchor.webp'}" uri="getting_started/first_2d_game/img/ui_anchor.webp"></image>
        <section ids="scorelabel" names="scorelabel">
            <title>ScoreLabel</title>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>添加文本 <literal>0</literal>。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>将“Horizontal Alignment”和“Vertical Alignment”设置为 <literal>Center</literal>。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>为“Anchor Preset”选择 <literal>Center Top</literal>。</paragraph>
                </list_item>
            </enumerated_list>
        </section>
        <section ids="message" names="message">
            <title>Message</title>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>添加文本 <literal>Dodge the Creeps!</literal>。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>将“Horizontal Alignment”和“Vertical Alignment”设置为 <literal>Center</literal>。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>将“Autowrap Mode”设置为 <literal>Word</literal>，否则标签只会有一行。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>在“Control - Layout/Transform”中将“Size X”设置为 <literal>480</literal>，使用屏幕的完整宽度。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>为“Anchor Preset”选择 <literal>Center</literal>。</paragraph>
                </list_item>
            </enumerated_list>
        </section>
        <section ids="startbutton" names="startbutton">
            <title>StartButton</title>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>添加文本 <literal>Start</literal>。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>在“Control - Layout/Transform”中将“Size X”设置为 <literal>200</literal>、“Size Y”设置为 <literal>100</literal>，在边框和文本之间添加间距。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>为“Anchor Preset”选择 <literal>Center Bottom</literal>。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>在“Control - Layout/Transform”中将“Position Y”设置为 <literal>580</literal>。</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>在 <literal>MessageTimer</literal> 中，将 <literal>Wait Time</literal> 设置为 <literal>2</literal> 并将 <literal>One Shot</literal> 属性设置为“启用”。</paragraph>
            <paragraph>现将这个脚本添加到 <literal>HUD</literal>：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends CanvasLayer

# Notifies `Main` node that the button has been pressed
signal start_game</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class HUD : CanvasLayer
{
    // Don't forget to rebuild the project so the editor knows about the new signal.

    [Signal]
    public delegate void StartGameEventHandler();
}</literal_block>
                </div>
            </container>
            <paragraph>当想显示一条临时消息时，比如“Get Ready”，就会调用这个函数</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func show_message(text):
    $Message.text = text
    $Message.show()
    $MessageTimer.start()</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void ShowMessage(string text)
{
    var message = GetNode&lt;Label&gt;("Message");
    message.Text = text;
    message.Show();

    GetNode&lt;Timer&gt;("MessageTimer").Start();
}</literal_block>
                </div>
            </container>
            <paragraph>我们还需要处理玩家死亡的情况。以下代码会显示 2 秒“Game Over”，然后返回标题屏幕，暂停一会儿之后再显示“Start”按钮。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func show_game_over():
    show_message("Game Over")
    # Wait until the MessageTimer has counted down.
    await $MessageTimer.timeout

    $Message.text = "Dodge the Creeps!"
    $Message.show()
    # Make a one-shot timer and wait for it to finish.
    await get_tree().create_timer(1.0).timeout
    $StartButton.show()</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">async public void ShowGameOver()
{
    ShowMessage("Game Over");

    var messageTimer = GetNode&lt;Timer&gt;("MessageTimer");
    await ToSignal(messageTimer, Timer.SignalName.Timeout);

    var message = GetNode&lt;Label&gt;("Message");
    message.Text = "Dodge the Creeps!";
    message.Show();

    await ToSignal(GetTree().CreateTimer(1.0), SceneTreeTimer.SignalName.Timeout);
    GetNode&lt;Button&gt;("StartButton").Show();
}</literal_block>
                </div>
            </container>
            <paragraph>当玩家死亡时调用这个函数。将显示“Game Over”2 秒，然后返回标题屏幕并显示“Start”按钮。</paragraph>
            <note>
                <paragraph>当你需要暂停片刻时，可以使用场景树的 <literal>get_tree().create_timer(2)</literal> 函数替代使用 <literal>Timer</literal> 节点。这对于延迟非常有用，例如在上述代码中，在这里我们需要在显示“开始”按钮前等待片刻。</paragraph>
            </note>
            <paragraph>将以下更新分数代码添加到 <literal>HUD</literal> 中</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func update_score(score):
    $ScoreLabel.text = str(score)</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void UpdateScore(int score)
{
    GetNode&lt;Label&gt;("ScoreLabel").Text = score.ToString();
}</literal_block>
                </div>
            </container>
            <paragraph>连接 <literal>StartButton</literal> 的 <literal>pressed()</literal> 信号与 <literal>MessageTimer</literal> 的 <literal>timeout()</literal> 信号，然后在新函数中添加以下代码：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_start_button_pressed():
    $StartButton.hide()
    start_game.emit()

func _on_message_timer_timeout():
    $Message.hide()</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private void OnStartButtonPressed()
{
    GetNode&lt;Button&gt;("StartButton").Hide();
    EmitSignal(SignalName.StartGame);
}

private void OnMessageTimerTimeout()
{
    GetNode&lt;Label&gt;("Message").Hide();
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="connecting-hud-to-main" names="connecting\ hud\ to\ main 将\ hud\ 场景连接到\ main\ 场景">
            <title>将 HUD 场景连接到 Main 场景</title>
            <paragraph>现在我们完成了 <literal>HUD</literal> 场景，保存并返回 <literal>Main</literal> 场景。和 <literal>Player</literal> 场景的做法一样，在 <literal>Main</literal> 场景中实例化 <literal>HUD</literal> 场景。如果你没有错过任何东西，完整的场景树应该像这样：</paragraph>
            <image candidates="{'*': 'getting_started/first_2d_game/img/completed_main_scene.webp'}" uri="getting_started/first_2d_game/img/completed_main_scene.webp"></image>
            <paragraph>现在我们需要将 <literal>HUD</literal> 功能与我们的 <literal>Main</literal> 脚本连接起来。这需要在 <literal>Main</literal> 场景中添加一些内容：</paragraph>
            <paragraph>在“节点”选项卡中，点击“连接信号”窗口中的“选取”按钮，选择 <literal>new_game()</literal> 方法或在窗口的“接收方法”下面输入“new_game”，将 HUD 的 <literal>start_game</literal> 信号连接到 Main 节点的 <literal>new_game()</literal> 函数。请确认脚本中 <literal>func new_game()</literal> 的旁边出现了一个绿色的连接图标。</paragraph>
            <paragraph>在 <literal>new_game()</literal> 函数中，更新分数显示并显示“Get Ready”消息：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">$HUD.update_score(score)
$HUD.show_message("Get Ready")</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var hud = GetNode&lt;HUD&gt;("HUD");
hud.UpdateScore(_score);
hud.ShowMessage("Get Ready!");</literal_block>
                </div>
            </container>
            <paragraph>在 <literal>game_over()</literal> 中我们需要调用相应的 <literal>HUD</literal> 函数：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">$HUD.show_game_over()</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GetNode&lt;HUD&gt;("HUD").ShowGameOver();</literal_block>
                </div>
            </container>
            <paragraph>最后，将下面的代码添加到 <literal>_on_score_timer_timeout()</literal> 中，保持不断变化的分数的同步显示：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">$HUD.update_score(score)</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">GetNode&lt;HUD&gt;("HUD").UpdateScore(_score);</literal_block>
                </div>
            </container>
            <warning>
                <paragraph>如果还没做的话，请不要忘记在 <literal>_ready()</literal> 中移除对 <literal>new_game()</literal> 的调用。否则你的游戏将自动开始。</paragraph>
            </warning>
            <paragraph>现在你就可以开始游戏了！点击“运行项目”按钮。此时会要求你选择一个主场景，选择 <literal>main.tscn</literal> 即可。</paragraph>
        </section>
        <section ids="removing-old-creeps" names="removing\ old\ creeps 删除旧的小怪">
            <title>删除旧的小怪</title>
            <paragraph>如果你一直玩到“游戏结束”，然后重新开始新游戏，上局游戏的小怪仍然显示在屏幕上。更好的做法是在新游戏开始时清除它们。我们需要一个同时让<emphasis>所有</emphasis>小怪删除它自己的方法，为此可以使用“分组”功能。</paragraph>
            <paragraph>在 <literal>Mob</literal> 场景中，选择根节点，然后单击检查器旁边的“节点”选项卡（在该位置可以找到节点的信号）。 点击“信号”旁边的“分组”，然后可以输入新的组名称，点击“添加”。</paragraph>
            <image candidates="{'*': 'getting_started/first_2d_game/img/group_tab.webp'}" uri="getting_started/first_2d_game/img/group_tab.webp"></image>
            <paragraph>现在，所有小怪都将属于“mobs”（小怪）分组。我们可以将以下行添加到 <literal>Main</literal> 中的 <literal>new_game()</literal> 函数中：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">get_tree().call_group("mobs", "queue_free")</literal_block>
                </div>
                <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// Note that for calling Godot-provided methods with strings,
// we have to use the original Godot snake_case name.
GetTree().CallGroup("mobs", Node.MethodName.QueueFree);</literal_block>
                </div>
            </container>
            <paragraph><literal>call_group()</literal> 函数调用组中每个节点上的删除函数——让每个怪物删除其自身。</paragraph>
            <paragraph>游戏在这一点上大部分已经完成。在下一部分和最后一部分中，我们将通过添加背景，循环音乐和一些键盘快捷键来对其进行一些润色。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
