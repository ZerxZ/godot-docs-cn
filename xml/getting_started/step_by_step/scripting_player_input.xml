<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/step_by_step/scripting_player_input.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">Intention: only introduce one necessary input method at this point. The
Inputs section of the docs should provide more guides comparing the various
tools you have to manage the complexity of user input.</comment>
    <target refid="doc-scripting-player-input"></target>
    <section ids="listening-to-player-input doc-scripting-player-input" names="listening\ to\ player\ input 监听玩家的输入 doc_scripting_player_input">
        <title>监听玩家的输入</title>
        <paragraph>在上一课 <reference internal="True" refuri="scripting_first_script#doc-scripting-first-script"><inline classes="std std-ref">创建第一个脚本</inline></reference> 的基础上，让我们看看任何游戏的另一个重要特征：将控制权交给玩家。为了增加这一点，我们需要修改 <literal>sprite_2d.gd</literal> 的代码。</paragraph>
        <image candidates="{'*': 'getting_started/step_by_step/img/scripting_first_script_moving_with_input.gif'}" uri="getting_started/step_by_step/img/scripting_first_script_moving_with_input.gif"></image>
        <paragraph>在 Godot 中，你有两个主要工具来处理玩家的输入：</paragraph>
        <enumerated_list enumtype="arabic" prefix="" suffix=".">
            <list_item>
                <paragraph>内置的输入回调，主要是 <literal>_unhandled_input()</literal>。和 <literal>_process()</literal>一样 ，它是一个内置的虚函数，Godot 每次在玩家按下一个键时都会调用。它是你想用来对那些不是每一帧都发生的事件做出反应的工具，比如按 <literal classes="kbd">Space</literal> 来跳跃。要了解更多关于输入回调的信息，请参阅 <reference internal="True" refuri="../../tutorials/inputs/inputevent#doc-inputevent"><inline classes="std std-ref">使用 InputEvent</inline></reference> 。</paragraph>
            </list_item>
            <list_item>
                <paragraph><literal>Input</literal> 单例。单例是一个全局可访问的对象。Godot 在脚本中提供对几个对象的访问。它是每一帧检查输入的有效工具。</paragraph>
            </list_item>
        </enumerated_list>
        <paragraph>我们这里将使用 <literal>Input</literal> 单例，因为我们需要知道在每一帧中玩家是否想转身或者移动。</paragraph>
        <paragraph>对于转弯，我们应该使用一个新的变量：<literal>direction</literal>。在我们的 <literal>_process()</literal> 函数中，将 <literal>rotation += angular_speed * delta</literal> 替换成以下代码。</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var direction = 0
if Input.is_action_pressed("ui_left"):
    direction = -1
if Input.is_action_pressed("ui_right"):
    direction = 1

rotation += angular_speed * direction * delta</literal_block>
            </div>
            <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var direction = 0;
if (Input.IsActionPressed("ui_left"))
{
    direction = -1;
}
if (Input.IsActionPressed("ui_right"))
{
    direction = 1;
}

Rotation += _angularSpeed * direction * (float)delta;</literal_block>
            </div>
        </container>
        <paragraph>我们的 <literal>direction</literal> 局部变量是一个乘数，代表玩家想要转向的方向。<literal>0</literal> 的值表示玩家没有按左或右方向键。<literal>1</literal> 表示玩家想向右转，而 <literal>-1</literal> 表示他们想向左转。</paragraph>
        <paragraph>为了产生这些值，我们引入了条件和 <literal>Input</literal> 的使用。条件以 GDScript 中的 <literal>if</literal> 关键字开始，以冒号结束。条件是关键字和行末之间的表达式。</paragraph>
        <paragraph>为了检查当前帧玩家是否按下了某个键，我们需要调用 <literal>Input.is_action_pressed()</literal>。这个方法使用一个字符串来表示一个输入动作。当该按键被按下时，函数返回 <literal>true</literal>，否则这个函数将返回 <literal>false</literal>。</paragraph>
        <paragraph>上面我们使用的两个动作，“ui_left”和“ui_right”，是每个 Godot 项目中预定义的。它们分别在玩家按键盘上的左右箭头或游戏手柄上的左右键时触发。</paragraph>
        <note>
            <paragraph>打开“项目 -&gt; 项目设置”并点击“输入映射”选项卡，就可以查看并编辑项目中的输入动作。</paragraph>
        </note>
        <paragraph>最后，当我们更新节点的 <literal>rotation</literal> 时，我们使用 <literal>direction</literal> 作为乘数：<literal>rotation += angular_speed * direction * delta</literal>。</paragraph>
        <paragraph>Comment out the lines <literal>var velocity = Vector2.UP.rotated(rotation) * speed</literal> and <literal>position += velocity * delta</literal> like this:</paragraph>
        <container classes="sphinx-tabs" type="tab-element">
            <div aria-label="Tabbed content" role="tablist">
                <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
            </div>
            <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">#var velocity = Vector2.UP.rotated(rotation) * speed

#position += velocity * delta</literal_block>
            </div>
            <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">//var velocity = Vector2.Up.Rotated(Rotation) * _speed;

//Position += velocity * (float)delta;</literal_block>
            </div>
        </container>
        <paragraph>This will ignore the code that moved the icon's position in a circle without user input from the previous exercise.</paragraph>
        <paragraph>如果你用这段代码运行场景，当你按下 <literal classes="kbd">Left</literal>（左方向键）和 <literal classes="kbd">Right</literal>（右方向键） 时，图标应该会旋转。</paragraph>
        <section ids="moving-when-pressing-up" names='moving\ when\ pressing\ "up" 按“上”时移动'>
            <title>按“上”时移动</title>
            <paragraph>To only move when pressing a key, we need to modify the code that calculates the
                velocity. Uncomment the code and replace the line starting with <literal>var velocity</literal> with the code below.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var velocity = Vector2.ZERO
if Input.is_action_pressed("ui_up"):
    velocity = Vector2.UP.rotated(rotation) * speed</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">var velocity = Vector2.Zero;
if (Input.IsActionPressed("ui_up"))
{
    velocity = Vector2.Up.Rotated(Rotation) * _speed;
}</literal_block>
                </div>
            </container>
            <paragraph>我们将 <literal>velocity</literal> 的值初始化为 <literal>Vector2.ZERO</literal>，这是内置 <literal>Vector</literal> 类型的一个常量，代表长度为 0 的二维向量。</paragraph>
            <paragraph>如果玩家按下“ui_up”动作，我们就会更新速度的值，使精灵向前移动。</paragraph>
        </section>
        <section ids="complete-script" names="complete\ script 完整脚本">
            <title>完整脚本</title>
            <paragraph>这是完整的 <literal>sprite_2d.gd</literal> 文件，仅供参考。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Sprite2D

var speed = 400
var angular_speed = PI


func _process(delta):
    var direction = 0
    if Input.is_action_pressed("ui_left"):
        direction = -1
    if Input.is_action_pressed("ui_right"):
        direction = 1

    rotation += angular_speed * direction * delta

    var velocity = Vector2.ZERO
    if Input.is_action_pressed("ui_up"):
        velocity = Vector2.UP.rotated(rotation) * speed

    position += velocity * delta</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MySprite2D : Sprite2D
{
    private float _speed = 400;
    private float _angularSpeed = Mathf.Pi;

    public override void _Process(double delta)
    {
        var direction = 0;
        if (Input.IsActionPressed("ui_left"))
        {
            direction = -1;
        }
        if (Input.IsActionPressed("ui_right"))
        {
            direction = 1;
        }

        Rotation += _angularSpeed * direction * (float)delta;

        var velocity = Vector2.Zero;
        if (Input.IsActionPressed("ui_up"))
        {
            velocity = Vector2.Up.Rotated(Rotation) * _speed;
        }

        Position += velocity * (float)delta;
    }
}</literal_block>
                </div>
            </container>
            <paragraph>如果你运行这个场景，你现在应该能够用左右方向键进行旋转，并通过按 <literal classes="kbd">Up</literal> 向前移动。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/scripting_first_script_moving_with_input.gif'}" uri="getting_started/step_by_step/img/scripting_first_script_moving_with_input.gif"></image>
        </section>
        <section ids="summary" names="summary 总结">
            <title>总结</title>
            <paragraph>总之，Godot中的每个脚本都代表一个类，并扩展了引擎的一个内置类。在我们sprite的例子中，你的类所继承的节点类型可以让你访问一些属性，例如在“精灵” 例子中的 <literal>rotation</literal> 和 <literal>position</literal> 。你还继承了许多函数，但我们在这个例子中没有使用这些函数。</paragraph>
            <paragraph>在 GDScript 中，放在文件顶部的变量是类的属性，也称为成员变量。除了变量之外，你还可以定义函数，在大多数情况下，这些函数将是类的方法。</paragraph>
            <paragraph>Godot 提供了几个虚函数，你可以定义这些函数来将类与引擎连接起来。其中包括 <literal>_process()</literal> ，用于每帧将更改应用于节点，以及 <literal>_unhandled_input()</literal> ，用于接收用户的输入事件，如按键和按钮。还有很多。</paragraph>
            <paragraph><literal>Input</literal> 单例允许你在代码中的任何位置对玩家的输入做出反应。 尤其是，你在 <literal>_process()</literal> 循环中使用它。</paragraph>
            <paragraph>在下一课 <reference internal="True" refuri="signals#doc-signals"><inline classes="std std-ref">使用信号</inline></reference> 中，我们会让节点触发脚本中的代码，让脚本和代码之间产生联系。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
