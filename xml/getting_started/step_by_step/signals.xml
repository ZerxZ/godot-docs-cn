<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/step_by_step/signals.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <comment xml:space="preserve">Intention: give the user a first taste of signals. We should write more
documentation in the scripting/ section.</comment>
    <comment xml:space="preserve">Note: GDScript snippets use one line return instead of two because they're
really short.</comment>
    <meta content="信号" name="keywords">
    </meta>
    <target refid="doc-signals"></target>
    <section ids="using-signals doc-signals" names="using\ signals 使用信号 doc_signals">
        <title>使用信号</title>
        <paragraph>在本课中，我们将介绍信号。它们是节点在发生特定事件时发出的消息，例如按下按钮。其他节点可以连接到该信号，并在事件发生时调用函数。</paragraph>
        <paragraph>信号是 Godot 内置的委派机制，允许一个游戏对象对另一个游戏对象的变化做出反应，而无需相互引用。使用信号可以限制<reference name="耦合" refuri="https://zh.wikipedia.org/zh-cn/%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">耦合</reference><target ids="id1" names="耦合" refuri="https://zh.wikipedia.org/zh-cn/%E8%80%A6%E5%90%88%E6%80%A7_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)"></target>，并保持代码的灵活性。</paragraph>
        <paragraph>例如，你可能在屏幕上有一个代表玩家生命值的生命条。当玩家受到伤害或使用治疗药水时，你希望生命条反映变化。要做到这一点，在 Godot 中，你会使用到信号。</paragraph>
        <note>
            <paragraph>正如引言中提到的，信号是 Godot 版本的观察者模式。你可以在此处了解有关它的更多信息：<reference refuri="https://gameprogrammingpatterns.com/observer.html">https://gameprogrammingpatterns.com/observer.html</reference></paragraph>
        </note>
        <paragraph>现在，我们将使用信号来使上一节课（<reference internal="True" refuri="scripting_player_input#doc-scripting-player-input"><inline classes="std std-ref">监听玩家的输入</inline></reference>）中的 Godot 图标移动，并通过按下按钮来停止。</paragraph>
        <comment xml:space="preserve">Example</comment>
        <section ids="scene-setup" names="scene\ setup 场景设置">
            <title>场景设置</title>
            <paragraph>To add a button to our game, we will create a new scene which will include
                both a <reference internal="True" refuri="../../classes/class_button#class-button"><inline classes="std std-ref">Button</inline></reference> and the <literal>sprite_2d.tscn</literal> scene we created in
                the <reference internal="True" refuri="scripting_first_script#doc-scripting-first-script"><inline classes="std std-ref">创建第一个脚本</inline></reference> lesson.</paragraph>
            <paragraph>通过转到菜单“场景 -&gt; 新建场景”来创建新场景。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_01_new_scene.webp'}" uri="getting_started/step_by_step/img/signals_01_new_scene.webp"></image>
            <paragraph>在场景面板中，单击“2D 场景”按钮。这样就会添加一个 <reference internal="True" refuri="../../classes/class_node2d#class-node2d"><inline classes="std std-ref">Node2D</inline></reference> 作为我们的根节点。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_02_2d_scene.webp'}" uri="getting_started/step_by_step/img/signals_02_2d_scene.webp"></image>
            <paragraph>在文件系统面板中，单击之前保存的 <literal>sprite_2d.tscn</literal> 文件并将其拖动到 Node2D 上，对其进行实例化。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_03_dragging_scene.png'}" uri="getting_started/step_by_step/img/signals_03_dragging_scene.png"></image>
            <paragraph>我们想要添加另一个节点作为 Sprite2D 的同级节点。为此，请右键单击 Node2D，然后选择“添加子节点”。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_04_add_child_node.webp'}" uri="getting_started/step_by_step/img/signals_04_add_child_node.webp"></image>
            <paragraph>寻找并添加 <reference internal="True" refuri="../../classes/class_button#class-button"><inline classes="std std-ref">Button</inline></reference> 节点。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_05_add_button.webp'}" uri="getting_started/step_by_step/img/signals_05_add_button.webp"></image>
            <paragraph>该节点默认比较小。在视口中，点击并拖拽该按钮右下角的手柄来调整大小。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_06_drag_button.png'}" uri="getting_started/step_by_step/img/signals_06_drag_button.png"></image>
            <paragraph>如果看不到手柄，请确保工具栏中的选择工具处于活动状态。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_07_select_tool.webp'}" uri="getting_started/step_by_step/img/signals_07_select_tool.webp"></image>
            <paragraph>点击并拖拽按钮使其更接近精灵。</paragraph>
            <paragraph>你可以通过修改检查器中的 Text 属性来给 Button 上写一个标签。请输入<literal>Toggle motion</literal>。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_08_toggle_motion_text.webp'}" uri="getting_started/step_by_step/img/signals_08_toggle_motion_text.webp"></image>
            <paragraph>你的场景树和视口应该是类似这样的。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_09_scene_setup.png'}" uri="getting_started/step_by_step/img/signals_09_scene_setup.png"></image>
            <paragraph>如果你还没保存场景的话，保存新建的场景为 <literal>node_2d.tscn</literal>。然后你就可以使用 <literal classes="kbd">F6`（macOS 则为 :kbd:`Cmd + R</literal>）来运行。此时，你可以看到按钮，但是按下之后不会有任何反应。</paragraph>
        </section>
        <section ids="connecting-a-signal-in-the-editor" names="connecting\ a\ signal\ in\ the\ editor 在编辑器中连接信号">
            <title>在编辑器中连接信号</title>
            <paragraph>然后，我们希望将按钮的“pressed”信号连接到我们的 Sprite2D，并且我们想要调用一个新函数来打开和关闭其运动。我们需要像我们在上一课中所做的操作一样，将一个脚本附加到 Sprite2D 节点。</paragraph>
            <paragraph>你可以在“节点”面板中连接信号。选择 Button 节点，然后在编辑器的右侧，单击检查器旁边名为“节点”的选项卡。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_10_node_dock.webp'}" uri="getting_started/step_by_step/img/signals_10_node_dock.webp"></image>
            <paragraph>停靠栏显示所选节点上可用的信号列表。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_11_pressed_signals.webp'}" uri="getting_started/step_by_step/img/signals_11_pressed_signals.webp"></image>
            <paragraph>双击“pressed”信号，打开节点连接窗口。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_12_node_connection.webp'}" uri="getting_started/step_by_step/img/signals_12_node_connection.webp"></image>
            <paragraph>然后，你可以将信号连接到 Sprite2D 节点。该节点需要一个用于接收按钮信号的函数，当按钮发出信号时，Godot 将调用该函数。编辑器会为你生成一个。按照规范，我们将这些回调方法命名为"_on_node_name_signal_name"。在这里，它被命名为"_on_button_pressed"。</paragraph>
            <note>
                <paragraph>通过编辑器的节点面板连接信号时，可以使用两种模式。简单的一个只允许你连接到附加了脚本的节点，并在它们上面创建一个新的回调函数。</paragraph>
                <image candidates="{'*': 'getting_started/step_by_step/img/signals_advanced_connection_window.png'}" uri="getting_started/step_by_step/img/signals_advanced_connection_window.png"></image>
                <paragraph>你可以在高级视图中连接到任何节点和任何内置函数、向回调添加参数、设置选项。你可以单击窗口右下角的“高级”按钮来切换模式。</paragraph>
            </note>
            <paragraph>单击“连接”按钮以完成信号连接并跳转到脚本工作区。你应该会看到新方法，并在左边距中带有连接图标。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_13_signals_connection_icon.webp'}" uri="getting_started/step_by_step/img/signals_13_signals_connection_icon.webp"></image>
            <paragraph>如果单击该图标，将弹出一个窗口并显示有关连接的信息。此功能仅在编辑器中连接节点时可用。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_14_signals_connection_info.webp'}" uri="getting_started/step_by_step/img/signals_14_signals_connection_info.webp"></image>
            <paragraph>让我们用代码替换带有 <literal>pass</literal> 关键字的一行，以切换节点的运动。</paragraph>
            <paragraph>我们的 Sprite2D 由于 <literal>_process()</literal> 函数中的代码而移动。Godot 提供了一种打开和关闭处理的方法：<reference internal="True" refuri="../../classes/class_node#class-node-method-set-process"><inline classes="std std-ref">Node.set_process()</inline></reference> 。Node 的另一个方法 <literal>is_processing()</literal> ，如果空闲处理处于活动状态，则返回 <literal>true</literal>。我们可以使用 <literal>not</literal> 关键字来反转该值。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_button_pressed():
    set_process(not is_processing())</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private void OnButtonPressed()
{
    SetProcess(!IsProcessing());
}</literal_block>
                </div>
            </container>
            <paragraph>此函数将切换处理，进而切换按下按钮时图标的移动。</paragraph>
            <paragraph>在尝试游戏之前，我们需要简化 <literal>_process()</literal> 函数，以自动移动节点，而不是等待用户输入。将其替换为以下代码，这是我们在两课前看到的代码：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _process(delta):
    rotation += angular_speed * delta
    var velocity = Vector2.UP.rotated(rotation) * speed
    position += velocity * delta</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Process(double delta)
{
    Rotation += _angularSpeed * (float)delta;
    var velocity = Vector2.Up.Rotated(Rotation) * _speed;
    Position += velocity * (float)delta;
}</literal_block>
                </div>
            </container>
            <paragraph>你的完整的 <literal>Sprite_2d.gd</literal> 代码应该是类似下面这样的。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Sprite2D

var speed = 400
var angular_speed = PI


func _process(delta):
    rotation += angular_speed * delta
    var velocity = Vector2.UP.rotated(rotation) * speed
    position += velocity * delta


func _on_button_pressed():
    set_process(not is_processing())</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MySprite2D : Sprite2D
{
    private float _speed = 400;
    private float _angularSpeed = Mathf.Pi;

    public override void _Process(double delta)
    {
        Rotation += _angularSpeed * (float)delta;
        var velocity = Vector2.Up.Rotated(Rotation) * _speed;
        Position += velocity * (float)delta;
    }

    private void OnButtonPressed()
    {
        SetProcess(!IsProcessing());
    }
}</literal_block>
                </div>
            </container>
            <paragraph>运行该场景，然后点击按钮，就可以看到精灵开始或停止运行。</paragraph>
        </section>
        <section ids="connecting-a-signal-via-code" names="connecting\ a\ signal\ via\ code 用代码连接信号">
            <title>用代码连接信号</title>
            <paragraph>你可以通过代码连接信号，而不是使用编辑器。这在脚本中创建节点或实例化场景时是必需的。</paragraph>
            <paragraph>让我们在这里使用一个不同的节点。Godot 有一个 <reference internal="True" refuri="../../classes/class_timer#class-timer"><inline classes="std std-ref">Timer</inline></reference> 节点，可用于实现技能冷却时间、武器重装等。</paragraph>
            <paragraph>回到 2D 工作区。你可以点击窗口顶部的“2D”字样，或者按 <literal classes="kbd">Ctrl + F1</literal>（macOS 上则是 <literal classes="kbd">Ctrl + Cmd + 1</literal>）。</paragraph>
            <paragraph>在“场景”面板中，右键点击 Sprite2D 节点并添加新的子节点。搜索 Timer 并添加对应节点。你的场景现在应该类似这样。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_15_scene_tree.png'}" uri="getting_started/step_by_step/img/signals_15_scene_tree.png"></image>
            <paragraph>选中 Timer 节点，在“检查器”中勾选 <strong>Autostart</strong> 属性。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_18_timer_autostart.png'}" uri="getting_started/step_by_step/img/signals_18_timer_autostart.png"></image>
            <paragraph>点击 Sprite2D 旁的脚本图标，返回脚本工作区。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_16_click_script.png'}" uri="getting_started/step_by_step/img/signals_16_click_script.png"></image>
            <paragraph>我们需要执行两个操作来通过代码连接节点：</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>从 Sprite2D 获取 Timer 的引用。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>通过 Timer 的“timeout”信号调用 <literal>connect()</literal> 方法。</paragraph>
                </list_item>
            </enumerated_list>
            <note>
                <paragraph>要使用代码来连接信号，你需要调用所需监听节点信号的 <literal>connect()</literal> 方法。这里我们要监听的是 Timer 的“timeout”信号。</paragraph>
            </note>
            <paragraph>我们想要在场景实例化时连接信号，我们可以使用 <reference internal="True" refuri="../../classes/class_node#class-node-private-method-ready"><inline classes="std std-ref">Node._ready()</inline></reference> 内置函数来实现这一点，当节点完全实例化时，引擎会自动调用该函数。</paragraph>
            <paragraph>为了获取相对于当前节点的引用，我们使用方法 <reference internal="True" refuri="../../classes/class_node#class-node-method-get-node"><inline classes="std std-ref">Node.get_node()</inline></reference>。我们可以将引用存储在变量中。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    var timer = get_node("Timer")</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    var timer = GetNode&lt;Timer&gt;("Timer");
}</literal_block>
                </div>
            </container>
            <paragraph><literal>get_node()</literal> 函数会查看 Sprite2D 的子节点，并按节点的名称获取节点。例如，如果在编辑器中将 Timer 节点重命名为“BlinkingTimer”，则必须将调用更改为 <literal>get_node("BlinkingTimer")</literal>。</paragraph>
            <comment xml:space="preserve">add seealso to a page that explains node features.</comment>
            <paragraph>现在，我们可以在 <literal>_ready()</literal> 函数中将Timer连接到Sprite2D。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    var timer = get_node("Timer")
    timer.timeout.connect(_on_timer_timeout)</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    var timer = GetNode&lt;Timer&gt;("Timer");
    timer.Timeout += OnTimerTimeout;
}</literal_block>
                </div>
            </container>
            <paragraph>该行读起来是这样的：我们将计时器的“timeout”信号连接到脚本附加到的节点上。当计时器发出“timeout”时，去调用我们需要定义的函数``_on_timer_timeout()``。让我们将其定义添加到脚本的底部，并使用它来切换 sprite 的可见性。</paragraph>
            <note>
                <paragraph>按照惯例，我们将这些回调方法在 GDScript 中命名为“_on_node_name_signal_name”，在 C# 中命名为“OnNodeNameSignalName”。故此处的GDScript 为“_on_timer_timeout”，C# 为“OnTimerTimeout()”。</paragraph>
            </note>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_timer_timeout():
    visible = not visible</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private void OnTimerTimeout()
{
    Visible = !Visible;
}</literal_block>
                </div>
            </container>
            <paragraph><literal>visible</literal> 属性是一个布尔值，用于控制节点的可见性。<literal>visible = not visible</literal> 行切换该值。如果 <literal>visible</literal> 是 <literal>true</literal>，它就会变成 <literal>false</literal>，反之亦然。</paragraph>
            <paragraph>如果你现在运行场景，就会看到精灵在闪啊闪的，间隔为一秒。</paragraph>
        </section>
        <section ids="complete-script" names="complete\ script 完整脚本">
            <title>完整脚本</title>
            <paragraph>这就是我们小小的 Godot 图标移动闪烁演示了！这是完整的 <literal>sprite_2d.gd</literal> 文件，仅供参考。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Sprite2D

var speed = 400
var angular_speed = PI


func _ready():
    var timer = get_node("Timer")
    timer.timeout.connect(_on_timer_timeout)


func _process(delta):
    rotation += angular_speed * delta
    var velocity = Vector2.UP.rotated(rotation) * speed
    position += velocity * delta


func _on_button_pressed():
    set_process(not is_processing())


func _on_timer_timeout():
    visible = not visible</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MySprite2D : Sprite2D
{
    private float _speed = 400;
    private float _angularSpeed = Mathf.Pi;

    public override void _Ready()
    {
        var timer = GetNode&lt;Timer&gt;("Timer");
        timer.Timeout += OnTimerTimeout;
    }

    public override void _Process(double delta)
    {
        Rotation += _angularSpeed * (float)delta;
        var velocity = Vector2.Up.Rotated(Rotation) * _speed;
        Position += velocity * (float)delta;
    }

    private void OnButtonPressed()
    {
        SetProcess(!IsProcessing());
    }

    private void OnTimerTimeout()
    {
        Visible = !Visible;
    }
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="custom-signals" names="custom\ signals 自定义信号">
            <title>自定义信号</title>
            <note>
                <paragraph>本节介绍的是如何定义并使用你自己的信号，不依赖之前课程所创建的项目。</paragraph>
            </note>
            <paragraph>你可以在脚本中定义自定义信号。例如，假设你希望在玩家的生命值为零时通过屏幕显示游戏结束。为此，当他们的生命值达到 0 时，你可以定义一个名为“died”或“health_depleted”的信号。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

signal health_depleted

var health = 10</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode2D : Node2D
{
    [Signal]
    public delegate void HealthDepletedEventHandler();

    private int _health = 10;
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph>由于信号表示刚刚发生的事件，我们通常在其名称中使用过去时态的动作动词。</paragraph>
            </note>
            <paragraph>自定义信号的工作方式与内置信号相同：它们显示在“节点”选项卡中，你可以像连接其他信号一样连接到它们。</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_17_custom_signal.webp'}" uri="getting_started/step_by_step/img/signals_17_custom_signal.webp"></image>
            <paragraph>要通过代码发出信号，请调用信号的 <literal>emit()</literal> 方法。</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func take_damage(amount):
    health -= amount
    if health &lt;= 0:
        health_depleted.emit()</literal_block>
                </div>
                <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void TakeDamage(int amount)
{
    _health -= amount;

    if (_health &lt;= 0)
    {
        EmitSignal(SignalName.HealthDepleted);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>信号还可以选择声明一个或多个参数。在括号之间指定参数的名称：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

signal health_changed(old_value, new_value)

var health = 10</literal_block>
                </div>
                <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode : Node
{
    [Signal]
    public delegate void HealthChangedEventHandler(int oldValue, int newValue);

    private int _health = 10;
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph>这些信号参数显示在编辑器的节点停靠面板中，Godot 可以使用它们为你生成回调函数。但是，发出信号时仍然可以发出任意数量的参数；所以由你来决定是否发出正确的值。</paragraph>
            </note>
            <paragraph>要在发出信号的同时传值，请将它们添加为 <literal>emit()</literal> 函数的额外参数：</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-10-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-10-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-10-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func take_damage(amount):
    var old_health = health
    health -= amount
    health_changed.emit(old_health, health)</literal_block>
                </div>
                <div aria-labelledby="tab-10-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-10-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void TakeDamage(int amount)
{
    int oldHealth = _health;
    _health -= amount;
    EmitSignal(SignalName.HealthChanged, oldHealth, _health);
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="summary" names="summary 总结">
            <title>总结</title>
            <paragraph>Godot 中的任何节点都会在发生特定事件时发出信号，例如按下按钮。其他节点可以连接到单个信号并对所选事件做出反应。</paragraph>
            <paragraph>信号有很多用途。有了它们，你可以对进入或退出游戏世界的节点、碰撞、角色进入或离开某个区域、界面元素的大小变化等等做出反应。</paragraph>
            <paragraph>例如，代表金币的 <reference internal="True" refuri="../../classes/class_area2d#class-area2d"><inline classes="std std-ref">Area2D</inline></reference> 会在玩家的物理实体进入其碰撞形状时发出 <literal>body_entered</literal> 信号，让你知道玩家收集到了金币。</paragraph>
            <paragraph>在下一节 <reference internal="True" refuri="../first_2d_game/index#doc-your-first-2d-game"><inline classes="std std-ref">你的第一个 2D 游戏</inline></reference> 中，你将创建一个完整的 2D 游戏，使用目前为止学到的东西进行实战。</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
