<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/getting_started/step_by_step/signals.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <meta content="Signal" name="keywords"></meta>
    <comment xml:space="preserve">Intention: give the user a first taste of signals. We should write more
documentation in the scripting/ section.</comment>
    <comment xml:space="preserve">Note: GDScript snippets use one line return instead of two because they're
really short.</comment>
    <target refid="doc-signals"></target>
    <section ids="using-signals doc-signals" names="using\ signals doc_signals">
        <title>Using signals</title>
        <paragraph>In this lesson, we will look at signals. They are messages that nodes emit when
            something specific happens to them, like a button being pressed. Other nodes can
            connect to that signal and call a function when the event occurs.</paragraph>
        <paragraph>Signals are a delegation mechanism built into Godot that allows one game object to
            react to a change in another without them referencing one another. Using signals
            limits <reference name="coupling" refuri="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">coupling</reference><target ids="coupling" names="coupling" refuri="https://en.wikipedia.org/wiki/Coupling_(computer_programming)"></target> and keeps your
            code flexible.</paragraph>
        <paragraph>For example, you might have a life bar on the screen that represents the
            player's health. When the player takes damage or uses a healing potion, you want
            the bar to reflect the change. To do so, in Godot, you would use signals.</paragraph>
        <paragraph>Like methods (<reference internal="True" refuri="../../classes/class_callable#class-callable"><inline classes="std std-ref">Callable</inline></reference>), signals are a first-class type since Godot
            4.0. This means you can pass them around as method arguments directly without
            having to pass them as strings, which allows for better autocompletion and is
            less error-prone. See the <reference internal="True" refuri="../../classes/class_signal#class-signal"><inline classes="std std-ref">Signal</inline></reference> class reference for a list of
            what you can do with the Signal type directly.</paragraph>
        <seealso>
            <paragraph>As mentioned in the introduction, signals are Godot's version of the
                observer pattern. You can learn more about it in
                <reference name="Game Programming Patterns" refuri="https://gameprogrammingpatterns.com/observer.html">Game Programming Patterns</reference>.</paragraph>
        </seealso>
        <paragraph>We will now use a signal to make our Godot icon from the previous lesson
            (<reference internal="True" refuri="scripting_player_input#doc-scripting-player-input"><inline classes="std std-ref">Listening to player input</inline></reference>) move and stop by pressing a button.</paragraph>
        <note>
            <paragraph>For this project, we will be following the Godot naming conventions.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><strong>GDScript</strong>: Classes (nodes) use PascalCase, variables and
                        functions use snake_case, and constants use ALL_CAPS (See
                        <reference internal="True" refuri="../../tutorials/scripting/gdscript/gdscript_styleguide#doc-gdscript-styleguide"><inline classes="std std-ref">GDScript style guide</inline></reference>).</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>C#</strong>: Classes, export variables and methods use PascalCase,
                        private fields use _camelCase, local variables and parameters use
                        camelCase (See <reference internal="True" refuri="../../tutorials/scripting/c_sharp/c_sharp_style_guide#doc-c-sharp-styleguide"><inline classes="std std-ref">C# style guide</inline></reference>). Be careful to type
                        the method names precisely when connecting signals.</paragraph>
                </list_item>
            </bullet_list>
        </note>
        <section ids="scene-setup" names="scene\ setup">
            <title>Scene setup</title>
            <paragraph>To add a button to our game, we will create a new scene which will include
                both a <reference internal="True" refuri="../../classes/class_button#class-button"><inline classes="std std-ref">Button</inline></reference> and the <literal>sprite_2d.tscn</literal> scene we created in
                the <reference internal="True" refuri="scripting_first_script#doc-scripting-first-script"><inline classes="std std-ref">Creating your first script</inline></reference> lesson.</paragraph>
            <paragraph>Create a new scene by going to the menu <inline classes="role-menu role-ui">Scene &gt; New Scene</inline>.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_01_new_scene.webp'}" original_uri="img/signals_01_new_scene.webp" uri="getting_started/step_by_step/img/signals_01_new_scene.webp"></image>
            <paragraph>In the Scene dock, click the <inline classes="role-button role-ui">2D Scene</inline> button. This will add
                a <reference internal="True" refuri="../../classes/class_node2d#class-node2d"><inline classes="std std-ref">Node2D</inline></reference> as our root.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_02_2d_scene.webp'}" original_uri="img/signals_02_2d_scene.webp" uri="getting_started/step_by_step/img/signals_02_2d_scene.webp"></image>
            <paragraph>In the FileSystem dock, click and drag the <literal>sprite_2d.tscn</literal> file you saved
                previously onto the Node2D to instantiate it.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_03_dragging_scene.png'}" original_uri="img/signals_03_dragging_scene.png" uri="getting_started/step_by_step/img/signals_03_dragging_scene.png"></image>
            <paragraph>We want to add another node as a sibling of the Sprite2D. To do so, right-click
                on Node2D and select <inline classes="role-button role-ui">Add Child Node</inline>.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_04_add_child_node.webp'}" original_uri="img/signals_04_add_child_node.webp" uri="getting_started/step_by_step/img/signals_04_add_child_node.webp"></image>
            <paragraph>Search for the <reference internal="True" refuri="../../classes/class_button#class-button"><inline classes="std std-ref">Button</inline></reference> node and add it.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_05_add_button.webp'}" original_uri="img/signals_05_add_button.webp" uri="getting_started/step_by_step/img/signals_05_add_button.webp"></image>
            <paragraph>The node is small by default. Click and drag on the bottom-right handle of the
                Button in the viewport to resize it.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_06_drag_button.png'}" original_uri="img/signals_06_drag_button.png" uri="getting_started/step_by_step/img/signals_06_drag_button.png"></image>
            <paragraph>If you don't see the handles, ensure the select tool is active in the toolbar.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_07_select_tool.webp'}" original_uri="img/signals_07_select_tool.webp" uri="getting_started/step_by_step/img/signals_07_select_tool.webp"></image>
            <paragraph>Click and drag on the button itself to move it closer to the sprite.</paragraph>
            <paragraph>You can also write a label on the Button by editing its <inline classes="role-ui">Text</inline> property
                in the <inline classes="role-ui">Inspector</inline>. Enter <literal>Toggle motion</literal>.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_08_toggle_motion_text.webp'}" original_uri="img/signals_08_toggle_motion_text.webp" uri="getting_started/step_by_step/img/signals_08_toggle_motion_text.webp"></image>
            <paragraph>Your scene tree and viewport should look like this.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_09_scene_setup.png'}" original_uri="img/signals_09_scene_setup.png" uri="getting_started/step_by_step/img/signals_09_scene_setup.png"></image>
            <paragraph>Save your newly created scene as <literal>node_2d.tscn</literal>, if you haven't already.
                You can then run it with <literal classes="kbd">F6</literal> (<literal classes="kbd">Cmd + R</literal> on macOS).
                At the moment, the button will be visible, but nothing will happen if you
                press it.</paragraph>
        </section>
        <section ids="connecting-a-signal-in-the-editor" names="connecting\ a\ signal\ in\ the\ editor">
            <title>Connecting a signal in the editor</title>
            <paragraph>Here, we want to connect the Button's "pressed" signal to our Sprite2D, and we
                want to call a new function that will toggle its motion on and off. We need to
                have a script attached to the Sprite2D node, which we do from the previous
                lesson.</paragraph>
            <paragraph>You can connect signals in the <inline classes="role-ui">Node</inline> dock. Select the Button node and, on the
                right side of the editor, click on the tab named <inline classes="role-ui">Node</inline> next to the
                <inline classes="role-ui">Inspector</inline>.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_10_node_dock.webp'}" original_uri="img/signals_10_node_dock.webp" uri="getting_started/step_by_step/img/signals_10_node_dock.webp"></image>
            <paragraph>The dock displays a list of signals available on the selected node.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_11_pressed_signals.webp'}" original_uri="img/signals_11_pressed_signals.webp" uri="getting_started/step_by_step/img/signals_11_pressed_signals.webp"></image>
            <paragraph>Double-click the "pressed" signal to open the node connection window.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_12_node_connection.webp'}" original_uri="img/signals_12_node_connection.webp" uri="getting_started/step_by_step/img/signals_12_node_connection.webp"></image>
            <paragraph>There, you can connect the signal to the Sprite2D node. The node needs a
                receiver method, a function that Godot will call when the Button emits the
                signal. The editor generates one for you. By convention, we name these callback
                methods "_on_node_name_signal_name". Here, it'll be "_on_button_pressed".</paragraph>
            <note>
                <paragraph>When connecting signals via the editor's Node dock, you can use two
                    modes. The simple one only allows you to connect to nodes that have a
                    script attached to them and creates a new callback function on them.</paragraph>
                <image candidates="{'*': 'getting_started/step_by_step/img/signals_advanced_connection_window.png'}" original_uri="img/signals_advanced_connection_window.png" uri="getting_started/step_by_step/img/signals_advanced_connection_window.png"></image>
                <paragraph>The advanced view lets you connect to any node and any built-in
                    function, add arguments to the callback, and set options. You can
                    toggle the mode in the window's bottom-right by clicking the <inline classes="role-button role-ui">Advanced</inline>
                    button.</paragraph>
            </note>
            <note>
                <paragraph>If you are using an external editor (such as VS Code), this
                    automatic code generation might not work. In this case, you need to connect
                    the signal via code as explained in the next section.</paragraph>
            </note>
            <paragraph>Click the <inline classes="role-button role-ui">Connect</inline> button to complete the signal connection and jump to the
                <inline classes="role-ui">Script</inline> workspace. You should see the new method with a connection icon in the
                left margin.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_13_signals_connection_icon.webp'}" original_uri="img/signals_13_signals_connection_icon.webp" uri="getting_started/step_by_step/img/signals_13_signals_connection_icon.webp"></image>
            <paragraph>If you click the icon, a window pops up and displays information about the
                connection. This feature is only available when connecting nodes in the editor.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_14_signals_connection_info.webp'}" original_uri="img/signals_14_signals_connection_info.webp" uri="getting_started/step_by_step/img/signals_14_signals_connection_info.webp"></image>
            <paragraph>Let's replace the line with the <literal>pass</literal> keyword with code that'll toggle the
                node's motion.</paragraph>
            <paragraph>Our Sprite2D moves thanks to code in the <literal>_process()</literal> function. Godot provides
                a method to toggle processing on and off: <reference internal="True" refuri="../../classes/class_node#class-node-method-set-process"><inline classes="std std-ref">Node.set_process()</inline></reference>. Another method of the Node class,
                <literal>is_processing()</literal>, returns <literal>true</literal> if idle processing is active. We can use
                the <literal>not</literal> keyword to invert the value.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-0-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_button_pressed():
    set_process(not is_processing())</literal_block>
                </div>
                <div aria-labelledby="tab-0-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">// We also specified this function name in PascalCase in the editor's connection window.
private void OnButtonPressed()
{
    SetProcess(!IsProcessing());
}</literal_block>
                </div>
            </container>
            <paragraph>This function will toggle processing and, in turn, the icon's motion on and off
                upon pressing the button.</paragraph>
            <paragraph>Before trying the game, we need to simplify our <literal>_process()</literal> function to move
                the node automatically and not wait for user input. Replace it with the
                following code, which we saw two lessons ago:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-1-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-1-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _process(delta):
    rotation += angular_speed * delta
    var velocity = Vector2.UP.rotated(rotation) * speed
    position += velocity * delta</literal_block>
                </div>
                <div aria-labelledby="tab-1-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Process(double delta)
{
    Rotation += _angularSpeed * (float)delta;
    var velocity = Vector2.Up.Rotated(Rotation) * _speed;
    Position += velocity * (float)delta;
}</literal_block>
                </div>
            </container>
            <paragraph>Your complete <literal>sprite_2d.gd</literal> code should look like the following.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-2-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-2-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Sprite2D

var speed = 400
var angular_speed = PI


func _process(delta):
    rotation += angular_speed * delta
    var velocity = Vector2.UP.rotated(rotation) * speed
    position += velocity * delta


func _on_button_pressed():
    set_process(not is_processing())</literal_block>
                </div>
                <div aria-labelledby="tab-2-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MySprite2D : Sprite2D
{
    private float _speed = 400;
    private float _angularSpeed = Mathf.Pi;

    public override void _Process(double delta)
    {
        Rotation += _angularSpeed * (float)delta;
        var velocity = Vector2.Up.Rotated(Rotation) * _speed;
        Position += velocity * (float)delta;
    }

    // We also specified this function name in PascalCase in the editor's connection window.
    private void OnButtonPressed()
    {
        SetProcess(!IsProcessing());
    }
}</literal_block>
                </div>
            </container>
            <paragraph>Run the current scene by pressing <literal classes="kbd">F6</literal> (<literal classes="kbd">Cmd + R</literal> on macOS),
                and click the button to see the sprite start and stop.</paragraph>
        </section>
        <section ids="connecting-a-signal-via-code" names="connecting\ a\ signal\ via\ code">
            <title>Connecting a signal via code</title>
            <paragraph>You can connect signals via code instead of using the editor. This is necessary
                when you create nodes or instantiate scenes inside of a script.</paragraph>
            <paragraph>Let's use a different node here. Godot has a <reference internal="True" refuri="../../classes/class_timer#class-timer"><inline classes="std std-ref">Timer</inline></reference> node
                that's useful to implement skill cooldown times, weapon reloading, and more.</paragraph>
            <paragraph>Head back to the 2D workspace. You can either click the "2D" text at the top of
                the window or press <literal classes="kbd">Ctrl + F1</literal> (<literal classes="kbd">Ctrl + Cmd + 1</literal> on macOS).</paragraph>
            <paragraph>In the Scene dock, right-click on the Sprite2D node and add a new child node.
                Search for Timer and add the corresponding node. Your scene should now look like
                this.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_15_scene_tree.webp'}" original_uri="img/signals_15_scene_tree.webp" uri="getting_started/step_by_step/img/signals_15_scene_tree.webp"></image>
            <paragraph>With the Timer node selected, go to the <inline classes="role-ui">Inspector</inline> and enable the <inline classes="role-ui">Autostart</inline>
                property.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_18_timer_autostart.webp'}" original_uri="img/signals_18_timer_autostart.webp" uri="getting_started/step_by_step/img/signals_18_timer_autostart.webp"></image>
            <paragraph>Click the script icon next to Sprite2D to jump back to the scripting workspace.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_16_click_script.webp'}" original_uri="img/signals_16_click_script.webp" uri="getting_started/step_by_step/img/signals_16_click_script.webp"></image>
            <paragraph>We need to do two operations to connect the nodes via code:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Get a reference to the Timer from the Sprite2D.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Call the <literal>connect()</literal> method on the Timer's "timeout" signal.</paragraph>
                </list_item>
            </enumerated_list>
            <note>
                <paragraph>To connect to a signal via code, you need to call the <literal>connect()</literal>
                    method of the signal you want to listen to. In this case, we want to
                    listen to the Timer's "timeout" signal.</paragraph>
            </note>
            <paragraph>We want to connect the signal when the scene is instantiated, and we can do that
                using the <reference internal="True" refuri="../../classes/class_node#class-node-private-method-ready"><inline classes="std std-ref">Node._ready()</inline></reference> built-in function,
                which is called automatically by the engine when a node is fully instantiated.</paragraph>
            <paragraph>To get a reference to a node relative to the current one, we use the method
                <reference internal="True" refuri="../../classes/class_node#class-node-method-get-node"><inline classes="std std-ref">Node.get_node()</inline></reference>. We can store the reference
                in a variable.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-3-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-3-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    var timer = get_node("Timer")</literal_block>
                </div>
                <div aria-labelledby="tab-3-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    var timer = GetNode&lt;Timer&gt;("Timer");
}</literal_block>
                </div>
            </container>
            <paragraph>The function <literal>get_node()</literal> looks at the Sprite2D's children and gets nodes by
                their name. For example, if you renamed the Timer node to "BlinkingTimer" in the
                editor, you would have to change the call to <literal>get_node("BlinkingTimer")</literal>.</paragraph>
            <comment xml:space="preserve">add seealso to a page that explains node features.</comment>
            <paragraph>We can now connect the Timer to the Sprite2D in the <literal>_ready()</literal> function.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-4-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-4-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _ready():
    var timer = get_node("Timer")
    timer.timeout.connect(_on_timer_timeout)</literal_block>
                </div>
                <div aria-labelledby="tab-4-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public override void _Ready()
{
    var timer = GetNode&lt;Timer&gt;("Timer");
    timer.Timeout += OnTimerTimeout;
}</literal_block>
                </div>
            </container>
            <paragraph>The line reads like so: we connect the Timer's "timeout" signal to the node to
                which the script is attached. When the Timer emits <literal>timeout</literal>, we want to call
                the function <literal>_on_timer_timeout()</literal>, that we need to define. Let's add it at the
                bottom of our script and use it to toggle our sprite's visibility.</paragraph>
            <note>
                <paragraph>By convention, we name these callback methods in GDScript as
                    "_on_node_name_signal_name" and in C# as "OnNodeNameSignalName".
                    Here, it'll be "_on_timer_timeout" for GDScript and OnTimerTimeout() for C#.</paragraph>
            </note>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-5-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-5-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func _on_timer_timeout():
    visible = not visible</literal_block>
                </div>
                <div aria-labelledby="tab-5-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">private void OnTimerTimeout()
{
    Visible = !Visible;
}</literal_block>
                </div>
            </container>
            <paragraph>The <literal>visible</literal> property is a boolean that controls the visibility of our node.
                The line <literal>visible = not visible</literal> toggles the value. If <literal>visible</literal> is
                <literal>true</literal>, it becomes <literal>false</literal>, and vice-versa.</paragraph>
            <paragraph>If you run the Node2D scene now, you will see that the sprite blinks on and off, at one
                second intervals.</paragraph>
        </section>
        <section ids="complete-script" names="complete\ script">
            <title>Complete script</title>
            <paragraph>That's it for our little moving and blinking Godot icon demo!
                Here is the complete <literal>sprite_2d.gd</literal> file for reference.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-6-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-6-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Sprite2D

var speed = 400
var angular_speed = PI


func _ready():
    var timer = get_node("Timer")
    timer.timeout.connect(_on_timer_timeout)


func _process(delta):
    rotation += angular_speed * delta
    var velocity = Vector2.UP.rotated(rotation) * speed
    position += velocity * delta


func _on_button_pressed():
    set_process(not is_processing())


func _on_timer_timeout():
    visible = not visible</literal_block>
                </div>
                <div aria-labelledby="tab-6-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MySprite2D : Sprite2D
{
    private float _speed = 400;
    private float _angularSpeed = Mathf.Pi;

    public override void _Ready()
    {
        var timer = GetNode&lt;Timer&gt;("Timer");
        timer.Timeout += OnTimerTimeout;
    }

    public override void _Process(double delta)
    {
        Rotation += _angularSpeed * (float)delta;
        var velocity = Vector2.Up.Rotated(Rotation) * _speed;
        Position += velocity * (float)delta;
    }

    // We also specified this function name in PascalCase in the editor's connection window.
    private void OnButtonPressed()
    {
        SetProcess(!IsProcessing());
    }

    private void OnTimerTimeout()
    {
        Visible = !Visible;
    }
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="custom-signals" names="custom\ signals">
            <title>Custom signals</title>
            <note>
                <paragraph>This section is a reference on how to define and use your own signals,
                    and does not build upon the project created in previous lessons.</paragraph>
            </note>
            <paragraph>You can define custom signals in a script. Say, for example, that you want to
                show a game over screen when the player's health reaches zero. To do so, you
                could define a signal named "died" or "health_depleted" when their health
                reaches 0.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-7-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-7-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

signal health_depleted

var health = 10</literal_block>
                </div>
                <div aria-labelledby="tab-7-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode2D : Node2D
{
    [Signal]
    public delegate void HealthDepletedEventHandler();

    private int _health = 10;
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph>As signals represent events that just occurred, we generally use an
                    action verb in the past tense in their names.</paragraph>
            </note>
            <paragraph>Your signals work the same way as built-in ones: they appear in the <inline classes="role-ui">Node</inline> tab and
                you can connect to them like any other.</paragraph>
            <image candidates="{'*': 'getting_started/step_by_step/img/signals_17_custom_signal.webp'}" original_uri="img/signals_17_custom_signal.webp" uri="getting_started/step_by_step/img/signals_17_custom_signal.webp"></image>
            <paragraph>To emit a signal in your scripts, call <literal>emit()</literal> on the signal.</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-8-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-8-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func take_damage(amount):
    health -= amount
    if health &lt;= 0:
        health_depleted.emit()</literal_block>
                </div>
                <div aria-labelledby="tab-8-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void TakeDamage(int amount)
{
    _health -= amount;

    if (_health &lt;= 0)
    {
        EmitSignal(SignalName.HealthDepleted);
    }
}</literal_block>
                </div>
            </container>
            <paragraph>A signal can optionally declare one or more arguments. Specify the argument
                names between parentheses:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-9-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-9-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-9-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-9-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-9-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">extends Node2D

signal health_changed(old_value, new_value)

var health = 10</literal_block>
                </div>
                <div aria-labelledby="tab-9-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-9-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">using Godot;

public partial class MyNode : Node
{
    [Signal]
    public delegate void HealthChangedEventHandler(int oldValue, int newValue);

    private int _health = 10;
}</literal_block>
                </div>
            </container>
            <note>
                <paragraph>The signal arguments show up in the editor's node dock, and Godot can use
                    them to generate callback functions for you. However, you can still emit any
                    number of arguments when you emit signals. So it's up to you to emit the
                    correct values.</paragraph>
            </note>
            <paragraph>To emit values along with the signal, add them as extra arguments to the
                <literal>emit()</literal> function:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-10-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                    <button aria-controls="panel-10-QyM=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-10-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
                </div>
                <div aria-labelledby="tab-10-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-10-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">func take_damage(amount):
    var old_health = health
    health -= amount
    health_changed.emit(old_health, health)</literal_block>
                </div>
                <div aria-labelledby="tab-10-QyM=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-10-QyM=" name="QyM=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="csharp" linenos="False" xml:space="preserve">public void TakeDamage(int amount)
{
    int oldHealth = _health;
    _health -= amount;
    EmitSignal(SignalName.HealthChanged, oldHealth, _health);
}</literal_block>
                </div>
            </container>
        </section>
        <section ids="summary" names="summary">
            <title>Summary</title>
            <paragraph>Any node in Godot emits signals when something specific happens to them, like a
                button being pressed. Other nodes can connect to individual signals and react to
                selected events.</paragraph>
            <paragraph>Signals have many uses. With them, you can react to a node entering or exiting
                the game world, to a collision, to a character entering or leaving an area, to
                an element of the interface changing size, and much more.</paragraph>
            <paragraph>For example, an <reference internal="True" refuri="../../classes/class_area2d#class-area2d"><inline classes="std std-ref">Area2D</inline></reference> representing a coin emits a
                <literal>body_entered</literal> signal whenever the player's physics body enters its collision
                shape, allowing you to know when the player collected it.</paragraph>
            <paragraph>In the next section, <reference internal="True" refuri="../first_2d_game/index#doc-your-first-2d-game"><inline classes="std std-ref">Your first 2D game</inline></reference>, you'll create a complete 2D
                game and put everything you learned so far into practice.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
