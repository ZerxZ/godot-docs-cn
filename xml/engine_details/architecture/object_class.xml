<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/engine_details/architecture/object_class.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-object-class"></target>
    <section ids="object-class doc-object-class" names="object\ class doc_object_class">
        <title>Object class</title>
        <seealso>
            <paragraph>This page describes the C++ implementation of objects in Godot.
                Looking for the Object class reference? <reference internal="True" refuri="../../classes/class_object#class-object"><inline classes="std std-ref">Have a look here.</inline></reference></paragraph>
        </seealso>
        <section ids="general-definition" names="general\ definition">
            <title>General definition</title>
            <paragraph><reference internal="True" refuri="../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference> is the base class for almost everything. Most classes in Godot
                inherit directly or indirectly from it. Declaring them is a matter of using a single
                macro like this:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">class CustomObject : public Object {
    GDCLASS(CustomObject, Object); // This is required to inherit from Object.
};</literal_block>
            <paragraph>Objects come with a lot of built-in functionality, like reflection and editable properties:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">CustomObject *obj = memnew(CustomObject);
print_line("Object class: ", obj-&gt;get_class()); // print object class

OtherClass *obj2 = Object::cast_to&lt;OtherClass&gt;(obj); // Converting between classes, similar to dynamic_cast</literal_block>
            <section dupnames="references:" ids="references">
                <title>References:</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/object/object.h" refuri="https://github.com/godotengine/godot/blob/master/core/object/object.h">core/object/object.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="registering-object-classes" names="registering\ object\ classes">
            <title>Registering Object classes</title>
            <paragraph>Most <literal>Object</literal> subclasses are registered by calling <literal>GDREGISTER_CLASS</literal>.</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">GDREGISTER_CLASS(MyCustomClass)</literal_block>
            <paragraph>This will register it as a named, public class in the <literal>ClassDB</literal>, which will allow the class to be instantiated by
                scripts, code, or by deserialization. Note that classes registered as <literal>GDREGISTER_CLASS</literal> should expect to be
                instantiated or freed automatically, for example by the editor or the documentation system.</paragraph>
            <paragraph>Besides <literal>GDREGISTER_CLASS</literal>, there are a few other modes of privateness:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// Registers the class publicly, but prevents automatic instantiation through ClassDB.
GDREGISTER_VIRTUAL_CLASS(MyCustomClass);

// Registers the class publicly, but prevents all instantiation through ClassDB.
GDREGISTER_ABSTRACT_CLASS(MyCustomClass);

// Registers the class in ClassDB, but marks it as private,
// such that it is not visible to scripts or extensions.
// This is the same as not registering the class explicitly at all
// - in this case, the class is registered as internal automatically
// when it is first constructed.
GDREGISTER_INTERNAL_CLASS(MyCustomClass);

// Registers the class such that it is only available at runtime (but not in the editor).
GDREGISTER_RUNTIME_CLASS(MyCustomClass);</literal_block>
            <paragraph>It is also possible to use <literal>GDSOFTCLASS(MyCustomClass, SuperClass)</literal> instead of <literal>GDCLASS(MyCustomClass, SuperClass)</literal>.
                Classes defined this way are not registered in the <literal>ClassDB</literal> at all. This is sometimes used for platform-specific
                subclasses.</paragraph>
            <section ids="registering-bindings" names="registering\ bindings">
                <title>Registering bindings</title>
                <paragraph>Object-derived classes can override the static function
                    <literal>static void _bind_methods()</literal>. When the class is registered, this
                    static function is called to register all the object methods,
                    properties, constants, etc. It's only called once.</paragraph>
                <paragraph>Inside <literal>_bind_methods</literal>, there are a couple of things that can be done.
                    Registering functions is one:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">ClassDB::bind_method(D_METHOD("methodname", "arg1name", "arg2name", "arg3name"), &amp;MyCustomType::method);</literal_block>
                <paragraph>Default values for arguments can be passed as parameters at the end:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">ClassDB::bind_method(D_METHOD("methodname", "arg1name", "arg2name", "arg3name"), &amp;MyCustomType::method, DEFVAL(-1), DEFVAL(-2)); // Default values for arg2name (-1) and arg3name (-2).</literal_block>
                <paragraph>Default values must be provided in the same order as they are declared,
                    skipping required arguments and then providing default values for the optional ones.
                    This matches the syntax for declaring methods in C++.</paragraph>
                <paragraph><literal>D_METHOD</literal> is a macro that converts "methodname" to a StringName for more
                    efficiency. Argument names are used for introspection, but when
                    compiling on release, the macro ignores them, so the strings are unused
                    and optimized away.</paragraph>
                <paragraph>Check <literal>_bind_methods</literal> of Control or Object for more examples.</paragraph>
                <paragraph>If just adding modules and functionality that is not expected to be
                    documented as thoroughly, the <literal>D_METHOD()</literal> macro can safely be ignored and a
                    string passing the name can be passed for brevity.</paragraph>
                <section dupnames="references:" ids="id1">
                    <title>References:</title>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><reference name="core/object/class_db.h" refuri="https://github.com/godotengine/godot/blob/master/core/object/class_db.h">core/object/class_db.h</reference></paragraph>
                        </list_item>
                    </bullet_list>
                </section>
            </section>
            <section ids="constants" names="constants">
                <title>Constants</title>
                <paragraph>Classes often have enums such as:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">enum SomeMode {
   MODE_FIRST,
   MODE_SECOND
};</literal_block>
                <paragraph>For these to work when binding to methods, the enum must be declared
                    convertible to int. A macro is provided to help with this:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">VARIANT_ENUM_CAST(MyClass::SomeMode); // now functions that take SomeMode can be bound.</literal_block>
                <paragraph>The constants can also be bound inside <literal>_bind_methods</literal>, by using:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">BIND_CONSTANT(MODE_FIRST);
BIND_CONSTANT(MODE_SECOND);</literal_block>
            </section>
            <section ids="properties-set-get" names="properties\ (set/get)">
                <title>Properties (set/get)</title>
                <paragraph>Objects export properties, properties are useful for the following:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Serializing and deserializing the object.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Creating a list of editable values for the Object derived class.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Properties are usually defined by the PropertyInfo() class and
                    constructed as:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">PropertyInfo(type, name, hint, hint_string, usage_flags)</literal_block>
                <paragraph>For example:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">PropertyInfo(Variant::INT, "amount", PROPERTY_HINT_RANGE, "0,49,1", PROPERTY_USAGE_EDITOR)</literal_block>
                <paragraph>This is an integer property named "amount". The hint is a range, and the range
                    goes from 0 to 49 in steps of 1 (integers). It is only usable for the editor
                    (editing the value visually) but won't be serialized.</paragraph>
                <paragraph>Another example:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">PropertyInfo(Variant::STRING, "modes", PROPERTY_HINT_ENUM, "Enabled,Disabled,Turbo")</literal_block>
                <paragraph>This is a string property, can take any string but the editor will only
                    allow the defined hint ones. Since no usage flags were specified, the
                    default ones are PROPERTY_USAGE_STORAGE and PROPERTY_USAGE_EDITOR.</paragraph>
                <paragraph>There are plenty of hints and usage flags available in object.h, give them a
                    check.</paragraph>
                <paragraph>Properties can also work like C# properties and be accessed from script
                    using indexing, but this usage is generally discouraged, as using
                    functions is preferred for legibility. Many properties are also bound
                    with categories, such as "animation/frame" which also make indexing
                    impossible unless using operator [].</paragraph>
                <paragraph>From <literal>_bind_methods()</literal>, properties can be created and bound as long as
                    set/get functions exist. Example:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">ADD_PROPERTY(PropertyInfo(Variant::INT, "amount"), "set_amount", "get_amount")</literal_block>
                <paragraph>This creates the property using the setter and the getter.</paragraph>
                <target refid="doc-binding-properties-using-set-get-property-list"></target>
            </section>
            <section ids="binding-properties-using-set-get-get-property-list doc-binding-properties-using-set-get-property-list" names="binding\ properties\ using\ _set/_get/_get_property_list doc_binding_properties_using_set_get_property_list">
                <title>Binding properties using <literal>_set</literal>/<literal>_get</literal>/<literal>_get_property_list</literal></title>
                <paragraph>An additional method of creating properties exists when more flexibility
                    is desired (i.e. adding or removing properties on context).</paragraph>
                <paragraph>The following functions can be overridden in an Object derived class,
                    they are NOT virtual, DO NOT make them virtual, they are called for
                    every override and the previous ones are not invalidated (multilevel
                    call).</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">protected:
     void _get_property_list(List&lt;PropertyInfo&gt; *r_props) const;      // return list of properties
     bool _get(const StringName &amp;p_property, Variant &amp;r_value) const; // return true if property was found
     bool _set(const StringName &amp;p_property, const Variant &amp;p_value); // return true if property was found</literal_block>
                <paragraph>This is also a little less efficient since <literal>p_property</literal> must be
                    compared against the desired names in serial order.</paragraph>
            </section>
            <section ids="signals" names="signals">
                <title>Signals</title>
                <paragraph>Objects can have a set of signals defined (similar to Delegates in other
                    languages). This example shows how to connect to them:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// This is the function signature:
//
// Error connect(const StringName &amp;p_signal, const Callable &amp;p_callable, uint32_t p_flags = 0)
//
// For example:
obj-&gt;connect("signal_name_here", callable_mp(this, &amp;MyCustomType::method), CONNECT_DEFERRED);</literal_block>
                <paragraph><literal>callable_mp</literal> is a macro to create a custom callable function pointer to member functions.
                    For the values of <literal>p_flags</literal>, see <reference internal="True" refuri="../../classes/class_object#enum-object-connectflags"><inline classes="std std-ref">ConnectFlags</inline></reference>.</paragraph>
                <paragraph>Adding signals to a class is done in <literal>_bind_methods</literal>, using the
                    <literal>ADD_SIGNAL</literal> macro, for example:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">ADD_SIGNAL(MethodInfo("been_killed"))</literal_block>
            </section>
        </section>
        <section ids="object-ownership-and-casting" names="object\ ownership\ and\ casting">
            <title>Object ownership and casting</title>
            <paragraph>Objects are allocated on the heap. There are two different ownership models:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Objects derived from <literal>RefCounted</literal> are reference counted.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>All other objects are manually memory managed.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The ownership models are fundamentally different. Refer to the section for each respectively to learn how to
                create, store, and free the object.</paragraph>
            <paragraph>When you do not know whether an object passed to you (via <literal>Object *</literal>) is <literal>RefCounted</literal>, and you need to store it,
                you should store its <literal>ObjectID</literal> rather than a pointer (as explained below, in the manual memory management section).</paragraph>
            <paragraph>When an object is passed to you via <reference internal="True" refuri="../../classes/class_variant#class-variant"><inline classes="std std-ref">Variant</inline></reference>, especially when using deferred callbacks, it is
                possible that the contained <literal>Object *</literal> was already freed by the time your function runs.
                Instead of converting directly to <literal>Object *</literal>, you should use <literal>get_validated_object</literal>:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void do_something(Variant p_variant) {
    Object *object = p_variant.get_validated_object();
    ERR_FAIL_NULL(object);
}</literal_block>
            <section ids="manual-memory-management" names="manual\ memory\ management">
                <title>Manual memory management</title>
                <paragraph>Manually memory managed objects are created using <literal>memnew</literal> and freed using <literal>memdelete</literal>:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">Node *node = memnew(Node);
// ...
memdelete(node);
node = nullptr;</literal_block>
                <paragraph>When you are not the sole owner of an object, storing a pointer to it is dangerous: The object may at any point be
                    freed through other references to it, causing your pointer to become a dangling pointer, which will eventually result in
                    a crash.</paragraph>
                <paragraph>When storing objects you are not the only owner of, you should store its <literal>ObjectID</literal> rather than a pointer:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">Node *node = memnew(Node);
ObjectID node_id = node.get_instance_id();
// ...
Object *maybe_node = ObjectDB::get_instance(node_id);
ERR_FAIL_NULL(maybe_node); // The node may have been freed between calls.</literal_block>
            </section>
            <section ids="refcounted-memory-management" names="refcounted\ memory\ management">
                <title><literal>RefCounted</literal> memory management</title>
                <paragraph><reference internal="True" refuri="../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> subclasses are memory managed with
                    <reference name="reference counting semantics" refuri="https://en.wikipedia.org/wiki/Reference_counting">reference counting semantics</reference>.</paragraph>
                <paragraph>They are constructed using <literal>memnew</literal>, and should be stored in <literal>Ref</literal> instances. When the last <literal>Ref</literal> instance is
                    dropped, the object automatically self-destructs.</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">class MyRefCounted: public RefCounted {
    GDCLASS(MyReference, RefCounted);
};

Ref&lt;MyRefCounted&gt; my_ref = memnew(MyRefCounted);
// ...
// Ref holds shared ownership over the object, so the object
// will not be freed. As long as you have a valid, non-null
// Ref, it can be safely assumed the object is still valid.
my_ref-&gt;get_class_name();</literal_block>
                <paragraph>You should never call <literal>memdelete</literal> for <literal>RefCounted</literal> subclasses, because there may be other owners of it.</paragraph>
                <paragraph>You should also never store <literal>RefCounted</literal> subclasses using raw pointers, for example
                    <literal>RefCounted *object = memnew(RefCounted)</literal>. This is unsafe because other owners may destruct the object, leaving you
                    with a dangling pointer, which will eventually result in a crash.</paragraph>
                <section dupnames="references:" ids="id2">
                    <title>References:</title>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><reference name="core/object/ref_counted.h" refuri="https://github.com/godotengine/godot/blob/master/core/object/ref_counted.h">core/object/ref_counted.h</reference></paragraph>
                        </list_item>
                    </bullet_list>
                </section>
            </section>
            <section ids="dynamic-casting" names="dynamic\ casting">
                <title>Dynamic casting</title>
                <paragraph>Godot provides dynamic casting between Object-derived classes, for example:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void some_func(Object *p_object) {
     Button *button = Object::cast_to&lt;Button&gt;(p_object);
}</literal_block>
                <paragraph>If the cast fails, <literal>nullptr</literal> is returned. This works the same as <literal>dynamic_cast</literal>, but does not use
                    <reference name="C++ RTTI" refuri="https://en.wikipedia.org/wiki/Run-time_type_information">C++ RTTI</reference>.</paragraph>
            </section>
        </section>
        <section ids="notifications" names="notifications">
            <title>Notifications</title>
            <paragraph>All objects in Godot have a <reference internal="True" refuri="../../classes/class_object#class-object-private-method-notification"><inline classes="std std-ref">_notification</inline></reference>
                method that allows them to respond to engine-level callbacks that may relate to it.
                More information can be found on the <reference internal="True" refuri="../../tutorials/best_practices/godot_notifications#doc-godot-notifications"><inline classes="std std-ref">Godot notifications</inline></reference> page.</paragraph>
        </section>
        <section ids="resources" names="resources">
            <title>Resources</title>
            <paragraph><reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> inherits from RefCounted, so all resources
                are reference counted. Resources can optionally contain a path, which
                reference a file on disk. This can be set with <literal>resource.set_path(path)</literal>,
                though this is normally done by the resource loader. No two different
                resources can have the same path; attempting to do so will result in an error.</paragraph>
            <paragraph>Resources without a path are fine too.</paragraph>
            <section dupnames="references:" ids="id3">
                <title>References:</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/io/resource.h" refuri="https://github.com/godotengine/godot/blob/master/core/io/resource.h">core/io/resource.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="resource-loading" names="resource\ loading">
                <title>Resource loading</title>
                <paragraph>Resources can be loaded with the ResourceLoader API, like this:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">Ref&lt;Resource&gt; res = ResourceLoader::load("res://someresource.res")</literal_block>
                <paragraph>If a reference to that resource has been loaded previously and is in
                    memory, the resource loader will return that reference. This means that
                    there can be only one resource loaded from a file referenced on disk at
                    the same time.</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>resourceinteractiveloader (TODO)</paragraph>
                    </list_item>
                </bullet_list>
                <section dupnames="references:" ids="id4">
                    <title>References:</title>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><reference name="core/io/resource_loader.h" refuri="https://github.com/godotengine/godot/blob/master/core/io/resource_loader.h">core/io/resource_loader.h</reference></paragraph>
                        </list_item>
                    </bullet_list>
                </section>
            </section>
            <section ids="resource-saving" names="resource\ saving">
                <title>Resource saving</title>
                <paragraph>Saving a resource can be done with the resource saver API:</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">ResourceSaver::save("res://someresource.res", instance)</literal_block>
                <paragraph>The instance will be saved, and sub resources that have a path to a file will
                    be saved as a reference to that resource. Sub resources without a path will
                    be bundled with the saved resource and assigned sub-IDs, like
                    <literal>res://someresource.res::1</literal>. This also helps to cache them when loaded.</paragraph>
                <section dupnames="references:" ids="id5">
                    <title>References:</title>
                    <bullet_list bullet="-">
                        <list_item>
                            <paragraph><reference name="core/io/resource_saver.h" refuri="https://github.com/godotengine/godot/blob/master/core/io/resource_saver.h">core/io/resource_saver.h</reference></paragraph>
                        </list_item>
                    </bullet_list>
                    <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
                </section>
            </section>
        </section>
    </section>
</document>
