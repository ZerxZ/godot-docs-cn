<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/engine_details/architecture/custom_modules_in_cpp.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-custom-modules-in-cpp"></target>
    <section ids="custom-modules-in-c doc-custom-modules-in-cpp" names="custom\ modules\ in\ c++ doc_custom_modules_in_cpp">
        <title>Custom modules in C++</title>
        <section ids="modules" names="modules">
            <title>Modules</title>
            <paragraph>Godot allows extending the engine in a modular way. New modules can be
                created and then enabled/disabled. This allows for adding new engine
                functionality at every level without modifying the core, which can be
                split for use and reuse in different modules.</paragraph>
            <paragraph>Modules are located in the <literal>modules/</literal> subdirectory of the build system.
                By default, dozens of modules are enabled, such as GDScript (which, yes,
                is not part of the base engine), GridMap support, a regular expressions
                module, and others. As many new modules as desired can be
                created and combined. The SCons build system will take care of it
                transparently.</paragraph>
        </section>
        <section ids="what-for" names="what\ for?">
            <title>What for?</title>
            <paragraph>While it's recommended that most of a game be written in scripting (as
                it is an enormous time saver), it's perfectly possible to use C++
                instead. Adding C++ modules can be useful in the following scenarios:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Binding an external library to Godot (like PhysX, FMOD, etc).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Optimize critical parts of a game.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Adding new functionality to the engine and/or editor.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Porting an existing game to Godot.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Write a whole, new game in C++ because you can't live without C++.</paragraph>
                </list_item>
            </bullet_list>
            <note>
                <paragraph>While it is possible to use modules for custom game logic,
                    <reference internal="True" refuri="../../tutorials/scripting/gdextension/index#doc-gdextension"><inline classes="std std-ref">GDExtension</inline></reference> is generally more suited as it doesn't
                    require recompiling the engine after every code change.</paragraph>
                <paragraph>C++ modules are mainly needed when GDExtension doesn't suffice and deeper engine
                    integration is required.</paragraph>
            </note>
        </section>
        <section ids="creating-a-new-module" names="creating\ a\ new\ module">
            <title>Creating a new module</title>
            <paragraph>Before creating a module, make sure to <reference internal="True" refuri="../development/compiling/index#toc-devel-compiling"><inline classes="std std-ref">download the source code of Godot
                        and compile it</inline></reference>.</paragraph>
            <paragraph>To create a new module, the first step is creating a directory inside
                <literal>modules/</literal>. If you want to maintain the module separately, you can checkout
                a different VCS into modules and use it.</paragraph>
            <paragraph>The example module will be called "summator" (<literal>godot/modules/summator</literal>).
                Inside we will create a summator class:</paragraph>
            <container classes="literal-block-wrapper" ids="id1" literal_block="True">
                <caption>godot/modules/summator/summator.h</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#pragma once

#include "core/object/ref_counted.h"

class Summator : public RefCounted {
    GDCLASS(Summator, RefCounted);

    int count;

protected:
    static void _bind_methods();

public:
    void add(int p_value);
    void reset();
    int get_total() const;

    Summator();
};</literal_block>
            </container>
            <paragraph>And then the cpp file.</paragraph>
            <container classes="literal-block-wrapper" ids="id2" literal_block="True">
                <caption>godot/modules/summator/summator.cpp</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "summator.h"

void Summator::add(int p_value) {
    count += p_value;
}

void Summator::reset() {
    count = 0;
}

int Summator::get_total() const {
    return count;
}

void Summator::_bind_methods() {
    ClassDB::bind_method(D_METHOD("add", "value"), &amp;Summator::add);
    ClassDB::bind_method(D_METHOD("reset"), &amp;Summator::reset);
    ClassDB::bind_method(D_METHOD("get_total"), &amp;Summator::get_total);
}

Summator::Summator() {
    count = 0;
}</literal_block>
            </container>
            <paragraph>Then, the new class needs to be registered somehow, so two more files
                need to be created:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">register_types.h
register_types.cpp</literal_block>
            <important>
                <paragraph>These files must be in the top-level folder of your module (next to your
                    <literal>SCsub</literal> and <literal>config.py</literal> files) for the module to be registered properly.</paragraph>
            </important>
            <paragraph>These files should contain the following:</paragraph>
            <container classes="literal-block-wrapper" ids="id3" literal_block="True">
                <caption>godot/modules/summator/register_types.h</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "modules/register_module_types.h"

void initialize_summator_module(ModuleInitializationLevel p_level);
void uninitialize_summator_module(ModuleInitializationLevel p_level);
/* yes, the word in the middle must be the same as the module folder name */</literal_block>
            </container>
            <container classes="literal-block-wrapper" ids="id4" literal_block="True">
                <caption>godot/modules/summator/register_types.cpp</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "register_types.h"

#include "core/object/class_db.h"
#include "summator.h"

void initialize_summator_module(ModuleInitializationLevel p_level) {
    if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) {
        return;
    }
    ClassDB::register_class&lt;Summator&gt;();
}

void uninitialize_summator_module(ModuleInitializationLevel p_level) {
    if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) {
        return;
    }
   // Nothing to do here in this example.
}</literal_block>
            </container>
            <paragraph>Next, we need to create an <literal>SCsub</literal> file so the build system compiles
                this module:</paragraph>
            <container classes="literal-block-wrapper" ids="id5" literal_block="True">
                <caption>godot/modules/summator/SCsub</caption>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># SCsub

Import('env')

env.add_source_files(env.modules_sources, "*.cpp") # Add all cpp files to the build</literal_block>
            </container>
            <paragraph>With multiple sources, you can also add each file individually to a Python
                string list:</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">src_list = ["summator.cpp", "other.cpp", "etc.cpp"]
env.add_source_files(env.modules_sources, src_list)</literal_block>
            <paragraph>This allows for powerful possibilities using Python to construct the file list
                using loops and logic statements. Look at some modules that ship with Godot by
                default for examples.</paragraph>
            <paragraph>To add include directories for the compiler to look at you can append it to the
                environment's paths:</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">env.Append(CPPPATH=["mylib/include"]) # this is a relative path
env.Append(CPPPATH=["#myotherlib/include"]) # this is an 'absolute' path</literal_block>
            <paragraph>If you want to add custom compiler flags when building your module, you need to clone
                <literal>env</literal> first, so it won't add those flags to whole Godot build (which can cause errors).
                Example <literal>SCsub</literal> with custom flags:</paragraph>
            <container classes="literal-block-wrapper" ids="id6" literal_block="True">
                <caption>godot/modules/summator/SCsub</caption>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">Import('env')

module_env = env.Clone()
module_env.add_source_files(env.modules_sources, "*.cpp")
# Append CCFLAGS flags for both C and C++ code.
module_env.Append(CCFLAGS=['-O2'])
# If you need to, you can:
# - Append CFLAGS for C code only.
# - Append CXXFLAGS for C++ code only.</literal_block>
            </container>
            <paragraph>And finally, the configuration file for the module, this is a
                Python script that must be named <literal>config.py</literal>:</paragraph>
            <container classes="literal-block-wrapper" ids="id7" literal_block="True">
                <caption>godot/modules/summator/config.py</caption>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># config.py

def can_build(env, platform):
    return True

def configure(env):
    pass</literal_block>
            </container>
            <paragraph>The module is asked if it's OK to build for the specific platform (in
                this case, <literal>True</literal> means it will build for every platform).</paragraph>
            <paragraph>And that's it. Hope it was not too complex! Your module should look like
                this:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">godot/modules/summator/config.py
godot/modules/summator/summator.h
godot/modules/summator/summator.cpp
godot/modules/summator/register_types.h
godot/modules/summator/register_types.cpp
godot/modules/summator/SCsub</literal_block>
            <paragraph>You can then zip it and share the module with everyone else. When
                building for every platform (instructions in the previous sections),
                your module will be included.</paragraph>
        </section>
        <section ids="using-the-module" names="using\ the\ module">
            <title>Using the module</title>
            <paragraph>You can now use your newly created module from any script:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var s = Summator.new()
s.add(10)
s.add(20)
s.add(30)
print(s.get_total())
s.reset()</literal_block>
                </div>
            </container>
            <paragraph>The output will be <literal>60</literal>.</paragraph>
            <seealso>
                <paragraph>The previous Summator example is great for small, custom modules,
                    but what if you want to use a larger, external library? Refer to
                    <reference internal="True" refuri="binding_to_external_libraries#doc-binding-to-external-libraries"><inline classes="std std-ref">Binding to external libraries</inline></reference> for details about binding to
                    external libraries.</paragraph>
            </seealso>
            <warning>
                <paragraph>If your module is meant to be accessed from the running project
                    (not just from the editor), you must also recompile every export
                    template you plan to use, then specify the path to the custom
                    template in each export preset. Otherwise, you'll get errors when
                    running the project as the module isn't compiled in the export
                    template. See the <reference internal="True" refuri="../development/compiling/index#toc-devel-compiling"><inline classes="std std-ref">Compiling</inline></reference> pages
                    for more information.</paragraph>
            </warning>
        </section>
        <section ids="compiling-a-module-externally" names="compiling\ a\ module\ externally">
            <title>Compiling a module externally</title>
            <paragraph>Compiling a module involves moving the module's sources directly under the
                engine's <literal>modules/</literal> directory. While this is the most straightforward way to
                compile a module, there are a couple of reasons as to why this might not be a
                practical thing to do:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Having to manually copy modules sources every time you want to compile the
                        engine with or without the module, or taking additional steps needed to
                        manually disable a module during compilation with a build option similar to
                        <literal>module_summator_enabled=no</literal>. Creating symbolic links may also be a solution,
                        but you may additionally need to overcome OS restrictions like needing the
                        symbolic link privilege if doing this via script.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Depending on whether you have to work with the engine's source code, the
                        module files added directly to <literal>modules/</literal> changes the working tree to the
                        point where using a VCS (like <literal>git</literal>) proves to be cumbersome as you need to
                        make sure that only the engine-related code is committed by filtering
                        changes.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>So if you feel like the independent structure of custom modules is needed, lets
                take our "summator" module and move it to the engine's parent directory:</paragraph>
            <literal_block force="False" highlight_args="{}" language="shell" linenos="False" xml:space="preserve">mkdir ../modules
mv modules/summator ../modules</literal_block>
            <paragraph>Compile the engine with our module by providing <literal>custom_modules</literal> build option
                which accepts a comma-separated list of directory paths containing custom C++
                modules, similar to the following:</paragraph>
            <literal_block force="False" highlight_args="{}" language="shell" linenos="False" xml:space="preserve">scons custom_modules=../modules</literal_block>
            <paragraph>The build system shall detect all modules under the <literal>../modules</literal> directory
                and compile them accordingly, including our "summator" module.</paragraph>
            <warning>
                <paragraph>Any path passed to <literal>custom_modules</literal> will be converted to an absolute path
                    internally as a way to distinguish between custom and built-in modules. It
                    means that things like generating module documentation may rely on a
                    specific path structure on your machine.</paragraph>
            </warning>
            <seealso>
                <paragraph><reference internal="True" refuri="../development/compiling/introduction_to_the_buildsystem#doc-buildsystem-custom-modules"><inline classes="std std-ref">Introduction to the buildsystem - Custom modules build option</inline></reference>.</paragraph>
            </seealso>
        </section>
        <section ids="customizing-module-types-initialization" names="customizing\ module\ types\ initialization">
            <title>Customizing module types initialization</title>
            <paragraph>Modules can interact with other built-in engine classes during runtime and even
                affect the way core types are initialized. So far, we've been using
                <literal>register_summator_types</literal> as a way to bring in module classes to be available
                within the engine.</paragraph>
            <paragraph>A crude order of the engine setup can be summarized as a list of the following
                type registration methods:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">preregister_module_types();
preregister_server_types();
register_core_singletons();
register_server_types();
register_scene_types();
EditorNode::register_editor_types();
register_platform_apis();
register_module_types();
initialize_physics();
initialize_navigation_server();
register_server_singletons();
register_driver_types();
ScriptServer::init_languages();</literal_block>
            <paragraph>Our <literal>Summator</literal> class is initialized during the <literal>register_module_types()</literal>
                call. Imagine that we need to satisfy some common module runtime dependency
                (like singletons), or allow us to override existing engine method callbacks
                before they can be assigned by the engine itself. In that case, we want to
                ensure that our module classes are registered <emphasis>before</emphasis> any other built-in type.</paragraph>
            <paragraph>This is where we can define an optional <literal>preregister_summator_types()</literal>
                method which will be called before anything else during the
                <literal>preregister_module_types()</literal> engine setup stage.</paragraph>
            <paragraph>We now need to add this method to <literal>register_types</literal> header and source files:</paragraph>
            <container classes="literal-block-wrapper" ids="id8" literal_block="True">
                <caption>godot/modules/summator/register_types.h</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#define MODULE_SUMMATOR_HAS_PREREGISTER
void preregister_summator_types();

void register_summator_types();
void unregister_summator_types();</literal_block>
            </container>
            <note>
                <paragraph>Unlike other register methods, we have to explicitly define
                    <literal>MODULE_SUMMATOR_HAS_PREREGISTER</literal> to let the build system know what
                    relevant method calls to include at compile time. The module's name
                    has to be converted to uppercase as well.</paragraph>
            </note>
            <container classes="literal-block-wrapper" ids="id9" literal_block="True">
                <caption>godot/modules/summator/register_types.cpp</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "register_types.h"

#include "core/object/class_db.h"
#include "summator.h"

void preregister_summator_types() {
    // Called before any other core types are registered.
    // Nothing to do here in this example.
}

void register_summator_types() {
    ClassDB::register_class&lt;Summator&gt;();
}

void unregister_summator_types() {
   // Nothing to do here in this example.
}</literal_block>
            </container>
        </section>
        <section ids="writing-custom-documentation" names="writing\ custom\ documentation">
            <title>Writing custom documentation</title>
            <paragraph>Writing documentation may seem like a boring task, but it is highly recommended
                to document your newly created module to make it easier for users to benefit
                from it. Not to mention that the code you've written one year ago may become
                indistinguishable from the code that was written by someone else, so be kind to
                your future self!</paragraph>
            <paragraph>There are several steps in order to setup custom docs for the module:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Make a new directory in the root of the module. The directory name can be
                        anything, but we'll be using the <literal>doc_classes</literal> name throughout this section.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Now, we need to edit <literal>config.py</literal>, add the following snippet:</paragraph>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">def get_doc_path():
    return "doc_classes"

def get_doc_classes():
    return [
        "Summator",
    ]</literal_block>
                </list_item>
            </enumerated_list>
            <paragraph>The <literal>get_doc_path()</literal> function is used by the build system to determine
                the location of the docs. In this case, they will be located in the
                <literal>modules/summator/doc_classes</literal> directory. If you don't define this,
                the doc path for your module will fall back to the main <literal>doc/classes</literal>
                directory.</paragraph>
            <paragraph>The <literal>get_doc_classes()</literal> method is necessary for the build system to
                know which registered classes belong to the module. You need to list all of your
                classes here. The classes that you don't list will end up in the
                main <literal>doc/classes</literal> directory.</paragraph>
            <tip>
                <paragraph>You can use Git to check if you have missed some of your classes by checking the
                    untracked files with <literal>git status</literal>. For example:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">git status</literal_block>
                <paragraph>Example output:</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">Untracked files:
    (use "git add &lt;file&gt;..." to include in what will be committed)

    doc/classes/MyClass2D.xml
    doc/classes/MyClass4D.xml
    doc/classes/MyClass5D.xml
    doc/classes/MyClass6D.xml
    ...</literal_block>
            </tip>
            <enumerated_list enumtype="arabic" prefix="" start="3" suffix=".">
                <list_item>
                    <paragraph>Now we can generate the documentation:</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>We can do this via running Godot's doctool i.e. <literal>godot --doctool &lt;path&gt;</literal>,
                which will dump the engine API reference to the given <literal>&lt;path&gt;</literal> in XML format.</paragraph>
            <paragraph>In our case we'll point it to the root of the cloned repository. You can point it
                to an another folder, and just copy over the files that you need.</paragraph>
            <paragraph>Run command:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">bin/&lt;godot_binary&gt; --doctool .</literal_block>
            <paragraph>Now if you go to the <literal>godot/modules/summator/doc_classes</literal> folder, you will see
                that it contains a <literal>Summator.xml</literal> file, or any other classes, that you referenced
                in your <literal>get_doc_classes</literal> function.</paragraph>
            <paragraph>Edit the file(s) following the <reference name="class reference primer" refuri="https://contributing.godotengine.org/en/latest/documentation/class_reference/class_reference_primer.html">class reference primer</reference> and recompile the engine.</paragraph>
            <paragraph>Once the compilation process is finished, the docs will become accessible within
                the engine's built-in documentation system.</paragraph>
            <paragraph>In order to keep documentation up-to-date, all you'll have to do is simply modify
                one of the XML files and recompile the engine from now on.</paragraph>
            <paragraph>If you change your module's API, you can also re-extract the docs, they will contain
                the things that you previously added. Of course if you point it to your godot
                folder, make sure you don't lose work by extracting older docs from an older engine build
                on top of the newer ones.</paragraph>
            <paragraph>Note that if you don't have write access rights to your supplied <literal>&lt;path&gt;</literal>,
                you might encounter an error similar to the following:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">ERROR: Can't write doc file: docs/doc/classes/@GDScript.xml
   At: editor/doc/doc_data.cpp:956</literal_block>
            <target refid="doc-custom-module-unit-tests"></target>
        </section>
        <section ids="writing-custom-unit-tests doc-custom-module-unit-tests" names="writing\ custom\ unit\ tests doc_custom_module_unit_tests">
            <title>Writing custom unit tests</title>
            <paragraph>It's possible to write self-contained unit tests as part of a C++ module. If you
                are not familiar with the unit testing process in Godot yet, please refer to
                <reference internal="True" refuri="unit_testing#doc-unit-testing"><inline classes="std std-ref">Unit testing</inline></reference>.</paragraph>
            <paragraph>The procedure is the following:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Create a new directory named <literal>tests/</literal> under your module's root:</paragraph>
                </list_item>
            </enumerated_list>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">cd modules/summator
mkdir tests
cd tests</literal_block>
            <enumerated_list enumtype="arabic" prefix="" start="2" suffix=".">
                <list_item>
                    <paragraph>Create a new test suite: <literal>test_summator.h</literal>. The header must be prefixed
                        with <literal>test_</literal> so that the build system can collect it and include it as part
                        of the <literal>tests/test_main.cpp</literal> where the tests are run.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Write some test cases. Here's an example:</paragraph>
                </list_item>
            </enumerated_list>
            <container classes="literal-block-wrapper" ids="id10" literal_block="True">
                <caption>godot/modules/summator/tests/test_summator.h</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#pragma once

#include "tests/test_macros.h"

#include "modules/summator/summator.h"

namespace TestSummator {

TEST_CASE("[Modules][Summator] Adding numbers") {
    Ref&lt;Summator&gt; s = memnew(Summator);
    CHECK(s-&gt;get_total() == 0);

    s-&gt;add(10);
    CHECK(s-&gt;get_total() == 10);

    s-&gt;add(20);
    CHECK(s-&gt;get_total() == 30);

    s-&gt;add(30);
    CHECK(s-&gt;get_total() == 60);

    s-&gt;reset();
    CHECK(s-&gt;get_total() == 0);
}

} // namespace TestSummator</literal_block>
            </container>
            <enumerated_list enumtype="arabic" prefix="" start="4" suffix=".">
                <list_item>
                    <paragraph>Compile the engine with <literal>scons tests=yes</literal>, and run the tests with the
                        following command:</paragraph>
                </list_item>
            </enumerated_list>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">./bin/&lt;godot_binary&gt; --test --source-file="*test_summator*" --success</literal_block>
            <paragraph>You should see the passing assertions now.</paragraph>
            <target refid="doc-custom-module-icons"></target>
        </section>
        <section ids="adding-custom-editor-icons doc-custom-module-icons" names="adding\ custom\ editor\ icons doc_custom_module_icons">
            <title>Adding custom editor icons</title>
            <paragraph>Similarly to how you can write self-contained documentation within a module,
                you can also create your own custom icons for classes to appear in the editor.</paragraph>
            <paragraph>For the actual process of creating editor icons to be integrated within the engine,
                please refer to <reference internal="True" refuri="../editor/creating_icons#doc-editor-icons"><inline classes="std std-ref">Editor icons</inline></reference> first.</paragraph>
            <paragraph>Once you've created your icon(s), proceed with the following steps:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Make a new directory in the root of the module named <literal>icons</literal>. This is the
                        default path for the engine to look for module's editor icons.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Move your newly created <literal>svg</literal> icons (optimized or not) into that folder.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Recompile the engine and run the editor. Now the icon(s) will appear in
                        editor's interface where appropriate.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>If you'd like to store your icons somewhere else within your module,
                add the following code snippet to <literal>config.py</literal> to override the default path:</paragraph>
            <block_quote>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">def get_icons_path():
    return "path/to/icons"</literal_block>
            </block_quote>
        </section>
        <section ids="summing-up" names="summing\ up">
            <title>Summing up</title>
            <paragraph>Remember to:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Use <literal>GDCLASS</literal> macro for inheritance, so Godot can wrap it.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Use <literal>_bind_methods</literal> to bind your functions to scripting, and to
                        allow them to work as callbacks for signals.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Avoid multiple inheritance for classes exposed to Godot</strong>, as <literal>GDCLASS</literal>
                        doesn't support this. You can still use multiple inheritance in your own
                        classes as long as they're not exposed to Godot's scripting API.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>But this is not all, depending what you do, you will be greeted with
                some (hopefully positive) surprises.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>If you inherit from <reference internal="True" refuri="../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> (or any derived node type, such as
                        Sprite2D), your new class will appear in the editor, in the inheritance
                        tree in the "Add Node" dialog.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>If you inherit from <reference internal="True" refuri="../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference>, it will appear in the resource
                        list, and all the exposed properties can be serialized when
                        saved/loaded.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>By this same logic, you can extend the Editor and almost any area of
                        the engine.</paragraph>
                </list_item>
            </bullet_list>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
