<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/engine_details/architecture/custom_audiostreams.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-custom-audiostreams"></target>
    <section ids="custom-audiostreams doc-custom-audiostreams" names="custom\ audiostreams doc_custom_audiostreams">
        <title>Custom AudioStreams</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>AudioStream is the base class of all audio emitting objects.
                AudioStreamPlayer binds onto an AudioStream to emit PCM data
                into an AudioServer which manages audio drivers.</paragraph>
            <paragraph>All audio resources require two audio based classes: AudioStream
                and AudioStreamPlayback. As a data container, AudioStream contains
                the resource and exposes itself to GDScript. AudioStream references
                its own internal custom AudioStreamPlayback which translates
                AudioStream into PCM data.</paragraph>
            <paragraph>This guide assumes the reader knows how to create C++ modules. If not, refer to this guide
                <reference internal="True" refuri="custom_modules_in_cpp#doc-custom-modules-in-cpp"><inline classes="std std-ref">Custom modules in C++</inline></reference>.</paragraph>
            <section dupnames="references:" ids="references">
                <title>References:</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/audio/audio_stream.h" refuri="https://github.com/godotengine/godot/blob/master/servers/audio/audio_stream.h">servers/audio/audio_stream.h</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="scene/audio/audio_stream_player.cpp" refuri="https://github.com/godotengine/godot/blob/master/scene/audio/audio_stream_player.cpp">scene/audio/audio_stream_player.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="what-for" names="what\ for?">
            <title>What for?</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Binding external libraries (like Wwise, FMOD, etc).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Adding custom audio queues</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Adding support for more audio formats</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="create-an-audiostream" names="create\ an\ audiostream">
            <title>Create an AudioStream</title>
            <paragraph>An AudioStream consists of three components: data container, stream name,
                and an AudioStreamPlayback friend class generator. Audio data can be
                loaded in a number of ways such as with an internal counter for a tone generator,
                internal/external buffer, or a file reference.</paragraph>
            <paragraph>Some AudioStreams need to be stateless such as objects loaded from
                ResourceLoader. ResourceLoader loads once and references the same
                object regardless how many times <literal>load</literal> is called on a specific resource.
                Therefore, playback state must be self-contained in AudioStreamPlayback.</paragraph>
            <container classes="literal-block-wrapper" ids="id3" literal_block="True">
                <caption>audiostream_mytone.h</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "core/reference.h"
#include "core/resource.h"
#include "servers/audio/audio_stream.h"

class AudioStreamMyTone : public AudioStream {
    GDCLASS(AudioStreamMyTone, AudioStream)

private:
    friend class AudioStreamPlaybackMyTone;
    uint64_t pos;
    int mix_rate;
    bool stereo;
    int hz;

public:
    void reset();
    void set_position(uint64_t pos);
    virtual Ref&lt;AudioStreamPlayback&gt; instance_playback();
    virtual String get_stream_name() const;
    void gen_tone(int16_t *pcm_buf, int size);
    virtual float get_length() const { return 0; } // if supported, otherwise return 0
    AudioStreamMyTone();

protected:
    static void _bind_methods();
};</literal_block>
            </container>
            <container classes="literal-block-wrapper" ids="id4" literal_block="True">
                <caption>audiostream_mytone.cpp</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "audiostream_mytone.h"

AudioStreamMyTone::AudioStreamMyTone()
        : mix_rate(44100), stereo(false), hz(639) {
}

Ref&lt;AudioStreamPlayback&gt; AudioStreamMyTone::instance_playback() {
    Ref&lt;AudioStreamPlaybackMyTone&gt; talking_tree;
    talking_tree.instantiate();
    talking_tree-&gt;base = Ref&lt;AudioStreamMyTone&gt;(this);
    return talking_tree;
}

String AudioStreamMyTone::get_stream_name() const {
    return "MyTone";
}
void AudioStreamMyTone::reset() {
    set_position(0);
}
void AudioStreamMyTone::set_position(uint64_t p) {
    pos = p;
}
void AudioStreamMyTone::gen_tone(int16_t *pcm_buf, int size) {
    for (int i = 0; i &lt; size; i++) {
        pcm_buf[i] = 32767.0 * sin(2.0 * Math_PI * double(pos + i) / (double(mix_rate) / double(hz)));
    }
    pos += size;
}
void AudioStreamMyTone::_bind_methods() {
    ClassDB::bind_method(D_METHOD("reset"), &amp;AudioStreamMyTone::reset);
    ClassDB::bind_method(D_METHOD("get_stream_name"), &amp;AudioStreamMyTone::get_stream_name);
}</literal_block>
            </container>
            <section dupnames="references:" ids="id1">
                <title>References:</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/audio/audio_stream.h" refuri="https://github.com/godotengine/godot/blob/master/servers/audio/audio_stream.h">servers/audio/audio_stream.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="create-an-audiostreamplayback" names="create\ an\ audiostreamplayback">
            <title>Create an AudioStreamPlayback</title>
            <paragraph>AudioStreamPlayer uses <literal>mix</literal> callback to obtain PCM data. The callback must match sample rate and fill the buffer.</paragraph>
            <paragraph>Since AudioStreamPlayback is controlled by the audio thread, i/o and dynamic memory allocation are forbidden.</paragraph>
            <container classes="literal-block-wrapper" ids="id5" literal_block="True">
                <caption>audiostreamplayer_mytone.h</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "core/reference.h"
#include "core/resource.h"
#include "servers/audio/audio_stream.h"

class AudioStreamPlaybackMyTone : public AudioStreamPlayback {
    GDCLASS(AudioStreamPlaybackMyTone, AudioStreamPlayback)
    friend class AudioStreamMyTone;

private:
    enum {
        PCM_BUFFER_SIZE = 4096
    };
    enum {
        MIX_FRAC_BITS = 13,
        MIX_FRAC_LEN = (1 &lt;&lt; MIX_FRAC_BITS),
        MIX_FRAC_MASK = MIX_FRAC_LEN - 1,
    };
    void *pcm_buffer;
    Ref&lt;AudioStreamMyTone&gt; base;
    bool active;

public:
    virtual void start(float p_from_pos = 0.0);
    virtual void stop();
    virtual bool is_playing() const;
    virtual int get_loop_count() const; // times it looped
    virtual float get_playback_position() const;
    virtual void seek(float p_time);
    virtual void mix(AudioFrame *p_buffer, float p_rate_scale, int p_frames);
    virtual float get_length() const; // if supported, otherwise return 0
    AudioStreamPlaybackMyTone();
    ~AudioStreamPlaybackMyTone();
};</literal_block>
            </container>
            <container classes="literal-block-wrapper" ids="id6" literal_block="True">
                <caption>audiostreamplayer_mytone.cpp</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "audiostreamplayer_mytone.h"

#include "core/math/math_funcs.h"
#include "core/print_string.h"

AudioStreamPlaybackMyTone::AudioStreamPlaybackMyTone()
        : active(false) {
    AudioServer::get_singleton()-&gt;lock();
    pcm_buffer = AudioServer::get_singleton()-&gt;audio_data_alloc(PCM_BUFFER_SIZE);
    zeromem(pcm_buffer, PCM_BUFFER_SIZE);
    AudioServer::get_singleton()-&gt;unlock();
}
AudioStreamPlaybackMyTone::~AudioStreamPlaybackMyTone() {
    if(pcm_buffer) {
        AudioServer::get_singleton()-&gt;audio_data_free(pcm_buffer);
        pcm_buffer = NULL;
    }
}
void AudioStreamPlaybackMyTone::stop() {
    active = false;
    base-&gt;reset();
}
void AudioStreamPlaybackMyTone::start(float p_from_pos) {
    seek(p_from_pos);
    active = true;
}
void AudioStreamPlaybackMyTone::seek(float p_time) {
    float max = get_length();
    if (p_time &lt; 0) {
            p_time = 0;
    }
    base-&gt;set_position(uint64_t(p_time * base-&gt;mix_rate) &lt;&lt; MIX_FRAC_BITS);
}
void AudioStreamPlaybackMyTone::mix(AudioFrame *p_buffer, float p_rate, int p_frames) {
    ERR_FAIL_COND(!active);
    if (!active) {
            return;
    }
    zeromem(pcm_buffer, PCM_BUFFER_SIZE);
    int16_t *buf = (int16_t *)pcm_buffer;
    base-&gt;gen_tone(buf, p_frames);

    for(int i = 0; i &lt; p_frames; i++) {
        float sample = float(buf[i]) / 32767.0;
        p_buffer[i] = AudioFrame(sample, sample);
    }
}
int AudioStreamPlaybackMyTone::get_loop_count() const {
    return 0;
}
float AudioStreamPlaybackMyTone::get_playback_position() const {
    return 0.0;
}
float AudioStreamPlaybackMyTone::get_length() const {
    return 0.0;
}
bool AudioStreamPlaybackMyTone::is_playing() const {
    return active;
}</literal_block>
            </container>
            <section ids="resampling" names="resampling">
                <title>Resampling</title>
                <paragraph>Godot's AudioServer currently uses 44100 Hz sample rate. When other sample rates are
                    needed such as 48000, either provide one or use AudioStreamPlaybackResampled.
                    Godot provides cubic interpolation for audio resampling.</paragraph>
                <paragraph>Instead of overloading <literal>mix</literal>, AudioStreamPlaybackResampled uses <literal>_mix_internal</literal> to
                    query AudioFrames and <literal>get_stream_sampling_rate</literal> to query current mix rate.</paragraph>
                <container classes="literal-block-wrapper" ids="id7" literal_block="True">
                    <caption>mytone_audiostream_resampled.h</caption>
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "core/reference.h"
#include "core/resource.h"
#include "servers/audio/audio_stream.h"

class AudioStreamMyToneResampled;

class AudioStreamPlaybackResampledMyTone : public AudioStreamPlaybackResampled {
    GDCLASS(AudioStreamPlaybackResampledMyTone, AudioStreamPlaybackResampled)
    friend class AudioStreamMyToneResampled;

private:
    enum {
        PCM_BUFFER_SIZE = 4096
    };
    enum {
        MIX_FRAC_BITS = 13,
        MIX_FRAC_LEN = (1 &lt;&lt; MIX_FRAC_BITS),
        MIX_FRAC_MASK = MIX_FRAC_LEN - 1,
    };
    void *pcm_buffer;
    Ref&lt;AudioStreamMyToneResampled&gt; base;
    bool active;

protected:
    virtual void _mix_internal(AudioFrame *p_buffer, int p_frames);

public:
    virtual void start(float p_from_pos = 0.0);
    virtual void stop();
    virtual bool is_playing() const;
    virtual int get_loop_count() const; // times it looped
    virtual float get_playback_position() const;
    virtual void seek(float p_time);
    virtual float get_length() const; // if supported, otherwise return 0
    virtual float get_stream_sampling_rate();
    AudioStreamPlaybackResampledMyTone();
    ~AudioStreamPlaybackResampledMyTone();
};</literal_block>
                </container>
                <container classes="literal-block-wrapper" ids="id8" literal_block="True">
                    <caption>mytone_audiostream_resampled.cpp</caption>
                    <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "mytone_audiostream_resampled.h"

#include "core/math/math_funcs.h"
#include "core/print_string.h"

AudioStreamPlaybackResampledMyTone::AudioStreamPlaybackResampledMyTone()
        : active(false) {
    AudioServer::get_singleton()-&gt;lock();
    pcm_buffer = AudioServer::get_singleton()-&gt;audio_data_alloc(PCM_BUFFER_SIZE);
    zeromem(pcm_buffer, PCM_BUFFER_SIZE);
    AudioServer::get_singleton()-&gt;unlock();
}
AudioStreamPlaybackResampledMyTone::~AudioStreamPlaybackResampledMyTone() {
    if (pcm_buffer) {
        AudioServer::get_singleton()-&gt;audio_data_free(pcm_buffer);
        pcm_buffer = NULL;
    }
}
void AudioStreamPlaybackResampledMyTone::stop() {
    active = false;
    base-&gt;reset();
}
void AudioStreamPlaybackResampledMyTone::start(float p_from_pos) {
    seek(p_from_pos);
    active = true;
}
void AudioStreamPlaybackResampledMyTone::seek(float p_time) {
    float max = get_length();
    if (p_time &lt; 0) {
            p_time = 0;
    }
    base-&gt;set_position(uint64_t(p_time * base-&gt;mix_rate) &lt;&lt; MIX_FRAC_BITS);
}
void AudioStreamPlaybackResampledMyTone::_mix_internal(AudioFrame *p_buffer, int p_frames) {
    ERR_FAIL_COND(!active);
    if (!active) {
        return;
    }
    zeromem(pcm_buffer, PCM_BUFFER_SIZE);
    int16_t *buf = (int16_t *)pcm_buffer;
    base-&gt;gen_tone(buf, p_frames);

    for(int i = 0;  i &lt; p_frames; i++) {
        float sample = float(buf[i]) / 32767.0;
            p_buffer[i] = AudioFrame(sample, sample);
    }
}
float AudioStreamPlaybackResampledMyTone::get_stream_sampling_rate() {
    return float(base-&gt;mix_rate);
}
int AudioStreamPlaybackResampledMyTone::get_loop_count() const {
    return 0;
}
float AudioStreamPlaybackResampledMyTone::get_playback_position() const {
    return 0.0;
}
float AudioStreamPlaybackResampledMyTone::get_length() const {
    return 0.0;
}
bool AudioStreamPlaybackResampledMyTone::is_playing() const {
    return active;
}</literal_block>
                </container>
            </section>
            <section dupnames="references:" ids="id2">
                <title>References:</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/math/audio_frame.h" refuri="https://github.com/godotengine/godot/blob/master/core/math/audio_frame.h">core/math/audio_frame.h</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/audio/audio_stream.h" refuri="https://github.com/godotengine/godot/blob/master/servers/audio/audio_stream.h">servers/audio/audio_stream.h</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="scene/audio/audio_stream_player.cpp" refuri="https://github.com/godotengine/godot/blob/master/scene/audio/audio_stream_player.cpp">scene/audio/audio_stream_player.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
