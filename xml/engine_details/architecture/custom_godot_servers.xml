<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/engine_details/architecture/custom_godot_servers.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-custom-godot-servers"></target>
    <section ids="custom-godot-servers doc-custom-godot-servers" names="custom\ godot\ servers doc_custom_godot_servers">
        <title>Custom Godot servers</title>
        <section ids="introduction" names="introduction">
            <title>Introduction</title>
            <paragraph>Godot implements multi-threading as servers. Servers are daemons which
                manage data, process it, and push the result. Servers implement the
                mediator pattern which interprets resource ID and process data for the
                engine and other modules. In addition, the server claims ownership for
                its RID allocations.</paragraph>
            <paragraph>This guide assumes the reader knows how to create C++ modules and Godot
                data types. If not, refer to <reference internal="True" refuri="custom_modules_in_cpp#doc-custom-modules-in-cpp"><inline classes="std std-ref">Custom modules in C++</inline></reference>.</paragraph>
            <section dupnames="references" ids="references">
                <title>References</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="Why does Godot use servers and RIDs?" refuri="https://godotengine.org/article/why-does-godot-use-servers-and-rids">Why does Godot use servers and RIDs?</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="Singleton pattern" refuri="https://en.wikipedia.org/wiki/Singleton_pattern">Singleton pattern</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="Mediator pattern" refuri="https://en.wikipedia.org/wiki/Mediator_pattern">Mediator pattern</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="what-for" names="what\ for?">
            <title>What for?</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Adding artificial intelligence.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Adding custom asynchronous threads.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Adding support for a new input device.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Adding writing threads.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Adding a custom VoIP protocol.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>And more...</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="creating-a-godot-server" names="creating\ a\ godot\ server">
            <title>Creating a Godot server</title>
            <paragraph>At minimum, a server must have a static instance, a sleep timer, a thread loop,
                an initialization state and a cleanup procedure.</paragraph>
            <container classes="literal-block-wrapper" ids="id3" literal_block="True">
                <caption>hilbert_hotel.h</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#pragma once

#include "core/object/object.h"
#include "core/os/thread.h"
#include "core/os/mutex.h"
#include "core/templates/list.h"
#include "core/templates/rid.h"
#include "core/templates/set.h"
#include "core/variant/variant.h"

class HilbertHotel : public Object {
    GDCLASS(HilbertHotel, Object);

    static HilbertHotel *singleton;
    static void thread_func(void *p_udata);

private:
    bool thread_exited;
    mutable bool exit_thread;
    Thread *thread;
    Mutex *mutex;

public:
    static HilbertHotel *get_singleton();
    Error init();
    void lock();
    void unlock();
    void finish();

protected:
    static void _bind_methods();

private:
    uint64_t counter;
    RID_Owner&lt;InfiniteBus&gt; bus_owner;
    // https://github.com/godotengine/godot/blob/master/core/templates/rid.h
    Set&lt;RID&gt; buses;
    void _emit_occupy_room(uint64_t room, RID rid);

public:
    RID create_bus();
    Variant get_bus_info(RID id);
    bool empty();
    bool delete_bus(RID id);
    void clear();
    void register_rooms();
    HilbertHotel();
};</literal_block>
            </container>
            <container classes="literal-block-wrapper" ids="id4" literal_block="True">
                <caption>hilbert_hotel.cpp</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "hilbert_hotel.h"

#include "core/variant/dictionary.h"
#include "core/os/os.h"

#include "prime_225.h"

void HilbertHotel::thread_func(void *p_udata) {

    HilbertHotel *ac = (HilbertHotel *) p_udata;
    uint64_t msdelay = 1000;

    while (!ac-&gt;exit_thread) {
        if (!ac-&gt;empty()) {
            ac-&gt;lock();
            ac-&gt;register_rooms();
            ac-&gt;unlock();
        }
        OS::get_singleton()-&gt;delay_usec(msdelay * 1000);
    }
}

Error HilbertHotel::init() {
    thread_exited = false;
    counter = 0;
    mutex = Mutex::create();
    thread = Thread::create(HilbertHotel::thread_func, this);
    return OK;
}

HilbertHotel *HilbertHotel::singleton = NULL;

HilbertHotel *HilbertHotel::get_singleton() {
    return singleton;
}

void HilbertHotel::register_rooms() {
    for (Set&lt;RID&gt;::Element *e = buses.front(); e; e = e-&gt;next()) {
        auto bus = bus_owner.getornull(e-&gt;get());

        if (bus) {
            uint64_t room = bus-&gt;next_room();
            _emit_occupy_room(room, bus-&gt;get_self());
        }
    }
}

void HilbertHotel::unlock() {
    if (!thread || !mutex) {
        return;
    }

    mutex-&gt;unlock();
}

void HilbertHotel::lock() {
    if (!thread || !mutex) {
        return;
    }

    mutex-&gt;lock();
}

void HilbertHotel::_emit_occupy_room(uint64_t room, RID rid) {
    _HilbertHotel::get_singleton()-&gt;_occupy_room(room, rid);
}

Variant HilbertHotel::get_bus_info(RID id) {
    InfiniteBus *bus = bus_owner.getornull(id);

    if (bus) {
        Dictionary d;
        d["prime"] = bus-&gt;get_bus_num();
        d["current_room"] = bus-&gt;get_current_room();
        return d;
    }

    return Variant();
}

void HilbertHotel::finish() {
    if (!thread) {
        return;
    }

    exit_thread = true;
    Thread::wait_to_finish(thread);

    memdelete(thread);

    if (mutex) {
        memdelete(mutex);
    }

    thread = NULL;
}

RID HilbertHotel::create_bus() {
    lock();
    InfiniteBus *ptr = memnew(InfiniteBus(PRIME[counter++]));
    RID ret = bus_owner.make_rid(ptr);
    ptr-&gt;set_self(ret);
    buses.insert(ret);
    unlock();

    return ret;
}

// https://github.com/godotengine/godot/blob/master/core/templates/rid.h
bool HilbertHotel::delete_bus(RID id) {
    if (bus_owner.owns(id)) {
        lock();
        InfiniteBus *b = bus_owner.get(id);
        bus_owner.free(id);
        buses.erase(id);
        memdelete(b);
        unlock();
        return true;
    }

    return false;
}

void HilbertHotel::clear() {
    for (Set&lt;RID&gt;::Element *e = buses.front(); e; e = e-&gt;next()) {
        delete_bus(e-&gt;get());
    }
}

bool HilbertHotel::empty() {
    return buses.size() &lt;= 0;
}

void HilbertHotel::_bind_methods() {
}

HilbertHotel::HilbertHotel() {
    singleton = this;
}</literal_block>
            </container>
            <container classes="literal-block-wrapper" ids="id5" literal_block="True">
                <caption>prime_255.h</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">const uint64_t PRIME[225] = {
        2,3,5,7,11,13,17,19,23,
        29,31,37,41,43,47,53,59,61,
        67,71,73,79,83,89,97,101,103,
        107,109,113,127,131,137,139,149,151,
        157,163,167,173,179,181,191,193,197,
        199,211,223,227,229,233,239,241,251,
        257,263,269,271,277,281,283,293,307,
        311,313,317,331,337,347,349,353,359,
        367,373,379,383,389,397,401,409,419,
        421,431,433,439,443,449,457,461,463,
        467,479,487,491,499,503,509,521,523,
        541,547,557,563,569,571,577,587,593,
        599,601,607,613,617,619,631,641,643,
        647,653,659,661,673,677,683,691,701,
        709,719,727,733,739,743,751,757,761,
        769,773,787,797,809,811,821,823,827,
        829,839,853,857,859,863,877,881,883,
        887,907,911,919,929,937,941,947,953,
        967,971,977,983,991,997,1009,1013,1019,
        1021,1031,1033,1039,1049,1051,1061,1063,1069,
        1087,1091,1093,1097,1103,1109,1117,1123,1129,
        1151,1153,1163,1171,1181,1187,1193,1201,1213,
        1217,1223,1229,1231,1237,1249,1259,1277,1279,
        1283,1289,1291,1297,1301,1303,1307,1319,1321,
        1327,1361,1367,1373,1381,1399,1409,1423,1427
};</literal_block>
            </container>
        </section>
        <section ids="custom-managed-resource-data" names="custom\ managed\ resource\ data">
            <title>Custom managed resource data</title>
            <paragraph>Godot servers implement a mediator pattern. All data types inherit <literal>RID_Data</literal>.
                <literal>RID_Owner&lt;MyRID_Data&gt;</literal> owns the object when <literal>make_rid</literal> is called. During debug mode only,
                RID_Owner maintains a list of RIDs. In practice, RIDs are similar to writing
                object-oriented C code.</paragraph>
            <container classes="literal-block-wrapper" ids="id6" literal_block="True">
                <caption>infinite_bus.h</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">class InfiniteBus : public RID_Data {
    RID self;

private:
    uint64_t prime_num;
    uint64_t num;

public:
    uint64_t next_room() {
        return prime_num * num++;
    }

    uint64_t get_bus_num() const {
        return prime_num;
    }

    uint64_t get_current_room() const {
        return prime_num * num;
    }

    _FORCE_INLINE_ void set_self(const RID &amp;p_self) {
        self = p_self;
    }

    _FORCE_INLINE_ RID get_self() const {
        return self;
    }

    InfiniteBus(uint64_t prime) : prime_num(prime), num(1) {};
    ~InfiniteBus() {};
}</literal_block>
            </container>
            <section dupnames="references" ids="id1">
                <title>References</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference internal="True" refuri="../../classes/class_rid#class-rid"><inline classes="std std-ref">RID</inline></reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="core/templates/rid.h" refuri="https://github.com/godotengine/godot/blob/master/core/templates/rid.h">core/templates/rid.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="registering-the-class-in-gdscript" names="registering\ the\ class\ in\ gdscript">
            <title>Registering the class in GDScript</title>
            <paragraph>Servers are allocated in <literal>register_types.cpp</literal>. The constructor sets the static
                instance and <literal>init()</literal> creates the managed thread; <literal>unregister_types.cpp</literal>
                cleans up the server.</paragraph>
            <paragraph>Since a Godot server class creates an instance and binds it to a static singleton,
                binding the class might not reference the correct instance. Therefore, a dummy
                class must be created to reference the proper Godot server.</paragraph>
            <paragraph>In <literal>register_server_types()</literal>, <literal>Engine::get_singleton()-&gt;add_singleton</literal>
                is used to register the dummy class in GDScript.</paragraph>
            <container classes="literal-block-wrapper" ids="id7" literal_block="True">
                <caption>register_types.h</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">/* Yes, the word in the middle must be the same as the module folder name */
void register_hilbert_hotel_types();
void unregister_hilbert_hotel_types();</literal_block>
            </container>
            <container classes="literal-block-wrapper" ids="id8" literal_block="True">
                <caption>register_types.cpp</caption>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "register_types.h"

#include "core/object/class_db.h"
#include "core/config/engine.h"

#include "hilbert_hotel.h"

static HilbertHotel *hilbert_hotel = NULL;
static _HilbertHotel *_hilbert_hotel = NULL;

void register_hilbert_hotel_types() {
    hilbert_hotel = memnew(HilbertHotel);
    hilbert_hotel-&gt;init();
    _hilbert_hotel = memnew(_HilbertHotel);
    ClassDB::register_class&lt;_HilbertHotel&gt;();
    Engine::get_singleton()-&gt;add_singleton(Engine::Singleton("HilbertHotel", _HilbertHotel::get_singleton()));
}

void unregister_hilbert_hotel_types() {
    if (hilbert_hotel) {
        hilbert_hotel-&gt;finish();
        memdelete(hilbert_hotel);
    }

    if (_hilbert_hotel) {
        memdelete(_hilbert_hotel);
    }
}</literal_block>
            </container>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="servers/register_server_types.cpp" refuri="https://github.com/godotengine/godot/blob/master/servers/register_server_types.cpp">servers/register_server_types.cpp</reference></paragraph>
                </list_item>
            </bullet_list>
            <section ids="bind-methods" names="bind\ methods">
                <title>Bind methods</title>
                <paragraph>The dummy class binds singleton methods to GDScript. In most cases, the dummy class methods wraps around.</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">Variant _HilbertHotel::get_bus_info(RID id) {
    return HilbertHotel::get_singleton()-&gt;get_bus_info(id);
}</literal_block>
                <paragraph>Binding Signals</paragraph>
                <paragraph>It is possible to emit signals to GDScript by calling the GDScript dummy object.</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void HilbertHotel::_emit_occupy_room(uint64_t room, RID rid) {
    _HilbertHotel::get_singleton()-&gt;_occupy_room(room, rid);
}</literal_block>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">class _HilbertHotel : public Object {
    GDCLASS(_HilbertHotel, Object);

    friend class HilbertHotel;
    static _HilbertHotel *singleton;

protected:
    static void _bind_methods();

private:
    void _occupy_room(int room_number, RID bus);

public:
    RID create_bus();
    void connect_signals();
    bool delete_bus(RID id);
    static _HilbertHotel *get_singleton();
    Variant get_bus_info(RID id);

    _HilbertHotel();
    ~_HilbertHotel();
};

#endif</literal_block>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">_HilbertHotel *_HilbertHotel::singleton = NULL;
_HilbertHotel *_HilbertHotel::get_singleton() { return singleton; }

RID _HilbertHotel::create_bus() {
    return HilbertHotel::get_singleton()-&gt;create_bus();
}

bool _HilbertHotel::delete_bus(RID rid) {
    return HilbertHotel::get_singleton()-&gt;delete_bus(rid);
}

void _HilbertHotel::_occupy_room(int room_number, RID bus) {
    emit_signal("occupy_room", room_number, bus);
}

Variant _HilbertHotel::get_bus_info(RID id) {
    return HilbertHotel::get_singleton()-&gt;get_bus_info(id);
}

void _HilbertHotel::_bind_methods() {
    ClassDB::bind_method(D_METHOD("get_bus_info", "r_id"), &amp;_HilbertHotel::get_bus_info);
    ClassDB::bind_method(D_METHOD("create_bus"), &amp;_HilbertHotel::create_bus);
    ClassDB::bind_method(D_METHOD("delete_bus"), &amp;_HilbertHotel::delete_bus);
    ADD_SIGNAL(MethodInfo("occupy_room", PropertyInfo(Variant::INT, "room_number"), PropertyInfo(Variant::_RID, "r_id")));
}

void _HilbertHotel::connect_signals() {
    HilbertHotel::get_singleton()-&gt;connect("occupy_room", _HilbertHotel::get_singleton(), "_occupy_room");
}

_HilbertHotel::_HilbertHotel() {
    singleton = this;
}

_HilbertHotel::~_HilbertHotel() {
}</literal_block>
            </section>
        </section>
        <section ids="messagequeue" names="messagequeue">
            <title>MessageQueue</title>
            <paragraph>In order to send commands into SceneTree, MessageQueue is a thread-safe buffer
                to queue set and call methods for other threads. To queue a command, obtain
                the target object RID and use either <literal>push_call</literal>, <literal>push_set</literal>, or <literal>push_notification</literal>
                to execute the desired behavior. The queue will be flushed whenever either
                <literal>SceneTree::idle</literal> or <literal>SceneTree::iteration</literal> is executed.</paragraph>
            <section ids="id2" names="references:">
                <title>References:</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/object/message_queue.cpp" refuri="https://github.com/godotengine/godot/blob/master/core/object/message_queue.cpp">core/object/message_queue.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="summing-it-up" names="summing\ it\ up">
            <title>Summing it up</title>
            <paragraph>Here is the GDScript sample code:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node

func _ready():
    print("Start debugging")
    HilbertHotel.occupy_room.connect(_print_occupy_room)
    var rid = HilbertHotel.create_bus()
    OS.delay_msec(2000)
    HilbertHotel.create_bus()
    OS.delay_msec(2000)
    HilbertHotel.create_bus()
    OS.delay_msec(2000)
    print(HilbertHotel.get_bus_info(rid))
    HilbertHotel.delete_bus(rid)
    print("Ready done")

func _print_occupy_room(room_number, r_id):
    print("Room number: "  + str(room_number) + ", RID: " + str(r_id))
    print(HilbertHotel.get_bus_info(r_id))</literal_block>
            <section ids="notes" names="notes">
                <title>Notes</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>The actual <reference name="Hilbert Hotel" refuri="https://en.wikipedia.org/wiki/Hilbert%27s_paradox_of_the_Grand_Hotel">Hilbert Hotel</reference> is impossible.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Connecting signal example code is pretty hacky.</paragraph>
                    </list_item>
                </bullet_list>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
