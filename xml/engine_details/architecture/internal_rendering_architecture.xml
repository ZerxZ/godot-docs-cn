<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/engine_details/architecture/internal_rendering_architecture.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-internal-rendering-architecture"></target>
    <section ids="internal-rendering-architecture doc-internal-rendering-architecture" names="internal\ rendering\ architecture doc_internal_rendering_architecture">
        <title>Internal rendering architecture</title>
        <paragraph>This page is a high-level overview of Godot 4's internal renderer design.
            It does not apply to previous Godot versions.</paragraph>
        <paragraph>The goal of this page is to document design decisions taken to best suit
            <reference name="Godot's design philosophy" refuri="https://contributing.godotengine.org/en/latest/engine/guidelines/best_practices.html">Godot's design philosophy</reference>,
            while providing a starting point for new rendering contributors.</paragraph>
        <paragraph>If you have questions about rendering internals not answered here, feel free to
            ask in the <literal>#rendering</literal> channel of the
            <reference name="Godot Contributors Chat" refuri="https://chat.godotengine.org/channel/rendering">Godot Contributors Chat</reference>.</paragraph>
        <note>
            <paragraph>If you have difficulty understanding concepts on this page, it is
                recommended to go through an OpenGL tutorial such as
                <reference name="LearnOpenGL" refuri="https://learnopengl.com/">LearnOpenGL</reference>.</paragraph>
            <paragraph>Modern low-level APIs (Vulkan/Direct3D 12/Metal) require intermediate
                knowledge of higher-level APIs (OpenGL/Direct3D 11) to be used
                effectively. Thankfully, contributors rarely need to work directly with
                low-level APIs. Godot's renderers are built entirely on OpenGL and
                RenderingDevice, which is our abstraction over Vulkan/Direct3D 12/Metal.</paragraph>
        </note>
        <target refid="doc-internal-rendering-architecture-methods"></target>
        <section ids="rendering-methods doc-internal-rendering-architecture-methods" names="rendering\ methods doc_internal_rendering_architecture_methods">
            <title>Rendering methods</title>
            <section ids="forward" names="forward+">
                <title>Forward+</title>
                <paragraph>This is a forward renderer that uses a <emphasis>clustered</emphasis> approach to lighting.</paragraph>
                <paragraph>Clustered lighting uses a compute shader to group lights into a 3D frustum
                    aligned grid. Then, at render time, pixels can lookup what lights affect the
                    grid cell they are in and only run light calculations for lights that might
                    affect that pixel.</paragraph>
                <paragraph>This approach can greatly speed up rendering performance on desktop hardware,
                    but is substantially less efficient on mobile.</paragraph>
            </section>
            <section ids="mobile" names="mobile">
                <title>Mobile</title>
                <paragraph>This is a forward renderer that uses a traditional single-pass approach to lighting.
                    Internally, it is called <strong>Forward Mobile</strong>.</paragraph>
                <paragraph>Intended for mobile platforms, but can also run on desktop platforms. This
                    rendering method is optimized to perform well on mobile GPUs. Mobile GPUs have a
                    very different architecture compared to desktop GPUs due to their unique
                    constraints around battery usage, heat, and overall bandwidth limitations of
                    reading and writing data. Compute shaders also have very limited support or
                    aren't supported at all. As a result, the mobile renderer purely uses
                    raster-based shaders (fragment/vertex).</paragraph>
                <paragraph>Unlike desktop GPUs, mobile GPUs perform <emphasis>tile-based rendering</emphasis>. Instead of
                    rendering the whole image as a single unit, the image is divided in smaller
                    tiles that fit within the faster internal memory of the mobile GPU. Each tile is
                    rendered and then written out to the destination texture. This all happens
                    automatically on the graphics driver.</paragraph>
                <paragraph>The problem is that this introduces bottlenecks in our traditional approach. For
                    desktop rendering, we render all opaque geometry, then handle the background,
                    then transparent geometry, then post-processing. Each pass will need to read the
                    current result into tile memory, perform its operations and then write it out
                    again. We then wait for all tiles to be completed before moving on to the next
                    pass.</paragraph>
                <paragraph>The first important change in the mobile renderer is that the mobile renderer
                    does not use the RGBA16F texture formats that the desktop renderer does.
                    Instead, it is using an R10G10B10A2 UNORM texture format. This halves the bandwidth
                    required and has further improvements as mobile hardware often further optimizes
                    for 32-bit formats. The tradeoff is that the mobile renderer has limited HDR
                    capabilities due to the reduced precision and maximum values in the color data.</paragraph>
                <paragraph>The second important change is the use of sub-passes whenever possible.
                    Sub-passes allows us to perform the rendering steps end-to-end per tile saving
                    on the overhead introduced by reading from and writing to the tiles between each
                    rendering pass. The ability to use sub-passes is limited by the inability to
                    read neighboring pixels, as we're constrained to working within a single tile.</paragraph>
                <paragraph>This limitation of subpasses results in not being able to implement features
                    such as glow and depth of field efficiently. Similarly, if there is a
                    requirement to read from the screen texture or depth texture, we must fully
                    write out the rendering result limiting our ability to use sub-passes. When such
                    features are enabled, a mix of sub-passes and normal passes are used, and these
                    features result in a notable performance penalty.</paragraph>
                <paragraph>On desktop platforms, the use of sub-passes won't have any impact on
                    performance. However, this rendering method can still perform better than
                    Forward+ in simple scenes thanks to its lower complexity and lower
                    bandwidth usage. This is especially noticeable on low-end GPUs, integrated
                    graphics or in VR applications.</paragraph>
                <paragraph>Given its low-end focus, this rendering method does not provide high-end
                    rendering features such as SDFGI and <reference internal="True" refuri="../../tutorials/3d/volumetric_fog#doc-volumetric-fog"><inline classes="std std-ref">Volumetric fog and fog volumes</inline></reference>. Several
                    post-processing effects are also not available.</paragraph>
                <target refid="doc-internal-rendering-architecture-compatibility"></target>
            </section>
            <section ids="compatibility doc-internal-rendering-architecture-compatibility" names="compatibility doc_internal_rendering_architecture_compatibility">
                <title>Compatibility</title>
                <note>
                    <paragraph>This is the only rendering method available when using the OpenGL driver.
                        This rendering method is not available when using Vulkan, Direct3D 12, or Metal.</paragraph>
                </note>
                <paragraph>This is a traditional (non-clustered) forward renderer. Internally, it is called
                    <strong>GL Compatibility</strong>. It's intended for old GPUs that don't have Vulkan support,
                    but still works very efficiently on newer hardware. Specifically, it is optimized
                    for older and lower-end mobile devices. However, many optimizations carry over
                    making it a good choice for older and lower-end desktop as well.</paragraph>
                <paragraph>Like the Mobile renderer, the Compatibility renderer uses an R10G10B10A2 UNORM
                    texture for 3D rendering. Unlike the mobile renderer, colors are tonemapped and
                    stored in sRGB format so there is no HDR support. This avoids the need for a
                    tonemapping pass and allows us to use the lower bit texture without substantial
                    banding.</paragraph>
                <paragraph>The Compatibility renderer uses a traditional forward single-pass approach to
                    drawing objects with lights, but it uses a multi-pass approach to draw lights
                    with shadows. Specifically, in the first pass, it can draw multiple lights
                    without shadows and up to one DirectionalLight3D with shadows. In each
                    subsequent pass, it can draw up to one OmniLight3D, one SpotLight3D and one
                    DirectionalLight3D with shadows. Lights with shadows will affect the scene
                    differently than lights without shadows, as the lighting is blended in sRGB space
                    instead of linear space. This difference in lighting will impact how the scene
                    looks and needs to be kept in mind when designing scenes for the Compatibility
                    renderer.</paragraph>
                <paragraph>Given its low-end focus, this rendering method does not provide high-end
                    rendering features (even less so compared to Mobile). Most
                    post-processing effects are not available.</paragraph>
            </section>
            <section ids="why-not-deferred-rendering" names="why\ not\ deferred\ rendering?">
                <title>Why not deferred rendering?</title>
                <paragraph>Forward rendering generally provides a better tradeoff for performance versus
                    flexibility, especially when a clustered approach to lighting is used. While
                    deferred rendering can be faster in some cases, it's also less flexible and
                    requires using hacks to be able to use MSAA. Since games with a less realistic
                    art style can benefit a lot from MSAA, we chose to go with forward rendering for
                    Godot 4 (like Godot 3).</paragraph>
                <paragraph>That said, parts of the forward renderer <emphasis>are</emphasis> performed with a deferred approach
                    to allow for some optimizations when possible. This applies to VoxelGI and SDFGI
                    in particular.</paragraph>
                <paragraph>A clustered deferred renderer may be developed in the future. This renderer
                    could be used in situations where performance is favored over flexibility.</paragraph>
            </section>
        </section>
        <section ids="rendering-drivers" names="rendering\ drivers">
            <title>Rendering drivers</title>
            <paragraph>Godot 4 supports the following graphics APIs:</paragraph>
            <section ids="vulkan" names="vulkan">
                <title>Vulkan</title>
                <paragraph>This is the main driver in Godot 4, with most of the development focus going
                    towards this driver.</paragraph>
                <paragraph>Vulkan 1.0 is required as a baseline, with optional Vulkan 1.1 and 1.2 features
                    used when available. <reference name="volk" refuri="https://github.com/zeux/volk">volk</reference> is used as a Vulkan
                    loader, and
                    <reference name="Vulkan Memory Allocator" refuri="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">Vulkan Memory Allocator</reference>
                    is used for memory management.</paragraph>
                <paragraph>Both the Forward+ and Mobile
                    <reference internal="True" refid="doc-internal-rendering-architecture-methods"><inline classes="std std-ref">Rendering methods</inline></reference> are supported when using the
                    Vulkan driver.</paragraph>
                <paragraph><strong>Vulkan context creation:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="drivers/vulkan/vulkan_context.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/drivers/vulkan/vulkan_context.cpp">drivers/vulkan/vulkan_context.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Direct3D 12 context creation:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="drivers/d3d12/d3d12_context.cpp" refuri="https://github.com/godotengine/godot/blob/master/drivers/d3d12/d3d12_context.cpp">drivers/d3d12/d3d12_context.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="direct3d-12" names="direct3d\ 12">
                <title>Direct3D 12</title>
                <paragraph>Like Vulkan, the Direct3D 12 driver targets modern platforms only. It is
                    designed to target both Windows and Xbox (whereas Vulkan can't be used directly on Xbox).</paragraph>
                <paragraph>Both the Forward+ and Mobile <reference internal="True" refid="doc-internal-rendering-architecture-methods"><inline classes="std std-ref">Rendering methods</inline></reference> can be
                    used with Direct3D 12.</paragraph>
                <paragraph><reference internal="True" refid="doc-internal-rendering-architecture-core-shaders"><inline classes="std std-ref">Core shaders</inline></reference> are shared with the
                    Vulkan renderer. Shaders are transpiled from
                    <abbreviation explanation="Standard Portable Intermediate Representation">SPIR-V</abbreviation> to
                    <abbreviation explanation="DirectX Intermediate Language">DXIL</abbreviation> using
                    Mesa NIR (<reference name="more information" refuri="https://godotengine.org/article/d3d12-adventures-in-shaderland/">more information</reference>).</paragraph>
                <paragraph><strong>This driver is still experimental and only available in Godot 4.3 and later.</strong>
                    While Direct3D 12 allows supporting Direct3D-exclusive features on Windows 11 such
                    as windowed optimizations and Auto HDR, Vulkan is still recommended for most projects.
                    See the <reference name="pull request that introduced Direct3D 12 support" refuri="https://github.com/godotengine/godot/pull/70315">pull request that introduced Direct3D 12 support</reference>
                    for more information.</paragraph>
            </section>
            <section ids="metal" names="metal">
                <title>Metal</title>
                <paragraph>Godot provides a native Metal driver that works on all Apple Silicon hardware
                    (macOS ARM). Compared to using the MoltenVK translation layer, this is
                    significantly faster, particularly in CPU-bound scenarios.</paragraph>
                <paragraph>Both the Forward+ and Mobile <reference internal="True" refid="doc-internal-rendering-architecture-methods"><inline classes="std std-ref">Rendering methods</inline></reference> can be
                    used with Metal.</paragraph>
                <paragraph><reference internal="True" refid="doc-internal-rendering-architecture-core-shaders"><inline classes="std std-ref">Core shaders</inline></reference> are shared with the
                    Vulkan renderer. Shaders are transpiled from GLSL to <abbreviation explanation="Metal Shading Language">MSL</abbreviation>
                    using SPIRV-Cross.</paragraph>
                <paragraph>Godot also supports Metal rendering via <reference name="MoltenVK" refuri="https://github.com/KhronosGroup/MoltenVK">MoltenVK</reference>,
                    which is used as a fallback when native Metal support is not available (e.g. on x86 macOS).</paragraph>
                <paragraph><strong>This driver is still experimental and only available in Godot 4.4 and later.</strong>
                    See the <reference name="pull request that introduced Metal support" refuri="https://github.com/godotengine/godot/pull/88199">pull request that introduced Metal support</reference>
                    for more information.</paragraph>
            </section>
            <section ids="opengl" names="opengl">
                <title>OpenGL</title>
                <paragraph>This driver uses OpenGL ES 3.0 and targets legacy and low-end devices that don't
                    support Vulkan. OpenGL 3.3 Core Profile is used on desktop platforms to run this
                    driver, as most graphics drivers on desktop don't support OpenGL ES.
                    WebGL 2.0 is used for web exports.</paragraph>
                <paragraph>It is possible to use OpenGL ES 3.0 directly on desktop platforms
                    by passing the <literal>--rendering-driver opengl3_es</literal> command line argument, although this
                    will only work on graphics drivers that feature native OpenGL ES support (such
                    as Mesa).</paragraph>
                <paragraph>Only the <reference internal="True" refid="doc-internal-rendering-architecture-compatibility"><inline classes="std std-ref">Compatibility</inline></reference> rendering
                    method can be used with the OpenGL driver.</paragraph>
                <paragraph><reference internal="True" refid="doc-internal-rendering-architecture-core-shaders"><inline classes="std std-ref">Core shaders</inline></reference> are entirely different
                    from the Vulkan renderer.</paragraph>
                <paragraph>Many advanced features are not supported with this driver, as it targets low-end
                    devices first and foremost.</paragraph>
            </section>
            <section ids="summary-of-rendering-drivers-methods" names="summary\ of\ rendering\ drivers/methods">
                <title>Summary of rendering drivers/methods</title>
                <paragraph>The following rendering API + rendering method combinations are currently possible:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Vulkan + Forward+ (optionally through MoltenVK on macOS and iOS)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Vulkan + Mobile (optionally through MoltenVK on macOS and iOS)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Direct3D 12 + Forward+</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Direct3D 12 + Mobile</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Metal + Forward+</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Metal + Mobile</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>OpenGL + Compatibility (optionally through ANGLE on Windows and macOS)</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Each combination has its own limitations and performance characteristics. Make
                    sure to test your changes on all rendering methods if possible before opening a
                    pull request.</paragraph>
            </section>
        </section>
        <section ids="renderingdevice-abstraction" names="renderingdevice\ abstraction">
            <title>RenderingDevice abstraction</title>
            <note>
                <paragraph>The OpenGL driver does not use the RenderingDevice abstraction.</paragraph>
            </note>
            <paragraph>To make the complexity of modern low-level graphics APIs more manageable,
                Godot uses its own abstraction called RenderingDevice.</paragraph>
            <paragraph>This means that when writing code for modern rendering methods, you don't
                actually use the Vulkan, Direct3D 12, or Metal APIs directly. While this is still
                lower-level than an API like OpenGL, this makes working on the renderer easier,
                as RenderingDevice will abstract many API-specific quirks for you. The
                RenderingDevice presents a similar level of abstraction as WebGPU.</paragraph>
            <paragraph><strong>Vulkan RenderingDevice implementation:</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="drivers/vulkan/rendering_device_driver_vulkan.cpp" refuri="https://github.com/godotengine/godot/blob/master/drivers/vulkan/rendering_device_driver_vulkan.cpp">drivers/vulkan/rendering_device_driver_vulkan.cpp</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>Direct3D 12 RenderingDevice implementation:</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="drivers/d3d12/rendering_device_driver_d3d12.cpp" refuri="https://github.com/godotengine/godot/blob/master/drivers/d3d12/rendering_device_driver_d3d12.cpp">drivers/d3d12/rendering_device_driver_d3d12.cpp</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>Metal RenderingDevice implementation:</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="drivers/metal/rendering_device_driver_metal.mm" refuri="https://github.com/godotengine/godot/blob/master/drivers/metal/rendering_device_driver_metal.mm">drivers/metal/rendering_device_driver_metal.mm</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="core-rendering-classes-architecture" names="core\ rendering\ classes\ architecture">
            <title>Core rendering classes architecture</title>
            <paragraph>This diagram represents the structure of rendering classes in Godot, including the RenderingDevice abstraction:</paragraph>
            <image candidates="{'*': 'engine_details/architecture/img/rendering_architecture_diagram.webp'}" original_uri="img/rendering_architecture_diagram.webp" uri="engine_details/architecture/img/rendering_architecture_diagram.webp"></image>
            <paragraph><reference name="View at full size" refuri="https://raw.githubusercontent.com/godotengine/godot-docs/master/engine_details/architecture/img/rendering_architecture_diagram.webp">View at full size</reference></paragraph>
            <target refid="doc-internal-rendering-architecture-core-shaders"></target>
        </section>
        <section ids="core-shaders doc-internal-rendering-architecture-core-shaders" names="core\ shaders doc_internal_rendering_architecture_core_shaders">
            <title>Core shaders</title>
            <paragraph>While shaders in Godot projects are written using a
                <reference internal="True" refuri="../../tutorials/shaders/shader_reference/shading_language#doc-shading-language"><inline classes="std std-ref">custom language inspired by GLSL</inline></reference>, core shaders are
                written directly in GLSL.</paragraph>
            <paragraph>These core shaders are embedded in the editor and export template binaries at
                compile-time. To see any changes you've made to those GLSL shaders, you need to
                recompile the editor or export template binary.</paragraph>
            <paragraph>Some material features such as height mapping, refraction and proximity fade are
                not part of core shaders, and are performed in the default BaseMaterial3D using
                the Godot shader language instead (not GLSL). This is done by procedurally
                generating the required shader code depending on the features enabled in the
                material.</paragraph>
            <paragraph>By convention, shader files with <literal>_inc</literal> in their name are included in other
                GLSL files for better code reuse. Standard GLSL preprocessing is used to achieve
                this.</paragraph>
            <warning>
                <paragraph>Core material shaders will be used by every material in the scene â€“ both
                    with the default BaseMaterial3D and custom shaders. As a result, these
                    shaders must be kept as simple as possible to avoid performance issues and
                    ensure shader compilation doesn't become too slow.</paragraph>
                <paragraph>If you use <literal>if</literal> branching in a shader, performance may decrease as
                    <abbreviation explanation="Vector General-Purpose Register">VGPR</abbreviation> usage will increase in the
                    shader. This happens even if all pixels evaluate to <literal>true</literal> or <literal>false</literal> in
                    a given frame.</paragraph>
                <paragraph>If you use <literal>#if</literal> preprocessor branching, the number of required shader
                    versions will increase in the scene. In a worst-case scenario, adding a
                    single boolean <literal>#define</literal> can <emphasis>double</emphasis> the number of shader versions that
                    may need to be compiled in a given scene. In some cases, Vulkan
                    specialization constants can be used as a faster (but more limited)
                    alternative.</paragraph>
                <paragraph>This means there is a high barrier to adding new built-in material features
                    in Godot, both in the core shaders and BaseMaterial3D. While BaseMaterial3D
                    can make use of dynamic code generation to only include the shader code if
                    the feature is enabled, it'll still require generating more shader versions
                    when these features are used in a project. This can make shader compilation
                    stutter more noticeable in complex 3D scenes.</paragraph>
                <paragraph>See
                    <reference name="The Shader Permutation Problem" refuri="https://therealmjp.github.io/posts/shader-permutations-part1/">The Shader Permutation Problem</reference>
                    and
                    <reference name="Branching on a GPU" refuri="https://medium.com/@jasonbooth_86226/branching-on-a-gpu-18bfc83694f2">Branching on a GPU</reference>
                    blog posts for more information.</paragraph>
            </warning>
            <paragraph><strong>Core GLSL material shaders:</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Forward+: <reference name="servers/rendering/renderer_rd/shaders/forward_clustered/scene_forward_clustered.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/forward_clustered/scene_forward_clustered.glsl">servers/rendering/renderer_rd/shaders/forward_clustered/scene_forward_clustered.glsl</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph>Mobile: <reference name="servers/rendering/renderer_rd/shaders/forward_mobile/scene_forward_mobile.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/forward_mobile/scene_forward_mobile.glsl">servers/rendering/renderer_rd/shaders/forward_mobile/scene_forward_mobile.glsl</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph>Compatibility: <reference name="drivers/gles3/shaders/scene.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/drivers/gles3/shaders/scene.glsl">drivers/gles3/shaders/scene.glsl</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>Material shader generation:</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="scene/resources/material.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/resources/material.cpp">scene/resources/material.cpp</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>Other GLSL shaders for Forward+ and Mobile rendering methods:</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="servers/rendering/renderer_rd/shaders/" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/">servers/rendering/renderer_rd/shaders/</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="modules/lightmapper_rd/" refuri="https://github.com/godotengine/godot/blob/4.2/modules/lightmapper_rd">modules/lightmapper_rd/</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>Other GLSL shaders for the Compatibility rendering method:</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="drivers/gles3/shaders/" refuri="https://github.com/godotengine/godot/blob/4.2/drivers/gles3/shaders/">drivers/gles3/shaders/</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="d-and-3d-rendering-separation" names="2d\ and\ 3d\ rendering\ separation">
            <title>2D and 3D rendering separation</title>
            <note>
                <paragraph>The following is only applicable in the Forward+ and Mobile
                    rendering methods, not in Compatibility. Multiple Viewports can be used to
                    emulate this when using the Compatibility renderer, or to perform 2D
                    resolution scaling.</paragraph>
            </note>
            <paragraph>2D and 3D are rendered to separate buffers, as 2D rendering in Godot is performed
                in <abbreviation explanation="Low Dynamic Range">LDR</abbreviation> sRGB-space while 3D rendering uses
                <abbreviation explanation="High Dynamic Range">HDR</abbreviation> linear space.</paragraph>
            <paragraph>The color format used for 2D rendering is RGB8 (RGBA8 if the <strong>Transparent</strong>
                property on the Viewport is enabled). 3D rendering uses a 24-bit unsigned
                normalized integer depth buffer, or 32-bit signed floating-point if a 24-bit
                depth buffer is not supported by the hardware. 2D rendering does not use a depth
                buffer.</paragraph>
            <paragraph>3D resolution scaling is performed differently depending on whether bilinear or
                FSR 1.0 scaling is used. When bilinear scaling is used, no special upscaling
                shader is run. Instead, the viewport's texture is stretched and displayed with a
                linear sampler (which makes the filtering happen directly on the hardware). This
                allows maximizing the performance of bilinear 3D scaling.</paragraph>
            <paragraph>The <literal>configure()</literal> function in RenderSceneBuffersRD reallocates the 2D/3D
                buffers when the resolution or scaling changes.</paragraph>
            <comment xml:space="preserve">UPDATE: Planned feature. When dynamic resolution scaling is supported,</comment>
            <comment xml:space="preserve">update this paragraph.</comment>
            <paragraph>Dynamic resolution scaling isn't supported yet, but is planned in a future Godot
                release.</paragraph>
            <paragraph><strong>2D and 3D rendering buffer configuration C++ code:</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="servers/rendering/renderer_rd/storage_rd/render_scene_buffers_rd.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/storage_rd/render_scene_buffers_rd.cpp">servers/rendering/renderer_rd/storage_rd/render_scene_buffers_rd.cpp</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>FSR 1.0:</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="servers/rendering/renderer_rd/effects/fsr.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/effects/fsr.cpp">servers/rendering/renderer_rd/effects/fsr.cpp</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="thirdparty/amd-fsr/" refuri="https://github.com/godotengine/godot/tree/master/thirdparty/amd-fsr">thirdparty/amd-fsr/</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="d-rendering-techniques" names="2d\ rendering\ techniques">
            <title>2D rendering techniques</title>
            <paragraph>2D light rendering is performed in a single pass to allow for better performance
                with large amounts of lights.</paragraph>
            <paragraph>All rendering methods feature 2D batching to improve performance, which is
                especially noticeable with lots of text on screen.</paragraph>
            <paragraph>MSAA can be enabled in 2D to provide "automatic" line and polygon antialiasing,
                but FXAA does not affect 2D rendering as it's calculated before 2D rendering
                begins. Godot's 2D drawing methods such as the Line2D node or some CanvasItem
                <literal>draw_*()</literal> methods provide their own way of antialiasing based on triangle
                strips and vertex colors, which don't require MSAA to work.</paragraph>
            <paragraph>A 2D signed distance field representing LightOccluder2D nodes in the viewport is
                automatically generated if a user shader requests it. This can be used for
                various effects in custom shaders, such as 2D global illumination. It is also
                used to calculate particle collisions in 2D.</paragraph>
            <paragraph><strong>2D SDF generation GLSL shader:</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="servers/rendering/renderer_rd/shaders/canvas_sdf.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/canvas_sdf.glsl">servers/rendering/renderer_rd/shaders/canvas_sdf.glsl</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="id1" names="3d\ rendering\ techniques">
            <title>3D rendering techniques</title>
            <section ids="batching-and-instancing" names="batching\ and\ instancing">
                <title>Batching and instancing</title>
                <paragraph>In the Forward+ renderer, Vulkan instancing is used to group rendering of
                    identical opaque or alpha-tested objects for performance. (Alpha-blended objects
                    are never instanced.) This is not as fast as static mesh merging, but it still
                    allows instances to be culled individually.</paragraph>
            </section>
            <section ids="light-decal-and-reflection-probe-rendering" names="light,\ decal\ and\ reflection\ probe\ rendering">
                <title>Light, decal and reflection probe rendering</title>
                <note>
                    <paragraph>Decal rendering is currently not available in the Compatibility renderer.</paragraph>
                </note>
                <paragraph>The Forward+ renderer uses clustered lighting. This
                    allows using as many lights as you want; performance largely depends on screen
                    coverage. Shadow-less lights can be almost free if they don't occupy much space
                    on screen.</paragraph>
                <paragraph>All rendering methods also support rendering up to 8 directional lights at the
                    same time (albeit with lower shadow quality when more than one light has shadows
                    enabled).</paragraph>
                <paragraph>The Mobile renderer uses a single-pass lighting approach, with a
                    limitation of 8 OmniLights + 8 SpotLights affecting each Mesh <emphasis>resource</emphasis> (plus a
                    limitation of 256 OmniLights + 256 SpotLights in the camera view). These limits
                    are hardcoded and can't be adjusted in the project settings.</paragraph>
                <paragraph>The Compatibility renderer uses a hybrid single-pass + multi-pass lighting
                    approach. Lights without shadows are rendered in a single pass. Lights with
                    shadows are rendered in multiple passes. This is required for performance
                    reasons on mobile devices. As a result, performance does not scale well with
                    many shadow-casting lights. It is recommended to only have a handful of lights
                    with shadows in the camera frustum at a time and for those lights to be spread
                    apart so that each object is only touched by 1 or 2 shadowed lights at a time.
                    The maximum number of lights visible at once can be adjusted in the project
                    settings.</paragraph>
                <comment xml:space="preserve">UPDATE: Planned feature. When static and dynamic shadow rendering are</comment>
                <comment xml:space="preserve">separated, update this paragraph.</comment>
                <paragraph>In all 3 methods, lights without shadows are much cheaper than lights with
                    shadows. To improve performance, lights are only updated when the light is
                    modified or when objects in its radius are modified. Godot currently doesn't
                    separate static shadow rendering from dynamic shadow rendering, but this is
                    planned in a future release.</paragraph>
                <paragraph>Clustering is also used for reflection probes and decal rendering in the
                    Forward+ renderer.</paragraph>
            </section>
            <section ids="shadow-mapping" names="shadow\ mapping">
                <title>Shadow mapping</title>
                <paragraph>Both Forward+ and Mobile methods use
                    <abbreviation explanation="Percentage Closer Filtering">PCF</abbreviation> to filter shadow maps and create a
                    soft penumbra. Instead of using a fixed PCF pattern, these methods use a vogel
                    disk pattern which allows for changing the number of samples and smoothly
                    changing the quality.</paragraph>
                <paragraph>Godot also supports percentage-closer soft shadows (PCSS) for more realistic
                    shadow penumbra rendering. PCSS shadows are limited to the Forward+ renderer
                    as they're too demanding to be usable in the Mobile renderer.
                    PCSS also uses a vogel-disk shaped kernel.</paragraph>
                <paragraph>Additionally, both shadow-mapping techniques rotate the kernel on a per-pixel
                    basis to help soften under-sampling artifacts.</paragraph>
                <paragraph>The Compatibility renderer supports shadow mapping for DirectionalLight3D,
                    OmniLight3D, and SpotLight3D lights.</paragraph>
            </section>
            <section ids="temporal-antialiasing" names="temporal\ antialiasing">
                <title>Temporal antialiasing</title>
                <note>
                    <paragraph>Only available in the Forward+ renderer, not the Mobile or Compatibility renderers.</paragraph>
                </note>
                <paragraph>Godot uses a custom TAA implementation based on the old TAA implementation from
                    <reference name="Spartan Engine" refuri="https://github.com/PanosK92/SpartanEngine">Spartan Engine</reference>.</paragraph>
                <paragraph>Temporal antialiasing requires motion vectors to work. If motion vectors
                    are not correctly generated, ghosting will occur when the camera or objects move.</paragraph>
                <paragraph>Motion vectors are generated on the GPU in the main material shader. This is
                    done by running the vertex shader corresponding to the previous rendered frame
                    (with the previous camera transform) in addition to the vertex shader for the
                    current rendered frame, then storing the difference between them in a color buffer.</paragraph>
                <paragraph>Alternatively, FSR 2.2 can be used as an upscaling solution that also provides
                    its own temporal antialiasing algorithm. FSR 2.2 is implemented on top of the
                    RenderingDevice abstraction as opposed to using AMD's reference code directly.</paragraph>
                <paragraph><strong>TAA resolve:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/taa_resolve.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/taa_resolve.glsl">servers/rendering/renderer_rd/shaders/effects/taa_resolve.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>FSR 2.2:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/effects/fsr2.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/effects/fsr2.cpp">servers/rendering/renderer_rd/effects/fsr2.cpp</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/fsr2/" refuri="https://github.com/godotengine/godot/tree/master/servers/rendering/renderer_rd/shaders/effects/fsr2">servers/rendering/renderer_rd/shaders/effects/fsr2/</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="thirdparty/amd-fsr2/" refuri="https://github.com/godotengine/godot/tree/master/thirdparty/amd-fsr2">thirdparty/amd-fsr2/</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="global-illumination" names="global\ illumination">
                <title>Global illumination</title>
                <note>
                    <paragraph>VoxelGI and SDFGI are only available in the Forward+ renderer, not the
                        Mobile or Compatibility renderers.</paragraph>
                    <paragraph>LightmapGI <emphasis>baking</emphasis> is only available in the Forward+ and Mobile renderers,
                        and can only be performed within the editor (not in an exported
                        project). LightmapGI <emphasis>rendering</emphasis> is supported by the Compatibility renderer.</paragraph>
                </note>
                <paragraph>Godot supports voxel-based GI (VoxelGI), signed distance field GI (SDFGI) and
                    lightmap baking and rendering (LightmapGI). These techniques can be used
                    simultaneously if desired.</paragraph>
                <paragraph>Lightmap baking happens on the GPU using Vulkan compute shaders. The GPU-based
                    lightmapper is implemented in the LightmapperRD class, which inherits from the
                    Lightmapper class. This allows for implementing additional lightmappers, paving
                    the way for a future port of the CPU-based lightmapper present in Godot 3.x.
                    This would allow baking lightmaps while using the Compatibility renderer.</paragraph>
                <paragraph><strong>Core GI C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/environment/gi.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/environment/gi.cpp">servers/rendering/renderer_rd/environment/gi.cpp</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="scene/3d/voxel_gi.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/3d/voxel_gi.cpp">scene/3d/voxel_gi.cpp</reference> - VoxelGI node</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="editor/plugins/voxel_gi_editor_plugin.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/editor/plugins/voxel_gi_editor_plugin.cpp">editor/plugins/voxel_gi_editor_plugin.cpp</reference> - Editor UI for the VoxelGI node</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Core GI GLSL shaders:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/voxel_gi.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/voxel_gi.glsl">servers/rendering/renderer_rd/shaders/environment/voxel_gi.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/voxel_gi_debug.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/voxel_gi_debug.glsl">servers/rendering/renderer_rd/shaders/environment/voxel_gi_debug.glsl</reference> - VoxelGI debug draw mode</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/sdfgi_debug.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/sdfgi_debug.glsl">servers/rendering/renderer_rd/shaders/environment/sdfgi_debug.glsl</reference> - SDFGI Cascades debug draw mode</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/sdfgi_debug_probes.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/sdfgi_debug_probes.glsl">servers/rendering/renderer_rd/shaders/environment/sdfgi_debug_probes.glsl</reference> - SDFGI Probes debug draw mode</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/sdfgi_integrate.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/sdfgi_integrate.glsl">servers/rendering/renderer_rd/shaders/environment/sdfgi_integrate.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/sdfgi_preprocess.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/sdfgi_preprocess.glsl">servers/rendering/renderer_rd/shaders/environment/sdfgi_preprocess.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/sdfgi_direct_light.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/sdfgi_direct_light.glsl">servers/rendering/renderer_rd/shaders/environment/sdfgi_direct_light.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Lightmapper C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="scene/3d/lightmap_gi.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/3d/lightmap_gi.cpp">scene/3d/lightmap_gi.cpp</reference> - LightmapGI node</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="editor/plugins/lightmap_gi_editor_plugin.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/editor/plugins/lightmap_gi_editor_plugin.cpp">editor/plugins/lightmap_gi_editor_plugin.cpp</reference> - Editor UI for the LightmapGI node</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="scene/3d/lightmapper.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/3d/lightmapper.cpp">scene/3d/lightmapper.cpp</reference> - Abstract class</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="modules/lightmapper_rd/lightmapper_rd.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/modules/lightmapper_rd/lightmapper_rd.cpp">modules/lightmapper_rd/lightmapper_rd.cpp</reference> - GPU-based lightmapper implementation</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Lightmapper GLSL shaders:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="modules/lightmapper_rd/lm_raster.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/modules/lightmapper_rd/lm_raster.glsl">modules/lightmapper_rd/lm_raster.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="modules/lightmapper_rd/lm_compute.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/modules/lightmapper_rd/lm_compute.glsl">modules/lightmapper_rd/lm_compute.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="modules/lightmapper_rd/lm_blendseams.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/modules/lightmapper_rd/lm_blendseams.glsl">modules/lightmapper_rd/lm_blendseams.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="depth-of-field" names="depth\ of\ field">
                <title>Depth of field</title>
                <note>
                    <paragraph>Only available in the Forward+ and Mobile renderers, not the
                        Compatibility renderer.</paragraph>
                </note>
                <paragraph>The Forward+ and Mobile renderers use different approaches to DOF rendering, with
                    different visual results. This is done to best match the performance characteristics
                    of the target hardware. In Forward+, DOF is performed using a compute shader. In
                    Mobile, DOF is performed using a fragment shader (raster).</paragraph>
                <paragraph>Box, hexagon and circle bokeh shapes are available (from fastest to slowest).
                    Depth of field can optionally be jittered every frame to improve its appearance
                    when temporal antialiasing is enabled.</paragraph>
                <paragraph><strong>Depth of field C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/effects/bokeh_dof.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/effects/bokeh_dof.cpp">servers/rendering/renderer_rd/effects/bokeh_dof.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Depth of field GLSL shader (compute - used for Forward+):</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/bokeh_dof.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/bokeh_dof.glsl">servers/rendering/renderer_rd/shaders/effects/bokeh_dof.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Depth of field GLSL shader (raster - used for Mobile):</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/bokeh_dof_raster.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/bokeh_dof_raster.glsl">servers/rendering/renderer_rd/shaders/effects/bokeh_dof_raster.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="screen-space-effects-ssao-ssil-ssr-sss" names="screen-space\ effects\ (ssao,\ ssil,\ ssr,\ sss)">
                <title>Screen-space effects (SSAO, SSIL, SSR, SSS)</title>
                <note>
                    <paragraph>Only available in the Forward+ renderer, not the Mobile or Compatibility renderers.</paragraph>
                </note>
                <paragraph>The Forward+ renderer supports screen-space ambient occlusion,
                    screen-space indirect lighting, screen-space reflections and subsurface scattering.</paragraph>
                <paragraph>SSAO uses an implementation derived from Intel's
                    <reference name="ASSAO" refuri="https://www.intel.com/content/www/us/en/developer/articles/technical/adaptive-screen-space-ambient-occlusion.html">ASSAO</reference>
                    (converted to Vulkan). SSIL is derived from SSAO to provide high-performance
                    indirect lighting.</paragraph>
                <paragraph>When both SSAO and SSIL are enabled, parts of SSAO and SSIL are shared to reduce
                    the performance impact.</paragraph>
                <paragraph>SSAO and SSIL are performed at half resolution by default to improve performance.
                    SSR is always performed at half resolution to improve performance.</paragraph>
                <paragraph><strong>Screen-space effects C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/effects/ss_effects.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/effects/ss_effects.cpp">servers/rendering/renderer_rd/effects/ss_effects.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Screen-space ambient occlusion GLSL shader:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssao.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssao.glsl">servers/rendering/renderer_rd/shaders/effects/ssao.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssao_blur.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssao_blur.glsl">servers/rendering/renderer_rd/shaders/effects/ssao_blur.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssao_interleave.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssao_interleave.glsl">servers/rendering/renderer_rd/shaders/effects/ssao_interleave.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssao_importance_map.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssao_importance_map.glsl">servers/rendering/renderer_rd/shaders/effects/ssao_importance_map.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Screen-space indirect lighting GLSL shader:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssil.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssil.glsl">servers/rendering/renderer_rd/shaders/effects/ssil.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssil_blur.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssil_blur.glsl">servers/rendering/renderer_rd/shaders/effects/ssil_blur.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssil_interleave.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssil_interleave.glsl">servers/rendering/renderer_rd/shaders/effects/ssil_interleave.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssil_importance_map.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssil_importance_map.glsl">servers/rendering/renderer_rd/shaders/effects/ssil_importance_map.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Screen-space reflections GLSL shader:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/screen_space_reflection.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/screen_space_reflection.glsl">servers/rendering/renderer_rd/shaders/effects/screen_space_reflection.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/screen_space_reflection_scale.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/screen_space_reflection_scale.glsl">servers/rendering/renderer_rd/shaders/effects/screen_space_reflection_scale.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/screen_space_reflection_filter.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/screen_space_reflection_filter.glsl">servers/rendering/renderer_rd/shaders/effects/screen_space_reflection_filter.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Subsurface scattering GLSL:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/subsurface_scattering.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/subsurface_scattering.glsl">servers/rendering/renderer_rd/shaders/effects/subsurface_scattering.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="sky-rendering" names="sky\ rendering">
                <title>Sky rendering</title>
                <seealso>
                    <paragraph><reference internal="True" refuri="../../tutorials/shaders/shader_reference/sky_shader#doc-sky-shader"><inline classes="std std-ref">Sky shaders</inline></reference></paragraph>
                </seealso>
                <paragraph>Godot supports using shaders to render the sky background. The radiance map
                    (which is used to provide ambient light and reflections for PBR materials) is
                    automatically updated based on the sky shader.</paragraph>
                <paragraph>The SkyMaterial resources such as ProceduralSkyMaterial, PhysicalSkyMaterial and
                    PanoramaSkyMaterial generate a built-in shader for sky rendering. This is
                    similar to what BaseMaterial3D provides for 3D scene materials.</paragraph>
                <paragraph>A detailed technical implementation can be found in the
                    <reference name="Custom sky shaders in Godot 4.0" refuri="https://godotengine.org/article/custom-sky-shaders-godot-4-0">Custom sky shaders in Godot 4.0</reference>
                    article.</paragraph>
                <paragraph><strong>Sky rendering C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/environment/sky.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/environment/sky.cpp">servers/rendering/renderer_rd/environment/sky.cpp</reference> - Sky rendering</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="scene/resources/sky.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/resources/sky.cpp">scene/resources/sky.cpp</reference> - Sky resource (not to be confused with sky rendering)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="scene/resources/sky_material.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/resources/sky_material.cpp">scene/resources/sky_material.cpp</reference> SkyMaterial resources (used in the Sky resource)</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Sky rendering GLSL shader:</strong></paragraph>
            </section>
            <section ids="volumetric-fog" names="volumetric\ fog">
                <title>Volumetric fog</title>
                <note>
                    <paragraph>Only available in the Forward+ renderer, not the Mobile or Compatibility renderers.</paragraph>
                </note>
                <seealso>
                    <paragraph><reference internal="True" refuri="../../tutorials/shaders/shader_reference/fog_shader#doc-fog-shader"><inline classes="std std-ref">Fog shaders</inline></reference></paragraph>
                </seealso>
                <paragraph>Godot supports a frustum-aligned voxel (froxel) approach to volumetric fog
                    rendering. As opposed to a post-processing filter, this approach is more
                    general-purpose as it can work with any light type. Fog can also use shaders for
                    custom behavior, which allows animating the fog or using a 3D texture to
                    represent density.</paragraph>
                <paragraph>The FogMaterial resource generates a built-in shader for FogVolume nodes. This is
                    similar to what BaseMaterial3D provides for 3D scene materials.</paragraph>
                <paragraph>A detailed technical explanation can be found in the
                    <reference name="Fog Volumes arrive in Godot 4.0" refuri="https://godotengine.org/article/fog-volumes-arrive-in-godot-4">Fog Volumes arrive in Godot 4.0</reference>
                    article.</paragraph>
                <paragraph><strong>Volumetric fog C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/environment/fog.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/environment/fog.cpp">servers/rendering/renderer_rd/environment/fog.cpp</reference> - General volumetric fog</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="scene/3d/fog_volume.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/3d/fog_volume.cpp">scene/3d/fog_volume.cpp</reference> - FogVolume node</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="scene/resources/fog_material.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/resources/fog_material.cpp">scene/resources/fog_material.cpp</reference> - FogMaterial resource (used by FogVolume)</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Volumetric fog GLSL shaders:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/volumetric_fog.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/volumetric_fog.glsl">servers/rendering/renderer_rd/shaders/environment/volumetric_fog.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/volumetric_fog_process.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/volumetric_fog_process.glsl">servers/rendering/renderer_rd/shaders/environment/volumetric_fog_process.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="occlusion-culling" names="occlusion\ culling">
                <title>Occlusion culling</title>
                <paragraph>While modern GPUs can handle drawing a lot of triangles, the number of draw
                    calls in complex scenes can still be a bottleneck (even with Vulkan, Direct3D 12,
                    and Metal).</paragraph>
                <paragraph>Godot 4 supports occlusion culling to reduce overdraw (when the depth prepass
                    is disabled) and reduce vertex throughput.
                    This is done by rasterizing a low-resolution buffer on the CPU using
                    <reference name="Embree" refuri="https://github.com/embree/embree">Embree</reference>. The buffer's resolution depends
                    on the number of CPU threads on the system, as this is done in parallel.
                    This buffer includes occluder shapes that were baked in the editor or created at
                    runtime.</paragraph>
                <paragraph>As complex occluders can introduce a lot of strain on the CPU, baked occluders
                    can be simplified automatically when generated in the editor.</paragraph>
                <paragraph>Godot's occlusion culling doesn't support dynamic occluders yet, but
                    OccluderInstance3D nodes can still have their visibility toggled or be moved.
                    However, this will be slow when updating complex occluders this way. Therefore,
                    updating occluders at runtime is best done only on simple occluder shapes such
                    as quads or cuboids.</paragraph>
                <paragraph>This CPU-based approach has a few advantages over other solutions, such as
                    portals and rooms or a GPU-based culling solution:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>No manual setup required (but can be tweaked manually for best performance).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>No frame delay, which is problematic in cutscenes during camera cuts or when
                            the camera moves fast behind a wall.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Works the same on all rendering drivers and methods, with no unpredictable
                            behavior depending on the driver or GPU hardware.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Occlusion culling is performed by registering occluder meshes, which is done
                    using OccluderInstance3D <emphasis>nodes</emphasis> (which themselves use Occluder3D <emphasis>resources</emphasis>).
                    RenderingServer then performs occlusion culling by calling Embree in
                    RendererSceneOcclusionCull.</paragraph>
                <paragraph><strong>Occlusion culling C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="scene/3d/occluder_instance_3d.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/3d/occluder_instance_3d.cpp">scene/3d/occluder_instance_3d.cpp</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_scene_occlusion_cull.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_scene_occlusion_cull.cpp">servers/rendering/renderer_scene_occlusion_cull.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="visibility-range-lod" names="visibility\ range\ (lod)">
                <title>Visibility range (LOD)</title>
                <paragraph>Godot supports manually authored hierarchical level of detail (HLOD), with
                    distances specified by the user in the inspector.</paragraph>
                <paragraph>In RenderingSceneCull, the <literal>_scene_cull()</literal> and <literal>_render_scene()</literal> functions
                    are where most of the LOD determination happens. Each viewport can render the
                    same mesh with different LODs (to allow for split screen rendering to look correct).</paragraph>
                <paragraph><strong>Visibility range C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_scene_cull.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_scene_cull.cpp">servers/rendering/renderer_scene_cull.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="automatic-mesh-lod" names="automatic\ mesh\ lod">
                <title>Automatic mesh LOD</title>
                <paragraph>The ImporterMesh class is used for the 3D mesh import workflow in the editor.
                    Its <literal>generate_lods()</literal> function handles generating using the
                    <reference name="meshoptimizer" refuri="https://meshoptimizer.org/">meshoptimizer</reference> library.</paragraph>
                <paragraph>LOD mesh generation also generates shadow meshes at the same time. These are
                    meshes that have their vertices welded regardless of smoothing and materials.
                    This is used to improve shadow rendering performance by lowering the vertex
                    throughput required to render shadows.</paragraph>
                <paragraph>The RenderingSceneCull class's <literal>_render_scene()</literal> function determines which
                    mesh LOD should be used when rendering. Each viewport can render the
                    same mesh with different LODs (to allow for split screen rendering to look correct).</paragraph>
                <paragraph>The mesh LOD is automatically chosen based on a screen coverage metric. This
                    takes resolution and camera FOV changes into account without requiring user
                    intervention. The threshold multiplier can be adjusted in the project settings.</paragraph>
                <paragraph>To improve performance, shadow rendering and reflection probe rendering also choose
                    their own mesh LOD thresholds (which can be different from the main scene rendering).</paragraph>
                <paragraph><strong>Mesh LOD generation on import C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="scene/resources/importer_mesh.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/resources/importer_mesh.cpp">scene/resources/importer_mesh.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Mesh LOD determination C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_scene_cull.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_scene_cull.cpp">servers/rendering/renderer_scene_cull.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
