<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.21.2 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/engine_details/development/debugging/using_sanitizers.rst" translation_progress="{'total': 0, 'translated': 0}" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-sanitizers"></target>
    <section ids="using-sanitizers doc-using-sanitizers" names="using\ sanitizers doc_using_sanitizers">
        <title>Using sanitizers</title>
        <section ids="what-are-sanitizers" names="what\ are\ sanitizers?">
            <title>What are sanitizers?</title>
            <paragraph>Sanitizers are static instrumentation tools that help find bugs that traditional
                debuggers usually cannot catch. This is particularly useful when combined with
                <reference internal="True" refuri="../../architecture/unit_testing#doc-unit-testing"><inline classes="std std-ref">Unit testing</inline></reference> in continuous integration.</paragraph>
            <paragraph>Sanitizers can be used on Windows, macOS and Linux by using the Clang (LLVM),
                GCC or Visual Studio compilers.
                <reference internal="True" refid="doc-using-sanitizers-platform-specific-sanitizers"><inline classes="std std-ref">Certain platforms</inline></reference>
                may also have their own sanitizers available.
                In situations where a single sanitizer is provided by several different compilers,
                remember that their output and behavior will differ slightly.</paragraph>
        </section>
        <section ids="using-sanitizers-on-godot" names="using\ sanitizers\ on\ godot">
            <title>Using sanitizers on Godot</title>
            <paragraph>Sanitizers <strong>require</strong> recompiling the binary. This means you cannot use
                official Godot binaries to run sanitizers.</paragraph>
            <paragraph>When <reference internal="True" refuri="../compiling/index#toc-devel-compiling"><inline classes="std std-ref">compiling</inline></reference> with any of the sanitizers enabled,
                the resulting binary will have the <literal>.san</literal> suffix added to its name to
                distinguish it from a binary without sanitizers.</paragraph>
            <paragraph>There is a performance impact as many additional runtime checks need to be
                performed. Memory utilization will also increase. It is possible to enable
                certain combinations of multiple sanitizers in a single build. Beware of the
                performance impact when using multiple sanitizers at once though, as the
                resulting binary may be excessively slow.</paragraph>
            <paragraph>Certain options can be passed to sanitizers without having to recompile the
                binary using environment variables.</paragraph>
            <target refid="doc-using-sanitizers-address-sanitizer"></target>
        </section>
        <section ids="address-sanitizer-asan doc-using-sanitizers-address-sanitizer" names="address\ sanitizer\ (asan) doc_using_sanitizers_address_sanitizer">
            <title>Address sanitizer (ASAN)</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Available in Clang and GCC.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Supported platforms:</strong> Linux, macOS, Windows (Visual Studio), Web</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="Clang ASAN documentation" refuri="https://clang.llvm.org/docs/AddressSanitizer.html">Clang ASAN documentation</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The address sanitizer is generally the most frequently used sanitizer. It can
                diagnose issues such as buffer overruns and out-of-bounds access. If the engine
                crashes with a message such as <literal>free(): invalid pointer</literal>, this is typically
                the result of a buffer overrun. (This message is printed by the C runtime, not
                Godot.)</paragraph>
            <paragraph>In certain situations (such as detecting uninitialized memory reads),
                the address sanitizer doesn't suffice. The <reference internal="True" refid="doc-using-sanitizers-memory-sanitizer"><inline classes="std std-ref">Memory sanitizer (MSAN)</inline></reference>
                should be used instead.</paragraph>
            <paragraph>It is also possible to detect use-after-return situations by specifying the
                <literal>ASAN_OPTIONS=detect_stack_use_after_return=1</literal> environment variable before
                <emphasis>running</emphasis> Godot (not when compiling it). This increases the address sanitizer's
                runtime overhead, so only enable this feature when you actually need it.</paragraph>
            <paragraph>To enable the address sanitizer in a Godot build, pass the <literal>use_asan=yes</literal>
                SCons option when compiling. Enabling ASAN generally makes the resulting binary
                about 2× slower.</paragraph>
            <warning>
                <paragraph>Due to a <reference name="design decision" refuri="https://stackoverflow.com/questions/36971902/why-cant-clang-enable-all-sanitizers/">design decision</reference>,
                    the address, memory and thread sanitizers are mutually exclusive. This means
                    you can only use one of those sanitizers in a given binary.</paragraph>
            </warning>
        </section>
        <section ids="leak-sanitizer-lsan" names="leak\ sanitizer\ (lsan)">
            <title>Leak sanitizer (LSAN)</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Available in Clang and GCC.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Supported platforms:</strong> Linux, Web</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="Clang LSAN documentation" refuri="https://clang.llvm.org/docs/LeakSanitizer.html">Clang LSAN documentation</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The leak sanitizer can detect memory leaks, which are situations where memory
                that is no longer in use is never freed by the running program. This can
                potentially lead to out-of-memory situations if the program runs for long
                enough. Since Godot may run on
                <reference internal="True" refuri="../../../tutorials/export/exporting_for_dedicated_servers#doc-exporting-for-dedicated-servers"><inline classes="std std-ref">dedicated servers</inline></reference> for months or
                even years without a restart, it's important to fix memory leaks when they occur.</paragraph>
            <paragraph>To enable the leak sanitizer in a Godot build, pass the <literal>use_lsan=yes</literal> SCons
                option when compiling. Enabling LSAN only has a small performance overhead, but
                the program will be much slower to exit as leak detection occurs when the
                program exits.</paragraph>
            <target refid="doc-using-sanitizers-memory-sanitizer"></target>
        </section>
        <section ids="memory-sanitizer-msan doc-using-sanitizers-memory-sanitizer" names="memory\ sanitizer\ (msan) doc_using_sanitizers_memory_sanitizer">
            <title>Memory sanitizer (MSAN)</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Available in Clang only, not GCC.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Supported platforms:</strong> Linux</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="Clang MSAN documentation" refuri="https://clang.llvm.org/docs/MemorySanitizer.html">Clang MSAN documentation</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The memory sanitizer complements the
                <reference internal="True" refid="doc-using-sanitizers-address-sanitizer"><inline classes="std std-ref">Address sanitizer (ASAN)</inline></reference>. Unlike the address sanitizer,
                the memory sanitizer can detect uninitialized memory reads.</paragraph>
            <paragraph>To enable the memory sanitizer in a Godot build, pass the <literal>use_msan=yes</literal>
                SCons option when compiling. Enabling MSAN generally makes the resulting binary
                about 3× slower.</paragraph>
            <warning>
                <paragraph>Due to a <reference name="design decision" refuri="https://stackoverflow.com/questions/36971902/why-cant-clang-enable-all-sanitizers/">design decision</reference>,
                    the address, memory and thread sanitizers are mutually exclusive. This means
                    you can only use one of those sanitizers in a given binary.</paragraph>
            </warning>
        </section>
        <section ids="thread-sanitizer-tsan" names="thread\ sanitizer\ (tsan)">
            <title>Thread sanitizer (TSAN)</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Available in Clang and GCC.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Supported platforms:</strong> Linux, macOS</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="Clang TSAN documentation" refuri="https://clang.llvm.org/docs/ThreadSanitizer.html">Clang TSAN documentation</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The thread sanitizer is used to track down race conditions related to
                multithreading. A race condition is when multiple threads try to modify the same
                data at the same time. Since thread scheduling can be ordered in any fashion by
                the operating system, this leads to incorrect behavior that only occurs
                occasionally (and can be difficult to track as a result). To prevent a race
                condition, you need to add a lock to ensure only one thread can access the
                shared data at a given time.</paragraph>
            <paragraph>To enable the thread sanitizer in a Godot build, pass the <literal>use_tsan=yes</literal> SCons
                option when compiling. Enabling TSAN generally makes the resulting binary 10×
                slower, while also multiplying memory usage by an approximately 8× factor.</paragraph>
            <warning>
                <paragraph>Due to a <reference name="design decision" refuri="https://stackoverflow.com/questions/36971902/why-cant-clang-enable-all-sanitizers/">design decision</reference>,
                    the address, memory and thread sanitizers are mutually exclusive. This means
                    you can only use one of those sanitizers in a given binary.</paragraph>
            </warning>
            <note>
                <paragraph>On Linux, if you stumble upon the following error:</paragraph>
                <paragraph><literal>FATAL: ThreadSanitizer: unexpected memory mapping</literal></paragraph>
                <paragraph>You may need to temporarily lower the Address Space Layout Randomization (ASLR) entropy in your system with:</paragraph>
                <literal_block force="False" highlight_args="{}" language="sh" linenos="False" xml:space="preserve">sudo sysctl vm.mmap_rnd_bits=28</literal_block>
                <paragraph>Or preferably disable it entirely with:</paragraph>
                <literal_block force="False" highlight_args="{}" language="sh" linenos="False" xml:space="preserve">sudo sysctl kernel.randomize_va_space=0</literal_block>
                <paragraph>And as soon as you are done with the thread sanitizer, increase the ASLR entropy with:</paragraph>
                <literal_block force="False" highlight_args="{}" language="sh" linenos="False" xml:space="preserve">sudo sysctl vm.mmap_rnd_bits=32</literal_block>
                <paragraph>Or re-enable ASLR with:</paragraph>
                <literal_block force="False" highlight_args="{}" language="sh" linenos="False" xml:space="preserve">sudo sysctl kernel.randomize_va_space=2</literal_block>
                <paragraph>Rebooting your machine will also revert the ASLR state to its default values.</paragraph>
                <paragraph>It's important to revert the changes as soon as possible because lowering the ASLR entropy or disabling ASLR entirely can be a security risk.</paragraph>
            </note>
        </section>
        <section ids="undefined-behavior-sanitizer-ubsan" names="undefined\ behavior\ sanitizer\ (ubsan)">
            <title>Undefined behavior sanitizer (UBSAN)</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Available in Clang and GCC.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Supported platforms:</strong> Linux, macOS, Web</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="Clang UBSAN documentation" refuri="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">Clang UBSAN documentation</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The undefined behavior sanitizer is used to track down situations where the
                program exhibits random and unpredictable behavior. This is due to C/C++ code
                that is accepted by the compiler, but is not <emphasis>correct</emphasis>. Compiling with a
                different set of optimizations can also change the observed results of undefined
                behavior.</paragraph>
            <paragraph>To enable the undefined behavior sanitizer in a Godot build, pass the
                <literal>use_ubsan=yes</literal> SCons option when compiling. Enabling UBSAN only has a small
                performance overhead.</paragraph>
            <target refid="doc-using-sanitizers-platform-specific-sanitizers"></target>
        </section>
        <section ids="platform-specific-sanitizers doc-using-sanitizers-platform-specific-sanitizers" names="platform-specific\ sanitizers doc_using_sanitizers_platform_specific_sanitizers">
            <title>Platform-specific sanitizers</title>
            <section ids="web" names="web">
                <title>Web</title>
                <paragraph>When <reference internal="True" refuri="../compiling/compiling_for_web#doc-compiling-for-web"><inline classes="std std-ref">compiling for the Web</inline></reference>,
                    there are 2 additional sanitizer SCons options available:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><literal>use_assertions=yes</literal> enables runtime Emscripten assertions, which can catch
                            various issues.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>use_safe_heap=yes</literal> enables <reference name="Emscripten's SAFE_HEAP sanitizer" refuri="https://emscripten.org/docs/debugging/Sanitizers.html">Emscripten's SAFE_HEAP sanitizer</reference>.
                            It provides similar functionality to ASAN, but it focuses on issues that
                            are specific to WebAssembly. <literal>SAFE_HEAP</literal> is not guaranteed to be compatible
                            with ASAN and UBSAN in the same binary, so you may have to build it separately.</paragraph>
                    </list_item>
                </bullet_list>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/?utm_source=widget"><image alt="Translation status" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/-/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
