<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/contributing/development/debugging/using_sanitizers.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-using-sanitizers"></target>
    <section ids="using-sanitizers doc-using-sanitizers" names="using\ sanitizers 使用\ sanitizer doc_using_sanitizers">
        <title>使用 Sanitizer</title>
        <section ids="what-are-sanitizers" names="what\ are\ sanitizers? 什么是\ sanitizer？">
            <title>什么是 Sanitizer？</title>
            <paragraph>Sanitizer 是一种静态检测工具，能够帮助找出传统调试器通常无法捕捉的问题。非常适合在持续集成中与 <reference internal="True" refuri="../core_and_modules/unit_testing#doc-unit-testing"><inline classes="std std-ref">单元测试</inline></reference> 结合使用。</paragraph>
            <paragraph>在 Windows、macOS、Linux 平台使用 Clang（LLVM）、GCC、Visual Studio 编译器时能够使用 Sanitizer。<reference internal="True" refid="doc-using-sanitizers-platform-specific-sanitizers"><inline classes="std std-ref">部分平台</inline></reference>可能也可以使用其独有的 Sanitizer。多种不同的编译器都提供相同的某种 Sanitizer 时，请记住它们的输出和行为有可能略有不同。</paragraph>
        </section>
        <section ids="using-sanitizers-on-godot" names="using\ sanitizers\ on\ godot 在\ godot\ 中使用\ sanitizer">
            <title>在 Godot 中使用 Sanitizer</title>
            <paragraph>Sanitizer <strong>要求</strong>重新编译二进制文件。这意味着你无法使用官方 Godot 二进制文件来运行 Sanitizer。</paragraph>
            <paragraph>When <reference internal="True" refuri="../compiling/index#toc-devel-compiling"><inline classes="std std-ref">compiling</inline></reference> with any of the sanitizers enabled,
                the resulting binary will have the <literal>.san</literal> suffix added to its name to
                distinguish it from a binary without sanitizers.</paragraph>
            <paragraph>There is a performance impact as many additional runtime checks need to be
                performed. Memory utilization will also increase. It is possible to enable
                certain combinations of multiple sanitizers in a single build. Beware of the
                performance impact when using multiple sanitizers at once though, as the
                resulting binary may be excessively slow.</paragraph>
            <paragraph>Certain options can be passed to sanitizers without having to recompile the
                binary using environment variables.</paragraph>
            <target refid="doc-using-sanitizers-address-sanitizer"></target>
        </section>
        <section ids="address-sanitizer-asan doc-using-sanitizers-address-sanitizer" names="address\ sanitizer\ (asan) 地址\ sanitizer（asan） doc_using_sanitizers_address_sanitizer">
            <title>地址 Sanitizer（ASAN）</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Clang 和 GCC 中可用。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>支持的平台：</strong>Linux、macOS、Windows（Visual Studio）、Web</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="Clang ASAN 文档" refuri="https://clang.llvm.org/docs/AddressSanitizer.html">Clang ASAN 文档</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The address sanitizer is generally the most frequently used sanitizer. It can
                diagnose issues such as buffer overruns and out-of-bounds access. If the engine
                crashes with a message such as <literal>free(): invalid pointer</literal>, this is typically
                the result of a buffer overrun. (This message is printed by the C runtime, not
                Godot.)</paragraph>
            <paragraph>In certain situations (such as detecting uninitialized memory reads),
                the address sanitizer doesn't suffice. The <reference internal="True" refid="doc-using-sanitizers-memory-sanitizer"><inline classes="std std-ref">内存 Sanitizer（MSAN）</inline></reference>
                should be used instead.</paragraph>
            <paragraph>It is also possible to detect use-after-return situations by specifying the
                <literal>ASAN_OPTIONS=detect_stack_use_after_return=1</literal> environment variable before
                <emphasis>running</emphasis> Godot (not when compiling it). This increases the address sanitizer's
                runtime overhead, so only enable this feature when you actually need it.</paragraph>
            <paragraph>To enable the address sanitizer in a Godot build, pass the <literal>use_asan=yes</literal>
                SCons option when compiling. Enabling ASAN generally makes the resulting binary
                about 2× slower.</paragraph>
            <warning>
                <paragraph>Due to a <reference name="design decision" refuri="https://stackoverflow.com/questions/36971902/why-cant-clang-enable-all-sanitizers/">design decision</reference>,
                    the address, memory and thread sanitizers are mutually exclusive. This means
                    you can only use one of those sanitizers in a given binary.</paragraph>
            </warning>
        </section>
        <section ids="leak-sanitizer-lsan" names="leak\ sanitizer\ (lsan) 泄漏\ sanitizer（lsan）">
            <title>泄漏 Sanitizer（LSAN）</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Clang 和 GCC 中可用。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>支持的平台：</strong>Linux、Web</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="Clang LSAN 文档" refuri="https://clang.llvm.org/docs/LeakSanitizer.html">Clang LSAN 文档</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The leak sanitizer can detect memory leaks, which are situations where memory
                that is no longer in use is never freed by the running program. This can
                potentially lead to out-of-memory situations if the program runs for long
                enough. Since Godot may run on
                <reference internal="True" refuri="../../../tutorials/export/exporting_for_dedicated_servers#doc-exporting-for-dedicated-servers"><inline classes="std std-ref">dedicated servers</inline></reference> for months or
                even years without a restart, it's important to fix memory leaks when they occur.</paragraph>
            <paragraph>To enable the leak sanitizer in a Godot build, pass the <literal>use_lsan=yes</literal> SCons
                option when compiling. Enabling LSAN only has a small performance overhead, but
                the program will be much slower to exit as leak detection occurs when the
                program exits.</paragraph>
            <target refid="doc-using-sanitizers-memory-sanitizer"></target>
        </section>
        <section ids="memory-sanitizer-msan doc-using-sanitizers-memory-sanitizer" names="memory\ sanitizer\ (msan) 内存\ sanitizer（msan） doc_using_sanitizers_memory_sanitizer">
            <title>内存 Sanitizer（MSAN）</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>仅 Clang 可用，GCC 不可用。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>支持的平台：</strong>Linux</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="Clang MSAN 文档" refuri="https://clang.llvm.org/docs/MemorySanitizer.html">Clang MSAN 文档</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The memory sanitizer complements the
                <reference internal="True" refid="doc-using-sanitizers-address-sanitizer"><inline classes="std std-ref">地址 Sanitizer（ASAN）</inline></reference>. Unlike the address sanitizer,
                the memory sanitizer can detect uninitialized memory reads.</paragraph>
            <paragraph>To enable the memory sanitizer in a Godot build, pass the <literal>use_msan=yes</literal>
                SCons option when compiling. Enabling MSAN generally makes the resulting binary
                about 3× slower.</paragraph>
            <warning>
                <paragraph>Due to a <reference name="design decision" refuri="https://stackoverflow.com/questions/36971902/why-cant-clang-enable-all-sanitizers/">design decision</reference>,
                    the address, memory and thread sanitizers are mutually exclusive. This means
                    you can only use one of those sanitizers in a given binary.</paragraph>
            </warning>
        </section>
        <section ids="thread-sanitizer-tsan" names="thread\ sanitizer\ (tsan) 线程\ sanitizer（tsan）">
            <title>线程 Sanitizer（TSAN）</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Clang 和 GCC 中可用。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>支持的平台：</strong>Linux、macOS</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="Clang TSAN 文档" refuri="https://clang.llvm.org/docs/ThreadSanitizer.html">Clang TSAN 文档</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The thread sanitizer is used to track down race conditions related to
                multithreading. A race condition is when multiple threads try to modify the same
                data at the same time. Since thread scheduling can be ordered in any fashion by
                the operating system, this leads to incorrect behavior that only occurs
                occasionally (and can be difficult to track as a result). To prevent a race
                condition, you need to add a lock to ensure only one thread can access the
                shared data at a given time.</paragraph>
            <paragraph>To enable the thread sanitizer in a Godot build, pass the <literal>use_tsan=yes</literal> SCons
                option when compiling. Enabling TSAN generally makes the resulting binary 10×
                slower, while also multiplying memory usage by an approximately 8× factor.</paragraph>
            <warning>
                <paragraph>Due to a <reference name="design decision" refuri="https://stackoverflow.com/questions/36971902/why-cant-clang-enable-all-sanitizers/">design decision</reference>,
                    the address, memory and thread sanitizers are mutually exclusive. This means
                    you can only use one of those sanitizers in a given binary.</paragraph>
            </warning>
        </section>
        <section ids="undefined-behavior-sanitizer-ubsan" names="undefined\ behavior\ sanitizer\ (ubsan) 未定义行为\ sanitizer（ubsan）">
            <title>未定义行为 Sanitizer（UBSAN）</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Clang 和 GCC 中可用。</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>支持的平台：</strong>Linux、macOS、Web</paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="Clang UBSAN 文档" refuri="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">Clang UBSAN 文档</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The undefined behavior sanitizer is used to track down situations where the
                program exhibits random and unpredictable behavior. This is due to C/C++ code
                that is accepted by the compiler, but is not <emphasis>correct</emphasis>. Compiling with a
                different set of optimizations can also change the observed results of undefined
                behavior.</paragraph>
            <paragraph>To enable the undefined behavior sanitizer in a Godot build, pass the
                <literal>use_ubsan=yes</literal> SCons option when compiling. Enabling UBSAN only has a small
                performance overhead.</paragraph>
            <target refid="doc-using-sanitizers-platform-specific-sanitizers"></target>
        </section>
        <section ids="platform-specific-sanitizers doc-using-sanitizers-platform-specific-sanitizers" names="platform-specific\ sanitizers 平台相关\ sanitizer doc_using_sanitizers_platform_specific_sanitizers">
            <title>平台相关 Sanitizer</title>
            <section ids="web" names="web">
                <title>Web</title>
                <paragraph>When <reference internal="True" refuri="../compiling/compiling_for_web#doc-compiling-for-web"><inline classes="std std-ref">compiling for the Web</inline></reference>,
                    there are 2 additional sanitizer SCons options available:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><literal>use_assertions=yes</literal> enables runtime Emscripten assertions, which can catch
                            various issues.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><literal>use_safe_heap=yes</literal> enables <reference name="Emscripten's SAFE_HEAP sanitizer" refuri="https://emscripten.org/docs/debugging/Sanitizers.html">Emscripten's SAFE_HEAP sanitizer</reference>.
                            It provides similar functionality to ASAN, but it focuses on issues that
                            are specific to WebAssembly. <literal>SAFE_HEAP</literal> is not guaranteed to be compatible
                            with ASAN and UBSAN in the same binary, so you may have to build it separately.</paragraph>
                    </list_item>
                </bullet_list>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
