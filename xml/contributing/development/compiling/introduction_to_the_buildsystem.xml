<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/contributing/development/compiling/introduction_to_the_buildsystem.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-introduction-to-the-buildsystem"></target>
    <section ids="introduction-to-the-buildsystem doc-introduction-to-the-buildsystem" names="introduction\ to\ the\ buildsystem 构建系统介绍 doc_introduction_to_the_buildsystem">
        <title>构建系统介绍</title>
        <paragraph>Godot is a primarily C++ project and it <reference internal="True" refuri="../../../about/faq#doc-faq-why-scons"><inline classes="std std-ref">uses the SCons build system.</inline></reference>
            We love SCons for how maintainable and easy to set up it makes our buildsystem. And thanks to
            that compiling Godot from source can be as simple as running:</paragraph>
        <literal_block force="False" language="shell" linenos="False" xml:space="preserve">scons</literal_block>
        <paragraph>This produces an editor build for your current platform, operating system, and architecture.
            You can change what gets built by specifying a target, a platform, and/or an architecture.
            For example, to build an export template used for running exported games, you can run:</paragraph>
        <literal_block force="False" language="shell" linenos="False" xml:space="preserve">scons target=template_release</literal_block>
        <paragraph>If you plan to debug or develop the engine, then you might want to enable the <literal>dev_build</literal>
            option to enable dev-only debugging code:</paragraph>
        <literal_block force="False" language="shell" linenos="False" xml:space="preserve">scons dev_build=yes</literal_block>
        <paragraph>Following sections in the article will explain these and other universal options in more detail. But
            before you can compile Godot, you need to install a few prerequisites. Please refer to the platform
            documentation to learn more:</paragraph>
        <bullet_list bullet="-">
            <list_item>
                <paragraph><reference internal="True" refuri="compiling_for_android#doc-compiling-for-android"><inline classes="std std-ref">为 Android 平台编译</inline></reference></paragraph>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="compiling_for_ios#doc-compiling-for-ios"><inline classes="std std-ref">为 iOS 平台编译</inline></reference></paragraph>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="compiling_for_linuxbsd#doc-compiling-for-linuxbsd"><inline classes="std std-ref">为 Linux、*BSD 平台编译</inline></reference></paragraph>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="compiling_for_macos#doc-compiling-for-macos"><inline classes="std std-ref">为 macOS 平台编译</inline></reference></paragraph>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="compiling_for_web#doc-compiling-for-web"><inline classes="std std-ref">为 Web 平台编译</inline></reference></paragraph>
            </list_item>
            <list_item>
                <paragraph><reference internal="True" refuri="compiling_for_windows#doc-compiling-for-windows"><inline classes="std std-ref">为 Windows 平台编译</inline></reference></paragraph>
            </list_item>
        </bullet_list>
        <paragraph>These articles cover in great detail both how to setup your environment to compile Godot on a specific
            platform, and how to compile for that platform. Please feel free to go back and forth between them and
            this article to reference platform-specific and universal configuration options.</paragraph>
        <section ids="using-multi-threading" names="using\ multi-threading">
            <title>Using multi-threading</title>
            <paragraph>The build process may take a while, depending on how powerful your system is. By default, Godot's
                SCons setup is configured to use all CPU threads but one (to keep the system responsive during
                compilation). If you want to adjust how many CPU threads SCons will use, use the <literal>-j &lt;threads&gt;</literal>
                parameter to specify how many threads will be used for the build.</paragraph>
            <paragraph>Example for using 4 threads:</paragraph>
            <literal_block force="False" language="shell" linenos="False" xml:space="preserve">scons -j4</literal_block>
        </section>
        <section ids="platform-selection" names="platform\ selection 选择平台">
            <title>选择平台</title>
            <paragraph>Godot的构建系统将从检测可构建的平台开始. 如果未检测到, 该平台将不会出现在可用平台列表中. 本教程后续部分将介绍每种平台的构建要求.</paragraph>
            <paragraph>仅通过调用 <literal>scons</literal> 即可调用SCons. 如果未指定平台,SCons将基于主机平台自动检测目标平台. 然后它将立即开始为目标平台构建.</paragraph>
            <paragraph>要列出可用的目标平台，请使用 <literal>scons platform=list</literal>：</paragraph>
            <literal_block force="False" language="shell" linenos="False" xml:space="preserve">scons platform=list
scons: Reading SConscript files ...
The following platforms are available:

    android
    javascript
    linuxbsd
    server
    windows

Please run SCons again and select a valid platform: platform=&lt;string&gt;</literal_block>
            <paragraph>To build for a platform (for example, <literal>linuxbsd</literal>), run with the <literal>platform=</literal>
                (or <literal>p=</literal> to make it short) argument:</paragraph>
            <literal_block force="False" language="shell" linenos="False" xml:space="preserve">scons platform=linuxbsd</literal_block>
            <target refid="doc-introduction-to-the-buildsystem-resulting-binary"></target>
        </section>
        <section ids="resulting-binary doc-introduction-to-the-buildsystem-resulting-binary" names="resulting\ binary 生成的二进制文件 doc_introduction_to_the_buildsystem_resulting_binary">
            <title>生成的二进制文件</title>
            <paragraph>生成的二进制文件将被放置在 <literal>bin/</literal> 子目录中，通常使用这种命名约定：</paragraph>
            <literal_block force="False" language="shell" linenos="False" xml:space="preserve">godot.&lt;platform&gt;.&lt;target&gt;[.dev][.double].&lt;arch&gt;[.&lt;extra_suffix&gt;][.&lt;ext&gt;]</literal_block>
            <paragraph>For the previous build attempt, the result would look like this:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">ls bin
bin/godot.linuxbsd.editor.x86_64</literal_block>
            <paragraph>This means that the binary is for Linux <emphasis>or</emphasis> *BSD (<emphasis>not</emphasis> both), is not optimized, has the
                whole editor compiled in, and is meant for 64 bits.</paragraph>
            <paragraph>一个具有相同配置的Windows二进制文件将如下所示:</paragraph>
            <literal_block force="False" highlight_args="{}" language="doscon" linenos="False" xml:space="preserve">C:\godot&gt; dir bin/
godot.windows.editor.64.exe</literal_block>
            <paragraph>Copy that binary to any location you like, as it contains the Project Manager,
                editor and all means to execute the game. However, it lacks the data to export
                it to the different platforms. For that the export templates are needed (which
                can be either downloaded from <reference name="godotengine.org" refuri="https://godotengine.org/">godotengine.org</reference>, or
                you can build them yourself).</paragraph>
            <paragraph>除此之外, 在所有的构建目标平台中有几个标准选项可以进行设置, 下面将对此进行说明.</paragraph>
            <target refid="doc-introduction-to-the-buildsystem-target"></target>
        </section>
        <section ids="target doc-introduction-to-the-buildsystem-target" names="target 目标 doc_introduction_to_the_buildsystem_target">
            <title>目标</title>
            <paragraph>Target controls if the editor is contained and debug flags are used.
                All builds are optimized. Each mode means:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>target=editor</literal>: Build with editor, optimized, with debugging code (defines: <literal>TOOLS_ENABLED</literal>, <literal>DEBUG_ENABLED</literal>, <literal>-O2</literal>/<literal>/O2</literal>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>target=template_debug</literal>: Build with C++ debugging symbols (defines: <literal>DEBUG_ENABLED</literal>, <literal>-O2</literal>/<literal>/O2</literal>)</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>target=template_release</literal>: Build without symbols (defines: <literal>-O3</literal>/<literal>/O2</literal>)</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>The editor is enabled by default in all PC targets (Linux, Windows, macOS),
                disabled for everything else. Disabling the editor produces a binary that can
                run projects but does not include the editor or the Project Manager.</paragraph>
            <literal_block force="False" language="shell" linenos="False" xml:space="preserve">scons platform=&lt;platform&gt; target=editor/template_debug/template_release</literal_block>
        </section>
        <section ids="development-and-production-aliases" names="development\ and\ production\ aliases 开发别名与生产别名">
            <title>开发别名与生产别名</title>
            <paragraph>When creating builds for development (running debugging/<reference internal="True" refuri="../debugging/using_cpp_profilers#doc-using-cpp-profilers"><inline classes="std std-ref">profiling</inline></reference>
                tools), you often have different goals compared to production builds
                (making binaries as fast and small as possible).</paragraph>
            <paragraph>Godot provides two aliases for this purpose:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>dev_mode=yes</literal> is an alias for <literal>verbose=yes warnings=extra werror=yes
tests=yes</literal>. This enables warnings-as-errors behavior (similar to Godot's
                        continuous integration setup) and also builds <reference internal="True" refuri="../core_and_modules/unit_testing#doc-unit-testing"><inline classes="std std-ref">unit tests</inline></reference> so you can run them locally.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>production=yes</literal> is an alias for <literal>use_static_cpp=yes debug_symbols=no
lto=auto</literal>. Statically linking libstdc++ allows for better binary portability
                        when compiling for Linux. This alias also enables link-time optimization when
                        compiling for Linux, Web and Windows with MinGW, but keeps LTO disabled when
                        compiling for macOS, iOS or Windows with MSVC. This is because LTO on those
                        platforms is very slow to link or has issues with the generated code.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>You can manually override options from those aliases by specifying them on the
                same command line with different values. For example, you can use <literal>scons
production=yes debug_symbols=yes</literal> to create production-optimized binaries with
                debugging symbols included.</paragraph>
        </section>
        <section ids="dev-build" names="dev\ build 开发构建">
            <title>开发构建</title>
            <note>
                <paragraph><literal>dev_build</literal> should <strong>not</strong> be confused with <literal>dev_mode</literal>, which is an
                    alias for several development-related options (see above).</paragraph>
            </note>
            <paragraph>When doing engine development the <literal>dev_build</literal> option can be used together
                with <literal>target</literal> to enable dev-specific code. <literal>dev_build</literal> defines <literal>DEV_ENABLED</literal>,
                disables optimization (<literal>-O0</literal>/<literal>/0d</literal>), enables generating debug symbols, and
                does not define <literal>NDEBUG</literal> (so <literal>assert()</literal> works in thirdparty libraries).</paragraph>
            <literal_block force="False" language="shell" linenos="False" xml:space="preserve">scons platform=&lt;platform&gt; dev_build=yes</literal_block>
            <paragraph>This flag appends the <literal>.dev</literal> suffix (for development) to the generated
                binary name.</paragraph>
            <seealso>
                <paragraph>There are additional SCons options to enable <emphasis>sanitizers</emphasis>, which are tools
                    you can enable at compile-time to better debug certain engine issues.
                    See <reference internal="True" refuri="../debugging/using_sanitizers#doc-using-sanitizers"><inline classes="std std-ref">使用 Sanitizer</inline></reference> for more information.</paragraph>
            </seealso>
        </section>
        <section ids="debugging-symbols" names="debugging\ symbols 调试符号">
            <title>调试符号</title>
            <paragraph>By default, <literal>debug_symbols=no</literal> is used, which means <strong>no</strong> debugging symbols
                are included in compiled binaries. Use <literal>debug_symbols=yes</literal> to include debug
                symbols within compiled binaries, which allows debuggers and profilers to work
                correctly. Debugging symbols are also required for Godot's crash stacktraces to
                display with references to source code files and lines.</paragraph>
            <paragraph>The downside is that debugging symbols are large files (significantly larger
                than the binaries themselves). As a result, official binaries currently do not
                include debugging symbols. This means you need to compile Godot yourself to have
                access to debugging symbols.</paragraph>
            <paragraph>When using <literal>debug_symbols=yes</literal>, you can also use
                <literal>separate_debug_symbols=yes</literal> to put debug information in a separate file with
                a <literal>.debug</literal> suffix. This allows distributing both files independently. Note
                that on Windows, when compiling with MSVC, debugging information is <emphasis>always</emphasis>
                written to a separate <literal>.pdb</literal> file regardless of <literal>separate_debug_symbols</literal>.</paragraph>
            <tip>
                <paragraph>Use the <literal>strip &lt;path/to/binary&gt;</literal> command to remove debugging symbols from
                    a binary you've already compiled.</paragraph>
            </tip>
        </section>
        <section ids="optimization-level" names="optimization\ level 优化级别">
            <title>优化级别</title>
            <paragraph>Several compiler optimization levels can be chosen from:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><literal>optimize=speed_trace</literal> <emphasis>(default when targeting non-Web platforms)</emphasis>: Favors
                        execution speed at the cost of larger binary size. Optimizations may sometimes
                        negatively impact debugger usage (stack traces may be less accurate. If this
                        occurs to you, use <literal>optimize=debug</literal> instead.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>optimize=speed</literal>: Favors even more execution speed, at the cost of even
                        larger binary size compared to <literal>optimize=speed_trace</literal>. Even less friendly to
                        debugging compared to <literal>optimize=debug</literal>, as this uses the most aggressive
                        optimizations available.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>optimize=size</literal> <emphasis>(default when targeting the Web platform)</emphasis>: Favors small
                        binaries at the cost of slower execution speed.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>optimize=debug</literal>: Only enables optimizations that do not impact debugging in
                        any way. This results in faster binaries than <literal>optimize=none</literal>, but slower
                        binaries than <literal>optimize=speed_trace</literal>.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>optimize=none</literal>: Do not perform any optimization. This provides the fastest
                        build times, but the slowest execution times.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><literal>optimize=custom</literal> <emphasis>(advanced users only)</emphasis>: Do not pass optimization
                        arguments to the C/C++ compilers. You will have to pass arguments manually
                        using the <literal>cflags</literal>, <literal>ccflags</literal> and <literal>cxxflags</literal> SCons options.</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="architecture" names="architecture 架构">
            <title>架构</title>
            <paragraph>The <literal>arch</literal> option is meant to control the CPU or OS version intended to run the
                binaries. It is focused mostly on desktop platforms and ignored everywhere
                else.</paragraph>
            <paragraph>Supported values for the <literal>arch</literal> option are <strong>auto</strong>, <strong>x86_32</strong>, <strong>x86_64</strong>,
                <strong>arm32</strong>, <strong>arm64</strong>, <strong>rv64</strong>, <strong>ppc32</strong>, <strong>ppc64</strong> and <strong>wasm32</strong>.</paragraph>
            <literal_block force="False" language="shell" linenos="False" xml:space="preserve">scons platform=&lt;platform&gt; arch={auto|x86_32|x86_64|arm32|arm64|rv64|ppc32|ppc64|wasm32}</literal_block>
            <paragraph>This flag appends the value of <literal>arch</literal> to resulting binaries when
                relevant.  The default value <literal>arch=auto</literal> detects the architecture
                that matches the host platform.</paragraph>
            <target refid="doc-buildsystem-custom-modules"></target>
        </section>
        <section ids="custom-modules doc-buildsystem-custom-modules" names="custom\ modules 自定义模块 doc_buildsystem_custom_modules">
            <title>自定义模块</title>
            <paragraph>可以编译驻扎在Godot目录树之外的模块, 以及内置模块.</paragraph>
            <paragraph>在编译之前, 可以在命令行中传递一个 <literal>custom_modules</literal> 构建选项. 这个选项代表了一个以逗号分隔的目录路径列表, 其中包含了一系列独立的C++模块, 这些模块可以被看作是C++包, 就像内置的 <literal>modules/</literal> 目录一样.</paragraph>
            <paragraph>例如, 可以同时提供包含此类模块的相对, 绝对和用户目录路径:</paragraph>
            <literal_block force="False" language="shell" linenos="False" xml:space="preserve">scons custom_modules="../modules,/abs/path/to/modules,~/src/godot_modules"</literal_block>
            <note>
                <paragraph>如果有任何自定义模块的目录名与内置模块的目录名完全相同, 引擎将只编译自定义模块. 这个逻辑可以用来覆盖内置模块的实现.</paragraph>
            </note>
            <seealso>
                <paragraph><reference internal="True" refuri="../core_and_modules/custom_modules_in_cpp#doc-custom-modules-in-cpp"><inline classes="std std-ref">自定义 C++ 模块</inline></reference></paragraph>
            </seealso>
        </section>
        <section ids="cleaning-generated-files" names="cleaning\ generated\ files 清理生成的文件">
            <title>清理生成的文件</title>
            <paragraph>有时, 你可能会遇到一个错误, 因为生成的文件存在. 你可以使用``scons --clean &lt;options&gt;``删除它们, 其中 <literal>&lt;options&gt;</literal> 是你之前用来构建Godot的构建选项列表.</paragraph>
            <paragraph>或者, 你也可以使用``git clean -fixd``来清理所有平台和配置的构建工件. 注意, 这将删除版本库中所有未跟踪和忽略的文件. 如果你有未提交的工作, 请不要运行这个命令！</paragraph>
        </section>
        <section ids="other-build-options" names="other\ build\ options 其他构建选项">
            <title>其他构建选项</title>
            <paragraph>你还可以使用其他几个构建选项来配置Godot的构建方式(编译器, 调试选项等), 以及要包含/禁用的功能.</paragraph>
            <paragraph>检查 <literal>scons --help</literal> 的输出, 以获取有关你愿意编译的版本的每个选项的详细信息.</paragraph>
            <target refid="doc-overriding-build-options"></target>
            <section ids="overriding-the-build-options doc-overriding-build-options" names="overriding\ the\ build\ options 重写构建选项 doc_overriding_build_options">
                <title>重写构建选项</title>
                <section ids="using-a-file" names="using\ a\ file 使用文件">
                    <title>使用文件</title>
                    <paragraph>默认的 <literal>custom.py</literal> 文件可以在Godot引擎源的根部创建, 以初始化任何通过命令行传递的SCons构建选项:</paragraph>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># custom.py

optimize = "size"
module_mono_enabled = "yes"
use_llvm = "yes"
extra_suffix = "game_title"</literal_block>
                    <paragraph>你也可以在编译前禁用一些内置模块，节省一些构建引擎的时间。详情请参阅 <reference internal="True" refuri="optimizing_for_size#doc-optimizing-for-size"><inline classes="std std-ref">为尺寸优化构建</inline></reference> 页面。</paragraph>
                    <seealso>
                        <paragraph>你可以使用在线 <reference name="Godot 构建选项生成器" refuri="https://godot-build-options-generator.github.io/">Godot 构建选项生成器</reference> , 生成一个包含SCons选项的 <literal>custom.py</literal> 文件. 然后你可以保存这个文件, 并将其放在Godot源目录的根目录下.</paragraph>
                    </seealso>
                    <paragraph>另一个自定义文件可以用 <literal>profile</literal> 命令行选项明确指定, 都会覆盖默认的构建配置:</paragraph>
                    <literal_block force="False" highlight_args="{}" language="shell" linenos="False" xml:space="preserve">scons profile=path/to/custom.py</literal_block>
                    <note>
                        <paragraph>从文件中设置的构建选项可以被命令行选项所覆盖.</paragraph>
                    </note>
                    <paragraph>也可以有条件地重写这些选项:</paragraph>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># custom.py

import version

# Override options specific for Godot 3.x and 4.x versions.
if version.major == 3:
    pass
elif version.major == 4:
    pass</literal_block>
                </section>
                <section ids="using-the-sconsflags" names="using\ the\ sconsflags 使用sconsflags">
                    <title>使用SCONSFLAGS</title>
                    <paragraph><literal>SCONSFLAGS</literal> 是一个环境变量,SCons用来自动设置选项, 而无需通过命令行提供.</paragraph>
                    <paragraph>For instance, you may want to force a number of CPU threads with the
                        aforementioned <literal>-j</literal> option for all future builds:</paragraph>
                    <container classes="sphinx-tabs" type="tab-element">
                        <div aria-label="Tabbed content" role="tablist">
                            <button aria-controls="panel-0-TGludXgvbWFjT1M=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-TGludXgvbWFjT1M=" name="TGludXgvbWFjT1M=" role="tab" tabindex="0">Linux/macOS</button>
                            <button aria-controls="panel-0-V2luZG93cyAoY21kKQ==" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-V2luZG93cyAoY21kKQ==" name="V2luZG93cyAoY21kKQ==" role="tab" tabindex="-1">Windows (cmd)</button>
                            <button aria-controls="panel-0-V2luZG93cyAoUG93ZXJTaGVsbCk=" aria-selected="false" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-V2luZG93cyAoUG93ZXJTaGVsbCk=" name="V2luZG93cyAoUG93ZXJTaGVsbCk=" role="tab" tabindex="-1">Windows (PowerShell)</button>
                        </div>
                        <div aria-labelledby="tab-0-TGludXgvbWFjT1M=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-TGludXgvbWFjT1M=" name="TGludXgvbWFjT1M=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="bash" linenos="False" xml:space="preserve">export SCONSFLAGS="-j4"</literal_block>
                        </div>
                        <div aria-labelledby="tab-0-V2luZG93cyAoY21kKQ==" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-V2luZG93cyAoY21kKQ==" name="V2luZG93cyAoY21kKQ==" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="bat" linenos="False" xml:space="preserve">set SCONSFLAGS=-j4</literal_block>
                        </div>
                        <div aria-labelledby="tab-0-V2luZG93cyAoUG93ZXJTaGVsbCk=" classes="sphinx-tabs-panel code-tab group-tab" hidden="true" ids="panel-0-V2luZG93cyAoUG93ZXJTaGVsbCk=" name="V2luZG93cyAoUG93ZXJTaGVsbCk=" role="tabpanel" tabindex="0">
                            <literal_block force="False" highlight_args="{}" language="powershell" linenos="False" xml:space="preserve">$env:SCONSFLAGS="-j4"</literal_block>
                        </div>
                    </container>
                </section>
                <section ids="scu-single-compilation-unit-build" names="scu\ (single\ compilation\ unit)\ build">
                    <title>SCU (single compilation unit) build</title>
                    <paragraph>Regular builds tend to be bottlenecked by including large numbers of headers
                        in each compilation translation unit. Primarily to speed up development (rather
                        than for production builds), Godot offers a "single compilation unit" build
                        (aka "Unity / Jumbo" build).</paragraph>
                    <paragraph>For the folders accelerated by this option, multiple <literal>.cpp</literal> files are
                        compiled in each translation unit, so headers can be shared between multiple
                        files, which can dramatically decrease build times.</paragraph>
                    <paragraph>To perform an SCU build, use the <literal>scu_build=yes</literal> SCons option.</paragraph>
                    <note>
                        <paragraph>When developing a Pull Request using SCU builds, be sure to make a
                            regular build prior to submitting the PR. This is because SCU builds
                            by nature include headers from earlier <literal>.cpp</literal> files in the
                            translation unit, therefore won't catch all the includes you will
                            need in a regular build. The CI will catch these errors but it will
                            usually be faster to catch them on a local build on your machine.</paragraph>
                    </note>
                </section>
            </section>
        </section>
        <section ids="export-templates" names="export\ templates 导出模板">
            <title>导出模板</title>
            <paragraph>官方的导出模板可以从 <reference name="Godot 的官方网站" refuri="https://godotengine.org/">Godot 的官方网站</reference> 下载到. 此外, 你可能想要自己构建它们(可能想要构建更新的版本, 要使用自定义模块, 不信任我们编译的包是否安全).</paragraph>
            <paragraph>如果下载官方导出模板程序包并解压缩, 你会注意到大多数文件都是针对每个平台的优化二进制文件或程序包:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">android_debug.apk
android_release.apk
android_source.zip
ios.zip
linux_debug.arm32
linux_debug.arm64
linux_debug.x86_32
linux_debug.x86_64
linux_release.arm32
linux_release.arm64
linux_release.x86_32
linux_release.x86_64
macos.zip
version.txt
web_debug.zip
web_dlink_debug.zip
web_dlink_nothreads_debug.zip
web_dlink_nothreads_release.zip
web_dlink_release.zip
web_nothreads_debug.zip
web_nothreads_release.zip
web_release.zip
windows_debug_x86_32_console.exe
windows_debug_x86_32.exe
windows_debug_x86_64_console.exe
windows_debug_x86_64.exe
windows_release_x86_32_console.exe
windows_release_x86_32.exe
windows_release_x86_64_console.exe
windows_release_x86_64.exe</literal_block>
            <paragraph>要自己创建它们, 请按照该教程中针对每个平台的详细说明的部分进行操作. 每个平台都说明了如何创建自己的模板.</paragraph>
            <paragraph><literal>version.txt</literal> 文件应包含相应的 Godot 版本标识符。该文件用于在特定于版本的目录中安装导出模板，以避免冲突。例如，如果你要为 Godot 3.1.1 构建导出模板，则 <literal>version.txt</literal> 文件的第一行应包含 <literal>3.1.1.stable</literal>（没有其他内容）。该版本标识符<reference name="在 Godot Git 仓库库中的 version.py 文件" refuri="https://github.com/godotengine/godot/blob/master/version.py">在 Godot Git 仓库库中的 version.py 文件</reference>的 <literal>major</literal>、<literal>minor</literal>、<literal>patch</literal>（如果存在）和 <literal>status</literal> 行。</paragraph>
            <paragraph>If you are developing for multiple platforms, macOS is definitely the most
                convenient host platform for cross-compilation, since you can cross-compile for
                every target. Linux and Windows come in second place,
                but Linux has the advantage of being the easier platform to set this up.</paragraph>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
