<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/contributing/development/core_and_modules/custom_modules_in_cpp.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-custom-modules-in-cpp"></target>
    <section ids="custom-modules-in-c doc-custom-modules-in-cpp" names="custom\ modules\ in\ c++ 自定义\ c++\ 模块 doc_custom_modules_in_cpp">
        <title>自定义 C++ 模块</title>
        <section ids="modules" names="modules 模块">
            <title>模块</title>
            <paragraph>Godot 允许通过模块化的方式对引擎进行扩展. 你可以创建新的模块, 然后启用/禁用它. 这允许在每个级别添加新的引擎功能, 而无需修改内核, 可以将其拆分以供在不同模块中使用和重用.</paragraph>
            <paragraph>模块位于构建系统的 <literal>modules/</literal> 子目录下. 默认情况下, 有几十个模块被启用, 如GDScript(是的, 它不是基础引擎的一部分), Mono运行时, 正则表达式模块和其他. 可以根据需要创建和组合尽可能多的新模块.SCons构建系统将清晰地处理它.</paragraph>
        </section>
        <section ids="what-for" names="what\ for? 可以做什么？">
            <title>可以做什么？</title>
            <paragraph>尽管我们建议使用脚本编写游戏的大部分代码(因为这能够节省大量的时间), 但使用 C++ 进行开发也是完全可行的. 在以下情况下, 添加C ++模块可能会很有用:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>将外部库绑定到 Godot（例如 PhysX、FMOD 等）。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>优化游戏的核心部分。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>为引擎和/或编辑器添加新功能。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Porting an existing game to Godot.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>使用 C++ 编写整个新游戏，因为你离不开 C++。</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="creating-a-new-module" names="creating\ a\ new\ module 创建新模块">
            <title>创建新模块</title>
            <paragraph>创建模块之前，请先<reference internal="True" refuri="../compiling/index#toc-devel-compiling"><inline classes="std std-ref">下载 Godot 源代码并编译</inline></reference>。</paragraph>
            <paragraph>要创建一个新模块, 首先我们要在 <literal>modules/</literal> 文件夹下创建一个新目录. 如果要单独维护模块, 则可以在版本控制系统(VCS)检出到模块中并使用它.</paragraph>
            <paragraph>The example module will be called "summator" (<literal>godot/modules/summator</literal>).
                Inside we will create a summator class:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">/* summator.h */

#ifndef SUMMATOR_H
#define SUMMATOR_H

#include "core/object/ref_counted.h"

class Summator : public RefCounted {
    GDCLASS(Summator, RefCounted);

    int count;

protected:
    static void _bind_methods();

public:
    void add(int p_value);
    void reset();
    int get_total() const;

    Summator();
};

#endif // SUMMATOR_H</literal_block>
            <paragraph>然后是 cpp 文件。</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">/* summator.cpp */

#include "summator.h"

void Summator::add(int p_value) {
    count += p_value;
}

void Summator::reset() {
    count = 0;
}

int Summator::get_total() const {
    return count;
}

void Summator::_bind_methods() {
    ClassDB::bind_method(D_METHOD("add", "value"), &amp;Summator::add);
    ClassDB::bind_method(D_METHOD("reset"), &amp;Summator::reset);
    ClassDB::bind_method(D_METHOD("get_total"), &amp;Summator::get_total);
}

Summator::Summator() {
    count = 0;
}</literal_block>
            <paragraph>然后, 需要以某种方式注册新类, 因此需要再创建两个文件:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">register_types.h
register_types.cpp</literal_block>
            <important>
                <paragraph>这些文件必须在你的模块的顶层文件夹中( <literal>SCsub</literal> 和 <literal>config.py</literal> 文件旁边), 这样模块才能被正确注册.</paragraph>
            </important>
            <paragraph>这些文件应包含以下内容:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">/* register_types.h */

#include "modules/register_module_types.h"

void initialize_summator_module(ModuleInitializationLevel p_level);
void uninitialize_summator_module(ModuleInitializationLevel p_level);
/* yes, the word in the middle must be the same as the module folder name */</literal_block>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">/* register_types.cpp */

#include "register_types.h"

#include "core/object/class_db.h"
#include "summator.h"

void initialize_summator_module(ModuleInitializationLevel p_level) {
    if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) {
            return;
    }
    ClassDB::register_class&lt;Summator&gt;();
}

void uninitialize_summator_module(ModuleInitializationLevel p_level) {
    if (p_level != MODULE_INITIALIZATION_LEVEL_SCENE) {
            return;
    }
   // Nothing to do here in this example.
}</literal_block>
            <paragraph>接下来, 我们需要创建一个 <literal>SCsub</literal> 文件, 以便构建系统编译此模块:</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># SCsub

Import('env')

env.add_source_files(env.modules_sources, "*.cpp") # Add all cpp files to the build</literal_block>
            <paragraph>使用多个源文件, 你还可以将每个文件分别添加到Python字符串列表中:</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">src_list = ["summator.cpp", "other.cpp", "etc.cpp"]
env.add_source_files(env.modules_sources, src_list)</literal_block>
            <paragraph>使用循环和逻辑语句, 这使得使用Python来构建文件列表有了强大的可行性. 请看Godot默认的一些模块的例子.</paragraph>
            <paragraph>要添加供编译器查看的包含目录, 可以将其追加到环境的路径中:</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">env.Append(CPPPATH=["mylib/include"]) # this is a relative path
env.Append(CPPPATH=["#myotherlib/include"]) # this is an 'absolute' path</literal_block>
            <paragraph>如果你想在构建模块时添加自定义编译器标志，你需要先克隆 <literal>env</literal> ，这样它就不会把这些标志添加到整个Godot构建中（这可能导致错误）。例子 <literal>SCsub</literal> 带有自定义标志:</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># SCsub

Import('env')

module_env = env.Clone()
module_env.add_source_files(env.modules_sources, "*.cpp")
# Append CCFLAGS flags for both C and C++ code.
module_env.Append(CCFLAGS=['-O2'])
# If you need to, you can:
# - Append CFLAGS for C code only.
# - Append CXXFLAGS for C++ code only.</literal_block>
            <paragraph>And finally, the configuration file for the module, this is a
                Python script that must be named <literal>config.py</literal>:</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># config.py

def can_build(env, platform):
    return True

def configure(env):
    pass</literal_block>
            <paragraph>询问模块是否可以针对特定平台进行构建(在这种情况下, <literal>True</literal> 表示它将针对每个平台进行构建).</paragraph>
            <paragraph>就是这样. 希望它不太复杂！ 你的模块应如下所示:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">godot/modules/summator/config.py
godot/modules/summator/summator.h
godot/modules/summator/summator.cpp
godot/modules/summator/register_types.h
godot/modules/summator/register_types.cpp
godot/modules/summator/SCsub</literal_block>
            <paragraph>然后, 你可以压缩它并与其他所有人分享该模块. 当针对每个平台进行构建时(上一节中的说明), 你的模块将包括在内.</paragraph>
            <note>
                <paragraph>对于子类之类的东西,C ++模块中的参数限制为5. 通过包含头文件 <literal>core/method_bind_ext.gen.inc</literal>, 可以将其增加到13个.</paragraph>
            </note>
        </section>
        <section ids="using-the-module" names="using\ the\ module 使用模块">
            <title>使用模块</title>
            <paragraph>现在, 你可以通过任何脚本使用新创建的模块:</paragraph>
            <container classes="sphinx-tabs" type="tab-element">
                <div aria-label="Tabbed content" role="tablist">
                    <button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" classes="sphinx-tabs-tab code-tab group-tab" ids="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button>
                </div>
                <div aria-labelledby="tab-0-R0RTY3JpcHQ=" classes="sphinx-tabs-panel code-tab group-tab" ids="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
                    <literal_block force="False" highlight_args="{}" language="gdscript" linenos="False" xml:space="preserve">var s = Summator.new()
s.add(10)
s.add(20)
s.add(30)
print(s.get_total())
s.reset()</literal_block>
                </div>
            </container>
            <paragraph>输出将是 <literal>60</literal> .</paragraph>
            <seealso>
                <paragraph>前面的Summator例子对于小型的自定义模块来说是很好的, 但是如果你想使用一个更大的外部库呢？请参考 <reference internal="True" refuri="binding_to_external_libraries#doc-binding-to-external-libraries"><inline classes="std std-ref">绑定到外部库</inline></reference>, 了解有关绑定外部库的细节.</paragraph>
            </seealso>
            <warning>
                <paragraph>如果要从正在运行的项目（而不仅仅是从编辑器）访问模块，则还必须重新编译计划使用的每个导出模板，然后在每个导出预设中指定自定义模板的路径。否则，由于未在导出模板中编译模块，因此在运行项目时会出现错误。更多信息见<reference internal="True" refuri="../compiling/index#toc-devel-compiling"><inline classes="std std-ref">编译</inline></reference>页面。</paragraph>
            </warning>
        </section>
        <section ids="compiling-a-module-externally" names="compiling\ a\ module\ externally 从外部编译模块">
            <title>从外部编译模块</title>
            <paragraph>编译一个模块需要将模块的源代码直接移到引擎的 <literal>modules/</literal> 目录下. 虽然这是最直接的编译模块的方法, 但是有几个原因说明为什么这样做不实用:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>每次编译引擎时, 不管有没有模块, 都必须手动复制模块源码, 或者在编译过程中使用类似 <literal>module_summator_enabled=no</literal> 的编译选项, 采取额外的步骤手动禁用模块. 创建符号链接也是一种解决方案, 但你可能还需要克服操作系统的限制, 比如如果通过脚本来做, 需要符号链接的权限.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>根据你是否需要使用引擎的源代码, 直接添加到 <literal>modules/</literal> 的模块文件会改变工作树, 以至于使用VCS(比如 <literal>git</literal> )被证明是很麻烦的, 因为你需要通过过滤变化来确保只提交与引擎相关的代码.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>所以, 如果你觉得需要自定义模块的独立结构, 把 "summator" 模块移到引擎的父目录下:</paragraph>
            <literal_block force="False" highlight_args="{}" language="shell" linenos="False" xml:space="preserve">mkdir ../modules
mv modules/summator ../modules</literal_block>
            <paragraph>通过提供 <literal>custom_modules</literal> 构建选项来编译我们的引擎, 该选项接受一个以逗号分隔的包含自定义C++模块的目录路径列表, 类似于下面:</paragraph>
            <literal_block force="False" highlight_args="{}" language="shell" linenos="False" xml:space="preserve">scons custom_modules=../modules</literal_block>
            <paragraph>构建系统将检测到 <literal>./modules</literal> 目录下的所有模块并进行相应的编译, 包括 "summator" 模块.</paragraph>
            <warning>
                <paragraph>传递给 <literal>custom_modules</literal> 的任何路径都将在内部转换为绝对路径, 以区分自定义模块和内置模块, 这意味着像生成模块文档这样的事情可能会依赖于你机器上的特定路径结构.</paragraph>
            </warning>
            <seealso>
                <paragraph><reference internal="True" refuri="../compiling/introduction_to_the_buildsystem#doc-buildsystem-custom-modules"><inline classes="std std-ref">构建系统介绍 - 自定义模块构建选项</inline></reference>.</paragraph>
            </seealso>
        </section>
        <section ids="customizing-module-types-initialization" names="customizing\ module\ types\ initialization">
            <title>Customizing module types initialization</title>
            <paragraph>Modules can interact with other built-in engine classes during runtime and even
                affect the way core types are initialized. So far, we've been using
                <literal>register_summator_types</literal> as a way to bring in module classes to be available
                within the engine.</paragraph>
            <paragraph>A crude order of the engine setup can be summarized as a list of the following
                type registration methods:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">preregister_module_types();
preregister_server_types();
register_core_singletons();
register_server_types();
register_scene_types();
EditorNode::register_editor_types();
register_platform_apis();
register_module_types();
initialize_physics();
initialize_navigation_server();
register_server_singletons();
register_driver_types();
ScriptServer::init_languages();</literal_block>
            <paragraph>Our <literal>Summator</literal> class is initialized during the <literal>register_module_types()</literal>
                call. Imagine that we need to satisfy some common module run-time dependency
                (like singletons), or allow us to override existing engine method callbacks
                before they can be assigned by the engine itself. In that case, we want to
                ensure that our module classes are registered <emphasis>before</emphasis> any other built-in type.</paragraph>
            <paragraph>This is where we can define an optional <literal>preregister_summator_types()</literal>
                method which will be called before anything else during the
                <literal>preregister_module_types()</literal> engine setup stage.</paragraph>
            <paragraph>We now need to add this method to <literal>register_types</literal> header and source files:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">/* register_types.h */

#define MODULE_SUMMATOR_HAS_PREREGISTER
void preregister_summator_types();

void register_summator_types();
void unregister_summator_types();</literal_block>
            <note>
                <paragraph>Unlike other register methods, we have to explicitly define
                    <literal>MODULE_SUMMATOR_HAS_PREREGISTER</literal> to let the build system know what
                    relevant method calls to include at compile time. The module's name
                    has to be converted to uppercase as well.</paragraph>
            </note>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">/* register_types.cpp */

#include "register_types.h"

#include "core/object/class_db.h"
#include "summator.h"

void preregister_summator_types() {
    // Called before any other core types are registered.
    // Nothing to do here in this example.
}

void register_summator_types() {
    ClassDB::register_class&lt;Summator&gt;();
}

void unregister_summator_types() {
   // Nothing to do here in this example.
}</literal_block>
        </section>
        <section ids="improving-the-build-system-for-development" names="improving\ the\ build\ system\ for\ development 改善开发的构建系统">
            <title>改善开发的构建系统</title>
            <warning>
                <paragraph>This shared library support is not designed to support distributing a module
                    to other users without recompiling the engine. For that purpose, use
                    a GDExtension instead.</paragraph>
            </warning>
            <paragraph>到目前为止，我们定义了一个干净的 SCsub，让我们能够将新模块的源文件添加为 Godot 二进制文件的一部分。</paragraph>
            <paragraph>那么当我们要构建游戏的发行版，并希望将所有模块都放在一个二进制文件中时，这种静态方法就很好。</paragraph>
            <paragraph>然而，代价是每一个变化都意味着游戏的全面重新编译。即使 SCons 能够检测并重新编译已经改变的文件，找到这些文件并最终链接到最终的二进制文件会花费很长时间。</paragraph>
            <paragraph>避免这种成本的解决方案是将我们自己的模块构建为共享库, 该库在启动游戏二进制文件时将动态加载.</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># SCsub

Import('env')

sources = [
    "register_types.cpp",
    "summator.cpp"
]

# First, create a custom env for the shared library.
module_env = env.Clone()

# Position-independent code is required for a shared library.
module_env.Append(CCFLAGS=['-fPIC'])

# Don't inject Godot's dependencies into our shared library.
module_env['LIBS'] = []

# Define the shared library. By default, it would be built in the module's
# folder, however it's better to output it into `bin` next to the
# Godot binary.
shared_lib = module_env.SharedLibrary(target='#bin/summator', source=sources)

# Finally, notify the main build environment it now has our shared library
# as a new dependency.

# LIBPATH and LIBS need to be set on the real "env" (not the clone)
# to link the specified libraries to the Godot executable.

env.Append(LIBPATH=['#bin'])

# SCons wants the name of the library with it custom suffixes
# (e.g. ".linuxbsd.tools.64") but without the final ".so".
shared_lib_shim = shared_lib[0].name.rsplit('.', 1)[0]
env.Append(LIBS=[shared_lib_shim])</literal_block>
            <paragraph>一旦编译完成, 我们应该有一个 <literal>bin</literal> 目录, 其中包含 <literal>godot*</literal> 可执行文件和 <literal>libsummator*.so</literal> . 然而, 鉴于.so不在一个标准的目录中(如 <literal>/usr/lib</literal> ), 我们必须在运行时用 <literal>LD_LIBRARY_PATH</literal> 环境变量帮助可执行文件找到它:</paragraph>
            <literal_block force="False" highlight_args="{}" language="shell" linenos="False" xml:space="preserve">export LD_LIBRARY_PATH="$PWD/bin/"
./bin/godot*</literal_block>
            <note>
                <paragraph>你必须 <literal>export</literal> 这个环境变量，否则你将无法从编辑器中运行你的项目。</paragraph>
            </note>
            <paragraph>最重要的是，能够选择将我们的模块编译为共享库（用于开发）还是作为 Godot 二进制文件的一部分（用于发布）将是一件很不错的事情。为此，我们可以使用 <literal>ARGUMENT</literal> 命令定义要传递给 SCons 的自定义标志：</paragraph>
            <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve"># SCsub

Import('env')

sources = [
    "register_types.cpp",
    "summator.cpp"
]

module_env = env.Clone()
module_env.Append(CCFLAGS=['-O2'])

if ARGUMENTS.get('summator_shared', 'no') == 'yes':
    # Shared lib compilation
    module_env.Append(CCFLAGS=['-fPIC'])
    module_env['LIBS'] = []
    shared_lib = module_env.SharedLibrary(target='#bin/summator', source=sources)
    shared_lib_shim = shared_lib[0].name.rsplit('.', 1)[0]
    env.Append(LIBS=[shared_lib_shim])
    env.Append(LIBPATH=['#bin'])
else:
    # Static compilation
    module_env.add_source_files(env.modules_sources, sources)</literal_block>
            <paragraph>现在默认情况下, <literal>scons</literal> 命令会将我们的模块构建为Godot二进制文件的一部分, 并在传递 <literal>summator_shared=yes</literal> 时构建为共享库.</paragraph>
            <paragraph>最后, 你甚至可以通过在SCons命令中明确指定你的共享模块为目标来进一步加快构建速度:</paragraph>
            <literal_block force="False" highlight_args="{}" language="shell" linenos="False" xml:space="preserve">scons summator_shared=yes platform=linuxbsd bin/libsummator.linuxbsd.tools.64.so</literal_block>
        </section>
        <section ids="writing-custom-documentation" names="writing\ custom\ documentation 编写自定义文档">
            <title>编写自定义文档</title>
            <paragraph>Writing documentation may seem like a boring task, but it is highly recommended
                to document your newly created module to make it easier for users to benefit
                from it. Not to mention that the code you've written one year ago may become
                indistinguishable from the code that was written by someone else, so be kind to
                your future self!</paragraph>
            <paragraph>为了设置模块的自定义文档, 有几个步骤:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>在模块的根目录中创建一个新目录. 目录名称可以是任何名称, 但是在本节中, 我们将使用 <literal>doc_classes</literal> 名称.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>现在, 我们需要编辑 <literal>config.py</literal> , 添加以下片段:</paragraph>
                    <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">def get_doc_path():
    return "doc_classes"

def get_doc_classes():
    return [
        "Summator",
    ]</literal_block>
                </list_item>
            </enumerated_list>
            <paragraph>构建系统使用 <literal>get_doc_path()</literal> 函数来确定文档的位置. 在这种情况下, 它们将位于 <literal>modules/summator/doc_classes</literal> 目录下. 如果你不定义这个, 你的模块的文档路径将退回到主 <literal>doc/classes</literal> 目录.</paragraph>
            <paragraph><literal>get_doc_classes()</literal> 方法对于构建系统知道哪些注册的类属于该模块是必要的. 你需要在这里列出你所有的类. 你没有列出的类最终将出现主 <literal>doc/classes</literal> 目录中.</paragraph>
            <tip>
                <paragraph>你可以用 Git 来检查是否漏掉了一些类，用 <literal>git status</literal> 检查未跟踪的文件。例如：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">user@host:~/godot$ git status</literal_block>
                <paragraph>输出示例：</paragraph>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">Untracked files:
    (use "git add &lt;file&gt;..." to include in what will be committed)

    doc/classes/MyClass2D.xml
    doc/classes/MyClass4D.xml
    doc/classes/MyClass5D.xml
    doc/classes/MyClass6D.xml
    ...</literal_block>
            </tip>
            <enumerated_list enumtype="arabic" prefix="" start="3" suffix=".">
                <list_item>
                    <paragraph>现在我们可以生成文档:</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>我们可以通过运行Godot的doctool, 即 <literal>godot -doctool &lt;path&gt;</literal> , 它将以XML格式转储引擎API引用到给定的 <literal>&lt;path&gt;</literal> .</paragraph>
            <paragraph>在我们的例子中, 将把它指向克隆的版本库的根目录. 你可以把它指向另一个文件夹, 然后复制需要的文件.</paragraph>
            <paragraph>运行命令:</paragraph>
            <block_quote>
                <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">user@host:~/godot$ ./bin/&lt;godot_binary&gt; --doctool .</literal_block>
            </block_quote>
            <paragraph>现在, 如果进入 <literal>godot/modules/summator/doc_classes</literal> 文件夹, 会看到它包含一个在 <literal>get_doc_classes</literal> 函数中引用的 <literal>Summator.xml</literal> 文件, 或者其他类.</paragraph>
            <paragraph>Edit the file(s) following <reference internal="True" refuri="../../documentation/class_reference_primer#doc-class-reference-primer"><inline classes="std std-ref">类参考入门</inline></reference> and recompile the engine.</paragraph>
            <paragraph>一旦编译过程完成, 这些文档将可以在引擎的内置文档系统中访问.</paragraph>
            <paragraph>为了保持文档的更新, 你所要做的就是简单地修改其中一个XML文件, 然后从现在开始重新编译引擎.</paragraph>
            <paragraph>如果你改变了模块的API, 可以重新提取文档, 它们会包含你之前添加的东西. 当然如果你把它指向 godot 文件夹, 请确保不会因为在新的文档上提取旧引擎构建的旧文档而损失工作.</paragraph>
            <paragraph>请注意, 如果你对提供的 <literal>&lt;path&gt;</literal> 没有写访问权限, 可能会遇到类似下面的错误:</paragraph>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">ERROR: Can't write doc file: docs/doc/classes/@GDScript.xml
   At: editor/doc/doc_data.cpp:956</literal_block>
            <target refid="doc-custom-module-unit-tests"></target>
        </section>
        <section ids="writing-custom-unit-tests doc-custom-module-unit-tests" names="writing\ custom\ unit\ tests 编写自定义单元测试 doc_custom_module_unit_tests">
            <title>编写自定义单元测试</title>
            <paragraph>It's possible to write self-contained unit tests as part of a C++ module. If you
                are not familiar with the unit testing process in Godot yet, please refer to
                <reference internal="True" refuri="unit_testing#doc-unit-testing"><inline classes="std std-ref">单元测试</inline></reference>.</paragraph>
            <paragraph>The procedure is the following:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Create a new directory named <literal>tests/</literal> under your module's root:</paragraph>
                </list_item>
            </enumerated_list>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">cd modules/summator
mkdir tests
cd tests</literal_block>
            <enumerated_list enumtype="arabic" prefix="" start="2" suffix=".">
                <list_item>
                    <paragraph>Create a new test suite: <literal>test_summator.h</literal>. The header must be prefixed
                        with <literal>test_</literal> so that the build system can collect it and include it as part
                        of the <literal>tests/test_main.cpp</literal> where the tests are run.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Write some test cases. Here's an example:</paragraph>
                </list_item>
            </enumerated_list>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">// test_summator.h
#ifndef TEST_SUMMATOR_H
#define TEST_SUMMATOR_H

#include "tests/test_macros.h"

#include "modules/summator/summator.h"

namespace TestSummator {

TEST_CASE("[Modules][Summator] Adding numbers") {
    Ref&lt;Summator&gt; s = memnew(Summator);
    CHECK(s-&gt;get_total() == 0);

    s-&gt;add(10);
    CHECK(s-&gt;get_total() == 10);

    s-&gt;add(20);
    CHECK(s-&gt;get_total() == 30);

    s-&gt;add(30);
    CHECK(s-&gt;get_total() == 60);

    s-&gt;reset();
    CHECK(s-&gt;get_total() == 0);
}

} // namespace TestSummator

#endif // TEST_SUMMATOR_H</literal_block>
            <enumerated_list enumtype="arabic" prefix="" start="4" suffix=".">
                <list_item>
                    <paragraph>Compile the engine with <literal>scons tests=yes</literal>, and run the tests with the
                        following command:</paragraph>
                </list_item>
            </enumerated_list>
            <literal_block force="False" highlight_args="{}" language="console" linenos="False" xml:space="preserve">./bin/&lt;godot_binary&gt; --test --source-file="*test_summator*" --success</literal_block>
            <paragraph>You should see the passing assertions now.</paragraph>
            <target refid="doc-custom-module-icons"></target>
        </section>
        <section ids="adding-custom-editor-icons doc-custom-module-icons" names="adding\ custom\ editor\ icons 添加自定义编辑器图标 doc_custom_module_icons">
            <title>添加自定义编辑器图标</title>
            <paragraph>与如何在模块中编写独立的文档类似, 你也可以为类创建自己的自定义图标, 以使其出现在编辑器中.</paragraph>
            <paragraph>有关创建要集成到引擎中的编辑器图标的实际过程, 首先请参考 <reference internal="True" refuri="../editor/creating_icons#doc-editor-icons"><inline classes="std std-ref">编辑器图标</inline></reference>.</paragraph>
            <paragraph>创建图标后, 请执行以下步骤:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>在名为 <literal>icons</literal> 的模块的根目录中创建一个新目录. 这是引擎查找模块的编辑器图标的默认路径.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>将新创建的 <literal>svg</literal> 图标(已优化或未优化)移动到该文件夹中.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>重新编译引擎并运行编辑器. 现在, 相应的图标将出现在编辑器的界面中合适的位置中.</paragraph>
                </list_item>
            </enumerated_list>
            <paragraph>如果你想将图标存储在模块内的其他位置, 请将以下代码段添加到 <literal>config.py</literal> 以覆盖默认路径:</paragraph>
            <block_quote>
                <literal_block force="False" highlight_args="{}" language="python" linenos="False" xml:space="preserve">def get_icons_path():
    return "path/to/icons"</literal_block>
            </block_quote>
        </section>
        <section ids="summing-up" names="summing\ up 总结">
            <title>总结</title>
            <paragraph>记得:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>对于继承使用 <literal>GDCLASS</literal> 宏, 因此Godot可以封装它。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Use <literal>_bind_methods</literal> to bind your functions to scripting, and to
                        allow them to work as callbacks for signals.</paragraph>
                </list_item>
                <list_item>
                    <paragraph><strong>Avoid multiple inheritance for classes exposed to Godot</strong>, as <literal>GDCLASS</literal>
                        doesn't support this. You can still use multiple inheritance in your own
                        classes as long as they're not exposed to Godot's scripting API.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>但这还不是全部, 取决于你做什么, 你会得到一些(希望是积极的)惊喜.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>If you inherit from <reference internal="True" refuri="../../../classes/class_node#class-node"><inline classes="std std-ref">Node</inline></reference> (or any derived node type, such as
                        Sprite2D), your new class will appear in the editor, in the inheritance
                        tree in the "Add Node" dialog.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>如果你从 <reference internal="True" refuri="../../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> 继承, 则它将出现在资源列表中, 并且所有暴露的属性在保存/加载时都可以序列化.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>通过同样的逻辑, 你可以扩展编辑器, 以及引擎中几乎所有领域.</paragraph>
                </list_item>
            </bullet_list>
            <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
        </section>
    </section>
</document>
