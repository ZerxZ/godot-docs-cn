<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/contributing/development/core_and_modules/custom_godot_servers.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-custom-godot-servers"></target>
    <section ids="custom-godot-servers doc-custom-godot-servers" names="custom\ godot\ servers 自定义\ godot\ 服务器 doc_custom_godot_servers">
        <title>自定义 Godot 服务器</title>
        <section ids="introduction" names="introduction 前言">
            <title>前言</title>
            <paragraph>Godot 以服务器的形式实现多线程。服务器是用来管理数据、处理数据、推送结果的守护服务。服务器实现了中介者模式，能够为引擎和其他模块解释资源 ID、处理数据。另外服务器还拥有分配的 RID 的所有权。</paragraph>
            <paragraph>本指南需要读者知道如何创建 C++ 模块、了解 Godot 的数据类型。如果你还没有准备好，请参考 <reference internal="True" refuri="custom_modules_in_cpp#doc-custom-modules-in-cpp"><inline classes="std std-ref">自定义 C++ 模块</inline></reference>。</paragraph>
            <section dupnames="references" ids="references" names="参考">
                <title>参考</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="为什么 Godot 要使用服务器和 RID？" refuri="https://godotengine.org/article/why-does-godot-use-servers-and-rids">为什么 Godot 要使用服务器和 RID？</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="单例模式" refuri="https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="中介者模式" refuri="https://zh.wikipedia.org/wiki/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F">中介者模式</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="what-for" names="what\ for? 可以做什么？">
            <title>可以做什么？</title>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>添加人工智能。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>添加自定义异步线程。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>添加对新输入设备的支持。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>添加写线程。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>添加自定义 VoIP 协议。</paragraph>
                </list_item>
                <list_item>
                    <paragraph>以及更多……</paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="creating-a-godot-server" names="creating\ a\ godot\ server 创建\ godot\ 服务器">
            <title>创建 Godot 服务器</title>
            <paragraph>服务器至少必须拥有静态的实例、睡眠计时器、线程循环、初始化状态、清理过程。</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#ifndef HILBERT_HOTEL_H
#define HILBERT_HOTEL_H

#include "core/object/object.h"
#include "core/os/thread.h"
#include "core/os/mutex.h"
#include "core/templates/list.h"
#include "core/templates/rid.h"
#include "core/templates/set.h"
#include "core/variant/variant.h"

class HilbertHotel : public Object {
        GDCLASS(HilbertHotel, Object);

        static HilbertHotel *singleton;
        static void thread_func(void *p_udata);

private:
        bool thread_exited;
        mutable bool exit_thread;
        Thread *thread;
        Mutex *mutex;

public:
        static HilbertHotel *get_singleton();
        Error init();
        void lock();
        void unlock();
        void finish();

protected:
        static void _bind_methods();

private:
        uint64_t counter;
        RID_Owner&lt;InfiniteBus&gt; bus_owner;
        // https://github.com/godotengine/godot/blob/master/core/templates/rid.h
        Set&lt;RID&gt; buses;
        void _emit_occupy_room(uint64_t room, RID rid);

public:
        RID create_bus();
        Variant get_bus_info(RID id);
        bool empty();
        bool delete_bus(RID id);
        void clear();
        void register_rooms();
        HilbertHotel();
};

#endif</literal_block>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">#include "hilbert_hotel.h"

#include "core/variant/dictionary.h"
#include "core/os/os.h"

#include "prime_225.h"

void HilbertHotel::thread_func(void *p_udata) {

        HilbertHotel *ac = (HilbertHotel *) p_udata;
        uint64_t msdelay = 1000;

        while (!ac-&gt;exit_thread) {
                if (!ac-&gt;empty()) {
                        ac-&gt;lock();
                        ac-&gt;register_rooms();
                        ac-&gt;unlock();
                }
                OS::get_singleton()-&gt;delay_usec(msdelay * 1000);
        }
}

Error HilbertHotel::init() {
        thread_exited = false;
        counter = 0;
        mutex = Mutex::create();
        thread = Thread::create(HilbertHotel::thread_func, this);
        return OK;
}

HilbertHotel *HilbertHotel::singleton = NULL;

HilbertHotel *HilbertHotel::get_singleton() {
        return singleton;
}

void HilbertHotel::register_rooms() {
        for (Set&lt;RID&gt;::Element *e = buses.front(); e; e = e-&gt;next()) {
                auto bus = bus_owner.getornull(e-&gt;get());

                if (bus) {
                        uint64_t room = bus-&gt;next_room();
                        _emit_occupy_room(room, bus-&gt;get_self());
                }
        }
}

void HilbertHotel::unlock() {
        if (!thread || !mutex) {
                return;
        }

        mutex-&gt;unlock();
}

void HilbertHotel::lock() {
        if (!thread || !mutex) {
                return;
        }

        mutex-&gt;lock();
}

void HilbertHotel::_emit_occupy_room(uint64_t room, RID rid) {
        _HilbertHotel::get_singleton()-&gt;_occupy_room(room, rid);
}

Variant HilbertHotel::get_bus_info(RID id) {
        InfiniteBus *bus = bus_owner.getornull(id);

        if (bus) {
                Dictionary d;
                d["prime"] = bus-&gt;get_bus_num();
                d["current_room"] = bus-&gt;get_current_room();
                return d;
        }

        return Variant();
}

void HilbertHotel::finish() {
        if (!thread) {
                return;
        }

        exit_thread = true;
        Thread::wait_to_finish(thread);

        memdelete(thread);

        if (mutex) {
                memdelete(mutex);
        }

        thread = NULL;
}

RID HilbertHotel::create_bus() {
        lock();
        InfiniteBus *ptr = memnew(InfiniteBus(PRIME[counter++]));
        RID ret = bus_owner.make_rid(ptr);
        ptr-&gt;set_self(ret);
        buses.insert(ret);
        unlock();

        return ret;
}

// https://github.com/godotengine/godot/blob/master/core/templates/rid.h
bool HilbertHotel::delete_bus(RID id) {
        if (bus_owner.owns(id)) {
                lock();
                InfiniteBus *b = bus_owner.get(id);
                bus_owner.free(id);
                buses.erase(id);
                memdelete(b);
                unlock();
                return true;
        }

        return false;
}

void HilbertHotel::clear() {
        for (Set&lt;RID&gt;::Element *e = buses.front(); e; e = e-&gt;next()) {
                delete_bus(e-&gt;get());
        }
}

bool HilbertHotel::empty() {
        return buses.size() &lt;= 0;
}

void HilbertHotel::_bind_methods() {
}

HilbertHotel::HilbertHotel() {
        singleton = this;
}</literal_block>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">/* prime_225.h */

const uint64_t PRIME[225] = {
                2,3,5,7,11,13,17,19,23,
                29,31,37,41,43,47,53,59,61,
                67,71,73,79,83,89,97,101,103,
                107,109,113,127,131,137,139,149,151,
                157,163,167,173,179,181,191,193,197,
                199,211,223,227,229,233,239,241,251,
                257,263,269,271,277,281,283,293,307,
                311,313,317,331,337,347,349,353,359,
                367,373,379,383,389,397,401,409,419,
                421,431,433,439,443,449,457,461,463,
                467,479,487,491,499,503,509,521,523,
                541,547,557,563,569,571,577,587,593,
                599,601,607,613,617,619,631,641,643,
                647,653,659,661,673,677,683,691,701,
                709,719,727,733,739,743,751,757,761,
                769,773,787,797,809,811,821,823,827,
                829,839,853,857,859,863,877,881,883,
                887,907,911,919,929,937,941,947,953,
                967,971,977,983,991,997,1009,1013,1019,
                1021,1031,1033,1039,1049,1051,1061,1063,1069,
                1087,1091,1093,1097,1103,1109,1117,1123,1129,
                1151,1153,1163,1171,1181,1187,1193,1201,1213,
                1217,1223,1229,1231,1237,1249,1259,1277,1279,
                1283,1289,1291,1297,1301,1303,1307,1319,1321,
                1327,1361,1367,1373,1381,1399,1409,1423,1427
};</literal_block>
        </section>
        <section ids="custom-managed-resource-data" names="custom\ managed\ resource\ data 自定义托管资源数据">
            <title>自定义托管资源数据</title>
            <paragraph>Godot 服务器实现了中介者模式。所有数据类型都继承自 <literal>RID_Data</literal>。<literal>RID_Owner &lt;MyRID_Data&gt;</literal> 在调用 <literal>make_rid</literal> 时拥有对象。RID_Owner 只有在调试模式下才会维护 RID 列表。实际上，RID 类似于编写面向对象的 C 代码。</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">class InfiniteBus : public RID_Data {
        RID self;

private:
        uint64_t prime_num;
        uint64_t num;

public:
        uint64_t next_room() {
                return prime_num * num++;
        }

        uint64_t get_bus_num() const {
                return prime_num;
        }

        uint64_t get_current_room() const {
                return prime_num * num;
        }

        _FORCE_INLINE_ void set_self(const RID &amp;p_self) {
                self = p_self;
        }

        _FORCE_INLINE_ RID get_self() const {
                return self;
        }

        InfiniteBus(uint64_t prime) : prime_num(prime), num(1) {};
        ~InfiniteBus() {};
}</literal_block>
            <section dupnames="references" ids="id1" names="参考">
                <title>参考</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference internal="True" refuri="../../../classes/class_rid#class-rid"><inline classes="std std-ref">RID</inline></reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="core/templates/rid.h" refuri="https://github.com/godotengine/godot/blob/master/core/templates/rid.h">core/templates/rid.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="registering-the-class-in-gdscript" names="registering\ the\ class\ in\ gdscript 在\ gdscript\ 中注册类">
            <title>在 GDScript 中注册类</title>
            <paragraph>服务器在 <literal>register_types.cpp</literal> 中分配。构造函数设置静态实例，<literal>init()</literal> 创建托管线程；<literal>unregister_types.cpp</literal> 清理服务器。</paragraph>
            <paragraph>由于 Godot 的服务器类会创建实例并将其与静态单例绑定，将类绑定后可能引用错误的实例。因此，必须创建一个虚设类，引用正确的 Godot 服务器。</paragraph>
            <paragraph>在 <literal>register_server_types()</literal> 中使用 <literal>Engine :: get_singleton() -&gt; add_singleton</literal> 向 GDScript 注册虚设类。</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">/* register_types.cpp */

#include "register_types.h"

#include "core/object/class_db.h"
#include "core/config/engine.h"

#include "hilbert_hotel.h"

static HilbertHotel *hilbert_hotel = NULL;
static _HilbertHotel *_hilbert_hotel = NULL;

void register_hilbert_hotel_types() {
        hilbert_hotel = memnew(HilbertHotel);
        hilbert_hotel-&gt;init();
        _hilbert_hotel = memnew(_HilbertHotel);
        ClassDB::register_class&lt;_HilbertHotel&gt;();
        Engine::get_singleton()-&gt;add_singleton(Engine::Singleton("HilbertHotel", _HilbertHotel::get_singleton()));
}

void unregister_hilbert_hotel_types() {
        if (hilbert_hotel) {
                hilbert_hotel-&gt;finish();
                memdelete(hilbert_hotel);
        }

        if (_hilbert_hotel) {
                memdelete(_hilbert_hotel);
        }
}</literal_block>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">/* register_types.h */

/* Yes, the word in the middle must be the same as the module folder name */
void register_hilbert_hotel_types();
void unregister_hilbert_hotel_types();</literal_block>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="servers/register_server_types.cpp" refuri="https://github.com/godotengine/godot/blob/master/servers/register_server_types.cpp">servers/register_server_types.cpp</reference></paragraph>
                </list_item>
            </bullet_list>
            <section ids="bind-methods" names="bind\ methods 绑定方法">
                <title>绑定方法</title>
                <paragraph>虚设类将单例方法绑定到 GDScript。虚设类中的方法在大多数情况下都只是简单的封装。</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">Variant _HilbertHotel::get_bus_info(RID id) {
        return HilbertHotel::get_singleton()-&gt;get_bus_info(id);
}</literal_block>
                <paragraph>绑定信号</paragraph>
                <paragraph>调用 GDScript 虚设对象就可以向 GDScript 发出信号。</paragraph>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void HilbertHotel::_emit_occupy_room(uint64_t room, RID rid) {
        _HilbertHotel::get_singleton()-&gt;_occupy_room(room, rid);
}</literal_block>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">class _HilbertHotel : public Object {
        GDCLASS(_HilbertHotel, Object);

        friend class HilbertHotel;
        static _HilbertHotel *singleton;

protected:
        static void _bind_methods();

private:
        void _occupy_room(int room_number, RID bus);

public:
        RID create_bus();
        void connect_signals();
        bool delete_bus(RID id);
        static _HilbertHotel *get_singleton();
        Variant get_bus_info(RID id);

        _HilbertHotel();
        ~_HilbertHotel();
};

#endif</literal_block>
                <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">_HilbertHotel *_HilbertHotel::singleton = NULL;
_HilbertHotel *_HilbertHotel::get_singleton() { return singleton; }

RID _HilbertHotel::create_bus() {
        return HilbertHotel::get_singleton()-&gt;create_bus();
}

bool _HilbertHotel::delete_bus(RID rid) {
        return HilbertHotel::get_singleton()-&gt;delete_bus(rid);
}

void _HilbertHotel::_occupy_room(int room_number, RID bus) {
        emit_signal("occupy_room", room_number, bus);
}

Variant _HilbertHotel::get_bus_info(RID id) {
        return HilbertHotel::get_singleton()-&gt;get_bus_info(id);
}

void _HilbertHotel::_bind_methods() {
        ClassDB::bind_method(D_METHOD("get_bus_info", "r_id"), &amp;_HilbertHotel::get_bus_info);
        ClassDB::bind_method(D_METHOD("create_bus"), &amp;_HilbertHotel::create_bus);
        ClassDB::bind_method(D_METHOD("delete_bus"), &amp;_HilbertHotel::delete_bus);
        ADD_SIGNAL(MethodInfo("occupy_room", PropertyInfo(Variant::INT, "room_number"), PropertyInfo(Variant::_RID, "r_id")));
}

void _HilbertHotel::connect_signals() {
        HilbertHotel::get_singleton()-&gt;connect("occupy_room", _HilbertHotel::get_singleton(), "_occupy_room");
}

_HilbertHotel::_HilbertHotel() {
        singleton = this;
}

_HilbertHotel::~_HilbertHotel() {
}</literal_block>
            </section>
        </section>
        <section ids="messagequeue" names="messagequeue">
            <title>MessageQueue</title>
            <paragraph>为了将命令发送到SceneTree中,MessageQueue是线程安全的缓冲区, 用于将其他线程的设置和调用方法排队. 要对命令进行排队, 请获取目标对象RID并使用 <literal>push_call</literal>, <literal>push_set</literal>, 或 <literal>push_notification</literal> 执行所需的行为. 每当执行 <literal>SceneTree::idle</literal> 或 <literal>SceneTree::iteration</literal> 时, 都会刷新队列.</paragraph>
            <section ids="id2" names="references: 参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/object/message_queue.cpp" refuri="https://github.com/godotengine/godot/blob/master/core/object/message_queue.cpp">core/object/message_queue.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="summing-it-up" names="summing\ it\ up 总结">
            <title>总结</title>
            <paragraph>这是GDScript示例代码:</paragraph>
            <literal_block force="False" language="gdscript" linenos="False" xml:space="preserve">extends Node

func _ready():
    print("Start debugging")
    HilbertHotel.connect("occupy_room", self, "_print_occupy_room")
    var rid = HilbertHotel.create_bus()
    OS.delay_msec(2000)
    HilbertHotel.create_bus()
    OS.delay_msec(2000)
    HilbertHotel.create_bus()
    OS.delay_msec(2000)
    print(HilbertHotel.get_bus_info(rid))
    HilbertHotel.delete_bus(rid)
    print("Ready done")

func _print_occupy_room(room_number, r_id):
    print("Room number: "  + str(room_number) + ", RID: " + str(r_id))
    print(HilbertHotel.get_bus_info(r_id))</literal_block>
            <section ids="notes" names="notes 注意">
                <title>注意</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>实际的 <reference name="希尔伯特旅馆悖论" refuri="https://en.wikipedia.org/wiki/Hilbert%27s_paradox_of_the_Grand_Hotel">希尔伯特旅馆悖论</reference> 是不可能的.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>连接信号的示例代码是很旁门左道的.</paragraph>
                    </list_item>
                </bullet_list>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
