<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/contributing/development/core_and_modules/core_types.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-core-types"></target>
    <section ids="core-types doc-core-types" names="core\ types 核心类型 doc_core_types">
        <title>核心类型</title>
        <paragraph>Godot 具有构成其核心的丰富的类和模板集，并且所有内容都基于它们构建。</paragraph>
        <paragraph>这份参考将试着按顺序列出它们，使之更容易被理解。</paragraph>
        <section ids="definitions" names="definitions 定义">
            <title>定义</title>
            <paragraph>Godot 使用标准的 C99 数据类型，如 <literal>uint8_t</literal>、<literal>uint32_t</literal>、<literal>int64_t</literal> 等，现在每个编译器都支持。为这些东西重新发明轮子没什么意思，只会让代码更难以阅读。</paragraph>
            <paragraph>通常，除非使用大型结构或数组，否则不必在意是否使用给定任务的最有效数据类型。除非必要，否则大多数代码都使用 <literal>int</literal>。这样做是因为如今每个设备都至少具有 32 位总线，并且可以在一个周期中执行这样的操作。它也使代码更具可读性。</paragraph>
            <paragraph>对于文件或内存大小，使用 <literal>size_t</literal>，保证为 64 位。</paragraph>
            <paragraph>对于 Unicode 字符，使用 CharType 而不是 wchar_t，因为许多架构中 wchar_t 的长度是 4 个字节，而我们需要的是 2 个字节。但是默认情况下，这不会被强制，CharType 会直接映射到 wchar_t。</paragraph>
            <section dupnames="references:" ids="references" names="参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/typedefs.h" refuri="https://github.com/godotengine/godot/blob/master/core/typedefs.h">core/typedefs.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="memory-model" names="memory\ model 内存模型">
            <title>内存模型</title>
            <paragraph>PC 是一个很棒的架构。计算机通常具有 GB 级的内存、TB 级的存储空间和 GHz 级的 CPU，当应用程序需要更多资源时，操作系统会交换出不活动的资源。其他架构（如移动设备或游戏主机）在这些方面通常有更多的限制。</paragraph>
            <paragraph>最常见的内存模型是堆，应用程序会从中请求一块内存区域，底层操作系统会试着从某处找到一块适合这样的内存并返回它。这通常效果最好，并且很灵活，但是随着时间的流逝和滥用，这可能会导致分段。</paragraph>
            <paragraph>分段缓慢地产生对于大多数常见分配而言太小的孔洞，从而浪费了内存。关于堆和分段的文献有很多，因此在此不再赘述。现代操作系统使用分页内存，这有助于减轻但不能解决分段问题。</paragraph>
            <paragraph>然而，许多研究和测试显示，在给出足够内存的情况下，如果最大分配大小所占堆最大大小的比例低于一个给定的阈值，并且有一定比例的内存本来就是不使用的，那么分段就不会变化，不会随着时间的推移成为问题。换句话说，如果留出 10-20％ 的可用内存空间，并且执行的都是小额内存分配，那么就不会出事。</paragraph>
            <paragraph>Godot 确保所有的可动态分配的对象都很小（最多不到几 kb）。但是如果出现很大的分配（像图像、网格几何数据或大数组）会怎样呢？在这种情况下，Godot 可以选择使用动态内存池。内存会被锁定以进行访问操作；如果内存不足，则内存池会根据需要进行重新排列和压缩。根据游戏的需要，程序员可以配置动态内存池的大小。</paragraph>
        </section>
        <section ids="allocating-memory" names="allocating\ memory 内存分配">
            <title>内存分配</title>
            <paragraph>Godot有许多工具可用于跟踪游戏中的内存使用情况, 尤其是在调试期间. 因此, 不应使用常规的C和C++库调用. 相反,Godot提供了一些其它的供你使用.</paragraph>
            <paragraph>Godot提供了一些宏可以用来处理C风格的内存分配:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">memalloc()
memrealloc()
memfree()</literal_block>
            <paragraph>这些等效于标准C库中通常的malloc, realloc, free.</paragraph>
            <paragraph>这些宏可以用来处理C++风格的内存分配:</paragraph>
            <literal_block force="False" highlight_args="{}" language="none" linenos="False" xml:space="preserve">memnew( Class / Class(args) )
memdelete( instance )

memnew_arr( Class , amount )
memdelete_arr( pointer to array )</literal_block>
            <paragraph>这些等效于new, delete, new[]和delete[].</paragraph>
            <paragraph>memnew/memdelete也使用一点C++的小技巧, 在对象创建之后和删除之前, 通知对象.</paragraph>
            <paragraph>对于动态内存，提供了 PoolVector&lt;&gt; 模板。PoolVector 是一个标准的 Vector 类，与 C++ 标准库中的 vector 非常相似。要创建 PoolVector 缓冲区，请使用以下命令：</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">PoolVector&lt;int&gt; data;</literal_block>
            <paragraph>可以使用[]运算符访问PoolVector, 并且存在一些帮助:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">PoolVector&lt;int&gt;::Read r = data.read()
int someint = r[4]</literal_block>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">PoolVector&lt;int&gt;::Write w = data.write()
w[4] = 22;</literal_block>
            <paragraph>这些操作允许从PoolVectors快速读/写并保持锁定直到它们超出作用域. 但是,PoolVectors应该用于小型动态内存操作, 因为read()和write()对于大量访问来说太慢了.</paragraph>
            <section dupnames="references:" ids="id1" names="参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/os/memory.h" refuri="https://github.com/godotengine/godot/blob/master/core/os/memory.h">core/os/memory.h</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="core/pool_vector.h" refuri="https://github.com/godotengine/godot/blob/master/core/pool_vector.cpp">core/pool_vector.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="containers" names="containers 容器">
            <title>容器</title>
            <paragraph>Godot 还提供了一系列通用的容器:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>向量</paragraph>
                </list_item>
                <list_item>
                    <paragraph>List</paragraph>
                </list_item>
                <list_item>
                    <paragraph>设置</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Map</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>They aim to be as minimal as possible, as templates
                in C++ are often inlined and make the binary size much fatter, both in
                debug symbols and code. List, Set and Map can be iterated using
                pointers, like this:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">for(List&lt;int&gt;::Element *E=somelist.front();E;E=E-&gt;next()) {
    print_line(E-&gt;get()); // print the element
}</literal_block>
            <paragraph>Vector&lt;&gt;类还具有一些不错的功能:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>它会在写入时进行复制, 因此只要不对其进行修改, 制作拷贝就很容易.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>通过在引用计数器上使用原子操作, 来支持多线程.</paragraph>
                </list_item>
            </bullet_list>
            <section dupnames="references:" ids="id2" names="参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/templates/vector.h" refuri="https://github.com/godotengine/godot/blob/master/core/templates/vector.h">core/templates/vector.h</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="core/templates/list.h" refuri="https://github.com/godotengine/godot/blob/master/core/templates/list.h">core/templates/list.h</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="core/templates/set.h" refuri="https://github.com/godotengine/godot/blob/master/core/templates/hash_set.h">core/templates/set.h</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="core/templates/map.h" refuri="https://github.com/godotengine/godot/blob/master/core/templates/hash_map.h">core/templates/map.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="string" names="string 字符串">
            <title>字符串</title>
            <paragraph>Godot 还提供了一个字符串类 String.Godot还提供了String类. 此类具有大量功能, 在所有函数(如大小写操作)和utf8解析/提取中均提供全面的Unicode支持, 以及提供用于转换和可视化的帮助函数.</paragraph>
            <section dupnames="references:" ids="id3" names="参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/string/ustring.h" refuri="https://github.com/godotengine/godot/blob/master/core/string/ustring.h">core/string/ustring.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="stringname" names="stringname">
            <title>StringName</title>
            <paragraph>StringName（字符串名称）和 String（字符串）类似，但它们是唯一的。从字符串创建 StringName 会为所有相等的字符串产生唯一的内部指针。StringNames 对于将字符串用作标识符非常有用，因为比较它们基本上是在比较指针。</paragraph>
            <paragraph>创建一个字符串名称(尤其是一个新的) 是慢的, 但比较它们是快的.</paragraph>
            <section dupnames="references:" ids="id4" names="参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/string/string_name.h" refuri="https://github.com/godotengine/godot/blob/master/core/string/string_name.h">core/string/string_name.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="math-types" names="math\ types 数学类型">
            <title>数学类型</title>
            <paragraph>在core/math目录中, 有几种线性代数常用的类型.</paragraph>
            <section dupnames="references:" ids="id5" names="参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/math" refuri="https://github.com/godotengine/godot/tree/master/core/math">core/math</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="nodepath" names="nodepath 节点路径">
            <title>节点路径</title>
            <paragraph>这是一种特殊的数据类型, 用于在场景树中存储路径并快速引用它们.</paragraph>
            <section dupnames="references:" ids="id6" names="参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/string/node_path.h" refuri="https://github.com/godotengine/godot/blob/master/core/string/node_path.h">core/string/node_path.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="rid" names="rid">
            <title>RID</title>
            <paragraph>RID是资源ID. 服务使用这些来引用存储在其中的数据.RID是不透明的, 这意味着它们引用的数据不能直接访问.RID是唯一的, 甚至对于不同类型的引用数据也是如此.</paragraph>
            <section dupnames="references:" ids="id7" names="参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/templates/rid.h" refuri="https://github.com/godotengine/godot/blob/master/core/templates/rid.h">core/templates/rid.h</reference></paragraph>
                    </list_item>
                </bullet_list>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
