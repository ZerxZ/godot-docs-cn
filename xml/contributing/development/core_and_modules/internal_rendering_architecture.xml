<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/contributing/development/core_and_modules/internal_rendering_architecture.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-internal-rendering-architecture"></target>
    <section ids="internal-rendering-architecture doc-internal-rendering-architecture" names="internal\ rendering\ architecture 内部渲染架构 doc_internal_rendering_architecture">
        <title>内部渲染架构</title>
        <paragraph>这个页面是对 Godot 4 内部渲染器设计的高阶概述。不适用于旧版本的 Godot。</paragraph>
        <paragraph>这个页面的目标是记述最符合 <reference internal="True" refuri="../best_practices_for_engine_contributors#doc-best-practices-for-engine-contributors"><inline classes="std std-ref">Godot 设计理念</inline></reference>的设计决策，为新的渲染贡献者提供入手点。</paragraph>
        <paragraph>如果你有关于内部渲染的问题在此未得到解答，欢迎在 <reference name="Godot 贡献者聊天" refuri="https://chat.godotengine.org/channel/rendering">Godot 贡献者聊天</reference>的 <literal>#rendering</literal> 频道中进行提问。</paragraph>
        <note>
            <paragraph>如果你在理解这个页面上的概念时遇到了困难，建议先过一遍 <reference name="LearnOpenGL" refuri="https://learnopengl.com/">LearnOpenGL</reference> 等 OpenGL 教程。</paragraph>
            <paragraph>要想高效使用现代低阶 API（Vulkan/Direct3D 12）需要具备中等水平的更高阶 API（OpenGL/Direct3D 11）知识。值得庆幸的是，贡献者很少需要直接使用底层 API。Godot 的渲染器完全基于 OpenGL 和 RenderingDevice，后者是我们对 Vulkan/Direct3D 12 的抽象。</paragraph>
        </note>
        <target refid="doc-internal-rendering-architecture-methods"></target>
        <section ids="rendering-methods doc-internal-rendering-architecture-methods" names="rendering\ methods 渲染方法 doc_internal_rendering_architecture_methods">
            <title>渲染方法</title>
            <section ids="forward" names="forward+">
                <title>Forward+</title>
                <paragraph>这是一种前向渲染器，使用<emphasis>集群</emphasis>方法实现光照。</paragraph>
                <paragraph>集群光照使用计算着色器将灯光按照 3D 视锥栅格进行分组。然后在渲染时，像素就能够查询影响某个栅格单元的有哪些灯光，仅对影响该像素的灯光进行光照计算。</paragraph>
                <paragraph>这种方法能够大幅提升在桌面硬件上的渲染性能，但是在移动端会略为低效。</paragraph>
            </section>
            <section ids="forward-mobile" names="forward\ mobile forward\ 移动">
                <title>Forward 移动</title>
                <paragraph>这是使用传统单阶段光照方法的向前渲染器。</paragraph>
                <paragraph>针对移动平台设计，但是也能够在桌面平台运行。这种渲染方法针对移动 GPU 进行了优化。移动 GPU 的架构与桌面 GPU 有很大的区别，因为需要考虑电池使用、散热、读写数据时的总体带宽限制等约束。对计算着色器的支持也非常有限，甚至完全不支持。因此，移动渲染器单纯使用基于光栅的着色器（片段/顶点）。</paragraph>
                <paragraph>与桌面 GPU 不同，移动 GPU 执行的是<emphasis>基于图块的渲染</emphasis>。整个图像不是作为整体渲染的，而是会细分为较小的图块，适合放置到移动 GPU 更快的内部存储中。图块单独渲染后就会写入到目标纹理上。图形驱动会自动进行这一步操作。</paragraph>
                <paragraph>问题在于，这种做法会在我们的传统方法中造成瓶颈。对于桌面渲染，我们会先渲染所有不透明的几何体，然后处理背景，再处理透明的几何体，最后进行后期处理。每个步骤都需要将当前的结果读进图块内存，执行对应的运算后再写出。我们需要等待所有图块都完成后才能继续下一个阶段。</paragraph>
                <paragraph>The first important change in the mobile renderer is that the mobile renderer
                    does not use the RGBA16F texture formats that the desktop renderer does.
                    Instead, it is using an R10G10B10A2 UNORM texture format. This halves the bandwidth
                    required and has further improvements as mobile hardware often further optimizes
                    for 32-bit formats. The tradeoff is that the mobile renderer has limited HDR
                    capabilities due to the reduced precision and maximum values in the color data.</paragraph>
                <paragraph>第二个重要更改就是尽可能使用子阶段（sub-pass）。子阶段能够按照图块来执行渲染步骤，节省每个渲染阶段之间读写图块带来的开销。使用子阶段带来的限制是无法读取相邻像素，因为我们只能针对单一图块进行处理。</paragraph>
                <paragraph>子阶段的这一限制导致我们无法高效实现辉光、景深等特性。类似地，如果需要读取屏幕纹理或者深度纹理，我们就必须将渲染结果完全写出，限制对子阶段的使用。启用这种特性时，会混用子阶段和正常阶段，因此会带来明显的性能损失。</paragraph>
                <paragraph>在桌面平台，使用子阶段对性能不会有任何影响。但对于简单的场景而言，这种渲染方法仍然比集群 Forward 要高效，因为复杂度和带宽占用都相对较低。这种情况在低端 GPU、集成显卡、VR 应用中尤为明显。</paragraph>
                <paragraph>由于关注点在于低端设备，这种渲染方法并不提供 SDFGI、<reference internal="True" refuri="../../../tutorials/3d/volumetric_fog#doc-volumetric-fog"><inline classes="std std-ref">体积雾和雾体积</inline></reference>等高端渲染特性。部分后期处理效果也不可用。</paragraph>
                <target refid="doc-internal-rendering-architecture-compatibility"></target>
            </section>
            <section ids="compatibility doc-internal-rendering-architecture-compatibility" names="compatibility 兼容 doc_internal_rendering_architecture_compatibility">
                <title>兼容</title>
                <note>
                    <paragraph>这是使用 OpenGL 驱动时唯一可用的渲染方法。这种渲染方法在使用 Vulkan 和 Direct3D 12 时不可用。</paragraph>
                </note>
                <paragraph>这是传统的（非集群）向前渲染器，针对的是不支持 Vulkan 的老旧 GPU，但在较新的硬件上仍然能够非常高效地工作。确切地说，这种渲染器针对较旧、较低端的移动设备进行了优化。不过，很多优化也适用于较旧、较低端的桌面设备，因此也是不错的选择。</paragraph>
                <paragraph>与“移动”渲染器类似，“兼容”渲染器在进行 3D 渲染时使用的也是 R10G10B10A2 UNORM 纹理。与移动渲染器不同的是，颜色都经过了色调映射，以 sRGB 格式存储，因此不支持 HDR。这样就不需要再执行色调映射阶段，能够使用低位纹理，不会产生明显的条带。</paragraph>
                <paragraph>“兼容”渲染器在绘制带光照的对象时使用的传统的单阶段向前方法，但是带阴影的灯光会使用多阶段方法。确切地说，第一个阶段能够绘制多个不带阴影的灯光以及一个带阴影的 DirectionalLight3D。后续的各个阶段中，最多只能分别绘制一个带阴影的 OmniLight3D、 SpotLight3D、 DirectionalLight3D。带阴影的灯光对场景的影响与不带阴影的灯光不同，因为光照的混合使用的是 sRGB 空间而不是线性空间。这种区别会影响场景的外观，针对“兼容”渲染器设计场景时需要谨记于心。</paragraph>
                <paragraph>由于关注点在于低端设备，这种渲染方法并不提供高端渲染特性（与 Forward 移动相比更少）。大多数后期处理效果不可用。</paragraph>
            </section>
            <section ids="why-not-deferred-rendering" names="why\ not\ deferred\ rendering? 为什么不使用延迟渲染？">
                <title>为什么不使用延迟渲染？</title>
                <paragraph>向前渲染通常能够在性能和灵活性之间达到更好的平衡，尤其是在灯光使用了集群方法的情况下。延迟渲染虽然在某些情况下更快，但是灵活性较低、使用 MSAA 需要特殊处理。MSAA 能够为非写实画风的游戏带来很大提升，因此我们选择在 Godot 4 使用向前渲染（Godot 3 也一样）。</paragraph>
                <paragraph>话虽如此，向前渲染器中<emphasis>确实</emphasis>有一部分是使用延迟方法执行的，以便在可能的情况下进行一些优化。这一点尤其适用于 VoxelGI 和 SDFGI。</paragraph>
                <paragraph>未来可能会开发集群延迟渲染器。这种渲染器可以在对性能的要求大于灵活性的场合使用。</paragraph>
            </section>
        </section>
        <section ids="rendering-drivers" names="rendering\ drivers 渲染驱动">
            <title>渲染驱动</title>
            <paragraph>Godot 4 支持以下图形 API：</paragraph>
            <section ids="vulkan" names="vulkan">
                <title>Vulkan</title>
                <paragraph>这是 Godot 4 的主要驱动，大部分开发集中在这个驱动上。</paragraph>
                <paragraph>Vulkan 1.0 是必要的基准，Vulkan 1.1 和 1.2 的特性会有可用时使用。我们使用 <reference name="volk" refuri="https://github.com/zeux/volk">volk</reference> 作为 Vulkan 加载器，使用 <reference name="Vulkan Memory Allocator" refuri="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">Vulkan Memory Allocator</reference> 进行内存管理。</paragraph>
                <paragraph>使用 Vulkan 驱动时支持 Forward+ 和移动 <reference internal="True" refid="doc-internal-rendering-architecture-methods"><inline classes="std std-ref">渲染方法</inline></reference>。</paragraph>
                <paragraph><strong>Vulkan 上下文的创建：</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="drivers/vulkan/vulkan_context.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/drivers/vulkan/vulkan_context.cpp">drivers/vulkan/vulkan_context.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Direct3D 12 context creation:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="drivers/d3d12/d3d12_context.cpp" refuri="https://github.com/godotengine/godot/blob/master/drivers/d3d12/d3d12_context.cpp">drivers/d3d12/d3d12_context.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="direct3d-12" names="direct3d\ 12">
                <title>Direct3D 12</title>
                <paragraph>与 Vulkan 类似，Direct3D 12 驱动仅支持现代平台，是针对 Windows 和 Xbox 设计的（鉴于 Xbox 上无法直接使用 Vulkan）。</paragraph>
                <paragraph>使用 Direct3D 12 时支持 Forward+ 和移动 <reference internal="True" refid="doc-internal-rendering-architecture-methods"><inline classes="std std-ref">渲染方法</inline></reference>。</paragraph>
                <paragraph><reference internal="True" refid="doc-internal-rendering-architecture-core-shaders"><inline classes="std std-ref">核心着色器</inline></reference> are shared with the
                    Vulkan renderer. Shaders are transpiled from
                    <abbreviation explanation="Standard Portable Intermediate Representation">SPIR-V</abbreviation> to
                    <abbreviation explanation="DirectX Intermediate Language">DXIL</abbreviation> using
                    Mesa NIR (<reference name="more information" refuri="https://godotengine.org/article/d3d12-adventures-in-shaderland/">more information</reference>).</paragraph>
                <paragraph><strong>This driver is still experimental and only available in Godot 4.3 and later.</strong>
                    While Direct3D 12 allows supporting Direct3D-exclusive features on Windows 11 such
                    as windowed optimizations and Auto HDR, Vulkan is still recommended for most projects.
                    See the <reference name="pull request that introduced Direct3D 12 support" refuri="https://github.com/godotengine/godot/pull/70315">pull request that introduced Direct3D 12 support</reference>
                    for more information.</paragraph>
            </section>
            <section ids="metal" names="metal">
                <title>Metal</title>
                <paragraph>Godot supports Metal rendering via <reference name="MoltenVK" refuri="https://github.com/KhronosGroup/MoltenVK">MoltenVK</reference>,
                    as macOS and iOS do not support Vulkan natively.
                    This is done automatically when specifying the Vulkan driver in the Project Settings.</paragraph>
                <paragraph>MoltenVK makes driver maintenance easy at the cost of some performance overhead.
                    Also, MoltenVK has several limitations that a native Metal driver implementation
                    wouldn't have. Both the clustered and mobile
                    <reference internal="True" refid="doc-internal-rendering-architecture-methods"><inline classes="std std-ref">渲染方法</inline></reference> can be used with a Metal
                    backend via MoltenVK.</paragraph>
                <paragraph>A native Metal driver is planned in the future for better performance and
                    compatibility.</paragraph>
            </section>
            <section ids="opengl" names="opengl">
                <title>OpenGL</title>
                <paragraph>这个驱动使用 OpenGL ES 3.0，针对的是不支持 Vulkan 的旧有设备以及低端设备。桌面平台运行该驱动时使用的是 OpenGL 3.3 Core Profile，因为桌面平台的大部分图形驱动不支持 OpenGL ES。Web 导出使用的是 WebGL 2.0。</paragraph>
                <paragraph>It is possible to use the use of OpenGL ES 3.0 directly on desktop platforms
                    using the <literal>--rendering-driver opengl3_es</literal> command line argument, although this
                    will only work on graphics drivers that feature native OpenGL ES support (such
                    as Mesa).</paragraph>
                <paragraph>使用 OpenGL 驱动是只能使用 <reference internal="True" refid="doc-internal-rendering-architecture-compatibility"><inline classes="std std-ref">兼容</inline></reference> 渲染方法。</paragraph>
                <paragraph><reference internal="True" refid="doc-internal-rendering-architecture-core-shaders"><inline classes="std std-ref">核心着色器</inline></reference> 与 Vulkan 渲染器完全不同。</paragraph>
                <paragraph>Many advanced features are not supported with this driver, as it targets low-end
                    devices first and foremost.</paragraph>
            </section>
            <section ids="summary-of-rendering-drivers-methods" names="summary\ of\ rendering\ drivers/methods 渲染驱动/方法总结">
                <title>渲染驱动/方法总结</title>
                <paragraph>目前可用的渲染 API + 渲染方法组合如下：</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>Vulkan + Forward+</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Vulkan + Forward 移动</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Direct3D 12 + Forward+</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Direct3D 12 + Forward 移动</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Metal + Forward+（通过 MoltenVK）</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Metal + Forward 移动（通过 MoltenVK）</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>OpenGL + 兼容</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Each combination has its own limitations and performance characteristics. Make
                    sure to test your changes on all rendering methods if possible before opening a
                    pull request.</paragraph>
            </section>
        </section>
        <section ids="renderingdevice-abstraction" names="renderingdevice\ abstraction renderingdevice\ 抽象">
            <title>RenderingDevice 抽象</title>
            <note>
                <paragraph>OpenGL 驱动不使用 RenderingDevice 抽象。</paragraph>
            </note>
            <paragraph>To make the complexity of modern low-level graphics APIs more manageable,
                Godot uses its own abstraction called RenderingDevice.</paragraph>
            <paragraph>This means that when writing code for modern rendering methods, you don't
                actually use the Vulkan or Direct3D 12 APIs directly. While this is still
                lower-level than an API like OpenGL, this makes working on the renderer easier,
                as RenderingDevice will abstract many API-specific quirks for you. The
                RenderingDevice presents a similar level of abstraction as Metal or WebGPU.</paragraph>
            <paragraph><strong>Vulkan RenderingDevice 实现：</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="drivers/vulkan/rendering_device_driver_vulkan.cpp" refuri="https://github.com/godotengine/godot/blob/master/drivers/vulkan/rendering_device_driver_vulkan.cpp">drivers/vulkan/rendering_device_driver_vulkan.cpp</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>Direct3D 12 RenderingDevice implementation:</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="drivers/d3d12/rendering_device_driver_d3d12.cpp" refuri="https://github.com/godotengine/godot/blob/master/drivers/d3d12/rendering_device_driver_d3d12.cpp">drivers/d3d12/rendering_device_driver_d3d12.cpp</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="core-rendering-classes-architecture" names="core\ rendering\ classes\ architecture 核心渲染类架构">
            <title>核心渲染类架构</title>
            <paragraph>This diagram represents the structure of rendering classes in Godot, including the RenderingDevice abstraction:</paragraph>
            <image candidates="{'*': 'contributing/development/core_and_modules/img/rendering_architecture_diagram.webp'}" uri="contributing/development/core_and_modules/img/rendering_architecture_diagram.webp"></image>
            <paragraph><reference name="View at full size" refuri="https://raw.githubusercontent.com/godotengine/godot-docs/master/contributing/development/core_and_modules/img/rendering_architecture_diagram.webp">View at full size</reference></paragraph>
            <target refid="doc-internal-rendering-architecture-core-shaders"></target>
        </section>
        <section ids="core-shaders doc-internal-rendering-architecture-core-shaders" names="core\ shaders 核心着色器 doc_internal_rendering_architecture_core_shaders">
            <title>核心着色器</title>
            <paragraph>While shaders in Godot projects are written using a
                <reference internal="True" refuri="../../../tutorials/shaders/shader_reference/shading_language#doc-shading-language"><inline classes="std std-ref">custom language inspired by GLSL</inline></reference>, core shaders are
                written directly in GLSL.</paragraph>
            <paragraph>These core shaders are embedded in the editor and export template binaries at
                compile-time. To see any changes you've made to those GLSL shaders, you need to
                recompile the editor or export template binary.</paragraph>
            <paragraph>Some material features such as height mapping, refraction and proximity fade are
                not part of core shaders, and are performed in the default BaseMaterial3D using
                the Godot shader language instead (not GLSL). This is done by procedurally
                generating the required shader code depending on the features enabled in the
                material.</paragraph>
            <paragraph>By convention, shader files with <literal>_inc</literal> in their name are included in other
                GLSL files for better code reuse. Standard GLSL preprocessing is used to achieve
                this.</paragraph>
            <warning>
                <paragraph>Core material shaders will be used by every material in the scene – both
                    with the default BaseMaterial3D and custom shaders. As a result, these
                    shaders must be kept as simple as possible to avoid performance issues and
                    ensure shader compilation doesn't become too slow.</paragraph>
                <paragraph>If you use <literal>if</literal> branching in a shader, performance may decrease as
                    <abbreviation explanation="Vector General-Purpose Register">VGPR</abbreviation> usage will increase in the
                    shader. This happens even if all pixels evaluate to <literal>true</literal> or <literal>false</literal> in
                    a given frame.</paragraph>
                <paragraph>If you use <literal>#if</literal> preprocessor branching, the number of required shader
                    versions will increase in the scene. In a worst-case scenario, adding a
                    single boolean <literal>#define</literal> can <emphasis>double</emphasis> the number of shader versions that
                    may need to be compiled in a given scene. In some cases, Vulkan
                    specialization constants can be used as a faster (but more limited)
                    alternative.</paragraph>
                <paragraph>This means there is a high barrier to adding new built-in material features
                    in Godot, both in the core shaders and BaseMaterial3D. While BaseMaterial3D
                    can make use of dynamic code generation to only include the shader code if
                    the feature is enabled, it'll still require generating more shader versions
                    when these features are used in a project. This can make shader compilation
                    stutter more noticeable in complex 3D scenes.</paragraph>
                <paragraph>See
                    <reference name="The Shader Permutation Problem" refuri="https://therealmjp.github.io/posts/shader-permutations-part1/">The Shader Permutation Problem</reference>
                    and
                    <reference name="Branching on a GPU" refuri="https://medium.com/@jasonbooth_86226/branching-on-a-gpu-18bfc83694f2">Branching on a GPU</reference>
                    blog posts for more information.</paragraph>
            </warning>
            <paragraph><strong>核心 GLSL 材质着色器：</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>Forward+: <reference name="servers/rendering/renderer_rd/shaders/forward_clustered/scene_forward_clustered.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/forward_clustered/scene_forward_clustered.glsl">servers/rendering/renderer_rd/shaders/forward_clustered/scene_forward_clustered.glsl</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph>Forward Mobile: <reference name="servers/rendering/renderer_rd/shaders/forward_mobile/scene_forward_mobile.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/forward_mobile/scene_forward_mobile.glsl">servers/rendering/renderer_rd/shaders/forward_mobile/scene_forward_mobile.glsl</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph>Compatibility: <reference name="drivers/gles3/shaders/scene.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/drivers/gles3/shaders/scene.glsl">drivers/gles3/shaders/scene.glsl</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>材质着色器生成：</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="scene/resources/material.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/resources/material.cpp">scene/resources/material.cpp</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>Forward+ 和 Forward Mobile 渲染方法的其他 GLSL 着色器：</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="servers/rendering/renderer_rd/shaders/" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/">servers/rendering/renderer_rd/shaders/</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="modules/lightmapper_rd/" refuri="https://github.com/godotengine/godot/blob/4.2/modules/lightmapper_rd">modules/lightmapper_rd/</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>Compatibility 渲染方法的其他 GLSL 着色器：</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="drivers/gles3/shaders/" refuri="https://github.com/godotengine/godot/blob/4.2/drivers/gles3/shaders/">drivers/gles3/shaders/</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="d-and-3d-rendering-separation" names="2d\ and\ 3d\ rendering\ separation 2d\ 与\ 3d\ 渲染的拆分">
            <title>2D 与 3D 渲染的拆分</title>
            <note>
                <paragraph>The following is only applicable in the Forward+ and Forward Mobile
                    rendering methods, not in Compatibility. Multiple Viewports can be used to
                    emulate this when using the Compatibility backend, or to perform 2D
                    resolution scaling.</paragraph>
            </note>
            <paragraph>2D and 3D are rendered to separate buffers, as 2D rendering in Godot is performed
                in <abbreviation explanation="Low Dynamic Range">LDR</abbreviation> sRGB-space while 3D rendering uses
                <abbreviation explanation="High Dynamic Range">HDR</abbreviation> linear space.</paragraph>
            <paragraph>The color format used for 2D rendering is RGB8 (RGBA8 if the <strong>Transparent</strong>
                property on the Viewport is enabled). 3D rendering uses a 24-bit unsigned
                normalized integer depth buffer, or 32-bit signed floating-point if a 24-bit
                depth buffer is not supported by the hardware. 2D rendering does not use a depth
                buffer.</paragraph>
            <paragraph>3D resolution scaling is performed differently depending on whether bilinear or
                FSR 1.0 scaling is used. When bilinear scaling is used, no special upscaling
                shader is run. Instead, the viewport's texture is stretched and displayed with a
                linear sampler (which makes the filtering happen directly on the hardware). This
                allows maximizing the performance of bilinear 3D scaling.</paragraph>
            <paragraph>The <literal>configure()</literal> function in RenderSceneBuffersRD reallocates the 2D/3D
                buffers when the resolution or scaling changes.</paragraph>
            <paragraph>Dynamic resolution scaling isn't supported yet, but is planned in a future Godot
                release.</paragraph>
            <paragraph><strong>2D and 3D rendering buffer configuration C++ code:</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="servers/rendering/renderer_rd/storage_rd/render_scene_buffers_rd.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/storage_rd/render_scene_buffers_rd.cpp">servers/rendering/renderer_rd/storage_rd/render_scene_buffers_rd.cpp</reference></paragraph>
                </list_item>
            </bullet_list>
            <paragraph><strong>FSR 1.0:</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="servers/rendering/renderer_rd/effects/fsr.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/effects/fsr.cpp">servers/rendering/renderer_rd/effects/fsr.cpp</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference name="thirdparty/amd-fsr/" refuri="https://github.com/godotengine/godot/tree/master/thirdparty/amd-fsr">thirdparty/amd-fsr/</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="d-rendering-techniques" names="2d\ rendering\ techniques 2d\ 渲染技术">
            <title>2D 渲染技术</title>
            <paragraph>2D light rendering is performed in a single pass to allow for better performance
                with large amounts of lights.</paragraph>
            <paragraph>The Forward+ and Mobile rendering methods don't feature 2D batching yet, but
                it's planned for a future release.</paragraph>
            <paragraph>The Compatibility backend features 2D batching to improve performance, which is
                especially noticeable with lots of text on screen.</paragraph>
            <paragraph>MSAA can be enabled in 2D to provide "automatic" line and polygon antialiasing,
                but FXAA does not affect 2D rendering as it's calculated before 2D rendering
                begins. Godot's 2D drawing methods such as the Line2D node or some CanvasItem
                <literal>draw_*()</literal> methods provide their own way of antialiasing based on triangle
                strips and vertex colors, which don't require MSAA to work.</paragraph>
            <paragraph>A 2D signed distance field representing LightOccluder2D nodes in the viewport is
                automatically generated if a user shader requests it. This can be used for
                various effects in custom shaders, such as 2D global illumination. It is also
                used to calculate particle collisions in 2D.</paragraph>
            <paragraph><strong>2D SDF 生成 GLSL 着色器：</strong></paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph><reference name="servers/rendering/renderer_rd/shaders/canvas_sdf.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/canvas_sdf.glsl">servers/rendering/renderer_rd/shaders/canvas_sdf.glsl</reference></paragraph>
                </list_item>
            </bullet_list>
        </section>
        <section ids="id1" names="3d\ rendering\ techniques 3d\ 渲染技术">
            <title>3D 渲染技术</title>
            <section ids="batching-and-instancing" names="batching\ and\ instancing 分批和实例">
                <title>分批和实例</title>
                <paragraph>In the Forward+ backend, Vulkan instancing is used to group rendering
                    of identical objects for performance. This is not as fast as static mesh
                    merging, but it still allows instances to be culled individually.</paragraph>
            </section>
            <section ids="light-decal-and-reflection-probe-rendering" names="light,\ decal\ and\ reflection\ probe\ rendering 精灵、多边形和线条渲染">
                <title>精灵、多边形和线条渲染</title>
                <note>
                    <paragraph>Reflection probe and decal rendering are currently not available in the
                        Compatibility backend.</paragraph>
                </note>
                <paragraph>As its name implies, the Forward+ backend uses clustered lighting. This
                    allows using as many lights as you want; performance largely depends on screen
                    coverage. Shadow-less lights can be almost free if they don't occupy much space
                    on screen.</paragraph>
                <paragraph>All rendering methods also support rendering up to 8 directional lights at the
                    same time (albeit with lower shadow quality when more than one light has shadows
                    enabled).</paragraph>
                <paragraph>The Forward Mobile backend uses a single-pass lighting approach, with a
                    limitation of 8 OmniLights + 8 SpotLights affecting each Mesh <emphasis>resource</emphasis> (plus a
                    limitation of 256 OmniLights + 256 SpotLights in the camera view). These limits
                    are hardcoded and can't be adjusted in the project settings.</paragraph>
                <paragraph>The Compatibility backend uses a hybrid single-pass + multi-pass lighting
                    approach. Lights without shadows are rendered in a single pass. Lights with
                    shadows are rendered in multiple passes. This is required for performance
                    reasons on mobile devices. As a result, performance does not scale well with
                    many shadow-casting lights. It is recommended to only have a handful of lights
                    with shadows in the camera frustum at a time and for those lights to be spread
                    apart so that each object is only touched by 1 or 2 shadowed lights at a time.
                    The maximum number of lights visible at once can be adjusted in the project
                    settings.</paragraph>
                <paragraph>In all 3 methods, lights without shadows are much cheaper than lights with
                    shadows. To improve performance, lights are only updated when the light is
                    modified or when objects in its radius are modified. Godot currently doesn't
                    separate static shadow rendering from dynamic shadow rendering, but this is
                    planned in a future release.</paragraph>
                <paragraph>Clustering is also used for reflection probes and decal rendering in the
                    Forward+ backend.</paragraph>
            </section>
            <section ids="shadow-mapping" names="shadow\ mapping 阴影贴图">
                <title>阴影贴图</title>
                <paragraph>Both Forward+ and Forward Mobile methods use
                    <abbreviation explanation="Percentage Closer Filtering">PCF</abbreviation> to filter shadow maps and create a
                    soft penumbra. Instead of using a fixed PCF pattern, these methods use a vogel
                    disk pattern which allows for changing the number of samples and smoothly
                    changing the quality.</paragraph>
                <paragraph>Godot also supports percentage-closer soft shadows (PCSS) for more realistic
                    shadow penumbra rendering. PCSS shadows are limited to the Forward+
                    backend as they're too demanding to be usable in the Forward Mobile backend.
                    PCSS also uses a vogel-disk shaped kernel.</paragraph>
                <paragraph>Additionally, both shadow-mapping techniques rotate the kernel on a per-pixel
                    basis to help soften under-sampling artifacts.</paragraph>
                <paragraph>The Compatibility backend doesn't support shadow mapping for any light types yet.</paragraph>
            </section>
            <section ids="temporal-antialiasing" names="temporal\ antialiasing">
                <title>Temporal antialiasing</title>
                <note>
                    <paragraph>Only available in the Forward+ backend, not the Forward Mobile or
                        Compatibility methods.</paragraph>
                </note>
                <paragraph>Godot uses a custom TAA implementation based on the old TAA implementation from
                    <reference name="Spartan Engine" refuri="https://github.com/PanosK92/SpartanEngine">Spartan Engine</reference>.</paragraph>
                <paragraph>Temporal antialiasing requires motion vectors to work. If motion vectors
                    are not correctly generated, ghosting will occur when the camera or objects move.</paragraph>
                <paragraph>Motion vectors are generated on the GPU in the main material shader. This is
                    done by running the vertex shader corresponding to the previous rendered frame
                    (with the previous camera transform) in addition to the vertex shader for the
                    current rendered frame, then storing the difference between them in a color buffer.</paragraph>
                <paragraph>Alternatively, FSR 2.2 can be used as an upscaling solution that also provides
                    its own temporal antialiasing algorithm. FSR 2.2 is implemented on top of the
                    RenderingDevice abstraction as opposed to using AMD's reference code directly.</paragraph>
                <paragraph><strong>TAA resolve:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/taa_resolve.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/taa_resolve.glsl">servers/rendering/renderer_rd/shaders/effects/taa_resolve.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>FSR 2.2:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/effects/fsr2.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/effects/fsr2.cpp">servers/rendering/renderer_rd/effects/fsr2.cpp</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/fsr2/" refuri="https://github.com/godotengine/godot/tree/master/servers/rendering/renderer_rd/shaders/effects/fsr2">servers/rendering/renderer_rd/shaders/effects/fsr2/</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="thirdparty/amd-fsr2/" refuri="https://github.com/godotengine/godot/tree/master/thirdparty/amd-fsr2">thirdparty/amd-fsr2/</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="global-illumination" names="global\ illumination 全局光照">
                <title>全局光照</title>
                <note>
                    <paragraph>VoxelGI and SDFGI are only available in the Forward+ backend, not the
                        Forward Mobile or Compatibility methods.</paragraph>
                    <paragraph>LightmapGI <emphasis>baking</emphasis> is only available in the Forward+ and Forward Mobile
                        methods, and can only be performed within the editor (not in an exported
                        project). LightmapGI <emphasis>rendering</emphasis> will eventually be supported by the
                        Compatibility backend.</paragraph>
                </note>
                <paragraph>Godot supports voxel-based GI (VoxelGI), signed distance field GI (SDFGI) and
                    lightmap baking and rendering (LightmapGI). These techniques can be used
                    simultaneously if desired.</paragraph>
                <paragraph>Lightmap baking happens on the GPU using Vulkan compute shaders. The GPU-based
                    lightmapper is implemented in the LightmapperRD class, which inherits from the
                    Lightmapper class. This allows for implementing additional lightmappers, paving
                    the way for a future port of the CPU-based lightmapper present in Godot 3.x.
                    This would allow baking lightmaps while using the Compatibility backend.</paragraph>
                <paragraph><strong>Core GI C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/environment/gi.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/environment/gi.cpp">servers/rendering/renderer_rd/environment/gi.cpp</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="scene/3d/voxel_gi.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/3d/voxel_gi.cpp">scene/3d/voxel_gi.cpp</reference> - VoxelGI node</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="editor/plugins/voxel_gi_editor_plugin.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/editor/plugins/voxel_gi_editor_plugin.cpp">editor/plugins/voxel_gi_editor_plugin.cpp</reference> - Editor UI for the VoxelGI node</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Core GI GLSL shaders:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/voxel_gi.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/voxel_gi.glsl">servers/rendering/renderer_rd/shaders/environment/voxel_gi.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/voxel_gi_debug.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/voxel_gi_debug.glsl">servers/rendering/renderer_rd/shaders/environment/voxel_gi_debug.glsl</reference> - VoxelGI debug draw mode</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/sdfgi_debug.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/sdfgi_debug.glsl">servers/rendering/renderer_rd/shaders/environment/sdfgi_debug.glsl</reference> - SDFGI Cascades debug draw mode</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/sdfgi_debug_probes.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/sdfgi_debug_probes.glsl">servers/rendering/renderer_rd/shaders/environment/sdfgi_debug_probes.glsl</reference> - SDFGI Probes debug draw mode</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/sdfgi_integrate.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/sdfgi_integrate.glsl">servers/rendering/renderer_rd/shaders/environment/sdfgi_integrate.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/sdfgi_preprocess.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/sdfgi_preprocess.glsl">servers/rendering/renderer_rd/shaders/environment/sdfgi_preprocess.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/sdfgi_direct_light.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/sdfgi_direct_light.glsl">servers/rendering/renderer_rd/shaders/environment/sdfgi_direct_light.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>光照贴图器 C++ 代码：</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="scene/3d/lightmap_gi.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/3d/lightmap_gi.cpp">scene/3d/lightmap_gi.cpp</reference> - LightmapGI node</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="editor/plugins/lightmap_gi_editor_plugin.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/editor/plugins/lightmap_gi_editor_plugin.cpp">editor/plugins/lightmap_gi_editor_plugin.cpp</reference> - Editor UI for the LightmapGI node</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="scene/3d/lightmapper.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/3d/lightmapper.cpp">scene/3d/lightmapper.cpp</reference> - Abstract class</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="modules/lightmapper_rd/lightmapper_rd.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/modules/lightmapper_rd/lightmapper_rd.cpp">modules/lightmapper_rd/lightmapper_rd.cpp</reference> - GPU-based lightmapper implementation</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>光照贴图器 GLSL 着色器：</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="modules/lightmapper_rd/lm_raster.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/modules/lightmapper_rd/lm_raster.glsl">modules/lightmapper_rd/lm_raster.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="modules/lightmapper_rd/lm_compute.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/modules/lightmapper_rd/lm_compute.glsl">modules/lightmapper_rd/lm_compute.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="modules/lightmapper_rd/lm_blendseams.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/modules/lightmapper_rd/lm_blendseams.glsl">modules/lightmapper_rd/lm_blendseams.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="depth-of-field" names="depth\ of\ field 景深">
                <title>景深</title>
                <note>
                    <paragraph>Only available in the Forward+ and Forward Mobile methods, not the
                        Compatibility backend.</paragraph>
                </note>
                <paragraph>The Forward+ and Forward Mobile methods use different approaches to
                    DOF rendering, with different visual results. This is done to best
                    match the performance characteristics of the target hardware. In Clustered
                    Forward, DOF is performed using a compute shader. In Forward Mobile, DOF is
                    performed using a fragment shader (raster).</paragraph>
                <paragraph>Box, hexagon and circle bokeh shapes are available (from fastest to slowest).
                    Depth of field can optionally be jittered every frame to improve its appearance
                    when temporal antialiasing is enabled.</paragraph>
                <paragraph><strong>Depth of field C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/effects/bokeh_dof.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/effects/bokeh_dof.cpp">servers/rendering/renderer_rd/effects/bokeh_dof.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Depth of field GLSL shader (compute - used for Forward+):</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/bokeh_dof.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/bokeh_dof.glsl">servers/rendering/renderer_rd/shaders/effects/bokeh_dof.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Depth of field GLSL shader (raster - used for Forward Mobile):</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/bokeh_dof_raster.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/bokeh_dof_raster.glsl">servers/rendering/renderer_rd/shaders/effects/bokeh_dof_raster.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="screen-space-effects-ssao-ssil-ssr-sss" names="screen-space\ effects\ (ssao,\ ssil,\ ssr,\ sss)">
                <title>Screen-space effects (SSAO, SSIL, SSR, SSS)</title>
                <note>
                    <paragraph>Only available in the Forward+ backend, not the Forward Mobile or
                        Compatibility methods.</paragraph>
                </note>
                <paragraph>The Forward+ backend supports screen-space ambient occlusion,
                    screen-space indirect lighting, screen-space reflections and subsurface scattering.</paragraph>
                <paragraph>SSAO uses an implementation derived from Intel's
                    <reference name="ASSAO" refuri="https://www.intel.com/content/www/us/en/developer/articles/technical/adaptive-screen-space-ambient-occlusion.html">ASSAO</reference>
                    (converted to Vulkan). SSIL is derived from SSAO to provide high-performance
                    indirect lighting.</paragraph>
                <paragraph>When both SSAO and SSIL are enabled, parts of SSAO and SSIL are shared to reduce
                    the performance impact.</paragraph>
                <paragraph>SSAO and SSIL are performed at half resolution by default to improve performance.
                    SSR is always performed at half resolution to improve performance.</paragraph>
                <paragraph><strong>屏幕空间效果 C++ 代码：</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/effects/ss_effects.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/effects/ss_effects.cpp">servers/rendering/renderer_rd/effects/ss_effects.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>屏幕空间环境光遮蔽 GLSL 着色器：</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssao.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssao.glsl">servers/rendering/renderer_rd/shaders/effects/ssao.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssao_blur.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssao_blur.glsl">servers/rendering/renderer_rd/shaders/effects/ssao_blur.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssao_interleave.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssao_interleave.glsl">servers/rendering/renderer_rd/shaders/effects/ssao_interleave.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssao_importance_map.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssao_importance_map.glsl">servers/rendering/renderer_rd/shaders/effects/ssao_importance_map.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>屏幕空间间接光照 GLSL 着色器：</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssil.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssil.glsl">servers/rendering/renderer_rd/shaders/effects/ssil.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssil_blur.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssil_blur.glsl">servers/rendering/renderer_rd/shaders/effects/ssil_blur.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssil_interleave.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssil_interleave.glsl">servers/rendering/renderer_rd/shaders/effects/ssil_interleave.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/ssil_importance_map.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/ssil_importance_map.glsl">servers/rendering/renderer_rd/shaders/effects/ssil_importance_map.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>屏幕空间反射 GLSL 着色器：</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/screen_space_reflection.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/screen_space_reflection.glsl">servers/rendering/renderer_rd/shaders/effects/screen_space_reflection.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/screen_space_reflection_scale.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/screen_space_reflection_scale.glsl">servers/rendering/renderer_rd/shaders/effects/screen_space_reflection_scale.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/screen_space_reflection_filter.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/screen_space_reflection_filter.glsl">servers/rendering/renderer_rd/shaders/effects/screen_space_reflection_filter.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>次表面散射 GLSL：</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/effects/subsurface_scattering.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/effects/subsurface_scattering.glsl">servers/rendering/renderer_rd/shaders/effects/subsurface_scattering.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="sky-rendering" names="sky\ rendering 天空渲染">
                <title>天空渲染</title>
                <seealso>
                    <paragraph><reference internal="True" refuri="../../../tutorials/shaders/shader_reference/sky_shader#doc-sky-shader"><inline classes="std std-ref">天空着色器</inline></reference></paragraph>
                </seealso>
                <paragraph>Godot supports using shaders to render the sky background. The radiance map
                    (which is used to provide ambient light and reflections for PBR materials) is
                    automatically updated based on the sky shader.</paragraph>
                <paragraph>The SkyMaterial resources such as ProceduralSkyMaterial, PhysicalSkyMaterial and
                    PanoramaSkyMaterial generate a built-in shader for sky rendering. This is
                    similar to what BaseMaterial3D provides for 3D scene materials.</paragraph>
                <paragraph>A detailed technical implementation can be found in the
                    <reference name="Custom sky shaders in Godot 4.0" refuri="https://godotengine.org/article/custom-sky-shaders-godot-4-0">Custom sky shaders in Godot 4.0</reference>
                    article.</paragraph>
                <paragraph><strong>天空渲染 C++ 代码：</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/environment/sky.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/environment/sky.cpp">servers/rendering/renderer_rd/environment/sky.cpp</reference> - Sky rendering</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="scene/resources/sky.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/resources/sky.cpp">scene/resources/sky.cpp</reference> - Sky resource (not to be confused with sky rendering)</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="scene/resources/sky_material.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/resources/sky_material.cpp">scene/resources/sky_material.cpp</reference> SkyMaterial resources (used in the Sky resource)</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>天空渲染 GLSL 着色器：</strong></paragraph>
            </section>
            <section ids="volumetric-fog" names="volumetric\ fog 体积雾">
                <title>体积雾</title>
                <note>
                    <paragraph>Only available in the Forward+ backend, not the Forward Mobile or
                        Compatibility methods.</paragraph>
                </note>
                <seealso>
                    <paragraph><reference internal="True" refuri="../../../tutorials/shaders/shader_reference/fog_shader#doc-fog-shader"><inline classes="std std-ref">雾着色器</inline></reference></paragraph>
                </seealso>
                <paragraph>Godot supports a frustum-aligned voxel (froxel) approach to volumetric fog
                    rendering. As opposed to a post-processing filter, this approach is more
                    general-purpose as it can work with any light type. Fog can also use shaders for
                    custom behavior, which allows animating the fog or using a 3D texture to
                    represent density.</paragraph>
                <paragraph>The FogMaterial resource generates a built-in shader for FogVolume nodes. This is
                    similar to what BaseMaterial3D provides for 3D scene materials.</paragraph>
                <paragraph>A detailed technical explanation can be found in the
                    <reference name="Fog Volumes arrive in Godot 4.0" refuri="https://godotengine.org/article/fog-volumes-arrive-in-godot-4">Fog Volumes arrive in Godot 4.0</reference>
                    article.</paragraph>
                <paragraph><strong>体积雾 C++ 代码：</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/environment/fog.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/environment/fog.cpp">servers/rendering/renderer_rd/environment/fog.cpp</reference> - General volumetric fog</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="scene/3d/fog_volume.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/3d/fog_volume.cpp">scene/3d/fog_volume.cpp</reference> - FogVolume node</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="scene/resources/fog_material.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/resources/fog_material.cpp">scene/resources/fog_material.cpp</reference> - FogMaterial resource (used by FogVolume)</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>体积雾 GLSL 着色器：</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/volumetric_fog.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/volumetric_fog.glsl">servers/rendering/renderer_rd/shaders/environment/volumetric_fog.glsl</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_rd/shaders/environment/volumetric_fog_process.glsl" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_rd/shaders/environment/volumetric_fog_process.glsl">servers/rendering/renderer_rd/shaders/environment/volumetric_fog_process.glsl</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="occlusion-culling" names="occlusion\ culling 遮挡剔除">
                <title>遮挡剔除</title>
                <paragraph>While modern GPUs can handle drawing a lot of triangles, the number of draw
                    calls in complex scenes can still be a bottleneck (even with Vulkan and Direct3D 12).</paragraph>
                <paragraph>Godot 4 supports occlusion culling to reduce overdraw (when the depth prepass
                    is disabled) and reduce vertex throughput.
                    This is done by rasterizing a low-resolution buffer on the CPU using
                    <reference name="Embree" refuri="https://github.com/embree/embree">Embree</reference>. The buffer's resolution depends
                    on the number of CPU threads on the system, as this is done in parallel.
                    This buffer includes occluder shapes that were baked in the editor or created at
                    run-time.</paragraph>
                <paragraph>As complex occluders can introduce a lot of strain on the CPU, baked occluders
                    can be simplified automatically when generated in the editor.</paragraph>
                <paragraph>Godot's occlusion culling doesn't support dynamic occluders yet, but
                    OccluderInstance3D nodes can still have their visibility toggled or be moved.
                    However, this will be slow when updating complex occluders this way. Therefore,
                    updating occluders at run-time is best done only on simple occluder shapes such
                    as quads or cuboids.</paragraph>
                <paragraph>This CPU-based approach has a few advantages over other solutions, such as
                    portals and rooms or a GPU-based culling solution:</paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph>No manual setup required (but can be tweaked manually for best performance).</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>No frame delay, which is problematic in cutscenes during camera cuts or when
                            the camera moves fast behind a wall.</paragraph>
                    </list_item>
                    <list_item>
                        <paragraph>Works the same on all rendering drivers and methods, with no unpredictable
                            behavior depending on the driver or GPU hardware.</paragraph>
                    </list_item>
                </bullet_list>
                <paragraph>Occlusion culling is performed by registering occluder meshes, which is done
                    using OccluderInstance3D <emphasis>nodes</emphasis> (which themselves use Occluder3D <emphasis>resources</emphasis>).
                    RenderingServer then performs occlusion culling by calling Embree in
                    RendererSceneOcclusionCull.</paragraph>
                <paragraph><strong>遮挡剔除 C++ 代码：</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="scene/3d/occluder_instance_3d.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/3d/occluder_instance_3d.cpp">scene/3d/occluder_instance_3d.cpp</reference></paragraph>
                    </list_item>
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_scene_occlusion_cull.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_scene_occlusion_cull.cpp">servers/rendering/renderer_scene_occlusion_cull.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="visibility-range-lod" names="visibility\ range\ (lod)">
                <title>Visibility range (LOD)</title>
                <paragraph>Godot supports manually authored hierarchical level of detail (HLOD), with
                    distances specified by the user in the inspector.</paragraph>
                <paragraph>In RenderingSceneCull, the <literal>_scene_cull()</literal> and <literal>_render_scene()</literal> functions
                    are where most of the LOD determination happens. Each viewport can render the
                    same mesh with different LODs (to allow for split screen rendering to look correct).</paragraph>
                <paragraph><strong>Visibility range C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_scene_cull.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_scene_cull.cpp">servers/rendering/renderer_scene_cull.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
            <section ids="automatic-mesh-lod" names="automatic\ mesh\ lod">
                <title>Automatic mesh LOD</title>
                <paragraph>The ImporterMesh class is used for the 3D mesh import workflow in the editor.
                    Its <literal>generate_lods()</literal> function handles generating using the
                    <reference name="meshoptimizer" refuri="https://meshoptimizer.org/">meshoptimizer</reference> library.</paragraph>
                <paragraph>LOD mesh generation also generates shadow meshes at the same time. These are
                    meshes that have their vertices welded regardless of smoothing and materials.
                    This is used to improve shadow rendering performance by lowering the vertex
                    throughput required to render shadows.</paragraph>
                <paragraph>The RenderingSceneCull class's <literal>_render_scene()</literal> function determines which
                    mesh LOD should be used when rendering. Each viewport can render the
                    same mesh with different LODs (to allow for split screen rendering to look correct).</paragraph>
                <paragraph>The mesh LOD is automatically chosen based on a screen coverage metric. This
                    takes resolution and camera FOV changes into account without requiring user
                    intervention. The threshold multiplier can be adjusted in the project settings.</paragraph>
                <paragraph>To improve performance, shadow rendering and reflection probe rendering also choose
                    their own mesh LOD thresholds (which can be different from the main scene rendering).</paragraph>
                <paragraph><strong>Mesh LOD generation on import C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="scene/resources/importer_mesh.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/scene/resources/importer_mesh.cpp">scene/resources/importer_mesh.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
                <paragraph><strong>Mesh LOD determination C++ code:</strong></paragraph>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="servers/rendering/renderer_scene_cull.cpp" refuri="https://github.com/godotengine/godot/blob/4.2/servers/rendering/renderer_scene_cull.cpp">servers/rendering/renderer_scene_cull.cpp</reference></paragraph>
                    </list_item>
                </bullet_list>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
