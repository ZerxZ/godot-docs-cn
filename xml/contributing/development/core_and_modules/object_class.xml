<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.17.1 -->
<document source="/home/runner/work/godot-docs-cn/godot-docs-cn/godot-docs/docs/contributing/development/core_and_modules/object_class.rst" xmlns:c="https://www.sphinx-doc.org/" xmlns:changeset="https://www.sphinx-doc.org/" xmlns:citation="https://www.sphinx-doc.org/" xmlns:cpp="https://www.sphinx-doc.org/" xmlns:index="https://www.sphinx-doc.org/" xmlns:js="https://www.sphinx-doc.org/" xmlns:math="https://www.sphinx-doc.org/" xmlns:py="https://www.sphinx-doc.org/" xmlns:rst="https://www.sphinx-doc.org/" xmlns:std="https://www.sphinx-doc.org/">
    <target refid="doc-object-class"></target>
    <section ids="object-class doc-object-class" names="object\ class object\ 类 doc_object_class">
        <title>Object 类</title>
        <seealso>
            <paragraph>本页介绍了Godot中对象的C++实现. 寻找Object类参考？ <reference internal="True" refuri="../../../classes/class_object#class-object"><inline classes="std std-ref">请看这里.</inline></reference></paragraph>
        </seealso>
        <section ids="general-definition" names="general\ definition 一般定义">
            <title>一般定义</title>
            <paragraph><reference internal="True" refuri="../../../classes/class_object#class-object"><inline classes="std std-ref">Object</inline></reference> 几乎是一切的基类。Godot 中的大多数类都直接或间接继承自它。Object 提供了反射和可编辑的属性，只需要一个宏就可以声明属性，就像这样：</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">class CustomObject : public Object {

    GDCLASS(CustomObject, Object); // this is required to inherit
};</literal_block>
            <paragraph>这就为 Object 添加了许多功能。例如：</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">obj = memnew(CustomObject);
print_line("Object class: ", obj-&gt;get_class()); // print object class

obj2 = Object::cast_to&lt;OtherClass&gt;(obj); // converting between classes, this also works without RTTI enabled.</literal_block>
            <section dupnames="references:" ids="references" names="参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/object/object.h" refuri="https://github.com/godotengine/godot/blob/master/core/object/object.h">core/object/object.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="registering-an-object" names="registering\ an\ object 注册对象">
            <title>注册对象</title>
            <paragraph>ClassDB 是一个静态类，其中包含从 Object 继承的所有已注册类的完整列表，以及对其所有方法属性和整数常量的动态绑定。</paragraph>
            <paragraph>通过以下调用来注册类：</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">ClassDB::register_class&lt;MyCustomClass&gt;()</literal_block>
            <paragraph>注册它将允许通过脚本、代码实例化类，或在反序列化时再次创建它们。</paragraph>
            <paragraph>注册为虚是相同的，但它不能实例化。</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">ClassDB::register_virtual_class&lt;MyCustomClass&gt;()</literal_block>
            <paragraph>Object 派生类可以重写静态函数 <literal>static void _bind_methods()</literal>。当类被注册时，将调用此静态函数来注册所有对象方法、属性、常量等。它只被调用一次。如果 Object 派生类已实例化但尚未注册，则它将自动注册为虚。</paragraph>
            <paragraph>在 <literal>_bind_methods</literal> 里面, 有几件事可以做. 注册函数是一个:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">ClassDB::bind_method(D_METHOD("methodname", "arg1name", "arg2name", "arg3name"), &amp;MyCustomType::method);</literal_block>
            <paragraph>Default values for arguments can be passed as parameters at the end:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">ClassDB::bind_method(D_METHOD("methodname", "arg1name", "arg2name", "arg3name"), &amp;MyCustomType::method, DEFVAL(-1), DEFVAL(-2)); // Default values for arg2name (-1) and arg3name (-2).</literal_block>
            <paragraph>Default values must be provided in the same order as they are declared,
                skipping required arguments and then providing default values for the optional ones.
                This matches the syntax for declaring methods in C++.</paragraph>
            <paragraph><literal>D_METHOD</literal> 是一个宏, 它将 <literal>methodname</literal> 转换为StringName以提高效率. 参数名称用于自我检查, 但在发布时进行编译时, 宏会忽略它们, 因此未使用字符串从而对其进行了优化.</paragraph>
            <paragraph>有关更多示例, 请查看Control或Object的 <literal>_bind_methods</literal> .</paragraph>
            <paragraph>如果只是添加不希望被彻底记录的模块和功能, 可以安全地忽略 <literal>D_METHOD()</literal> 宏, 并且为了简洁起见, 可以传递传递名称的字符串.</paragraph>
            <section dupnames="references:" ids="id1" names="参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/object/class_db.h" refuri="https://github.com/godotengine/godot/blob/master/core/object/class_db.h">core/object/class_db.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="constants" names="constants 常量">
            <title>常量</title>
            <paragraph>类通常有枚举, 例如:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">enum SomeMode {
   MODE_FIRST,
   MODE_SECOND
};</literal_block>
            <paragraph>For these to work when binding to methods, the enum must be declared
                convertible to int. A macro is provided to help with this:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">VARIANT_ENUM_CAST(MyClass::SomeMode); // now functions that take SomeMode can be bound.</literal_block>
            <paragraph>常量也可以绑定在 <literal>_bind_methods</literal> 中, 通过使用:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">BIND_CONSTANT(MODE_FIRST);
BIND_CONSTANT(MODE_SECOND);</literal_block>
        </section>
        <section ids="properties-set-get" names="properties\ (set/get) 属性（设置/获取）">
            <title>属性（设置/获取）</title>
            <paragraph>对象导出属性, 这些属性可用于以下用途:</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>序列化和反序列化对象.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>为Object派生类创建可编辑值列表.</paragraph>
                </list_item>
            </bullet_list>
            <paragraph>Properties are usually defined by the PropertyInfo() class and
                constructed as:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">PropertyInfo(type, name, hint, hint_string, usage_flags)</literal_block>
            <paragraph>例如：</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">PropertyInfo(Variant::INT, "amount", PROPERTY_HINT_RANGE, "0,49,1", PROPERTY_USAGE_EDITOR)</literal_block>
            <paragraph>This is an integer property named "amount". The hint is a range, and the range
                goes from 0 to 49 in steps of 1 (integers). It is only usable for the editor
                (editing the value visually) but won't be serialized.</paragraph>
            <paragraph>另一个示例:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">PropertyInfo(Variant::STRING, "modes", PROPERTY_HINT_ENUM, "Enabled,Disabled,Turbo")</literal_block>
            <paragraph>这是一个字符串属性, 可以接受任何字符串, 但编辑器只允许定义的提示字符串. 由于未指定使用标志, 因此默认值为 <literal>PROPERTY_USAGE_STORAGE</literal> 和 <literal>PROPERTY_USAGE_EDITOR</literal>.</paragraph>
            <paragraph>在object.h中有很多提示和用法标记, 请对其进行检查.</paragraph>
            <paragraph>属性也可以像C#属性一样工作, 并且可以使用索引从脚本访问, 但通常不鼓励这种用法, 因为使用函数是易读性的首选. 许多属性也与类别绑定, 例如 <literal>动画/帧</literal>, 除非使用运算符 <literal>[]</literal>, 否则也无法建立索引.</paragraph>
            <paragraph>从 <literal>_bind_methods()</literal> 开始, 只要存在set/get函数, 就可以创建和绑定属性. 例如:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">ADD_PROPERTY(PropertyInfo(Variant::INT, "amount"), "set_amount", "get_amount")</literal_block>
            <paragraph>这将使用setter和getter创建属性.</paragraph>
            <target refid="doc-binding-properties-using-set-get-property-list"></target>
        </section>
        <section ids="binding-properties-using-set-get-get-property-list doc-binding-properties-using-set-get-property-list" names="binding\ properties\ using\ _set/_get/_get_property_list 使用\ _set/_get/_get_property_list\ 绑定属性 doc_binding_properties_using_set_get_property_list">
            <title>使用 <literal>_set</literal>/<literal>_get</literal>/<literal>_get_property_list</literal> 绑定属性</title>
            <paragraph>当需要更大的灵活性时(即在上下文中添加或删除属性), 存在另一种创建属性的方法.</paragraph>
            <paragraph>可以在 Object 派生类中重写以下函数，它们不是虚函数，不要将它们设置为虚，它们会在每次重写时调用，而之前的函数不会失效（多级调用）。</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">protected:
     void _get_property_list(List&lt;PropertyInfo&gt; *r_props) const;      // return list of properties
     bool _get(const StringName &amp;p_property, Variant &amp;r_value) const; // return true if property was found
     bool _set(const StringName &amp;p_property, const Variant &amp;p_value); // return true if property was found</literal_block>
            <paragraph>由于 <literal>p_property</literal> 必须按顺序与所需的名称进行比较, 因此效率也较低.</paragraph>
        </section>
        <section ids="dynamic-casting" names="dynamic\ casting 动态转型">
            <title>动态转型</title>
            <paragraph>Godot在Object派生类之间提供动态转换, 例如:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">void somefunc(Object *some_obj) {

     Button *button = Object::cast_to&lt;Button&gt;(some_obj);
}</literal_block>
            <paragraph>如果强制转换失败, 则返回NULL. 这个系统使用RTTI, 但是当RTTI被禁用时它也可以正常工作(虽然有点慢). 这在二进制大小较小的平台上非常有用, 例如HTML5或游戏主机(具有较小的内存占用).</paragraph>
        </section>
        <section ids="signals" names="signals 信号">
            <title>信号</title>
            <paragraph>Objects can have a set of signals defined (similar to Delegates in other
                languages). This example shows how to connect to them:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">obj-&gt;connect(&lt;signal&gt;, target_instance, target_method)
// for example:
obj-&gt;connect("enter_tree", this, "_node_entered_tree")</literal_block>
            <paragraph><literal>_node_entered_tree</literal> 方法必须使用 <literal>ClassDB::bind_method</literal> (前面解释过)注册到类.</paragraph>
            <paragraph>使用 <literal>ADD_SIGNAL</literal> 宏在 <literal>_bind_methods</literal> 中添加信号到类中, 例如:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">ADD_SIGNAL(MethodInfo("been_killed"))</literal_block>
        </section>
        <section ids="notifications" names="notifications 通知">
            <title>通知</title>
            <paragraph>All objects in Godot have a <reference internal="True" refuri="../../../classes/class_object#class-object-private-method-notification"><inline classes="std std-ref">_notification</inline></reference>
                method that allows it to respond to engine level callbacks that may relate to it.
                More information can be found on the <reference internal="True" refuri="../../../tutorials/best_practices/godot_notifications#doc-godot-notifications"><inline classes="std std-ref">Godot 通知</inline></reference> page.</paragraph>
        </section>
        <section ids="id2" names="references 参考">
            <title>参考</title>
            <paragraph><reference internal="True" refuri="../../../classes/class_refcounted#class-refcounted"><inline classes="std std-ref">RefCounted</inline></reference> inherits from Object and holds a
                reference count. It is the base for reference counted object types.
                Declaring them must be done using Ref&lt;&gt; template. For example:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">class MyReference: public RefCounted {
    GDCLASS(MyReference, RefCounted);
};

Ref&lt;MyReference&gt; myref(memnew(MyReference));</literal_block>
            <paragraph><literal>myref</literal> 进行了引用计数。当没有其他 Ref&lt;&gt; 模板指向它时，它将被释放。</paragraph>
            <section dupnames="references:" ids="id3" names="参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/object/reference.h" refuri="https://github.com/godotengine/godot/blob/master/core/object/ref_counted.h">core/object/reference.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="resources" names="resources 资源">
            <title>资源</title>
            <paragraph><reference internal="True" refuri="../../../classes/class_resource#class-resource"><inline classes="std std-ref">Resource</inline></reference> inherits from Reference, so all resources
                are reference counted. Resources can optionally contain a path, which
                reference a file on disk. This can be set with <literal>resource.set_path(path)</literal>,
                though this is normally done by the resource loader. No two different
                resources can have the same path; attempting to do so will result in an error.</paragraph>
            <paragraph>资源也可以没有路径.</paragraph>
            <section dupnames="references:" ids="id4" names="参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/io/resource.h" refuri="https://github.com/godotengine/godot/blob/master/core/io/resource.h">core/io/resource.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="resource-loading" names="resource\ loading 资源加载">
            <title>资源加载</title>
            <paragraph>可以使用ResourceLoader API加载资源, 如下所示:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">Ref&lt;Resource&gt; res = ResourceLoader::load("res://someresource.res")</literal_block>
            <paragraph>如果先前已加载对该资源的引用并且该引用在内存中, 则资源加载器将返回该引用. 这意味着只能同时从磁盘上引用的文件加载一个资源.</paragraph>
            <bullet_list bullet="-">
                <list_item>
                    <paragraph>resourceinteractiveloader(TODO)</paragraph>
                </list_item>
            </bullet_list>
            <section dupnames="references:" ids="id5" names="参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/io/resource_loader.h" refuri="https://github.com/godotengine/godot/blob/master/core/io/resource_loader.h">core/io/resource_loader.h</reference></paragraph>
                    </list_item>
                </bullet_list>
            </section>
        </section>
        <section ids="resource-saving" names="resource\ saving 资源保存">
            <title>资源保存</title>
            <paragraph>可以使用资源保存器API保存资源:</paragraph>
            <literal_block force="False" highlight_args="{}" language="cpp" linenos="False" xml:space="preserve">ResourceSaver::save("res://someresource.res", instance)</literal_block>
            <paragraph>The instance will be saved, and sub resources that have a path to a file will
                be saved as a reference to that resource. Sub resources without a path will
                be bundled with the saved resource and assigned sub-IDs, like
                <literal>res://someresource.res::1</literal>. This also helps to cache them when loaded.</paragraph>
            <section dupnames="references:" ids="id6" names="参考：">
                <title>参考：</title>
                <bullet_list bullet="-">
                    <list_item>
                        <paragraph><reference name="core/io/resource_saver.h" refuri="https://github.com/godotengine/godot/blob/master/core/io/resource_saver.h">core/io/resource_saver.h</reference></paragraph>
                    </list_item>
                </bullet_list>
                <substitution_definition names="weblate_widget"><reference refuri="https://hosted.weblate.org/engage/godot-engine/zh_CN/?utm_source=widget"><image alt="翻译状态" candidates="{'?': 'https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png'}" height="66" uri="https://hosted.weblate.org/widgets/godot-engine/zh_CN/godot-docs/287x66-white.png" width="287"></image></reference></substitution_definition>
            </section>
        </section>
    </section>
</document>
