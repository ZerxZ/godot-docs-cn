:github_url: hide

.. DO NOT EDIT THIS FILE!!!
.. Generated automatically from Godot engine sources.
.. Generator: https://github.com/godotengine/godot/tree/4.2/doc/tools/make_rst.py.
.. XML source: https://github.com/godotengine/godot/tree/4.2/doc/classes/AESContext.xml.

.. _class_AESContext:

AESContext
==========

**继承：** :ref:`RefCounted<class_RefCounted>` **<** :ref:`Object<class_Object>`

提供对原始数据的 AES 加密/解密的访问。

.. rst-class:: classref-introduction-group

描述
----

这个类存放的是进行 AES（Advanced Encryption Standard，高级加密标准）加解密所需的上下文信息。支持 AES-ECB 和 AES-CBC 两种模式。


.. tabs::

 .. code-tab:: gdscript

    extends Node
    
    var aes = AESContext.new()
    
    func _ready():
        var key = "My secret key!!!" # 密钥必须是 16 或 32 字节。
        var data = "My secret text!!" # 数据大小必须是 16 字节的倍数，需要时添加补白。
        # ECB 加密
        aes.start(AESContext.MODE_ECB_ENCRYPT, key.to_utf8_buffer())
        var encrypted = aes.update(data.to_utf8_buffer())
        aes.finish()
        # ECB 解密
        aes.start(AESContext.MODE_ECB_DECRYPT, key.to_utf8_buffer())
        var decrypted = aes.update(encrypted)
        aes.finish()
        # ECB 校验
        assert(decrypted == data.to_utf8_buffer())
    
        var iv = "My secret iv!!!!" # IV 必须是 16 字节。
        # CBC 加密
        aes.start(AESContext.MODE_CBC_ENCRYPT, key.to_utf8_buffer(), iv.to_utf8_buffer())
        encrypted = aes.update(data.to_utf8_buffer())
        aes.finish()
        # CBC 解密
        aes.start(AESContext.MODE_CBC_DECRYPT, key.to_utf8_buffer(), iv.to_utf8_buffer())
        decrypted = aes.update(encrypted)
        aes.finish()
        # CBC 校验
        assert(decrypted == data.to_utf8_buffer())

 .. code-tab:: csharp

    using Godot;
    using System.Diagnostics;
    
    public partial class MyNode : Node
    {
        private AesContext _aes = new AesContext();
    
        public override void _Ready()
        {
            string key = "My secret key!!!"; // 密钥必须是 16 或 32 字节。
            string data = "My secret text!!"; // 数据大小必须是 16 字节的倍数，需要时添加补白。
            // ECB 加密
            _aes.Start(AesContext.Mode.EcbEncrypt, key.ToUtf8Buffer());
            byte[] encrypted = _aes.Update(data.ToUtf8Buffer());
            _aes.Finish();
            // ECB 解密
            _aes.Start(AesContext.Mode.EcbDecrypt, key.ToUtf8Buffer());
            byte[] decrypted = _aes.Update(encrypted);
            _aes.Finish();
            // ECB 校验
            Debug.Assert(decrypted == data.ToUtf8Buffer());
    
            string iv = "My secret iv!!!!"; // IV 必须是 16 字节。
            // CBC 加密
            _aes.Start(AesContext.Mode.EcbEncrypt, key.ToUtf8Buffer(), iv.ToUtf8Buffer());
            encrypted = _aes.Update(data.ToUtf8Buffer());
            _aes.Finish();
            // CBC 解密
            _aes.Start(AesContext.Mode.EcbDecrypt, key.ToUtf8Buffer(), iv.ToUtf8Buffer());
            decrypted = _aes.Update(encrypted);
            _aes.Finish();
            // CBC 校验
            Debug.Assert(decrypted == data.ToUtf8Buffer());
        }
    }



.. rst-class:: classref-reftable-group

方法
----

.. table::
   :widths: auto

   +-----------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | void                                          | :ref:`finish<class_AESContext_method_finish>` **(** **)**                                                                                                                                                             |
   +-----------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PackedByteArray<class_PackedByteArray>` | :ref:`get_iv_state<class_AESContext_method_get_iv_state>` **(** **)**                                                                                                                                                 |
   +-----------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Error<enum_@GlobalScope_Error>`         | :ref:`start<class_AESContext_method_start>` **(** :ref:`Mode<enum_AESContext_Mode>` mode, :ref:`PackedByteArray<class_PackedByteArray>` key, :ref:`PackedByteArray<class_PackedByteArray>` iv=PackedByteArray() **)** |
   +-----------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PackedByteArray<class_PackedByteArray>` | :ref:`update<class_AESContext_method_update>` **(** :ref:`PackedByteArray<class_PackedByteArray>` src **)**                                                                                                           |
   +-----------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

枚举
----

.. _enum_AESContext_Mode:

.. rst-class:: classref-enumeration

enum **Mode**:

.. _class_AESContext_constant_MODE_ECB_ENCRYPT:

.. rst-class:: classref-enumeration-constant

:ref:`Mode<enum_AESContext_Mode>` **MODE_ECB_ENCRYPT** = ``0``

AES 电子密码簿加密模式。

.. _class_AESContext_constant_MODE_ECB_DECRYPT:

.. rst-class:: classref-enumeration-constant

:ref:`Mode<enum_AESContext_Mode>` **MODE_ECB_DECRYPT** = ``1``

AES 电子密码簿解密模式。

.. _class_AESContext_constant_MODE_CBC_ENCRYPT:

.. rst-class:: classref-enumeration-constant

:ref:`Mode<enum_AESContext_Mode>` **MODE_CBC_ENCRYPT** = ``2``

AES 密码封锁器链式加密模式。

.. _class_AESContext_constant_MODE_CBC_DECRYPT:

.. rst-class:: classref-enumeration-constant

:ref:`Mode<enum_AESContext_Mode>` **MODE_CBC_DECRYPT** = ``3``

AES 密码封锁器链式解密模式。

.. _class_AESContext_constant_MODE_MAX:

.. rst-class:: classref-enumeration-constant

:ref:`Mode<enum_AESContext_Mode>` **MODE_MAX** = ``4``

模式列举的最大值。

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

方法说明
--------

.. _class_AESContext_method_finish:

.. rst-class:: classref-method

void **finish** **(** **)**

关闭此 AES 上下文，以便可以再次启动它。见 :ref:`start<class_AESContext_method_start>`\ 。

.. rst-class:: classref-item-separator

----

.. _class_AESContext_method_get_iv_state:

.. rst-class:: classref-method

:ref:`PackedByteArray<class_PackedByteArray>` **get_iv_state** **(** **)**

获取此上下文的当前 IV 状态（调用 :ref:`update<class_AESContext_method_update>` 时会更新 IV）。通常不需要此函数。

\ **注意：**\ 仅当上下文以 :ref:`MODE_CBC_ENCRYPT<class_AESContext_constant_MODE_CBC_ENCRYPT>` 或 :ref:`MODE_CBC_DECRYPT<class_AESContext_constant_MODE_CBC_DECRYPT>` 开头时，此函数才有意义。

.. rst-class:: classref-item-separator

----

.. _class_AESContext_method_start:

.. rst-class:: classref-method

:ref:`Error<enum_@GlobalScope_Error>` **start** **(** :ref:`Mode<enum_AESContext_Mode>` mode, :ref:`PackedByteArray<class_PackedByteArray>` key, :ref:`PackedByteArray<class_PackedByteArray>` iv=PackedByteArray() **)**

在给定的 ``mode`` 中启动 AES 上下文。必须始终提供 16 或 32 字节的 ``key``\ ，而仅当 ``mode`` 为 :ref:`MODE_CBC_ENCRYPT<class_AESContext_constant_MODE_CBC_ENCRYPT>` 或 :ref:`MODE_CBC_DECRYPT<class_AESContext_constant_MODE_CBC_DECRYPT>` 时，才需要正好为 16 字节的 ``iv``\ （初始化向量）。

.. rst-class:: classref-item-separator

----

.. _class_AESContext_method_update:

.. rst-class:: classref-method

:ref:`PackedByteArray<class_PackedByteArray>` **update** **(** :ref:`PackedByteArray<class_PackedByteArray>` src **)**

运行此 AES 上下文所需的操作。将返回包含加密（或解密）给定 ``src`` 结果的 :ref:`PackedByteArray<class_PackedByteArray>` 。有关操作模式，请参阅 :ref:`start<class_AESContext_method_start>`\ 。

\ **注意：**\ ``src`` 的大小必须是 16 倍的倍数。如果需要，应用一些填充。

.. |virtual| replace:: :abbr:`virtual (本方法通常需要用户覆盖才能生效。)`
.. |const| replace:: :abbr:`const (本方法没有副作用。不会修改该实例的任何成员变量。)`
.. |vararg| replace:: :abbr:`vararg (本方法除了在此处描述的参数外，还能够继续接受任意数量的参数。)`
.. |constructor| replace:: :abbr:`constructor (本方法用于构造某个类型。)`
.. |static| replace:: :abbr:`static (调用本方法无需实例，所以可以直接使用类名调用。)`
.. |operator| replace:: :abbr:`operator (本方法描述的是使用本类型作为左操作数的有效操作符。)`
.. |bitfield| replace:: :abbr:`BitField (这个值是由下列标志构成的位掩码整数。)`
