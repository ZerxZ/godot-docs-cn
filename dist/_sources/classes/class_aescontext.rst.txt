:github_url: hide

.. DO NOT EDIT THIS FILE!!!
.. Generated automatically from Godot engine sources.
.. Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.
.. XML source: https://github.com/godotengine/godot/tree/master/doc/classes/AESContext.xml.

.. _class_AESContext:

AESContext
==========

**ç»§æ‰¿ï¼š** :ref:`RefCounted<class_RefCounted>` **<** :ref:`Object<class_Object>`

æä¾›å¯¹åŸå§‹æ•°æ®çš„ AES åŠ å¯†/è§£å¯†çš„è®¿é—®ã€‚

.. rst-class:: classref-introduction-group

æè¿°
----

è¿™ä¸ªç±»å­˜æ”¾çš„æ˜¯è¿›è¡Œ AESï¼ˆAdvanced Encryption Standardï¼Œé«˜çº§åŠ å¯†æ ‡å‡†ï¼‰åŠ è§£å¯†æ‰€éœ€çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ã€‚æ”¯æŒ AES-ECB å’Œ AES-CBC ä¸¤ç§æ¨¡å¼ã€‚


.. tabs::

 .. code-tab:: gdscript

    extends Node
    
    var aes = AESContext.new()
    
    func _ready():
        var key = "My secret key!!!" # å¯†é’¥å¿…é¡»æ˜¯ 16 æˆ– 32 å­—èŠ‚ã€‚
        var data = "My secret text!!" # æ•°æ®å¤§å°å¿…é¡»æ˜¯ 16 å­—èŠ‚çš„å€æ•°ï¼Œéœ€è¦æ—¶æ·»åŠ è¡¥ç™½ã€‚
        # ECB åŠ å¯†
        aes.start(AESContext.MODE_ECB_ENCRYPT, key.to_utf8_buffer())
        var encrypted = aes.update(data.to_utf8_buffer())
        aes.finish()
        # ECB è§£å¯†
        aes.start(AESContext.MODE_ECB_DECRYPT, key.to_utf8_buffer())
        var decrypted = aes.update(encrypted)
        aes.finish()
        # ECB æ ¡éªŒ
        assert(decrypted == data.to_utf8_buffer())
    
        var iv = "My secret iv!!!!" # IV å¿…é¡»æ˜¯ 16 å­—èŠ‚ã€‚
        # CBC åŠ å¯†
        aes.start(AESContext.MODE_CBC_ENCRYPT, key.to_utf8_buffer(), iv.to_utf8_buffer())
        encrypted = aes.update(data.to_utf8_buffer())
        aes.finish()
        # CBC è§£å¯†
        aes.start(AESContext.MODE_CBC_DECRYPT, key.to_utf8_buffer(), iv.to_utf8_buffer())
        decrypted = aes.update(encrypted)
        aes.finish()
        # CBC æ ¡éªŒ
        assert(decrypted == data.to_utf8_buffer())

 .. code-tab:: csharp

    using Godot;
    using System.Diagnostics;
    
    public partial class MyNode : Node
    {
        private AesContext _aes = new AesContext();
    
        public override void _Ready()
        {
            string key = "My secret key!!!"; // å¯†é’¥å¿…é¡»æ˜¯ 16 æˆ– 32 å­—èŠ‚ã€‚
            string data = "My secret text!!"; // æ•°æ®å¤§å°å¿…é¡»æ˜¯ 16 å­—èŠ‚çš„å€æ•°ï¼Œéœ€è¦æ—¶æ·»åŠ è¡¥ç™½ã€‚
            // ECB åŠ å¯†
            _aes.Start(AesContext.Mode.EcbEncrypt, key.ToUtf8Buffer());
            byte[] encrypted = _aes.Update(data.ToUtf8Buffer());
            _aes.Finish();
            // ECB è§£å¯†
            _aes.Start(AesContext.Mode.EcbDecrypt, key.ToUtf8Buffer());
            byte[] decrypted = _aes.Update(encrypted);
            _aes.Finish();
            // ECB æ ¡éªŒ
            Debug.Assert(decrypted == data.ToUtf8Buffer());
    
            string iv = "My secret iv!!!!"; // IV å¿…é¡»æ˜¯ 16 å­—èŠ‚ã€‚
            // CBC åŠ å¯†
            _aes.Start(AesContext.Mode.EcbEncrypt, key.ToUtf8Buffer(), iv.ToUtf8Buffer());
            encrypted = _aes.Update(data.ToUtf8Buffer());
            _aes.Finish();
            // CBC è§£å¯†
            _aes.Start(AesContext.Mode.EcbDecrypt, key.ToUtf8Buffer(), iv.ToUtf8Buffer());
            decrypted = _aes.Update(encrypted);
            _aes.Finish();
            // CBC æ ¡éªŒ
            Debug.Assert(decrypted == data.ToUtf8Buffer());
        }
    }



.. rst-class:: classref-reftable-group

æ–¹æ³•
----

.. table::
   :widths: auto

   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | |void|                                        | :ref:`finish<class_AESContext_method_finish>`\ (\ )                                                                                                                                                                      |
   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PackedByteArray<class_PackedByteArray>` | :ref:`get_iv_state<class_AESContext_method_get_iv_state>`\ (\ )                                                                                                                                                          |
   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Error<enum_@GlobalScope_Error>`         | :ref:`start<class_AESContext_method_start>`\ (\ mode\: :ref:`Mode<enum_AESContext_Mode>`, key\: :ref:`PackedByteArray<class_PackedByteArray>`, iv\: :ref:`PackedByteArray<class_PackedByteArray>` = PackedByteArray()\ ) |
   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PackedByteArray<class_PackedByteArray>` | :ref:`update<class_AESContext_method_update>`\ (\ src\: :ref:`PackedByteArray<class_PackedByteArray>`\ )                                                                                                                 |
   +-----------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

æšä¸¾
----

.. _enum_AESContext_Mode:

.. rst-class:: classref-enumeration

enum **Mode**: :ref:`ğŸ”—<enum_AESContext_Mode>`

.. _class_AESContext_constant_MODE_ECB_ENCRYPT:

.. rst-class:: classref-enumeration-constant

:ref:`Mode<enum_AESContext_Mode>` **MODE_ECB_ENCRYPT** = ``0``

AES ç”µå­å¯†ç ç°¿åŠ å¯†æ¨¡å¼ã€‚

.. _class_AESContext_constant_MODE_ECB_DECRYPT:

.. rst-class:: classref-enumeration-constant

:ref:`Mode<enum_AESContext_Mode>` **MODE_ECB_DECRYPT** = ``1``

AES ç”µå­å¯†ç ç°¿è§£å¯†æ¨¡å¼ã€‚

.. _class_AESContext_constant_MODE_CBC_ENCRYPT:

.. rst-class:: classref-enumeration-constant

:ref:`Mode<enum_AESContext_Mode>` **MODE_CBC_ENCRYPT** = ``2``

AES å¯†ç å°é”å™¨é“¾å¼åŠ å¯†æ¨¡å¼ã€‚

.. _class_AESContext_constant_MODE_CBC_DECRYPT:

.. rst-class:: classref-enumeration-constant

:ref:`Mode<enum_AESContext_Mode>` **MODE_CBC_DECRYPT** = ``3``

AES å¯†ç å°é”å™¨é“¾å¼è§£å¯†æ¨¡å¼ã€‚

.. _class_AESContext_constant_MODE_MAX:

.. rst-class:: classref-enumeration-constant

:ref:`Mode<enum_AESContext_Mode>` **MODE_MAX** = ``4``

æ¨¡å¼åˆ—ä¸¾çš„æœ€å¤§å€¼ã€‚

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

æ–¹æ³•è¯´æ˜
--------

.. _class_AESContext_method_finish:

.. rst-class:: classref-method

|void| **finish**\ (\ ) :ref:`ğŸ”—<class_AESContext_method_finish>`

å…³é—­æ­¤ AES ä¸Šä¸‹æ–‡ï¼Œä»¥ä¾¿å¯ä»¥å†æ¬¡å¯åŠ¨å®ƒã€‚è§ :ref:`start<class_AESContext_method_start>`\ ã€‚

.. rst-class:: classref-item-separator

----

.. _class_AESContext_method_get_iv_state:

.. rst-class:: classref-method

:ref:`PackedByteArray<class_PackedByteArray>` **get_iv_state**\ (\ ) :ref:`ğŸ”—<class_AESContext_method_get_iv_state>`

è·å–æ­¤ä¸Šä¸‹æ–‡çš„å½“å‰ IV çŠ¶æ€ï¼ˆè°ƒç”¨ :ref:`update<class_AESContext_method_update>` æ—¶ä¼šæ›´æ–° IVï¼‰ã€‚é€šå¸¸ä¸éœ€è¦æ­¤å‡½æ•°ã€‚

\ **æ³¨æ„ï¼š**\ ä»…å½“ä¸Šä¸‹æ–‡ä»¥ :ref:`MODE_CBC_ENCRYPT<class_AESContext_constant_MODE_CBC_ENCRYPT>` æˆ– :ref:`MODE_CBC_DECRYPT<class_AESContext_constant_MODE_CBC_DECRYPT>` å¼€å¤´æ—¶ï¼Œæ­¤å‡½æ•°æ‰æœ‰æ„ä¹‰ã€‚

.. rst-class:: classref-item-separator

----

.. _class_AESContext_method_start:

.. rst-class:: classref-method

:ref:`Error<enum_@GlobalScope_Error>` **start**\ (\ mode\: :ref:`Mode<enum_AESContext_Mode>`, key\: :ref:`PackedByteArray<class_PackedByteArray>`, iv\: :ref:`PackedByteArray<class_PackedByteArray>` = PackedByteArray()\ ) :ref:`ğŸ”—<class_AESContext_method_start>`

åœ¨ç»™å®šçš„ ``mode`` ä¸­å¯åŠ¨ AES ä¸Šä¸‹æ–‡ã€‚å¿…é¡»å§‹ç»ˆæä¾› 16 æˆ– 32 å­—èŠ‚çš„ ``key``\ ï¼Œè€Œä»…å½“ ``mode`` ä¸º :ref:`MODE_CBC_ENCRYPT<class_AESContext_constant_MODE_CBC_ENCRYPT>` æˆ– :ref:`MODE_CBC_DECRYPT<class_AESContext_constant_MODE_CBC_DECRYPT>` æ—¶ï¼Œæ‰éœ€è¦æ­£å¥½ä¸º 16 å­—èŠ‚çš„ ``iv``\ ï¼ˆåˆå§‹åŒ–å‘é‡ï¼‰ã€‚

.. rst-class:: classref-item-separator

----

.. _class_AESContext_method_update:

.. rst-class:: classref-method

:ref:`PackedByteArray<class_PackedByteArray>` **update**\ (\ src\: :ref:`PackedByteArray<class_PackedByteArray>`\ ) :ref:`ğŸ”—<class_AESContext_method_update>`

è¿è¡Œæ­¤ AES ä¸Šä¸‹æ–‡æ‰€éœ€çš„æ“ä½œã€‚å°†è¿”å›åŒ…å«åŠ å¯†ï¼ˆæˆ–è§£å¯†ï¼‰ç»™å®š ``src`` ç»“æœçš„ :ref:`PackedByteArray<class_PackedByteArray>` ã€‚æœ‰å…³æ“ä½œæ¨¡å¼ï¼Œè¯·å‚é˜… :ref:`start<class_AESContext_method_start>`\ ã€‚

\ **æ³¨æ„ï¼š**\ ``src`` çš„å¤§å°å¿…é¡»æ˜¯ 16 å€çš„å€æ•°ã€‚å¦‚æœéœ€è¦ï¼Œåº”ç”¨ä¸€äº›å¡«å……ã€‚

.. |virtual| replace:: :abbr:`virtual (æœ¬æ–¹æ³•é€šå¸¸éœ€è¦ç”¨æˆ·è¦†ç›–æ‰èƒ½ç”Ÿæ•ˆã€‚)`
.. |const| replace:: :abbr:`const (æœ¬æ–¹æ³•æ— å‰¯ä½œç”¨ï¼Œä¸ä¼šä¿®æ”¹è¯¥å®ä¾‹çš„ä»»ä½•æˆå‘˜å˜é‡ã€‚)`
.. |vararg| replace:: :abbr:`vararg (æœ¬æ–¹æ³•é™¤äº†èƒ½æ¥å—åœ¨æ­¤å¤„æè¿°çš„å‚æ•°å¤–ï¼Œè¿˜èƒ½å¤Ÿç»§ç»­æ¥å—ä»»æ„æ•°é‡çš„å‚æ•°ã€‚)`
.. |constructor| replace:: :abbr:`constructor (æœ¬æ–¹æ³•ç”¨äºæ„é€ æŸä¸ªç±»å‹ã€‚)`
.. |static| replace:: :abbr:`static (è°ƒç”¨æœ¬æ–¹æ³•æ— éœ€å®ä¾‹ï¼Œå¯ç›´æ¥ä½¿ç”¨ç±»åè¿›è¡Œè°ƒç”¨ã€‚)`
.. |operator| replace:: :abbr:`operator (æœ¬æ–¹æ³•æè¿°çš„æ˜¯ä½¿ç”¨æœ¬ç±»å‹ä½œä¸ºå·¦æ“ä½œæ•°çš„æœ‰æ•ˆè¿ç®—ç¬¦ã€‚)`
.. |bitfield| replace:: :abbr:`BitField (è¿™ä¸ªå€¼æ˜¯ç”±ä¸‹åˆ—ä½æ ‡å¿—æ„æˆä½æ©ç çš„æ•´æ•°ã€‚)`
.. |void| replace:: :abbr:`void (æ— è¿”å›å€¼ã€‚)`
