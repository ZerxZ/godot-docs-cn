:github_url: hide

.. DO NOT EDIT THIS FILE!!!
.. Generated automatically from Godot engine sources.
.. Generator: https://github.com/godotengine/godot/tree/master/doc/tools/make_rst.py.
.. XML source: https://github.com/godotengine/godot/tree/master/doc/classes/DTLSServer.xml.

.. _class_DTLSServer:

DTLSServer
==========

**ç»§æ‰¿ï¼š** :ref:`RefCounted<class_RefCounted>` **<** :ref:`Object<class_Object>`

å®ç° DTLS æœåŠ¡å™¨çš„è¾…åŠ©ç±»ã€‚

.. rst-class:: classref-introduction-group

æè¿°
----

è¯¥ç±»ç”¨äºå­˜å‚¨ DTLS æœåŠ¡å™¨çš„çŠ¶æ€ã€‚åœ¨ :ref:`setup<class_DTLSServer_method_setup>` ä¹‹åï¼Œå®ƒå°†è¿æ¥çš„ :ref:`PacketPeerUDP<class_PacketPeerUDP>` è½¬æ¢ä¸º :ref:`PacketPeerDTLS<class_PacketPeerDTLS>`\ ï¼Œé€šè¿‡ :ref:`take_connection<class_DTLSServer_method_take_connection>` æ¥å—å®ƒä»¬ä½œä¸º DTLS å®¢æˆ·ç«¯ã€‚åœ¨åº•å±‚ï¼Œè¿™ä¸ªç±»ç”¨äºå­˜å‚¨æœåŠ¡å™¨çš„ DTLS çŠ¶æ€å’Œ cookieã€‚ä¸ºä»€ä¹ˆéœ€è¦çŠ¶æ€å’Œ cookie çš„åŸå› ä¸åœ¨æœ¬æ–‡æ¡£çš„èŒƒå›´å†…ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªå¦‚ä½•ä½¿ç”¨å®ƒçš„å°ä¾‹å­ï¼š


.. tabs::

 .. code-tab:: gdscript

    # server_node.gd
    extends Node
    
    var dtls := DTLSServer.new()
    var server := UDPServer.new()
    var peers = []
    
    func _ready():
        server.listen(4242)
        var key = load("key.key") # ä½ çš„ç§é’¥ã€‚
        var cert = load("cert.crt") # ä½ çš„ X509 è¯ä¹¦ã€‚
        dtls.setup(key, cert)
    
    func _process(delta):
        while server.is_connection_available():
            var peer: PacketPeerUDP = server.take_connection()
            var dtls_peer: PacketPeerDTLS = dtls.take_connection(peer)
            if dtls_peer.get_status() != PacketPeerDTLS.STATUS_HANDSHAKING:
                continue # ç”±äº cookie äº¤æ¢ï¼Œ50% çš„è¿æ¥ä¼šå¤±è´¥ï¼Œè¿™æ˜¯æ­£å¸¸ç°è±¡ã€‚
            print("å¯¹ç­‰ä½“å·²è¿æ¥ï¼")
            peers.append(dtls_peer)
    
        for p in peers:
            p.poll() # å¿…é¡»è½®è¯¢ä»¥æ›´æ–°çŠ¶æ€ã€‚
            if p.get_status() == PacketPeerDTLS.STATUS_CONNECTED:
                while p.get_available_packet_count() > 0:
                    print("ä»å®¢æˆ·ç«¯æ”¶åˆ°æ¶ˆæ¯ï¼š%s" % p.get_packet().get_string_from_utf8())
                    p.put_packet("ä½ å¥½ DTLS å®¢æˆ·ç«¯".to_utf8_buffer())

 .. code-tab:: csharp

    // ServerNode.cs
    using Godot;
    
    public partial class ServerNode : Node
    {
        private DtlsServer _dtls = new DtlsServer();
        private UdpServer _server = new UdpServer();
        private Godot.Collections.Array<PacketPeerDtls> _peers = new Godot.Collections.Array<PacketPeerDtls>();
    
        public override void _Ready()
        {
            _server.Listen(4242);
            var key = GD.Load<CryptoKey>("key.key"); // ä½ çš„ç§é’¥ã€‚
            var cert = GD.Load<X509Certificate>("cert.crt"); // ä½ çš„ X509 è¯ä¹¦ã€‚
            _dtls.Setup(key, cert);
        }
    
        public override void _Process(double delta)
        {
            while (Server.IsConnectionAvailable())
            {
                PacketPeerUdp peer = _server.TakeConnection();
                PacketPeerDtls dtlsPeer = _dtls.TakeConnection(peer);
                if (dtlsPeer.GetStatus() != PacketPeerDtls.Status.Handshaking)
                {
                    continue; // ç”±äº cookie äº¤æ¢ï¼Œ50% çš„è¿æ¥ä¼šå¤±è´¥ï¼Œè¿™æ˜¯æ­£å¸¸ç°è±¡ã€‚
                }
                GD.Print("å¯¹ç­‰ä½“å·²è¿æ¥ï¼");
                _peers.Add(dtlsPeer);
            }
    
            foreach (var p in _peers)
            {
                p.Poll(); // å¿…é¡»è½®è¯¢ä»¥æ›´æ–°çŠ¶æ€ã€‚
                if (p.GetStatus() == PacketPeerDtls.Status.Connected)
                {
                    while (p.GetAvailablePacketCount() > 0)
                    {
                        GD.Print($"ä»å®¢æˆ·ç«¯æ”¶åˆ°æ¶ˆæ¯ï¼š{p.GetPacket().GetStringFromUtf8()}");
                        p.PutPacket("ä½ å¥½ DTLS å®¢æˆ·ç«¯".ToUtf8Buffer());
                    }
                }
            }
        }
    }




.. tabs::

 .. code-tab:: gdscript

    # client_node.gd
    extends Node
    
    var dtls := PacketPeerDTLS.new()
    var udp := PacketPeerUDP.new()
    var connected = false
    
    func _ready():
        udp.connect_to_host("127.0.0.1", 4242)
        dtls.connect_to_peer(udp, false) # ç”Ÿäº§ç¯å¢ƒä¸­è¯·ä½¿ç”¨ true è¿›è¡Œè¯ä¹¦æ ¡éªŒï¼
    
    func _process(delta):
        dtls.poll()
        if dtls.get_status() == PacketPeerDTLS.STATUS_CONNECTED:
            if !connected:
                # å°è¯•è”ç³»æœåŠ¡å™¨
                dtls.put_packet("å›åº”æ˜¯â€¦ 42ï¼".to_utf8_buffer())
            while dtls.get_available_packet_count() > 0:
                print("å·²è¿æ¥ï¼š%s" % dtls.get_packet().get_string_from_utf8())
                connected = true

 .. code-tab:: csharp

    // ClientNode.cs
    using Godot;
    using System.Text;
    
    public partial class ClientNode : Node
    {
        private PacketPeerDtls _dtls = new PacketPeerDtls();
        private PacketPeerUdp _udp = new PacketPeerUdp();
        private bool _connected = false;
    
        public override void _Ready()
        {
            _udp.ConnectToHost("127.0.0.1", 4242);
            _dtls.ConnectToPeer(_udp, validateCerts: false); // ç”Ÿäº§ç¯å¢ƒä¸­è¯·ä½¿ç”¨ true è¿›è¡Œè¯ä¹¦æ ¡éªŒï¼
        }
    
        public override void _Process(double delta)
        {
            _dtls.Poll();
            if (_dtls.GetStatus() == PacketPeerDtls.Status.Connected)
            {
                if (!_connected)
                {
                    // å°è¯•è”ç³»æœåŠ¡å™¨
                    _dtls.PutPacket("å›åº”æ˜¯â€¦ 42ï¼".ToUtf8Buffer());
                }
                while (_dtls.GetAvailablePacketCount() > 0)
                {
                    GD.Print($"å·²è¿æ¥ï¼š{_dtls.GetPacket().GetStringFromUtf8()}");
                    _connected = true;
                }
            }
        }
    }



.. rst-class:: classref-reftable-group

æ–¹æ³•
----

.. table::
   :widths: auto

   +---------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------+
   | :ref:`Error<enum_@GlobalScope_Error>`       | :ref:`setup<class_DTLSServer_method_setup>`\ (\ server_options\: :ref:`TLSOptions<class_TLSOptions>`\ )                     |
   +---------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------+
   | :ref:`PacketPeerDTLS<class_PacketPeerDTLS>` | :ref:`take_connection<class_DTLSServer_method_take_connection>`\ (\ udp_peer\: :ref:`PacketPeerUDP<class_PacketPeerUDP>`\ ) |
   +---------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------+

.. rst-class:: classref-section-separator

----

.. rst-class:: classref-descriptions-group

æ–¹æ³•è¯´æ˜
--------

.. _class_DTLSServer_method_setup:

.. rst-class:: classref-method

:ref:`Error<enum_@GlobalScope_Error>` **setup**\ (\ server_options\: :ref:`TLSOptions<class_TLSOptions>`\ ) :ref:`ğŸ”—<class_DTLSServer_method_setup>`

è®¾ç½® DTLS æœåŠ¡å™¨ä»¥ä½¿ç”¨ç»™å®šçš„ ``server_options``\ ã€‚è¯·å‚é˜… :ref:`TLSOptions.server<class_TLSOptions_method_server>`\ ã€‚

.. rst-class:: classref-item-separator

----

.. _class_DTLSServer_method_take_connection:

.. rst-class:: classref-method

:ref:`PacketPeerDTLS<class_PacketPeerDTLS>` **take_connection**\ (\ udp_peer\: :ref:`PacketPeerUDP<class_PacketPeerUDP>`\ ) :ref:`ğŸ”—<class_DTLSServer_method_take_connection>`

å°è¯•ä¸ç»™å®š ``udp_peer`` å¯åŠ¨ DTLS æ¡æ‰‹ï¼Œå¿…é¡»å·²è¿æ¥åˆ°è¯¥ ``udp_peer``\ ï¼ˆè¯·å‚é˜… :ref:`PacketPeerUDP.connect_to_host<class_PacketPeerUDP_method_connect_to_host>`\ ï¼‰ã€‚

\ **æ³¨æ„ï¼š**\ å¿…é¡»æ£€æŸ¥è¿”å›çš„ PacketPeerUDP çš„çŠ¶æ€æ˜¯å¦ä¸º :ref:`PacketPeerDTLS.STATUS_HANDSHAKING<class_PacketPeerDTLS_constant_STATUS_HANDSHAKING>`\ ï¼Œå› ä¸ºæ­£å¸¸æƒ…å†µä¸‹ï¼Œ50% çš„æ–°è¿æ¥ä¼šå› ä¸º cookie äº¤æ¢è€Œæ— æ•ˆã€‚

.. |virtual| replace:: :abbr:`virtual (æœ¬æ–¹æ³•é€šå¸¸éœ€è¦ç”¨æˆ·è¦†ç›–æ‰èƒ½ç”Ÿæ•ˆã€‚)`
.. |const| replace:: :abbr:`const (æœ¬æ–¹æ³•æ— å‰¯ä½œç”¨ï¼Œä¸ä¼šä¿®æ”¹è¯¥å®ä¾‹çš„ä»»ä½•æˆå‘˜å˜é‡ã€‚)`
.. |vararg| replace:: :abbr:`vararg (æœ¬æ–¹æ³•é™¤äº†èƒ½æ¥å—åœ¨æ­¤å¤„æè¿°çš„å‚æ•°å¤–ï¼Œè¿˜èƒ½å¤Ÿç»§ç»­æ¥å—ä»»æ„æ•°é‡çš„å‚æ•°ã€‚)`
.. |constructor| replace:: :abbr:`constructor (æœ¬æ–¹æ³•ç”¨äºæ„é€ æŸä¸ªç±»å‹ã€‚)`
.. |static| replace:: :abbr:`static (è°ƒç”¨æœ¬æ–¹æ³•æ— éœ€å®ä¾‹ï¼Œå¯ç›´æ¥ä½¿ç”¨ç±»åè¿›è¡Œè°ƒç”¨ã€‚)`
.. |operator| replace:: :abbr:`operator (æœ¬æ–¹æ³•æè¿°çš„æ˜¯ä½¿ç”¨æœ¬ç±»å‹ä½œä¸ºå·¦æ“ä½œæ•°çš„æœ‰æ•ˆè¿ç®—ç¬¦ã€‚)`
.. |bitfield| replace:: :abbr:`BitField (è¿™ä¸ªå€¼æ˜¯ç”±ä¸‹åˆ—ä½æ ‡å¿—æ„æˆä½æ©ç çš„æ•´æ•°ã€‚)`
.. |void| replace:: :abbr:`void (æ— è¿”å›å€¼ã€‚)`
